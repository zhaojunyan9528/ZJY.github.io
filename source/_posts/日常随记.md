---
title: 日常随记
tags:
  - 前端
categories:
  - - 笔记
    - Javascript
date: 2023-11-03 09:49:54
---

## 2023-11-03

### /sockjs-node/info?t=${时间戳}

当运行npm run dev启动项目后，在浏览器的network中会自动持续发送`/sockjs-node/info?t=${时间戳}`请求。

sockjs-node是什么？
sockjs-node是一个JavaScript库，提供跨浏览器的API，创建了一个低延迟、全双工的浏览器和web服务器之间的通道。
在项目运行后，会一直调用该接口。
SockJS是一个JavaScript库。提供类似于websocket的对象。其作用就是在开发环境下，保证我们在改完代码重写编译后，能够通知浏览器重新加载变更结果。

这里理解为这个库用来让浏览器和本地之间热更新通信的。

如果两个地址对接不上，或者更换wifi等都会报错：sockjs-node/info?t= net::ERR_CONNECTION_TIMED_OUT

需要关闭该请求可以找到node_modules/sockjs-client/dist/sockjs.js ，注释代码的第1603行： 

```js
  try {
    // self.xhr.send(payload); 注释掉该行
  } catch (e) {
    self.emit('finish', 0, '');
    self._cleanup(false);
  }
```

以上只在本地有效，重新安装依赖或者别的同事都需要重新修改，可添加脚本，当npm install后替换掉node_modules/sockjs-client/dist/sockjs.js该文件

1.在根目录下新建该文件lib/sockjs.js,拷贝node_modules/sockjs-client/dist/sockjs.js文件并注释掉1603行

2.在根目录下创建installSockjs.js文件，将node_modules对应文件替换为lib/sockjs.js文件

3.在package.json的scripts中添加脚本命令：

```json
"scripts": {
  ...
  "postinstall: node installSockjs.js"
}
```

4.最后npm install即可，但是这样作热更新没有了。

### postinstall干什么的？？？

postinstall是安装完某个包后自动执行的脚本。可以在package.json添加postinstall设置执行的脚本命令，帮我们做一些额外的处理，例如复制文件、创建目录、执行脚本、打印信息等。

例如：将 dist 目录下的所有文件复制到 public 目录下。

```json
"scripts:" {
  "postinstall": "cp -r dist/* public/"
}
```

### 数组扩展运算符

数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。

## 2023-11-22

### 事件循环

事件循环：浏览器的核心

进程：

何为进程：程序运行需要有他自己专有的内存空间，可以把这块内存空间简单的称为进程

每个应用至少有一个进程，进程之间相互独立，即使通信也要双方同意。

何为线程：
有了进程后，就可以运行程序，运行程序的称为线程。
一个进程至少有一个线程，所以在进程开启后会自动创建一个线程来运行代码，这个线程称为主线程。
如果程序需要同时运行多块代码，主线程会启动更多的线程来运行代码。所以一个进程可以包含多个线程。

浏览器有哪些进程和线程？

浏览器是一个多进程多线程的应用程序。

浏览器内部及其复杂，为了避免互相影响，减少崩溃的几率，启动浏览器后，会启动多个进程。

浏览器进程、网络进程、渲染进程 等

浏览器主要进程有：

浏览器进程：
负责界面显示、用户交互、子进程管理等，浏览器进程会开启多个线程执行任务。

网络进程：
负责加载网络资源。网络进程内部会开启多个线程来执行不同的网络任务。

渲染进程：
渲染进程开启后，会启动一个渲染主线程，主线程负责html、css、js代码。

默认情况下，浏览器为每一个标签页开启一个新的渲染进程，保证不同标签页互不影响。

事件循环发生在渲染主线程。

渲染主线程是如何工作的？

渲染主线程是浏览器最繁忙的线程，需要它处理的任务包括但不限于：

+ 解析html
+ 解析css
+ 计算样式
+ 布局
+ 处理图层
+ 每秒把页面画60次
+ 执行全局js代码
+ 处理事件监听函数
+ 执行定时器的回调函数
+ ...

渲染主线程如何调度任务呢？排队

1、最开始的时候，渲染主线程进入一个无限循环
2、每一次循环会检查事件队列（消息队列）是否有任务存在，如果有，取出第一个任务在主线程执行，执行完后进入下一个循环；如果没有则进入休眠
3、其他所有线程（包括其他进程的线程）可以随时向事件队列添加任务，新任务会添加到事件队列的末尾。在添加新任务时如果主线程处在休眠状态则会唤醒以继续循环拿取任务。

以上整个过程称为事件循环。

何为异步？

代码在执行过程中，会遇到无法立即处理的任务，比如：

+ 计时完成后需要执行的任务：setTimeout setInterval
+ 网络通信完成后需要执行的任务：xhr fetch
+ 用户操作后要执行的任务：addEventListener

如果让渲染主线程等待这些任务的时机到达，就会导致主线程阻塞，造成浏览器卡死。因此浏览器选择异步来解决问题。

比如：渲染主线程遇到计时器，通知计时线程去计时，结束该任务，继续循环从事件队列拿取任务，计时线程计时结束后将回调函数包装成任务放进事件队列末尾。

使用异步的方式，渲染主线程永不阻塞。

### 如何理解js中的异步？

js是一门单线程的语言，运行在浏览器的渲染主线程内，渲染主线程只有一个，承担很多任务，比如解析html、css、计算样式、布局、执行js代码等。如果使用同步的方式就有可能阻塞主线程，导致事件队列的其他任务不能执行，造成渲染主线程白白浪费，页面无法更新，给用户造成卡死现象。
所以浏览器使用异步的方式来避免。具体做法是某些任务发生时，如计时器、网络、事件监听，主线程交给其他线程去处理，自身立即结束任务，执行后续代码。当其他线程执行结束时，就将事先传递回调函数包装成任务加入到事件队列末尾，等待主线程调度执行。
在这种异步模式下，浏览器永不阻塞，最大限度的保证了单线程的流畅运行。

js为何会阻碍渲染？

```js
let h1 = document.getElementsByTagName('h1')[0]
let btn = document.getElementsByTagName('button')[0]
function delay(duration) {
  let start = Date.now()
  while(Date.now() - start < duration) {}
}
btn.onclick = function(e) {
  h1.textContent = 'hahah'
  console.log('onclick')
  delay(3000)
}
```

以上代码点击按钮时，会打印onclick，延时3秒后h1显示‘hahah’，因为delay方法占据主线程运行3秒，h1.textContent绘制需要事件队列排队等待，造成页面阻塞。

任务有优先级吗？
任务没有优先级，在队列中先进先出
但是事件队列是有优先级的。
根据w3c最新解释：

+ 每个任务都有一个类型，同一个类型的任务必须在同一个队列，不同类型的任务可以分属于不同的队列。再一次事件循环中，浏览器可以根据实际情况从不同的队列取出任务执行。
+ 浏览器必须有一个微队列，微队列中的任务优先于其他任务执行

随着浏览器的复杂度上升，w3c不再使用宏队列的说法

在目前chrome的实现中，至少包含以下队列：

+ 延时队列：用于存放计时器的回调任务，优先级【中】
+ 交互队列：用于存放用户操作后的回调任务，优先级【高】
+ 微队列：用户存放最快执行的任务，优先级【最高】

添加到微队列的方式主要是Promise、MutationObserver
例如：

```js
立即把一个函数添加到微队列
Promise.resolve().then(函数)
```

示例1：

```js
setTimeout(function() {
  console.log(1) // fn1
}, 0)
console.log(2)
```

输出： 2、1

主线程：全局js
微队列：
延时队列：fn1
交互队列：

解析：主线程执行全局js，遇到setTimeout，计时线程0秒后将fn1放入延时队列-》继续执行全局js-》输出2-》全局js结束，主线程空，微队列空，执行延时队列fn1-》输出1

示例2:

```js
function delay(duration) {
  let start = Date.now()
  while(Date.now() - start < duration) {}
}
setTimeout(() => {
  console.log(1)
}, 0)
delay()
console.log(2)
```

输出：等待3秒、2、1

解析：主线程执行全局js，遇到setTimeout，计时线程0秒后将fn1放入延时队列-》继续执行全局js-》执行delay函数3秒-》输出2-》全局js结束，主线程空，微队列空，执行延时队列fn1-》输出1

示例3:

```js
setTimeout(() => {
  console.log(1) // 回调fn1
}, 0)
Promise.resolve().then(function() {
  console.log(2) // 回调fn2
})
console.log(3)
```

输出：3、2、1

主线程：全局js
微队列：fn2
延时队列：fn1
交互队列：

解析：
  主线程执行全局js，遇到setTimeout，计时线程0秒后将fn1放入延时队列
  继续全局js执行，遇Promise，立即将fn2添加到微队列
  继续全局js，输出3
  全局js结束，主线程空，微队列不为空，执行fn2
  输出2，fn2结束，继续循环
  微队列空，延迟队列不为空，执行fn1
  输出1，fn1结束，继续循环

示例4:

```js
function a() {
  console.log(1)
  Promise.resolve().then(function() {
    console.log(2) // fn2
  })
}
setTimeout(() => { // fn3
  console.log(3)
  Promise.resolve().then(a) // fn(a)
}, 0)
Promise.resolve().then(function() {
  console.log(4) // fn4
})
console.log(5)
```

输出：5、4、3、1、2

主线程：全局js
微队列：fn4->fn(a)->fn2
延时队列：fn3
交互队列：

解析：
  主线程执行全局js，遇到setTimeout，计时线程0秒后将fn3放入延时队列
  继续全局js执行，遇Promise，立即将fn4添加到微队列
  继续全局js，输出5
  全局js结束，主线程空，微队列不为空，执行fn4
  输出4，结束任务，继续循环，微队列空，查询延时队列不为空
  执行fn3，输出3、遇Promise，立即将fn(a)添加到微队列，结束该任务，继续循环
  微队列不空，执行fn(a)，输出1，遇Promise，立即将fn2添加到微队列，结束该任务，继续循环
  微队列不空，执行fn2，输出2，结束该任务

示例5:

```js
function a() {
  console.log(1)
  Promise.resolve().then(function() {
    console.log(2) // fn2
  })
}
setTimeout(() => { 
  console.log(3) // fn3
}, 0)
Promise.resolve().then(a) // fn(a)
console.log(4)
```

输出：4、1、2、3

主线程：全局js
微队列：fn(a)->fn2
延时队列：fn3
交互队列：

解析：
  主线程执行全局js，遇到setTimeout，计时线程0秒后将fn3放入延时队列
  继续全局js执行，遇Promise，立即将fn(a)添加到微队列
  继续全局js，输出4
  全局js结束，主线程空，微队列不为空，执行fn(a)
  输出1，遇Promise，立即将fn2添加到微队列，结束该任务，继续循环
  微队列不空，执行fn2，输出2，结束该任务，继续循环
  微队列空，延时队列不空，执行fn3，输出3，结束该任务

阐述js的事件循环：

事件循环又叫做消息循环，是浏览器的渲染主线程的工作方式。

在chrome中开启一个无限循环，每次循环从队列中取出第一个任务执行，而其他线程只需要在合适的时机将任务添加到队列末尾。
过去把消息队列分为宏队列和微队列，这种说法无法满足复杂的浏览器环境，取而代之的是另一钟灵活的处理方式。

根据w3c官方解释，每个任务都有一个类型，同一个类型的任务必须在同一个队列，不同任务属于不同的队列。
不同的任务队列有不同的优先级，在一次事件循环中，浏览器自行决定选取哪一个队列的任务。但浏览器必须有一个微队列，微队列具有最高的优先级，必须优先调度执行。

### js中计时器能做到精准计时吗？

不能，因为：

+ 计算机硬件没有原子钟，无法做到精准计时
+ 操作系统的计时函数本身就有偏差，js计时器最终调用的是操作系统的函数，所以携带了偏差
+ 按照w3c的标准，浏览器实现计时器，嵌套超过5层，则会带有4毫秒的最小偏差，计时少于4毫秒又带来偏差
+ 受事件循环的影响，计时器的回调函数只能在主线程空闲时执行，因此带来偏差

单线程是异步产生的原因
事件循环是异步的实现方式

### 浏览器的渲染原理

当浏览器的网络线程收到HTML文档后，会产生一个渲染任务，并将其传递到渲染主线程的消息队列。
在事件循环机制下，渲染主线程取出渲染任务，开启渲染流程。

整个渲染流程分为多个阶段，分别是：HTML解析、样式计算、布局、分层、绘制、分块、光栅化、画。
每个阶段都有明确的输出，上一个阶段的输出是下一个阶段的输入。
这样，整个阶段就成为一段严密的流水线。

***HTML字符串-〉解析HTML-〉样式计算-〉布局-〉分层-〉绘制-〉分块-〉光栅化-〉画-〉像素信息***
渲染：将html字符串->像素信息

#### 1.解析HTML

**
解析过程中遇到css，解析css，遇到js解析js。为了提高效率，浏览器在解析前，会启动一个预解析的线程，率先下载HTML中外部的css文件和外部的js文件。
如果主线程解析到link位置，此时外部的css文件还没有解析下载好，主线程不会等待，继续后续HTML的解析。这是因为下载和解析css是在与解析线程中进行的。这就是css不会阻塞HTML解析的根本原因。
如果主线程解析道script位置，主线程会停止解析HTML，转而等待js文件下载好，并将全局代码解析完成后，才继续解析HTML。这是因为js代码可能会修改当前的DOM树，所以DOM生成必须暂停。这就是js会阻塞HMTL解析的根本原因。
第一步完成后，会生成CSSOM树和DOM树，内部样式、外部样式、内联样式、浏览器默认样式都会包含在CSSOM树。
**

渲染的第一步是解析HTMl，ParseHTML，产生DOM树（Document Object Model）和CSSOM树(css Object Model)

css样式包括：内部样式style，外部样式link，内联样式，浏览器默认样式
js修改style样式，docu.style = ''
js修改`<style>`和外部样式，document.styleSheets[0].addRule('div', 'border: 1px solid #f40')

解析HTML，遇到css代码怎么办？
为了提高效率，浏览器会启动一个预解析器率先下载和解析css，css不会阻塞解析HTML。

#### 2、样式计算- recalculate style

**
主线程遍历整个DOM树，依次为每一个节点计算出最终样式，computed style，
在这个过程中，很多预设值会变成绝对值，比如red会变成rgb(255, 0, 0); 相对单位会变成绝对单位，比如em会变成px。
这一步完成后，会得到一颗带样式的DOM树
**

getComputedStyle()获取最终样式

#### 3、布局-Layout

**
接下来是布局，布局完成后会得到布局树。
布局阶段会依次遍历DOM树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。
大部分时候，DOM树和布局树不是一一对应的。
比如dislay:none没有几何信息，因此不会生成到布局树中，又比如使用伪元素选择器，虽然DOM树中不存在这些伪元素节点，但是他们拥有几何信息，所以会生成到布局树。
**

DOM树和布局树不是一一对应的。有几何信息的才会在布局树中出现，display：none不出现
文本内容必须放在行盒中。

document.body.clientWidth,获取的布局信息

#### 4、分层

**
主线程会使用一套复杂的策略对布局树进行分层。
分层的好处在于，将来某一层改变后，仅对该层进行后续处理，从而提高效率。

滚动条、堆叠上下文、transform、opacity等样式都会影响分层结果。will-change会更大程度影响分层。
**

#### 5、绘制

**
主线程会为每个层单独产生绘制指令集，用于描述每个层的内容该如何画出来。
完成绘制后，主线程将绘制信息提交给合成线程，后续工作交由合成线程完成。
**

#### 6、分块

合成线程会对每个图层进行分块，将其划分为更小的区域。
它会从线程池中拿更多线程来完成分块工作。

分块完成后进入光栅化阶段。

#### 7.光栅化

合成线程将块交由GPU进程，完成光栅化，极高速度。
GPU进程会开启多个线程完成光栅化，并且优先处理靠近视口区域的块。
光栅化的结果是一块一块的位图。

#### 8.画

合成线程计算出每个位图的在屏幕上的位置，交由GPU进程最终呈现。

渲染进程（在沙盒，隔离硬件，安全）：渲染主线程、合成线程

所以交由GPU进程

transform发生在合成线程，与渲染主线程无关所以效率高。

### 什么是reflow？

渲染主线程：parse----computed style----layout----layer----paint
合成线程：----tiling分块----raster光栅化----draw-〉

cssom
dom
几何信息、布局

reflow的本质是重新计算布局树。
当进行了会影响布局树的操作后，会重新计算布局树，引发layout。
为了避免连续多次的操作导致布局树多次计算，浏览器会合并这些操作。当js代码全部执行完后统一计算。所以改动属性引发的reflow是异步的。

因此js获取布局属性时，可能是重新布局前的信息，无法获取最新的布局信息，浏览器在反复权衡下，最终决定获取布局信息立即reflow。

doc.style.width = ''
doc.style.height = ''
doc.style.margin = ''
doc.clientWidth // 立即reflow

### 什么是repaint？

repaint本质是重新根据分层信息计算了绘制指令。
当改动了可见样式就需要重新计算，引发repaint。
由于元素的布局信息也属于可见样式，所以reflow一定引发repaint。

### 为什么transform的效率高？

因为transform既不影响布局也不影响绘制，它影响的是渲染流程的最后一个阶段draw。
由于draw阶段在合成线程，所以transform的变化几乎不影响渲染主线程。反之，渲染主线程也不会影响transform的变化。

## 2023-11-27

### 1.灰阶滤镜

filter: grayscale(1) 灰阶滤镜 将对应元素的像素点转换为灰色，0是原图，1是全灰，grayscale是filter滤镜中的一种，
可以设置在html全局或局部区域上。

### 2.js实现无限循环轮播图

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Swiper</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    .container {
      width: 300px;
      height: 200px;
      overflow: hidden;
      border: 1px solid blue;
      position: relative;
    }
    .carousel {
      display: flex;
      height: 100%;
      /* transition: 0.5s; */
    }
    .carousel_item {
      background-color: aquamarine;
      color: white;
      height: 100%;
      width: 300px;
      min-width: 300px;
      text-align: center;
      font-size: 30px;
      padding-top: 60px;
    }
    .indicate {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
    }
    .dot {
      width: 10px;
      height: 10px;
      margin: 0 10px 0 0;
      border-radius: 50%;
      border: 2px solid blueviolet;
      background-color: white;
    }
    .dot.active {
      background-color: blueviolet;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="carousel">
      <div class="carousel_item" >1</div>
      <div class="carousel_item">2</div>
      <div class="carousel_item">3</div>
    </div>
    <div class="indicate">
      <div class="dot active"></div>
      <div class="dot"></div>
      <div class="dot"></div>
    </div>
  </div>
  <script type="text/javascript">
    // 无限循环原理：
    // 弹性盒水平排列，设置translateX移动加transition过渡动画
    // 克隆第一个轮播图元素到轮播容器末尾，当轮播到最后一个轮播图时即克隆的第一个元素，下标items.length-1
    // 指示器active第一个点，过渡动画结束后，立即translateX移动到第一个轮播位置（取消过渡动画），重设轮播的下标为0，实现无痕无限循环轮播

    let doms = {
      carousel: document.querySelector('.carousel'),
      carouselItems: document.querySelectorAll('.carousel_item'),
      indicators: document.querySelectorAll('.dot')
    }
    
    function moveTo(index) {
      console.log('moveTo: ' + index)
      doms.carousel.style.transition = '0.5s'
      doms.carousel.style.transform = `translateX(-${index}00%)`
      // 去除当前选中指示器
      let active = document.querySelector('.dot.active')
      active.classList.remove('active')
      // 重新设置指示器
      doms.indicators[index].classList.add('active')
    }
    // 给指示器添加点击事件
    doms.indicators.forEach((item, index) => {
      item.onclick = function () {
        moveTo(index)
      }
    })
    // 在轮播收尾各添加一个克隆项
    const firstClone = doms.carouselItems[0].cloneNode(true)
    doms.carousel.appendChild(firstClone)
    let initialValue = 0
    let currentItems = document.querySelectorAll('.carousel_item')
    let interval = setInterval(() => {
      initialValue++
      // 当轮播到最后一张时，轮播指向克隆的第一张，指示器指向第一个，过渡动画结束后移到第一张轮播图
      if (initialValue >= currentItems.length - 1) {
        doms.carousel.style.transition = '0.5s'
        doms.carousel.style.transform = `translateX(-${initialValue}00%)`
        // 去除当前选中指示器
        let active = document.querySelector('.dot.active')
        if (active) active.classList.remove('active')
        // 重新设置指示器为第一个
        doms.indicators[0].classList.add('active')
        setTimeout(() => {
          initialValue = 0
          doms.carousel.style.transition = 'none'
          doms.carousel.style.transform = `translateX(-${initialValue}00%)`
        }, 500)
      } else {
        moveTo(initialValue)
      }
    }, 3000)
  </script>
</body>
</html>
```

### 3.sticky定位

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sticky</title>
  <style>
    dl {
      /* overflow: hidden; */
    }
    dt {
      background-color: aquamarine;
      font-size: 30px;
      height: 40px;
      position: sticky;
      top: 0;
    }
    dd {
      height: 30px;
      line-height: 30px;
    }
  </style>
</head>
<body>
  <div>
    <dl>
      <dt>A</dt>
      <dd>ALorem, ipsum.</dd>
      <dd>ANisi, rerum?</dd>
      <dd>ANisi, recusandae.</dd>
      <dd>AIusto, provident!</dd>
      <dd>AFuga, sed!</dd>
      <dd>ANemo, nobis?</dd>
      <dd>AModi, consequatur.</dd>
      <dd>ANemo, nihil!</dd>
      <dd>ARepellat, alias.</dd>
      <dd>AHic, nostrum!</dd>
      <dd>AMinima, ducimus.</dd>
      <dd>ABeatae, a!</dd>
      <dd>AAccusantium, vel?</dd>
      <dd>ACorporis, totam!</dd>
      <dd>AMinus, sapiente.</dd>
      <dd>ARem, tenetur.</dd>
      <dd>ALaboriosam, perferendis.</dd>
      <dd>AQuisquam, iste!</dd>
      <dd>AItaque, nihil?</dd>
      <dd>AQuos, ipsum.</dd>
      <dt>B</dt>
      <dd>BLorem, ipsum.</dd>
      <dd>BNisi, rerum?</dd>
      <dd>BNisi, recusandae.</dd>
      <dd>BIusto, provident!</dd>
      <dd>BFuga, sed!</dd>
      <dd>BNemo, nobis?</dd>
      <dd>BModi, consequatur.</dd>
      <dd>BNemo, nihil!</dd>
      <dd>BRepellat, alias.</dd>
      <dd>BHic, nostrum!</dd>
      <dd>BMinima, ducimus.</dd>
      <dd>BBeatae, a!</dd>
      <dd>BAccusantium, vel?</dd>
      <dd>BCorporis, totam!</dd>
      <dd>BMinus, sapiente.</dd>
      <dd>BRem, tenetur.</dd>
      <dd>BLaboriosam, perferendis.</dd>
      <dd>BQuisquam, iste!</dd>
      <dd>BItaque, nihil?</dd>
      <dd>BQuos, ipsum.</dd>
      <dd>BBeatae, a!</dd>
      <dd>BAccusantium, vel?</dd>
      <dd>BCorporis, totam!</dd>
      <dd>BMinus, sapiente.</dd>
      <dd>BRem, tenetur.</dd>
      <dd>BLaboriosam, perferendis.</dd>
      <dd>BQuisquam, iste!</dd>
      <dd>BItaque, nihil?</dd>
      <dd>BQuos, ipsum.</dd>
      <dt>C</dt>
      <dd>CLorem, ipsum.</dd>
      <dd>CNisi, rerum?</dd>
      <dd>CNisi, recusandae.</dd>
      <dd>CIusto, provident!</dd>
      <dd>CFuga, sed!</dd>
      <dd>CNemo, nobis?</dd>
      <dd>CModi, consequatur.</dd>
      <dd>CNemo, nihil!</dd>
      <dd>CRepellat, alias.</dd>
      <dd>CHic, nostrum!</dd>
      <dd>CMinima, ducimus.</dd>
      <dd>CBeatae, a!</dd>
      <dd>CAccusantium, vel?</dd>
      <dd>CCorporis, totam!</dd>
      <dd>CMinus, sapiente.</dd>
      <dd>CRem, tenetur.</dd>
      <dd>CLaboriosam, perferendis.</dd>
      <dd>CQuisquam, iste!</dd>
      <dd>CItaque, nihil?</dd>
      <dd>CQuos, ipsum.</dd>
      <dd>CMinima, ducimus.</dd>
      <dd>CBeatae, a!</dd>
      <dd>CAccusantium, vel?</dd>
      <dd>CCorporis, totam!</dd>
      <dd>CMinus, sapiente.</dd>
      <dd>CRem, tenetur.</dd>
      <dd>CLaboriosam, perferendis.</dd>
      <dd>CQuisquam, iste!</dd>
      <dd>CItaque, nihil?</dd>
      <dd>CQuos, ipsum.</dd>
      <dd>CMinima, ducimus.</dd>
      <dd>CBeatae, a!</dd>
      <dd>CAccusantium, vel?</dd>
      <dd>CCorporis, totam!</dd>
      <dd>CMinus, sapiente.</dd>
      <dd>CRem, tenetur.</dd>
      <dd>CLaboriosam, perferendis.</dd>
      <dd>CQuisquam, iste!</dd>
      <dd>CItaque, nihil?</dd>
      <dd>CQuos, ipsum.</dd>
      <dd>CMinima, ducimus.</dd>
      <dd>CBeatae, a!</dd>
      <dd>CAccusantium, vel?</dd>
      <dd>CCorporis, totam!</dd>
      <dd>CMinus, sapiente.</dd>
      <dd>CRem, tenetur.</dd>
      <dd>CLaboriosam, perferendis.</dd>
      <dd>CQuisquam, iste!</dd>
      <dd>CItaque, nihil?</dd>
      <dd>CQuos, ipsum.</dd>
    </dl>
  </div>
</body>
</html>
```

注意，一个 sticky 元素会“固定”在离它最近的一个拥有“滚动机制”的祖先上，如果给其父元素dl设置overflow属性，则该属性失效，如果给body设置overflow属性，则相对于dl元素固定。如果都不设置，则相对于视口。
positon: sticky;元素根据正常文档流进行定位，然后相对它的最近滚动祖先和包含块，包括 table-related 元素，基于 top、right、bottom 和 left 的值进行偏移。
该值总是创建一个新的层叠上下文。须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。

### 4.visibilitychange 离开/进入标签页事件-页面可见度

```js
document.addEventListener('visibilitychange', function() {
  console.log(document.visibilityState) // hidden, visible
})
```

### 5.零宽字符

零宽字符是一种不可打印的Unicode字符，在浏览器等环境不可见，但是真实存在，获取字符串长度时也会占位置，表示某一种控制功能的字符。

```js
const str1 = '哈哈\u200d\u200d嘿嘿'
const str2 = '哈哈嘿嘿'
console.log(str1, str1.length, str1 === str2) // 哈哈‍‍嘿嘿 6 false
```

### 6.求和

求1开始的前n项的奇数和

```js
function sum(n) {
    let result = 0
    for(let i=0;i<n;i++) {
        result+=2*i+1
    }
    return result
}
sum(1) // 1
sum(2) // 4
sum(3) // 9
sum(4) // 16
sum(5) // 25
sum(6) // 36

// 或者
function sum(n) {
  return n*n
}
```

求1开始的前n项的偶数和

```js
function sum(n) {
    let result = 0
    for(let i=0;i<n;i++) {
        result+=2*(i+1)
    }
    return result
}
sum(1) // 2 = 1*2
sum(2) // 6 = 2*3
sum(3) // 12 = 3*4
sum(4) // 20 = 4*5
sum(5) // 30 = 5*6
sum(6) // 42 = 6*7

// 或者
function sum(n) {
  return n*(n+1)
}
```

求1开始的前n项的和

```js
function sum(n) {
    let result = 0
    for(let i=0;i<n;i++) {
        result+=(i+1)
    }
    return result
}
sum(1) // 1 = n*(n+1)/2
sum(2) // 3 
sum(3) // 6
sum(4) // 10
sum(5) // 15
sum(6) // 21

// 或者
function sum(n) {
  return n*(n+1)/2
}
```

求1-n之间的奇数和

```js
function sum(n) {
    let result = 0
    for(let i=0;i<n;i++) {
      if (i%2 = 1) {
        result+=i
      }
    }
    return result
}
sum(1) // 1
sum(2) // 1 
sum(3) // 4
sum(4) // 4
sum(5) // 9
sum(6) // 9

```

### 7.文字描边text-stroke

-webkit-text-stroke: 2px #fff;

### 8.js类里创建私有字段

```js
<script>
    class A {
      constructor() {
        this._abc = 1 // 以前没有私有字段用_来说明是私有字段但是外部可以访问
      }
    }
    let a = new A()
    console.log(a._abc) // 1

    class B {
      #abc; // 定义一个私有字段
      constructor() {
        this.#abc = 1
      }
      #method (){} // 私有方法
    }
    let b = new B()
    console.log(b, b.#abc) // private field '#abc' must be declared in an enclosing class
  </script>
  ```

### 9.下拉菜单的过渡效果

**css获取焦点设置高度auto展开，但是transition无效，只针对数值有效。**

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>select-transition</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      padding-left: 100px;
    }
    input {
      width: 400px;
      height: 40px;
    }
    .select {
      width: 400px;
      border-right: 1px solid;
      border-left: 1px solid;
      border-bottom: 1px solid;
      margin-top: -1px;
      height: 0;
      overflow: hidden;
      transition: 1s;
    }
    .select > div {
      line-height: 30px;
      padding-left: 20px;
    }
    input:focus ~ .select {
      height: auto
    }
  </style>
</head>
<body>
  <input type="text">
  <div class="select">
    <div>Lorem, ipsum.</div>
    <div>Ab, vel?</div>
    <div>Voluptatum, iusto.</div>
    <div>Atque, repudiandae?</div>
    <div>Corporis, voluptas.</div>
  </div>
</body>
</html>
```

已知select高度情况下可以设置具体值，比如

```css
input:focus ~ .select {
  height: 300px
}
```

**设置max-height值也可以实现效果。**

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>select-transition</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      padding-left: 100px;
    }
    input {
      width: 400px;
      height: 40px;
    }
    .select {
      width: 400px;
      border-right: 1px solid;
      border-left: 1px solid;
      border-bottom: 1px solid;
      margin-top: -1px;
      height: auto;
      overflow: hidden;
      max-height: 0;
      transition: 1s;
    }
    .select > div {
      line-height: 30px;
      padding-left: 20px;
    }
    input:focus ~ .select {
      max-height: 300px;
    }
  </style>
</head>
<body>
  <input type="text">
  <div class="select">
    <div>Lorem, ipsum.</div>
    <div>Ab, vel?</div>
    <div>Voluptatum, iusto.</div>
    <div>Atque, repudiandae?</div>
    <div>Corporis, voluptas.</div>
  </div>
</body>
</html>
```

注意，max-height的值，300px的高度过渡动画为1s，但实际上select真实高度并不一定是300，因此失焦时收起select会有延时

**使用js添加获取/失去焦点事件控制select高度。**

先css设置height为0，获取焦点时，设置高度auto获取实际高度，然后再设置select高度0，再设置获取的实际高度和transition，失焦时隐藏高度

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>select-transition</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      padding-left: 100px;
    }
    input {
      width: 400px;
      height: 40px;
    }
    .select {
      width: 400px;
      border-right: 1px solid;
      border-left: 1px solid;
      border-bottom: 1px solid;
      margin-top: -1px;
      height: 0;
      overflow: hidden;
      transition: 1s;
    }
    .select > div {
      line-height: 30px;
      padding-left: 20px;
    }
  </style>
</head>
<body>
  <input type="text">
  <div class="select">
    <div>Lorem, ipsum.</div>
    <div>Ab, vel?</div>
    <div>Voluptatum, iusto.</div>
    <div>Atque, repudiandae?</div>
    <div>Corporis, voluptas.</div>
  </div>
  <script>
    let input = document.querySelector('input')
    let select = document.querySelector('.select')
    input.onfocus = function() {
      select.style.transition = 'none'
      select.style.height = 'auto'
      // 获取select高度
      const height = select.offsetHeight
      console.log(height)
      select.style.height = 0
      select.offsetHeight // 获取元素几何信息强制浏览器渲染，因为浏览器js设置dom会合并操作所以需要强制渲染
      select.style.transition = '1s'
      select.style.height = height + 'px'
    }
    input.onblur = function() {
      select.style.transition = '1s'
      select.style.height = '0'
    }
  </script>
</body>
</html>
```

**利用css3的scaleY缩放高度。**

注：缩放过程字体会重叠

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>select-transition</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      padding-left: 100px;
    }
    input {
      width: 400px;
      height: 40px;
    }
    .select {
      width: 400px;
      border-right: 1px solid;
      border-left: 1px solid;
      border-bottom: 1px solid;
      margin-top: -1px;
      height: auto;
      overflow: hidden;
      transition: 1s;
      z-index: -1;
      transform-origin: center top;
      transform: scaleY(0);
    }
    .select > div {
      line-height: 30px;
      padding-left: 20px;
    }
    input:focus ~ .select {
      transform: scaleY(1);
    }
  </style>
</head>
<body>
  <input type="text">
  <div class="select">
    <div>Lorem, ipsum.</div>
    <div>Ab, vel?</div>
    <div>Voluptatum, iusto.</div>
    <div>Atque, repudiandae?</div>
    <div>Corporis, voluptas.</div>
  </div>
</body>
</html>
```

### 10.跨域cors

CORS是基于http1.1的一种跨域解决方案，全称跨域资源共享。
它的总体思路：如果浏览器要跨域访问服务器的资源，需要获取服务器的允许。

针对不同请求，cors规定里三种不同的交互模式：

+ 简单请求
+ 需要预检的请求
+ 携带身份凭证的请求

#### 简单请求

1. 请求方法属于以下的一种：get、post、head
2. 请求头仅包含安全的字段，常见安全字段如下：
   + Accept
   + Accept-Language
   + Content-Language
   + Content-Type
   + DPR
   + Downlink
   + Save-Data
   + Viewport-Width
   + Width

3. 请求头如果包含Content-Type，仅限以下值之一：
   + text/plain
   + multipart/form-data
   + application/x-www-form-urlencoded

以上三个条件都满足，浏览器判断为简单请求。

#### 简单请求的交互规范

当前浏览器某个跨域请求是简单请求时，会发生以下：

1. 请求头中会自动添加Origin字段，哪个源地址在跨域请求
2. 服务器响应头应包含Access-Control-Allow-Origin
   服务器收到响应，如果允许跨域，则在响应头添加Access-Control-Allow-Origin字段，该属性值有：
   + *：允许一切
   + http://my.com: 只允许http://my.com这个源访问

#### 需要预检的请求

如果浏览器不认为是简单请求，会按照以下流程进行：

+ 浏览器发送预检请求，访问服务器是否允许
+ 服务器允许访问
+ 浏览器发送真实的请求
+ 服务器完成真实的响应

例如以下请求，就是需要预检请求

```js
fetch("http://my.com/api/user", {
  method: "POST",
  header: {
    a:1
    'Content-Type': 'application/json'
  },
  body: ...
})
```

#### 附带身份凭证的请求

默认情况下，ajax的请求并不会携带cookie，可以配置：

```js
// xhr
var xhr = new XMLHttpRequest()
xhr.withCredentials = true

// fetch api
fetch(url, {
  credentials: 'include'
})
```

这样，该跨域的请求就是附带身份凭证的请求。当一个请求附带cookie时，无论是简单请求还是预检请求，都会在请求头中添加cookie字段，
而服务器响应时需要明确告知客户端服务器允许这样的凭证：Access-Control-Allow-Credentials: true.若服务器没有响应则跨域被拒绝，
注意：对于附带身份凭证的请求，服务器不得设置Access-Control-Allow-Origin:*。

#### 补充

在跨域访问时，js只能拿到一些最基本的响应头，比如：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Progma，如果要访问其他头，需要服务器设置响应头。

Access-Control-Export-Headers：authorization...,这样浏览器就可以访问authorization响应头了。

### 10.解析url中的参数

```js
function parseQuery(url) {
  let q = {}
  url.replace(/([^?&=]+)=([^&]+)/g,
  (_, k, v) => (q[k] = v))
  return q
}
let a = parseQuery('http://my.com?a=1&b=2')
let b = parseQuery('a=1&b=2')
console.log(a, b)
```

### 11.生成随机颜色

```js
function randomColor() {
  return '#' + Math.floor(Math.random() * 0xffffff).toString(16).padEnd(6, '0')
}
// padEnd() 方法会将当前字符串从末尾开始填充给定的字符串（如果需要会重复填充），直到达到给定的长度。填充是从当前字符串的末尾开始的。
console.log(randomColor())
```

### 12.js的atob和btoa函数

btoa() 方法可以将一个二进制字符串（例如，将字符串中的每一个字节都视为一个二进制数据字节）编码为 Base64 编码的 ASCII 字符串.
atob() 对经过 base-64 编码的字符串进行解码.

```js
let encodedData = window.btoa("Hello, world"); // 编码
let decodedData = window.atob(encodedData); // 解码
console.log(encodedData, decodedData)
// SGVsbG8sIHdvcmxk Hello, world
```

### 13.判断一个值是否是Promise Like？

和Promise结构类似
Promise A+规范：<https://promisesaplus.com/>
“promise”是一个具有符合本规范的then方法的对象或函数。

```js
function isPromiseLike(value) {
  return value !== null && (typeof value === 'object' || typeof value === 'function') && (typeof value.then === 'function')
}
```

### 14.手写一个Promise

promise是一个构造函数，带有then方法
它有三种状态：pending 挂起，任务进行中、fulfilled 完成、rejected 失败
then方法接收2个参数，onFulfilled 和 onRejected 都是可选参数，它们是异步执行的
可以多次对同一个promise调用then方法，从而注册多个onFulfilled或onRejected
then方法必须再次返回一个promise
Promise(resolve, reject), resolve, reject是函数,改变状态

```js
const PENDING = 'pending'
const FULLFILLED = 'fulfilled'
const REJECTED = 'rejected'

// promise是一个构造函数，带有then方法
// 它有三种状态：pending 挂起，任务进行中、fulfilled 完成、rejected 失败
class MyPromise {
  #state = PENDING // 私有属性，promise初始状态pending
  #result = undefined // 私有属性，promise结果
  #handler = [] // 保存每次调用then方法的回调onFulfilled, onRejected，resolve，reject
  constructor(executor) {
    const resolve = (data) => {
      // 改变状态
      this.#changeState(FULLFILLED, data)
    }
    const reject = (reason) => {
      // 改变状态
      this.#changeState(REJECTED, reason)
    }
    try {
      executor(resolve, reject)
    } catch (error) {
      reject(error)
    }
  }
  #changeState(state, result) {
    if (this.#state !== PENDING) return // 状态一旦改变不可再更改
    this.#state = state
    this.#result = result
    this.#run() // 异步的时候这里知道什么时候改变状态
  }
  #isPromiseLike(value) {
    return value !== null && (typeof value === 'object' || typeof value === 'function') && (typeof value.then === 'function')
  }
  #runMicroTask(callback) {
    setTimeout(callback, 0)
  }
  #run() {
    // fulfilled、rejected、pending
    if (this.#state === PENDING) {
      return
    }
    // 遍历then方法的回调执行
    while(this.#handler.length) {
      const { onFulfilled, onRejected, resolve, reject } = this.#handler.shift()
      // p.then传递参数 onFulfilled, onRejected：
      // 1.回调不是函数：p.then(null), 直接resolve， rejected
      // 2.回调是函数：函数有执行结果 p.then((res)=> {}, err => {})
      // 3.回调的函数的返回结果是promise
      if (this.#state === FULLFILLED) {
        this.#runMicroTask(() => { // promise运行在微队列中
          // 回调不是函数
          if (typeof onFulfilled !== 'function') {
            resolve(this.#result)
          } else {
            // 回调是函数
            try {
              const data = onFulfilled(this.#result) // 回调的函数返回结果是promise
              if (this.#isPromiseLike(data)) {
                data.then(resolve, reject)
              } else {
                resolve(data)
              }
            } catch (error) {
              reject(error)
            }
          }
        })
      } else { // rejected
        this.#runMicroTask(() => { // promise运行在微队列中
          // 回调不是函数
          if (typeof onRejected !== 'function') {
            reject(this.#result)
          } else {
            // 回调是函数
            try {
              const data = onRejected(this.#result) // 回调的函数返回结果是promise
              if (this.#isPromiseLike(data)) {
                data.then(resolve, reject)
              } else {
                resolve(data)
              }
            } catch (error) {
              reject(error)
            }
          }
        })
      }
    }
  }
  // then方法接收2个参数，onFulfilled 和 onRejected 都是可选参数，它们是异步执行的
  // 可以多次对同一个promise调用then方法，从而注册多个onFulfilled或onRejected
  // then方法必须再次返回一个promise
  then(onFulfilled, onRejected) {
    return new MyPromise((resolve, reject) => {
      // 如果是同步：状态直接是fulfilled/rejected
      // 异步：pending
      // 可多次调用、可能异步（pending）
      // 保存每次调用then方法的回调onFulfilled, onRejected，resolve，reject，等待完成即状态改变（#changeState）时调用
      this.#handler.push({
        onFulfilled,
        onRejected,
        resolve,
        reject
      })
      this.#run()
    })
  }
}
const p = new MyPromise((resolve, reject) => {
  setTimeout(() => {
    reject(123)
  }, 1000)
})
// p.then(
//   null,
//   (err) => {
//     console.log('promise-fail1', err)
//     return 456
//   }
// ).then(
//   (res) => {
//     console.log('promise-success2', res)
//   },
//   (err) => {
//     console.log('promise-fail2', err)
//   }
// )
// promise-fail1 123
// promise-success2 456

p.then(
  null,
  (err) => {
    console.log('promise-fail1', err)
    throw 456
  }
).then(
  (res) => {
    console.log('promise-success2', res)
  },
  (err) => {
    console.log('promise-fail2', err)
  }
)
// promise-fail1 123
// promise-fail2 456
```

### 15.语义化版本

x.y.z ， x、y、z都是数字，只能增加
x：主版本，breaking update， 不兼容式升级，比如vue2-vue3
y：次版本，更新兼容以前版本
z：修订版本，修复bug，优化等

1.8.2->2.0.0
1.8.2->1.9.0

高位版本增加，低位版本要清零

0.1.0，主版本0表示测试版本，未正式发布
1.2.3-alpha，alpha预发布版本

### 16.axios

Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。

特性

  从浏览器中创建 XMLHttpRequests
  从 node.js 创建 http 请求
  支持 Promise API
  拦截请求和响应
  转换请求数据和响应数据
  取消请求
  自动转换 JSON 数据
  客户端支持防御 XSRF

### 17.数据埋点

服务监控：产品（ARMS、神策，sentry免费）

  错误监控
  性能监控
  行为监控

数据埋点：

  侵入：监控用户行为，关键业务代码处埋点
  非侵入：错误、性能监控，对代码等无侵入，在入口文件收集即可

### 18.web性能指标

评定web应用程序用户体验是否优秀：

  RAIL模型：Response响应时间、Animation动画流畅不丢帧不跳帧、Idle页面运行过程是否给用户留够交互时间、load加载时间

衡量的关键指标：

+ FCP：首次内容加载经过的时间，从白屏到第一个有意义的内容（可以是文字、图片、按钮或背景色元素，看得见的内容）出现的时间
+ LCP：最大内容绘制时间，屏幕内最大的元素加载出来
+ CLS：累计偏移，前面有内容突然加载出来导致内容往后挤，破坏用户的操作，比如点击按钮时，前面有内容加载导致按钮往后排，点击到别的按钮等
+ TBT：total blocking time总的阻塞时间，从FCP到TTI的时间，TTI表示用户可交互的时间点

使用Chrome lighthouse工具衡量这些指标

了解用户真实指标需要收集，第三方库web vitals

### 19.从视频文件中提取画面帧

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>提取视频文件中的画面帧</title>
</head>
<body>
  <input type="file" name="video" id="">
  <script>
    let file = document.querySelector('input[type=file]')
    file.onchange = async (e) => {
      console.log(e.target.files)
      let file = e.target.files[0]
      // 提取第10秒的帧并img预览
      // const frame = await captureFrame(file, 10)
      // createPreview(frame)
      // console.log(frame)
      // 每隔1秒提取帧展示
      for (let i = 1; i < 10; i++) {
        const frame = await captureFrame(file, 1 * i)
        createPreview(frame)
      }
    }
    function drawVideo(vdo) {
      return new Promise((resolve, reject) => {
        const cvs = document.createElement('canvas')
        const ctx = cvs.getContext('2d')
        cvs.width = vdo.videoWidth
        cvs.height = vdo.videoHeight
        ctx.drawImage(vdo, 0, 0, cvs.width, cvs.height)
        cvs.toBlob((blob) => {
          resolve({
            blob,
            url: URL.createObjectURL(blob)
          })
        })
      })
      
    }
    function captureFrame(vdoFile, time = 0) {
      return new Promise((resolve, reject) => {
        const vdo = document.createElement('video')
        vdo.currentTime = time
        vdo.muted = true
        vdo.autoplay = true
        vdo.oncanplay = async () => {
          const frame = await drawVideo(vdo)
          resolve(frame)
        }
        vdo.src = URL.createObjectURL(vdoFile)
      })
    }
    function createPreview(frame) {
      const img = document.createElement('img')
      img.src = frame.url
      document.body.append(img)
    }
  </script>
</body>
</html>
```

### 20.ESMoudle的工作原理

静态导入：

```js
import A from './A.js'
```

动态导入：

```js
import('./dynmaic.js').then(d => {
  console.log(d.default)
})
```

静态导入解析是在运行之前发生的，动态导入的解析是在运行时发生的。
比如import A from './A.js'，会先将A.js转换为完整的引入url：***/A.js，再下载，先模块解析，再运行
动态导入：完整URL-》下载js-》解析-》运行-》然后执行then里面语句

### 21.defineProperty和proxy

defineProperty是对象基本操作（内部函数调用），用来定义属性描述符的，不能暴露给开发者，比如get读取属性会调用has方法，delete obj[k] 调用内部函数delete
proxy针对所有的操作都可以拦截，也暴露了内部方法。

### 22.垃圾回收与内存泄露

程序运行需要内存空间，可能某一块内存空间不再需要，这块内存空间称为垃圾，回收垃圾的叫垃圾回收器
内存泄露：一块内存空间不需要但垃圾回收器没法回收的内存就是内存泄露

垃圾回收机制：标记清除算法、引用计数算法（不用）

### 23.解析DOM树

```js
function removeTag(fragment) {
    return (new DOMParser().parseFromString(fragment, 'text/html').body.textContent || '')
}
removeTag(`<div class="container">
    <h1>DOM Parser</h1>
    <ul>
      <li>Lorem.</li>
      <li>Maiores.</li>
      <li>Sapiente!</li>
      <li>Doloremque.</li>
    </ul>
  </div>`)

// output:
// DOM Parser
        
// Lorem.
// Maiores.
// Sapiente!
// Doloremque.
        
```

### 22. 大文件切片上传

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>大文件上传切片</title>
</head>
<body>
  <input type="file" name="file" id="fileUpload">
  <script src="./upload.js"></script>
</body>
</html>
```

upload.js

```js
const uploadFile = document.querySelector("#fileUpload")

uploadFile.onchange = async e => {
  const file = e.target.files[0]
  console.time("upfile")
  const chunks = await cutFile(file) // 获取分片结果
  console.timeEnd("upfile")
  console.log("切片：", chunks)
}

const CHUNK_SIZE = 1024 * 1024 * 5 // 5M
const THREAD_COUNT = navigator.hardwareConcurrency || 4 // 线程数量（切片运行在主线程可能会造成阻塞，可开启别的线程进行分片工作）
// 分片
async function cutFile(file) {
  // 比如 file.size :70M, chunkCount: 14  workerChunkCount: 4
  return new Promise(async (resolve, reject) => {
    const chunkCount = Math.ceil(file.size / CHUNK_SIZE) // 分片数量
    const workerChunkCount = Math.ceil(chunkCount / THREAD_COUNT) // 每个线程处理的分片数量

    console.log("切片数量", chunkCount)
    const result = []
    // 切片运行在主线程
    // for (let i = 0; i < chunkCount; i++) {
    //   const chunk = await createChunk(file, i, CHUNK_SIZE)
    //   result.push(chunk)
    // }
    // 开启其他线程去分片提高效率
    let finishWorker = 0
    for (let i = 0; i < THREAD_COUNT; i++) {
      const worker = new Worker("./worker.js", {
        type: "module"
      })
      // 每个线程起始切片和结束切片索引
      const startIndex = i * workerChunkCount // 0-4 4-8 8-12 12-14
      let endIndex = startIndex + workerChunkCount
      if (endIndex > chunkCount) {
        endIndex = chunkCount
      }
      // 发送消息
      worker.postMessage({
        file,
        CHUNK_SIZE,
        startIndex,
        endIndex
      })
      // 处理结束接受消息
      worker.onmessage = e => {
        console.log(e.data) // 数组
        // 保证切片顺序正确
        // i: index
        // 0: 0-4
        // 1: 4-8
        // 2: 8-12
        // 3: 12-14
        for (let index = startIndex; index < endIndex; index++) {
          result[index] = e.data[index - startIndex] // index - startIndex: 0 1 2 3
        }
        worker.terminate() // 收到消息后当前线程切片工作完成，结束线程
        finishWorker++
        if (finishWorker === THREAD_COUNT) {
          // 所有线程都完成
          resolve(result)
        }
      }
    }
  })
}
// 创建分片 slice截取
function createChunk(file, index, chunkSize) {
  return new Promise((resolve, reject) => {
    const start = index * chunkSize
    const end = start + chunkSize
    const fileReader = new FileReader()
    fileReader.onload = e => {
      // console.log('fileReader-onload', e.target.result)
      resolve({
        start,
        end,
        index,
        hash: e.target.result
      })
    }
    fileReader.readAsArrayBuffer(file.slice(start, end))
  })
}
```

worker.js

```js
onmessage = async (e) => {
  const promises = []
  const { file, CHUNK_SIZE, startIndex, endIndex } = e.data
  for (let index = startIndex; index < endIndex; index++) {
    promises.push(createChunk(file, index, CHUNK_SIZE))
  }
  const result = await Promise.all(promises)
  postMessage(result)
}

// 创建分片 slice截取
function createChunk(file, index, chunkSize) {
  return new Promise((resolve, reject) => {
    const start = index * chunkSize
    const end = start + chunkSize
    const fileReader = new FileReader()
    fileReader.onload = e => {
      // console.log('fileReader-onload', e.target.result)
      resolve({
        start,
        end,
        index,
        hash: e.target.result
      })
    }
    fileReader.readAsArrayBuffer(file.slice(start, end))
  })
}
```

不必等到全部切片再上传，可以开启其他线程进行切片，边切片边进行上传

### 23.单点登录

多条产品线，共享同一套用户系统，抽离用户系统，形成用户中心

session+cookie模式：
认证中心登录成功后生成用户信息到session表里（sid:身份信息），然后将该 Session ID 存储在 Cookie 中，并返回给客户的端，客户端再次访问业务系统会带上cookie（包含sid），业务系统去认证中心验证sid是否有效，有效就可以访问业务系统登录后的资源。

认证中心会将用户信息存储session表里，session 存储在服务器里面，当用户同时在线量比较多时，这些 session 会占据较多的内存，需要在服务端定期的去清理过期的 session。

token模式：

用户-认证中心登录成功后返回给客户端一个token（jwt），客户端自己存储。客户端再访问业务系统携带token，业务系统自行验证token是否有效。

token+refresh模式：

用户-认证中心登录成功后返回给客户端token+refreshToken, token过期时间短，refreshToken长期有效，客户端访问业务系统携带token，由业务系统进行验证，如果token过期，客户端会用refreshToken去认证中心重新获取新的token，再去访问业务系统

### 24.LRU缓存置换算法

LRU：选择最近最久未使用的置换

```js
class LRUCache {
  #map;
  #length;
  constructor(length) {
    this.#map = new Map()
    this.#length = length
  }
  get(key) {
    if (!this.$map.get(key)) {
      return
    }
    const value = this.$map.get(key)
    this.#map.delete(key)
    this.#map.set(key, value)
    return value
  }
  set(key, value) {
    if (this.$map.get(key)) {
      this.#map.delete(key)
    }
    this.#map.set(key, value)
    if (this.#map.size > this.#length) {
      const firstkey = this.#map.keys().next().value
      this.#map.delete(firstkey)
    }
  }
}
```

### 25.判断是不是数组

#### 1.Object.prototype.toString.call([])

从原型入手，Array.prototype.isPrototypeOf(obj);
利用isPrototypeOf()方法判断Array是否在obj的原型链上

```js
let arr = []
let obj = {}
Object.prototype.toString.call(arr) // '[object Array]'
Object.prototype.toString.call(obj) // '[object Object]'
// but
let obj1 = {
  [Symbol.toStringTag]: 'abc'
}
Object.prototype.toString.call(obj1) // '[object abc]'
```

对象的Symbol.toStringTag属性，指向一个方法。在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制[object Object]或[object Array]中object后面的那个字符串。

#### 2.[] instanceof Array

instanceof检测构造函数的prototype属性是否存在实例对象的原型链上

```js
[] instanceof Array // true
const Array1 = window.Array
const Array2 = iframe.contentWindow.Array
const arr = new Array2()
arr instanceof Array // false
```

#### 3.Array.isArray([]);

Array.isArray() 检查传递的值是否为 Array。它不检查值的原型链，也不依赖于它所附加的 Array 构造函数。
对于使用数组字面量语法或 Array 构造函数创建的任何值，它都会返回 true

```js
// 下面的函数调用都返回 true
Array.isArray([]);
Array.isArray([1]);
Array.isArray(new Array());
Array.isArray(new Array("a", "b", "c", "d"));
Array.isArray(new Array(3));
// 鲜为人知的事实：其实 Array.prototype 也是一个数组：
Array.isArray(Array.prototype);

// 下面的函数调用都返回 false
Array.isArray();
Array.isArray({});
Array.isArray(null);
Array.isArray(undefined);
Array.isArray(17);
Array.isArray("Array");
Array.isArray(true);
Array.isArray(false);
Array.isArray(new Uint8Array(32));
// 这不是一个数组，因为它不是使用数组字面量语法或 Array 构造函数创建的
Array.isArray({ __proto__: Array.prototype });
```

当检测 Array 实例时，Array.isArray 优于 instanceof，因为 Array.isArray 能跨领域工作。

```js
const iframe = document.createElement("iframe");
document.body.appendChild(iframe);
const xArray = window.frames[window.frames.length - 1].Array;
const arr = new xArray(1, 2, 3); // [1, 2, 3]

// 正确检查 Array
Array.isArray(arr); // true
// arr 的原型是 xArray.prototype，它是一个不同于 Array.prototype 的对象
arr.__proto__ == xArray.prototype // true
arr.__proto__ == Array.prototype // false

arr instanceof Array; // false
```

### 26.Reflect的本质

Reflect: 调用对象的基本方法。

针对js的对象的基本内部方法有：

![image](/images/objectbase.png)

支持对象被作为函数调用的其他基础内部方法:

![image](/images/objectcall.png)

这些对象的基本内部方法不对外暴漏，但是有了Reflect可以通过函数方式调用而不使用语法：

```js
const obj = {}
// obj.a = '3' 语法
Reflect.set(obj, 'a', '3')
// {a: '3'}
```

当使用语法obj.a = '3'赋值时，执行代码时会先执行一个被封装过后的方法，方法里面调用了内部方法get

```js
const obj = {
  a: 1,
  b: 2,
  get c() {
    return this.a + this.b
  }
}
console.log(obj.c) // 3

// [Get]]---(propertyKey, Receiver) → any---返回这个对象里 key 值为 propertyKey 的属性的值。如果必须运行一些的 ECMAScript 代码来检索这个属性值，Receiver 就会作为解析代码时的 this 值。

// 因为obj.c调取get内部方法，Receiver即this传递的是obj，所以没办法更改this的值

// 但是Reflect可以传递Receiver更改this
Reflect.get(obj, 'c', {a: 3, b: 4}) // 7
```

```js
let obj = {
  a: 1,
  b: 2,
  [Symbol('c')]: 3
}
Object.defineProperty(obj, 'd', {
  value: 4,
  enumerable: false
})
console.log(Object.keys(obj)) // ['a', 'b']
// Object.keys方法调用的封装后的方法里面设置过滤掉不可枚举的属性，调用内部方法OwnPropertyKeys：返回一个包含所有自身属性 key 值的 List。
console.log(Reflect.ownKeys(obj)) //  ['a', 'b', 'd', Symbol(c)]
// OwnPropertyKeys对应的Reflect方法ownKeys，Reflect.ownKeys直接调用对象的内部方法可获取全部属性
```

### 27.img的srcset、size

srcset可以设置不同dpr使用的图片尺寸

图像的尺寸 = css尺寸 *  dpr  图片不会模糊

```css
img {
  width: 150px;
  height: 150px;
}
```

```html
<img srcset="
  https://picsum.photos/id/164/150 1x,
  https://picsum.photos/id/164/300 2x,
  https://picsum.photos/id/164/450 3x,
  https://picsum.photos/id/164/600 4x,
  https://picsum.photos/id/164/750 5x,
  https://picsum.photos/id/164/900 6x,
">
```

"https://picsum.photos/id/164/150" 1x, dpr为1时，使用150的图片

sizes: 媒体查询来响应图片大小，多个值用逗号隔开
例如：sizes="(max-width: 300px) 50vw, 50vw"，
表示当视区宽度不大于300像素时候，图片的宽度限制为50vw，其他情况下，使用50vw,那么当视区宽度为200像素时，图片尺寸等于100px*dpr,
假设dpr为2，那么就匹配最接近的即150w

```html
<img srcset="
    https://picsum.photos/id/164/150 150w,
    https://picsum.photos/id/164/300 300w
    https://picsum.photos/id/164/600 600w,
    https://picsum.photos/id/164/900 900w,
    https://picsum.photos/id/164/1200 1200w,
  "
  sizes="(max-width: 300px) 50vw,
  (max-width: 600px) 50vw,
  (max-width: 900px) 50vw,
  (max-width: 1200px) 50vw,
  50vw
  ">
  ```

### 28.es2023中的数组纯函数

es2023的新数组函数：toSorted、toReversed、toSliced、with(index, value)-arr[index] = value
这些数组函数不会改变原数组的值只会返回更改后的值

```js
// let arr = [1, 7, 3]
// arr.sort((a, b) => a - b)
// console.log(arr) // [1, 3, 7]
let arr = [1, 7, 3]
let sortArr = arr.toSorted((a, b) => a - b)
console.log(sortArr, arr) // [1, 3, 7]  [1, 7, 3]
```

### 29.动态执行js

1.使用eval: 同步代码,当前作用域

```js
var a = 1
function exec(code) {
  var a = 2
  eval(code)
}
exec('console.log("a", a)')
console.log('sync')
// a 2 
// 'sync'
// eval: 同步代码,当前作用域
```

2.setTimeout: 异步，全局作用域

```js
var a = 1
function exec(code) {
  var a = 2
  setTimeout(code, 0)
}
exec('console.log("a", a)')
console.log('asynchronous')
// 'asynchronous'
// a 1
```

3.创建script标签加入body: 同步，全局作用域

```js
var a = 1
function exec(code) {
  var a = 2
  const script = document.createElement('script')
  script.innerHTML = code
  document.body.appendChild(script)
}
exec('console.log("a", a)')
console.log('sync')
// a 1
// 'sync'
```

4.Function: 同步，全局作用域, 无需创建多余的标签

```js
ar a = 1
function exec(code) {
  var a = 2
  let fn = new Function(code) // 创建一个function，函数体为code
  fn()
}
exec('console.log("a", a)')
console.log('sync')
// a 1
// 'sync'
```

### node模块查找策略

代码使用require、import，根据路径怎么查找文件
require('./a') require('/a')

文件查找：
  
  按照路径查找a，后缀补js查找a.js找不到查找a.json还找不到去查找文件夹

文件夹查找：

  首先查看a文件夹下面是否有package.json文件，配置"main": "./t.js",就去找a/t.js
  如果a文件夹下面没有package.json文件或者没有配置main或者配置了一个不存在的路径，就去查找
  a文件夹下面有没有index.js, index.json文件

require('a')：

内置模块：

  如果路径直接写名字，首先会去内置模块查找，比如node内置模块http,fs, path等
  如果a在内置模块就使用，不是就去第三方模块查找

第三方模块：

  从node_modules查找，如果当前node_modules没有a，就去上级目录查找

### vue状态仓库持久化：vuex、pina

vuex、pina都是存储在内存里，一旦刷新页面就没了

vuex：

```js
// index.js
import { createStore } from 'vuex'
import counter from './counter'
import persistPligin from "./persistPligin"

const store = createStore({
  modules: {
    counter
  },
  plugins: [persistPligin]
})
```

```js
// persistPligin.js
const KEY = 'vuex-store'
export default function(store) {
  // 保存仓库数据到本地
  console.log(store)
  window.addEventListener('beforeunload', () => {
    localStorage.setItem(KEY, JSON.stringify(store.state))
  })
  // 恢复仓库数据
  try {
    const localState = localStorage.getItem(KEY)
    if (localState) {
      store.replaceState(JSON.parse(localState))
    }
  } catch (error) {
    console.log(error)
  }
}
```

或者使用第三方库比如vuex-persist

pina：

```js
// main.js
import { createPinia } from 'pinia'
import persistPligin from "./store/persistPligin"
const pinia = createPinia()
pinia.use(persistPligin)
```

```js
// persistPligin.js
const KEY_PREFIX = 'pina_store_'
export default function(context) {
  const { store, id } = context
  const KEY = KEY_PREFIX + id
  // 保存仓库数据到本地
  window.addEventListener('beforeunload', () => {
    localStorage.setItem(KEY, JSON.stringify(store.$state))
  })
  // 恢复仓库数据
  try {
    const localState = localStorage.getItem(KEY)
    if (localState) {
      store.$patch(JSON.parse(localState))
    }
  } catch (error) {
    console.log(error)
  }
}
```

也可以使用第三方插件实现持久话存储

### css选择器focus-within、has、 first-letter、selection

`:focus-within` CSS 伪类表示当元素或其任意后代元素被聚焦时，将匹配该元素.

CSS 函数式伪类 `:has()` 表示一个元素，如果作为参数传递的任何相对选择器在锚定到该元素时，至少匹配一个元素.

```css
h1:has(+ h2) {
  margin: 0 0 0.25rem 0;
}
```

CSS 伪元素 `::first-letter`会选中某 block-level element（块级元素）第一行的第一个字母，并且文字所处的行之前没有其他内容

`::selection` CSS 伪元素应用于文档中被用户高亮的部分（比如使用鼠标或其他选择设备选中的部分）

### 文件上传、文件夹、拖拽上传

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>上传文件-支持文件夹-拖拽等</title>
  <style>
    .drop {
      width: 800px;
      height: 300px;
      border: 1px solid black;
      border-radius: 10px;
    }
  </style>
</head>
  <div class="drop">拖拽</div>
  <!-- multiple 支持多选文件 -->
  <!-- webkitdirectory mozdirectory odirectory 文件支持目录选择-->

  <input type="file" id="fileFile" multiple />
  <br>
  <input type="file" id="filepicker" multiple webkitdirectory mozdirectory odirectory />
  <ul id="listing"></ul>
  <script>
    // 选择文件
    document.getElementById("fileFile").addEventListener(
      "change",
      (event) => {
        let output = document.getElementById("listing");
        for (const file of event.target.files) {
          console.log(file)
          let item = document.createElement("li");
          item.textContent = file.name + '----' + file.size;
          output.appendChild(item);
        }
      },
      false,
    );
    // 选择文件夹
    document.getElementById("filepicker").addEventListener(
      "change",
      (event) => {
        let output = document.getElementById("listing");
        for (const file of event.target.files) {
          console.log(file)
          let item = document.createElement("li");
          item.textContent = file.webkitRelativePath;
          output.appendChild(item);
        }
      },
      false,
    );
    // 拖拽
    const drop = document.querySelector('.drop')
    drop.ondragenter = (e) => {
      e.preventDefault()
    }
    drop.ondragover = (e) => {
      e.preventDefault()
    }
    drop.ondrop = (e) => {
      e.preventDefault()
      // 如果只支持拖拽文件
      // const files = e.dataTransfer.files
      // 支持拖拽文件夹
      for (const item of e.dataTransfer.items) {
        const entry = item.webkitGetAsEntry()
        console.log(entry)
        // filesystem: DOMFileSystem: {name: 'http_127.0.0.1_5500:Isolated_AF5320443A64781FE8803A9C403E7049', root: DirectoryEntry}
        // fullPath: "/1.js"
        // isDirectory:false
        // isFile:true
        // name: "1.js"
        if (entry.isDirectory) { // 目录                      
          const reader = entry.createReader()
          reader.readEntries((entries) => {
            console.log(entries)
          })
        } else { // 文件
          entry.file((f) => {
            console.log(f)
          })
        }
      }
    }

  </script>
</body>
</html>
```

### vue组建命名规范

大驼峰`<StarRate>`、段横线`<star-rate>`
组件命名：

```js
import StarRate from './StarRate'
export default {
  components: {
    abc: StarRate // abc是组件真实名称
  }
}
```

组件中的name：

```js
export default {
  name: 'StartRate'
}
```

这里name的用途：

+ 组件递归引用
+ 调试工具显示
+ 和keep-alive配合

### 浏览器自动播放策略

1、互动后播放

先尝试自动播放，若发生异常，则引导用户进行互动操作，然后再进行播放

```js
const vdo = document.querySelector('video')
const btn = document.querySelector('.play')
async function play() {
  try {
    await vdo.play()
    btn.style.display = 'none'
    btn.removeEventListener('click', play)
  } catch(e) {
    btn.style.display = 'flex'
    btn.addEventListener('click', play)
  }
}
play()
```

2、互动后出声

先静音播放，然后根据是否能自动播放决定是否取消静音：

1、能自动播放，取消静音
2、不能自动播放，引导用户进行互动操作后取消静音。

```js
const vdo = document.querySelector('video')
const btn = document.querySelector('.play')
function play() {
  vdo.muted = true
  vdo.play()
  const ctx = new AudioContext() // 音频上下文
  const canAutoPlay = ctx.state === 'running' // 音频能够播放
  ctx.close()
  if (canAutoPlay) {
    vdo.muted = false
    btn.style.display = 'none'
    btn.removeEventListener('click', play)
  } else {
    btn.style.display = 'flex'
    btn.addEventListener('click', play)
  }
}
```

### web api

环境： 浏览器、node、微信小程序
ES: EcmaScript，是一个语言标准，定义语法、标准库，是一个标准文档
环境API： 浏览器：Web API

JS：ES + Web API

### 数字字面量

```js
01
// output: 1
08
// output: 8
09
// output: 9
010
// output: 8 // 数字字面量前面加0，尝试转换8进制，转换不成功转成10进制

// 八进制0o
0o8
// output: caught SyntaxError: Invalid or unexpected token
0o10
// output:8
0o11
// output:9

// 十六进制0x
0x123456
// output: 1193046
// 二进制0b
0b010101
// output：21

1e10
// 10000000000
3.14e10
// 31400000000

11.toString()
// VM2977:1 Uncaught SyntaxError: Invalid or unexpected token
// 11.会认为是小数
11..toString()
// '11'
// 第一个点是小数点，第二个点是调用方法的点
```

### 随机数

随机16进制颜色

```js
function randomColor() {
  return '#' + Math.random().toString(16).substring(2, 8).padEnd(6, '0')
}
randomColor()
// '#f371b3'
```

随机字符串：

```js
function randomStr(len = 6) {
    // Math.random().toString(36): '0.d88kqf4iy54' 截取0. 后11位
    if (len <= 11) {
        return Math.random().toString(36).substring(2, 2+len).padEnd(len, '0')
        
    } else {
        return randomStr(11) + randomStr(len - 11)
    }
}
randomStr(20)
// '3oc4csdw5pra4e5zw1tc'
```

### 数字格式化

```js
const str = '100000000000'
// 前瞻运算符匹配位置
const r = str.replace(/\B(?=(\d{3})+$)/g, ',')
console.log(r)
// 100,000,000,000
```

(?=)前瞻运算符匹配位置
(\d{3})+ 连续3个数字匹配1-多次
\B非单词边界，即: ,100,1000,1000, 1前面边界

### 层叠规则

computed style样式计算： 声明、层叠、继承、默认
visual fomatting model视觉格式化模型

层叠：解决样式冲突

+ 比较优先级：
  + 作者样式表!important
  + 默认样式表!important
  + 作者样式表
  + 默认样式表
  
+ 比较特殊性（权重）（四位：?,?,?,?）高位相同比较下一位
  + 第一位：内联样式style为1，否则为0
  + 第二位：元素所属选择器所有的id个数，1个id为1，100个id为100
  + 第三位：元素所属选择器所有的类选择器+属性选择器+伪类选择器的个数
  + 第四位：元素所属选择器所有的元素选择器+伪元素选择器的个数
  
+ 源次序：样式在源代码里面的次序，后面样式覆盖前面

### 布尔类型

+ 布尔类型：ture false
+ 布尔判定：假：null undefined false NaN 0 ''
  if (xxx)
  xxx || yyy
  xxx && yyy
  xxx ? xxx : yyy
+ 短路运算
  xxx || yyy 最后一个运算的是啥就是啥 console.log(0 || NaN) // NaN
  xxx && yyy console.log(0 && NaN) // 0
  obj.a.b.c.d.e:
  obj && obj.a && obj.a.b && obj.a.b.c && obj.a.b.c.d && obj.a.b.c.d.e
  obj?.a?.b?.c?.d?.e

### 赋值运算

```js
var a = { n: 1}
var b = a // {n: 1}
a.x = a = { n: 2} // 
console.log(a.x) // undefined
console.log(b.x) // { n: 2}
```

a.x = (a = {n : 2})
a的内存空间存一个x属性， a = {n : 2}, 给a重新开辟一块内存，a = {n: 2},此时b = {n: 1, x: undefined},
将a = { n: 2}的值赋值给a.x（a.x已经计算过，不再查找）, 即原先a和b共同的内存空间{n: 1, x: undefined}将{n:2}赋值给x，即b = {n:1, x: {n:2}}

### js数据类型和typeof

原始类型：Number、String、Boolean、null、undefined、Symbol、BigInt
对应typeof：number、string、boolean、object、undefined、symbol、bigint
对象类型：Object
对应typeof：object、function

### ssr服务端渲染

什么是 SSR？​
Vue.js 是一个用于构建客户端应用的框架。默认情况下，Vue 组件的职责是在浏览器中生成和操作 DOM。然而，Vue 也支持将组件在服务端直接渲染成 HTML 字符串，作为服务端响应返回给浏览器，最后在浏览器端将静态的 HTML“激活”(hydrate) 为能够交互的客户端应用。

一个由服务端渲染的 Vue.js 应用也可以被认为是“同构的”(Isomorphic) 或“通用的”(Universal)，因为应用的大部分代码同时运行在服务端和客户端。

为什么要用 SSR？​
与客户端的单页应用 (SPA) 相比，SSR 的优势主要在于：

+ 更快的首屏加载：这一点在慢网速或者运行缓慢的设备上尤为重要。服务端渲染的 HTML 无需等到所有的 JavaScript 都下载并执行完成之后才显示，所以你的用户将会更快地看到完整渲染的页面。除此之外，数据获取过程在首次访问时在服务端完成，相比于从客户端获取，可能有更快的数据库连接。这通常可以带来更高的核心 Web 指标评分、更好的用户体验，而对于那些“首屏加载速度与转化率直接相关”的应用来说，这点可能至关重要。

+ 统一的心智模型：你可以使用相同的语言以及相同的声明式、面向组件的心智模型来开发整个应用，而不需要在后端模板系统和前端框架之间来回切换。

+ 更好的 SEO：搜索引擎爬虫可以直接看到完全渲染的页面。

使用 SSR 时还有一些权衡之处需要考量：

+ 开发中的限制。浏览器端特定的代码只能在某些生命周期钩子中使用；一些外部库可能需要特殊处理才能在服务端渲染的应用中运行。

+ 更多的与构建配置和部署相关的要求。服务端渲染的应用需要一个能让 Node.js 服务器运行的环境，不像完全静态的 SPA 那样可以部署在任意的静态文件服务器上。

+ 更高的服务端负载。在 Node.js 中渲染一个完整的应用要比仅仅托管静态文件更加占用 CPU 资源，因此如果你预期有高流量，请为相应的服务器负载做好准备，并采用合理的缓存策略。

在为你的应用使用 SSR 之前，你首先应该问自己是否真的需要它。这主要取决于首屏加载速度对应用的重要程度。例如，如果你正在开发一个内部的管理面板，初始加载时的那额外几百毫秒对你来说并不重要，这种情况下使用 SSR 就没有太多必要了。然而，在内容展示速度极其重要的场景下，SSR 可以尽可能地帮你实现最优的初始加载性能。

SSR vs. SSG​
静态站点生成 (Static-Site Generation，缩写为 SSG)，也被称为预渲染，是另一种流行的构建快速网站的技术。如果用服务端渲染一个页面所需的数据对每个用户来说都是相同的，那么我们可以只渲染一次，提前在构建过程中完成，而不是每次请求进来都重新渲染页面。预渲染的页面生成后作为静态 HTML 文件被服务器托管。

SSG 保留了和 SSR 应用相同的性能表现：它带来了优秀的首屏加载性能。同时，它比 SSR 应用的花销更小，也更容易部署，因为它输出的是静态 HTML 和资源文件。这里的关键词是静态：SSG 仅可以用于消费静态数据的页面，即数据在构建期间就是已知的，并且在多次部署期间不会改变。每当数据变化时，都需要重新部署。

如果你调研 SSR 只是为了优化为数不多的营销页面的 SEO (例如 /、/about 和 /contact 等)，那么你可能需要 SSG 而不是 SSR。SSG 也非常适合构建基于内容的网站，比如文档站点或者博客。事实上，你现在正在阅读的这个网站就是使用 VitePress 静态生成的，它是一个由 Vue 驱动的静态站点生成器。

nuxt.js：一个基于 Vue.js 的服务端渲染应用框架.

### 作用域

作用域规定了如何设置变量，当前执行代码对变量的访问权限
js采用词法作用域即静态作用域，函数定义的时候就已经确定了作用域

```js
var value = 1
function get() {
  console.log(value)
}
function getFn() {
  var value = 2
  get()
}
get() // 1
getFn() // 1
```

变量对象：当前代码段中，所有的变量、函数、形参等组成的对象
全局变量对象variable object VO函数由于被执行才激活actived object AO

### 作用域链

是变量对象的集合，就是变量对象组成的链式结构
js中函数存在一个隐式属性[[scopes]]，保存当前函数的执行上下文，数据结构式链式的，因此被称为作用域链。
一系列AO对象组成的一个链式结构

[[scopes]]在函数声明时产生，在函数调用时更新：在函数调用时，将该函数的AO对象压入unnshift到[[scopes]]中

**作用域链的作用：**
作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，访问到window即终止，作用域链的变量向下访问是禁止的。
函数内部可以访问函数外部的变量，函数外部不可以访问函数内部的变量

函数执行完后作用域链就断开销毁