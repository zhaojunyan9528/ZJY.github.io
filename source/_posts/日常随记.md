---
title: 日常随记
tags:
  - 前端
categories:
  - - 笔记
    - Javascript
date: 2023-11-03 09:49:54
---

## 2023-11-03

### /sockjs-node/info?t=${时间戳}

当运行npm run dev启动项目后，在浏览器的network中会自动持续发送`/sockjs-node/info?t=${时间戳}`请求。

sockjs-node是什么？
sockjs-node是一个JavaScript库，提供跨浏览器的API，创建了一个低延迟、全双工的浏览器和web服务器之间的通道。
在项目运行后，会已知调用该接口。
SockJS是一个JavaScript库。提供类似于websocket的对象。其作用就是在开发环境下，保证我们在改完代码重写编译后，能够通知浏览器重新加载变更结果。

这里理解为这个库用来让浏览器和本地之间热更新通信的。

如果两个地址对接不上，或者更换wifi等都会报错：sockjs-node/info?t= net::ERR_CONNECTION_TIMED_OUT

需要关闭该请求可以找到node_modules/sockjs-client/dist/sockjs.js ，注释代码的第1603行： 

```js
  try {
    // self.xhr.send(payload); 注释掉该行
  } catch (e) {
    self.emit('finish', 0, '');
    self._cleanup(false);
  }
```

以上只在本地有效，重新安装依赖或者别的同事都需要重新修改，可添加脚本，当npm install后替换掉node_modules/sockjs-client/dist/sockjs.js该文件

1.在根目录下新建该文件lib/sockjs.js,拷贝node_modules/sockjs-client/dist/sockjs.js文件并注释掉1603行

2.在根目录下创建installSockjs.js文件，将node_modules对应文件替换为lib/sockjs.js文件

3.在package.json的scripts中添加脚本命令：

```json
"scripts": {
  ...
  "postinstall: node installSockjs.js"
}
```

4.最后npm install即可，但是这样作热更新没有了。

### postinstall干什么的？？？

postinstall是安装完某个包后自动执行的脚本。可以在package.json添加postinstall设置执行的脚本命令，帮我们做一些额外的处理，例如复制文件、创建目录、执行脚本、打印信息等。

例如：将 dist 目录下的所有文件复制到 public 目录下。

```json
"scripts:" {
  "postinstall": "cp -r dist/* public/"
}
```

### 数组扩展运算符

数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。

## 2023-11-22

### 事件循环

事件循环：浏览器的核心

进程：

何为进程：程序运行需要有他自己专有的内存空间，可以把这块内存空间简单的称为进程

每个应用至少有一个进程，进程之间相互独立，即使通信也要双方同意。

何为线程：
有了进程后，就可以运行程序，运行程序的称为线程。
一个进程至少有一个线程，所以在进程开启后会自动创建一个线程来运行代码，这个线程称为主线程。
如果程序需要同时运行多块代码，主线程会启动更多的线程来运行代码。所以一个进程可以包含多个线程。

浏览器有哪些进程和线程？

浏览器是一个多进程多线程的应用程序。

浏览器内部及其复杂，为了避免互相影响，减少崩溃的几率，启动浏览器后，会启动多个进程。

浏览器进程、网络进程、渲染进程 等

浏览器主要进程有：

浏览器进程：
负责界面显示、用户交互、子进程管理等，浏览器进程会开启多个线程执行任务。

网络进程：
负责加载网络资源。网络进程内部会开启多个线程来执行不同的网络任务。

渲染进程：
渲染进程开启后，会启动一个渲染主线程，主线程负责html、css、js代码。

默认情况下，浏览器为每一个标签页开启一个新的渲染进程，保证不同标签页互不影响。

事件循环发生在渲染主线程。

渲染主线程是如何工作的？

渲染主线程是浏览器最繁忙的线程，需要它处理的任务包括但不限于：

+ 解析html
+ 解析css
+ 计算样式
+ 布局
+ 处理图层
+ 每秒把页面画60次
+ 执行全局js代码
+ 处理事件监听函数
+ 执行定时器的回调函数
+ ...

渲染主线程如何调度任务呢？排队

1、最开始的时候，渲染主线程进入一个无限循环
2、每一次循环会检查事件队列（消息队列）是否有任务存在，如果有，取出第一个任务在主线程执行，执行完后进入下一个循环；如果没有则进入休眠
3、其他所有线程（包括其他进程的线程）可以随时向事件队列添加任务，新任务会添加到事件队列的末尾。在添加新任务时如果主线程处在休眠状态则会唤醒以继续循环拿取任务。

以上整个过程称为事件循环。

何为异步？

代码在执行过程中，会遇到无法立即处理的任务，比如：

+ 计时完成后需要执行的任务：setTimeout setInterval
+ 网络通信完成后需要执行的任务：xhr fetch
+ 用户操作后要执行的任务：addEventListener

如果让渲染主线程等待这些任务的时机到达，就会导致主线程阻塞，造成浏览器卡死。因此浏览器选择异步来解决问题。

比如：渲染主线程遇到计时器，通知计时线程去计时，结束该任务，继续循环从事件队列拿取任务，计时线程计时结束后将回调函数包装成任务放进事件队列末尾。

使用异步的方式，渲染主线程永不阻塞。

### 如何理解js中的异步？

js是一门单线程的语言，运行在浏览器的渲染主线程内，渲染主线程只有一个，承担很多任务，比如解析html、css、计算样式、布局、执行js代码等。如果使用同步的方式就有可能阻塞主线程，导致事件队列的其他任务不能执行，造成渲染主线程白白浪费，页面无法更新，给用户造成卡死现象。
所以浏览器使用异步的方式来避免。具体做法是某些任务发生时，如计时器、网络、事件监听，主线程交给其他线程去处理，自身立即结束任务，执行后续代码。当其他线程执行结束时，就将事先传递回调函数包装成任务加入到事件队列末尾，等待主线程调度执行。
在这种异步模式下，浏览器永不阻塞，最大限度的保证了单线程的流畅运行。

js为何会阻碍渲染？

```js
let h1 = document.getElementsByTagName('h1')[0]
let btn = document.getElementsByTagName('button')[0]
function delay(duration) {
  let start = Date.now()
  while(Date.now() - start < duration) {}
}
btn.onclick = function(e) {
  h1.textContent = 'hahah'
  console.log('onclick')
  delay(3000)
}
```

以上代码点击按钮时，会打印onclick，延时3秒后h1显示‘hahah’，因为delay方法占据主线程运行3秒，h1.textContent绘制需要事件队列排队等待，造成页面阻塞。

任务有优先级吗？
任务没有优先级，在队列中先进先出
但是事件队列是有优先级的。
根据w3c最新解释：

+ 每个任务都有一个类型，同一个类型的任务必须在同一个队列，不同类型的任务可以分属于不同的队列。再一次事件循环中，浏览器可以根据实际情况从不同的队列取出任务执行。
+ 浏览器必须有一个微队列，微队列中的任务优先于其他任务执行

随着浏览器的复杂度上升，w3c不再使用宏队列的说法

在目前chrome的实现中，至少包含以下队列：

+ 延时队列：用于存放计时器的回调任务，优先级【中】
+ 交互队列：用于存放用户操作后的回调任务，优先级【高】
+ 微队列：用户存放最快执行的任务，优先级【最高】

添加到微队列的方式主要是Promise、MutationObserver
例如：

```js
立即把一个函数添加到微队列
Promise.resolve().then(函数)
```

示例1：

```js
setTimeout(function() {
  console.log(1) // fn1
}, 0)
console.log(2)
```

输出： 2、1

主线程：全局js
微队列：
延时队列：fn1
交互队列：

解析：主线程执行全局js，遇到setTimeout，计时线程0秒后将fn1放入延时队列-》继续执行全局js-》输出2-》全局js结束，主线程空，微队列空，执行延时队列fn1-》输出1

示例2:

```js
function delay(duration) {
  let start = Date.now()
  while(Date.now() - start < duration) {}
}
setTimeout(() => {
  console.log(1)
}, 0)
delay()
console.log(2)
```

输出：等待3秒、2、1

解析：主线程执行全局js，遇到setTimeout，计时线程0秒后将fn1放入延时队列-》继续执行全局js-》执行delay函数3秒-》输出2-》全局js结束，主线程空，微队列空，执行延时队列fn1-》输出1

示例3:

```js
setTimeout(() => {
  console.log(1) // 回调fn1
}, 0)
Promise.resolve().then(function() {
  console.log(2) // 回调fn2
})
console.log(3)
```

输出：3、2、1

主线程：全局js
微队列：fn2
延时队列：fn1
交互队列：

解析：
  主线程执行全局js，遇到setTimeout，计时线程0秒后将fn1放入延时队列
  继续全局js执行，遇Promise，立即将fn2添加到微队列
  继续全局js，输出3
  全局js结束，主线程空，微队列不为空，执行fn2
  输出2，fn2结束，继续循环
  微队列空，延迟队列不为空，执行fn1
  输出1，fn1结束，继续循环

示例4:

```js
function a() {
  console.log(1)
  Promise.resolve().then(function() {
    console.log(2) // fn2
  })
}
setTimeout(() => { // fn3
  console.log(3)
  Promise.resolve().then(a) // fn(a)
}, 0)
Promise.resolve().then(function() {
  console.log(4) // fn4
})
console.log(5)
```

输出：5、4、3、1、2

主线程：全局js
微队列：fn4->fn(a)->fn2
延时队列：fn3
交互队列：

解析：
  主线程执行全局js，遇到setTimeout，计时线程0秒后将fn3放入延时队列
  继续全局js执行，遇Promise，立即将fn4添加到微队列
  继续全局js，输出5
  全局js结束，主线程空，微队列不为空，执行fn4
  输出4，结束任务，继续循环，微队列空，查询延时队列不为空
  执行fn3，输出3、遇Promise，立即将fn(a)添加到微队列，结束该任务，继续循环
  微队列不空，执行fn(a)，输出1，遇Promise，立即将fn2添加到微队列，结束该任务，继续循环
  微队列不空，执行fn2，输出2，结束该任务

示例5:

```js
function a() {
  console.log(1)
  Promise.resolve().then(function() {
    console.log(2) // fn2
  })
}
setTimeout(() => { 
  console.log(3) // fn3
}, 0)
Promise.resolve().then(a) // fn(a)
console.log(4)
```

输出：4、1、2、3

主线程：全局js
微队列：fn(a)->fn2
延时队列：fn3
交互队列：

解析：
  主线程执行全局js，遇到setTimeout，计时线程0秒后将fn3放入延时队列
  继续全局js执行，遇Promise，立即将fn(a)添加到微队列
  继续全局js，输出4
  全局js结束，主线程空，微队列不为空，执行fn(a)
  输出1，遇Promise，立即将fn2添加到微队列，结束该任务，继续循环
  微队列不空，执行fn2，输出2，结束该任务，继续循环
  微队列空，延时队列不空，执行fn3，输出3，结束该任务

阐述js的事件循环：

事件循环又叫做消息循环，是浏览器的渲染主线程的工作方式。

在chrome中开启一个无限循环，每次循环从队列中取出第一个任务执行，而其他线程只需要在合适的时机将任务添加到队列末尾。
过去把消息队列分为宏队列和微队列，这种说法无法满足复杂的浏览器环境，取而代之的是另一钟灵活的处理方式。

根据w3c官方解释，每个任务都有一个类型，同一个类型的任务必须在同一个队列，不同任务属于不同的队列。
不同的任务队列有不同的优先级，在一次事件循环中，浏览器自行决定选取哪一个队列的任务。但浏览器必须有一个微队列，微队列具有最高的优先级，必须优先调度执行。

### js中计时器能做到精准计时吗？

不能，因为：

+ 计算机硬件没有原子钟，无法做到精准计时
+ 操作系统的计时函数本身就有偏差，js计时器最终调用的是操作系统的函数，所以携带了偏差
+ 按照w3c的标准，浏览器实现计时器，嵌套超过5层，则会带有4毫秒的最小偏差，计时少于4毫秒又带来偏差
+ 受事件循环的影响，计时器的回调函数只能在主线程空闲时执行，因此带来偏差

单线程是异步产生的原因
事件循环是异步的实现方式

### 浏览器的渲染原理

当浏览器的网络线程收到HTML文档后，会产生一个渲染任务，并将其传递到渲染主线程的消息队列。
在事件循环机制下，渲染主线程取出渲染任务，开启渲染流程。

整个渲染流程分为多个阶段，分别是：HTML解析、样式计算、布局、分层、绘制、分块、光栅化、画。
每个阶段都有明确的输出，上一个阶段的输出是下一个阶段的输入。
这样，整个阶段就成为一段严密的流水线。

***HTML字符串-〉解析HTML-〉样式计算-〉布局-〉分层-〉绘制-〉分块-〉光栅化-〉画-〉像素信息***
渲染：将html字符串->像素信息

#### 1.解析HTML

**
解析过程中遇到css，解析css，遇到js解析js。为了提高效率，浏览器在解析前，会启动一个预解析的线程，率先下载HTML中外部的css文件和外部的js文件。
如果主线程解析到link位置，此时外部的css文件还没有解析下载好，主线程不会等待，继续后续HTML的解析。这是因为下载和解析css是在与解析线程中进行的。这就是css不会阻塞HTML解析的根本原因。
如果主线程解析道script位置，主线程会停止解析HTML，转而等待js文件下载好，并将全局代码解析完成后，才继续解析HTML。这是因为js代码可能会修改当前的DOM树，所以DOM生成必须暂停。这就是js会阻塞HMTL解析的根本原因。
第一步完成后，会生成CSSOM树和DOM树，内部样式、外部样式、内联样式、浏览器默认样式都会包含在CSSOM树。
**

渲染的第一步是解析HTMl，ParseHTML，产生DOM树（Document Object Model）和CSSOM树(css Object Model)

css样式包括：内部样式style，外部样式link，内联样式，浏览器默认样式
js修改style样式，docu.style = ''
js修改`<style>`和外部样式，document.styleSheets[0].addRule('div', 'border: 1px solid #f40')

解析HTML，遇到css代码怎么办？
为了提高效率，浏览器会启动一个预解析器率先下载和解析css，css不会阻塞解析HTML。

#### 2、样式计算- recalculate style

**
主线程遍历整个DOM树，依次为每一个节点计算出最终样式，computed style，
在这个过程中，很多预设值会变成绝对值，比如red会变成rgb(255, 0, 0); 相对单位会变成绝对单位，比如em会变成px。
这一步完成后，会得到一颗带样式的DOM树
**

getComputedStyle()获取最终样式

#### 3、布局-Layout

**
接下来是布局，布局完成后会得到布局树。
布局阶段会依次遍历DOM树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。
大部分时候，DOM树和布局树不是一一对应的。
比如dislay:none没有几何信息，因此不会生成到布局树中，又比如使用伪元素选择器，虽然DOM树中不存在这些伪元素节点，但是他们拥有几何信息，所以会生成到布局树。
**

DOM树和布局树不是一一对应的。有几何信息的才会在布局树中出现，display：none不出现
文本内容必须放在行盒中。

document.body.clientWidth,获取的布局信息

#### 4、分层

**
主线程会使用一套复杂的策略对布局树进行分层。
分层的好处在于，将来某一层改变后，仅对该层进行后续处理，从而提高效率。

滚动条、堆叠上下文、transform、opacity等样式都会影响分层结果。will-change熟悉会更大程度影响分层。
**

#### 5、绘制

**
主线程会为每个层单独产生绘制指令集，用于描述每个层的内容该如何画出来。
完成绘制后，主线程将绘制信息提交给合成线程，后续工作交由合成线程完成。
**

#### 6、分块

合成线程会对每个图层进行分块，将其划分为更小的区域。
它会从线程池中拿更多线程来完成分块工作。

分块完成后进入光栅化阶段。

#### 7.光栅化

合成线程将块交由GPU进程，完成光栅化，极高速度。
GPU进程会开启多个线程完成光栅化，并且优先处理靠近视口区域的块。
光栅化的结果是一块一块的位图。

#### 8.画

合成线程计算出每个位图的在屏幕上的位置，交由GPU进程最终呈现。

渲染进程（在沙盒，隔离硬件，安全）：渲染主线程、合成线程

所以交由GPU进程

transform发生在合成线程，与渲染主线程无关所以效率高。

### 什么是reflow？

渲染主线程：parse----computed style----layout----layer----paint
合成线程：----tiling分块----raster光栅化----draw-〉

cssom
dom
几何信息、布局

reflow的本质是重新计算布局树。
当进行了会影响布局树的操作后，会重新计算布局树，引发layout。
为了避免连续多次的操作导致布局树多次计算，浏览器会合并这些操作。当js代码全部执行完后统一计算。所以改动属性引发的reflow是异步的。

因此js获取布局属性时，可能是重新布局前的信息，无法获取最新的布局信息，浏览器在反复权衡下，最终决定获取熟悉立即reflow。

doc.style.width = ''
doc.style.height = ''
doc.style.margin = ''
doc.clientWidth // 立即reflow

### 什么是repaint？

repaint本质是重新根据分层信息计算了绘制指令。
当改动了可见样式就需要重新计算，引发repaint。
由于元素的布局信息也属于可见样式，所以reflow一定引发repaint。

### 为什么transform的效率高？


因为transform既不影响布局也不影响绘制，它影响的是渲染流程的最后一个阶段draw。
由于draw阶段在合成线程，所以transform的变化几乎不影响渲染主线程。反之，渲染主线程也不会影响transform的变化。