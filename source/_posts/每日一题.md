---
title: 每日一题
tags:
  - 前端
categories:
  - - 问题&总结
    - Javascript
date: 2022-03-28 09:40:12
---

### 1.js中 ?? 和 || 的区别？

```js
value1  ??  value2
value1  ||  value2
```

相同点：

  用法相同，都是符号前后是值，中间是符号。根据前面的值判断返回value1还是value2。

不同点：

  1.使用??时，只有当value1的值为null或undefined时才返回value2，否则返回value1
  2.使用||时，value1会转换为bool值，为true时返回value1,  false时返回value2

??更适合不知道变量是否有值时使用

### 2.URI和URL的区别

1.URI：统一资源标识符（Uniform Resource Identifier,URI）是一个标识某个互联网资源的字符串。表示Web上可用的每种资源-html文档、图像、视频片段、程序等由一个URI进行标识。

URI格式：[协议名]://[用户名]:[密码]@[服务器地址]:[端口号]/[路径]?[查询字符串]#[片段id]

2.URL：统一资源定位符（Uniform Resource Locator），采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL是URI概念的一种实现方式。

URL下列三部分组成:第一部分是协议（或称为服务方式）；第二部分是存有该资源的主机IP地址（有时也包括端口号）；第三部分是主机资源的具体地址。

3.URI和URL之间的区别

URI和URL都定义了资源是什么，但URL还定义了该如何访问资源。URL是一种具体的URI，它是URI的一个子集，它不仅唯一标识资源，而且还提供了定位该资源的信息。URI 是一种语义上的抽象概念，可以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位，是绝对的。

### 3.Http中的301，302，303，307，308相应状态码

1、301 Move Permanently

  表明资源永久的移动到了一个新的URI，任何未来对这个资源的引用都应该使用新的URI

2、302 Found

  表明资源临时的移动到了一个新的URI，由于重定向是临时的，所以之后的请求还应该使用原本的URI
  服务器会在响应头的Location字段放上这个不同的URI，浏览器可以使用这个URI进行自动重定向
  注：由于历史原因，用户代理可能会在重定向后把请求的post改为get方法。

3、303 See Other

  303 状态码表示服务器要将浏览器重定向到另一个资源，这个资源的 URI 会被写在响应 Header 的 Location 字段。从语义上讲，重定向到的资源并不是你所请求的资源，而是对你所请求资源的一些描述。
  303 常用于将 POST 请求重定向到 GET 请求，比如你上传了一份个人信息，服务器发回一个 303 响应，将你导向一个“上传成功”页面。
  不管原请求是什么方法，重定向请求的方法都是 GET（或 HEAD，不常用）

4、307 Temporary Redirect

  307 的定义实际上和 302 是一致的，唯一的区别在于，307 状态码不允许浏览器将原本为 POST 的请求重定向到 GET 请求上

5、308 Permanent Redirect

  308 的定义实际上和 301 是一致的，唯一的区别在于，308 状态码不允许浏览器将原本为 POST 的请求重定向到 GET 请求上

6、302和303、307的关系

302允许各种各样的重定向，一般情况下都会重定向到get，但不能确保post重定向到post
303只允许任意请求重定向到get
307和302一样，但不允许post到get的重定向

### 4.link和@import引入css的区别？

1、link是HTML的的标签，除了链接样式表还可以设置RSS，rel等属性，@import只能加载css
2、link会在页面加载时同时加载，@import会在页面加载完成后再加载
3、link无兼容性问题，@import是在css2.1提出，低版本浏览器不支持
4、可以通过js操作dom将link样式表插入文档改变样式，@import不支持

### 5.圣杯布局和双飞翼布局

三栏布局，两边固宽

圣杯布局：三栏利用float和负margin并列，利用父容器的padding给两边空出空间

```html
<div class="container">
  <div class="main">
    <p>圣杯布局</p>
    <p>hahahhaha</p>
  </div>
  <div class="left">left</div>
  <div class="right">right</div>
</div>
```

```css
* {
  padding: 0;
  margin: 0;
}
.container {
  padding: 0 60px 0 30px;
  height: 150px;

}
.main {
  float: left;
  width: 100%;
  height: 150px;
  background-color: aquamarine;
}
.left {
  float: left;
  width: 30px;
  height: 100px;
  background-color: darkkhaki;
  margin-left: calc(-100% - 30px);
}
.right {
  float: left;
  width: 60px;
  height: 100px;
  background-color: firebrick;
  /* margin-left: -60px;
  position: relative;
  left: 60px; */
  margin-right: -60px;
}
```

双飞翼布局：三栏利用float和负margin并列，中间栏加一层容器，利用margin给两栏空出空间

```html
<div class="container1">
  <div class="main1">
    <div class="content">
      <p>双飞翼布局</p>
      <p>hahahhaha</p>
    </div>
  </div>
  <div class="left1">left1</div>
  <div class="right1">right1</div>
  </div>
</div>
```

```css
* {
  padding: 0;
  margin: 0;
}
.container1 {
  width: 100%;
  height: 150px;
  border-top: 1px solid;
}
.container1 .main1 {
  float: left;
  width: 100%;
}
.content {
  height: 150px;
  background-color: aquamarine;
  margin: 0 60px 0 30px;
}
.left1 {
  float: left;
  width: 30px;
  height: 100px;
  margin-left: -100%;
  background-color: darkkhaki;
}
.right1 {
  float: left;
  width: 60px;
  height: 100px;
  margin-left: -60px;
  background-color: firebrick;
}
```

flex布局也可实现三栏布局

```html
<div class="container2">
  <div class="left2">left2</div>
  <div class="main2">
    flex
  </div>
  <div class="right2">right2</div>
</div>
```

```css
.container2 {
  width: 100%;
  height: 150px;
  border-top: 1px solid;
  display: flex;
  flex: 1 1 auto;
}
.main2 {
  height: 150px;
  background-color: aquamarine;
  width: 100%;
}
.left2 {
  width: 30px;
  height: 100px;
  background-color: darkkhaki;
}
.right2 {
  width: 60px;
  height: 100px;
  background-color: firebrick;
  flex-shrink: 0;
}
```

![image](/images/buju.jpg)

圣杯和双飞翼中间栏放首位可保证首先渲染，但是中间栏宽度小于左栏会页面错乱

### 6.用递归算法实现，数组长度为5且元素的随机整数数在2-32间不重复的值

```js
function randomArr5(arr) {
  arr = arr || []
  if (arr.length === 5) return arr
  let num = 2 + Math.floor(Math.random() * 31)
  if (!arr.includes(num)) arr.push(num)
  return randomArr5(arr)
}
randomArr5() // [30, 19, 28, 3, 11]
```

随机数2-32，数组长度5且元素不重复，递归

### 7. html的元素有哪些（包含h5）？

块元素：
html、body、head、header、nav、section、main、aside、footer页面结构
article、h1-h6、p 文章
div
ul、ol、li、dl、dt、dd 列表
table、tr、td、thead、tbody表格
form表单

行内元素：
a(inline)
span(inline)
img(inline)
strong(inline)、i(inline)、em(inline)文本内容
label(inline)
canvas(inline)
audio(inline,无controls值为none)、video(inline)媒体

行内块元素：
input(inline-block)
select(inline-block)
button(inline-block)

### 8.css3新特效有哪些？

1.边框属性
border-image(边框图片)、border-radius(边框圆角)、box-shadow(边框阴影)

2.背景属性
backgrou-image: url(),url();多背景图片
background-clip: border-box/padding-box/content-box;背景图片绘制区域，默认border-box图片被剪裁到边框盒
background-origin: padding-box/border-box/content-box;图片相对于什么位置定位，默认值padding-box
background-size: auto/cover/contain/length/%;景图像的尺寸

3.文本属性
text-shadow文本阴影
word-wrap: normal/break-word; 允许长单词或URL换行
word-break: normal/keep-all(只允许在半角空格或连字符处换行)/break-all(允许在单词内换行)

4.transform属性
2D或3D变换，允许元素进行旋转、移动、缩放、倾斜
transform：

+ none：不进行任何转换
+ matrix(n,n,n,n,n,n):定义2D转换，使用六个值的矩阵
+ matrix3d(n,…n):定义3D转换，使用16个值的矩阵
+ translate(x,y):定义2D转换
+ translate3d(x,y,z): 定义3D转换
+ translateX(x): 定义转换，只是用 X 轴的值。
+ translateY(y): 定义转换，只是用 Y 轴的值。
+ translateZ(z): 定义转换，只是用 Z 轴的值。
+ scale(x,y): 定义2D缩放转换
+ scale3d(x,y,z): 定义3D缩放转换
+ scaleX(x): 通过设置 X 轴的值来定义缩放转换。
+ scaleY(y): 通过设置 Y 轴的值来定义缩放转换。
+ scaleZ(z): 通过设置 Z 轴的值来定义缩放转换。
+ rotate(angle): 定义 2D 旋转，在参数中规定角度
+ rotate(x,y,angle): 定义3D旋转
+ rotateX(angle): 定义沿着 X 轴的 3D 旋转
+ rotatezY(angle): 定义沿着 Y 轴的 3D 旋转
+ rotateZ(angle): 定义沿着 Z 轴的 3D 旋转
+ skew(x-angle,y-angle): 定义沿着x轴和y轴倾斜转换
+ skewX(angle): 定义沿着X轴的2D倾斜转换
+ skewY(angle):定义沿着y轴的2D倾斜转换

5.过渡动画transition
transition: property duration timing-function delay;

```css
transion: width 2s;
div:hover {
  width: 30px;
}
```

6.animation动画

```css
div{
  animation: myFirst 5s;
}
@keyframes myFirst{
  from {
    background-color: red;
  }
  to {
    background-color: yellow;
  }
}
```

7.弹性盒子flexbox

8.多媒体查询@media

9.渐变
linear-gradient 线性渐变
radial-gradient 径向渐变

### 9.写一个方法去掉字符串中的空格，要求传入不同的类型分别能去掉前、后、前后、中间的空格

```js
function trim(str, type = 'all') {
    const Type = {
        left: /^\s+/g,
        right: /\s+$/g,
        all: /\s+/g,
        both: /^\s+|\s+$/g
    }
    if (type === 'center') {
        let leftStr = str.match(/^\s+/g)[0]
        let rightStr = str.match(/\s+$/g)[0]
        return leftStr + str.replace(/\s+/g,'') + rightStr
    }
    return str.replace(Type[type], '')
}
let strs = '  12 3  4  56 '
trim(strs) // all '123456'
trim(strs, 'left') // left '12 3  4  56 '
trim(strs, 'right') // right '  12 3  4  56'
trim(strs, 'both') // both '12 3  4  56'
trim(strs, 'center') // center '  123456 '
```

### 10.HTML全局属性（global attribute）有哪些？

全局属性是所有HTML元素共有的属性，它们可以用于所有元素，即使属性对某些元素不起作用。

1.accesskey提供了为当前元素生成键盘快捷键的提示。

```html
<input type="text" accesskey="n">
```

windows系统使用alt+n快捷键可快速选择对应元素
mac系统使用crtl+option+n快捷键

2.autocapitalize控制用户输入如何自动大写

3.class

4.contenteditable元素是否可以被编辑

5.data-* 自定义数据属性

6.dir指示元素中文本方向的枚举属性（ltr、rtl、auto）

7.draggable,枚举属性，指示是否可以使用Drog盒Drop API拖动元素

8.hidden隐藏元素

9.id唯一标识符

10.lang：定义元素的语言，xml:lang优先于它

11.spellcheck:是否启动拼写和语法检查

12.slot插槽，具有slot属性的元素被分配给由`<slot>`元素创建的沟槽，其name属性的值与slot属性的值匹配。

13.style内联样式

14.tabindex规定元素的tab键控制次序

15.title

16.translate页面本地化时是否转换元素的属性值及其Text 节点子节点的值

17.还有事件处理程序属性：onabort, onautocomplete, onautocompleteerror, onblur, oncancel, oncanplay, oncanplaythrough, onchange, onclick, onclose, oncontextmenu, oncuechange, ondblclick, ondrag, ondragend, ondragenter, ondragexit, ondragleave, ondragover, ondragstart, ondrop, ondurationchange, onemptied, onended, onerror, onfocus, oninput, oninvalid, onkeydown, onkeypress, onkeyup, onload, onloadeddata, onloadedmetadata, onloadstart, onmousedown, onmouseenter, onmouseleave, onmousemove, onmouseout, onmouseover, onmouseup, onmousewheel, onpause, onplay, onplaying, onprogress, onratechange, onreset, onresize, onscroll, onseeked, onseeking, onselect, onshow, onsort, onstalled, onsubmit, onsuspend, ontimeupdate, ontoggle, onvolumechange, onwaiting

### 11.页面上隐藏元素的方法有哪些？

1.给元素设置hidden属性，不占位
2.display:none;不占位
6.width:0;height:0;transform:scale(0);不占位
3.visibility:hidden;占位
4.opacity: 0;/filter: opacity(0);占位
5.filter: opacity(0);占位
7.width:0;height:0;overflow:hidden;有些元素有border值依然会占位，有宽高
8.position:absolute;left/margin-left:-1000%;脱离文档流不占位
9.position:absolute;z-index: -1;脱离文档流不占位,但是后面元素只是盖在该元素上面，如果后面元素比该元素小只会隐藏一部分
10.font-size:0;不占位仅对文本内容有效

### 12.去除字符串中最后一个指定的字符

```js
function delChar(str, char){
  if(typeof str !== 'string') {
    console.log('not string')
    return
  } else {
    let lastIndex = str.lastIndexOf(char)
    if (lastIndex != -1) {
      return str.substring(0, lastIndex) + str.substring(lastIndex + char.length)
    }
    console.log('not find ',char)
  }
}
delChar('abniok9866dasd%fnad#fv%vvv', 'd#') // 'abniok9866dasd%fnafv%vvv'

// 正则
function delLastAnyChar(str, char) {
  // [^]表示任意字符 .查找单个字符除换行和行结束符，单行模式下，[^]就是.,但是多行模式下，[^]可以匹配到\n
  // [^]*表示任意长度字符 ()表示元组，$1表示匹配到的第一个()内容
  let reg = new Reg(`(^[^]*)(${char})([^]*$)`)
  return str.replace(reg, '$1$3')
}
delLastAnyChar('acdabdbde', 'bd') // acdabde
```

### 13.HTML5离线存储方式有哪些，怎么使用，原理是什么？

浏览器检测是否在线 navigator.onLine 返回true/false

查看{% post_link HTML5存储方式 %}

### 14.css选择器有哪些？哪些属性可继承？

**选择器:**

+ 通用选择器  * 匹配文档内所有元素
+ 元素选择其 elementName
+ 类选择器 .className
+ id选择器 #idName
+ 组合选择器
  + element,element  h1,h2 {}
  + element element  body h1 {} 嵌套选择器或后代选择器
  + element > element  div > p, ul > li
  + element + element  div + p 相邻同级选择器
  + element1～element2  p~ul p和ul具有相同的父元素， ul在p后面，不必紧跟
+ 属性选择器
  + [attr]  a[class] a[target]
  + [attr=value]  p[class="title"]
  + [attr`~`=value] p[class`~`="test"] 包含指定属性值的元素，基于属性值空格分隔开的属性("test a"包含，"test_a"不包含)
  + [attr|=value] [lang|=en] 用于选择指定属性具有指定值开始的元素(en-us,en)
  + [attr^=value] [class^="test"] 匹配元素属性值带指定的值开始的元素(test,test_a)
  + [attr$=value] [class$="test"] 匹配元素属性值带指定的值结尾的元素(test, a_test)
  + [attr*=value] [class*="test"] 匹配元素属性值包含指定值的元素(test,a_test,test_a)
+ 伪类选择器
  :active,:after,:before,:checked,:disabled,:empty,:enabled,:first-child,:first-letter,:first-of-type,:focus,:hover,:in-range,:invalid,:lang(),:last-child,:last-of-type,:link,:not,:nth-child(),:nth-last-child(),:nth-last-of-type(),:nth-of-type(),:only-child,:optional,:out-of-range,:read-only,:read-write,:required,:root,::selection,:target,:valid,:visited

**可继承的属性:**

+ 字体系列属性
  font-family,font-weight,font-size,font-style,font-variant,font-stretch,font-size-adjust
+ 文本系列属性
  text-align, line-height, word-spacing, letter-spacing, text-transform, direction, color
+ 元素可见性
  visibility, opacity
+ 表格布局属性
+ 列表属性
+ 光标属性 cursor
...

### 15.写一个方法把下划线命名转成大驼峰命名

```js
function toCamelCase(str) {
  if (str.split('_').length === 1) return
  let arr = str.split('_')
  let res = ''
  arr.forEach(item => {
      res =  res + item.substr(0,1).toUpperCase() + item.substr(1)
  })
  return res
}
toCamelCase('a_project_name_title') // 'AProjectNameTitle'

// 正则
function toCamelCase(str) {
    if (!str.length) return
    str = str.replace(/(_)(\w)/g, (match,$1,$2) => {
        return $2.toUpperCase()
    })
    return str.substr(0,1).toUpperCase() + str.substr(1)
}
toCamelCase('test_project_container') // TestProjectContainer

function toCamelCase(str){
    return str.replace(/(^|_)(\w)/g,(m,$1,$2)=>$2.toUpperCase());
}
toCamelCase('test_project_container') // TestProjectContainer
```

### 16.简述超链接target属性的取值和作用

|target值 |作用 |
|:---:|:---:|
|_blank |在新的窗口打开被链接的文档|
|_self|默认，在相同框架中打开被链接的文档|
|_parent|在父框架集中打开被链接的文档|
|_top|在整个窗口中（最顶层框架集）打开被链接的文档|
|framename|在指定的框架中打开被链接的文档|

### 17.CSS3新增伪类有哪些并简要描述？

|新增伪类 |作用 |
|:---:|:---:|
|:first-of-type|p:first-of-type 选择的每个 p 元素是其父元素的第一个 p 元素|
|:last-of-type|p:last-of-type 匹配元素其父级是特定类型的最后一个子元素|
|:only-of-type|p:only-of-type 匹配p的父元素的唯一子元素p|
|:only-child|p:only-child 匹配p元素的父元素唯一的子元素p元素|
|:nth-child(n)|p:nth-child(2) 选择所有 p 元素的父元素的第二个子元素(不是第二个子p元素)|
|:enabled|input:enabled 选择所有启用的元素|
|:disabled|input:disabled 选择所有禁用的元素|
|:checked| input:checked 选择所有选中的元素|
|:empty|p:empty 选择所有没有子元素的p元素|
|:focus|input:focus 选择元素输入后具有焦点|
|:root|选择文档的根元素|

### 18.写一个把字符串大小写切换的方法？

例：aBcdEFg --> AbCDefG

```js
function caseConvert(str) {
    let res = ''
    for(let i of str) {
        res+= i.toLowerCase() === i ? i.toUpperCase() : i.toLowerCase()
    }
    return res
}
caseConvert('aBcdEfGD') // AbCDeFgd
// 正则
function caseConvert(str){
  return str.replace(/([a-z]*)([A-Z]*)/g, (m, s1, s2)=>{
    return `${s1.toUpperCase()}${s2.toLowerCase()}`
  })
}
caseConvert('例：aBcdEFg') // AbCDefG
```

### 19.label都有哪些作用？

1.关联表单控件，扩大点选范围
2.关联表单控件，聚焦到关联输入框
3.为input元素定义的标记
4.利用label"模拟"button来解决不同浏览器原生button样式不同的问题

### 20. 用css创建一个三角形，并简述原理

当width和height为0时，设置border会将其分割成45度的等腰三角形，设置上下左右border宽度或颜色透明即可得到三角形

```css
width: 0;
height: 0;
display: inline-block;
border: 10px solid red;
border-bottom-color: transparent;
border-left-color: transparent;
border-right-color: transparent;
```

若要获取左直角等三角形，只需修改上下左右边框颜色透明

### 21.写一个去除制表符和换行符的方法

```js
function removeTab(str) {
  return str.replace(/\n|\t/g, '')
}
removeTab('h\taha\nfdals') // hahafdals
```

### 22.iframe框架都有哪些优缺点?

缺点：
1.会产生多个页面，不容易管理
2.多iframe的页面会增加服务器的http请求
3.每个iframe对应一个页面，其多余的css和js文件的载入会增加请求的开销
4.window.onload事件会在所有的iframe加载完成后才触发，会造成页面阻塞
5.如果iframe内有滚动条，会影响用户的使用体验
6.代码复杂，无法被一些搜索引擎索引到，对搜索引擎不友好

优点：
1.投放广告之类的飘窗无疑是最好的选择
2.重载时只需要重载页面中的一个iframe，不需要重载整个页面
3.可以实现异步刷新，单个iframe刷新不影响整个窗口的刷新（在FormData无法使用时，可以实现无刷新上传）
4.可以实现跨域，每个iframe的源可以不相同（方便引入第三方内容）
5.多页面应用时，对于共同的header，footer可以使用iframe加载，拆分代码（方便制作导航栏）
6.技术容易掌握。可主要应用于不需要搜索引擎来搜索的页面

### 23.简述你对BFC规范的理解

查看{% post_link css-BFC %}

### 24.统计某一字符或字符串在另一个字符串中出现的次数

```js
function countTarget(str, target) {
    let count = 0
    while(target.match(str)) {
        target = target.replace(str, " ")
        count++
    }
    return count
}
function countTarget(str, target) {
  return target.match(new RegExp(str, 'g')).length
}
countTarget("ad", "dasdlajdadeorwad") // 2
```

### 25.清除浮动的方式有哪些及优缺点

1.触发父元素BFC
如给父元素设置overflow:hidden，特别注意的是：在IE6中还需要触发hasLayout，例如给父元素设置zoom:1

原理是触发父级BFC后，父元素在计算高度时，浮动的子元素也会参与计算

优点
代码简洁

缺点
设置overflow:hidden容易造成不会自动换行导致超出的尺寸被隐藏掉，无法显示要溢出的元素

2.给父元素设置高度
优点
代码简洁

缺点
不够灵活，只适用于高度固定的布局

3.添加额外标签
在最后一个浮动元素的后面新加一个标签如

，并在其CSS样式中设置clear: both
优点
代码简洁，兼容性好

缺点
额外增加无语义html元素，代码语义化差，后期维护成本大

4.使用after伪元素

```css
.clearfix::after {
  content: ".";
  display: block;
  height: 0;
  line-height: 0;
  clear: both;
  visibility:hidden;
  font-size: 0;
}

.clearfix {
  // 注意此处是为了兼容IE6和IE7浏览器，即触发hasLayoutcs
  zoom: 1;
}
```

优点
符合闭合浮动思想，结构语义化正确

缺点
代码量多，因为IE6-7下不支持after伪元素，需要额外写 zoom:1来 触发hasLayout

### 26.写一个加密字符串的方法

```js
// 1.base-64加密
let tempStr = "hello world"
let tempPass = window.btoa(tempStr) // 'aGVsbG8gd29ybGQ='
// base-64解密
console.log(window.atob(tempPass)) // "hello world"

// 2.
function encode (str) {
  return btoa(encodeURIComponent(str));
}

function decode (str) {
  return decodeURIComponent(atob(str));
}
encode('hello world') // 'aGVsbG8lMjB3b3JsZA=='
decode('aGVsbG8lMjB3b3JsZA==') //'hello world'

// 3.
function encodeStr(str, padding) {
  return !str
    ? str
    : str.split('')
      .map(s => {
          return String.fromCharCode(s.charCodeAt() + padding)
      })
      .join('')
}
function decodeStr(str, padding) {
  return !str
    ? str
    : str.split('')
      .map(s => {
          return String.fromCharCode(s.charCodeAt() - padding)
      })
      .join('')
}
encodeStr('hello world!', 10) // 'rovvy*\x81y|vn+'
decodeStr('rovvy*\x81y|vn+', 10) // 'hello world!'
```

### 27.浏览器内多个标签页之间的通信方式有哪些?

1.websocket 可跨域
WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议

2.postMessage 可跨域

```js
window.addEventListener('message', function(){}) // 接收消息
window.parent.postMessage('msg', '*') // 发送消息 window.frames[0].postMessage Window.frames +索引值（命名或数字）
```

3.SharedWorker
作为浏览器的一个新特性，可以提供一个额外的线程来执行一些js代码（真正的多线程），并且不会影响到浏览器用户界面，但是不能DOM操作

4.Server-Sent Events
HTML5 服务器发送事件（server-sent event）允许网页获得来自服务器的更新。
Server-Sent 事件指的是网页自动获取来自服务器的更新。

5.localStorage（可以添加事件监听）

6.Cookies(Cookies在同一个域名内，并且目录也得相同)

7.BroadcastChannel(Chrome商店的api)
这个方式，只要是在同一原始域和用户代理下，所有窗口、iframe之间都可以进行交互。这个感觉就有点类似于广播了。

```js
//在一个页面上，触发事件，引发以下代码执行
//创建一个名字是mychannel的对象。记住这个名字，下面会用到
let cast = new BroadcastChannel('mychannel'); 
let myObj = { from: "children1", content: "add" };
cast.postMessage(myObj)

    
//在子页面上，定义以下代码(当前页面也可以接收消息)
//创建一个和刚才的名字一样的对象
let cast1 = new BroadcastChannel('mychannel');
cast1.onmessage = function (e) {
    alert(e)
}
```

### 28.简述下你理解的优雅降级和渐进增强

渐进增强（Progressive Enhancement）：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。

优雅降级（Graceful Degradation）：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。

在传统软件开发中，经常会提到向上兼容和向下兼容的概念。渐进增强相当于向上兼容，而优雅降级相当于向下兼容.

### 29.写一个判断数据类型的方法

```js
function getType(val) {
    return Object.prototype.toString.call(val).replace(/\[object\s|\]/g, '').toLowerCase()
}
getType(null) // null
getType(undefined) // 'undefined'
getType('') // 'string'
getType([]) // 'array'
getType({}) // 'object'
getType(true) // 'boolean'
getType(Number) // 'function'
getType(12) // 'number'
getType(Symbol('1')) // 'symbol'
```

### 30.viewport常见设置都有哪些？

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
```

该meta标签的作用是让当前viewport的宽度等于设备的宽度.同时不允许用户手动缩放
meta viewport有6个属性（content设置内容），如下：

|属性|作用|
|:---:|:---:|
|width|设置viewport  的宽度，为一个正整数，或字符串"width-device"|
|initial-scale|设置页面的初始缩放值，为一个数字，可以带小数|
|minimum-scale|允许用户的最小缩放值，为一个数字，可以带小数|
|maximum-scale|允许用户的最大缩放值，为一个数字，可以带小数|
|height|设置layout viewport  的高度，这个属性对我们并不重要，很少使用|
|user-scalable|是否允许用户进行缩放，值为"no"或"yes", no 代表不允许，yes代表允许|

此外，在安卓中还支持 target-densitydpi 这个私有属性，它表示目标设备的密度等级，作用是决定css中的1px代表多少物理像素.
target-densitydpi:值可以为一个数值或 high-dpi 、 medium-dpi、 low-dpi、 device-dpi 这几个字符串中的一个
当 target-densitydpi=device-dpi 时， css中的1px会等于物理像素中的1px。

首先如果不设置meta viewport标签，那么移动设备上浏览器默认的宽度值为800px，980px，1024px等这些，总之是大于屏幕宽度的。这里的宽度所用的单位px都是指css中的px，它跟代表实际屏幕物理像素的px不是一回事.

第二、每个移动设备浏览器中都有一个理想的宽度，这个理想的宽度是指css中的宽度，跟设备的物理宽度没有关系，在css中，这个宽度就相当于100%的所代表的那个宽度。我们可以用meta标签把viewport的宽度设为那个理想的宽度，如果不知道这个设备的理想宽度是多少，那么用device-width这个特殊值就行了，同时initial-scale=1也有把viewport的宽度设为理想宽度的作用.

可以同时使用

```html
<meta name="viewport" content="width=device-width, initial-scale=1">
```

### 31.对比下px、em、rem有什么不同？

px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。

em单位名称为相对长度单位。相对于当前对象内文本的字体尺寸.em的值并不是固定的；

rem是CSS3新增的一个相对单位（root em，根em）,仍然是相对大小，但相对的只是HTML根元素

### 32.简要描述下什么是回调函数并写一个例子出来

回调函数：做为实参数传入函数，并在该外部函数内调用，用以完成某些任务。

```js
function greeting(name) {
  alert('Hello,' + name)
}
function processUserInput(callback) {
  var name = prompt('Please enter your name.');
  callback(name);
}

processUserInput(greeting); 
```

以上示例为同步回调，它是立即执行的。
回调函数经常被用于在一个异步操作完成后执行代码，它们被称为异步回调.
一个常见的例子是在 promise 末尾添加的 .then 内执行回调函数（在 promise 被兑现或拒绝时执行）

### 33.你对标签语义化的理解是什么？

代码结构清晰，方便阅读，有利于团队合作开发。

方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以语义的方式来渲染网页。

有利于搜索引擎优化（SEO）。

### 34.css常用的布局方式有哪些？

流式布局: 最基本的布局，就是顺着 html 像流水一样流下来
绝对定位：利用postion: absolute进行绝对定位的布局
flaot布局：浮动布局，最初用来解决多栏布局，比如圣杯、双飞燕布局都可以用float实现
栅格布局：bootstrap布局，把页面分为24列，通过row和col布局
flex布局：css3的布局，弹性布局"，用来为盒状模型提供最大的灵活性
grid布局：网格布局

### 35.简要描述下JS有哪些内置的对象

**标准内置对象分类:**

**值属性**
这些全局属性返回一个简单值，这些值没有自己的属性和方法

+ Infinity： 一个数值，表示无穷大
+ NaN: 全局属性 NaN 是一个表示非数字的值。
+ undefined: 表示原始值undefined，是js的一个原始数据类型
+ globalThis: 全局属性gobalThis包含全局的this，类似全局对象

**函数属性**
全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将值返回给调用者。

+ eval():会将传入的字符串当做 JavaScript 代码进行执行。
+ isFinite(): 判断传入参数是否是一个有限数值。参数会首先转为一个数值。
+ isNaN(): 判断传入参数是否是NaN
+ parseFloat():解析一个参数（必要时先转换为字符串）并返回一个浮点数。
+ parseInt(): parseInt(string, radix) 解析一个字符串并返回指定基数的十进制整数，radix 是 2-36 之间的整数，表示被解析字符串的基数.
+ decodeURI(): 函数能解码由encodeURI 创建或其它流程得到的统一资源标识符（URI）。
+ decodeURIComponent(): 方法用于解码由 encodeURIComponent 方法或者其它类似方法编码的部分统一资源标识符（URI）
+ encodeURI(): 函数通过将特定字符的每个实例替换为一个、两个、三或四转义序列来对统一资源标识符 (URI) 进行编码
+ encodeURIComponent(): 函数通过将一个，两个，三个或四个表示字符的 UTF-8 编码的转义序列替换某些字符的每个实例来编码 URI

**基本对象**
顾名思义，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象

+ Object
+ Function
+ Boolean
+ Symbol

**错误对象**
错误对象是一种特殊的基本对象。它们拥有基本的 Error 类型，同时也有多种具体的错误类

+ Error：当运行时错误产生时，Error 对象会被抛出。Error 对象也可用于用户自定义的异常的基础对象
+ EvalError： 错误原因与eval()有关
+ RangeError: 错误原因：数值变量或参数超出其有效范围
+ ReferenceError: 无效引用
+ SyntaxError： 语法错误
+ TypeError: 变量或参数不属于有效类型
+ URIError：给encodeURI和decodeURI传递的参数无效
+ AggregateError:其中包裹了由一个操作产生且需要报告的多个错误。如：Promise.any() 产生的错误。
+ InternalError: 创建一个代表 Javascript 引擎内部错误的异常抛出的实例。如：递归太多。

**数字和日期对象**
用来表示数字、日期和执行数学计算的对象。

+ Number
+ BigInt
+ Math
+ Date

**字符串**
用来表示和操作字符串的对象

+ String
+ RegExp

**可索引的集合对象**
这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。

+ Array
+ Int8Array
+ Uint8Array
+ Uint8ClampedArray
+ Int16Array
+ Uint16Array
+ Int32Array
+ Uint32Array
+ Float32Array
+ Float64Array
+ BigInt64Array
+ BigUint64Array

**使用键的集合对象**
这些集合对象在存储数据时会使用到键，包括可迭代的Map 和 Set，支持按照插入顺序来迭代元素。

+ Map
+ Set
+ WeakMap
+ WeakSet

....

[JavaScript 标准内置对象(MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects)

### 36.常见的浏览器内核都有哪些？并介绍下你对内核的理解

浏览器内核分为渲染引擎和js引擎。渲染引擎负责页面的渲染，js引擎负责执行解析js。
之后，由于js引擎越来越独立，现在所说的浏览器内核大都指渲染引擎。
目前主流的浏览器内核有：

+ Trident:由微软开发的即ie内核
+ Gecko：使用c++开发的渲染引擎，firefox内核
+ Blink：Opera>12.18,chrome>=28,edge使用的内核
+ Webkit：chrome<28和safari使用的内核
+ Presto:Opera <= 12.18

### 37.说说你对css盒子模型的理解

完整的 CSS 盒模型应用于块级盒子，内联盒子只使用盒模型中定义的部分内容。模型定义了盒的每个部分 —— margin, border, padding, and content

CSS 中组成一个块级盒子需要：

+ Content box: 这个区域是用来显示内容，大小可以通过设置 width 和 height.
+ Padding box: 包围在内容区域外部的空白区域；大小通过 padding 相关属性设置
+ Border box: 边框盒包裹内容和内边距。大小通过 border 相关属性设置。
+ Margin box: 这是最外面的区域，是盒子和其他元素之间的空白区域。大小通过 margin 相关属性设置。

**标准盒模型**
在标准模型中，如果你给盒设置 width 和 height，实际设置的是 content box。padding 和 border 再加上设置的宽高一起决定整个盒子的大小。

```css
.box {
  width: 350px;
  height: 150px;
  margin: 25px;
  padding: 25px;
  border: 5px solid black;
}
```

如果使用标准模型宽度 = 410px (350 + 25 + 25 + 5 + 5)，高度 = 210px (150 + 25 + 25 + 5 + 5)，padding 加 border 再加 content box。

**替代（IE）盒模型**
宽度是可见宽度，所以内容宽度是该宽度减去边框和填充部分。

默认浏览器会使用标准模型。如果需要使用替代模型，您可以通过为其设置 box-sizing: border-box 来实现。

### 38.写一个获取当前url查询字符串中的参数的方法

```js
function getUrlParams(url) {
  if (url.split('?').length > 1) {
    const urlParams = url.split('?')[1].split('&')
    let res = {}
    urlParams.forEach(item => {
      let temp = item.split('=')
      res[temp[0]] = temp[1]
    })
    return res
  }
  return {}
}
getUrlParams('http://192.168.1.200:8080?a=1&b=2') // {a: '1', b:'2'}
// 正则
function getUrlParams(url) {
  let params = {}
  url.replace(/([^&=?]+)=([^&]+)/g, (m, $1, $2) => {
    params[$1] = $2
  })
  return params
}
getUrlParams('http://192.168.1.200:8080?a=1&b=2') // {a: '1', b:'2'}
```

### 39.网页应用从服务器主动推送到客户端有那些方式？

**webSocket**
WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议

WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。

**eventsource(SSE)**
EventSource 接口是 Web 内容与服务器发送的事件的接口。一个 EventSource 实例打开一个持久连接 HTTP 服务器，它发送事件的 text/event-stream 格式。连接保持打开状态，直到通过调用关闭 EventSource.close()。

与 WebSockets 不同，服务器发送的事件是单向的。也就是说，数据消息是从服务器到客户端（例如用户的 Web 浏览器）沿一个方向传递的

**Web Push**
就是用户订阅了一个站点的 Web Push 服务后，即使用户关闭了浏览器，一旦站点主动发送推送消息，用户都能收到，只要你的电脑是开着的。这是目前谷歌和苹果在 Chrome 和 Safari 上都力推的一种全新推送服务，Firefox 最近也加入了这个阵营。

但是由于需要 GCM 支持，所以这个方法并不常见

### 40.html5中的form怎么关闭自动完成？

autocomplete设置off，有时不生效
在浏览器设置里自动填充模块关闭

### 41.::before和:after中单冒号和双冒号的区别是什么，这两个伪元素有什么作用？

::和:是css3为了区分伪类和伪元素的，:表示伪类，::表示伪元素
::before是在元素前面插入内容，::after则是在元素后面插入内容，不过需要content配合，并且插入的内容是inline的。

### 43.http都有哪些状态码？

**HTTP状态码分类:**

|分类|分类描述|
|:---:|:---:|
|1** |信息，服务器收到请求，需要请求者继续执行操作|
|2** |成功，操作被成功接收并处理|
|3** |重定向，需要进一步的操作以完成请求|
|4** |客户端错误，请求包含语法错误或无法完成请求|
|5** |服务器错误，服务器在处理请求的过程中发生了错误|

**常见状态码:**

|状态码|描述|
|:---:|:---:|
|200|成功|
|301|永久重定向|
|302|临时重定向|
|304|使用缓存，不改变|
|400|客户端请求的语法错误，服务器无法理解|
|403|服务器理解请求客户端的请求，但是拒绝执行此请求|
|404|找不到资源|
|405|客户端请求中的方法被禁止|
|413|由于请求的实体过大，服务器无法处理，因此拒绝请求|
|500|服务器内部错误|
|502|Bad Gateway作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响|
|504|网关超时|

### 44.为什么HTML5只需要写<!DOCTYPE HTML>就可以？

因为html5和html4基于的基准不一样。html4基于SGML，因此除了DOCTYPE外还需要引入DTD来告诉浏览器用什么标准来渲染。DTD还区分严格模式和怪异模式。如果不写，浏览器自由发挥会变成怪异模式。
html5不基于SGML因此不需要DTD，但还是需要DOCTYPE来规范浏览器渲染行为。

SGML是通用标记语言的合集，有html、xml，因此需要DTD来指定使用哪种规范

DOCTYPE（Document Type Declaration）用于声明文档类型和DTD（Document Type Definition）规范，确保不同浏览器以相同的方式解析文档，以及执行相同的渲染模式。
DTD就是文档类型定义，一种标记符的语法规则，保证SGML和XML文档格式的合法性。

### 45.什么是闭包？优缺点分别是什么？

闭包是一个函数以及捆绑的周边环境状态（词法环境）的引用的组合。换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。闭包会随着函数的创建而被同时创建。

**闭包:**

```js
function makeFunc() {
  var name = "Mozilla";
  function displayName() {
    alert(name);
  }
  return displayName;
}

var myFunc = makeFunc();
myFunc();
```

**for循环：**

```html
<ul>
  <li>xxxxxxxxxxx</li>
  <li>xxxxxxxxxxx</li>
  <li>xxxxxxxxxxx</li>
  <li>xxxxxxxxxxx</li>
</ul>
```

```js
var liElements = document.getElementsByTagName('li');
for(var i=0; i< liElements.length; i++){
  liElements[i].onclick = function(){
    console.log(i) // 因为 变量i 是公用一个词法环境，所以最终输出的都一样，都输出 4
  }
}
```

解决这个问题的一种方案是使用更多的闭包

```js
var liElements = document.getElementsByTagName('li');
for(var i=0; i< liElements.length; i++){
  (liElements[i].onclick = function(){
    console.log(i)
  })() // 匿名闭包
}
// 闭包-函数工厂
for(var i=0; i< liElements.length; i++){
  liElements[i].onclick = function(){
    conFun(i)()
  }
}
function conFun(i) {
  return function() {
    console.log(i)
  }
}
// const let
for(let i=0; i< liElements.length; i++){
  liElements[i].onclick = function(){
    console.log(i)
  }
}
```

**性能考量:**
使用闭包可以隐藏变量以及防止变量被篡改和作用域的污染，从而实现封装。
而缺点就是由于保留了作用域链，会增加内存的开销。因此需要注意内存的使用，并且防止内存泄露的问题.
解决方法是：在退出函数之前，将不使用的局部变量全部删除；闭包会在函数外部，改变函数内部变量的值。

### 46.title与h1的区别、b与strong的区别、i与em的区别？

**title与h1的区别:**

+ 定义
  title是网站标题，一个页面只能有一个
  h1是文章主题
+ 作用
  title概括网站信息，可以直接告诉搜索引擎和用户这 个网站是关于什么主题和内容的，是显示在网页Tab栏里的；
  h1突出文章主题，面对用户，更突出其视觉效果，指向 页面主体信息，是显示在网页中的。
+ 注意
  如果title为空，但是页面存在h1,b,strong标签，搜索引擎会默认页面title为h1内的内容，所以 得出结论h1是在没有外界干扰下除title以外第二个能强调页面主旨的标记，在一个页面中应该使用且只使用一次h1标记。

**b与strong的区别：**

+ 定义
  b(bold)是实体标签，用来给文字加粗
  strong是逻辑标签，作用是加强字符语气
+ 区别
  b标签只是加粗的样式，没有实际含义，常用来表达无强调或着中意味的粗体文字
  trong表示标签内字符重要，用以强调，其默认格式是加粗，但是可以通过css添加样式，使用别的样式强调。在使用阅读设备时，会重读
+ 建议：为了符合css3的规范语义化，b应尽量少用而改用strong

**i与em的区别：**

+ 定义
  i(italic)是实体标签，用来使字符倾斜
  em(emphasis)是逻辑标签，作用是强调文本内容
+ 区别
  i标签只是斜体的样式，没有实际含义，常用来表达无强调或着重意味的斜体，比如生物学名、术语、外来语；
  em表示标签内字符重要，用以强调，其默认格式是斜体，但是可以通过CSS添加样式。在使用阅读设备时，会重读
+ 建议：为了符合CSS3的规 范，i应尽量少用而改用em。

物理元素是告诉浏览器我应该以何种格式显示文字，逻辑元素告诉浏览器这些文字有怎么样的重要性。
对于搜索引擎来说em和strong比i和b要重视的多。

### 47.style标签写在body前和body后的区别是什么？

在 HTML4 的时候，不应该把 style 放到 body 中间。

浏览器在渲染页面时 DOM 和 CSSOM 是并行的，然后两者结合形成 Render Tree 显示页面。从直觉上来说，style 写在 body 前不会对 DOM 的渲染进行阻塞；而写在 body 内会对 DOM 渲染进行阻塞。会产生 FOUC（Flash of Unstyled Content) 的现象，既一瞬间的白屏或者样式的突然变化（原因是 Render Tree 重新生成了）。

不过 W3C 在 HTML5.2 的定义中对于 style 标签的使用的定义中是允许将 style 放到 body 中的.

### 48.写一个数组去重的方法（支持多维数组）

```js
// 1.
function flatArr(arr) {
  let result = []
  arr.forEach(item => {
    if (Array.isArray(item)) {
        result = result.concat(...flatArr(item))
    } else {
        result.push(item)
    }
  })
  return result
}
function dupRemove(arr) {
    arr = flatArr(arr)
    return Array.from(new Set(arr))
}
dupRemove([1,2,3,[4,5], 3,2,1,[1,2,3,[4, 4, 5]],5,6,8,4,9,[1,2,3],[1,2,3], [4,5], [1,2,3,[4, 5]]]) // [1, 2, 3, 4, 5, 6, 8, 9]

// 2.不展开数组去重
function dupRemove(arr) {
  arr = Array.from(new Set(arr))
  arr.forEach((item, index) => {
    if (Array.isArray(item)) {
      arr[index] = dupRemove(item)
    }
  })
  return arr
}
dupRemove([1,2,3,[4,5], 3,2,1,[1,2,3,[4, 4, 5]],5,6,8,4,9,[1,2,3],[1,2,3], [4,5], [1,2,3,[4, 5]]]) // [1, 2, 3, Array(2), Array(4), 5, 6, 8, 4, 9, Array(3), Array(3), Array(2), Array(4)]

// 3.
function dupRemove(arr) {
  return [...new Set(arr.flat(Infinity))]
}
dupRemove([1,2,3,[4,5], 3,2,1,[1,2,3,[4, 4, 5]],5,6,8,4,9,[1,2,3],[1,2,3], [4,5], [1,2,3,[4, 5]]]) // [1, 2, 3, 4, 5, 6, 8, 9]
```

### 49.元素的alt和title有什么区别？

**alt：**

```html
<img src="#" alt="alt 信息" />
```

当图片不输出信息的时候，会显示 alt 信息， 鼠标放上去没有信息。
当图片正常读取，不会出现 alt 信息。

**title：**

```html
<img src="#" alt="alt 信息" title="title 信息" />
```

当图片不输出信息的时候，会显示 alt 信息，鼠标放上去会出现 title 信息。
当图片正常输出的时候，不会出现 alt 信息，鼠标放上去会出现 title 信息。

### 50.请描述margin边界叠加是什么及解决方案

块的上外边距 (margin-top)和下外边距 (margin-bottom)有时合并 (折叠) 为单个边距，其大小为单个边距的最大值 (或如果它们相等，则仅为其中一个)，这种行为称为边距折叠。

注：有设定float和position=absolute的元素不会产生外边距重叠行为。

有三种情况会形成外边距重叠：

+ 同一层相邻元素之间
  相邻的两个元素之间的外边距重叠，除非后一个元素加上[clear-fix 清除浮动](https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear>)

```html
<style>
p:nth-child(1){
  margin-bottom: 13px;
}
p:nth-child(2){
  margin-top: 87px;
}
</style>

<p>下边界范围会...</p>
<p>...会跟这个元素的上边界范围重叠。</p>
```

+ 没有内容将父元素和后代元素分开
  如果没有边框border，内边距padding，行内内容，也没有创建块级格式上下文或清除浮动来分开一个块级元素的上边界margin-top 与其内一个或多个后代块级元素的上边界margin-top；或没有边框，内边距，行内内容，高度height，最小高度min-height或 最大高度max-height 来分开一个块级元素的下边界margin-bottom与其内的一个或多个后代后代块元素的下边界margin-bottom，则就会出现父块元素和其内后代块元素外边界重叠，重叠部分最终会溢出到父级块元素外面。

```html
<style type="text/css">
    section    {
        margin-top: 13px;
        margin-bottom: 87px;
    }

    header {
        margin-top: 87px;
    }

    footer {
        margin-bottom: 13px;
    }
</style>

<section>
    <header>上边界重叠 87</header>
    <main></main>
    <footer>下边界重叠 87 不能再高了</footer>
</section>
```

+ 空的块级元素
  当一个块元素上边界margin-top 直接贴到元素下边界margin-bottom时也会发生边界折叠。这种情况会发生在一个块元素完全没有设定边框border、内边距padding、高度height、最小高度min-height 、最大高度max-height 、内容设定为 inline 或是加上clear-fix的时候。

```html
<style>
​​​​​​p {
  margin: 0;
}
div {
  margin-top: 13px;
  margin-bottom: 87px;
}
</style>

<p>上边界范围是 87 ...</p>
<div></div>
<p>... 上边界范围是 87</p>
```

解决方法，可以通过触发BFC解决：

+ 1、根元素，即 html
+ 2、float 的值不为 none（默认）
+ 3、overflow 的值不为 visible（默认）
+ 4、display 的值为 inline-block、table-cell、table-caption
+ 5、position 的值为 absolute 或 fixed
+ 6.外层padding
+ 7.透明边框border:1px solid transparent;

### 51.返回到顶部的方法有哪些？

1.window.scrollTo(0,0) ie支持不好
2.window.scroll(0,0) 和scrollTo类似
3.`<a href="#">top</a>`
4.location.href += '#';当这个方法执行多次即有多个 # 时，页面不会有响应。
5.document.documentElement.scrollTop = 0;
6.锚点法，在顶部加个标签

### 52.解释下 CSS sprites的原理和优缺点分别是什么？

将一个页面涉及到的所有零星图片都包含到一张大图中， 利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位， 访问页面时避免图片载入缓慢的现象。

**优点：**
1.减少网页的http请求，从而大大的提高页面的性能
**缺点：**
图片合并麻烦
图片适应性差：在高分辨的屏幕下自适应页面，若图片不够宽会出现背景断裂。
图片定位繁琐
可维护性差

### 53.typeof('abc')和typeof 'abc'都是string, 那么typeof是操作符还是函数？

typeof是操作符不是函数，括号只是进行分组而非函数。

### 54.说说你对SVN和GIT的理解和区别

svn是集中式的，允许单次下载单文件修改，因为对每个文件都有对应的.svn文件控制
git是分布式的，每次clone都是获得一个完整的代码版本，可以不依赖服务器本地独立运行项目

### 55.怎样在页面上实现一个圆形的可点击区域？

1.DOM 元素配合 border-radius: 50% 即可实现圆形点击区域
2.利用 `<map>`和 `<area>`标签设置圆形点击区域。参考文章:[HTML 标签及在实际开发中的应用](https://www.zhangxinxu.com/wordpress/2017/05/html-area-map/)
3.利用 SVG 作出圆形，然后添加点击事件。
4.如果在 canvas 上，就需要画出圆形，然后计算鼠标的坐标是否落在圆内。

### 56.什么是FOUC？你是如何避免FOUC的？

FOUC 即 Flash of Unstyled Content，是指页面一开始以样式 A（或无样式）的渲染，突然变成样式B。原因是样式表晚于 HTML 加载导致页面重新进行绘制。

+ 通过 @import 方式导入样式表
+ style 标签在 body 中

解决方法：把 link 标签将样式放在 head 中

### 57.你理解的"use strict";是什么?使用它有什么优缺点？

JavaScript 严格模式（strict mode）即在严格的条件下运行。

**为什么使用严格模式:**

+ 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;
+ 消除代码运行的一些不安全之处，保证代码运行的安全；
+ 提高编译器效率，增加运行速度；
+ 为未来新版本的Javascript做好铺垫。

**严格模式的限制:**

不允许使用未声明的变量：

```js
"use strict";
x = 3.14; // 报错 (x 未定义)
```

不允许删除变量或对象：

```js
"use strict";
var x = 3.14;
delete x; // 报错
```

不允许删除函数：

```js
"use strict";
function x(){};
delete x // 报错
```

不允许变量重名：

```js
"use strict";
function x(p1, p1) {};   // 报错
```

不允许使用八进制：

```js
"use strict";
var x = 010;             // 报错
```

不允许使用转义字符：

```js
"use strict";
var x = \010;            // 报错
```

不允许对只读属性赋值:

```js
"use strict";
var obj = {};
Object.defineProperty(obj, "x", {value:0, writable:false});

obj.x = 3.14;            // 报错
```

不允许对一个使用getter方法读取的属性进行赋值:

```js
"use strict";
var obj = {get x() {return 0} };

obj.x = 3.14;            // 报错
```

不允许删除一个不允许删除的属性：

```js
"use strict";
delete Object.prototype; // 报错
```

变量名不能使用 "eval" 字符串:

```js
"use strict";
var eval = 3.14;         // 报错
```

变量名不能使用 "arguments" 字符串:

```js
"use strict";
var arguments = 3.14;    // 报错
```

不允许使用以下这种语句:

```js
"use strict";
with (Math){x = cos(2)}; // 报错
```

由于一些安全原因，在作用域 eval() 创建的变量不能被调用：

```js
"use strict";
eval ("var x = 2");
alert (x);               // 报错
```

禁止this关键字指向全局对象:

```js
function f(){
    return !this;
} 
// 返回false，因为"this"指向全局对象，"!this"就是false

function f(){ 
    "use strict";
    return !this;
} 
// 返回true，因为严格模式下，this的值为undefined，所以"!this"为true。
```

保留关键字:

implements
interface
let
package
private
protected
public
static
yield

注： "use strict" 指令只允许出现在脚本或函数的开头。

### 58.可替换元素

在css中，可替换元素的展现效果不是由css来控制的，这些元素是一种外部对象，它们外观的渲染是独立于css的。简单来说，它们的内容不受当前文档样式的影响。CSS 可以影响可替换元素的位置，但不会影响到可替换元素自身的内容。

CSS 能对可替换元素产生的唯一影响在于，部分属性支持控制元素内容在其框中的位置或定位方式

可替换元素有：

+ iframe
+ video
+ embed
+ img

用 CSS content 属性插入的对象是匿名的可替换元素。它们并不存在于 HTML 标记中，因此是“匿名的“。

某些 CSS 属性可用于指定 可替换元素中包含的内容对象 在该元素的盒区域内的位置或定位方式

+ object-fit
指定可替换元素的内容对象在元素盒区域中的填充方式（有些类似于 background-size ）
+ object-position
指定可替换元素的内容对象在元素盒区域中的位置。（类似于 background-position ）

### 59.css重的content属性有什么作用？有哪些场景可以用到？

css中的content属性用于::before和::after伪元素中插入内容。使用content属性拆入的内容都是匿名的[可替换元素](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Replaced_element)。

content的值：

+ none: 不会产生伪元素
+ normal: before 和 :after 伪类元素中会被视为 none
+ `<string>`: 文本内容
+ `<uri>`: url('http://www.example.com/test.html'),URI 值会指定一个外部资源（比如图片）
+ `<counter>`:计数器可以指定两种不同的函数：counter() 或 counters()
+ attr(x): 将元素的x属性以字符串形式返回。如果该元素没有 X 属性，则返回一个空字符串。区分大小写的属性返回值依赖文挡的语言设定。
+ open-quote | close-quote：这些值会被 [quotes](https://developer.mozilla.org/zh-CN/docs/Web/CSS/quotes) 中定义的字符串替换
+ no-open-quote | no-close-quote:不会生产任何内容，但是会改变（增加或降低）引号层级。

### 60.“attribute”和“property”有什么不同？

**property:**

+ 是DOM的属性，js中的对象
+ 读取方式，element.id,element.value,element.className
+ 设置方式：element.id = newId
+ 对大小写敏感

**attribute：**

+ 是HTML的属性，直接在html标签添加的都是attribute属性
+ 读取方式：element.getAttribute("attrName"),比如element.getAttribute('class')
+ 设置方式：element.setAttribute("attrName", value)

### 61.请描述HTML元素的显示优先级

元素的显示优先级，即元素覆盖次序的规则。显示优先级规则如下：

+ 帧元素（frameset）> 表单元素 > 非表单元素；
+ 有窗口元素 > 无窗口元素；
+ 同一类元素间，z-index 值大的元素 > z-index 值小的元素。

表单元素：文本输入框、密码输入框、单选框、复选框、文本输入域、列表框等等；

非表单元素：a、div、table、span 等等；

有窗口元素：select 元素、object 元素、frames 元素等等；

无窗口元素：大部分 html 元素都是无窗口元素，如 a、table 等等

### 62.要让Chrome支持小于12px的文字怎么做？

1. 改用图片
2. 使用 -webkit-text-size-adjust:none; 但是不支持chrome 27.0以上版本
3. 使用 transform: scale()缩小

+ transform 对行内元素无效，因此要么使用 display: block; 要么使用 display: inline-block;
+ transform 即使进行了缩放，原来元素还是会占据对应的位置。因此需要做调整，最好是在外面再包一层元素，以免影响其他元素。

### 63.身份证号校验的方法

身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)

### 64.谈谈你对input元素中readonly和disabled属性的理解

**readonly:**
这个布尔属性指明无法修改控件的值。如果控件的type属性为hidden,range,color,checkbox,radio,file,此属性将被忽略。可以被提交，可以tab获取焦点

**disabled:**
这个布尔属性指明表单控件不可用。特别是在禁用的控件中，click事件将不会被分发。并且，禁用的控件的值在提交表单时也不会被提交。如果 type 属性为 hidden，此属性将被忽略。不可获取焦点。

### 65.说说你对line-height是如何理解的

line-height CSS 属性用于设置多行元素的空间量，如多行文本的间距。对于块级元素，它指定元素行盒（line boxes）的最小高度。对于非替代的 inline 元素，它用于计算行盒（line box）的高度。

line-height 属性被指定为以下任何一个：

+ 一个数字： line-height: 2;
+ 一个长度： line-height: 2em;
+ 一个百分比： line-height: 30%;
+ 关键词：normal

**取值：**

+ normal: 取决于用户端，桌面浏览器（包括 Firefox）使用默认值，约为1.2，这取决于元素的 font-family。
+ 数字：该属性的应用值是这个无单位数字<数字>乘以该元素的字体大小
+ 长度：line-height: 2em;。以 em 为单位的值可能会产生不确定的结果。
+ 百分比： 与元素自身的字体大小有关。计算值是给定的百分比值乘以元素计算出的字体大小

### 66.写一个方法验证是否是中文？

```js
// 使用的Unicode 编码 4e00 和 9fa5 分别表示第一个汉字和最后一个汉字的编码
function isChinese(str) {
  const re = /^[\u4e00-\u9fa5]+$/;
  return re.test(str);
}
```

### 67.来说说你对重绘和重排的理解，以及如何优化?

浏览器渲染过程如下：

+ 解析HTML，生成DOM树，解析CSS，生成CSSOM树
+ 将DOM树和CSSOM树结合，生成渲染树(Render Tree)
+ Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）
+ Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素
+ Display:将像素发送给GPU，展示在页面上

通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流

我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。

何时发生回流重绘

+ 添加或删除可见的DOM元素
+ 元素的位置发生变化
+ 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）
+ 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。
+ 页面一开始渲染的时候（这肯定避免不了）
+ 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）

注意：回流一定会触发重绘，而重绘不一定会回流根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。

当你获取布局信息的操作的时候，会强制队列刷新

最小化重绘和重排：

  批量修改DOM：
  使元素脱离文档流
  对其进行多次修改
  将元素带回到文档中。

有三种方式可以让DOM脱离文档流：

  隐藏元素，应用修改，重新显示
  使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。
  将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。

### 68.js放在html的`<body>`和`<head`>有什么区别？

点击查看{% post_link script标签的加载和执行 %}

### 69.说说浏览器解析CSS选择器的过程？

**浏览器渲染过程：**
![images](/images/browerRender.png)

浏览器渲染分为两部分：

+ HTML Parser生成DOM树;
+ CSS Parser生成Style Rules;
  
之后DOM树和Style Rules会生产Render Tree渲染树，结合Layout绘制在屏幕上，从而展现出来。

**CSS 选择器解析顺序：**
解析 CSS 选择器时是从右往左解析。
如果采用从左至右的方式读取 CSS 规则，那么大多数规则读到最后（最右）才会发现是不匹配的，这样会做费时耗能，最后有很多都是无用的；而如果采取从右向左的方式，那么只要发现最右边选择器不匹配，就可以直接舍弃了，避免了许多无效匹配。

浏览器 CSS 匹配核心算法的规则是以从右向左方式匹配节点的。这样做是为了减少无效匹配次数，从而匹配快、性能更优。

### 70.你对new 运算符的理解是什么？手动实现一个new方法

new 运算符创建一个用户定义的对象类型的实例或者具有构造函数的内置对象的实例。

**语法：**
new constructor[(arguments)]

参数：

+ constructor: 一个指定对象实例的类型的类或函数
+ arguments：一个用于被constructor调用的参数列表。

描述：

new 关键字会进行如下操作：

+ 创建一个空的简单js对象（即{}）；
+ 为新创建的对象添加属性__proto__,将该属性链接到构造函数的原型对象；
+ 将新创建的对象作为this的上下文；
+ 如果该函数没有返回对象，则返回this；

创建一个用户自定义对象需要两步：
1.通过编写函数来定义对象类型
2.通过new来创建对象实例

下面的代码将一个值为 null 的 color 属性添加到 car 类型的所有对象，然后仅在实例对象 car1 中用字符串 "black" 覆盖该值。

```js
function Car() {}
car1 = new Car();
car2 = new Car();

console.log(car1.color);    // undefined

Car.prototype.color = "original color";
console.log(car1.color);    // original color

car1.color = 'black';
console.log(car1.color);   // black

console.log(car1.__proto__.color) //original color
console.log(car2.__proto__.color) //original color
console.log(car1.color)  // black
console.log(car2.color) // original color
```

如果你没有使用 new 运算符，构造函数会像其他的常规函数一样被调用，并不会创建一个对象。在这种情况下， this 的指向也是不一样的。

对象类型和对象实例:

```js
// car汽车对象类型
function Car(make, model, year) {
   this.make = make;
   this.model = model;
   this.year = year;
}
// 对象实例
var mycar = new Car("Eagle", "Talon TSi", 1993);
```

对象属性为其他对象:

```js
// 定义了一个对象叫做 person：
function Person(name, age, sex) {
   this.name = name;
   this.age = age;
   this.sex = sex;
}
// 实例化两个新的 person 对象如下：
var rand = new Person("Rand McNally", 33, "M");
var ken = new Person("Ken Jones", 39, "M");
// 可以重写 car 的定义，添加一个值为 person 对象的 owner 属性，如下：
function Car(make, model, year, owner) {
   this.make = make;
   this.model = model;
   this.year = year;
   this.owner = owner;
}
// 实例化新的对象
var car1 = new Car("Eagle", "Talon TSi", 1993, rand);
var car2 = new Car("Nissan", "300ZX", 1992, ken);
console.log(car2.owner.name) // Ken Jones
```

**模拟new：**

Object.create()方法创建一个新的对象,使用现有的对象来提供新创建对象的__proto__.
语法：Object.create(proto, [propertiesObject])：

+ 参数proto为新创建对象的原型对象
+ propertiesObject:可选,需要传入一个对象.该对象的属性类型
查看-{% post_link javascript的Object-create方法 %}

apply用来重新定义this对象的

```js
function _new(fn, ...arg) {
  const obj = Object.create(fn.prototype)
  // obj: {
  //   __proto__: {
  //     fn.prototype
  //   }
  // }
  const _this = fn.apply(obj, arg) // _this对象的this指向obj
  return _this instanceof Object ? _this : obj
}
```

扩展：

```js
// Object.create示例：
var aObj = {
    a:'zjy',
    b:'name',
    c:function(n){
        console.log('n:'+n);
    }
};
var _aObj = Object.create(aObj,{
    txt:{
        value:'Object.create()方法的继承'
    }
});
console.log(_aObj);
// _aObj{
//     txt:'Object.create()方法的继承',
//     __proto__:{
//         a:'zjy',
//         b:'name',
//         c:funtion()
//     }
// }
_aObj.c('haha'); // n:haha


// call/apply/bind示例：
var name = 'wang',age = 17;
var obj = {
    name: 'zhang',
    objAag: this.age,
    myFun:function(fm,t){
        console.log(this.name + '年龄' + this.age,'来自 '+ fm+' 去往'+t)
    }
}
var db = {
    name:'dema',
    age: 99
}

obj.myFun.call(db,'成都','上海'); //dema年龄99 来自 成都 去往上海
obj.myFun.apply(db,['成都','上海']); //dema年龄99 来自 成都 去往上海
obj.myFun.bind(db,['成都','上海'])(); //dema年龄99 来自 成都,上海 去往undefined
obj.myFun.bind(db,'成都','上海')(); //dema年龄99 来自 成都 去往上海
obj.myFun.bind(db)('成都','上海'); // dema年龄99 来自 成都 去往上海
```

### 71.关于`<form>`标签的enctype属性你有哪些了解？

当method属性为post时，enctype就是将表单的内容提交给服务器的MIME类型。可能的值有：

+ application/x-www-form-urlencoded: 未指定属性时的默认值，在发送前对所有字符进行编码（将空格转换为 "+" 符号，特殊字符转换为 ASCII HEX 值）。
+ mulipart/form-data:当表单包含type=file的input元素时使用此值。
+ text/plain: 表单以纯文本形式进行编码.将空格转换为 "+" 符号，但不编码特殊字符.

### 72.说说CSS的优先级是如何计算的？

优先级就是分配给指定的 CSS 声明的一个权重，它由 匹配的选择器中的 每一种选择器类型的 数值 决定。
当同一个元素有多个声明的时候，优先级才会有意义

css里的c代表cascade,层叠，层叠决定了如何解决冲突，是css语言的基础。层叠会依据三种条件解决冲突。

(1) 样式表的来源：样式是从哪里来的，包括你的样式和浏览器默认样式等。

(2) 选择器优先级：哪些选择器比另一些选择器更重要。

(3) 源码顺序：样式在样式表里的声明顺序。

**1.样式表的来源:**

  你添加到网页里的样式表并不是浏览器唯一使用的样式表，还有其他类型或来源的样式表。你的样式表属于作者样式表，除此之外还有用户代理样式表，即浏览器默认样式。用户代理样式表优先级低，你的样式会覆盖它们.

  ! important声明会被当作更高优先级的来源，因此总体的优先级按照由高到低排列如下所示：
  (1) 作者的！important
  (2) 作者的样式表
  (3) 用户代理样式表

  层叠规则顺序：不同来源的声明-内联声明-选择器优先级声明-源码顺序声明

**2.选择器优先级：**

伪类选择器（:hover）和属性选择器（[type="input"]）与一个类选择器的优先级相同。
通用选择器（*）和组合选择器（>,+,~）对优先级无影响。

!important > 内联样式 > id > 类选择器((例如，.example)，属性选择器（例如，[type="radio"]）和伪类（例如，:hover）) > 类型选择器（例如，h1）和伪元素（例如，::before） > * > 继承 >默认

### 73.0.1 + 0.2、0.1 + 0.3和0.1 * 0.2分别等于多少？并解释下为什么？

Javascript不详细区分整数、浮点数以及带符号的数字类型。使用双精度的64位浮点数字格式（IEEE 754）来表示数字，因此数字本质上都是浮点数。在该格式中，符号占1位（bit），指数部分占11位，小数部分占52位，共64位。

简单来说就是js中采用IEEE754的双精度标准，因为精度不足导致的问题。

0.1不再是 0.1 了，而是变成了 0.100000000000000002

```js
0.100000000000000002 === 0.1 // true
```

0.2 :0.200000000000000002

```js
0.200000000000000002 === 0.2 // true
```

由此我们可以得出:

```js
0.1 + 0.2 === 0.30000000000000004 // true
```

所以0.1+0.2 != 0.3

```js
parseFloat((0.1+0.2).toFixed(10)) === 0.3 // true
```

### 74.对属性data-的理解

data-*全局属性是一类被称为自定义数据属性的属性，它赋予我们在所有 HTML 元素上嵌入自定义数据属性的能力，并可以通过脚本在 HTML 与 DOM 表现之间进行专有数据的交换。

**HTML语法.**

所有元素上以data-开头的属性为数据属性。

比如说你有一篇文章，而你又想要存储一些不需要显示在浏览器上的额外信息。请使用 data 属性：

```html
<article
  id="electriccars"
  data-columns="3"
  data-index-number="12314"
  data-parent="cars">
...
</article>
```

写入数据属性:

```js
var article = document.querySelector('#electriccars');

article.dataset.column = 5; // 将column修改为5
console.log(article.dataset.columns); // 5
```

**JavaScript 访问.**

可以使用getAttribute()配合它们完整的 HTML 名称去读取它们.

为了使用dataset对象去获取到数据属性，需要获取属性名中data-之后的部分 (要注意的是破折号连接的名称需要改写为骆驼拼写法 (如"index-number"转换为"indexNumber"))。

```js
var article = document.querySelector('#electriccars');

article.dataset.columns // "3"
article.dataset.indexNumber // "12314"
article.dataset.parent // "cars"
```

**CSS 访问.**

data 设定为 HTML 属性，他们同样能被CSS访问

```css
article::before {
  content: attr(data-parent);
}
```

也同样可以在 CSS 中使用属性选择器根据 data 来改变样式：

```css
article[data-columns='3'] {
  width: 400px;
}
article[data-columns='4'] {
  width: 600px;
}
```

### 75.如何快速让一个数组乱序

```js
function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i + 1))
    var target = array[j]
    array[j] = array[i]
    array[i] = target 
  }
    return array
}
shuffle([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]) //  [1, 3, 9, 4, 8, 10, 7, 2, 6, 5]
```

### 76.请说说`<script>`、`<script async>`和`<script defer>`的区别?

点击查看{% post_link script标签的加载和执行 %}

### 77.写一个判断设备来源的方法

```js
function checkPlatform() {
  let userAgentInfo = navigator.userAgent;
  const Agents = ['Android', 'iPhone', 'SysbianOS', 'Windows Phone', 'iPad', 'iPod'];

  for (let i = 0; i < Agents.length; i++) {
    if (userAgentInfo.indexOf(Agents[i]) > 0) {
      return alert('当前为移动端设备，机型为：' + Agents[i]);
    }
  }
  return alert('当前为PC端');
}
checkPlatform();
```

或者<https://github.com/matthewhudson/current-device>

### 78.解释下你对GBK和UTF-8的理解？并说说页面上产生乱码的可能原因

**GBK编码：**
是指中国的中文字符，其它它包含了简体中文与繁体中文字符，另外还有一种字符“gb2312”，这种字符仅能存储简体中文字符。

**UTF-8编码：**
它是一种全国家通过的一种编码，如果你的网站涉及到多个国家的语言，那么建议你选择UTF-8编码。由于 UTF-8 包含了多种语言，也因此其占用的空间会比较大一些。

而网页产生乱码往往是因为编码与解码不匹配造成的。一般我们会在`<meta>` 标签中设置 charset 来决定网页采用的编码。如果引用的文件为其他格式，则会出现无法解释或者解释不对的字符，即乱码问题。

### 79.说说你对z-index的理解

查看{% post_link css中的z-index属性 %}

### 80.说说bind、call、apply的区别？并手写实现一个bind的方法

```js
var name = 'wang',age = 17;
var obj = {
    name: 'zhang',
    objAag: this.age,
    myFun:function(){
        console.log(this.name + '年龄' + this.age)
    }
}
obj.objAag; //17
obj.myFun(); //zhang年龄undefined

```

使用call/apply/bind

```js
var db = {
    name:'dema',
    age: 99
}
obj.myFun.call(db); // dema年龄99
obj.myFun.apply(db); // dema年龄99
obj.myFun.bind(db)(); // dema年龄99
```

以上除了bind多了个（）外，结果都一致，由此可知，bind返回的是一个新函数，必须调用它能执行

call/apply/bind 传参数区别

```js
var name = 'wang',age = 17;
var obj = {
    name: 'zhang',
    objAag: this.age,
    myFun:function(fm,t){
        console.log(this.name + '年龄' + this.age,'来自 '+ fm+' 去往'+t)
    }
}
var db = {
    name:'dema',
    age: 99
}

obj.myFun.call(db,'成都','上海'); //dema年龄99 来自 成都 去往上海
obj.myFun.apply(db,['成都','上海']); //dema年龄99 来自 成都 去往上海
obj.myFun.bind(db,['成都','上海'])(); //dema年龄99 来自 成都,上海 去往undefined
obj.myFun.bind(db,'成都','上海')(); //dema年龄99 来自 成都 去往上海
obj.myFun.bind(db)('成都','上海'); // dema年龄99 来自 成都 去往上海
```

call 、bind 、 apply 这三个函数的第一个参数都是 this 的指向对象,第二个参数：
call的参数直接放进去，多个参数用逗号分隔
apply的第二个参数是数组
bind 除了返回是函数以外，它 的参数和 call 一样

**实现:**

```js
Function.prototype.myCall = function(context = window) {
  context.fn = this
  var args = [...arguments].slice(1)
  var result = context.fn(...args)
  delete context.fn
  return result
}
```

```js
Function.prototype.myApply = function(context = window) {
  context.fn = this
  var result
  if (arguments[1]) {
    result = context.fn(...arguments[1])
  } else {
    result = context.fn()
  }
  return result
}
```

```js
Function.prototype.myBind = function (context) {
  if (typeof this !=== 'function') {
    throw new Error('Error')
  }
  var args = [...arguments].slice(1)
  return (...args) => this.call(context, ...args)
}
```

### 81.git branch

git branch: 不带参数命令，获取本地仓库的分支列表，并显示当前所在分支，即head指向的分支

git branch -v: 查看每个分支的最后一次commit提交信息

git branch --merged: 查看已经合并到当前分支的分支

git branch --no-merged: 查看没有合并到当前分支的分支

 git branch -D branchname: 强制删除某个分支，会丢失被删除的分支上面的所有内容。

### 82.说说你对影子(Shadow)DOM的了解

Shadow Dom是对标记结构、样式和行为的封装，Shadow DOM 接口可以将一个隐藏的独立的DOM附加到另一个元素上。
Shadow DOM 内部的元素始终不会影响到它外部的元素。
比如你所能看到的只是一个 `<video>` 标签，实际上，在它的 Shadow DOM 中，包含了一系列的按钮和其他控制器

**基本用法.**

可以使用 Element.attachShadow() 方法来将一个 shadow root(shadow tree 的根节点) 附加到任何一个元素上。它接受一个配置对象作为参数，该对象有一个 mode 属性，值可以是 open 或者 closed。

open 表示可以通过页面内的 JavaScript 方法来获取 Shadow DOM，例如使用 Element.shadowRoot 属性：

```js
let myShadowDom = myCustomElem.shadowRoot
```

mode 设置为 closed，那么就不可以从外部获取 Shadow DOM 了——myCustomElem.shadowRoot 将会返回 null.
浏览器中的某些内置元素就是如此，例如video，包含了不可访问的 Shadow DOM。

```js
let shadow = this.attachShadow({mode: 'open'});
var para = document.createElement('p');
shadow.appendChild(para);
```

将 Shadow DOM 附加到一个元素之后，就可以使用 DOM APIs 对它进行操作，就和处理常规 DOM 一样。

[使用 shadow DOM(MDN)](https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_shadow_DOM)

### 83.怎样修改chrome记住密码后自动填充表单的黄色背景？

-webkit-text-fill-color: red; 设置文本颜色
-webkit-box-shadow: 0 0 0 1000px white inset; 设置内阴影

### 84.说说你对arguments的理解，它是数组吗？

arguments是一个对应于传递给函数的参数的类数组对象。

类数组意味着arguments有长度属性并且属性的索引时从零开始的，但是并没有Array的内置方法，比如forEach()和map()

```js
function func1(a, b, c) {
  console.log(Object.prototype.toString.call(arguments))
  // output:  "[object Arguments]"

  console.log(arguments[0]);
  // expected output: 1

  console.log(arguments[1]);
  // expected output: 2

  console.log(arguments[2]);
  // expected output: 3
}

func1(1, 2, 3);
```

arguments对象是所有函数（非箭头函数）都可用的局部变量。可以使用arguments对象在函数中引用函数的参数。

```js
arguments[0]
arguments[1]
```

也可以被设置：

```js
arguments[0] = 0
```

arguments没有Array内置方法，但是可以转化为Array：

```js
function func1(a, b, c) {
  console.log(Object.prototype.toString.call(arguments))
  console.log(arguments[0]);
  // expected output: 1

  console.log(arguments[1]);
  // expected output: 2

  console.log(arguments[2]);
  // expected output: 3

  arguments[0] = 0
  console.log(arguments[0]);

  var args = Array.prototype.slice.call(arguments);
  console.log('args', args)
  // output: "args" Array [0, 2, 3]
  
  var args1 = [].slice.call(arguments);
  console.log('args1', args1)
  // output: "args1" Array [0, 2, 3]

  var args2 = Array.from(arguments)
  console.log('args2', args2)
  // output: "args2" Array [0, 2, 3]
  
  var args3 = [...arguments]
  console.log('args3', args3)
  // output: "args3" Array [0, 2, 3]
}

func1(1, 2, 3);
```

arguments.callee指向参数所属的当前执行的函数。

### 85.说说你对`<meta>`标签的理解

文档级元数据元素,表示那些不能被其他html元相关元素（base、link、script、style、title）之一表示的任何元数据信息。

meta 元素定义的元数据的类型包括以下几种：

+ 如果设置了name属性，meta元素提供的是文档级别的元数据，应用于整个页面。
+ 如果设置了http-equiv属性，meta元素则是编译指令，提供的信息与类似命名的http头部相同。
+ 如果设置了charset属性，meta元素是一个字符集声明，告诉文档用哪种字符编码。
+ 如果设置了itemprop属性，meta元素提供用户自定义的元数据。

**属性：**

备注： 全局属性 name 在 `<meta>`元素中具有特殊的语义；另外，在同一个 `<meta>`标签中，name, http-equiv 或者 charset 三者中任何一个属性存在时，itemprop 属性不能被使用。

+ charset
  声明字符编码，如果使用了这个属性，其值必须是与ASCLL大小写无关的“utf-8“

```html
<meta charset="utf-8">
```

+ content
  此属性包含http-equiv 或name 属性的值，具体取决于所使用的值。

```html
<meta http-equiv="refresh" content="3;url=https://www.mozilla.org">
```

+ http-equiv
  属性定义了一个编译指示指令。这个属性叫做 http-equiv(alent) 是因为所有允许的值都是特定 HTTP 头部的名称，如下:
  + content-security-policy 它允许页面作者定义当前页的内容策略 (en-US)。内容策略主要指定允许的服务器源和脚本端点，这有助于防止跨站点脚本攻击。
  + content-type 如果使用这个属性，其值必须是"text/html; charset=utf-8"。注意：该属性只能用于 MIME type 为 text/html 的文档，不能用于 MIME 类型为 XML 的文档。
  + default-style 设置默认 CSS 样式表组的名称。
  + x-ua-compatible 如果指定，则 content 属性必须具有值 "IE=edge"。用户代理必须忽略此指示。
  + refresh 这个属性指定：
  如果 content 只包含一个正整数，则为重新载入页面的时间间隔 (秒)；
  如果 content 包含一个正整数，并且后面跟着字符串 ';url=' 和一个合法的 URL，则是重定向到指定链接的时间间隔 (秒)

```html
<!-- 可以在 https 协议下请求 http -->
<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests" />
```

+ name
  name 和 content 属性可以一起使用，以名 - 值对的方式给文档提供元数据，其中 name 作为元数据的名称，content 作为元数据的值。

```html
<!-- 移动端页面设置视口宽度等于设备宽度，并禁止缩放。 -->
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" />
<!-- 禁止将页面中的数字识别为电话号码 -->
<meta name="format-detection" content="telephone=no" />
<!-- name=author: 用来设置作者，给 SEO 使用 -->
<!-- name=keywords: 网页的关键字，给 SEO 使用 -->
<!-- name=description: 页面的描述，在浏览器用作书签时会显示对应的内容 -->
```

### 87.rgba()和opacity这两个的透明效果有什么区别呢？

**opacity:**

指定了一个元素的不透明度。换言之，opacity 属性指定了一个元素后面的背景的被覆盖程度。
当 opacity 属性的值应用于某个元素上时，是把这个元素（包括它的内容）当成一个整体看待，即使这个值没有被子元素继承。
因此，一个元素和它包含的子元素都会具有和元素背景相同的透明度，哪怕这个元素和它的子元素有不同的 opacity 属性值。

***使用 opacity 属性，当属性值不为 1 时，会把元素放置在一个新的层叠上下文中。***

语法：

```css
/* 完全不透明 */
opacity: 1;
opacity: 1.0;

/* 半透明 */
opacity: 0.6;

/* 完全透明 */
opacity: 0.0;
opacity: 0;

opacity: inherit;
```

**rgba():**

rgba 只对颜色（backgorund-color、color）有影响，放在background的话只对背景颜色有影响，不会影响其他内容及子元素。

### 88.解释代码意思

```js
[].forEach.call($$("*"),function(a){ 
  a.style.outline="1px solid #"+(~~(Math.random()*(1<<24))).toString(16) 
})
```

**作用：**
给页面所有 dom 元素添加随机颜色的边框。

**解析：**

+ [].forEach.call() => 调用引用数组的forEach方法
+ $$('*') => document.querySelectorAll('*')
+ ~~a => parseInt(a)
+ 1<<24 => 对二进数1小数点右移24位
+ (parseInt(Math.random()*(1<<24)).toString(16)) => 获得了一个位于0-16777216之间的随机整数，也就是随机颜色，再使用toString(16)将它转化为十六进制数。

```js
[].forEach.call(
  document.querySelectorAll('*'),
  function(a){
    a.style.outline="1px solid #" + 
      (parseInt(Math.random()*(1<<24)).toString(16))
  }
)
```

### 89.在浏览器中输入url到页面显示出来的过程发生了什么?

1.浏览器地址栏输入URL并回车
2.通过DNS将域名解析成IP地址。在解析过程中，按照浏览器缓存、系统缓存、路由器缓存、ISP(运营商)DNS缓存、根域名服务器、顶级域名服务器、主域名服务器的顺序，逐步读取缓存，直到拿到IP地址。（应用层）
3.根据获取IP进行tcp连接（三次握手）（传输层）
4.发送http请求
5.服务器处理请求，浏览器接收http的响应
6.渲染页面，构造dom树
7.关闭tcp连接（四次挥手）

### 90.写一个获取数组的最大值、最小值的方法？

```js
Math.max.apply(Array, [12, 9,239,12348,83974,1,324,342, -1, -273]) // 83974
Math.min.apply(Array, [12, 9,239,12348,83974,1,324,342, -1, -273]) // -273

function getMax(arr) {
  return arr.reduce((total, current) => total = total > current ? total : current)
}
getMax([12, 9,239,12348,83974,1,324,342, -1, -273]) // 83974

function getMin(arr) {
  return arr.reduce((total, current) => total = total < current ? total : current)
}
getMin([12, 9,239,12348,83974,1,324,342, -1, -273]) // -273
```

### 91.网页上的验证码是为了解决什么问题？说说你了解的验证码种类有哪些

1.图形验证码
2.字符验证码 文字+混淆 如早期的7456这种结果的验证码
3.复杂字符验证码 复杂文字+混淆 如加入中文等本土化的增加识别难度
4.计算验证码 数字+运算符+混淆 如1+2=? 需要识别表达式增加识别难度
5.精确识别 文字+混淆文字 如选出 优贝在线 中的 贝字，或者选出所有的筷子，所有的红绿灯（12306）
6.滑动拼图验证 图像+滑块+图像凹槽 如常见的滑动拼图，提供商有易盾之类的
7.拼图验证 图像+打乱 需要用户去拼合完成
8.手机短信验证码
9.手机发送一条短信

防止机器行为，确定是人为操作，比如登陆、发帖等。
保护服务器

### 92.描述下你所了解的图片格式及使用场景

|格式|优点|缺点|适用场景|
|:---:|:---:|:---:|:---:|
|gif|文件小，支持动画、透明，无兼容性问题|只支持256种颜色|色彩简单的logo、icon、动图|
|jpg|色彩丰富，文件小|有损压缩，反复保存图片质量下降明显|色彩丰富的图片/渐变图像|
|png|无损压缩，支持透明，简单图片尺寸小|不支持动画，色彩丰富的图片尺寸大|logo/icon/透明图|
|webp|文件小，支持有损和无损压缩，支持动画、透明|浏览器兼容性不好|支持webp格式的app和webview|