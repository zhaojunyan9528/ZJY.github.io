---
title: 每日一题
tags:
  - 前端
categories:
  - - 问题&总结
    - Javascript
date: 2022-03-28 09:40:12
---

### 1.js中 ?? 和 || 的区别？

```js
value1  ??  value2
value1  ||  value2
```

相同点：

  用法相同，都是符号前后是值，中间是符号。根据前面的值判断返回value1还是value2。

不同点：

  1.使用??时，只有当value1的值为null或undefined时才返回value2，否则返回value1
  2.使用||时，value1会转换为bool值，为true时返回value1,  false时返回value2

??更适合不知道变量是否有值时使用

### 2.URI和URL的区别

1.URI：统一资源标识符（Uniform Resource Identifier,URI）是一个标识某个互联网资源的字符串。表示Web上可用的每种资源-html文档、图像、视频片段、程序等由一个URI进行标识。

URI格式：[协议名]://[用户名]:[密码]@[服务器地址]:[端口号]/[路径]?[查询字符串]#[片段id]

2.URL：统一资源定位符（Uniform Resource Locator），采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL是URI概念的一种实现方式。

URL下列三部分组成:第一部分是协议（或称为服务方式）；第二部分是存有该资源的主机IP地址（有时也包括端口号）；第三部分是主机资源的具体地址。

3.URI和URL之间的区别

URI和URL都定义了资源是什么，但URL还定义了该如何访问资源。URL是一种具体的URI，它是URI的一个子集，它不仅唯一标识资源，而且还提供了定位该资源的信息。URI 是一种语义上的抽象概念，可以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位，是绝对的。

### 3.Http中的301，302，303，307，308相应状态码

1、301 Move Permanently

  表明资源永久的移动到了一个新的URI，任何未来对这个资源的引用都应该使用新的URI

2、302 Found

  表明资源临时的移动到了一个新的URI，由于重定向是临时的，所以之后的请求还应该使用原本的URI
  服务器会在响应头的Location字段放上这个不同的URI，浏览器可以使用这个URI进行自动重定向
  注：由于历史原因，用户代理可能会在重定向后把请求的post改为get方法。

3、303 See Other

  303 状态码表示服务器要将浏览器重定向到另一个资源，这个资源的 URI 会被写在响应 Header 的 Location 字段。从语义上讲，重定向到的资源并不是你所请求的资源，而是对你所请求资源的一些描述。
  303 常用于将 POST 请求重定向到 GET 请求，比如你上传了一份个人信息，服务器发回一个 303 响应，将你导向一个“上传成功”页面。
  不管原请求是什么方法，重定向请求的方法都是 GET（或 HEAD，不常用）

4、307 Temporary Redirect

  307 的定义实际上和 302 是一致的，唯一的区别在于，307 状态码不允许浏览器将原本为 POST 的请求重定向到 GET 请求上

5、308 Permanent Redirect

  308 的定义实际上和 301 是一致的，唯一的区别在于，308 状态码不允许浏览器将原本为 POST 的请求重定向到 GET 请求上

6、302和303、307的关系

302允许各种各样的重定向，一般情况下都会重定向到get，但不能确保post重定向到post
303只允许任意请求重定向到get
307和302一样，但不允许post到get的重定向

### 4.link和@import引入css的区别？

1、link是HTML的的标签，除了链接样式表还可以设置RSS，rel等属性，@import只能加载css
2、link会在页面加载时同时加载，@import会在页面加载完成后再加载
3、link无兼容性问题，@import是在css2.1提出，低版本浏览器不支持
4、可以通过js操作dom将link样式表插入文档改变样式，@import不支持

### 5.圣杯布局和双飞翼布局

三栏布局，两边固宽

圣杯布局：三栏利用float和负margin并列，利用父容器的padding给两边空出空间

```html
<div class="container">
  <div class="main">
    <p>圣杯布局</p>
    <p>hahahhaha</p>
  </div>
  <div class="left">left</div>
  <div class="right">right</div>
</div>
```

```css
* {
  padding: 0;
  margin: 0;
}
.container {
  padding: 0 60px 0 30px;
  height: 150px;

}
.main {
  float: left;
  width: 100%;
  height: 150px;
  background-color: aquamarine;
}
.left {
  float: left;
  width: 30px;
  height: 100px;
  background-color: darkkhaki;
  margin-left: calc(-100% - 30px);
}
.right {
  float: left;
  width: 60px;
  height: 100px;
  background-color: firebrick;
  /* margin-left: -60px;
  position: relative;
  left: 60px; */
  margin-right: -60px;
}
```

双飞翼布局：三栏利用float和负margin并列，中间栏加一层容器，利用margin给两栏空出空间

```html
<div class="container1">
  <div class="main1">
    <div class="content">
      <p>双飞翼布局</p>
      <p>hahahhaha</p>
    </div>
  </div>
  <div class="left1">left1</div>
  <div class="right1">right1</div>
  </div>
</div>
```

```css
* {
  padding: 0;
  margin: 0;
}
.container1 {
  width: 100%;
  height: 150px;
  border-top: 1px solid;
}
.container1 .main1 {
  float: left;
  width: 100%;
}
.content {
  height: 150px;
  background-color: aquamarine;
  margin: 0 60px 0 30px;
}
.left1 {
  float: left;
  width: 30px;
  height: 100px;
  margin-left: -100%;
  background-color: darkkhaki;
}
.right1 {
  float: left;
  width: 60px;
  height: 100px;
  margin-left: -60px;
  background-color: firebrick;
}
```

flex布局也可实现三栏布局

```html
<div class="container2">
  <div class="left2">left2</div>
  <div class="main2">
    flex
  </div>
  <div class="right2">right2</div>
</div>
```

```css
.container2 {
  width: 100%;
  height: 150px;
  border-top: 1px solid;
  display: flex;
  flex: 1 1 auto;
}
.main2 {
  height: 150px;
  background-color: aquamarine;
  width: 100%;
}
.left2 {
  width: 30px;
  height: 100px;
  background-color: darkkhaki;
}
.right2 {
  width: 60px;
  height: 100px;
  background-color: firebrick;
  flex-shrink: 0;
}
```

![image](/images/buju.jpg)

圣杯和双飞翼中间栏放首位可保证首先渲染，但是中间栏宽度小于左栏会页面错乱

### 6.用递归算法实现，数组长度为5且元素的随机整数数在2-32间不重复的值

```js
function randomArr5(arr) {
  arr = arr || []
  if (arr.length === 5) return arr
  let num = 2 + Math.floor(Math.random() * 31)
  if (!arr.includes(num)) arr.push(num)
  return randomArr5(arr)
}
randomArr5() // [30, 19, 28, 3, 11]
```

随机数2-32，数组长度5且元素不重复，递归

### 7. html的元素有哪些（包含h5）？

块元素：
html、body、head、header、nav、section、main、aside、footer页面结构
article、h1-h6、p 文章
div
ul、ol、li、dl、dt、dd 列表
table、tr、td、thead、tbody表格
form表单

行内元素：
a(inline)
span(inline)
img(inline)
strong(inline)、i(inline)、em(inline)文本内容
label(inline)
canvas(inline)
audio(inline,无controls值为none)、video(inline)媒体

行内块元素：
input(inline-block)
select(inline-block)
button(inline-block)

### 8.css3新特效有哪些？

1.边框属性
border-image(边框图片)、border-radius(边框圆角)、box-shadow(边框阴影)

2.背景属性
backgrou-image: url(),url();多背景图片
background-clip: border-box/padding-box/content-box;背景图片绘制区域，默认border-box图片被剪裁到边框盒
background-origin: padding-box/border-box/content-box;图片相对于什么位置定位，默认值padding-box
background-size: auto/cover/contain/length/%;景图像的尺寸

3.文本属性
text-shadow文本阴影
word-wrap: normal/break-word; 允许长单词或URL换行
word-break: normal/keep-all(只允许在半角空格或连字符处换行)/break-all(允许在单词内换行)

4.transform属性
2D或3D变换，允许元素进行旋转、移动、缩放、倾斜
transform：

+ none：不进行任何转换
+ matrix(n,n,n,n,n,n):定义2D转换，使用六个值的矩阵
+ matrix3d(n,…n):定义3D转换，使用16个值的矩阵
+ translate(x,y):定义2D转换
+ translate3d(x,y,z): 定义3D转换
+ translateX(x): 定义转换，只是用 X 轴的值。
+ translateY(y): 定义转换，只是用 Y 轴的值。
+ translateZ(z): 定义转换，只是用 Z 轴的值。
+ scale(x,y): 定义2D缩放转换
+ scale3d(x,y,z): 定义3D缩放转换
+ scaleX(x): 通过设置 X 轴的值来定义缩放转换。
+ scaleY(y): 通过设置 Y 轴的值来定义缩放转换。
+ scaleZ(z): 通过设置 Z 轴的值来定义缩放转换。
+ rotate(angle): 定义 2D 旋转，在参数中规定角度
+ rotate(x,y,angle): 定义3D旋转
+ rotateX(angle): 定义沿着 X 轴的 3D 旋转
+ rotatezY(angle): 定义沿着 Y 轴的 3D 旋转
+ rotateZ(angle): 定义沿着 Z 轴的 3D 旋转
+ skew(x-angle,y-angle): 定义沿着x轴和y轴倾斜转换
+ skewX(angle): 定义沿着X轴的2D倾斜转换
+ skewY(angle):定义沿着y轴的2D倾斜转换

5.过渡动画transition
transition: property duration timing-function delay;

```css
transion: width 2s;
div:hover {
  width: 30px;
}
```

6.animation动画

```css
div{
  animation: myFirst 5s;
}
@keyframes myFirst{
  from {
    background-color: red;
  }
  to {
    background-color: yellow;
  }
}
```

7.弹性盒子flexbox

8.多媒体查询@media

9.渐变
linear-gradient 线性渐变
radial-gradient 径向渐变

### 9.写一个方法去掉字符串中的空格，要求传入不同的类型分别能去掉前、后、前后、中间的空格

```js
function trim(str, type = 'all') {
    const Type = {
        left: /^\s+/g,
        right: /\s+$/g,
        all: /\s+/g,
        both: /^\s+|\s+$/g
    }
    if (type === 'center') {
        let leftStr = str.match(/^\s+/g)[0]
        let rightStr = str.match(/\s+$/g)[0]
        return leftStr + str.replace(/\s+/g,'') + rightStr
    }
    return str.replace(Type[type], '')
}
let strs = '  12 3  4  56 '
trim(strs) // all '123456'
trim(strs, 'left') // left '12 3  4  56 '
trim(strs, 'right') // right '  12 3  4  56'
trim(strs, 'both') // both '12 3  4  56'
trim(strs, 'center') // center '  123456 '
```

### 10.HTML全局属性（global attribute）有哪些？

全局属性是所有HTML元素共有的属性，它们可以用于所有元素，即使属性对某些元素不起作用。

1.accesskey提供了为当前元素生成键盘快捷键的提示。

```html
<input type="text" accesskey="n">
```

windows系统使用alt+n快捷键可快速选择对应元素
mac系统使用crtl+option+n快捷键

2.autocapitalize控制用户输入如何自动大写

3.class

4.contenteditable元素是否可以被编辑

5.data-* 自定义数据属性

6.dir指示元素中文本方向的枚举属性（ltr、rtl、auto）

7.draggable,枚举属性，指示是否可以使用Drog盒Drop API拖动元素

8.hidden隐藏元素

9.id唯一标识符

10.lang：定义元素的语言，xml:lang优先于它

11.spellcheck:是否启动拼写和语法检查

12.slot插槽，具有slot属性的元素被分配给由`<slot>`元素创建的沟槽，其name属性的值与slot属性的值匹配。

13.style内联样式

14.tabindex规定元素的tab键控制次序

15.title

16.translate页面本地化时是否转换元素的属性值及其Text 节点子节点的值

17.还有事件处理程序属性：onabort, onautocomplete, onautocompleteerror, onblur, oncancel, oncanplay, oncanplaythrough, onchange, onclick, onclose, oncontextmenu, oncuechange, ondblclick, ondrag, ondragend, ondragenter, ondragexit, ondragleave, ondragover, ondragstart, ondrop, ondurationchange, onemptied, onended, onerror, onfocus, oninput, oninvalid, onkeydown, onkeypress, onkeyup, onload, onloadeddata, onloadedmetadata, onloadstart, onmousedown, onmouseenter, onmouseleave, onmousemove, onmouseout, onmouseover, onmouseup, onmousewheel, onpause, onplay, onplaying, onprogress, onratechange, onreset, onresize, onscroll, onseeked, onseeking, onselect, onshow, onsort, onstalled, onsubmit, onsuspend, ontimeupdate, ontoggle, onvolumechange, onwaiting

### 11.页面上隐藏元素的方法有哪些？

1.给元素设置hidden属性，不占位
2.display:none;不占位
6.width:0;height:0;transform:scale(0);不占位
3.visibility:hidden;占位
4.opacity: 0;/filter: opacity(0);占位
5.filter: opacity(0);占位
7.width:0;height:0;overflow:hidden;有些元素有border值依然会占位，有宽高
8.position:absolute;left/margin-left:-1000%;脱离文档流不占位
9.position:absolute;z-index: -1;脱离文档流不占位,但是后面元素只是盖在该元素上面，如果后面元素比该元素小只会隐藏一部分
10.font-size:0;不占位仅对文本内容有效

### 12.去除字符串中最后一个指定的字符

```js
function delChar(str, char){
  if(typeof str !== 'string') {
    console.log('not string')
    return
  } else {
    let lastIndex = str.lastIndexOf(char)
    if (lastIndex != -1) {
      return str.substring(0, lastIndex) + str.substring(lastIndex + char.length)
    }
    console.log('not find ',char)
  }
}
delChar('abniok9866dasd%fnad#fv%vvv', 'd#') // 'abniok9866dasd%fnafv%vvv'

// 正则
function delLastAnyChar(str, char) {
  // [^]表示任意字符 .查找单个字符除换行和行结束符，单行模式下，[^]就是.,但是多行模式下，[^]可以匹配到\n
  // [^]*表示任意长度字符 ()表示元组，$1表示匹配到的第一个()内容
  let reg = new Reg(`(^[^]*)(${char})([^]*$)`)
  return str.replace(reg, '$1$3')
}
delLastAnyChar('acdabdbde', 'bd') // acdabde
```

### 13.HTML5离线存储方式有哪些，怎么使用，原理是什么？

浏览器检测是否在线 navigator.onLine 返回true/false

{% post_link HTML5存储方式 "详见（HTML5存储方式）" %}

### 14.css选择器有哪些？哪些属性可继承？

**选择器:**

+ 通用选择器  * 匹配文档内所有元素
+ 元素选择其 elementName
+ 类选择器 .className
+ id选择器 #idName
+ 组合选择器
  + element,element  h1,h2 {}
  + element element  body h1 {} 嵌套选择器或后代选择器
  + element > element  div > p, ul > li
  + element + element  div + p 相邻同级选择器
  + element1～element2  p~ul p和ul具有相同的父元素， ul在p后面，不必紧跟
+ 属性选择器
  + [attr]  a[class] a[target]
  + [attr=value]  p[class="title"]
  + [attr`~`=value] p[class`~`="test"] 包含指定属性值的元素，基于属性值空格分隔开的属性("test a"包含，"test_a"不包含)
  + [attr|=value] [lang|=en] 用于选择指定属性具有指定值开始的元素(en-us,en)
  + [attr^=value] [class^="test"] 匹配元素属性值带指定的值开始的元素(test,test_a)
  + [attr$=value] [class$="test"] 匹配元素属性值带指定的值结尾的元素(test, a_test)
  + [attr*=value] [class*="test"] 匹配元素属性值包含指定值的元素(test,a_test,test_a)
+ 伪类选择器
  :active,:after,:before,:checked,:disabled,:empty,:enabled,:first-child,:first-letter,:first-of-type,:focus,:hover,:in-range,:invalid,:lang(),:last-child,:last-of-type,:link,:not,:nth-child(),:nth-last-child(),:nth-last-of-type(),:nth-of-type(),:only-child,:optional,:out-of-range,:read-only,:read-write,:required,:root,::selection,:target,:valid,:visited

**可继承的属性:**

+ 字体系列属性
  font-family,font-weight,font-size,font-style,font-variant,font-stretch,font-size-adjust
+ 文本系列属性
  text-align, line-height, word-spacing, letter-spacing, text-transform, direction, color
+ 元素可见性
  visibility, opacity
+ 表格布局属性
+ 列表属性
+ 光标属性 cursor
...

### 15.写一个方法把下划线命名转成大驼峰命名

```js
function toCamelCase(str) {
  if (str.split('_').length === 1) return
  let arr = str.split('_')
  let res = ''
  arr.forEach(item => {
      res =  res + item.substr(0,1).toUpperCase() + item.substr(1)
  })
  return res
}
toCamelCase('a_project_name_title') // 'AProjectNameTitle'

// 正则
function toCamelCase(str) {
    if (!str.length) return
    str = str.replace(/(_)(\w)/g, (match,$1,$2) => {
        return $2.toUpperCase()
    })
    return str.substr(0,1).toUpperCase() + str.substr(1)
}
toCamelCase('test_project_container') // TestProjectContainer

function toCamelCase(str){
    return str.replace(/(^|_)(\w)/g,(m,$1,$2)=>$2.toUpperCase());
}
toCamelCase('test_project_container') // TestProjectContainer
```

### 16.简述超链接target属性的取值和作用

|target值 |作用 |
|:---:|:---:|
|_blank |在新的窗口打开被链接的文档|
|_self|默认，在相同框架中打开被链接的文档|
|_parent|在父框架集中打开被链接的文档|
|_top|在整个窗口中（最顶层框架集）打开被链接的文档|
|framename|在指定的框架中打开被链接的文档|

### 17.CSS3新增伪类有哪些并简要描述？

|新增伪类 |作用 |
|:---:|:---:|
|:first-of-type|p:first-of-type 选择的每个 p 元素是其父元素的第一个 p 元素|
|:last-of-type|p:last-of-type 匹配元素其父级是特定类型的最后一个子元素|
|:only-of-type|p:only-of-type 匹配p的父元素的唯一子元素p|
|:only-child|p:only-child 匹配p元素的父元素唯一的子元素p元素|
|:nth-child(n)|p:nth-child(2) 选择所有 p 元素的父元素的第二个子元素(不是第二个子p元素)|
|:enabled|input:enabled 选择所有启用的元素|
|:disabled|input:disabled 选择所有禁用的元素|
|:checked| input:checked 选择所有选中的元素|
|:empty|p:empty 选择所有没有子元素的p元素|
|:focus|input:focus 选择元素输入后具有焦点|
|:root|选择文档的根元素|

### 18.写一个把字符串大小写切换的方法？

例：aBcdEFg --> AbCDefG

```js
function caseConvert(str) {
    let res = ''
    for(let i of str) {
        res+= i.toLowerCase() === i ? i.toUpperCase() : i.toLowerCase()
    }
    return res
}
caseConvert('aBcdEfGD') // AbCDeFgd
// 正则
function caseConvert(str){
  return str.replace(/([a-z]*)([A-Z]*)/g, (m, s1, s2)=>{
    return `${s1.toUpperCase()}${s2.toLowerCase()}`
  })
}
caseConvert('例：aBcdEFg') // AbCDefG
```

### 19.label都有哪些作用？

1.关联表单控件，扩大点选范围
2.关联表单控件，聚焦到关联输入框
3.为input元素定义的标记
4.利用label"模拟"button来解决不同浏览器原生button样式不同的问题

### 20. 用css创建一个三角形，并简述原理

当width和height为0时，设置border会将其分割成45度的等腰三角形，设置上下左右border宽度或颜色透明即可得到三角形

```css
width: 0;
height: 0;
display: inline-block;
border: 10px solid red;
border-bottom-color: transparent;
border-left-color: transparent;
border-right-color: transparent;
```

若要获取左直角等三角形，只需修改上下左右边框颜色透明

### 21.写一个去除制表符和换行符的方法

```js
function removeTab(str) {
  return str.replace(/\n|\t/g, '')
}
removeTab('h\taha\nfdals') // hahafdals
```

### 22.iframe框架都有哪些优缺点?

缺点：
1.会产生多个页面，不容易管理
2.多iframe的页面会增加服务器的http请求
3.每个iframe对应一个页面，其多余的css和js文件的载入会增加请求的开销
4.window.onload事件会在所有的iframe加载完成后才触发，会造成页面阻塞
5.如果iframe内有滚动条，会影响用户的使用体验
6.代码复杂，无法被一些搜索引擎索引到，对搜索引擎不友好

优点：
1.投放广告之类的飘窗无疑是最好的选择
2.重载时只需要重载页面中的一个iframe，不需要重载整个页面
3.可以实现异步刷新，单个iframe刷新不影响整个窗口的刷新（在FormData无法使用时，可以实现无刷新上传）
4.可以实现跨域，每个iframe的源可以不相同（方便引入第三方内容）
5.多页面应用时，对于共同的header，footer可以使用iframe加载，拆分代码（方便制作导航栏）
6.技术容易掌握。可主要应用于不需要搜索引擎来搜索的页面

### 23.简述你对BFC规范的理解

{% post_link css-BFC "css-BFC" %}

### 24.统计某一字符或字符串在另一个字符串中出现的次数

```js
function countTarget(str, target) {
    let count = 0
    while(target.match(str)) {
        target = target.replace(str, " ")
        count++
    }
    return count
}
function countTarget(str, target) {
  return target.match(new RegExp(str, 'g')).length
}
countTarget("ad", "dasdlajdadeorwad") // 2
```

### 25.清除浮动的方式有哪些及优缺点

1.触发父元素BFC
如给父元素设置overflow:hidden，特别注意的是：在IE6中还需要触发hasLayout，例如给父元素设置zoom:1

原理是触发父级BFC后，父元素在计算高度时，浮动的子元素也会参与计算

优点
代码简洁

缺点
设置overflow:hidden容易造成不会自动换行导致超出的尺寸被隐藏掉，无法显示要溢出的元素

2.给父元素设置高度
优点
代码简洁

缺点
不够灵活，只适用于高度固定的布局

3.添加额外标签
在最后一个浮动元素的后面新加一个标签如

，并在其CSS样式中设置clear: both
优点
代码简洁，兼容性好

缺点
额外增加无语义html元素，代码语义化差，后期维护成本大

4.使用after伪元素

```css
.clearfix::after {
  content: ".";
  display: block;
  height: 0;
  line-height: 0;
  clear: both;
  visibility:hidden;
  font-size: 0;
}

.clearfix {
  // 注意此处是为了兼容IE6和IE7浏览器，即触发hasLayoutcs
  zoom: 1;
}
```

优点
符合闭合浮动思想，结构语义化正确

缺点
代码量多，因为IE6-7下不支持after伪元素，需要额外写 zoom:1来 触发hasLayout

### 26.写一个加密字符串的方法

```js
// 1.base-64加密
let tempStr = "hello world"
let tempPass = window.btoa(tempStr) // 'aGVsbG8gd29ybGQ='
// base-64解密
console.log(window.atob(tempPass)) // "hello world"

// 2.
function encode (str) {
  return btoa(encodeURIComponent(str));
}

function decode (str) {
  return decodeURIComponent(atob(str));
}
encode('hello world') // 'aGVsbG8lMjB3b3JsZA=='
decode('aGVsbG8lMjB3b3JsZA==') //'hello world'

// 3.
function encodeStr(str, padding) {
  return !str
    ? str
    : str.split('')
      .map(s => {
          return String.fromCharCode(s.charCodeAt() + padding)
      })
      .join('')
}
function decodeStr(str, padding) {
  return !str
    ? str
    : str.split('')
      .map(s => {
          return String.fromCharCode(s.charCodeAt() - padding)
      })
      .join('')
}
encodeStr('hello world!', 10) // 'rovvy*\x81y|vn+'
decodeStr('rovvy*\x81y|vn+', 10) // 'hello world!'
```

### 27.浏览器内多个标签页之间的通信方式有哪些?

1.websocket 可跨域
WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议

2.postMessage 可跨域

```js
window.addEventListener('message', function(){}) // 接收消息
window.parent.postMessage('msg', '*') // 发送消息 window.frames[0].postMessage Window.frames +索引值（命名或数字）
```

3.SharedWorker
作为浏览器的一个新特性，可以提供一个额外的线程来执行一些js代码（真正的多线程），并且不会影响到浏览器用户界面，但是不能DOM操作

4.Server-Sent Events
HTML5 服务器发送事件（server-sent event）允许网页获得来自服务器的更新。
Server-Sent 事件指的是网页自动获取来自服务器的更新。

5.localStorage（可以添加事件监听）

6.Cookies(Cookies在同一个域名内，并且目录也得相同)

7.BroadcastChannel(Chrome商店的api)
这个方式，只要是在同一原始域和用户代理下，所有窗口、iframe之间都可以进行交互。这个感觉就有点类似于广播了。

```js
//在一个页面上，触发事件，引发以下代码执行
//创建一个名字是mychannel的对象。记住这个名字，下面会用到
let cast = new BroadcastChannel('mychannel'); 
let myObj = { from: "children1", content: "add" };
cast.postMessage(myObj)

    
//在子页面上，定义以下代码(当前页面也可以接收消息)
//创建一个和刚才的名字一样的对象
let cast1 = new BroadcastChannel('mychannel');
cast1.onmessage = function (e) {
    alert(e)
}
```

### 28.简述下你理解的优雅降级和渐进增强

渐进增强（Progressive Enhancement）：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。

优雅降级（Graceful Degradation）：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。

在传统软件开发中，经常会提到向上兼容和向下兼容的概念。渐进增强相当于向上兼容，而优雅降级相当于向下兼容.

### 29.写一个判断数据类型的方法

```js
function getType(val) {
    return Object.prototype.toString.call(val).replace(/\[object\s|\]/g, '').toLowerCase()
}
getType(null) // null
getType(undefined) // 'undefined'
getType('') // 'string'
getType([]) // 'array'
getType({}) // 'object'
getType(true) // 'boolean'
getType(Number) // 'function'
getType(12) // 'number'
getType(Symbol('1')) // 'symbol'
```

### 30.viewport常见设置都有哪些？

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
```

该meta标签的作用是让当前viewport的宽度等于设备的宽度.同时不允许用户手动缩放
meta viewport有6个属性（content设置内容），如下：

|属性|作用|
|:---:|:---:|
|width|设置viewport  的宽度，为一个正整数，或字符串"width-device"|
|initial-scale|设置页面的初始缩放值，为一个数字，可以带小数|
|minimum-scale|允许用户的最小缩放值，为一个数字，可以带小数|
|maximum-scale|允许用户的最大缩放值，为一个数字，可以带小数|
|height|设置layout viewport  的高度，这个属性对我们并不重要，很少使用|
|user-scalable|是否允许用户进行缩放，值为"no"或"yes", no 代表不允许，yes代表允许|

此外，在安卓中还支持 target-densitydpi 这个私有属性，它表示目标设备的密度等级，作用是决定css中的1px代表多少物理像素.
target-densitydpi:值可以为一个数值或 high-dpi 、 medium-dpi、 low-dpi、 device-dpi 这几个字符串中的一个
当 target-densitydpi=device-dpi 时， css中的1px会等于物理像素中的1px。

首先如果不设置meta viewport标签，那么移动设备上浏览器默认的宽度值为800px，980px，1024px等这些，总之是大于屏幕宽度的。这里的宽度所用的单位px都是指css中的px，它跟代表实际屏幕物理像素的px不是一回事.

第二、每个移动设备浏览器中都有一个理想的宽度，这个理想的宽度是指css中的宽度，跟设备的物理宽度没有关系，在css中，这个宽度就相当于100%的所代表的那个宽度。我们可以用meta标签把viewport的宽度设为那个理想的宽度，如果不知道这个设备的理想宽度是多少，那么用device-width这个特殊值就行了，同时initial-scale=1也有把viewport的宽度设为理想宽度的作用.

可以同时使用

```html
<meta name="viewport" content="width=device-width, initial-scale=1">
```

### 31.对比下px、em、rem有什么不同？

px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。

em单位名称为相对长度单位。相对于当前对象内文本的字体尺寸.em的值并不是固定的；

rem是CSS3新增的一个相对单位（root em，根em）,仍然是相对大小，但相对的只是HTML根元素

### 32.简要描述下什么是回调函数并写一个例子出来

回调函数：做为实参数传入函数，并在该外部函数内调用，用以完成某些任务。

```js
function greeting(name) {
  alert('Hello,' + name)
}
function processUserInput(callback) {
  var name = prompt('Please enter your name.');
  callback(name);
}

processUserInput(greeting); 
```

以上示例为同步回调，它是立即执行的。
回调函数经常被用于在一个异步操作完成后执行代码，它们被称为异步回调.
一个常见的例子是在 promise 末尾添加的 .then 内执行回调函数（在 promise 被兑现或拒绝时执行）

### 33.你对标签语义化的理解是什么？

代码结构清晰，方便阅读，有利于团队合作开发。

方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以语义的方式来渲染网页。

有利于搜索引擎优化（SEO）。

### 34.css常用的布局方式有哪些？

流式布局: 最基本的布局，就是顺着 html 像流水一样流下来
绝对定位：