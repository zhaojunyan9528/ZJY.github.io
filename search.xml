<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>setTimeout中的this指向</title>
      <link href="/ZJY.github.io/2021/03/01/settimeout%E4%B8%AD%E7%9A%84this%E6%8C%87%E5%90%91/"/>
      <url>/ZJY.github.io/2021/03/01/settimeout%E4%B8%AD%E7%9A%84this%E6%8C%87%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h2 id="setTimeout中的this指向"><a href="#setTimeout中的this指向" class="headerlink" title="setTimeout中的this指向"></a>setTimeout中的this指向</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    x:<span class="number">2</span>,</span><br><span class="line">    fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(obj)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn(); </span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     x:2,</span></span><br><span class="line"><span class="comment">//     fn:f()</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     x:2,</span></span><br><span class="line"><span class="comment">//     fn:f()</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(obj.fn, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//window全局对象</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     x:2,</span></span><br><span class="line"><span class="comment">//     fn:f()</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//等同于：setTimeout是window下的方法</span></span><br><span class="line"><span class="built_in">window</span>.setTimeout(obj.fn, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// obj.fn相当于把fn函数给拿出来调用</span></span><br><span class="line"><span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);<span class="comment">//this是全局对象</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//全局</span></span><br><span class="line">        <span class="built_in">console</span>.log(obj);<span class="comment">//obj</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript的Object.create方法</title>
      <link href="/ZJY.github.io/2021/03/01/javascript%E7%9A%84Object-create%E6%96%B9%E6%B3%95/"/>
      <url>/ZJY.github.io/2021/03/01/javascript%E7%9A%84Object-create%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h2><p>Object.create()方法创建一个新的对象,使用现有的对象来提供新创建对象的<strong>proto</strong>.</p><p>语法:<br>Object.create(proto, [propertiesObject])<br>参数:<br>proto:新创建对象的原型对象,<br>propertiesObject:可选,需要传入一个对象.该对象的属性类型,参照Object.defineProperties()的,<br>第二个参数.如果该参数被指定且不为undefined,该传入对象的自有可枚举属性(即其自身定义的属性,而不<br>是其原型链上的枚举属性)将为新创建的对象添加指定的属性值和对应的属性描述符.<br>返回值:一个新对象,带着指定的原型对象和属性<br>例外:如果propertiesObject参数是null或非原始包装对象,则抛出一个typeerror异常</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  isHuman: <span class="literal">false</span>,</span><br><span class="line">  printIntroduction: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>. Am I human? <span class="subst">$&#123;<span class="built_in">this</span>.isHuman&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> me = <span class="built_in">Object</span>.create(person);</span><br><span class="line"><span class="built_in">console</span>.log(me);</span><br><span class="line"><span class="comment">// me&#123;</span></span><br><span class="line"><span class="comment">//     __proto__:&#123;</span></span><br><span class="line"><span class="comment">//         isHuman: false,</span></span><br><span class="line"><span class="comment">//         printIntroduction:function()</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">me.name = <span class="string">&#x27;zjy&#x27;</span>;</span><br><span class="line">me.isHuman = <span class="literal">true</span>;</span><br><span class="line">me.printIntroduction();</span><br><span class="line"><span class="built_in">console</span>.log(me);</span><br><span class="line"><span class="comment">// me&#123;</span></span><br><span class="line"><span class="comment">//     isHuman: true,</span></span><br><span class="line"><span class="comment">//     name:&#x27;zjy&#x27;,</span></span><br><span class="line"><span class="comment">//     __proto__:&#123;</span></span><br><span class="line"><span class="comment">//         isHuman: false,</span></span><br><span class="line"><span class="comment">//         printIntroduction:function()</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xxx = <span class="built_in">Object</span>.create(&#123;</span><br><span class="line">    a:<span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;,&#123;</span><br><span class="line">    <span class="string">&#x27;str&#x27;</span>:&#123;</span><br><span class="line">        value:<span class="string">&#x27;zjy&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>:&#123;</span><br><span class="line">        value:<span class="string">&#x27;ha&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(xxx);</span><br><span class="line"><span class="comment">// xxx&#123;</span></span><br><span class="line"><span class="comment">//     name:&#x27;ha&#x27;,</span></span><br><span class="line"><span class="comment">//     xxx:&#x27;zjy&#x27;,</span></span><br><span class="line"><span class="comment">//     __proto__:&#123;</span></span><br><span class="line"><span class="comment">//         a:&#x27;a&#x27;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aObj = &#123;</span><br><span class="line">    a:<span class="string">&#x27;zjy&#x27;</span>,</span><br><span class="line">    b:<span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">    c:<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;n:&#x27;</span>+n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> _aObj = <span class="built_in">Object</span>.create(aObj,&#123;</span><br><span class="line">    txt:&#123;</span><br><span class="line">        value:<span class="string">&#x27;Object.create()方法的继承&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(_aObj);</span><br><span class="line"><span class="comment">// _aObj&#123;</span></span><br><span class="line"><span class="comment">//     txt:&#x27;Object.create()方法的继承&#x27;,</span></span><br><span class="line"><span class="comment">//     __proto__:&#123;</span></span><br><span class="line"><span class="comment">//         a:&#x27;zjy&#x27;,</span></span><br><span class="line"><span class="comment">//         b:&#x27;name&#x27;,</span></span><br><span class="line"><span class="comment">//         c:funtion()</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">_aObj.c(<span class="string">&#x27;haha&#x27;</span>);<span class="comment">//n:haha</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript的Object.entries方法</title>
      <link href="/ZJY.github.io/2021/03/01/javascript%E7%9A%84Object-entries%E6%96%B9%E6%B3%95/"/>
      <url>/ZJY.github.io/2021/03/01/javascript%E7%9A%84Object-entries%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="Object-entries方法"><a href="#Object-entries方法" class="headerlink" title="Object.entries方法"></a>Object.entries方法</h2><p>Object.entries()方法会返回指定对象自身可枚举属性，并返回其健值对数组，其排列与使用与for…in遍历该对象时返回一致，只不过for…in还会枚举其原型链中属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;</span><br><span class="line">    a: <span class="string">&#x27;somestring&#x27;</span>,</span><br><span class="line">    b: <span class="number">42</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(object1));</span><br><span class="line"><span class="comment">// Array：[[&#x27;a&#x27;,&#x27;somestring&#x27;],[&quot;b&quot;,42]]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(object1)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a: somestring</span></span><br><span class="line"><span class="comment">// b: 42</span></span><br></pre></td></tr></table></figure><p>语法：Object.entries(obj)<br>参数：<br>obj: 可以返回枚举健值对的对象<br>返回值：返回指定对象可枚举属性的健值对数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">  baz: <span class="number">42</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(obj)); <span class="comment">// [ [&#x27;foo&#x27;, &#x27;bar&#x27;], [&#x27;baz&#x27;, 42] ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// array like object</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">&#x27;c&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(obj1)); <span class="comment">// [ [&#x27;0&#x27;, &#x27;a&#x27;], [&#x27;1&#x27;, &#x27;b&#x27;], [&#x27;2&#x27;, &#x27;c&#x27;] ]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// array like object with random key ordering</span></span><br><span class="line"><span class="keyword">const</span> anObj = &#123;</span><br><span class="line">    <span class="number">100</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="number">7</span>: <span class="string">&#x27;c&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(anObj)); <span class="comment">// [ [&#x27;2&#x27;, &#x27;b&#x27;], [&#x27;7&#x27;, &#x27;c&#x27;], [&#x27;100&#x27;, &#x27;a&#x27;] ]</span></span><br><span class="line"><span class="keyword">for</span> (k <span class="keyword">in</span> anObj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(k); <span class="comment">//2   7   10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// getFoo is property which isn&#x27;t enumerable</span></span><br><span class="line"><span class="comment">// create和defineProperty方法创建对象属性,enumerable默认值为false</span></span><br><span class="line"><span class="keyword">const</span> myObj = <span class="built_in">Object</span>.create(&#123;&#125;, &#123;</span><br><span class="line">  getFoo: &#123;</span><br><span class="line">      <span class="function"><span class="title">value</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">this</span>.foo;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(myObj); <span class="comment">//&#123; getFoo:()&#125;</span></span><br><span class="line">myObj.foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myObj); <span class="comment">//&#123;foo:&quot;bar&quot;,getFoo:()&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(myObj)); <span class="comment">// [ [&#x27;foo&#x27;, &#x27;bar&#x27;] ]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// non-object argument will be coerced to an object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// [ [&#x27;0&#x27;, &#x27;f&#x27;], [&#x27;1&#x27;, &#x27;o&#x27;], [&#x27;2&#x27;, &#x27;o&#x27;] ]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// iterate through key-value gracefully</span></span><br><span class="line"><span class="keyword">const</span> objs = &#123;</span><br><span class="line">    a: <span class="number">5</span>,</span><br><span class="line">    b: <span class="number">7</span>,</span><br><span class="line">    c: <span class="number">9</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(objs)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> <span class="subst">$&#123;value&#125;</span>`</span>); <span class="comment">// &quot;a 5&quot;, &quot;b 7&quot;, &quot;c 9&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Or, using array extras</span></span><br><span class="line"><span class="built_in">Object</span>.entries(objs).forEach(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> <span class="subst">$&#123;value&#125;</span>`</span>); <span class="comment">// &quot;a 5&quot;, &quot;b 7&quot;, &quot;c 9&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Object转换为Map:</span></span><br><span class="line"><span class="comment">// new Map() 构造函数接受一个可迭代的entries。借助Object.entries方法你可以</span></span><br><span class="line"><span class="comment">// 很容易的将Object转换为Map:</span></span><br><span class="line"><span class="keyword">var</span> obj3 = &#123; <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;; </span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(obj3));</span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// Map &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript的Object.assign方法</title>
      <link href="/ZJY.github.io/2021/03/01/javascript%E7%9A%84Object-assign%E6%96%B9%E6%B3%95/"/>
      <url>/ZJY.github.io/2021/03/01/javascript%E7%9A%84Object-assign%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Object.assign方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象，并返回目标对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> resourceObject = &#123;</span><br><span class="line">    b: <span class="number">4</span>,</span><br><span class="line">    c: <span class="number">5</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> resourceObject1 = &#123;</span><br><span class="line">    d: <span class="number">6</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> returnObject = <span class="built_in">Object</span>.assign(target, resourceObject, resourceObject1);</span><br><span class="line"><span class="built_in">console</span>.log(target);</span><br><span class="line"><span class="built_in">console</span>.log(returnObject);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   a:1,</span></span><br><span class="line"><span class="comment">//   b:4,</span></span><br><span class="line"><span class="comment">//   c:5,</span></span><br><span class="line"><span class="comment">//   d:6</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>语法：Object.assign(target,…resource);<br>参数：</p><ul><li>target：目标对象</li><li>resource：源对象<br>返回值：目标对象<br>描述：如果目标对象和源对象有相同属性，则目标对象属性值会被源对象覆盖，相应的后面的源对象的属性会覆盖前面源对象的属性</li></ul><p>Object.assign只会拷贝源对象自身的并且可枚举属性到目标对象上。该方法使用源对象的getter方法和目标对象的setter方法。因此他分配属性不仅仅是复制或定义新的属性。<br>如果合并源包含getter，可能不适合将新属性合并到原型上，为了将属性定义复制到原型，应使用Object.defineProperty和Object.getOwnPropertyDescriptor()</p><p>注意，Object.assign不会在源对象属性值为null或undefined时抛出错误</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">    test:<span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">    foo:<span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(a,b)</span><br><span class="line"><span class="comment">// &#123;test:null, foo:undefined&#125;</span></span><br></pre></td></tr></table></figure><p>String和Symbol类型的属性都会被拷贝.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">    c: <span class="built_in">Symbol</span>.for(<span class="number">1</span>),</span><br><span class="line">    d: <span class="built_in">String</span>(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(b, <span class="string">&#x27;b&#x27;</span>, &#123;</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="number">4</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> c = <span class="built_in">Object</span>.assign(a, b);</span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br><span class="line"><span class="comment">// object&#123;</span></span><br><span class="line"><span class="comment">//     a:1,</span></span><br><span class="line"><span class="comment">//     b:2,</span></span><br><span class="line"><span class="comment">//     c:Symbol(1),</span></span><br><span class="line"><span class="comment">//     d:&#x27;aaa&#x27;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getter获取a.b属性的值，对目标对象b.b属性进行覆盖，调用b的setter方法，但b.b不可修改，报错</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="built_in">Object</span>.assign(b,a);<span class="comment">//typeerror:cannot assign to read only property &#x27;b&#x27; </span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> aa = &#123;</span><br><span class="line">    a: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> bb = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(bb, <span class="string">&#x27;b&#x27;</span>, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;i am b&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> cc = <span class="built_in">Object</span>.assign(aa, bb);</span><br><span class="line"><span class="built_in">console</span>.log(cc);</span><br><span class="line"><span class="comment">// object&#123;</span></span><br><span class="line"><span class="comment">//     a:&#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#125;//不能将含有getter的属性合并到原型中</span></span><br></pre></td></tr></table></figure><h3 id="深拷贝问题"><a href="#深拷贝问题" class="headerlink" title="深拷贝问题:"></a>深拷贝问题:</h3><p>针对深拷贝，需要使用其他办法，因为 Object.assign()拷贝的是（可枚举）属性值。<br>假如源值是一个对象的引用，它仅仅会复制其引用值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> log = <span class="built_in">console</span>.log;</span><br><span class="line"><span class="keyword">const</span> stringify = <span class="built_in">JSON</span>.stringify</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    &#x27;use strict&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">        a: <span class="number">0</span>,</span><br><span class="line">        b: &#123;</span><br><span class="line">            c: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1);</span><br><span class="line">    log(stringify(obj2)); <span class="comment">//&#123;&quot;a&quot;:0,&quot;b&quot;:&#123;&quot;c&quot;:0&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    obj1.a = <span class="number">1</span>;</span><br><span class="line">    log(stringify(obj1)); <span class="comment">//&#123;&quot;a&quot;:1,&quot;b&quot;:&#123;&quot;c&quot;:0&#125;&#125;</span></span><br><span class="line">    log(stringify(obj2)); <span class="comment">//&#123;&quot;a&quot;:0,&quot;b&quot;:&#123;&quot;c&quot;:0&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    obj2.a = <span class="number">2</span>;</span><br><span class="line">    log(stringify(obj1)); <span class="comment">//&#123;&quot;a&quot;:1,&quot;b&quot;:&#123;&quot;c&quot;:0&#125;&#125;</span></span><br><span class="line">    log(stringify(obj2)); <span class="comment">//&#123;&quot;a&quot;:2,&quot;b&quot;:&#123;&quot;c&quot;:0&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    obj2.b.c = <span class="number">3</span>;</span><br><span class="line">    log(stringify(obj1)); <span class="comment">//&#123;&quot;a&quot;:1,&quot;b&quot;:&#123;&quot;c&quot;:3&#125;&#125;</span></span><br><span class="line">    log(stringify(obj2)); <span class="comment">//&#123;&quot;a&quot;:1,&quot;b&quot;:&#123;&quot;c&quot;:3&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//deep clone</span></span><br><span class="line">    obj1 = &#123;</span><br><span class="line">        a: <span class="number">0</span>,</span><br><span class="line">        b: &#123;</span><br><span class="line">            c: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> obj3 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj1));</span><br><span class="line">    obj1.a = <span class="number">4</span>;</span><br><span class="line">    obj1.b.c = <span class="number">4</span>;</span><br><span class="line">    log(stringify(obj3)); <span class="comment">//&#123;&quot;a&quot;:0,&quot;b&quot;:&#123;&quot;c&quot;:0&#125;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>合并对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 = &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> o2 = &#123;</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> o3 = &#123;</span><br><span class="line">    c: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj4 = <span class="built_in">Object</span>.assign(o1, o2, o3);</span><br><span class="line"><span class="built_in">console</span>.log(obj4); <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(o1); <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;, 注意目标对象自身也会改变</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>合并具有相同属性的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oo1 = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">1</span>,</span><br><span class="line">  c: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> oo2 = &#123;</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> oo3 = &#123;</span><br><span class="line">  c: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj5 = <span class="built_in">Object</span>.assign(&#123;&#125;, oo1, oo2, oo3);</span><br><span class="line"><span class="built_in">console</span>.log(obj5); <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;</span></span><br></pre></td></tr></table></figure><p>拷贝 symbol 类型的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> v1 = &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> v2 = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)]: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj6 = <span class="built_in">Object</span>.assign(&#123;&#125;, v1, v2);</span><br><span class="line"><span class="built_in">console</span>.log(obj6); <span class="comment">// &#123; a : 1, Symbol(&quot;foo&quot;): 2 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(obj6)); <span class="comment">// [Symbol(foo)]</span></span><br></pre></td></tr></table></figure><p>继承属性和不可枚举属性是不能拷贝的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj7 = <span class="built_in">Object</span>.create(&#123;</span><br><span class="line">    foo: <span class="number">1</span></span><br><span class="line">&#125;, &#123; <span class="comment">// foo 是个继承属性。</span></span><br><span class="line">    bar: &#123;</span><br><span class="line">        value: <span class="number">2</span> <span class="comment">// bar 是个不可枚举属性。</span></span><br><span class="line">    &#125;,</span><br><span class="line">    baz: &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        enumerable: <span class="literal">true</span> <span class="comment">// baz 是个自身可枚举属性。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> copy = <span class="built_in">Object</span>.assign(&#123;&#125;, obj7);</span><br><span class="line"><span class="built_in">console</span>.log(copy); <span class="comment">// &#123; baz: 3 &#125;</span></span><br></pre></td></tr></table></figure><p>原始类型会被包装为对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m1 = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> m2 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> m3 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> m4 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> res = <span class="built_in">Object</span>.assign(&#123;&#125;, m1, <span class="literal">null</span>, m2, <span class="literal">undefined</span>, m3, m4);</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//     0:&#x27;a&#x27;,</span></span><br><span class="line"><span class="comment">//     1:&#x27;b&#x27;,</span></span><br><span class="line"><span class="comment">//     2:&#x27;c&#x27;,</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> res) <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(res <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res1 = <span class="built_in">Object</span>.assign(<span class="literal">true</span>, <span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res1);</span><br><span class="line"><span class="comment">// Boolean&#123;</span></span><br><span class="line"><span class="comment">//     true,</span></span><br><span class="line"><span class="comment">//     0:&#x27;a&#x27;,</span></span><br><span class="line"><span class="comment">//     1:&#x27;b&#x27;,</span></span><br><span class="line"><span class="comment">//     2:&#x27;c&#x27;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> res1); <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(res1 <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res2 = <span class="built_in">Object</span>.assign(<span class="string">&#x27;abc&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res2);</span><br><span class="line"><span class="comment">// String&#123;</span></span><br><span class="line"><span class="comment">//     0:&#x27;a&#x27;,</span></span><br><span class="line"><span class="comment">//     1:&#x27;b&#x27;,</span></span><br><span class="line"><span class="comment">//     2:&#x27;c&#x27;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> res2); <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(res2 <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res3 = <span class="built_in">Object</span>.assign(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res3);</span><br><span class="line"><span class="comment">// Number&#123;10,0:&#x27;a&#x27;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> res3); <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(res3 <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>异常会打断后续拷贝任务</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetObj = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">&quot;foo&quot;</span>, &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  writable: <span class="literal">false</span></span><br><span class="line">&#125;); <span class="comment">// targetObj 的 foo 属性是个只读属性。</span></span><br><span class="line"><span class="built_in">Object</span>.assign(targetObj, &#123;<span class="attr">bar</span>: <span class="number">2</span>&#125;, &#123;<span class="attr">foo2</span>: <span class="number">3</span>, <span class="attr">foo</span>: <span class="number">3</span>, <span class="attr">foo3</span>: <span class="number">3</span>&#125;, &#123;<span class="attr">baz</span>: <span class="number">4</span>&#125;);<span class="comment">// TypeError: &quot;foo&quot; is read-only</span></span><br></pre></td></tr></table></figure><p>注意这个异常是在拷贝第二个源对象的第二个属性时发生的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// console.log(targetObj);//&#123;bar:2,foo2:3,foo:1&#125;</span></span><br><span class="line"><span class="comment">// console.log(targetObj.bar);  // 2，说明第一个源对象拷贝成功了。</span></span><br><span class="line"><span class="comment">// console.log(targetObj.foo2); // 3，说明第二个源对象的第一个属性也拷贝成功了。</span></span><br><span class="line"><span class="comment">// console.log(targetObj.foo);  // 1，只读属性不能被覆盖，所以第二个源对象的第二个属性拷贝失败了。</span></span><br><span class="line"><span class="comment">// console.log(targetObj.foo3); // undefined，异常之后 assign 方法就退出了，第三个属性是不会被拷贝到的。</span></span><br><span class="line"><span class="comment">// console.log(targetObj.baz);  // undefined，第三个源对象更是不会被拷贝到的。</span></span><br></pre></td></tr></table></figure><p>拷贝访问器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">bar</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)]: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> copy1 = <span class="built_in">Object</span>.assign(&#123;&#125;, o);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;assign&#x27;</span>,copy1); <span class="comment">//copy.bar的值来自obj.bar的getter函数的返回值 &#123;foo:1,bar:2&#125;</span></span><br><span class="line"><span class="comment">// assign&#123;</span></span><br><span class="line"><span class="comment">//     bar:2,</span></span><br><span class="line"><span class="comment">//     foo:1,</span></span><br><span class="line"><span class="comment">//     Symbol(foo):1</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript的reduce方法</title>
      <link href="/ZJY.github.io/2021/03/01/javascript%E7%9A%84reduce%E6%96%B9%E6%B3%95/"/>
      <url>/ZJY.github.io/2021/03/01/javascript%E7%9A%84reduce%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>reduce()方法接收一个函数作为累加器，数组中的每个值从左向右缩减，最终计算为一个值<br>reduce()作为空数组不会执行回调函数的。</p><p>语法:<br>reduce(function(total,currentValue,currentIndex,arr),initalValue);<br>参数：</p><ul><li>function(total,currentValue,currentIndex,arr)：必须，用于执行每个数组元素的函数<ul><li>total:必须，初始值或者用于计算后返回的函数值</li><li>currentValue:必须，当前值</li><li>currentIndex：可选，当前元素索引</li><li>arr: 可选，当前元素所属的数组对象</li></ul></li><li>initalValue:可选，传递给函数的初始值</li></ul><p>返回值：计算结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">total,num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> total + num</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//6</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript中this的指向</title>
      <link href="/ZJY.github.io/2021/03/01/javascript%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91/"/>
      <url>/ZJY.github.io/2021/03/01/javascript%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h2 id="javascript中this的指向"><a href="#javascript中this的指向" class="headerlink" title="javascript中this的指向"></a>javascript中this的指向</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xx</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">//window</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span> === <span class="built_in">window</span>); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line">xx();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> yy = &#123;</span><br><span class="line">  a:<span class="string">&#x27;zjy&#x27;</span>,</span><br><span class="line">  b:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//yy</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span> === yy);<span class="comment">//true</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">bb</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//window</span></span><br><span class="line">      &#125;</span><br><span class="line">      bb();<span class="comment">//bb只是在yy的属性b中执行，并不是b的属性，属于window</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">yy.b();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    s:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = o.s;</span><br><span class="line">f();<span class="comment">//this指向window,js中函数是按引用传递的</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xx3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.x = <span class="number">333</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">//xx3:&#123;x: 333&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.__proto__==xx3.prototype);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> xx3();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dom事件级别</title>
      <link href="/ZJY.github.io/2021/03/01/dom%E4%BA%8B%E4%BB%B6%E7%BA%A7%E5%88%AB/"/>
      <url>/ZJY.github.io/2021/03/01/dom%E4%BA%8B%E4%BB%B6%E7%BA%A7%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="DOM事件级别"><a href="#DOM事件级别" class="headerlink" title="DOM事件级别"></a>DOM事件级别</h2><p>DOM级别一共可以分为四个级别：DOM0级、DOM1级、DOM2级和DOM3级。而DOM事件分为3个级别：DOM 0级事件处理，DOM 2级事件处理和DOM 3级事件处理。由于DOM 1级中没有事件的相关内容，所以没有DOM 1级事件</p><h2 id="dom0级事件"><a href="#dom0级事件" class="headerlink" title="dom0级事件"></a>dom0级事件</h2><p>不允许为同个元素绑定多个同类dom0级事件，给元素的事件行为绑定方法，这些方法都是在当前元素事件的冒泡或者目标阶段执行的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;btn1&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;click me:dom0&#x27;)&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn1&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;click me: dom1&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击btn1时，输出’click me: dom1’，不允许为同个元素绑定多个同类dom0级事件</p><h2 id="dom2级事件"><a href="#dom2级事件" class="headerlink" title="dom2级事件"></a>dom2级事件</h2><p>el.addEventListener(event-name, callback, useCapture)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn1&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;click me: addEventListener111&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn1&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;click me: addEventListener222&#x27;</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>点击btn1，依次输出：<br>click me: addEventListener111<br>click me: addEventListener222</p><h2 id="dom3级事件：在dom2级事件基础上添加了更多的事件类型。"><a href="#dom3级事件：在dom2级事件基础上添加了更多的事件类型。" class="headerlink" title="dom3级事件：在dom2级事件基础上添加了更多的事件类型。"></a>dom3级事件：在dom2级事件基础上添加了更多的事件类型。</h2><p>UI事件:当用户与页面上元素交互时触发,比如:load,scroll,<br>焦点事件:当元素获得或失去焦点时触发,比如:blur,focus,<br>鼠标事件:当用户通过鼠标在页面执行操作时触发如：dblclick、mouseup,<br>滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel<br>文本事件，当在文档中输入文本时触发，如：textInput<br>键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress<br>合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart<br>变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified<br>同时DOM3级事件也允许使用者自定义一些事件</p><h2 id="DOM事件模型和事件流"><a href="#DOM事件模型和事件流" class="headerlink" title="DOM事件模型和事件流"></a>DOM事件模型和事件流</h2><p>DOM事件模型分为捕获和冒泡。一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段</p><p>1.捕获阶段：事件从window对象自上而下向目标节点传播的阶段<br>2.目标阶段：真正的目标节点正在处理事件的阶段<br>3.冒泡阶段：事件从目标节点自下而上向window对象传播的阶段</p><h2 id="事件代理（事件委托）"><a href="#事件代理（事件委托）" class="headerlink" title="事件代理（事件委托）"></a>事件代理（事件委托）</h2><p>由于事件会在冒泡阶段传播到父元素上，由父元素监听函数同时处理多个子节点的事件，称为事件代理。<br>优点：减少内存的消耗提高性能</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;list&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 兼容性处理</span></span><br><span class="line">  <span class="keyword">var</span> event = e || <span class="built_in">window</span>.event;</span><br><span class="line">  <span class="keyword">var</span> target = event.target || event.srcElement;</span><br><span class="line">  <span class="comment">// 判断是否匹配目标元素</span></span><br><span class="line">  <span class="keyword">if</span> (target.nodeName.toLocaleLowerCase() === <span class="string">&#x27;li&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;the content is: &#x27;</span>, target.innerHTML);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Event对象常见的应用"><a href="#Event对象常见的应用" class="headerlink" title="Event对象常见的应用"></a>Event对象常见的应用</h2><p>event.preventDefault();阻止默认事件的发生，比如链接跳转，表单提交<br>event.stopPropagation();阻止事件冒泡到父元素,阻止任何父元素事件处理程序被执行<br>event.stopImmediatePropagation();既能阻止事件向父元素冒泡,也能阻止元素同事件类型的其他监听器被触发</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#btn1&#x27;</span>);</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;btn click 1&#x27;</span>);</span><br><span class="line">  event.stopImmediatePropagation();</span><br><span class="line">&#125;);</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;btn click 2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;body click&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>点击btn，输出’btn click 1’</p><h2 id="event-amp-currentTarget"><a href="#event-amp-currentTarget" class="headerlink" title="event &amp; currentTarget"></a>event &amp; currentTarget</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;b&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;c&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;d&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;a&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;target: &#x27;</span>+ e.target.id+<span class="string">&#x27; &amp;curretTarget: &#x27;</span>+e.currentTarget.id)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;b&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;target: &#x27;</span>+ e.target.id+<span class="string">&#x27; &amp;curretTarget: &#x27;</span>+e.currentTarget.id)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;c&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;target: &#x27;</span>+ e.target.id+<span class="string">&#x27; &amp;curretTarget: &#x27;</span>+e.currentTarget.id)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;d&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;target: &#x27;</span>+ e.target.id+<span class="string">&#x27; &amp;curretTarget: &#x27;</span>+e.currentTarget.id)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>点击d元素，依次输出：<br>target: d &amp;curretTarget: d<br>target: d &amp;curretTarget: c<br>target: d &amp;curretTarget: b<br>target: d &amp;curretTarget: a</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript的双向绑定</title>
      <link href="/ZJY.github.io/2021/02/28/javascript%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
      <url>/ZJY.github.io/2021/02/28/javascript%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<p>实现双向绑定方式：</p><ul><li>1.javascript的get、set方法</li><li>2.Object.defineProperty</li><li>3.es6的proxy</li></ul><h2 id="JavaScript的get-set方法"><a href="#JavaScript的get-set方法" class="headerlink" title="JavaScript的get,set方法"></a>JavaScript的get,set方法</h2><p>在创建新对象初始化时定义一个getter<br>get语法将对象属性绑定到查询该属性时将调用的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  _t:<span class="string">&#x27;zjy&#x27;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">fn</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._t;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title">fn</span>(<span class="params">_x</span>)&#123;</span><br><span class="line">    <span class="built_in">this</span>._t = _x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.fn); <span class="comment">//zjy</span></span><br><span class="line"><span class="built_in">console</span>.log(obj._t); <span class="comment">//zjy</span></span><br><span class="line">obj.fn = <span class="string">&#x27;hahaha&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.fn); <span class="comment">//hahaha</span></span><br><span class="line"><span class="built_in">console</span>.log(obj._t); <span class="comment">//hahaha</span></span><br></pre></td></tr></table></figure><p>使用delete操作符删除getter</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> obj.fn; <span class="comment">//true</span></span><br><span class="line">obj.fn; <span class="comment">//undefined</span></span><br><span class="line">obj._t; <span class="comment">//hahaha</span></span><br></pre></td></tr></table></figure><h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h2><p>使用defineProperty在现有对象上定义getter<br>要随时在现有对象上添加getter，使用Object.defineProperty</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;b&#x27;</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.a + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj.a); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.b); <span class="comment">//2</span></span><br><span class="line">obj.a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.b); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">obj.b = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.b); <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>使用计算出的属性名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expr = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  get [expr]() &#123; <span class="keyword">return</span> <span class="string">&#x27;bar&#x27;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.foo); <span class="comment">//bar</span></span><br></pre></td></tr></table></figure><h3 id="get-vs-defineProperty"><a href="#get-vs-defineProperty" class="headerlink" title="get vs. defineProperty"></a>get vs. defineProperty</h3><p>1.当使用 get 关键字时，它和Object.defineProperty() 有类似的效果，在classes中使用时，二者有细微的差别。</p><p>2.当使用 get 关键字时，属性将被定义在实例的原型上，当使用Object.defineProperty()时，属性将被定义在实例自身上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">hello</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> exa = <span class="keyword">new</span> Example();</span><br><span class="line"><span class="built_in">console</span>.log(exa.hello);<span class="comment">//world</span></span><br></pre></td></tr></table></figure><p>Object.getOwnPropertyDescriptor(obj,property)方法返回指定对象上一个自有属性对应的属性描述符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(exa,<span class="string">&#x27;hello&#x27;</span>); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(getPropertyOf(exa),<span class="string">&#x27;hello&#x27;</span>); <span class="comment">//&#123; configurable: true, enumerable: false, get:funciton, set:undefined&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">&#x27;aaa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">//&#123; configurable: true, enumerable: true, value: &quot;aaa&quot;, writable: true&#125;</span></span><br></pre></td></tr></table></figure><p>语法：Object.getOwnPropertyDescriptor(obj,prop)<br>参数：</p><ul><li>1.obj:需要查找的对象</li><li>2.prop:目标对象内属性名称</li><li>3.返回值：如果指定的属性存在对象上，则返回其属性描述符对象。否则返回undefined</li><li>4.描述：该方法允许对一个属性的描述进行检索。属性描述符由以下组成：<ul><li>value：该属性的值（仅针对数据属性描述符有效）</li><li>writable：当且仅当该属性值可修改时为true（仅数据描述符有效）</li><li>get: 获取该属性的访问器函数，如果没有访问器，则该值为undefined（仅针对包含访问器或设置器的属性描述符有效）</li><li>set: 获取该属性的设置器函数，如果没有设置器，则该值为undefined（仅针对包含访问器或设置器的属性描述符有效）</li><li>configurable: 当且仅当对象属性描述可以被改变或者该属性可以被删除时，该值为true</li><li>enumerble: 当且仅当属性可枚举时，该值为true</li></ul></li></ul><p>访问器属性描述符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">foo</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">17</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj,<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line"><span class="comment">//&#123; enumerable: true, configurable: true, get:f foo(), set:undefined&#125;</span></span><br></pre></td></tr></table></figure><p>数据属性描述符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo:<span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj,<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line"><span class="comment">//&#123; writable: true, value:&#x27;bar&#x27;, configurable: true, enumerable:true&#125;</span></span><br></pre></td></tr></table></figure><p>使用Object.defineProperty(obj,prop)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;foo&#x27;</span>,&#123;</span><br><span class="line">    value: <span class="number">12</span>,</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    enumerable:<span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(o,<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line"><span class="comment">// &#123;value: 12, writable: false, enumerable: false, configurable: false&#125;</span></span><br></pre></td></tr></table></figure><p>Object.defineProperty()方法会直接在一个对象上定义一个新的属性，或者修改一个对象的现有属性，并返回此对象。<br>备注：应当直接在 Object 构造器对象上调用此方法，而不是在任意一个 Object 类型的实例上调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj1,<span class="string">&#x27;property1&#x27;</span>,&#123;</span><br><span class="line">    value:<span class="number">44</span>,</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line">obj1.property1 = <span class="number">77</span>;<span class="comment">//// throws an error in strict mode</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.property1); <span class="comment">//44</span></span><br></pre></td></tr></table></figure><p>语法：Object.defineProperty(obj,prop,desc)<br>参数：</p><ul><li>obj: 要定义属性的对象</li><li>prop: 要定义或要修改的属性名称或Symbol</li><li>desc：要定义或要修改的属性描述符</li></ul><p>返回值：被传递给函数的对象<br>描述：该方法允许精确的添加或修改对象的属性。通过赋值操作添加的普通属性都是可枚举的（例：var obj = {a:’a’}）.可通过for…in或Object.keys枚举到。可以修改这些属性的值，也可以删除属性。</p><p>默认情况下，通过Object.defineProperty方法添加的属性是不可修改的。<br>对象里目前存在2种类型的描述符：</p><ul><li>数据描述符：具有值的属性，该值可被修改也可以不能被修改</li><li>存取描述符：由getter或者setter函数所描述的属性</li></ul><p>一个描述符只能是2种描述符的一种，不能同时存在。他们共享以下可选健值（默认值是指在使用Object.defineProperty()定义属性时的默认值）：</p><ul><li>configurable: 当且仅当该值为true时，该属性的值可修改，属性也可以被删除</li><li>enumerable：当且仅当该值为true时，该属性可以被枚举</li></ul><p>数据描述符还具有以下可选健值：</p><ul><li>value：该属性对应的值，可以是任何任何js值，默认为undefined</li><li>writable: 当且仅当该值为true时，value的值才可被赋值运算修改，默认为false</li></ul><p>存取描述符还具有以下可选健值：</p><ul><li>get：属性的getter函数，如果没有，则为undefined，当访问该属性时，会调用该函数，执行时不传入任何参数，但是会默认传入this对象，由于继承关系，this不一定是该属性所属对象，该函数的返回值被用作属性的值默认为undefined</li><li>set：属性的setter函数，如果没有，则为undefined，当属性值被修改时，会调用该函数，该方法接受一个参数。默认把赋值时的this对象传入，默认值为undefined</li></ul><p>描述符汇总：<br>拥有布尔值的属性：writable,configurable,enumerable,默认值false<br>属性值和函数的键：value,get,set，默认值undefined</p><p>描述符可以拥有的健值：</p><table><thead><tr><th></th><th>enumerable</th><th>configurable</th><th>writable</th><th>value</th><th>get</th><th>set</th></tr></thead><tbody><tr><td>数据描述符</td><td>可以</td><td>可以</td><td>可以</td><td>可以</td><td>不可以</td><td>不可以</td></tr><tr><td>存取描述符</td><td>可以</td><td>可以</td><td>不可以</td><td>不可以</td><td>可以</td><td>可以</td></tr></tbody></table><p>如果一个描述符不具有value,writable，get，set中任意一个键,那么它将会被认为是一个数据描述符.</p><p>如果一个描述符同时拥有value或writable和get或set值,则会产生异常.</p><p>这些选项不一定是自身属性,也要考虑继承来的属性.</p><h3 id="创建属性："><a href="#创建属性：" class="headerlink" title="创建属性："></a>创建属性：</h3><p>如果对象中不存在指定的值,Object.defineProperty()会创建这个属性.当描述符中省略某些字段时,这些字段会使用默认值.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;<span class="comment">//创建一个新对象</span></span><br><span class="line"><span class="comment">//在对象中添加一个属性与属性描述符的示例</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&quot;a&quot;</span>,&#123;</span><br><span class="line">  value: <span class="number">37</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configuarable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o.a);</span><br><span class="line"><span class="comment">// 对象 o 拥有了属性 a，值为 37</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在对象中添加一个设置了存取描述符属性的示例</span></span><br><span class="line"><span class="keyword">var</span> bValue = <span class="number">38</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&quot;b&quot;</span>,&#123;</span><br><span class="line">  <span class="comment">//使用了方法名称缩写（ES2015特性）</span></span><br><span class="line">  <span class="comment">//下面两个缩写等价于：</span></span><br><span class="line">  <span class="comment">//get:function() &#123; return bValue&#125;,</span></span><br><span class="line">  <span class="comment">//set:function() &#123; return bValue;&#125;,</span></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;<span class="keyword">return</span> bValue;&#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123; bValue = newValue&#125;,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configuarable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line">o.b; <span class="comment">//38</span></span><br><span class="line"><span class="built_in">console</span>.log(o.b);</span><br><span class="line"><span class="comment">// 对象 o 拥有了属性 b，值为 38</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据描述符和存取描述符不能混合使用</span></span><br><span class="line"><span class="comment">// Object.defineProperty(o,&quot;conflict&quot;, &#123;</span></span><br><span class="line"><span class="comment">//   value: 0x9f91102,</span></span><br><span class="line"><span class="comment">//   get() &#123; return 0xdeadbeef&#125;</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br></pre></td></tr></table></figure><h3 id="修改属性："><a href="#修改属性：" class="headerlink" title="修改属性："></a>修改属性：</h3><p>如果属性已经存在，Object.defineProperty将尝试根据描述符中的值以及对象当前配置来修改这个属性。<br>如果旧属性将configurable值设置false，则该属性不可被配置，其他属性不可修改（除来单向将writable设置为false）<br>当试图改变不可配置属性的值时,除了value和writable属性之外,会抛出typeerror,除非当前值和新值相同.</p><h3 id="writable属性："><a href="#writable属性：" class="headerlink" title="writable属性："></a>writable属性：</h3><p>当writable属性设置为false时,该属性不可写,不能重新被赋值.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">    value: <span class="number">37</span>,</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">//37</span></span><br><span class="line">o.a = <span class="number">25</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">//37</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;b&#x27;</span>,&#123;</span><br><span class="line">      value: <span class="number">2</span>,</span><br><span class="line">      writable: <span class="literal">false</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// o.b = 3; //throws typeerror: &quot;b&quot; is read-only</span></span><br><span class="line">  <span class="keyword">return</span> o.b;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><h3 id="enumerable属性"><a href="#enumerable属性" class="headerlink" title="enumerable属性"></a>enumerable属性</h3><p>enumerable属性定义了对象的属性是否可以被for…in或Object.keys所枚举</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">&quot;a&quot;</span>, &#123; <span class="attr">value</span> : <span class="number">1</span>, <span class="attr">enumerable</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">&quot;b&quot;</span>, &#123; <span class="attr">value</span> : <span class="number">2</span>, <span class="attr">enumerable</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">&quot;c&quot;</span>, &#123; <span class="attr">value</span> : <span class="number">3</span> &#125;); <span class="comment">// enumerable 默认为 false</span></span><br><span class="line">o.d = <span class="number">4</span>; <span class="comment">// 如果使用直接赋值的方式创建对象的属性，则 enumerable 为 true</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="built_in">Symbol</span>.for(<span class="string">&#x27;e&#x27;</span>), &#123;</span><br><span class="line">  value: <span class="number">5</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="built_in">Symbol</span>.for(<span class="string">&#x27;f&#x27;</span>), &#123;</span><br><span class="line">  value: <span class="number">6</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> o)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);<span class="comment">// a,d</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Object</span>.keys(o)); <span class="comment">//[&quot;a&quot;,&quot;d&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(o.propertyIsEnumerable(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(o.propertyIsEnumerable(<span class="string">&#x27;b&#x27;</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(o.propertyIsEnumerable(<span class="string">&#x27;c&#x27;</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(o.propertyIsEnumerable(<span class="string">&#x27;d&#x27;</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(o.propertyIsEnumerable(<span class="built_in">Symbol</span>.for(<span class="string">&#x27;e&#x27;</span>)));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(o.propertyIsEnumerable(<span class="built_in">Symbol</span>.for(<span class="string">&#x27;f&#x27;</span>)));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(o);</span><br><span class="line"><span class="keyword">var</span> p = &#123; ...o&#125;</span><br><span class="line"><span class="built_in">console</span>.log(p.a);<span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(p.b);<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(p.c);<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(p.d);<span class="comment">//4</span></span><br><span class="line"><span class="built_in">console</span>.log(p[<span class="built_in">Symbol</span>.for(<span class="string">&#x27;e&#x27;</span>)]);<span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(p[<span class="built_in">Symbol</span>.for(<span class="string">&#x27;f&#x27;</span>)]);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><h3 id="configurable属性"><a href="#configurable属性" class="headerlink" title="configurable属性"></a>configurable属性</h3><p>configurable属性定义了该属性是否可被删除，以及除value和writable属性外属性是否可以被修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">   <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> <span class="number">1</span>;&#125;,</span><br><span class="line">   configuarable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">    configuarable: <span class="literal">true</span></span><br><span class="line">&#125;);<span class="comment">//typeerror:Cannot redefine property &#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">&#125;);<span class="comment">//typeerror:Cannot redefine property &#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;);<span class="comment">//typeerror:Cannot redefine property &#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">&#125;);<span class="comment">//typeerror:Cannot redefine property &#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">    value: <span class="number">12</span></span><br><span class="line">&#125;);<span class="comment">//typeerror:Cannot redefine property &#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">//1</span></span><br><span class="line"><span class="keyword">delete</span> o.a;<span class="comment">//false Nothing happens</span></span><br><span class="line"><span class="built_in">console</span>.log(o.a);<span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>如果 o.a 的 configurable 属性为 true，则不会抛出任何错误，并且，最后，该属性会被删除</p><p>添加多个属性和默认值：<br>考虑特性被赋予的默认特性值非常重要,通常,使用点运算符和Object.defineProperty()为对象的属性赋值时,<br>数据描述符中的属性默认值是不同的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">o.a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(o,<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line"><span class="comment">// a &#123;</span></span><br><span class="line"><span class="comment">//     configurable: true</span></span><br><span class="line"><span class="comment">//     enumerable: true</span></span><br><span class="line"><span class="comment">//     value: 1</span></span><br><span class="line"><span class="comment">//     writable: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 等同于:</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">   value:<span class="number">1</span>,</span><br><span class="line">   writable: <span class="literal">true</span>,</span><br><span class="line">   configurable: <span class="literal">true</span>,</span><br><span class="line">   enumerable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//另一方面：</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;b&#x27;</span>,&#123;<span class="attr">value</span>:<span class="number">1</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(o,<span class="string">&#x27;b&#x27;</span>));</span><br><span class="line"><span class="comment">// b&#123;</span></span><br><span class="line"><span class="comment">//     configurable: false</span></span><br><span class="line"><span class="comment">//     enumerable: false</span></span><br><span class="line"><span class="comment">//     value: 1</span></span><br><span class="line"><span class="comment">//     writable: false</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 等同于:</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;b&#x27;</span>, &#123;</span><br><span class="line">   value:<span class="number">1</span>,</span><br><span class="line">   configurable:<span class="literal">false</span>,</span><br><span class="line">   enumerable: <span class="literal">false</span>,</span><br><span class="line">   writable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="自定义setters和getters："><a href="#自定义setters和getters：" class="headerlink" title="自定义setters和getters："></a>自定义setters和getters：</h3><p>下面的例子展示了如何实现一个自存档对象。当设置temperature 属性时，archive 数组会收到日志条目</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Archiver</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> temperature = <span class="literal">null</span>;</span><br><span class="line"> <span class="keyword">var</span> archive = [];</span><br><span class="line"></span><br><span class="line"> <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>, <span class="string">&#x27;temperature&#x27;</span>, &#123;</span><br><span class="line">   get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;get!&#x27;</span>);</span><br><span class="line">     <span class="keyword">return</span> temperature;</span><br><span class="line">   &#125;,</span><br><span class="line">   set: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">     temperature = value;</span><br><span class="line">     archive.push(&#123; <span class="attr">val</span>: temperature &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">this</span>.getArchive = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> archive; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arc = <span class="keyword">new</span> Archiver();</span><br><span class="line">arc.temperature; <span class="comment">// &#x27;get!&#x27;</span></span><br><span class="line">arc.temperature = <span class="number">11</span>;</span><br><span class="line">arc.temperature = <span class="number">13</span>;</span><br><span class="line">arc.getArchive(); <span class="comment">// [&#123; val: 11 &#125;, &#123; val: 13 &#125;]</span></span><br></pre></td></tr></table></figure><p>下面这个例子中，getter 总是会返回一个相同的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = &#123;</span><br><span class="line"> get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&#x27;I alway return this string,whatever you have assigned&#x27;</span>;</span><br><span class="line"> &#125;,</span><br><span class="line"> set: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">this</span>.myname = <span class="string">&#x27;this is my name string&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TestDefineSetAndGet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>, <span class="string">&#x27;myproperty&#x27;</span>, pattern);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> TestDefineSetAndGet();</span><br><span class="line">instance.myproperty = <span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#x27;I alway return this string,whatever you have assigned&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.myproperty);</span><br><span class="line"><span class="comment">// &#x27;this is my name string&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.myname);</span><br></pre></td></tr></table></figure><h3 id="继承属性"><a href="#继承属性" class="headerlink" title="继承属性"></a>继承属性</h3><p>如果访问者的属性是被继承的，它的 get 和 set 方法会在子对象的属性被访问或者修改时被调用。<br>如果这些方法用一个变量存值，该值会被所有对象共享。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myclass</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> value ;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myclass.prototype,<span class="string">&quot;x&quot;</span>,&#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">x</span>)</span> &#123;</span><br><span class="line">        value = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> myclass();</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> myclass();</span><br><span class="line">a.x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b.x);<span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>这可以通过将值存储在另一个属性中解决。在 get 和 set 方法中，this 指向某个被访问和修改属性的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myclass</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myclass.prototype,<span class="string">&quot;x&quot;</span>,&#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.stored_x;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">x</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stored_x = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> myclass();</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> myclass();</span><br><span class="line">a.x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.x);<span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(b.x);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>不像访问者属性，值属性始终在对象自身上设置，而不是一个原型。然而，如果一个不可写的属性被继承，它仍然可以防止修改对象的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myclass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myclass.prototype.x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myclass.prototype, <span class="string">&quot;y&quot;</span>, &#123;</span><br><span class="line"> writable: <span class="literal">false</span>,</span><br><span class="line"> value: <span class="number">1</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> myclass();</span><br><span class="line">a.x = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.x); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(myclass.prototype.x); <span class="comment">// 1</span></span><br><span class="line">a.y = <span class="number">2</span>; <span class="comment">// Ignored, throws in strict mode </span></span><br><span class="line"><span class="built_in">console</span>.log(a.y); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(myclass.prototype.y); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS3新特性</title>
      <link href="/ZJY.github.io/2021/02/22/CSS3%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/ZJY.github.io/2021/02/22/CSS3%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="边框属性"><a href="#边框属性" class="headerlink" title="边框属性"></a>边框属性</h2><h2 id="border-image边框图片属性"><a href="#border-image边框图片属性" class="headerlink" title="border-image边框图片属性"></a>border-image边框图片属性</h2><p>border-image:none 100% 1 0 stretch; 默认值<br>border-image是一个简写，用于设置以下属性：</p><ul><li>border-image-source: 边框图片路径</li><li>border-image-slice: 图片边框向内偏移</li><li>border-image-width: 图片边框的宽度</li><li>border-image-outset: 边框图像区域超出边框的量</li><li>border-image-repeat: 图片边框是否平铺（repeated）,铺满（rounded）或拉伸（stretched）</li></ul><h2 id="border-radius边框圆角属性"><a href="#border-radius边框圆角属性" class="headerlink" title="border-radius边框圆角属性"></a>border-radius边框圆角属性</h2><p>border-radius: 0; 默认值<br>border-radius是一个简写，用于设置以下属性：</p><ul><li>border-top-left-radius: 左上角圆角属性</li><li>border-top-right-radius: 右上角圆角属性，若省略则取top-left的值</li><li>border-bottom-left-radius: 左下角圆角属性，若省略则取top-right的值</li><li>border-bottom-right-radius: 右下角圆角属性，若省略则取top-left的值</li></ul><p>以上属性值可取2种值：</p><ul><li>length: 具体的值,比如2px,2em等</li><li>%: 百分比</li></ul><h2 id="box-shadow边框阴影属性"><a href="#box-shadow边框阴影属性" class="headerlink" title="box-shadow边框阴影属性"></a>box-shadow边框阴影属性</h2><p>box-shadow属性向边框添加一个或多个阴影，是由逗号分隔的阴影列表，每个阴影由2-4个长度值、可选的颜色以及可选的inset关键词来规定。省略长度的值是0.</p><p>box-shadow属性值：</p><ul><li>h-shadow: 必需，水平阴影的位置，允许负值</li><li>v-shadow：必需，垂直阴影的位置，允许负值</li><li>blur： 可选，模糊距离</li><li>spread：可选，阴影的尺寸</li><li>color：可选，阴影的颜色</li><li>inset：可选，将外部阴影设置为内部阴影</li></ul><h2 id="背景属性"><a href="#背景属性" class="headerlink" title="背景属性"></a>背景属性</h2><h2 id="background-image多背景图片属性"><a href="#background-image多背景图片属性" class="headerlink" title="background-image多背景图片属性"></a>background-image多背景图片属性</h2><p>background-image:url(bg_flower.gif),url(bg_flower_2.gif);</p><h2 id="background-clip背景的绘制区域"><a href="#background-clip背景的绘制区域" class="headerlink" title="background-clip背景的绘制区域"></a>background-clip背景的绘制区域</h2><p>background-clip 属性规定背景的绘制区域</p><p>background-clip属性可选值：</p><ul><li>border-box：默认值，图片被剪裁到边框盒</li><li>padding-box: 图片被剪裁到内边距框</li><li>content-box: 图片被剪裁到内容框</li></ul><h2 id="background-origin规定背景图片的定位区域"><a href="#background-origin规定背景图片的定位区域" class="headerlink" title="background-origin规定背景图片的定位区域"></a>background-origin规定背景图片的定位区域</h2><p>background-origin属性规定background-position属性相对于什么位置来定位。<br>如果background-attachment属性设置为“fixed”，该属性无效。</p><p>background-origin属性值：</p><ul><li>padding-box: 默认值，背景图片相对于内边距框来定位</li><li>border-box: 背景图片相对于边框盒来定位</li><li>content-box: 背景图片相对于内容框来定位</li></ul><h2 id="background-size规定背景图片的尺寸"><a href="#background-size规定背景图片的尺寸" class="headerlink" title="background-size规定背景图片的尺寸"></a>background-size规定背景图片的尺寸</h2><p>background-size 属性规定背景图像的尺寸</p><p>background-size: auto;默认值</p><p>background-size取值四种方式：</p><ul><li>length：设置宽度和高度，第一个设置宽度，第二个值设置高度，如果只设置一个值，第二个值会被设置为”auto”.</li><li>%:百分比设置宽度和高度，相对于父元素的宽高设置，第一个设置宽度，第二个值设置高度，如果只设置一个值，第二个值会被设置为”auto”.</li><li>cover：把背景图片扩展至足够大，以使背景图像完全覆盖背景区域</li><li>contain：把背景图片扩展至最大尺寸，以使其宽高完全适应内容区域</li></ul><h2 id="文本效果"><a href="#文本效果" class="headerlink" title="文本效果"></a>文本效果</h2><h2 id="text-shadow文本阴影"><a href="#text-shadow文本阴影" class="headerlink" title="text-shadow文本阴影"></a>text-shadow文本阴影</h2><p>text-shadow 属性向文本设置阴影。<br>text-shadow: none;默认值</p><p>text-shadow属性包含下列值：</p><ul><li>h-shadow: 必需，水平阴影的位置，允许负值</li><li>v-shadow: 必需，垂直阴影的位置，允许负值</li><li>blur: 可选，模糊的距离</li><li>color: 可选，阴影的颜色</li></ul><h2 id="word-wrap属性"><a href="#word-wrap属性" class="headerlink" title="word-wrap属性"></a>word-wrap属性</h2><p>word-wrap属性允许长单词或 URL 地址换行到下一行。</p><p>word-wrap:normal;默认值</p><ul><li>break-word：允许长单词或url地址换到下一行</li><li>normal: 只在允许的断字点换行（浏览器保持默认处理）</li></ul><h2 id="word-break属性规定自动换行的处理方法"><a href="#word-break属性规定自动换行的处理方法" class="headerlink" title="word-break属性规定自动换行的处理方法"></a>word-break属性规定自动换行的处理方法</h2><p>word-break: noraml默认值</p><ul><li>noraml:浏览器默认换行规则</li><li>break-all: 允许在单词内换行</li><li>keep-all： 只允许在半角空格或连字符处换行</li></ul><h2 id="transform属性"><a href="#transform属性" class="headerlink" title="transform属性"></a>transform属性</h2><p>transform属性向元素应用2D或3D属性。该属性允许元素进行旋转、缩放、倾斜、移动</p><p>transform:none/transform-function,none为默认值</p><p>transform值可以是以下方法：</p><ul><li>none：不进行任何转换</li><li>matrix(n,n,n,n,n,n):定义2D转换，使用六个值的矩阵</li><li>matrix3d(n,…n):定义3D转换，使用16个值的矩阵</li><li>translate(x,y):定义2D转换</li><li>translate3d(x,y,z): 定义3D转换</li><li>translateX(x): 定义转换，只是用 X 轴的值。</li><li>translateY(y): 定义转换，只是用 Y 轴的值。</li><li>translateZ(z): 定义转换，只是用 Z 轴的值。</li><li>scale(x,y): 定义2D缩放转换</li><li>scale3d(x,y,z): 定义3D缩放转换</li><li>scaleX(x): 通过设置 X 轴的值来定义缩放转换。</li><li>scaleY(y): 通过设置 Y 轴的值来定义缩放转换。</li><li>scaleZ(z): 通过设置 Z 轴的值来定义缩放转换。</li><li>rotate(angle): 定义 2D 旋转，在参数中规定角度</li><li>rotate(x,y,angle): 定义3D旋转</li><li>rotateX(angle): 定义沿着 X 轴的 3D 旋转</li><li>rotatezY(angle): 定义沿着 Y 轴的 3D 旋转</li><li>rotateZ(angle): 定义沿着 Z 轴的 3D 旋转</li><li>skew(x-angle,y-angle): 定义沿着x轴和y轴倾斜转换</li><li>skewX(angle): 定义沿着X轴的2D倾斜转换</li><li>skewY(angle):定义沿着y轴的2D倾斜转换</li></ul><h2 id="transition过渡属性"><a href="#transition过渡属性" class="headerlink" title="transition过渡属性"></a>transition过渡属性</h2><p>transition过渡是元素从一种样式逐渐改变为另一种效果，需要规定2项内容：</p><ul><li>规定希望效果作用到元素哪个属性上</li><li>规定效果的时长</li></ul><p>transition是简写属性，包含以下转换属性：</p><ul><li>transition-property:规定应用过渡的css属性名称，取值：none/property/all</li><li>transition-duration:规定应用过渡时长，默认值0，以秒或毫秒计</li><li>transition-timing-function: 规定过渡效果的曲线，默认值是ease</li><li>transition-delay: 规定效果从何时开始，默认值是0</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">transition</span>: width <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">-moz-transition</span>: width <span class="number">2s</span>;<span class="comment">/* Firefox 4 */</span></span><br><span class="line">  <span class="attribute">-webkit-transition</span>: width <span class="number">2s</span>;<span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line">  <span class="attribute">-o-transition</span>: width <span class="number">2s</span>;<span class="comment">/* Opera */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="animation动画"><a href="#animation动画" class="headerlink" title="animation动画"></a>animation动画</h2><p>@keyframes规则用于创建动画</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> myFirst&#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在@keyframes创建动画后，需要将它绑定到某个选择器，需要以下2项css3动画属性，即可将动画绑定到选择器：</p><ul><li>规定动画的名称</li><li>规定动画的时长</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">animation</span>: myFirst <span class="number">5s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可用0%和100%代替from和to。</p><ul><li>@keyframes：创建动画</li><li>animation：动画属性简写</li><li>animation-name: 规定@keyframes动画的名称</li><li>animation-duration: 规定动画的一个周期所需时长，默认是0</li><li>animation-timing-function: 规定动画的曲线，默认是ease</li><li>animation-delay: 规定动画何时开始，默认是0</li><li>animation-iteration-count: 规定动画播放次数，默认是1，值可取n/infinate(无限播放)</li><li>animation-direction: 规定动画是否在下一周期逆向播放，默认是normal,取值normal/alternate</li><li>animation-play-state: 规定动画是正在运行还是暂停，默认值是running，取值running/paused</li><li>animation-fill-mode: 定对象动画时间之外的状态</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端开发常见面试问题及答案整理</title>
      <link href="/ZJY.github.io/2021/02/21/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%95%B4%E7%90%86/"/>
      <url>/ZJY.github.io/2021/02/21/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前端开发常见面试问题及答案整理"><a href="#前端开发常见面试问题及答案整理" class="headerlink" title="前端开发常见面试问题及答案整理"></a>前端开发常见面试问题及答案整理</h2><h2 id="闭包的理解"><a href="#闭包的理解" class="headerlink" title="闭包的理解"></a>闭包的理解</h2><p>闭包是为了设计私有方法和变量。<br>优点：避免全局变量的污染<br>缺点：闭包常驻内存，加大内存使用，使用不当容易造成内存泄漏</p><p>闭包的三大特性：</p><ul><li>函数嵌套函数</li><li>函数内部可以引用外部的参数和变量</li><li>参数和变量不会被垃圾回收机制回收</li></ul><h2 id="cookie的弊端"><a href="#cookie的弊端" class="headerlink" title="cookie的弊端"></a>cookie的弊端</h2><p>1.每个特定的域名下最多生成20个cookie，每个cookie长度不能超过4KB，否则会被截掉。<br>2.安全性问题。如果cookie被拦截，那就可以取到所有session信息，即使加密也于事无补，，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。</p><h2 id="浏览器本地存储"><a href="#浏览器本地存储" class="headerlink" title="浏览器本地存储"></a>浏览器本地存储</h2><p>html5中web storage包括了2种存储方式：sessionStorage和localStorage</p><ul><li>sessionStorage:用于存储本地的一个会话的数据，这些数据只能在同一个会话中的页面才能访问并且当会话结束后会随之销毁。所以sessionStorage不是一个持久化的的本地存储，仅仅是会话级别的存储。</li><li>localStorage：是持久化的本地存储，除非主动删除数据，否则永远不用过期。</li></ul><h3 id="web-storage和cookie的区别"><a href="#web-storage和cookie的区别" class="headerlink" title="web storage和cookie的区别"></a>web storage和cookie的区别</h3><p>web storage和cookie类似，区别是web storage是为了更大容量设计的。<br>cookie大小受限制；且每次打开新的页面，cookie都会被发送过去，无形中浪费带宽；且cookie不能跨域</p><p>web storage拥有setItem,getItem,removeItem,clear等方法，而cookie需要自己封装setCookie,getCookie</p><p>但cookie是不可或缺的：cookie的作用是与服务器进行交互，作为http的规范而存在，web storage仅仅是为了本地存储</p><p>localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem</p><h3 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h3><ul><li>cookie存放在客户端浏览器，session存放在服务器</li><li>cookie最大4kb，且每个站点最多20个cookie</li><li>cookie不是很安全，别人可以获取cookie进行cookie欺骗</li><li>session会在一定时间内存储在服务器，当访问量增大时，占用服务器的性能</li></ul><h2 id="css相关问题"><a href="#css相关问题" class="headerlink" title="css相关问题"></a>css相关问题</h2><h3 id="display-none-和-visibility-hidden"><a href="#display-none-和-visibility-hidden" class="headerlink" title="display:none 和 visibility:hidden"></a>display:none 和 visibility:hidden</h3><ul><li>display:none隐藏对应的元素,文档布局中不再分配空间，周边元素会当他不存在</li><li>visibility:hidden 隐藏元素，保留布局，占用空间。</li></ul><h3 id="css中link和-import的区别"><a href="#css中link和-import的区别" class="headerlink" title="css中link和@import的区别"></a>css中link和@import的区别</h3><ul><li>link是html标签，@import是css提供的</li><li>link是html标签无兼容问题，@import需ie5以上才兼容</li><li>页面加载时，link会被一起加载，而@import需要页面加载完后再加载</li><li>link引入样式权重高于@import权重</li></ul><h3 id="position-absolute和float的异同"><a href="#position-absolute和float的异同" class="headerlink" title="position:absolute和float的异同"></a>position:absolute和float的异同</h3><ul><li>相同点：对内联元素设置position:absolute和float都会使其脱离文档流，并可设置宽和高</li><li>不同点：设置position:absolute的元素会覆盖文档流中的其他元素，而float仍然占据位置。</li></ul><h3 id="box-sizing属性"><a href="#box-sizing属性" class="headerlink" title="box-sizing属性"></a>box-sizing属性</h3><p>box-sizing属性用来控制元素的盒模型解析模式，默认是content-box</p><ul><li>content-box: w3c标准盒模型，元素的宽高由padding+border+content决定，设置元素的width/height属性是指content的宽/高</li><li>border-box: IE怪异盒模型，设置元素的width/height属性是指content+padding+border</li></ul><p>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。</p><h3 id="CSS-选择符有哪些？"><a href="#CSS-选择符有哪些？" class="headerlink" title="CSS 选择符有哪些？"></a>CSS 选择符有哪些？</h3><ul><li>id选择器(#con)</li><li>class选择器(.con)</li><li>标签选择器(div/p)</li><li>相邻选择器(div + p)</li><li>子选择器(div &gt; p)</li><li>后代选择器(div p)</li><li>通配符选择器(*)</li><li>属性选择器（a[rel = “external”]）</li><li>伪类选择器(a:hover)</li></ul><h3 id="css哪些属性可以继承？"><a href="#css哪些属性可以继承？" class="headerlink" title="css哪些属性可以继承？"></a>css哪些属性可以继承？</h3><ul><li>可以继承属性：font-size, font-family,color,text-index</li><li>不可以继承属性：width,height,border,padding,margin</li></ul><h3 id="css优先级算法？"><a href="#css优先级算法？" class="headerlink" title="css优先级算法？"></a>css优先级算法？</h3><ul><li>优先级就近原则，同权重情况下样式定义最近者为准</li><li>载入样式以最后载入为准</li><li>!important &gt;  id &gt; class &gt; tag，important 比 内联优先级高,但内联比 id 要高</li></ul><h3 id="css3新增伪类有哪些？"><a href="#css3新增伪类有哪些？" class="headerlink" title="css3新增伪类有哪些？"></a>css3新增伪类有哪些？</h3><ul><li>p:first-of-type 选择属于其父元素的首个 <code>&lt;p&gt; </code>元素的每个<code> &lt;p&gt;</code> 元素。</li><li>p:last-of-type 选择属于其父元素的最后 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。</li><li>p:only-of-type 选择属于其父元素唯一的 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。</li><li>p:nth-child(2) 选择属于其父元素的第二个子元素的每个 <code>&lt;p&gt;</code> 元素。</li><li>p:only-child 选择属于其父元素的唯一子元素的每个 <code>&lt;p&gt;</code> 元素。</li><li>:enabled :disabled 控制表单控件的禁用状态。</li><li>:checked 单选框或复选框被选中。</li></ul><h3 id="position的值，分别相对于谁定位？"><a href="#position的值，分别相对于谁定位？" class="headerlink" title="position的值，分别相对于谁定位？"></a>position的值，分别相对于谁定位？</h3><ul><li>static： 默认值，没有定位，元素出现在正常文档流中。</li><li>relative：相对定位，相对于其在正常文档流中位置定位。</li><li>absolute： 绝对定位，相对于最近一级的定位不是staic的元素定位。</li><li>fixed： 绝对定位，相对于浏览器视窗定位。</li></ul><h3 id="css3有哪些新特性？"><a href="#css3有哪些新特性？" class="headerlink" title="css3有哪些新特性？"></a>css3有哪些新特性？</h3><ul><li>border-radius:圆角</li><li>border-image: 边框图片</li><li>box-shadow: 边框阴影</li><li>background-image: 多背景</li><li>background-clip: 背景图片绘制区域</li><li>background-origin: 背景图片的定位区域</li><li>text-shadow: 文本阴影</li><li>word-wrap:允许长单词或url换行到下一行</li><li>word-break: 设置自动换行的处理方法</li><li>transform: 旋转、缩放、移动、倾斜，2D或3D转换</li><li>animation: 使用@keyframes创建动画</li><li>transition: 设置元素过渡效果</li><li>column-count/gap/rule: 多列设置</li><li>::selection: 新增伪元素，设置选中高亮</li></ul><h3 id="XML和JSON的区别？"><a href="#XML和JSON的区别？" class="headerlink" title="XML和JSON的区别？"></a>XML和JSON的区别？</h3><ul><li>数据体积方面：JSON相对XML来说，数据体积小，传输速度更快</li><li>数据交互方面：JSON于js的交互更方便，更容易解析处理</li><li>数据描述方面：XML对数据的描述比JSON好</li><li>传输速度方面：JSON的传输速度要快于XML</li></ul><h3 id="对BFC的理解？"><a href="#对BFC的理解？" class="headerlink" title="对BFC的理解？"></a>对BFC的理解？</h3><p>BFC块级格式化上下文，是一个独立的渲染区域，内部元素不会影响外部元素定位，使内外元素相隔离</p><p>BFC布局规则：</p><ul><li>BFC是一个独立的区域，内外元素不互相影响</li><li>内部的box会在垂直方向，一个一个排列</li><li>box垂直方向的距离由margin决定，相邻的2个box间的margin会发生重叠</li><li>每个元素的margin box的左边与border box的左边相接触，即使浮动也如此</li><li>BFC区域不和浮动盒子相重叠</li><li>计算BFC高度时，float box也参与计算</li></ul><p>什么情况会形成BFC？</p><ul><li>根元素</li><li>position为absolute或fixed</li><li>浮动元素</li><li>display值为flex、inline-flex、inline-block、table-cell</li><li>overflow不为visible的元素</li></ul><h3 id="css-sprites-如何在网站使用？"><a href="#css-sprites-如何在网站使用？" class="headerlink" title="css sprites,如何在网站使用？"></a>css sprites,如何在网站使用？</h3><p>css sprites就是把网页中一些背景图片整合到一张图片中，利用”background-image”,”background-repeat”,”background-position”属性组合进行背景定位。”background-position”可以精准定位背景图片的位置。有效减少图片请求开销。</p><h2 id="html部分"><a href="#html部分" class="headerlink" title="html部分"></a>html部分</h2><h3 id="对语义化的理解？"><a href="#对语义化的理解？" class="headerlink" title="对语义化的理解？"></a>对语义化的理解？</h3><ul><li>样式丢失也能呈现出清晰的结构</li><li>有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓去更多信息</li><li>方便其他设备解析（屏幕阅读器、盲人阅读器）</li><li>便于团队开发和维护，语义化更具有可读性</li></ul><h3 id="Doctype的作用？严格模式和混杂模式区别？有何意义？"><a href="#Doctype的作用？严格模式和混杂模式区别？有何意义？" class="headerlink" title="Doctype的作用？严格模式和混杂模式区别？有何意义？"></a>Doctype的作用？严格模式和混杂模式区别？有何意义？</h3><ul><li><!DOCTYPE>声明位于文档最前面，告知浏览器以何种模式渲染文档</li><li>严格模式的排版和js运作模式是以浏览器支持的最高标准运行。</li><li>在混杂模式中以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。</li><li>DOCTYPE不存在或不正确会使浏览器以混杂模式呈现。</li></ul><h3 id="浮动工作原理？清除浮动的技巧？"><a href="#浮动工作原理？清除浮动的技巧？" class="headerlink" title="浮动工作原理？清除浮动的技巧？"></a>浮动工作原理？清除浮动的技巧？</h3><p>浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或浮动元素的边框停留。</p><p>清除浮动方式：</p><ul><li>使用空标签清除浮动：浮动标签后面添加一个空标签，定义css clear:both.弊端就是增加了无意义的标签</li><li>使用overflow：给包含浮动元素的父元素添加overflow:auto;zoom:1;zoom:1;兼容ie6</li><li>使用after伪对象清除浮动：只适用于非IE浏览器，该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素</li></ul><h3 id="浮动元素引起的问题和解决方案？"><a href="#浮动元素引起的问题和解决方案？" class="headerlink" title="浮动元素引起的问题和解决方案？"></a>浮动元素引起的问题和解决方案？</h3><ul><li>1.父元素的高度无法被撑开，影响与父元素同级的元素</li><li>2.与浮动元素同级的非浮动元素（内联元素）会跟随其后</li><li>3.若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面结构</li></ul><p>解决方法：<br>对于第二个第三个问题可用clear:both清除元素的浮动，对于第一个问题，给父元素添加clearfix样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">clear</span>:both;</span><br><span class="line">  <span class="attribute">visibility</span>:hidden;</span><br><span class="line">  <span class="attribute">display</span>:block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:inline-block; <span class="comment">/* for IE/Mac */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清除浮动的几种方式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1，额外标签法，&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;（缺点：不过这个办法会增加额外的标签使HTML结构看起来不够简洁。）</span><br><span class="line">2，使用<span class="selector-tag">after</span>伪类</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#parent</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">&quot;.&quot;</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">visibility</span>:hidden;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">clear</span>:both;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">3,浮动外部元素</span><br><span class="line">4,设置`<span class="selector-tag">overflow</span>`为`<span class="selector-tag">hidden</span>`或者<span class="selector-tag">auto</span></span><br></pre></td></tr></table></figure><h3 id="DOM操作——怎样添加、移除、移动、复制、创建和查找节点"><a href="#DOM操作——怎样添加、移除、移动、复制、创建和查找节点" class="headerlink" title="DOM操作——怎样添加、移除、移动、复制、创建和查找节点"></a>DOM操作——怎样添加、移除、移动、复制、创建和查找节点</h3><ul><li><p>创建</p><ul><li>createDocumentFragment() 创建一个Dom片段</li><li>createElement() 创建一个元素</li><li>createTextNode() 创建文本节点</li></ul></li><li><p>添加、移除、移动、复制</p><ul><li>appendChild() </li><li>removeChild()</li><li>replaceChild()</li><li>insertBefore()</li></ul></li><li><p>查找</p><ul><li>getElementsByTagName()</li><li>getElementById()</li><li>getElementsByClassName()</li></ul></li></ul><h3 id="html5有哪些新特性？"><a href="#html5有哪些新特性？" class="headerlink" title="html5有哪些新特性？"></a>html5有哪些新特性？</h3><ul><li>拖拽API</li><li>语义化更好的标签（header,section,article,footer,nav,aside）</li><li>音视频（audio/video）</li><li>canvas画布/svg</li><li>地理位置Geolocation</li><li>本地缓存：localStorage持久化缓存，sessionStorage会话级缓存</li><li>新的表单控件：calendar,date,time,url,search,email</li></ul><h3 id="常见浏览器兼容问题"><a href="#常见浏览器兼容问题" class="headerlink" title="常见浏览器兼容问题"></a>常见浏览器兼容问题</h3><ul><li>浏览器默认margin,padding值不同，需要添加全局*{margin:0;padding:0}</li><li>chrome浏览器设置字体小于12px，会默认为12px，解决方法：-webkit-text-size-adjust:none;</li><li>a标签超链接访问过后hover样式就不出现了，被访问过的链接不再具有hover和active，解决方法改变css属性的顺序：<br>L-V-H-A: a:link{} a:visited: a:hover a:active</li><li>怪异模式问题：漏写DTD声明时，火狐仍然按照标准模式来解析网页，但在IE中会触发怪异模式。</li></ul><h3 id="如何实现浏览器多个标签页之间通信？"><a href="#如何实现浏览器多个标签页之间通信？" class="headerlink" title="如何实现浏览器多个标签页之间通信？"></a>如何实现浏览器多个标签页之间通信？</h3><p>使用localStorage,cookies等本地存储方式</p><h3 id="进程和线程之间关系和区别？"><a href="#进程和线程之间关系和区别？" class="headerlink" title="进程和线程之间关系和区别？"></a>进程和线程之间关系和区别？</h3><ul><li><p>1.定义</p><ul><li>进程：是系统进行资源分配和调度的独立单位。</li><li>线程：线程是进程的一个实体，是cpu调度和分派的基本单位，是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，但是和进程内的其他线程共享进程拥有的全部资源。</li></ul></li><li><p>2.关系</p><ul><li>一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。</li><li>相对进程而言，线程更接近于执行体的概念，它可以与进程内的其他线程共享资源，但拥有自己的栈空间，拥有独立的执行序列</li></ul></li><li><p>3.区别<br>进程和线程的主要差别是他们是不同的操作系统资源的管理方式。进程拥有独立的地址空间，一个进程崩溃后，基于系统的保护程序，并不会影响其他进程，而线程只是进程中的不同执行路径。<br>线程拥有自己的堆栈和局部变量，但线程间没有单独的地址空间，一个线程死掉就相当于整个进程死掉，所以多进程的程序比多线程的程序更健壮，但在进程切换时，耗费资源较大，效率低一些。</p><ul><li>一个程序至少有一个进程，一个进程中至少有一个线程</li><li>线程的划分尺度低于进程，使得多线程的程序并发性高</li><li>进程在执行过程拥有独立的内存单元，而多个线程共享内存，从而极大的提高程序的运行效率</li><li>线程在执行过程中和进程还是有区别的。每个线程都有程序运行入口，顺序执行序列和程序的出口，但线程不能独立执行，必须依存于应用程序，由应用程序提供多个线程执行控制</li><li>从逻辑角度来看，多线程的意义在于应用程序中，有多个执行部分可以同时执行，但是操作系统并没有将多个线程看出多个独立的应用，来实现线程的调度和管理以及资源分配。这就是进程和线程的重要区别</li></ul></li><li><p>4.优缺点</p><ul><li>线程执行开销小，但不利于资源的管理和保护；而进程相反</li><li>线程适合于在SMP机器上运行，而进程则可以跨机器迁移。</li></ul></li></ul><h3 id="什么是FOUC？怎么解决？"><a href="#什么是FOUC？怎么解决？" class="headerlink" title="什么是FOUC？怎么解决？"></a>什么是FOUC？怎么解决？</h3><p>Flash Of Unstyled Content 文档式闪烁</p><ul><li>什么是FOUC(文档样式短暂失效)?<ul><li>如果使用import方法对CSS进行导入,会导致某些页面在Windows 下的Internet Explorer出现一些奇怪的现象:以无样式显示页面内容的瞬间闪烁,这种现象称之为文档样式短暂失效(Flash of Unstyled Content),简称为FOUC。</li></ul></li><li>造成原因：<ul><li>使用import引入css</li><li>将样式表放在页面底部</li><li>多个样式表放在html结构的不同位置<br>当样式表晚于页面html加载，当加载到此样式表时，页面将停止之前的渲染，等待文件的下载解析后将重新渲染页面，也就出现短暂页面闪烁</li></ul></li><li>解决方法：<ul><li>使用link标签将样式表放置与head中</li></ul></li></ul><h3 id="null和undefined的区别？"><a href="#null和undefined的区别？" class="headerlink" title="null和undefined的区别？"></a>null和undefined的区别？</h3><p>null是表示“无”的对象，转为数值为0，undefined是表示“无”的原始值，转为数值为NaN。</p><p>当声明的变量未初始化时，值为undefined。<br>null用来表示尚未存在的对象，常用来表示函数企图返回不存在的对象。</p><p>undefined:<br>1.变量被声明了，但没有赋值，该变量值为undefined<br>2.调用函数时，应该提供的参数没有提供，该参数值为undefined<br>3.未给对象的属性赋值时，该属性的值为undefined<br>4.函数没有返回值时，默认返回undefined</p><p>null：<br>1.作为函数的参数，表明该函数的参数不是对象<br>2.作为对象原型链的终点</p><h3 id="new-操作符具体做了什么？"><a href="#new-操作符具体做了什么？" class="headerlink" title="new 操作符具体做了什么？"></a>new 操作符具体做了什么？</h3><ul><li>1.创建新的空对象，并且this变量引用该对象，同时还继承了该函数的原型</li><li>2.属性和方法被加入到this引用的对象上</li><li>3.新创建的对象由this所引用，并隐式返回this</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.__proto__ = Base.prototype;</span><br><span class="line">Base.call(obj);</span><br></pre></td></tr></table></figure><h3 id="js延迟加载的几种方式？"><a href="#js延迟加载的几种方式？" class="headerlink" title="js延迟加载的几种方式？"></a>js延迟加载的几种方式？</h3><p>js延迟加载就是等页面加载完成后再加载js文件<br>js延迟加载有助于提高页面加载速度。<br>一般有以下几种方式：</p><ul><li><p>1.defer属性<br>html4为script标签添加了defer属性，表明脚本在执行时不会影响页面构造，也就是说脚本会延迟到整个页面都加载解析完毕再执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;script src=<span class="string">&quot;test.js&quot;</span> defer=<span class="string">&quot;defer&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><p>defer属性告诉浏览器立即下载，但延迟执行。虽然<code>&lt;script&gt;</code> 元素放在了<code>&lt;head&gt;</code>元素中，但包含的脚本会延迟到浏览器遇到<code>&lt;/html&gt;</code>标签后再执行。</p></li></ul><p>HTML5规范要求脚本按照它们出现的先后顺序执行</p><p>defer属性只适用于外部脚本文件</p><ul><li><p>2.async属性<br>html5为script标签定义了async属性，与defer属性类似。只适用于外部脚本。<br>目的：不让页面等待脚本下载和执行，从而异步加载页面其他内容<br>异步脚本一定会在onload事件前执行<br>不能保证脚本按照顺序执行</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;test1.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>async和defer一样，不会阻塞其他资源下载，不会影响页面加载<br>缺点：不能控制脚本加载顺序</p></li><li><p>3.动态创建DOM方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这些代码应被放置在&lt;/body&gt;标签前(接近HTML文件底部)</span></span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">downloadJSAtOnload</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">      varelement = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);  </span><br><span class="line">      element.src = <span class="string">&quot;defer.js&quot;</span>;  </span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(element);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener)  </span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">&quot;load&quot;</span>,downloadJSAtOnload, <span class="literal">false</span>);  </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.attachEvent)  </span><br><span class="line">      <span class="built_in">window</span>.attachEvent(<span class="string">&quot;onload&quot;</span>,downloadJSAtOnload);  </span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">      <span class="built_in">window</span>.onload =downloadJSAtOnload;  </span><br><span class="line">&lt;/script&gt;  </span><br></pre></td></tr></table></figure><p>创建script，插入到DOM中，加载完毕后callBack</p></li><li><p>4.使用setTimeout延迟</p></li><li><p>5.按需异步加载</p></li></ul><h3 id="document-write和innerHTML的区别"><a href="#document-write和innerHTML的区别" class="headerlink" title="document.write和innerHTML的区别"></a>document.write和innerHTML的区别</h3><p>document.write重绘整个页面<br>innerHTML重绘页面一部分</p><h3 id="哪些操作会造成内存泄漏？"><a href="#哪些操作会造成内存泄漏？" class="headerlink" title="哪些操作会造成内存泄漏？"></a>哪些操作会造成内存泄漏？</h3><p>内存泄漏是指任何对象在您不再拥有或需要时仍然存在<br>垃圾回收器会定时扫描对象，并计算应用了每个对象的其他对象的数量，当引用该对象数量为0，或对该对象的惟一引用是循环的，那么该对象的内存就会被回收。</p><p>setTimeout函数的第一个参数如果是字符串，闭包、控制台日志，循环（两个对象彼此存在且彼此引用时，会行程一个循环）会引发内存泄漏。</p><h3 id="如何判断当前脚本运行在浏览器还是node环境中？"><a href="#如何判断当前脚本运行在浏览器还是node环境中？" class="headerlink" title="如何判断当前脚本运行在浏览器还是node环境中？"></a>如何判断当前脚本运行在浏览器还是node环境中？</h3><p>通过判断Global对象是否等于window，如果不是则在node中</p><p>this == window</p><h3 id="ajax过程"><a href="#ajax过程" class="headerlink" title="ajax过程"></a>ajax过程</h3><ul><li>1.创建一个XMLHttpRequest对象，也就是异步调用对象</li><li>2.创建一个新的http请求，设置请求的方式、URL以及验证信息</li><li>3.设置响应http请求状态变化的函数</li><li>4.发送http请求</li><li>5.获取异步调用返回的结果</li><li>6.使用js和dom实现局部刷新</li></ul><h3 id="ie各版本和chrome可以并行下载多少个资源"><a href="#ie各版本和chrome可以并行下载多少个资源" class="headerlink" title="ie各版本和chrome可以并行下载多少个资源"></a>ie各版本和chrome可以并行下载多少个资源</h3><p>IE6 两个并发，iE7升级之后的6个并发，之后版本也是6个</p><p>Firefox，chrome也是6个</p><h3 id="javascript的同源策略"><a href="#javascript的同源策略" class="headerlink" title="javascript的同源策略"></a>javascript的同源策略</h3><p>同源：协议、域名、端口相同，同源策略是一种协议，指脚本只能读取来自同一源的窗口和文档属性。</p><h3 id="哪些地方会出现css阻塞，哪些地方会出现js阻塞？"><a href="#哪些地方会出现css阻塞，哪些地方会出现js阻塞？" class="headerlink" title="哪些地方会出现css阻塞，哪些地方会出现js阻塞？"></a>哪些地方会出现css阻塞，哪些地方会出现js阻塞？</h3><p>所有浏览器在下载js的时候，都会阻塞其他资源的下载，页面的呈现等。直到js下载、解析、执行完毕后才能继续并行下载其他资源并呈现内容。新一代浏览器都支持并行下载js，但仍然会阻塞其他资源（css，图片）的下载。<br>由于浏览器为了防止出现js修改dom树，造成重新构造dom树的情况，需要阻塞其他资源的下载和呈现<br>嵌入js会阻塞所有内容的呈现，外部js只会阻塞其后内容的显示，2种方式都会阻塞资源的下载。</p><p>css本来是可以并行下载的，在什么情况下会阻塞加载？<br>css后面跟着嵌入js的时候，会阻塞后面资源的下载，而把嵌入js放置在css前面就不会阻塞资源加载了。</p><p>原因：<br>因为浏览器会维持html中css和js的顺序，样式表必须在嵌入js前先加载、解析完。而嵌入js又会阻塞后面的资源加载，所以就会出现css阻塞下载的情况</p><p>嵌入js应该放在什么位置？<br>1.放置在底部，虽然放在底部会阻塞所有呈现，但不会阻塞资源下载<br>2.放在head，放在css前面<br>3.使用defer<br>4.嵌入js中不要调用运行时间较长的函数，如果要调用，可以使用setTimeout来调用</p><h3 id="js无阻塞加载方式？"><a href="#js无阻塞加载方式？" class="headerlink" title="js无阻塞加载方式？"></a>js无阻塞加载方式？</h3><ul><li>将脚本放在底部：script标签放在<code>&lt;/body&gt;</code>前</li><li>非阻塞脚本：等页面加载完后，再加载js。也就是在onload事件下载js<ul><li>1.defer属性/async属性</li><li>2.动态创建dom方式（创建script，插入文档，onload事件回调触发）</li></ul></li></ul><h3 id="eval是做什么的？"><a href="#eval是做什么的？" class="headerlink" title="eval是做什么的？"></a>eval是做什么的？</h3><p>功能是将对应的字符串解析成js代码并执行。</p><p>应该避免使用eval，不安全，耗性能（2次，一次解析成js代码，一次执行）</p><h3 id="事件冒泡和事件捕获？"><a href="#事件冒泡和事件捕获？" class="headerlink" title="事件冒泡和事件捕获？"></a>事件冒泡和事件捕获？</h3><p>事件流描述的是从页面接收事件的顺序。<br>IE是冒泡事件流<br>Firefox是捕获事件流</p><ul><li>事件冒泡：即事件从具体的元素到不具体的元素，从内向外传递事件</li><li>事件捕获：即事件从不具体的元素到具体的元素</li></ul><p>事件冒泡和事件捕获是两个相反的过程</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>event<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;obj1&quot;</span>&gt;</span></span><br><span class="line">        welcome</span><br><span class="line">        <span class="tag">&lt;<span class="name">h5</span> <span class="attr">id</span>=<span class="string">&quot;obj2&quot;</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h5</span> <span class="attr">id</span>=<span class="string">&quot;obj3&quot;</span>&gt;</span>world<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> obj1=<span class="built_in">document</span>.getElementById(<span class="string">&#x27;obj1&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> obj2=<span class="built_in">document</span>.getElementById(<span class="string">&#x27;obj2&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        obj1.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&#x27;hello&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;,<span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">        obj2.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&#x27;world&#x27;</span>);</span></span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>文档结构：document &gt; html &gt; body &gt; div &gt; h5<br>addEventListener的第三个参数为false,所以页面是在冒泡阶段处理绑定事件</p><p>1.点击文字welcome，触发obj1的点击事件，弹出hello<br>2.点击文字hello，触发obj2的点击事件，弹出world &gt; hello<br>3.点击world时，触发obj1的点击事件，弹出hello</p><ul><li>事件代理机制：</li></ul><p>我们想要在点击每个h5标签时，弹出对应的innerHTML 。常规做法是遍历每个h5,然后在每个h5上绑定一个点击事件，这种做法在h5较少的时候可以使用，但如果有一万个h5，那就会导致性能降低。这时就需要事件代理出场了。 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj1.addEventListener(&#x27;click&#x27;,function(e)&#123;</span><br><span class="line">    var e=e||window.event;</span><br><span class="line">    if(e.target.nodeName.toLowerCase()==&#x27;h5&#x27;)&#123;</span><br><span class="line">        alert(e.target.innerHTML);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;,false);</span><br></pre></td></tr></table></figure><p>由于事件冒泡机制，点击了h5后会冒泡到div,此时就会触发绑定在div上的点击事件，再利用target找到事件实际发生的元素，就可以达到预期的效果</p><p>采用事件代理，为页面所有a标签绑定click事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEvenetListenser(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(e.target.nodeName == <span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>问题：若a标签里面仍有span、img等其他元素，上述代码中，单击span、img等其他元素不能触发click事件。</p><p>原因：单击span、img等其他元素时，e.target指向的是触发click事件的元素（span、img等其他元素），而不是a标签</p><p>解决方法：从触发click事件的元素开始，逐级向上查找，直到找到a标签为止。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> node = e.target;</span><br><span class="line">  <span class="keyword">while</span>(node.parentNode.nodeName != <span class="string">&#x27;BODY&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node.nodeName == <span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node = node.parentNode</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>阻止事件冒泡：e.stopPropagation(),ie旧方法e.cancelBubble = true</p><h3 id="如何获取UA"><a href="#如何获取UA" class="headerlink" title="如何获取UA"></a>如何获取UA</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">whatBrowser</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        <span class="built_in">document</span>.Browser.Name.value=navigator.appName;  </span><br><span class="line">        <span class="built_in">document</span>.Browser.Version.value=navigator.appVersion;  </span><br><span class="line">        <span class="built_in">document</span>.Browser.Code.value=navigator.appCodeName;  </span><br><span class="line">        <span class="built_in">document</span>.Browser.Agent.value=navigator.userAgent;  </span><br><span class="line">    &#125;  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="js操作和设置cookie"><a href="#js操作和设置cookie" class="headerlink" title="js操作和设置cookie"></a>js操作和设置cookie</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建cookie</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, expires, path, domain, secure</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cookieText = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">&#x27;=&#x27;</span> + <span class="built_in">encodeURIComponent</span>(value);</span><br><span class="line">    <span class="keyword">if</span> (expires <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">        cookieText += <span class="string">&#x27;; expires=&#x27;</span> + expires;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (path) &#123;</span><br><span class="line">        cookieText += <span class="string">&#x27;; expires=&#x27;</span> + expires;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (domain) &#123;</span><br><span class="line">        cookieText += <span class="string">&#x27;; domain=&#x27;</span> + domain;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (secure) &#123;</span><br><span class="line">        cookieText += <span class="string">&#x27;; secure&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.cookie = cookieText;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取cookie</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cookieName = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> cookieStart = <span class="built_in">document</span>.cookie.indexOf(cookieName);</span><br><span class="line">    <span class="keyword">var</span> cookieValue = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (cookieStart &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> cookieEnd = <span class="built_in">document</span>.cookie.indexOf(<span class="string">&#x27;;&#x27;</span>, cookieStart);</span><br><span class="line">        <span class="keyword">if</span> (cookieEnd == -<span class="number">1</span>) &#123;</span><br><span class="line">            cookieEnd = <span class="built_in">document</span>.cookie.length;</span><br><span class="line">        &#125;</span><br><span class="line">        cookieValue = <span class="built_in">decodeURIComponent</span>(<span class="built_in">document</span>.cookie.substring(cookieStart + cookieName.length, cookieEnd));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cookieValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除cookie</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unsetCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.cookie = name + <span class="string">&quot;= ; expires=&quot;</span> + <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tcp三次握手"><a href="#tcp三次握手" class="headerlink" title="tcp三次握手"></a>tcp三次握手</h3><p>为了准确无误将数据送达目标处，TCP协议采取了三次握手协议。<br>用tcp协议将数据包送出去后，tcp不会对发送后的情况置之不理，它一定向对方确认是否收到。</p><ul><li>1.发送端首先发送带SYN标志的数据给对方。</li><li>2.接收方收到后回传一个SYN/ACK标志的数据包以示传达确认信息。</li><li>3.最后，发送端再回传一个带ACK标志的字段，代表握手结束</li></ul><p>若在握手过程中某个阶段被打断，TCP会再次以相同的顺序发送数据包。</p><h3 id="对promise的理解"><a href="#对promise的理解" class="headerlink" title="对promise的理解"></a>对promise的理解</h3><p>promise有四种状态：</p><ul><li>1.pending:初始状态，非fullfilled或rejected</li><li>2.fullfilled: 成功的状态</li><li>3.rejected: 失败的状态</li><li>4:settled：promise已被fullfilled或rejected，且不是pending</li></ul><p>另外，fullfilled和rejected合称settled</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (...) &#123;  <span class="comment">// succeed</span></span><br><span class="line">        resolve(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;   <span class="comment">// fails</span></span><br><span class="line">        reject(<span class="built_in">Error</span>(errMessage));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Promise 实例拥有 then 方法（具有 then 方法的对象，通常被称为 thenable）。它的使用方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure><p>接收两个函数作为参数，一个在 fulfilled 的时候被调用，一个在 rejected 的时候被调用，接收参数就是 future，onFulfilled 对应 resolve, onRejected 对应 reject</p><h3 id="谈谈性能优化问题"><a href="#谈谈性能优化问题" class="headerlink" title="谈谈性能优化问题"></a>谈谈性能优化问题</h3><p>代码层面：避免使用css表达式，避免使用高级选择器，通配选择器。<br>缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等<br>请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载。<br>请求带宽：压缩文件，开启GZIP</p><h3 id="什么是Etag？"><a href="#什么是Etag？" class="headerlink" title="什么是Etag？"></a>什么是Etag？</h3><p>浏览器下载组件的时候，会将它们存储到浏览器缓存中。如果需要再次获取相同的组件，浏览器将检查组件的缓存时间，假如已经过期，那么浏览器将发送一个条件GET请求到服务器，服务器判断缓存还有效，则发送一个304响应<br>告诉浏览器可以重用缓存组件</p><p>那么服务器是根据什么判断缓存是否还有效呢?答案有两种方式，一种是前面提到的ETag，另一种是根据Last-Modified</p><h3 id="栈和队列的区别"><a href="#栈和队列的区别" class="headerlink" title="栈和队列的区别?"></a>栈和队列的区别?</h3><p>栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。<br>队列先进先出，栈先进后出。</p><p>栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除 </p><h3 id="栈和堆的区别？"><a href="#栈和堆的区别？" class="headerlink" title="栈和堆的区别？"></a>栈和堆的区别？</h3><p>栈区（stack）—   由编译器自动分配释放   ，存放函数的参数值，局部变量的值等。<br>堆区（heap）   —   一般由程序员分配释放，   若程序员不释放，程序结束时可能由OS回收。<br>堆（数据结构）：堆可以被看成是一棵树，如：堆排序；<br>栈（数据结构）：一种先进后出的数据结构。 </p><h3 id="关于Http-2-0-你知道多少？"><a href="#关于Http-2-0-你知道多少？" class="headerlink" title="关于Http 2.0 你知道多少？"></a>关于Http 2.0 你知道多少？</h3><p>HTTP/2引入了“服务端推（serverpush）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。<br>HTTP/2提供更多的加密支持<br>HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。<br>它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript</title>
      <link href="/ZJY.github.io/2021/02/21/typescript/"/>
      <url>/ZJY.github.io/2021/02/21/typescript/</url>
      
        <content type="html"><![CDATA[<h2 id="TS（typescript）是什么？"><a href="#TS（typescript）是什么？" class="headerlink" title="TS（typescript）是什么？"></a>TS（typescript）是什么？</h2><p>TS是以JavaScript为基础构建的语言，是JavaScript的一个超集<br>TS扩展了JavaScript，并添加了类型。可以在任何支持JavaScript的平台执行。<br>TS不能被js解释器直接执行，需要将ts编译成js</p><h2 id="TS增加了什么？"><a href="#TS增加了什么？" class="headerlink" title="TS增加了什么？"></a>TS增加了什么？</h2><p>类型<br>支持ES的新特性<br>添加ES不具有的新特性<br>丰富的配置选项（编译为ES3，ES6等）<br>强大的开发工具</p><h2 id="TS安装"><a href="#TS安装" class="headerlink" title="TS安装"></a>TS安装</h2><p>1.安装node<br>2.安装npm<br>3.npm install -g typescript<br>4.tsc -v  查看tsc安装版本</p><h2 id="TS编译"><a href="#TS编译" class="headerlink" title="TS编译"></a>TS编译</h2><p>tsc ts.ts<br>编译成功生成同名js文件</p><h2 id="类型声明："><a href="#类型声明：" class="headerlink" title="类型声明："></a>类型声明：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a:number = <span class="number">10</span>;或者<span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a:number, b:number</span>):<span class="title">number</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>联合类型（Union Types）可以通过管道(|)将变量设置多种类型，赋值时可以根据设置的类型来赋值。</p><p>注意：只能赋值指定的类型，如果赋值其它类型就会报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> d: <span class="string">&#x27;male&#x27;</span> | <span class="string">&#x27;female&#x27;</span>;</span><br><span class="line">d = <span class="string">&#x27;male&#x27;</span>;</span><br><span class="line">d = <span class="string">&#x27;female&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> e: boolean | string;</span><br><span class="line">e = <span class="literal">false</span>;</span><br><span class="line">e = <span class="string">&#x27;123&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="TypeScript基础类型"><a href="#TypeScript基础类型" class="headerlink" title="TypeScript基础类型"></a>TypeScript基础类型</h2><table><thead><tr><th>数据类型</th><th>关键字</th><th>描述</th></tr></thead><tbody><tr><td>任意类型</td><td>any</td><td>声明为 any 的变量可以赋予任意类型的值</td></tr><tr><td>数字类型</td><td>number</td><td>双精度 64 位浮点值。它可以用来表示整数和分数。<br>let binaryLiteral: number = 0b1010; // 二进制 <br>let octalLiteral: number = 0o744;    // 八进制 <br>let decLiteral: number = 6;    // 十进制 <br>let hexLiteral: number = 0xf00d;    // 十六进制</td></tr><tr><td>字符串类型</td><td>string</td><td>一个字符系列，使用单引号（’）或双引号（”）来表示字符串类型。反引号（``）来定义多行文本和内嵌表达式。<br>let name: string = “Runoob”;<br>let years: number = 5;<br>let words: string = <code>您好，今年是 $&#123; name &#125; 发布 $&#123; years + 1&#125; 周年</code>;</td></tr><tr><td>布尔类型</td><td>boolean</td><td>表示逻辑值：true 和 false。<br>let flag: boolean = true;</td></tr><tr><td>数组类型</td><td>无</td><td>声明变量为数组。<br>// 在元素类型后面加上[]<br>let arr: number[] = [1, 2];<br>// 或者使用数组泛型<br>let arr: Array<number> = [1, 2];</td></tr><tr><td>元组</td><td>无</td><td>元组类型用来表示已知元素数量和类型的数组，各元素的类型不必相同，对应位置的类型需要相同。<br>let x: [string, number];<br>x = [‘Runoob’, 1];    // 运行正常<br>x = [1, ‘Runoob’];    // 报错<br>console.log(x[0]);    // 输出 Runoob</td></tr><tr><td>枚举</td><td>enum</td><td>用于定义数值集合 <br>enum Color {Red, Green, Blue};<br>let c: Color = Color.Blue;<br>console.log(c);    // 输出 2</td></tr><tr><td>void</td><td>void</td><td>用于标识方法返回值的类型，表示该方法没有返回值<br>function hello(): void {<br>alert(“Hello Runoob”);<br>或者return; /return null; /return undefined}</td></tr><tr><td>null</td><td>null</td><td>表示对象值缺失</td></tr><tr><td>undefined</td><td>undefined</td><td>用于初始化变量为一个未定义的值</td></tr><tr><td>never</td><td>never</td><td>never 是其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值</td></tr></tbody></table><h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line">a = <span class="number">123</span>;</span><br><span class="line">a = <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line">a = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s:string;</span><br><span class="line">s = a; <span class="comment">//正常</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c: unknown; <span class="comment">//未知类型的值</span></span><br><span class="line">c = <span class="number">123</span>;</span><br><span class="line">c = <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line">c = <span class="literal">true</span>;</span><br><span class="line">c = <span class="string">&#x27;str&#x27;</span>;</span><br><span class="line"></span><br><span class="line">s = c; <span class="comment">//错误：Type &#x27;unknown&#x27; is not assignable to type &#x27;string&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// unknown实际上是一个类型安全的any</span></span><br><span class="line"><span class="comment">// unknown类型的变量不可以直接赋值给其他变量，需要类型检测，any类型的可以直接赋值。</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> c === <span class="string">&#x27;string&#x27;</span>)&#123;</span><br><span class="line">    s = c; <span class="comment">//正常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者：</span></span><br><span class="line">s = h <span class="keyword">as</span> string; <span class="comment">//类型断言</span></span><br><span class="line">s = &lt;string&gt;e; <span class="comment">//类型断言</span></span><br></pre></td></tr></table></figure><h2 id="类型断言-Type-Assertion"><a href="#类型断言-Type-Assertion" class="headerlink" title="类型断言(Type Assertion)"></a>类型断言(Type Assertion)</h2><p>类型断言可以用来手动指定一个值的类型，即允许变量从一种值的类型转换为另一种类型。<br>语法：</p><ul><li>&lt;类型&gt;值</li><li>值 as 类型</li></ul><h2 id="never-不可能出现的值"><a href="#never-不可能出现的值" class="headerlink" title="never 不可能出现的值"></a>never 不可能出现的值</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示不会有返回值的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>): <span class="title">never</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值为 never 的函数可以是无法被执行到的终止点的情况</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n:never;</span><br><span class="line"><span class="keyword">let</span> m: string;</span><br><span class="line"><span class="comment">// n = 1; // 运行错误，数字类型不能转为 never 类型</span></span><br><span class="line"><span class="comment">// &lt;!-- 运行正确，never 类型可以赋值给 never类型 --&gt;</span></span><br><span class="line">n = (<span class="function">()=&gt;</span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>)&#125;)();</span><br><span class="line"></span><br><span class="line">m = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="comment">// &lt;!-- 运行正确，never 类型可以赋值给 字符串类型 --&gt;</span></span><br><span class="line">m = (<span class="function">()=&gt;</span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>)&#125;)();</span><br></pre></td></tr></table></figure><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>{}可以指定对象中有哪些属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj: &#123;<span class="attr">name</span>: string,age?:number&#125;;</span><br><span class="line">obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;zjy&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p>age?:number,?表示可选</p><p>多个属性可选：[propName: string]:any</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj: &#123;<span class="attr">name</span>: string,[propName:string]:any&#125;;</span><br><span class="line">obj = &#123;<span class="attr">name</span>:<span class="string">&#x27;zjy&#x27;</span>,<span class="attr">age</span>:<span class="number">13</span>,<span class="attr">sex</span>:<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><p>函数结构的类型声明：<br>语法：(属性：类型,…)=&gt;返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fun :<span class="function">(<span class="params">a:number,b:number</span>)=&gt;</span>number;</span><br><span class="line">fun = <span class="function"><span class="keyword">function</span>(<span class="params">n1:number,n2:number</span>):<span class="title">number</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n1 + n2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="amp-表示同时满足2个条件"><a href="#amp-表示同时满足2个条件" class="headerlink" title="&amp;:表示同时满足2个条件"></a>&amp;:表示同时满足2个条件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj2: &#123;<span class="attr">name</span>:string&#125; &amp; &#123;<span class="attr">age</span>:number&#125;;</span><br><span class="line">    obj2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;zjy&#x27;</span>, <span class="attr">age</span>:<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="类型的别名"><a href="#类型的别名" class="headerlink" title="类型的别名"></a>类型的别名</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型的别名</span></span><br><span class="line">type typename = <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> k: typename;</span><br><span class="line">k = <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="自动编译选项：tsc-xxx-ts-w"><a href="#自动编译选项：tsc-xxx-ts-w" class="headerlink" title="自动编译选项：tsc xxx.ts -w"></a>自动编译选项：tsc xxx.ts -w</h2><h2 id="添加tsconfig-json文件可编译目录下所有文件"><a href="#添加tsconfig-json文件可编译目录下所有文件" class="headerlink" title="添加tsconfig.json文件可编译目录下所有文件"></a>添加tsconfig.json文件可编译目录下所有文件</h2><p>tsc -init 生成tsconfig.json文件</p><h2 id="tsconfig-json编译选项"><a href="#tsconfig-json编译选项" class="headerlink" title="tsconfig.json编译选项"></a>tsconfig.json编译选项</h2><ul><li><p>include: [] 用于指定哪些文件需要被编译</p><ul><li>**: 任意目录</li><li>*: 任意文件</li></ul></li><li><p>exclude :[] 不需要被编译文件的目录</p><ul><li>“exclude”默认情况下会排除node_modules，bower_components，jspm_packages和<code>&lt;outDir&gt;</code>目录</li></ul></li><li><p>extends： 可以利用extends属性从另一个配置文件里继承配置</p></li><li><p>files: [] 指定一个包含相对或绝对文件路径的列表</p><ul><li>使用”include”引入的文件可以使用”exclude”属性过滤。 然而，通过 “files”属性明确指定的文件却总是会被包含在内，不管”exclude”如何设置</li></ul></li><li><p>compilerOptions:编译器选项配置</p><ul><li>target：指定ECMAScript目标版本，默认ES3，”ES5”， “ES6”/ “ES2015”， “ES2016”， “ES2017”或 “ESNext”。</li><li>module: 指定生成哪个模块系统代码： “None”， “CommonJS”， “AMD”， “System”， “UMD”， “ES6”或 “ES2015”。</li><li>lib:[]  编译过程中需要引入的库文件的列表,例如ES5，ES6 ，DOM等</li><li>outDir: 用来指定编译后文件所在目录</li><li>outFile: 将输出文件合并为一个文件,只有 “AMD”和 “System”能和 –outFile一起使用。</li><li>allowJs: 默认是false，允许编译javascript文件。</li><li>checkJs: 默认是false，是否检测js语法，与allowJs配合使用</li><li>removeComments: 默认是false，删除所有注释，除了以 /!*开头的版权信息。</li><li>noEmit: 默认是false,不输出编译文件</li><li>noEmitOnError: 默认是false 报错时不生成输出文件</li><li>alwaysStrict: 默认是false 以严格模式解析并为每个源文件生成 “use strict”语句,当文件使用模块化时自动采用严格模式，不会生成文件头部’use strict’</li><li>noImplicitAny: 默认是false 在表达式和声明上有隐含的 any类型时报错。<ul><li>例如：function add(a,b){<br>return a + b;<br>}</li></ul></li><li>noImplicitThis: 默认是false 当 this表达式的值为 any类型的时候，生成一个错误</li><li>strictNullChecks: 默认是false 严格检查空值</li><li>strict: 默认是false 启用所有严格类型检查选项。启用 –strict相当于启用 –noImplicitAny, –noImplicitThis, –alwaysStrict， –strictNullChecks和 –strictFunctionTypes和–strictPropertyInitialization</li></ul></li></ul><p>tsconfig.json文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">/* Visit https://aka.ms/tsconfig.json to read more about this file */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Basic Options */</span></span><br><span class="line">    <span class="comment">// &quot;incremental&quot;: true,                   /* Enable incremental compilation */</span></span><br><span class="line">    <span class="string">&quot;target&quot;</span>: <span class="string">&quot;es6&quot;</span>,                          <span class="comment">/* Specify ECMAScript target version: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, &#x27;ES2018&#x27;, &#x27;ES2019&#x27;, &#x27;ES2020&#x27;, or &#x27;ESNEXT&#x27;. */</span></span><br><span class="line">    <span class="string">&quot;module&quot;</span>: <span class="string">&quot;es6&quot;</span>,                     <span class="comment">/* Specify module code generation: &#x27;none&#x27;, &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27;, &#x27;es2015&#x27;, &#x27;es2020&#x27;, or &#x27;ESNext&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;lib&quot;: [],                             /* Specify library files to be included in the compilation. */</span></span><br><span class="line">    <span class="string">&quot;allowJs&quot;</span>: <span class="literal">true</span>,                       <span class="comment">/* Allow javascript files to be compiled. */</span></span><br><span class="line">    <span class="string">&quot;checkJs&quot;</span>: <span class="literal">true</span>,                       <span class="comment">/* Report errors in .js files. */</span></span><br><span class="line">    <span class="comment">// &quot;jsx&quot;: &quot;preserve&quot;,                     /* Specify JSX code generation: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;declaration&quot;: true,                   /* Generates corresponding &#x27;.d.ts&#x27; file. */</span></span><br><span class="line">    <span class="comment">// &quot;declarationMap&quot;: true,                /* Generates a sourcemap for each corresponding &#x27;.d.ts&#x27; file. */</span></span><br><span class="line">    <span class="comment">// &quot;sourceMap&quot;: true,                     /* Generates corresponding &#x27;.map&#x27; file. */</span></span><br><span class="line">    <span class="comment">// &quot;outFile&quot;: &quot;dist/app.js&quot;,                       /* Concatenate and emit output to single file. */</span></span><br><span class="line">    <span class="string">&quot;outDir&quot;</span>: <span class="string">&quot;dist/&quot;</span>,                        <span class="comment">/* Redirect output structure to the directory. */</span></span><br><span class="line">    <span class="comment">// &quot;rootDir&quot;: &quot;./&quot;,                       /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */</span></span><br><span class="line">    <span class="comment">// &quot;composite&quot;: true,                     /* Enable project compilation */</span></span><br><span class="line">    <span class="comment">// &quot;tsBuildInfoFile&quot;: &quot;./&quot;,               /* Specify file to store incremental compilation information */</span></span><br><span class="line">    <span class="string">&quot;removeComments&quot;</span>: <span class="literal">true</span>,                <span class="comment">/* Do not emit comments to output. */</span></span><br><span class="line">    <span class="string">&quot;noEmit&quot;</span>: <span class="literal">false</span>,                        <span class="comment">/* Do not emit outputs. */</span></span><br><span class="line">    <span class="string">&quot;noEmitOnError&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// &quot;importHelpers&quot;: true,                 /* Import emit helpers from &#x27;tslib&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;downlevelIteration&quot;: true,            /* Provide full support for iterables in &#x27;for-of&#x27;, spread, and destructuring when targeting &#x27;ES5&#x27; or &#x27;ES3&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;isolatedModules&quot;: true,               /* Transpile each file as a separate module (similar to &#x27;ts.transpileModule&#x27;). */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Strict Type-Checking Options */</span></span><br><span class="line">    <span class="string">&quot;strict&quot;</span>: <span class="literal">true</span>,                           <span class="comment">/* Enable all strict type-checking options. */</span></span><br><span class="line">    <span class="string">&quot;noImplicitAny&quot;</span>: <span class="literal">true</span>,                 <span class="comment">/* Raise error on expressions and declarations with an implied &#x27;any&#x27; type. */</span></span><br><span class="line">    <span class="comment">// &quot;strictNullChecks&quot;: true,              /* Enable strict null checks. */</span></span><br><span class="line">    <span class="comment">// &quot;strictFunctionTypes&quot;: true,           /* Enable strict checking of function types. */</span></span><br><span class="line">    <span class="comment">// &quot;strictBindCallApply&quot;: true,           /* Enable strict &#x27;bind&#x27;, &#x27;call&#x27;, and &#x27;apply&#x27; methods on functions. */</span></span><br><span class="line">    <span class="comment">// &quot;strictPropertyInitialization&quot;: true,  /* Enable strict checking of property initialization in classes. */</span></span><br><span class="line">    <span class="comment">// &quot;noImplicitThis&quot;: true,                /* Raise error on &#x27;this&#x27; expressions with an implied &#x27;any&#x27; type. */</span></span><br><span class="line">    <span class="comment">// &quot;alwaysStrict&quot;: true,                  /* Parse in strict mode and emit &quot;use strict&quot; for each source file. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Additional Checks */</span></span><br><span class="line">    <span class="comment">// &quot;noUnusedLocals&quot;: true,                /* Report errors on unused locals. */</span></span><br><span class="line">    <span class="comment">// &quot;noUnusedParameters&quot;: true,            /* Report errors on unused parameters. */</span></span><br><span class="line">    <span class="comment">// &quot;noImplicitReturns&quot;: true,             /* Report error when not all code paths in function return a value. */</span></span><br><span class="line">    <span class="comment">// &quot;noFallthroughCasesInSwitch&quot;: true,    /* Report errors for fallthrough cases in switch statement. */</span></span><br><span class="line">    <span class="comment">// &quot;noUncheckedIndexedAccess&quot;: true,      /* Include &#x27;undefined&#x27; in index signature results */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Module Resolution Options */</span></span><br><span class="line">    <span class="comment">// &quot;moduleResolution&quot;: &quot;node&quot;,            /* Specify module resolution strategy: &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6). */</span></span><br><span class="line">    <span class="comment">// &quot;baseUrl&quot;: &quot;./&quot;,                       /* Base directory to resolve non-absolute module names. */</span></span><br><span class="line">    <span class="comment">// &quot;paths&quot;: &#123;&#125;,                           /* A series of entries which re-map imports to lookup locations relative to the &#x27;baseUrl&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;rootDirs&quot;: [],                        /* List of root folders whose combined content represents the structure of the project at runtime. */</span></span><br><span class="line">    <span class="comment">// &quot;typeRoots&quot;: [],                       /* List of folders to include type definitions from. */</span></span><br><span class="line">    <span class="comment">// &quot;types&quot;: [],                           /* Type declaration files to be included in compilation. */</span></span><br><span class="line">    <span class="comment">// &quot;allowSyntheticDefaultImports&quot;: true,  /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */</span></span><br><span class="line">    <span class="string">&quot;esModuleInterop&quot;</span>: <span class="literal">true</span>,                  <span class="comment">/* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies &#x27;allowSyntheticDefaultImports&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;preserveSymlinks&quot;: true,              /* Do not resolve the real path of symlinks. */</span></span><br><span class="line">    <span class="comment">// &quot;allowUmdGlobalAccess&quot;: true,          /* Allow accessing UMD globals from modules. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Source Map Options */</span></span><br><span class="line">    <span class="comment">// &quot;sourceRoot&quot;: &quot;&quot;,                      /* Specify the location where debugger should locate TypeScript files instead of source locations. */</span></span><br><span class="line">    <span class="comment">// &quot;mapRoot&quot;: &quot;&quot;,                         /* Specify the location where debugger should locate map files instead of generated locations. */</span></span><br><span class="line">    <span class="comment">// &quot;inlineSourceMap&quot;: true,               /* Emit a single file with source maps instead of having a separate file. */</span></span><br><span class="line">    <span class="comment">// &quot;inlineSources&quot;: true,                 /* Emit the source alongside the sourcemaps within a single file; requires &#x27;--inlineSourceMap&#x27; or &#x27;--sourceMap&#x27; to be set. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Experimental Options */</span></span><br><span class="line">    <span class="comment">// &quot;experimentalDecorators&quot;: true,        /* Enables experimental support for ES7 decorators. */</span></span><br><span class="line">    <span class="comment">// &quot;emitDecoratorMetadata&quot;: true,         /* Enables experimental support for emitting type metadata for decorators. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Advanced Options */</span></span><br><span class="line">    <span class="string">&quot;skipLibCheck&quot;</span>: <span class="literal">true</span>,                     <span class="comment">/* Skip type checking of declaration files. */</span></span><br><span class="line">    <span class="string">&quot;forceConsistentCasingInFileNames&quot;</span>: <span class="literal">true</span>  <span class="comment">/* Disallow inconsistently-cased references to the same file. */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;include&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;src/**/*&quot;</span></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue框架基础</title>
      <link href="/ZJY.github.io/2021/02/20/vue%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80/"/>
      <url>/ZJY.github.io/2021/02/20/vue%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue-js优点"><a href="#Vue-js优点" class="headerlink" title="Vue.js优点"></a>Vue.js优点</h2><p>1.体积小</p><p>压缩后33k</p><p>2.更高的运行效率</p><p>基于虚拟dom，一种可以预先通过JavaScript进行各种计算，把最终的dom操作计算出来并优化的技术，由于这个dom操作属于预处理操作，并没有真实的操作dom，所以叫虚拟dom。</p><p>3.双向数据绑定</p><p>让开发者不再去操作dom对象，更多的精力投入到业务逻辑上</p><p>4.生态丰富、学习成本低</p><p>市场上拥有大量成熟、稳定的基于vue.js的ui框架、常用组件，实现快速开发。对初学者友好、入门容易、学习资料多。</p><h2 id="vue的安装与部署"><a href="#vue的安装与部署" class="headerlink" title="vue的安装与部署"></a>vue的安装与部署</h2><p>安装：</p><ul><li>1.通过script直接引入</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line">&lt;script src=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="comment">// &lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;</span></span><br><span class="line">&lt;script src=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>2.NPM</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue</span><br></pre></td></tr></table></figure><ul><li>3.命令行工具（CLI）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br><span class="line"><span class="comment">// OR</span></span><br><span class="line">yarn <span class="built_in">global</span> add @vue/cli</span><br></pre></td></tr></table></figure><h2 id="数据与方法"><a href="#数据与方法" class="headerlink" title="数据与方法"></a>数据与方法</h2><p>当一个 Vue 实例被创建时，它将 data 对象中的所有的 property 加入到 Vue 的响应式系统中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们的数据对象</span></span><br><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该对象被加入到一个 Vue 实例中</span></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得这个实例上的 property</span></span><br><span class="line"><span class="comment">// 返回源数据中对应的字段</span></span><br><span class="line">vm.a == data.a <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 property 也会影响到原始数据</span></span><br><span class="line">vm.a = <span class="number">2</span></span><br><span class="line">data.a <span class="comment">// =&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ……反之亦然</span></span><br><span class="line">data.a = <span class="number">3</span></span><br><span class="line">vm.a <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure><p>当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时就已经存在于 data 中的 property 才是响应式的。也就是说如果你添加一个新的 property，比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.b = <span class="string">&#x27;hi&#x27;</span></span><br></pre></td></tr></table></figure><p>那么对 b 的改动将不会触发任何视图的更新。如果你知道你会在晚些时候需要一个 property，但是一开始它为空或不存在，那么你仅需要设置一些初始值。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  newTodoText: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  visitCount: <span class="number">0</span>,</span><br><span class="line">  hideCompletedTodos: <span class="literal">false</span>,</span><br><span class="line">  todos: [],</span><br><span class="line">  error: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里唯一的例外是使用 Object.freeze()，这会阻止修改现有的 property，也意味着响应系统无法再追踪变化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.freeze(obj)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: obj</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; foo &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 这里的 `foo` 不会更新！ --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;foo = &#x27;baz&#x27;&quot;</span>&gt;</span>Change it<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>除了数据 property，Vue 实例还暴露了一些有用的实例 property 与方法。它们都有前缀 $，以便与用户定义的 property 区分开来。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.$data === data <span class="comment">// =&gt; true</span></span><br><span class="line">vm.$el === <span class="built_in">document</span>.getElementById(<span class="string">&#x27;example&#x27;</span>) <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $watch 是一个实例方法</span></span><br><span class="line">vm.$watch(<span class="string">&#x27;a&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">newValue, oldValue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个回调将在 `vm.a` 改变后调用</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</span></span><br><span class="line">beforeCreate:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;beforeCreate&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">/* 在实例创建完成后被立即调用。</span></span><br><span class="line"><span class="comment">在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。</span></span><br><span class="line"><span class="comment">然而，挂载阶段还没开始，$el 属性目前不可见。 */</span></span><br><span class="line">created:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;created&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//在挂载开始之前被调用：相关的渲染函数首次被调用</span></span><br><span class="line">beforeMount : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;beforeMount&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//el 被新创建的 vm.$el 替换, 挂载成功</span></span><br><span class="line"><span class="comment">// 注意 mounted 不会保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 mounted 内部使用 vm.$nextTick</span></span><br><span class="line">mounted : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;mounted&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//数据更新时调用</span></span><br><span class="line">beforeUpdate : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;beforeUpdate&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//组件 DOM 已经更新, 组件更新完毕 </span></span><br><span class="line">updated : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;updated&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例销毁之前调用。在这一步，实例仍然完全可用</span></span><br><span class="line">beforeDestory: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;beforeDestory&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。</span></span><br><span class="line">destroyed: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;destroyed&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 被 keep-alive 缓存的组件激活时调用。</span></span><br><span class="line">activated: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;activated&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 被 keep-alive 缓存的组件停用时调用</span></span><br><span class="line">deactivated: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;deactivated&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模版语法"><a href="#模版语法" class="headerlink" title="模版语法"></a>模版语法</h2><p>Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML，所以能被遵循规范的浏览器和 HTML 解析器解析。</p><p>在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。</p><p>1.文本<br>数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-once</span>&gt;</span>这个将不会改变: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.原始HTML<br>双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 v-html 指令：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using mustaches: &#123;&#123; rawHtml &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using v-html directive: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&quot;rawHtml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.Attribute<br>Mustache 语法不能作用在 HTML attribute 上，遇到这种情况应该使用 v-bind 指令：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;dynamicId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4.使用javascript表达式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; number + 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;&#x27;list-&#x27; + id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>指令 (Directives) 是带有 v- 前缀的特殊 attribute。指令 attribute 的值预期是单个 JavaScript 表达式 (v-for 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</p><p>1.参数<br>一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，v-bind 指令可以用于响应式地更新 HTML attribute：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另一个例子是 v-on 指令，它用于监听 DOM 事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.动态参数<br>从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[<span class="attr">attributeName</span>]=<span class="string">&quot;url&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同样地，你可以使用动态参数为一个动态的事件名绑定处理函数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:</span>[<span class="attr">eventName</span>]=<span class="string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对动态参数的值的约束:<br>  动态参数预期会求出一个字符串，异常情况下值为 null。这个特殊的 null 值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。<br>对动态参数表达式的约束:<br>  动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML attribute 名里是无效的。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这会触发一个编译警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[&#x27;<span class="attr">foo</span>&#x27; + <span class="attr">bar</span>]=<span class="string">&quot;value&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>变通的办法是使用没有空格或引号的表达式，或用计算属性替代这种复杂表达式。</p><p>在 DOM 中使用模板时 (直接在一个 HTML 文件里撰写模板)，还需要避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">在 DOM 中使用模板时这段代码会被转换为 `v-bind:[someattr]`。</span></span><br><span class="line"><span class="comment">除非在实例中有一个名为“someattr”的 property，否则代码不会工作。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[<span class="attr">someAttr</span>]=<span class="string">&quot;value&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.修饰符</p><p>修饰符 (modifier) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4.缩写</p><p>v-bind缩写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:</span>[<span class="attr">key</span>]=<span class="string">&quot;url&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>v-on缩写</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @[<span class="attr">event</span>]=<span class="string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="class和style绑定"><a href="#class和style绑定" class="headerlink" title="class和style绑定"></a>class和style绑定</h2><ul><li>绑定html class</li></ul><p>1.对象语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;&#123; active: isActive &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;div</span><br><span class="line">  class=&quot;static&quot;</span><br><span class="line">  v-bind:class=&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们也可以在这里绑定一个返回对象的计算属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;classObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  error: <span class="literal">null</span></span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  classObject: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      active: <span class="built_in">this</span>.isActive &amp;&amp; !<span class="built_in">this</span>.error,</span><br><span class="line">      <span class="string">&#x27;text-danger&#x27;</span>: <span class="built_in">this</span>.error &amp;&amp; <span class="built_in">this</span>.error.type === <span class="string">&#x27;fatal&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.数组语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;[activeClass, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;[&#123; active: isActive &#125;, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.用在组件上</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;&#123; active: isActive &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>绑定内联样式</li></ul><p>1.对象语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;styleObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  styleObject: &#123;</span><br><span class="line">    color: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">    fontSize: <span class="string">&#x27;13px&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.数组语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;[baseStyles, overridingStyles]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><ul><li><p>v-if<br>v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。</p></li><li><p>v-else<br>你可以使用 v-else 指令来表示 v-if 的“else 块”：</p></li><li><p>v-else-if<br>v-else-if，顾名思义，充当 v-if 的“else-if 块”，可以连续使用：</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;type === &#x27;A&#x27;&quot;</span>&gt;</span></span><br><span class="line">  A</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;B&#x27;&quot;</span>&gt;</span></span><br><span class="line">  B</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;C&#x27;&quot;</span>&gt;</span></span><br><span class="line">  C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  Not A/B/C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>用 key 管理可复用的元素<br>Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染.如果两个元素是完全独立的，不要复用它们，只需添加一个具有唯一值的key属性即可</p></li><li><p>v-show<br>另一个用于根据条件展示元素的选项是 v-show 指令。用法大致一样：</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">&quot;ok&quot;</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS property display。v-show 不支持 <code>&lt;template&gt; </code>元素，也不支持 v-else</p><ul><li>v-if vs v-show</li></ul><p>v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p><p>v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p>相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p><p>一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好</p><ul><li>v-if与v-for一起使用</li></ul><p>当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级</p><h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><ul><li>用 v-for 把一个数组对应为一组元素</li></ul><p>我们可以用 v-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组，而 item 则是被迭代的数组元素的别名。</p><p>你也可以用 of 替代 in 作为分隔符，因为它更接近 JavaScript 迭代器的语法：</p><ul><li>在 v-for 里使用对象</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;v-for-object&quot;</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;value in object&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; value &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#v-for-object&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    object: &#123;</span><br><span class="line">      title: <span class="string">&#x27;How to do lists in Vue&#x27;</span>,</span><br><span class="line">      author: <span class="string">&#x27;Jane Doe&#x27;</span>,</span><br><span class="line">      publishedAt: <span class="string">&#x27;2016-04-10&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以提供第二个的参数为 property 名称 (也就是键名)：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, name) in object&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还可以用第三个参数作为索引：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, name, index) in object&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在遍历对象时，会按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下都一致</p><ul><li>维护状态</li></ul><p>当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染</p><p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key attribute</p><p>建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</p><p>不要使用对象或数组之类的非基本类型值作为 v-for 的 key。请用字符串或数值类型的值。</p><ul><li>数组更新检查</li></ul><p>变更方法：Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：<br>push()<br>pop()<br>shift()<br>unshift()<br>splice()<br>sort()<br>reverse()</p><p>替换数组：变更方法，顾名思义，会变更调用了这些方法的原始数组。相比之下，也有非变更方法，例如 filter()、concat() 和 slice()。它们不会变更原始数组，而总是返回一个新数组。当使用非变更方法时，可以用新数组替换旧数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">example1.items = example1.items.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item.message.match(<span class="regexp">/Foo/</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>你可能认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表。幸运的是，事实并非如此。Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的启发式方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作</p><p>由于 JavaScript 的限制，Vue 不能检测数组和对象的变化</p><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>可以用 v-on 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example-1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;counter += 1&quot;</span>&gt;</span>Add 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>The button above has been clicked &#123;&#123; counter &#125;&#125; times.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然而许多事件处理逻辑会更为复杂，所以直接把 JavaScript 代码写在 v-on 指令中是不可行的。因此 v-on 还可以接收一个需要调用的方法名称。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example-2&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- `greet` 是在下面定义的方法名 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;greet&quot;</span>&gt;</span>Greet<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example-3&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;say(&#x27;hi&#x27;)&quot;</span>&gt;</span>Say hi<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;say(&#x27;what&#x27;)&quot;</span>&gt;</span>Say what<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;warn(&#x27;Form cannot be submitted yet.&#x27;, $event)&quot;</span>&gt;</span></span><br><span class="line">  Submit</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p>.stop<br>.prevent<br>.capture<br>.self<br>.once<br>.passive</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.once</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 而不会等待 `onScroll` 完成  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">&quot;onScroll&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击</p><h3 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 你可以直接将 KeyboardEvent.key 暴露的任意有效按键名转换为 kebab-case 来作为修饰符。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.page-down</span>=<span class="string">&quot;onPageDown&quot;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h2><p>你可以用 v-model 指令在表单<code> &lt;input&gt;</code>、<code>&lt;textarea&gt; </code>及 <code>&lt;select&gt;</code> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理</p><p>v-model 会忽略所有表单元素的 value、checked、selected attribute 的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值</p><p>v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：<br>text 和 textarea 元素使用 value property 和 input 事件；<br>checkbox 和 radio 使用 checked property 和 change 事件；<br>select 字段将 value 作为 prop 并将 change 作为事件</p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul><li>.lazy</li></ul><p>在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 lazy 修饰符，从而转为在 change 事件_之后_进行同步：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在“change”时而非“input”时更新 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.lazy</span>=<span class="string">&quot;msg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>.number</li></ul><p>如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.number</span>=<span class="string">&quot;age&quot;</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这通常很有用，因为即使在 type=”number” 时，HTML 输入元素的值也总会返回字符串。如果这个值无法被 parseFloat() 解析，则会返回原始的值</p><ul><li>.trim</li></ul><p>如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.trim</span>=<span class="string">&quot;msg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个名为 button-counter 的新组件</span><br><span class="line">Vue.component(&#x27;button-counter&#x27;, &#123;</span><br><span class="line">  data: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: &#x27;<span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;count++&quot;</span>&gt;</span>You clicked me &#123;&#123; count &#125;&#125; times.<span class="tag">&lt;/<span class="name">button</span>&gt;</span>&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>因为组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项。</p><h3 id="组件的复用"><a href="#组件的复用" class="headerlink" title="组件的复用"></a>组件的复用</h3><p>你可以将组件进行任意次数的复用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;components-demo&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意当点击按钮时，每个组件都会各自独立维护它的 count。因为你每用一次组件，就会有一个它的新实例被创建。</p><p><b>data 必须是一个函数</b><br>当我们定义这个 <code>&lt;button-counter&gt;</code> 组件时，你可能会发现它的 data 并不是像这样直接提供一个对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  count: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取而代之的是，一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 Vue 没有这条规则，点击一个按钮就可能会影响到其它所有实例</p><h3 id="通过prop向自组件传递数据"><a href="#通过prop向自组件传递数据" class="headerlink" title="通过prop向自组件传递数据"></a>通过prop向自组件传递数据</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;blog-post&#x27;</span>, &#123;</span><br><span class="line">  props: [<span class="string">&#x27;title&#x27;</span>],</span><br><span class="line">  template: <span class="string">&#x27;&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="监听子组件事件"><a href="#监听子组件事件" class="headerlink" title="监听子组件事件"></a>监听子组件事件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;blog-post</span><br><span class="line">  ...</span><br><span class="line">  v-on:enlarge-text=&quot;postFontSize += 0.1&quot;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 同时子组件可以通过调用内建的 $emit 方法并传入事件名称来触发一个事件：</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;$emit(&#x27;enlarge-text&#x27;)&quot;</span>&gt;</span></span><br><span class="line">  Enlarge text</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用事件抛出一个值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;$emit(&#x27;enlarge-text&#x27;, 0.1)&quot;</span>&gt;</span></span><br><span class="line">  Enlarge text</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在组件上使用v-model"><a href="#在组件上使用v-model" class="headerlink" title="在组件上使用v-model"></a>在组件上使用v-model</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;searchText&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等价于 --&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;input</span><br><span class="line">  v-bind:value=&quot;searchText&quot;</span><br><span class="line">  v-on:input=&quot;searchText = $event.target.value&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>当用在组件上时，v-model 则会这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;custom-input</span><br><span class="line">  v-bind:value=&quot;searchText&quot;</span><br><span class="line">  v-on:input=&quot;searchText = $event&quot;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了让它正常工作，这个组件内的 <input> 必须：<br>将其 value attribute 绑定到一个名叫 value 的 prop 上<br>在其 input 事件被触发时，将新的值通过自定义的 input 事件抛出</p><p>写成代码之后是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;custom-input&#x27;</span>, &#123;</span><br><span class="line">  props: [<span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      v-bind:value=&quot;value&quot;</span></span><br><span class="line"><span class="string">      v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在 v-model 就应该可以在这个组件上完美地工作起来了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">custom-input</span> <span class="attr">v-model</span>=<span class="string">&quot;searchText&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="通过插槽分发内容"><a href="#通过插槽分发内容" class="headerlink" title="通过插槽分发内容"></a>通过插槽分发内容</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;alert-box&#x27;, &#123;</span><br><span class="line">  template: `</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo-alert-box&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">strong</span>&gt;</span>Error!<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><p>有的时候，在不同组件之间进行动态切换是非常有用的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">&quot;currentTabComponent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h2><p>定义组件名的方式：</p><ul><li>使用kebab-case:以短横线分隔命名，你也必须在引用这个自定义元素时使用 kebab-case，例如 <code>&lt;my-component-name&gt;</code>。</li><li>使用 PascalCase:首字母大写命名定义组件，你在引用这个自定义元素时两种命名法都可以使用。也就是说 <code>&lt;my-component-name&gt;</code> 和 <code>&lt;MyComponentName&gt; </code>都是可接受的</li></ul><h3 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;my-component-name&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// ... 选项 ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">&#x27;component-a&#x27;</span>: ComponentA,</span><br><span class="line">    <span class="string">&#x27;component-b&#x27;</span>: ComponentB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Css单位px,rem,em,vw,vh的区别</title>
      <link href="/ZJY.github.io/2021/02/19/Css%E5%8D%95%E4%BD%8Dpx-rem-em-vw-vh%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/ZJY.github.io/2021/02/19/Css%E5%8D%95%E4%BD%8Dpx-rem-em-vw-vh%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="px"><a href="#px" class="headerlink" title="px"></a>px</h2><p>px就是pixel像素的缩写，相对长度单位，网页设计常用的基本单位。像素px是相对于显示器屏幕分辨率而言的</p><h2 id="em"><a href="#em" class="headerlink" title="em"></a>em</h2><p>em是相对长度单位。相对于当前对象内文本的字体尺寸（参考物是父元素的font-size）</p><p>如当前父元素的字体尺寸未设置，则相对于浏览器的默认字体尺寸</p><h2 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h2><p>rem是CSS3新增的一个相对单位，rem是相对于HTML根元素的字体大小（font-size）来计算的长度单位</p><p>如果你没有设置html的字体大小，就会以浏览器默认字体大小，一般是16px<br>html{font-size: 62.5%}  /* 10 ÷ 16 × 100% = 62.5% */</p><p>em与rem的区别：</p><p>　　rem是相对于根元素（html）的字体大小，而em是相对于其父元素的字体大小</p><p>两者使用规则：</p><p>  如果这个属性根据它的font-size进行测量，则使用em<br>  其他的一切事物属性均使用rem</p><h2 id="vw、vh"><a href="#vw、vh" class="headerlink" title="vw、vh"></a>vw、vh</h2><p>vw、vh、vmax、vmin这四个单位都是基于视口<br>vw是相对视口（viewport）的宽度而定的，长度等于视口宽度的1/100</p><p>假如浏览器的宽度为200px，那么1vw就等于2px（200px/100）</p><p>vh是相对视口（viewport）的高度而定的，长度等于视口高度的1/100</p><p>假如浏览器的高度为500px，那么1vh就等于5px（500px/100）</p><p>vmin和vmax是相对于视口的高度和宽度两者之间的最小值或最大值</p><p>如果浏览器的高为300px、宽为500px，那么1vmin就是3px，1vmax就是5px；如果浏览器的高为800px，宽为1080px，那么1vmin也是8px，1vmax也是10.8px</p><h2 id="（百分比）"><a href="#（百分比）" class="headerlink" title="%（百分比）"></a>%（百分比）</h2><p>一般来说就是相对于父元素</p><p>1、对于普通定位元素就是我们理解的父元素</p><p>2、对于position: absolute;的元素是相对于已定位的父元素</p><p>3、对于position: fixed;的元素是相对于ViewPort（可视窗口）</p><h2 id="vm"><a href="#vm" class="headerlink" title="vm"></a>vm</h2><p>css3新单位，相对于视口的宽度或高度中较小的那个</p><p>其中最小的那个被均分为100单位的vm</p><p>比如：浏览器高度900px，宽度1200px，取最小的浏览器高度，1 vm = 900px/100 = 9 px</p><p>缺点：兼容性差</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5基础</title>
      <link href="/ZJY.github.io/2021/02/19/HTML5/"/>
      <url>/ZJY.github.io/2021/02/19/HTML5/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><h3 id="开始学习HTML5"><a href="#开始学习HTML5" class="headerlink" title="开始学习HTML5"></a>开始学习HTML5</h3><h4 id="HTML5-简介"><a href="#HTML5-简介" class="headerlink" title="HTML5 简介"></a>HTML5 简介</h4><ul><li>HTML5是HTML最新的修订版本，2014年10月由万维网联盟（W3C）完成标准制定。</li><li>HTML5的设计目的是为了在移动设备上支持多媒体。</li></ul><h4 id="什么是-HTML5"><a href="#什么是-HTML5" class="headerlink" title="什么是 HTML5?"></a>什么是 HTML5?</h4><ul><li>HTML5 是下一代 HTML 标准。</li><li>HTML , HTML 4.01的上一个版本诞生于 1999 年。自从那以后，Web 世界已经经历了巨变。</li><li>HTML5 仍处于完善之中。然而，大部分现代浏览器已经具备了某些 HTML5 支持。</li><li>HTML5 受包括Firefox（火狐浏览器），IE9及其更高版本，Chrome（谷歌浏览器），Safari，Opera等国外主流浏览器的支持；国内的傲游浏览器（Maxthon）， 360浏览器、搜狗浏览器、QQ浏览器、猎豹浏览器等同样具备支持HTML5的能力。</li></ul><h4 id="HTML5-lt-DOCTYPE-gt"><a href="#HTML5-lt-DOCTYPE-gt" class="headerlink" title="HTML5 &lt;!DOCTYPE&gt;"></a>HTML5 &lt;!DOCTYPE&gt;</h4><!doctype><p> 声明必须位于 HTML5 文档中的第一行,使用非常简单:<code>&lt;!doctype html&gt;</code></p><h4 id="最小的HTML5文档"><a href="#最小的HTML5文档" class="headerlink" title="最小的HTML5文档"></a>最小的HTML5文档</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="HTML5的改进"><a href="#HTML5的改进" class="headerlink" title="HTML5的改进"></a>HTML5的改进</h4><ul><li>新元素</li><li>新属性</li><li>完全支持 CSS3</li><li>Video 和 Audio</li><li>2D/3D 制图</li><li>本地存储</li><li>本地 SQL 数据</li><li>Web 应用</li></ul><h4 id="HTML5多媒体"><a href="#HTML5多媒体" class="headerlink" title="HTML5多媒体"></a>HTML5多媒体</h4><p>使用 HTML5 你可以简单的在网页中播放 视频(video)与音频 (audio) 。</p><ul><li>html5 <code>&lt;video/&gt;</code></li><li>html5 <code>&lt;audio/&gt;</code></li></ul><h4 id="HTML5-图形"><a href="#HTML5-图形" class="headerlink" title="HTML5 图形"></a>HTML5 图形</h4><p>使用 HTML5 你可以简单的绘制图形:</p><ul><li>使用 <code>&lt;canvas&gt;</code> 元素</li><li>使用内联 SVG</li><li>使用 CSS3 2D/CSS 3D</li></ul><h4 id="HTML5-使用-CSS3"><a href="#HTML5-使用-CSS3" class="headerlink" title="HTML5 使用 CSS3"></a>HTML5 使用 CSS3</h4><ul><li>新选择器</li><li>新属性</li><li>动画</li><li>2D/3D 转换</li><li>圆角</li><li>阴影效果</li><li>可下载的字体</li></ul><h4 id="语义要素"><a href="#语义要素" class="headerlink" title="语义要素"></a>语义要素</h4><p>HTML5 添加了很多语义元素如下所示：</p><ul><li>article: 定义页面独立的内容区域。</li><li>aside:定义页面的侧边栏内容</li><li>bdi:允许您设置一段文本，使其脱离其父元素的文本方向设置。</li><li>command:定义命令按钮，比如单选按钮、复选框或按钮</li><li>details:用于描述文档或文档某个部分的细节</li><li>dialog:定义对话框，比如提示框</li><li>summary: 标签包含 details 元素的标题</li><li>figure:规定独立的流内容（图像、图表、照片、代码等等）</li><li>figcaption:定义 <code>&lt;figure&gt; </code>元素的标题</li><li>footer:定义 section 或 document 的页脚。</li><li>header:定义了文档的头部区域</li><li>mark:定义带有记号的文本。</li><li>meter:定义度量衡。仅用于已知最大和最小值的度量</li><li>nav:定义导航链接的部分。</li><li>progress:定义任何类型的任务的进度</li><li>ruby:定义 ruby 注释（中文注音或字符）</li><li>rt:定义字符（中文注音或字符）的解释或发音。</li><li>rp:在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容</li><li>section:定义文档中的节（section、区段）</li><li>time:定义日期或时间。</li><li>wbr:规定在文本中的何处适合添加换行符</li></ul><h4 id="HTML5-新特性"><a href="#HTML5-新特性" class="headerlink" title="HTML5 - 新特性"></a>HTML5 - 新特性</h4><ul><li>用于绘画的 canvas 元素</li><li>用于媒介回放的 video 和 audio 元素</li><li>对本地离线存储的更好的支持</li><li>新的特殊内容元素，比如 article、footer、header、nav、section</li><li>新的表单控件，比如 calendar、date、time、email、url、search</li></ul><h3 id="HTML5-浏览器支持"><a href="#HTML5-浏览器支持" class="headerlink" title="HTML5 浏览器支持"></a>HTML5 浏览器支持</h3><ul><li>HTML5 浏览器支持<br>  现代的浏览器都支持 HTML5。<br>  此外，所有浏览器，包括旧的和最新的，对无法识别的元素会作为内联元素自动处理。<br>  正因为如此，你可以 “教会” 浏览器处理 “未知” 的 HTML 元素。</li><li>将 HTML5 元素定义为块元素<br>  HTML5 定了 8 个新的 HTML 语义（semantic）  元素。所有这些元素都是块级 元素。<br>  为了能让旧版本的浏览器正确显示这些元素，你可以设置 CSS 的 display 属性值为 block:<br>  header, section, footer, aside, nav, main, article, figure {display: block;}</li><li>为 HTML 添加新元素</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> newEle = <span class="built_in">document</span>.createElement(<span class="string">&#x27;myHero&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> content = <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;myHero&#x27;</span>);</span></span><br><span class="line">        newEle.appendChild(content)</span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.body.appendChild(newEle);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    myHero&#123;</span><br><span class="line"><span class="css">        <span class="selector-tag">background-color</span><span class="selector-pseudo">:red</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">padding</span><span class="selector-pseudo">:30px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Internet Explorer 浏览器问题<ul><li>你可以使用以上的方法来为 IE 浏览器添加 HTML5 元素，但是Internet Explorer 8 及更早 IE 版本的浏览器不支持以上的方式.针对IE浏览器html5shiv 是比较好的解决方案。html5shiv主要解决HTML5提出的新的元素不被IE6-8识别，这些新元素不能作为父节点包裹子元素，并且不能应用CSS样式。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- [<span class="keyword">if</span> It IE <span class="number">9</span>] --&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;/html5shiv.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- [endif] --&gt;</span><br></pre></td></tr></table></figure><ul><li>完美的 Shiv 解决方案<ul><li>html5shiv.js 引用代码必须放在  <code>&lt;head&gt;</code> 元素中，因为 IE 浏览器在解析 HTML5 新元素时需要先加载该文件。</li></ul></li></ul><h3 id="HTML5-新元素"><a href="#HTML5-新元素" class="headerlink" title="HTML5 新元素"></a>HTML5 新元素</h3><h4 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h4><p>什么是canvas？<br>  标签定义图形，比如图表和其他图像。该标签基于javascript的绘图API。<br>创建画布<br>  画布在网页中是一个矩形框，通过<code>&lt;canvas&gt;</code>元素来绘制</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;myCanvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>使用 JavaScript 来绘制图像<br>  canvas本身没有绘图能力，所以绘图工作必须在js内完成：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = c.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">ctx.fillStyle=<span class="string">&quot;#ffffff&quot;</span>;</span><br><span class="line">ctx.fillRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">150</span>,<span class="number">75</span>);</span><br></pre></td></tr></table></figure><p>canvas-坐标<br>  canvas是一个二维网络，左上角坐标为（0，0）<br>  ctx.fillRect(0,0,150,75);在画布上绘制150*75的矩形，从左上角开始</p><p>canvas-路径<br>  moveTo(x,y) 定义线条开始坐标<br>  lineTo(x,y) 定义线条结束坐标</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx.moveTo(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">ctx.lineTo(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line">ctx.stroke();<span class="comment">//绘制线条</span></span><br></pre></td></tr></table></figure><p>  绘制圆形：arc(x,y,r,start,stop)</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx.begainPath();</span><br><span class="line">ctx.arc(<span class="number">0</span>,<span class="number">0</span>,<span class="number">40</span>,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p>canvas-文本<br>  fillText(text,x,y,[maxWidth]);</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx.font = <span class="string">&#x27;30px arial&#x27;</span>;</span><br><span class="line">ctx.fillText(<span class="string">&#x27;hello,world&quot;,10,50)</span></span><br></pre></td></tr></table></figure><p>canvas-渐变</p><p>  渐变可以填充在矩形，圆形，线条，文本等，可以定义不同的颜色<br>  createLinearGradient(x,y,x1,y1);//线条渐变<br>  createRadialGradient(x,y,r,x1,y1,r1);//径向/圆渐变<br>  当我们使用渐变对象，必须使用两种或两种以上的停止颜色<br>  addColorStop()方法指定颜色停止，参数使用坐标来描述，可以是0至1.<br>  设置fillStyle或strokeStyle的值为渐变，然后绘制形状，如矩形，文本，或一条线。<br>  使用createLinearGradient：创建一个线性渐变，使用渐变填充矩形</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//create gradient</span></span><br><span class="line"><span class="keyword">var</span> grd = ctx.createLinearGradient(<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">0</span>);</span><br><span class="line">grd.addColorStop(<span class="number">0</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line">grd.addColorStop(<span class="number">1</span>,<span class="string">&#x27;white&#x27;</span>);</span><br><span class="line"><span class="comment">//fill width gradient</span></span><br><span class="line">ctx.fillStyle = grd;</span><br><span class="line">ctx.fillRect(<span class="number">10</span>,<span class="number">10</span>,<span class="number">150</span>,<span class="number">80</span>);</span><br></pre></td></tr></table></figure><p>  使用createRadialGradient：创建一个径向/圆渐变，使用渐变填充矩形</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> grd = ctx.createRadialGradient(<span class="number">75</span>,<span class="number">50</span>,<span class="number">5</span>,<span class="number">90</span>,<span class="number">60</span>,<span class="number">100</span>);</span><br><span class="line">grd.addColorStop(<span class="number">0</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line">grd.addColorStop(<span class="number">1</span>,<span class="string">&#x27;white&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.fillStyle= grd;</span><br><span class="line">ctx.fillRect(<span class="number">10</span>,<span class="number">10</span>,<span class="number">150</span>,<span class="number">80</span>);</span><br></pre></td></tr></table></figure><p>  createRadialGradient(x , y , r , x1 , y1 , r1) 括号内的参数有如下的含义:<br>  x：表示渐变的开始圆的 x 坐标<br>  y：表示渐变的开始圆的 y 坐标<br>  r：表示开始圆的半径<br>  x1：表示渐变的结束圆的 x 坐标<br>  y1：表示渐变的结束圆的 y 坐标<br>  r1：表示结束圆的半径</p><p>canvas-图像<br>  drawImage(image,x,y)</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.getElementById(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">ctx.drawImage(img,<span class="number">10</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h4 id="新多媒体元素"><a href="#新多媒体元素" class="headerlink" title="新多媒体元素"></a>新多媒体元素</h4><ul><li>audio音频</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;audio.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;aduio/ogg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;audio.mp3&quot;</span> <span class="attr">type</span>=<span class="string">&quot;aduio/mpeg&quot;</span>&gt;</span></span><br><span class="line">  您的浏览器不支持audio元素</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><p>control 属性供添加播放、暂停和音量控件<br>在<code>&lt;audio&gt;</code> 与 <code>&lt;/audio&gt;</code> 之间你需要插入浏览器不支持的<code>&lt;audio&gt;</code>元素的提示文本 。<br><code>&lt;audio&gt;</code> 元素允许使用多个 <code>&lt;source&gt;</code> 元素. <code>&lt;source&gt;</code> 元素可以链接不同的音频文件，浏览器将使用第一个支持的音频文件</p><ul><li>video视频</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> <span class="attr">width</span>=<span class="string">&quot;320&quot;</span> <span class="attr">height</span>=<span class="string">&quot;240&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;movie.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/ogg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;movie.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line">  您的浏览器不支持video元素</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;video&gt;</code>元素提供了播放、暂停和音量控件来控制视频。<br>同时<code>&lt;video&gt;</code>元素也提供了 width 和 height 属性控制视频的尺寸.如果设置的高度和宽度，所需的视频空间会在页面加载时保留。。如果没有设置这些属性，浏览器不知道大小的视频，浏览器就不能再加载时保留特定的空间，页面就会根据原始视频的大小而改变。<br>元素支持多个source元素. 元素可以链接不同的视频文件。浏览器将使用第一个可识别的格式<br>元素支持三种视频格式： MP4, WebM, 和 Ogg:</p><ul><li><p>source<br><code>&lt;source&gt;</code> 标签可以为<code>&lt;picture&gt;</code>、<code>&lt;audio&gt;</code>或<code>&lt;video&gt;</code>元素指定一个或者多个的媒体资源</p></li><li><p>embed<br>定义嵌入的内容，比如插件，定义了一个容器，用来嵌入外部应用或者互动程序（插件）<br>属性：<br>height：规定嵌入内容的高度<br>src: 规定嵌入内容的url<br>type: 规定嵌入内容的MIME类型<br>width: 规定嵌入内容的宽带</p></li><li><p>track<br>为诸如 <code>&lt;video&gt;</code> 和 <code>&lt;audio&gt;</code> 元素之类的媒介规定外部文本轨道<br><code>&lt;track&gt;</code> 标签用作 <code>&lt;audio&gt;</code> 元素和 <code>&lt;video&gt; </code>元素的子级，它允许您指定定时文本轨道（或基于时间的数据），采用 WebVTT 格式（.vtt 文件）</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> <span class="attr">width</span>=<span class="string">&quot;320&quot;</span> <span class="attr">height</span>=<span class="string">&quot;240&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;movie.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/ogg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;movie.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">track</span> <span class="attr">src</span>=<span class="string">&quot;subtitle_en.vtt&quot;</span> <span class="attr">kind</span>=<span class="string">&quot;subtitles&quot;</span> <span class="attr">srclang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">label</span>=<span class="string">&quot;English&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">track</span> <span class="attr">src</span>=<span class="string">&quot;subtitle_zh.vtt&quot;</span> <span class="attr">kind</span>=<span class="string">&quot;subtitles&quot;</span> <span class="attr">srclang</span>=<span class="string">&quot;zh&quot;</span> <span class="attr">label</span>=<span class="string">&quot;Zh&quot;</span>&gt;</span></span><br><span class="line">  您的浏览器不支持video元素</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个元素用于规定字幕文件或其他包含文本的文件，当媒体播放时，这些文件是可见的。</p><h4 id="新表单元素"><a href="#新表单元素" class="headerlink" title="新表单元素"></a>新表单元素</h4><ul><li>datalist<br>定义选项列表。请与 input 元素配合使用该元素，来定义 input 可能的值<ul><li><code>&lt;datalist&gt;</code> 标签规定了 <code>&lt;input&gt;</code> 元素可能的选项列表。</li><li><code>&lt;datalist&gt;</code> 标签被用来在为 <code>&lt;input&gt;</code> 元素提供”自动完成”的特性。用户能看到一个下拉列表，里边的选项是预先定义好的，将作为用户的输入数据。</li><li>请使用 <code>&lt;input&gt;</code> 元素的 list 属性来绑定 <code>&lt;datalist&gt;</code> 元素。</li><li>提示：不能控制 datalist 的位置，并且不能将其与服务器的数据进行绑定。</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">list</span>=<span class="string">&quot;browser&quot;</span> <span class="attr">name</span>=<span class="string">&quot;browser&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">&quot;browser&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;IE&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Firefox&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;chrome&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Opera&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;safari&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>keygen</p><ul><li>规定用于表单的密钥对生成器字段</li><li>当提交表单时，私钥存储在本地，公钥发送到服务器。</li></ul></li><li><p>output</p><ul><li>定义不同类型的输出，比如脚本的输出</li></ul></li></ul><h4 id="新的语义和结构元素"><a href="#新的语义和结构元素" class="headerlink" title="新的语义和结构元素"></a>新的语义和结构元素</h4><ul><li><p>article：定义页面独立的内容区域，主要是布局文章、内容方面的内容</p></li><li><p>aside：定义页面的侧边栏内容。<code>&lt;aside&gt;</code> 标签定义 <code>&lt;article&gt;</code> 标签外的内容</p></li><li><p>bdi:标签允许您设置一段文本，使其脱离其父元素的文本方向设置</p></li><li><p>figure: 标签规定独立的流内容（图像、图表、照片、代码等等）,figure 元素的内容应该与主内容相关，但如果被删除，则不应对文档流产生影响</p></li><li><p>footer:标签定义文档document或节section的页脚。页脚通常包含文档的作者、版权信息、使用条款链接、联系信息等等。您可以在一个文档中使用多个 <code>&lt;footer&gt; </code>元素。</p></li><li><p>header:定义了文档的头部区域,表示介绍性的内容，可以让您了解页面涉及的内容，具有导航性.在一个文档中，您可以定义多个 <code>&lt;header&gt;</code> 元素。注释：<code>&lt;header&gt;</code> 标签不能被放在 <code>&lt;footer&gt;</code>、<code>&lt;address&gt;</code> 或者另一个 <code>&lt;header&gt;</code> 元素内部。</p></li><li><p>mark:带有记号的文本，请在需要突出显示文本时使用 <code>&lt;mark&gt; </code>标签。</p></li><li><p>meter：定义度量衡。仅用于已知最大和最小值的度量<code>&lt;meter min=&quot;0&quot; max=&quot;10&quot; value=&quot;5&quot;&gt;5 out of 10&lt;/meter&gt;</code></p></li><li><p>nav:标签定义导航链接的部分,如果文档中有“前后”按钮，则应该把它放到 <code>&lt;nav&gt; </code>元素中。</p></li><li><p>progress:标签标示任务的进度</p></li><li><p>ruby:标签定义 ruby 注释（中文注音或字符）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ruby</span>&gt;</span></span><br><span class="line">    王 <span class="tag">&lt;<span class="name">rp</span>&gt;</span>(<span class="tag">&lt;/<span class="name">rp</span>&gt;</span><span class="tag">&lt;<span class="name">rt</span>&gt;</span> wang <span class="tag">&lt;/<span class="name">rt</span>&gt;</span><span class="tag">&lt;<span class="name">rp</span>&gt;</span>)<span class="tag">&lt;/<span class="name">rp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ruby</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将 <code>&lt;ruby&gt;</code> 标签与 <code>&lt;rt&gt;</code> 和 <code>&lt;rp&gt; </code>标签一起使用<br>rt:定义字符（中文注音或字符）的解释或发音<br>rp:在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容</p></li><li><p>section:定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。</p></li><li><p>time:用来表示HTML网页中出现的日期和时间，目的是让搜索引擎等其它程序更容易的提取这些信息。<code>&lt;time&gt;</code> 标签不会在任何浏览器中呈现任何特殊效果，只是用来给机器识别的。</p></li><li><p>wbr:可以用来定义HTML文档中需要进行换行的位置，与<code>&lt;br&gt;</code>标签不同，如果浏览器窗口的宽度足够，则不换行；反之，则在添加了 <code>&lt;wbr&gt;</code> 标签的位置进行换行</p></li></ul><h3 id="HTML5-内联-SVG"><a href="#HTML5-内联-SVG" class="headerlink" title="HTML5 内联 SVG"></a>HTML5 内联 SVG</h3><p>SVG表示可缩放矢量图形，是基于可扩展标记语言（标准通用标记语言的子集），用于描述二维矢量图形的一种图形格式，它在2003年1月14日成为W3C推荐标准。<br>什么是SVG?</p><ul><li>SVG 指可伸缩矢量图形 (Scalable Vector Graphics)</li><li>SVG 用于定义用于网络的基于矢量的图形</li><li>SVG 使用 XML 格式定义图形</li><li>SVG 图像在放大或改变尺寸的情况下其图形质量不会有损失</li><li>SVG 是万维网联盟的标准</li><li>SVG 与 DOM 和 XSL 之类的 W3C 标准是一个整体</li></ul><p>与其他图像格式相比（比如 JPEG 和 GIF），使用 SVG 的优势在于：</p><ul><li>SVG 图像可通过文本编辑器来创建和修改</li><li>SVG 图像可被搜索、索引、脚本化或压缩</li><li>SVG 是可伸缩的</li><li>SVG 图像可在任何的分辨率下被高质量地打印</li><li>SVG 可在图像质量不下降的情况下被放大</li></ul><p>SVG 与 Canvas两者间的区别:</p><ul><li>SVG 是一种使用 XML 描述 2D 图形的语言。</li><li>Canvas 通过 JavaScript 来绘制 2D 图形</li><li>SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器</li><li>在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形</li><li>Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。</li></ul><p>Canvas与SVG的比较<br>canvas：</p><ul><li>依赖分辨率</li><li>不支持事件处理器</li><li>弱的文本渲染能力</li><li>能够以png或jpg格式保存结果图像</li><li>最适合图像密集型游戏，其中的许多对象会被频繁重绘</li></ul><p>svg：</p><ul><li>不依赖分辨率</li><li>支持事件处理器</li><li>最适合带有大型渲染区域的应用程序（比如地图）</li><li>复杂度稿会减慢渲染速度（任何过度使用DOM的应用都不快）</li><li>不适合游戏应用</li></ul><h3 id="HTML5-拖放"><a href="#HTML5-拖放" class="headerlink" title="HTML5 拖放"></a>HTML5 拖放</h3><ul><li>HTML5 拖放（Drag 和 Drop）<ul><li>拖放的目的是可以让你将某个对象放置到你想要放置的位置。</li><li>拖放（Drag 和 drop）是 HTML5 标准的组成部分。</li><li>拖放是一种常见的特性，即抓取对象以后拖到另一个位置。</li><li>在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">allowDrop</span>(<span class="params">ev</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ev.preventDefault();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drag</span>(<span class="params">ev</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ev.dataTransfer.setData(<span class="string">&quot;Text&quot;</span>,ev.target.id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drop</span>(<span class="params">ev</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ev.preventDefault();</span><br><span class="line"><span class="keyword">var</span> data=ev.dataTransfer.getData(<span class="string">&quot;Text&quot;</span>);</span><br><span class="line">ev.target.appendChild(<span class="built_in">document</span>.getElementById(data));</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;p&gt;请把 W3School 的图片拖放到矩形中：&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">&quot;div1&quot;</span> ondrop=<span class="string">&quot;drop(event)&quot;</span> ondragover=<span class="string">&quot;allowDrop(event)&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">&lt;img id=<span class="string">&quot;drag1&quot;</span> src=<span class="string">&quot;/i/eg_dragdrop_w3school.gif&quot;</span> draggable=<span class="string">&quot;true&quot;</span> ondragstart=<span class="string">&quot;drag(event)&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p>设置元素为可拖放:<code>&lt;img draggable=&quot;true&quot;&gt;</code><br>拖动什么 - ondragstart 和 setData()<br>放到何处 - ondragover,ondragover 事件规定在何处放置被拖动的数据。<br>默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。<br>这要通过调用 ondragover 事件的 event.preventDefault() 方法<br>进行放置 - ondrop</p><h3 id="HTML5-地理定位"><a href="#HTML5-地理定位" class="headerlink" title="HTML5 地理定位"></a>HTML5 地理定位</h3><p>HTML5 Geolocation（地理定位）用于定位用户的位置<br>Geolocation 通过请求一个位置信息，用户同意后，浏览器会返回一个包含经度和维度的位置信息</p><p>定位用户的位置:<br>  HTML5 Geolocation API 用于获得用户的地理位置<br>  鉴于该特性可能侵犯用户的隐私，除非用户同意，否则用户位置信息是不可用的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;p id=<span class="string">&quot;demo&quot;</span>&gt;点击按钮获取您当前坐标：&lt;/p&gt;</span><br><span class="line">&lt;button onclick=<span class="string">&quot;getLocation()&quot;</span>&gt;click me&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;demo&#x27;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getLocation</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(navigator.geolocation)&#123;</span><br><span class="line">            navigator.geolocation.getCurrentPosition(showPosition);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            x.innerHTML =<span class="string">&#x27;该浏览器不支持获取地理位置&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">showPosition</span>(<span class="params">position</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(position)</span><br><span class="line">        x.innerHTML = <span class="string">&#x27;纬度：&#x27;</span>+ position.coords.latitude+<span class="string">&#x27;&lt;br&gt;经度：&#x27;</span>+position.coords.longitude</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> HTML5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http常见面试题</title>
      <link href="/ZJY.github.io/2021/02/05/http%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/ZJY.github.io/2021/02/05/http%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="1-HTTP基本概念"><a href="#1-HTTP基本概念" class="headerlink" title="1.HTTP基本概念"></a>1.HTTP基本概念</h2><h3 id="1-1-http是什么？"><a href="#1-1-http是什么？" class="headerlink" title="1.1 http是什么？"></a>1.1 http是什么？</h3><p>http是超文本传输协议，也就是HyperText Transfer Protocaol。</p><ul><li>协议<ul><li>http是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式</li></ul></li><li>传输<ul><li>http协议是一个双向协议</li><li>http是一个在计算机世界里专门用来在两点之间传输数据的约定和规范<br>  我们在上网冲浪时，浏览器是请求方 A ，百度网站就是应答方 B。双方约定用 HTTP 协议来通信，于是浏览器把请求数据发送给网站，网站再把一些数据返回给浏览器，最后由浏览器渲染在屏幕，就可以看到图片、视频了。<br>  数据虽然是在 A 和 B 之间传输，但允许中间有中转或接力。<br>  就好像第一排的同学想穿递纸条给最后一排的同学，那么传递的过程中就需要经过好多个同学（中间人），这样的传输方式就从「A &lt; — &gt; B」，变成了「A &lt;-&gt; N &lt;-&gt; M &lt;-&gt; B」。<br>  而在 HTTP 里，需要中间人遵从 HTTP 协议，只要不打扰基本的数据传输，就可以添加任意额外的东西。</li></ul></li><li>超文本<ul><li>http传输的内容是超文本</li><li>我们先来理解「文本」，在互联网早期的时候只是简单的字符文字，但现在「文本」的涵义已经可以扩展为图片、视频、压缩包等，在 HTTP 眼里这些都算做「文本」</li><li>再来理解「超文本」，它就是超越了普通文本的文本，它是文字、图片、视频等的混合体最关键有超链接，能从一个超文本跳转到另外一个超文本</li><li>HTML 就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，在经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了</li></ul></li></ul><p><b>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</b></p><h3 id="1-2-「HTTP-是用于从互联网服务器传输超文本到本地浏览器的协议HTTP」-这种说法正确吗？"><a href="#1-2-「HTTP-是用于从互联网服务器传输超文本到本地浏览器的协议HTTP」-这种说法正确吗？" class="headerlink" title="1.2 「HTTP 是用于从互联网服务器传输超文本到本地浏览器的协议HTTP」,这种说法正确吗？"></a>1.2 「HTTP 是用于从互联网服务器传输超文本到本地浏览器的协议HTTP」,这种说法正确吗？</h3><p>这种说法是不正确的。因为也可以是「服务器&lt; – &gt;服务器」，所以采用两点之间的描述会更准确</p><h3 id="1-3-http常见的状态吗有哪些？"><a href="#1-3-http常见的状态吗有哪些？" class="headerlink" title="1.3 http常见的状态吗有哪些？"></a>1.3 http常见的状态吗有哪些？</h3><ul><li>1xx<ul><li>1xx类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少</li></ul></li><li>2xx<ul><li>2xx类状态码表示服务器成功处理了客户端的请求。</li><li>200 ok是最常见的成功状态码，表示一切正常。如果是非HEAD请求，服务器返回的相应头都会有body数据。</li><li>204 no content也是常见的成功状态码，与200基本相同，但响应头没有body数据。</li><li>206 partial content是应用于http分块下载或断电续传。表示响应返回的body数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li></ul></li><li>3xx<ul><li>3xx类状态码表示客户端请求的资源发生了变动，需要客户端用新的URL重新发送请求获取资源，也就是重定向。</li><li>301 Moved Permanently 表示永久重定向，说明请求的资源已经不在了，需要用另一个url再次访问</li><li>302 临时重定向，说明请求的资源还在，但暂时需要用另一个url来访问</li><li>301和302都会在响应头里使用字段location，指明后续要跳转的url，浏览器会自动重定向新的url。</li><li>304 not modified不具有跳转的含义，表示资源未被修改，重定向已存在的缓冲文件，也称为缓存重定向，用于缓存控制。</li></ul></li><li>4xx<ul><li>4xx类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。</li><li>400 bad request表示客户端请求的报文有误，但只是个笼统的错误</li><li>401 用户没有访问权限,需要进行身份认证</li><li>403 forbidden表示服务器禁止访问资源，并不是客户端的请求出错</li><li>404 not found表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul></li><li>5xx<ul><li>5xx类状态码表示客户端请求报文正确，但服务器处理时内部发生了错误，属于服务端的错误码。</li><li>500 internal server error，与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li><li>501 not implemented 表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li><li>502 bad gateway，通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误</li><li>503 service unavailable表示服务器当前很忙，暂时无法响应服务器。</li></ul></li></ul><h3 id="1-4-http常见字段有哪些？"><a href="#1-4-http常见字段有哪些？" class="headerlink" title="1.4 http常见字段有哪些？"></a>1.4 http常见字段有哪些？</h3><ul><li>Host<ul><li>客户端发送请求时，用来指定服务器的域名</li><li>host:http:<a href="http://www.a.com/">www.a.com</a></li><li>有了host字段，就可以将请求发往同一台服务器的不同网站</li></ul></li><li>Content-Length<ul><li>服务器在返回数据时，会有content-length字段，表明本次回应的数据长度</li></ul></li><li>Connection字段<ul><li>Connection字段最常用于客户端要求服务器使用TCP持久连接，以便其他请求复用。Connection: keep-alive</li></ul></li><li>Content-Type字段<ul><li>Content-Type字段用于服务器返回时，告诉客户端本次数据返回什么格式。</li><li>Content-Type: text/html; charset=utf-8</li><li>上面的类型表明，发送的是网页，而且编码是UTF-8</li><li>客户端请求的时候，可以使用 Accept 字段声明自己可以接受哪些数据格式</li><li>Accept: <em>/</em></li><li>上面代码中，客户端声明自己可以接受任何格式的数据。</li></ul></li><li>Content-Encoding字段<ul><li>Content-Encoding 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</li><li>Content-Encoding: gzip</li><li>上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。</li><li>客户端在请求时，用 Accept-Encoding 字段说明自己可以接受哪些压缩方法</li><li>Accept-Encoding: gzip, deflate</li></ul></li></ul><h2 id="2-GET和POST"><a href="#2-GET和POST" class="headerlink" title="2.GET和POST"></a>2.GET和POST</h2><h3 id="2-1get和post的区别？"><a href="#2-1get和post的区别？" class="headerlink" title="2.1get和post的区别？"></a>2.1get和post的区别？</h3><ul><li>get方法含义是请求从服务器获取资源，这个资源可以是静态的文本、页面、图片视频等。比如打开一篇文章，浏览器会发送get请求给服务器，服务器就会返回文章所有资源。</li><li>post方法向url指定的资源提交数据，数据就放在报文的body里。比如在一篇文章底部，提交留言板，浏览器就会执行一次post请求，把你的留言文字放进报文body里然后拼接好post请求，通过tcp协议发送给服务器。</li></ul><h3 id="2-2-get和post-方法都是安全和幂等的吗？"><a href="#2-2-get和post-方法都是安全和幂等的吗？" class="headerlink" title="2.2 get和post 方法都是安全和幂等的吗？"></a>2.2 get和post 方法都是安全和幂等的吗？</h3><ul><li>安全：在http协议里，所谓的安全是指请求方法不会破坏服务器上的资源。</li><li>幂等：多次执行相同的操作，结果都是相同的。</li><li>get方法就是安全且幂等的，因为它是只读操作，无论操作多少次，服务器上的数据是安全的，且每次的结果都是相同的。</li><li>post是新增或提交数据的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。</li></ul><h2 id="3-http的特性"><a href="#3-http的特性" class="headerlink" title="3.http的特性"></a>3.http的特性</h2><h3 id="3-1-你知道的-HTTP（1-1）-的优点有哪些，怎么体现的？"><a href="#3-1-你知道的-HTTP（1-1）-的优点有哪些，怎么体现的？" class="headerlink" title="3.1 你知道的 HTTP（1.1） 的优点有哪些，怎么体现的？"></a>3.1 你知道的 HTTP（1.1） 的优点有哪些，怎么体现的？</h3><p>http最凸出的优点是简单、灵活和易于扩展、应用广泛和跨平台。</p><ul><li>简单：http最基本的报文格式是header+body，头部信息也是key-value简单文本的形式。易于理解降低学习和使用门槛。</li><li>灵活和易于扩展：<ul><li>http协议里的各类请求方法、URL/URI、状态码、头字段等每个组成要求都没被固定死，都允许开发人员自定义和扩展。</li><li>http工作在应用层，则它下层可以随意变化</li><li>HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP3 甚至把 TCPP 层换成了基于 UDP 的 QUIC。</li></ul></li><li>应用广泛和跨平台</li></ul><h3 id="3-2-http的缺点？"><a href="#3-2-http的缺点？" class="headerlink" title="3.2 http的缺点？"></a>3.2 http的缺点？</h3><p>http协议里有优缺点一体的双刃剑，分别是无状态、明文传输，同时还有一大缺点不安全。</p><ul><li>无状态双刃剑<ul><li>无状态的好处，因为服务器不会去记忆http的状态，所以不需要额外的资源来记录状态信息，这可以减轻服务器的压力，能够把更多的cpu和内存用于对外提供服务</li><li>无状态的坏处，既然服务器没有记忆能力，在完成关联性的操作时会非常麻烦。例如登录-&gt;添加购物车-&gt;下单-&gt;结算-&gt;支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息</li></ul></li><li>明文传输双刃剑<ul><li>明文传输是在传输信息过程中，是可方便阅读的，在浏览器控制台和抓包可以直接肉眼查看，为开发者调试工作带来了便利。</li><li>但是就是因为这样，信息都暴露出来，容易泄漏，很容易被窃取。</li></ul></li><li>不安全<ul><li>通信使用明文，不加密，信息很容易被窃取。</li><li>不验证通信方的身份，很可能遭遇伪装，比如访问假的淘宝，京东</li><li>无法证明报文的完整性，所以有可能已遭篡改，比如网页植入广告</li><li>HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL/TLS 层，使得在安全上达到了极致。</li></ul></li></ul><h3 id="3-3-http1-1的性能？"><a href="#3-3-http1-1的性能？" class="headerlink" title="3.3 http1.1的性能？"></a>3.3 http1.1的性能？</h3><p>http协议是基于TCP/IPP，并且使用了请求-应答的通信模式，所以性能的关键就在这2点里。</p><ul><li>长连接<ul><li>早期http1.0性能上很大一个问题就是每发起一个请求，都要重新建立一次TCP连接（三次握手），而且是串行请求，做了无谓的TCP连接建立和断开，增加了通信的开销</li><li>为了解决上述的TCP连接问题，http1.1提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器的负载。</li><li>持久连接的特点是，只要任意一端没有明确说明断开连接则保持TCP连接状态。</li></ul></li><li>管道网络传输<ul><li>HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。</li><li>即在同一个TCP连接里，可发起多个请求，只要第一个请求发出去了，不必等其回来，就可发第二个请求出去，可以减少整体的响应时间。</li><li>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求</li><li>但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。要是 前面的回应特别慢，后面就会有许多请求排队等着。这称为「队头堵塞」。</li></ul></li><li>队头堵塞<ul><li>请求 - 应答的模式，加剧了http的性能问题。</li><li>因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，会导致后面的请求也被阻塞，客户端一直请求不到数据，这也就是对头阻塞。</li><li>总之 HTTP/1.1 的性能一般般，后续的 HTTP/2 和 HTTP/3 就是在优化 HTTP 的性能</li></ul></li></ul><h2 id="4-http和https"><a href="#4-http和https" class="headerlink" title="4.http和https"></a>4.http和https</h2><h3 id="4-1-HTTP-与-HTTPS-有哪些区别？"><a href="#4-1-HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="4.1 HTTP 与 HTTPS 有哪些区别？"></a>4.1 HTTP 与 HTTPS 有哪些区别？</h3><ul><li>http是超文本传输协议，信息是明文传输，存在安全隐患。https则解决了http不安全的问题，在TCP和HTTP网络层之间加入了SSL/TLS安全协议，使得报文能够加密传输。</li><li>http连接建立相对简单，TCP三次握手后就可进行http报文传输。而https在TCP三次握手之后，还需要进行SSL/TLS的握手过程，才可进入报文加密传输。</li><li>http的端口是80，https的端口是443</li><li>https需要向CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li></ul><h3 id="4-2-HTTPS解决了http的哪些问题？"><a href="#4-2-HTTPS解决了http的哪些问题？" class="headerlink" title="4.2 HTTPS解决了http的哪些问题？"></a>4.2 HTTPS解决了http的哪些问题？</h3><ul><li>HTTP 由于是明文传输，所以安全上存在以下三个风险：<ul><li>窃听风险，比如通信链路上可以获取通信内容，用户号容易没。</li><li>篡改风险，比如强制入垃圾广告，视觉污染，用户眼容易瞎。</li><li>冒充风险，比如冒充淘宝网站，用户钱容易没。</li></ul></li><li>HTTPS 在 HTTP 与 TCP 层之间加入了 SSL/TLS 协议。<ul><li>HTTP TCP IP MAC</li><li>HTTP SSL/TLS TCP IP MAC</li></ul></li><li>HTTP 与 HTTPS可以很好的解决了上述的风险：<ul><li>信息加密：交互信息无法被窃取</li><li>校验机制：无法篡改通信内容，篡改了就不能正常显示</li><li>身份证书：证明淘宝是真的淘宝网</li></ul></li><li>HTTPS 是如何解决上面的三个风险的？<ul><li>混合加密的方式实现信息的机密性，解决了窃听的风险</li><li>摘要算法的方式来实现完整性，它能够为数据生成独一无二的指纹，用于校验数据的完整性，解决来篡改的风险</li><li>将服务器公钥放进数字证书里，解决里冒充的风险。</li></ul></li></ul><h2 id="5-HTTP-1-1、HTTP-2、HTTP-3-演变"><a href="#5-HTTP-1-1、HTTP-2、HTTP-3-演变" class="headerlink" title="5.HTTP/1.1、HTTP/2、HTTP/3 演变"></a>5.HTTP/1.1、HTTP/2、HTTP/3 演变</h2><h3 id="5-1-HTTP-1-1-相比-HTTP-1-0-提高了什么性能？"><a href="#5-1-HTTP-1-1-相比-HTTP-1-0-提高了什么性能？" class="headerlink" title="5.1 HTTP/1.1 相比 HTTP/1.0 提高了什么性能？"></a>5.1 HTTP/1.1 相比 HTTP/1.0 提高了什么性能？</h3><ul><li>HTTP/1.1 相比 HTTP/1.0 性能上的改进：<ul><li>使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。</li><li>支持 管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间</li></ul></li><li>但 HTTP/1.1 还是有性能瓶颈：<ul><li>请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分</li><li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多</li><li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</li><li>没有请求优先级控制；</li><li>请求只能从客户端开始，服务器只能被动响应</li></ul></li></ul><h3 id="5-2-基于上面的-HTTP-1-1-的性能瓶颈，HTTP-2-做了什么优化？"><a href="#5-2-基于上面的-HTTP-1-1-的性能瓶颈，HTTP-2-做了什么优化？" class="headerlink" title="5.2 基于上面的 HTTP/1.1 的性能瓶颈，HTTP/2 做了什么优化？"></a>5.2 基于上面的 HTTP/1.1 的性能瓶颈，HTTP/2 做了什么优化？</h3><ul><li>HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。</li><li>那 HTTP/2 相比 HTTP/1.1 性能上的改进：<ul><li>头部压缩<ul><li>HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的分。</li><li>这就是所谓的 HPACK 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</li></ul></li><li>二进制格式<ul><li>HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了二进制格式。</li><li>头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧和数据帧</li><li>这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这增加了数据传输的效率。</li></ul></li><li>数据流<ul><li>HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</li><li>每个请求或回应的所有数据包，称为一个数据流（Stream）。</li><li>每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数</li><li>客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求</li></ul></li><li>多路复用<ul><li>HTTP/2 是可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。</li><li>移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，大幅度提高了连接的利用率。</li><li>举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。</li></ul></li><li>服务器推送<ul><li>HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。</li><li>举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）。</li></ul></li></ul></li></ul><h3 id="5-3-HTTP-2-有哪些缺陷？HTTP-3-做了哪些优化？"><a href="#5-3-HTTP-2-有哪些缺陷？HTTP-3-做了哪些优化？" class="headerlink" title="5.3 HTTP/2 有哪些缺陷？HTTP/3 做了哪些优化？"></a>5.3 HTTP/2 有哪些缺陷？HTTP/3 做了哪些优化？</h3><ul><li>HTTP/2 主要的问题在于：多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。</li><li>所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。<ul><li>HTTP/1.1 中的管道（ pipeline）传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了</li><li>HTTP/2 多请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。</li></ul></li><li>这都是基于 TCP 传输层的问题，所以 HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！<br><img src="/ZJY.github.io/images/http.jpg" alt="image"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookie、Session、Token、JWT的区别</title>
      <link href="/ZJY.github.io/2021/02/04/Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/ZJY.github.io/2021/02/04/Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="Cookie、Session、Token、JWT"><a href="#Cookie、Session、Token、JWT" class="headerlink" title="Cookie、Session、Token、JWT"></a>Cookie、Session、Token、JWT</h2><h3 id="什么是认证（Authentication）"><a href="#什么是认证（Authentication）" class="headerlink" title="什么是认证（Authentication）?"></a>什么是认证（Authentication）?</h3><p>认证就是验证当前用户的身份，证明你是你自己。<br>认证方式：</p><ul><li>用户名密码登录</li><li>手机号发送验证码</li><li>邮箱发送链接，点击验证登录</li></ul><h3 id="什么是授权（Authorization）"><a href="#什么是授权（Authorization）" class="headerlink" title="什么是授权（Authorization）?"></a>什么是授权（Authorization）?</h3><p>用户授予第三方应用访问用户某些资源的权限</p><ul><li>安装app时，app询问是否允许授予权限（位置，存储等）</li><li>访问微信小程序，授权登录，询问是否允许授予权限（昵称，头像，地区等信息）</li></ul><p>实现授权的方式：cookie、session、token、OAuth</p><h3 id="什么是凭证（Credentials）"><a href="#什么是凭证（Credentials）" class="headerlink" title="什么是凭证（Credentials）?"></a>什么是凭证（Credentials）?</h3><ul><li>实现认证和授权的前提</li><li>需要一种媒介（证书）来标记访问者的身份</li><li>比如居民身份证</li><li>比如bilibili，有游客模式和登录模式，游客模式可以正常浏览观看，但是若要点赞，收藏，则需要用户登录。用户登录后服务器会给该用户使用的浏览器一个令牌token，这个令牌来表明你的身份，每次浏览器发送请求时都会带上这个令牌。</li></ul><h3 id="什么是Cookie？"><a href="#什么是Cookie？" class="headerlink" title="什么是Cookie？"></a>什么是Cookie？</h3><ul><li><p>HTTP是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。</p></li><li><p>cookie存储在客户端：cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器发送请求时被携带并发送到服务器上。</p></li><li><p>cookie是不可跨域的：每个cookie都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠domain）</p></li><li><p>cookie重要的属性：</p><ul><li><p>name=value健值对，设置cookie的名称及相应的值，都必须是字符串类型。<br>  如果值为unicode字符，需要转为字符编码<br>  如果值为二进制，需要转为base64编码</p></li><li><p>domain指定cookie所属域名，默认是当前域名，path指定cookie在哪个路径下生效，默认是’/‘。如果设置为/abc，则只有/abc下的路由可以访问到该cookie，如/abc/read。</p></li><li><p>maxAgeCookie：失效的时间，单位秒，如果为整数，则该cookie在maxAge秒后失效。如果为负数，则该cookie为临时cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该cookie。如果为0，表示删除该cookie。默认为-1。比expires好用。一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除。</p></li><li><p>expires：过期时间，在设置的某个时间点后该cookie就会失效。</p></li><li><p>secure：该cookie是否仅被使用安全协议传输。安全协议有HTTPS，SSL等。在网络上传输数据先将数据进行加密。默认是false，当secure为true时，cookie在http中是无效的，在https才有效。</p></li><li><p>httpOnly：如果给某个cookie设置来httpOnly属性，则无法通过js脚本读取到该cookie的信息，但是还是能够通过Application中手动修改cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全</p></li></ul></li></ul><h3 id="什么是Session？"><a href="#什么是Session？" class="headerlink" title="什么是Session？"></a>什么是Session？</h3><ul><li><p>session是另一种记录服务器和客户端会话状态的机制</p></li><li><p>session是基于cookie实现的，session存储在服务端，sessionId会被存储在客户端的cookie中</p></li><li><p>session认证流程：</p><ul><li><p>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的session</p></li><li><p>请求返回将此session的唯一标识sessionId返回给浏览器</p></li><li><p>浏览器接收到服务器返回的sessionId后会将该信息存储到cookie中，同时cookie将记录此sessionId属于哪个域名</p></li><li><p>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在cookie信息，如果存在自动将cookie信息也发送给服务器，服务端会从cookie中获取sessionId，再根据sessionId查找对于session信息，如果没有找到说明用户没有登录或者登录失效，如果找到session证明用户已经登录可执行后续操作。</p></li></ul></li><li><p>sessionId是连接cookie和session的一道桥梁，大部分系统也是根据此原理来验证用户登录状态</p></li></ul><h3 id="cookie和session的区别？"><a href="#cookie和session的区别？" class="headerlink" title="cookie和session的区别？"></a>cookie和session的区别？</h3><ul><li>安全性：session比cookie安全，session是存储在服务端的，cookie是存储在客户端的</li><li>存取值的类型不同： cookie只支持字符串数据，想要设置其他类型的数据，需要将其转换为字符串，session可以存任意数据类型。</li><li>有效期不同：cookie可设置为长时间保持，比如我们经常使用的默认登录功能。session一般失效时间较短，客户端关闭或者session超时都会失效。</li><li>存储大小不同：单个cookie存储数据不能超过4k，session可存储数据远高于cookie，但是当访问量过多，会占用过多的服务器资源。</li></ul><h3 id="什么是token（令牌）？"><a href="#什么是token（令牌）？" class="headerlink" title="什么是token（令牌）？"></a>什么是token（令牌）？</h3><ul><li><p>Access Token</p><ul><li><p>访问资源接口（API）时所需要的资源凭证</p></li><li><p>简单token的组成： uid(用户唯一身份标识)、time(当前时间戳)、sign（签名，token的前几位以哈希算法压缩为一定长度的十六进制字符串）</p></li><li><p>特点： 服务端无状态化、可扩展行好、支持移动端设备、安全、支持跨程序调用</p></li><li><p>token的身份验证流程：</p><ul><li>浏览器发送用户名密码等信息给服务器，服务器将登录凭证做成数字签名，加密之后得到字符串作为token</li><li>服务器将token返回给浏览器，拿到token后，将token保存到本地</li><li>请求时携带token给服务端</li><li>服务器拿到token串，做解密和签名认证，判断其有效性，将数据返回给浏览器</li></ul></li><li><p>每一次请求都需要携带token，需要把token放到http的header里</p></li><li><p>基于token的用户认证是一种服务端无状态的方式，服务端不用存放token数据。用解析token的计算时间来换取session的存储空间，从而减轻服务器的压力。</p></li><li><p>token完全由应用管理，所以它可以避开同源策略</p></li></ul></li><li><p>Refresh Token</p><ul><li>refresh token是一种专用于刷新access token的token。如果没有refresh token也可以刷新access token，但每次刷新都需要用户输入登录名和密码，会很麻烦。有了refresh token可以减少这个麻烦。客户端直接用 refresh token 去更新 access token，无需用户进行额外的操作。</li><li>Access Token 的有效期比较短，当 Acesss Token 由于过期而失效时，使用 Refresh Token 就可以获取到新的 Token，如果 Refresh Token 也失效了，用户就只能重新登录了。</li><li>Refresh Token 及过期时间是存储在服务器的数据库中，只有在申请新的 Acesss Token 时才会验证，不会对业务接口响应时间造成影响，也不需要向 Session 一样一直保持在内存中以应对大量的请求。</li></ul></li></ul><h3 id="token和session的区别？"><a href="#token和session的区别？" class="headerlink" title="token和session的区别？"></a>token和session的区别？</h3><ul><li><p>session是一种记录客户端和服务器会话状态的机制，使服务端有状态化，可以记录会话信息。而token是令牌，访问资源接口（API）时所需要的资源凭证。token使服务端无状态化，不会存储会话信息。</p></li><li><p>session和token并不矛盾，作为身份认证token安全性比session好，因为每一个请求都有签名还能防止监听以及重放攻击，而session就必须依赖链路层来保障通讯安全了。如果你需要实现现有状态的会话，仍然可以增加session来在服务端保存一些状态。</p></li><li><p>所谓session认证只是简单的把user信息存储到session里，因为sessionId的不可预测性，暂且认为是安全的。而token，如果指的是OAuth token或类似机制的话，提供的是认证和授权。认证是真的用户，授权是针对app。</p></li></ul><h3 id="什么是JWT？"><a href="#什么是JWT？" class="headerlink" title="什么是JWT？"></a>什么是JWT？</h3><ul><li><p>JSON Web Token（简称JWT）是目前最流行的跨域认证解决方案。</p></li><li><p>是一种认证授权机制</p></li><li><p>JWT是为了在网络应用环境间传递声明而执行的一种基于JSON的开发标准。jwt的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。</p></li><li><p>可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。</p></li></ul><h3 id="JWT的原理"><a href="#JWT的原理" class="headerlink" title="JWT的原理"></a>JWT的原理</h3><ul><li>JWT认证流程：<ul><li>用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个JWT</li><li>客户端将token保存到本地（通常使用localStorage，也可以使用cookie）</li><li>当用户希望访问一个受保护的路由或者资源的时候，需要请求头的Authorization字段中使用bearer模式添加JWT，<br>  Authorization: bearer <token></li><li>服务端的保护路由将会检查请求头Authorization中的JWT信息，如果合法，则允许用户的行为。</li><li>因为JWT是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要。</li><li>因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</li><li>因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制</li></ul></li></ul><h3 id="JWT的使用方式"><a href="#JWT的使用方式" class="headerlink" title="JWT的使用方式"></a>JWT的使用方式</h3><p>客户端收到服务端返回的jwt，可以存储到cookie里面，也可以储存到localStorage里面。</p><ul><li>方式一<ul><li>当用户希望访问一个受保护的路由或者资源的时候，可以把它放在cookie里面自动发送，但是这样不能跨域，所以更好的做法是放在http请求头信息的Authorization字段里，使用bearer模式添加jwt。<br>  get: /user/page<br>  host: <a href="http://api.example.com/">http://api.example.com</a><br>  Authorization: Bearer<token></li><li>用户的状态不会保存在服务端，这是一种无状态的认证机制。</li><li>服务端的保护路由会检查请求头Authorization中的JWT信息，如果合法，则允许用户的行为</li><li>由于JWT是自包含的，因此减少了需要查询数据库的需要</li><li>JWT 的这些特性使得我们可以完全依赖其无状态的特性提供数据 API 服务，甚至是创建一个下载流服务</li><li>因为JWT并不使用cookie，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</li></ul></li><li>方式二<ul><li>跨域的时候，可以把 JWT 放在 POST 请求的数据体里。</li></ul></li><li>方式三<ul><li>通过 URL 传输：<a href="http://www.example.com/user?token=xxx">http://www.example.com/user?token=xxx</a></li></ul></li></ul><h3 id="token和JWT的区别？"><a href="#token和JWT的区别？" class="headerlink" title="token和JWT的区别？"></a>token和JWT的区别？</h3><ul><li>相同：<ul><li>都是访问资源的令牌</li><li>都可以记录用户的信息</li><li>都是使服务端无状态化</li><li>都是只有验证成功后，客户端才能访问服务端上受保护的资源</li></ul></li><li>区别：<ul><li>token：服务端验证客户端发送过来的token时，还需要查询数据库获取用户信息，然后验证token是否有效</li><li>JWT：将token和payload加密后存储于客户端，服务端只需要使用密钥进行校验（校验也是JWT自己实现的）即可，不需要查询或者减少查询数据库，因为JWT自包含了用户信息和加密的数据。</li></ul></li></ul><h3 id="常见的前后的鉴权方式"><a href="#常见的前后的鉴权方式" class="headerlink" title="常见的前后的鉴权方式"></a>常见的前后的鉴权方式</h3><ul><li>session/cookie</li><li>token验证（包括JWT，SSO）</li><li>OAuth2.0（开发授权）</li></ul><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li><p>使用cookie时需要考虑的问题</p><ul><li>存储在客户端容易被客户端篡改，使用前需要验证合法性</li><li>不能存户敏感数据</li><li>使用httpOnly在一定程度上可以提高安全性</li><li>尽量减少cookie的体积，能存储的数据不能超过4k</li><li>设置正确的domain和path，减少数据传输</li><li>cookie无法跨域</li><li>一个浏览器针对一个网站最多存20个cookie，浏览器一般只允许存放300个cookie</li><li>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token</li></ul></li><li><p>使用session时需要考虑的问题</p><ul><li>将 session 存储在服务器里面，当用户同时在线量比较多时，这些 session 会占据较多的内存，需要在服务端定期的去清理过期的 session</li><li>当网站采用集群部署的时候，会遇到多台 web 服务器之间如何做 session 共享的问题。因为 session 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 session 的服务器，那么该服务器就无法拿到之前已经放入到 session 中的登录凭证之类的信息了</li><li>当多个应用要共享 session 时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好 cookie 跨域的处理。</li><li>sessionId 是存储在 cookie 中的，假如浏览器禁止 cookie 或不支持 cookie 怎么办？ 一般会把 sessionId 跟在 url 参数后面即重写 url，所以 session 不一定非得需要靠 cookie 实现</li></ul></li><li><p>使用 token 时需要考虑的问题</p><ul><li>如果你认为用数据库来存储 token 会导致查询时间太长，可以选择放在内存当中。比如 redis 很适合你对 token 查询的需求</li><li>token 完全由应用管理，所以它可以避开同源策略</li><li>token 可以避免 CSRF 攻击(因为不需要 cookie 了)</li></ul></li><li><p>使用 JWT 时需要考虑的问题</p><ul><li>因为 JWT 并不依赖 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</li><li>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</li><li>JWT 不加密的情况下，不能将秘密数据写入 JWT。</li><li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</li><li>JWT 最大的优势是服务器不再需要存储 Session，使得服务器认证鉴权业务可以方便扩展。但这也是 JWT 最大的缺点：由于服务器不需要存储 Session 状态，因此使用过程中无法废弃某个 Token 或者更改 Token 的权限。也就是说一旦 JWT 签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。</li><li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证</li><li>JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态</li><li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输</li></ul></li></ul><h3 id="只要关闭浏览器-，session-真的就消失了？"><a href="#只要关闭浏览器-，session-真的就消失了？" class="headerlink" title="只要关闭浏览器 ，session 真的就消失了？"></a>只要关闭浏览器 ，session 真的就消失了？</h3><p>不对。对 session 来说，除非程序通知服务器删除一个 session，否则服务器会一直保留，程序一般都是在用户做 log off 的时候发个指令去删除 session。然而浏览器从来不会主动在关闭之前通知服务器它将要关闭，因此服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分 session 机制都使用会话 cookie 来保存 session id，而关闭浏览器后这个 session id 就消失了，再次连接服务器时也就无法找到原来的 session。如果服务器设置的 cookie 被保存在硬盘上，或者使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 session id 发送给服务器，则再次打开浏览器仍然能够打开原来的 session。恰恰是由于关闭浏览器不会导致 session 被删除，迫使服务器为 session 设置了一个失效时间，当距离客户端上一次使用 session 的时间超过这个失效时间时，服务器就认为客户端已经停止了活动，才会把 session 删除以节省存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器是如何运作的</title>
      <link href="/ZJY.github.io/2021/01/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84/"/>
      <url>/ZJY.github.io/2021/01/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器是如何运作的"><a href="#浏览器是如何运作的" class="headerlink" title="浏览器是如何运作的"></a>浏览器是如何运作的</h2><h3 id="1-浏览器发展史："><a href="#1-浏览器发展史：" class="headerlink" title="1.浏览器发展史："></a>1.浏览器发展史：</h3><ul><li>1991年Berners Lee建立了第一代网络浏览器WorldWideWeb,只支持显示文本图片 </li><li>1993年Mosaic问世，同时支持显示文本和图像</li><li>1994年网景浏览器发布 ，只能显示简单的静态html，没有js，css。同年出现Opera。</li><li>1995年微软发布IE1.0，IE2.0，自此第一次浏览器大战正式打响</li><li>1996年微软发布的IE3.0和window系统集成一起，网景份额此时占86%</li><li>1998年网景开源了firefox火狐来迎击IE</li><li>1999年IE市场份额占据99%</li><li>2003年苹果发布safari浏览器，被包含在所有苹果操作系统中 </li><li>2004年网景发布来firefox1.0版本，拉开第二次浏览器大战</li><li>2005年苹果开源了safari浏览器内核webkit </li><li>2008年谷歌以苹果开源项目webkit 创建了新的项目chromium， 在该项目的基础上谷歌发布了自己的浏览器产品Chrome，</li><li>2015年微软放弃了IE，推出了以webkit内核的Edge浏览器</li><li>2020年chrome已占据60%多的市场份额</li></ul><h3 id="2-浏览器结构图："><a href="#2-浏览器结构图：" class="headerlink" title="2.浏览器结构图："></a>2.浏览器结构图：</h3><ul><li>用户界面-用户界面用来展示除标签页窗口以外的其他用户界面内容</li><li>浏览器引擎- </li><li>渲染引擎-渲染引擎负责渲染用户请求的页面内容</li></ul><p>浏览器是运行在操作系统上的一个应用程序 ，每个应用程序必须至少启动一个进程来执行其功能，每个程序往往需要运行很多任务，进程就会创建很多线程去帮助它执行一些小的任务。</p><p>当我们启动一个应用程序时，就会创建一个进程来执行任务代码，同时为该进程分配内存空间。该应用程序的状态都保存在内存空间里，当应用关闭时，该内存就会被回收。<br>进程可以启动更多的进程来执行任务，由于每个进程分配的内存空间是独立的，如果两个进程间需要传递数据，则需要通过进程间通信管道IPC来传递。很多引用程序都是多进程的结构，避免某一个进程卡死，由于进程间相互独立，这样不会影响整个应用程序。<br>进程可以将任务分为更多个细小的任务，然后通过创建多个线程并行执行不同的任务，同一进程下的线程之间是可以通信共享数据的。</p><h3 id="3-浏览器是一个多进程的结构："><a href="#3-浏览器是一个多进程的结构：" class="headerlink" title="3.浏览器是一个多进程的结构："></a>3.浏览器是一个多进程的结构：</h3><ul><li>浏览器进程<br>  浏览器进程负责控制除标签页外的用户界面，包括地址栏，书签，前进，后退按钮以及负责与浏览器其他进程协调工作</li><li>缓存进程</li><li>网络进程<br>  负责发起接受网络请求</li><li>GPU进程<br>  负责整个浏览器界面的渲染</li><li>插件进程<br>  负责网站使用的所有插件，例如flash,插件并不是指插件安装的扩展</li><li>渲染器进程<br>  用来控制显示tab标签内的所有内容<br>  浏览器默认情况下会为每个标签页都创建一个进程（和启动浏览器选择的进程模型有关）</li></ul><h3 id="4-当你在浏览器输入地址时，浏览器内部会发生什么？"><a href="#4-当你在浏览器输入地址时，浏览器内部会发生什么？" class="headerlink" title="4.当你在浏览器输入地址时，浏览器内部会发生什么？"></a>4.当你在浏览器输入地址时，浏览器内部会发生什么？</h3><p>当你在浏览器输入内容时，浏览器进程的UI进程会捕捉你的输入内容，如果访问的是网址，则UI进程会启动一个网络线程来请求DNS进行域名解析，接着开始连接服务器来获取数据。如果输入的不是网址，而是关键词，浏览器就会使用默认配置的搜索引擎来查询。</p><p>当网络线程获取到数据后会通过SafeBrowsing来检查站点是否是恶意站点，如果是，会提示个警告页面阻止你继续访问，也可以强行继续访问。SafeBrowsing是谷歌内部的一套站点安全系统，通过检测该站点的数据判断是否安全。</p><p>当返回数据并安全校验通过时，网络线程就会通知UI线程（浏览器进程）准备好了，然后UI线程就会创建一个渲染器进程来渲染页面，浏览器进程就会通过进程通信管道IPC来把数据传递给渲染器进程，正式进入渲染流程。渲染器接受到的数据也就是html，渲染器的核心任务就是把html,js,css,image等资源渲染成用户可以交互的web页面。</p><p>渲染器进程的主线程将html进行解析，构造DOM数据结构。<br>html首先经过tokeniser标记化，通过词法分析将输入的html内容解析成多个标记，根据识别后的标记进行DOM树构造,在DOM树构造偶成中会创建document对象，然后以document为根节点的DOM树不断进行修改向其中添加各种元素。</p><pre><code>html-&gt;tokeniser-&gt;tree construction-&gt;DOMdocument-&gt;body-&gt;p-&gt;text</code></pre><p>html的代码中往往会引入一些额外的资源，比如图片、css、js脚本等，图片和css资源需要经过网络下载或者从缓存中加载，这些资源不回阻塞html的解析，因为它们不会影响dom的生成。但是html解析遇到script标签，就会停止html的解析流程，转而去加载解析并且执行js，可以使用async或defer来异步加载执行js。在html解析完成后会获得一个DOM 树，但是还不知道dom树上每个节点长什么样子。 </p><p>主线程需要解析css来确定每个dom节点的计算样式。</p><p>在知道DOM节点和每个节点的样式后，接下来需要直到每个节点放置的位置，也就是节点的坐标以及该节点需要占据的区域，这个阶段称为layout布局。</p><p>主线程通过遍历dom和计算好的样式来生成layout tree，layout tree上的每个节点都记录来x,y坐标以及边框尺寸。layout tree是和最后显示的节点一一对应的。</p><p>现在知道节点的形状大小，还需要知道以什么样的顺序来绘制，z-index属性会影响节点绘制的层级关系。按照dom层级顺序绘制节点是不对的，为了在屏幕上展示正确的层级，主线程遍历Layout tree 创建了一个绘制记录表（paint record）,该表记录了绘制的顺序，这个阶段被称为绘制（paint）。</p><p>现在知道了节点绘制的顺序，到了把这些信息转化称像素点显示在屏幕上的时候了。这种行为被称为栅格化。<br>chrome早期栅格化只栅格用户可视区域界面，随着滚动再继续栅格，会带来延迟。现在使用另一种更复杂的栅格化，叫做合成（Composting）,合成是一种将页面的各个部分分为多个图层，分别对其栅格化，并在合成器线程中单独进行合成页面的技术。<br>简单来说就是页面所有元素按照某种规则进行分图层，然后把图层都栅格化好了，然后只需把可视区域的内容组合成一帧展示给用户即可。</p><p>主线程遍历layout tree生成layer tree(图层),当layer tree生成完毕和绘制顺序确定后，主线程将这些信息传递给合成器线程，<br>合成器线程将每个图层栅格化，由于一层可能像页面的整个长度一样大，因此合成器线程将他们切分为许多图块，然后将每个图块发送给栅格化线程（Raster thread）。</p><p>栅格化线程栅格每个图块，并将它们存储在GPU内存中，当栅格化完成后，合成器线程将收集称为“draw quads”的图块信息，这些信息记录了图块在内存中的位置和在页面的哪个位置绘制图块的信息。根据这些信息合成器线程合成生成了一个合成器帧（Compositor Frame）,然后这个合成器帧通过进程间通信管道IPC传递给浏览器进程，接着浏览器进程将合成器帧传送到GPU，然后GPU渲染展示到屏幕上。</p><p>页面上终于可以看到内容，当页面发生变化，比如滚动页面，则会生成一个新的合成器帧，新的帧再传送到GPU，再渲染到屏幕上。</p><h3 id="5-总结："><a href="#5-总结：" class="headerlink" title="5.总结："></a>5.总结：</h3><ul><li>浏览器进程中的网络线程请求获取到html数据后，通过IPC将数据传给渲染器进程的主线程</li><li>主线程将html解析构造DOM树</li><li>然后进行样式计算</li><li>根据DOM树和生成好的样式成功layout tree</li><li>通过遍历layout tree生成绘制顺序表paint</li><li>接着遍历layout tree生成layer tree(图层)</li><li>然后主线程将layer tree和绘制顺序信息一起传递给合成器线程</li><li>合成器线程按照规则进行分图层，并把更小的tiles（图块）传递给栅格化线程进程栅格化</li><li>栅格化完成后，合成器线程将收到栅格化线程传递过来的“draw quads”的图块信息</li><li>根据这些信息合成器线程合成生成了一个合成器帧（Compositor Frame）</li><li>然后这个合成器帧通过进程间通信管道IPC传递给浏览器进程</li><li>浏览器进程再传送到GPU渲染，然后就展示到屏幕上了。</li></ul><p>主线程-&gt;DOM-&gt;style-&gt;layout tree-&gt;paint-&gt;layer（这些在主线程执行）<br>-&gt;合成器线程-&gt;tiles（图块）<br>-&gt;栅格化线程-&gt;“draw quads”的图块信息-&gt;传递给合成器线程-&gt;合成器帧-&gt;浏览器进程-&gt;GPU-&gt;渲染屏幕</p><p>当我们改变元素的尺寸位置时，会重新计算样式,layout,paint以及后面所有流程，这种行为称为重排reflow</p><p>当我们改变元素颜色属性时，不会出发layout layer 布局，但会触发样式计算，这种行为称为重绘repaint</p><p>重排和重绘都会占用主线程，js也在主线程运行，如果他们都在主线程运行，就会出现抢占执行时间的问题，如果写了一个不断导致重排重绘的动画，浏览器则需要在每一帧都运行样式计算布局和绘制的操作，页面以每秒60帧频率刷新时才不会让用户感觉到页面卡顿，绘制动画时，如果js运行时间过长，没有及时归还主线程，就会导致页面绘制卡顿。</p><p>可以通过requestAnimationFrame()和transform解决这个问题。<br>合成器线程和栅格化线程不运行在主线程，不会受到主线程中js执行的影响，css中transform动画不需要样式计算布局绘制，不运行在主线程。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>互联网是如何运行的</title>
      <link href="/ZJY.github.io/2021/01/26/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84/"/>
      <url>/ZJY.github.io/2021/01/26/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h2 id="互联网是如何运行的"><a href="#互联网是如何运行的" class="headerlink" title="互联网是如何运行的"></a>互联网是如何运行的</h2><p>当你的电脑联入互联网之后，会得到一个编号地址，这个地址称为Internet Protocal Address,也就是IP地址。<br>bilibili的服务器也接入互联网，它也将分配一个IP地址，常说的访问某某网站，就是访问这个网站的服务器。<br>如果你的电脑想通过访问index.html来获取b站首页内容， 此时称电脑为客户端，bilibili为服务端，这种形式就是客户端服务端模型。</p><p>客户端更贴近用户 ，是面向用户的应用程序，例如web浏览器，电子邮件客户端，手机app。<br>服务端是在远程计算机上运行的引用程序，客户端可以在需要时，通过互联网与服务端进行通信。</p><p>你的电脑发送给bilibili服务器消息，要获取index.html的内容，消息将会被转化为电子信号，通过电缆发送给bilibili服务器，在服务器端又将电子信号转换为计算机可以使用的文本数据。<br>以上通过Tcp/Ip协议族来实现。</p><p>协议：协议是一组规则，用于指定计算机应如何通过网络来互相通信。</p><h3 id="1-Tcp-Ip协议族共分为4层："><a href="#1-Tcp-Ip协议族共分为4层：" class="headerlink" title="1.Tcp/Ip协议族共分为4层："></a>1.Tcp/Ip协议族共分为4层：</h3><ul><li>应用层：提供特定于应用程序的协议（HTTP，FTP，IMAP）</li><li>Tcp传输控制层：发送数据包到计算机上使用特定端口号的应用程序</li><li>IP网络层：使用IP地址将数据包发送到特定的计算机</li><li>链路层：将二进制数据包与网络信号相互转换</li></ul><p>网络协议通过分层来明确每一层的职责，通过定义明确的接口来协同工作</p><p>1.在当前的例子中，使用应用层的HTTP协议请求获取html文本，这时需要发送一个请求消息，消息在发送前会被分解为许多片段，称为数据包。</p><p>2.通过应用层进入传输控制层后，每个数据包都会被分配一个端口号，端口号用来确定计算机的哪一个应用程序要接受并使用该数据包。<br>进入IP网络层后，每个数据包将会赋予目标计算机的IP地址。</p><p>3.有了IP地址和端口号之后，链路层会将数据包的文本数据转换为电子信号。然后通过电缆传输，在电缆中的另一端的路由器检查每个数据包中的地址，并确定发送到何处，最终数据包到达服务器。数据包到达服务器后，从Tcp/Ip协议族的底部数据链路层开始向上运行， 当数据包向上通过协议族时，客户端添加的所有路由数据，例如Ip地址和端口号都将从数据包剥离出来。当数据到达栈顶时，数据包已恢复成最初始的形式。</p><p>4.通过端口号可以将数据传递给当前服务器监听该端口的应用程序。应用程序根据当前请求数据作出反应。<br>比如现在想获取index.html，服务器会将路径index.html的数据通过刚才方式返回给你的电脑。也就是客户端，这样就可以看到b站首页内容。 这里完成了客户端与服务器在互联网的一次数据交互。</p><ul><li>应用层： 数据包</li><li>传输控制层： 数据  源端口  目标端口</li><li>网络层： 数据  源端口  目标端口  源IP 目标IP</li><li>数据链路层： 数据  源端口  目标端口  源IP 目标IP</li></ul><h3 id="Tcp是一种面向连接的可靠字节流服务。"><a href="#Tcp是一种面向连接的可靠字节流服务。" class="headerlink" title="Tcp是一种面向连接的可靠字节流服务。"></a>Tcp是一种面向连接的可靠字节流服务。</h3><p>Tcp必须经过3次握手建立连接后才可以交换数据，每个收到的数据包都会向发送方发送ack确认，以保证发送成功</p><h3 id="IP是-不可靠的无连接协议"><a href="#IP是-不可靠的无连接协议" class="headerlink" title="IP是 不可靠的无连接协议"></a>IP是 不可靠的无连接协议</h3><p>它并不关心数据包是否到达目的地，也不关心连接和端口号，它的工作是发送数据包并将其路由到目标计算机，其中每个数据包都是独立的不相互依赖的，所以有可能乱序到达目的地。</p><p>如何保证数据包到达和顺序正确？交给TCP。<br>当数据包过大时，在IP网络层会进行分包，由于每个数据包在物理链路层走的物理链路不同，传输速度不同，导致数据包没有按顺序到达目的地。但是TCP会根据数据包携带的序列号来进行排序重组，并且发送方在特定时间内没有接收到接收方发来的ack确认时，则发送方会重新发送该数据包。</p><p>IP是一种网络协议，IP地址是一串数字。</p><h3 id="IP有两种协议："><a href="#IP有两种协议：" class="headerlink" title="IP有两种协议："></a>IP有两种协议：</h3><ul><li>IPv4 Internet Protocol version4<br>  采用32位地址，即4字节，因此地址空间只有2<sup>32</sup>个，约40亿个，专用网络1800万个，多播地址2.7亿个， </li><li>IPv6 Internat Protocol version6<br>  采用128位地址，2<sup>128</sup>个</li></ul><h3 id="调制解调器（也叫猫）和路由器的区别："><a href="#调制解调器（也叫猫）和路由器的区别：" class="headerlink" title="调制解调器（也叫猫）和路由器的区别："></a>调制解调器（也叫猫）和路由器的区别：</h3><ul><li>猫用于网络间不同介质网络信号转接，比如把ADSL，光纤，有线通等的网络信号转成标准的电脑网络信号。</li><li>路由器用于网络信号的再分配，简单地说就是让一根网线可以连接更多的电脑。</li><li>家里有宽带就必须有猫，有多台电脑上网就必须有路由器，假如电脑很多，超过路由器的接口就需要交换机扩展接口。</li></ul><p>1.电脑通过调制解调器modem，也就是常说的“猫”，将计算机的数字信号翻译成可沿普通电话线传输的模拟信号后，在公共电话网络进行传输，公共电话网络通过连接Internet Service Provider，互联网服务提供商ISP，来接入互联网。生活中常见的电信，移动，联通都是ISP。</p><p>2.数据包经过电话网络和ISP后，它们将路由到ISP的主干网络。互联网骨干网由许多相互连接的大型网络组成，这些大型网络被称为网络服务提供商，简称NSP。NSP是为ISP提供网络主干服务的公司。ISP可以从NSP那里批量购入带宽，为客户提供网络接入服务。<br>NSP网络通过网络访问点NAP相连，来交换数据包流量，每个NSP都必须连接到至少三个网络访问点NAP。</p><p>3.计算机有个特殊的计算器-路由器，路由器中有个路由表，记录来其子网络的所有IP地址。当数据包到达路由器，路由器检查路由表上是否有目的地的IP地址，如果有则直接发送给那个网络。否则就向上层发送数据，在更高的层级去寻找拥有该iP的路由器。如果依然没有找到，继续向上路由，直到到达NSP主干网为止，连接到NSP主干网的路由器拥有最大的路由表，通过这张表可以将数据包路由到正确的骨干网。然后开始向下传播，直到找到目的地为止。你的电脑就是这样访问bilibili服务器的。</p><p>4.通过IP地址来访问bilibili服务器，ip地址可能会改变，通过域名来访问可以解决Ip地址改变问题。<br>浏览器通过DNS来知道哪个域名访问哪个IP地址。</p><p>Domian names service,简称DNS，是一个分布式数据库，记录来域名和其IP地址的对应关系。<br>在浏览器输入网址时，浏览器首先连接DNS服务器，获取到该域名的IP地址后，浏览器在连接访问该IP的服务器。<br>有了DNS后，之后IP有了变化，重新绑定下域名和新IP地址就可以了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试基础2</title>
      <link href="/ZJY.github.io/2021/01/22/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%802/"/>
      <url>/ZJY.github.io/2021/01/22/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%802/</url>
      
        <content type="html"><![CDATA[<h2 id="2-HTML"><a href="#2-HTML" class="headerlink" title="2. HTML"></a>2. HTML</h2><p><strong>为什么利用多个域名来存储网站资源会更有效 ？</strong></p><p><a href="https://www.jianshu.com/p/4cf3b6d6b50a">利用多个域名来存储网站资源</a></p><ul><li>确保用户在不同地区能用最快的速度打开网站，其中某个域名崩溃用户也能通过其他域名访问网站。</li><li>CDN 缓存更方便。简单来说，CDN 主要用来使用户就近获取资源。</li><li>突破浏览器并发限制。同一时间针对同一域名下的请求有一定数量限制，超过限制数目的请求会被阻塞。大多数浏览器的并发数量都控制在6以内。有些资源的请求时间很长，因而会阻塞其他资源的请求。因此，对于一些静态资源，如果放到不同的域名下面就能实现与其他资源的并发请求。</li><li>Cookieless, 节省带宽，尤其是上行带宽 一般比下行要慢。</li><li>对于 UGC 的内容和主站隔离，防止不必要的安全问题。</li><li>数据做了划分，甚至切到了不同的物理集群，通过子域名来分流比较省事.  这个可能被用的不多。</li></ul><hr><p><strong>window 常用属性与方法有哪些 ？</strong></p><p>window 对象的常用属性</p><ul><li>window.self 返回当前窗口的引用</li><li>window.parent   返回当前窗体的父窗体对象</li><li>window.top 返回当前窗体最顶层的父窗体的引用</li><li>window.outerwidth       返回当前窗口的外部宽</li><li>window.outerheight  返回当前窗口的外部高</li><li>window.innerwidth       返回当前窗口的可显示区域宽</li><li>window.innerheight  返回当前窗口的可显示区域高<br> <br>提示：通过直接在 Chrome 控制台中输入 console.log(window) 可以查看到其所有的被当前浏览器支持的属性及值。</li></ul><p>window 对象的常用方法</p><ul><li>window.prompt()   弹出一个输入提示框，若用户点击了“取消”则返回 null</li><li>window.alert()    弹出一个警告框</li><li>window.confirm()  弹出一个确认框</li><li>window.close()  关闭当前浏览器窗口。 有些浏览器对此方法有限制。</li><li>window.open(uri, [name], [features])  打开一个浏览器窗口，显示指定的网页。name 属性值可以是“_blank”、“_self”、“_parent”、“_top”、任意指定的一个窗口名。</li><li>window.blur( )    指定当前窗口失去焦点</li><li>window.focus( ) 指定当前窗口获得焦点</li><li>window.showModalDialog(uri, [dataFromParent])  打开一个“模态窗口”（打开的子窗口只要不关闭，其父窗口即无法获得焦点；且父子窗口间可以传递数据）</li></ul><hr><p><strong>document 常用属性与方法有哪些 ？</strong></p><p>document 常见的属性</p><ul><li>body 提供对 <code>&lt;body&gt;</code> 元素的直接访问。对于定义了框架集的文档，该属性引用最外层的 <code>&lt;frameset&gt;</code>。</li><li>cookie 设置或返回与当前文档有关的所有 cookie。</li><li>domain 返回当前文档的域名。</li><li>lastModified 返回文档被最后修改的日期和时间。</li><li>referrer 返回载入当前文档的文档的 URL。</li><li>title 返回当前文档的标题。</li><li>URL 返回当前文档的 URL。</li></ul><p>document常见的方法</p><ul><li>write()：动态向页面写入内容</li><li>createElement(Tag)：创建一个 HTML 标签对象</li><li>getElementById(ID)：获得指定 id 的对象</li><li>getElementsByName(Name)：获得之前 Name 的对象</li><li>body.appendChild(oTag)：向 HTML 中插入元素对象</li></ul><hr><p><strong>简述一下 src 与 href 的区别</strong></p><ul><li>href 是指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。</li><li>src 是指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；</li><li>在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片和 frame 等元素。<br>当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将 js 脚本放在底部而不是头部。</li></ul><hr><p><strong>写一个 div + css 布局，左边图片，右边文字，文字环绕图片，外面容器固定宽度，文字不固定。</strong></p><p>直接就一个 img，它 float：left，加文字加 p 标签就好了。</p><hr><p><strong>html 中 title 属性和 alt 属性的区别 ？</strong></p><ol><li>alt</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;#&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;alt 信息&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>当图片不输出信息的时候，会显示 alt 信息， 鼠标放上去没有信息。<br>当图片正常读取，不会出现 alt 信息。</p><ol><li>title</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;#&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;alt 信息&quot;</span> <span class="attr">title</span>=<span class="string">&quot;title 信息&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>当图片不输出信息的时候，会显示 alt 信息，鼠标放上去会出现 title 信息。<br>当图片正常输出的时候，不会出现 alt 信息，鼠标放上去会出现 title 信息。</p><hr><p><strong>讲述你对 reflow 和 repaint 的理解。</strong></p><p>repaint 就是重绘，reflow 就是回流。</p><p>严重性： 在性能优先的前提下，性能消耗 reflow 大于 repaint。</p><p>体现：repaint 是某个 DOM 元素进行重绘；reflow 是整个页面进行重排，也就是页面所有 DOM 元素渲染。</p><p>如何触发： style 变动造成 repaint 和 reflow。</p><ol><li>不涉及任何 DOM 元素的排版问题的变动为 repaint，例如元素的 color/text-align/text-decoration 等等属性的变动。</li><li>除上面所提到的 DOM 元素 style 的修改基本为 reflow。例如元素的任何涉及 长、宽、行高、边框、display 等 style 的修改。</li></ol><p>常见触发场景</p><p>触发 repaint：</p><ul><li>color 的修改，如 color=#ddd；</li><li>text-align 的修改，如 text-align=center；</li><li>a:hover 也会造成重绘。</li><li>:hover 引起的颜色等不导致页面回流的 style 变动。</li></ul><p>触发 reflow：</p><ul><li>width/height/border/margin/padding 的修改，如 width=778px；</li><li>动画，:hover 等伪类引起的元素表现改动，display=none 等造成页面回流；</li><li>appendChild 等 DOM 元素操作；</li><li>font 类 style 的修改；</li><li>background 的修改，注意着字面上可能以为是重绘，但是浏览器确实回流了，经过浏览器厂家的优化，部分 background 的修改只触发 repaint，当然 IE 不用考虑；</li><li>scroll 页面，这个不可避免；</li><li>resize 页面，桌面版本的进行浏览器大小的缩放，移动端的话，还没玩过能拖动程序，resize 程序窗口大小的多窗口操作系统。</li><li>读取元素的属性（这个无法理解，但是技术达人是这么说的，那就把它当做定理吧）：读取元素的某些属性（offsetLeft、offsetTop、offsetHeight、offsetWidth、scrollTop/Left/Width/Height、clientTop/Left/Width/Height、getComputedStyle()、currentStyle(in IE))；</li></ul><p>如何避免： </p><ul><li>尽可能在 DOM 末梢通过改变 class 来修改元素的 style 属性：尽可能的减少受影响的 DOM 元素。</li><li>避免设置多项内联样式：使用常用的 class 的方式进行设置样式，以避免设置样式时访问 DOM 的低效率。</li><li>设置动画元素 position 属性为 fixed 或者 absolute：由于当前元素从 DOM 流中独立出来，因此受影响的只有当前元素，元素 repaint。</li><li>牺牲平滑度满足性能：动画精度太强，会造成更多次的 repaint/reflow，牺牲精度，能满足性能的损耗，获取性能和平滑度的平衡。</li><li>避免使用 table 进行布局：table 的每个元素的大小以及内容的改动，都会导致整个 table 进行重新计算，造成大幅度的 repaint 或者 reflow。改用 div 则可以进行针对性的 repaint 和避免不必要的 reflow。</li><li>避免在 CSS 中使用运算式：学习 CSS 的时候就知道，这个应该避免，不应该加深到这一层再去了解，因为这个的后果确实非常严重，一旦存在动画性的 repaint/reflow，那么每一帧动画都会进行计算，性能消耗不容小觑。</li></ul><p>参考文章：<a href="https://segmentfault.com/a/1190000017329980">你真的了解回流和重绘吗</a></p><hr><ul><li><a href="https://www.jianshu.com/p/996d021bced3">我终于理解了伪类和伪元素</a></li></ul><hr><p><strong>Doctype 作用 ？标准模式与兼容模式各有什么区别 ?</strong></p><ul><li><!DOCTYPE> 声明位于位于 HTML 文档中的第一行，处于 <code>&lt;html&gt; </code>标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE 不存在或格式不正确会导致文档以兼容模式呈现。</li><li>标准模式的排版和 JS 运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。</li></ul><hr><p><strong>HTML5 为什么只需要写 &lt; !DOCTYPE HTML&gt; ？</strong></p><p>HTML5 不基于 SGML(标准通用标记语言（以下简称“通用标言”)，因此不需要对 DTD 进行引用，但是需要 doctype 来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；<br>而 HTML4.01 基于 SGML，所以需要对 DTD 进行引用，才能告知浏览器文档所使用的文档类型。</p><hr><p><strong>行内元素有哪些 ？块级元素有哪些 ？ 空(void)元素有那些 ？</strong></p><p>CSS 规范规定，每个元素都有 display 属性，确定该元素的类型，每个元素都有默认的 display 值。<br>如 div 的 display 默认值为 “block”，则为“块级”元素；<br>span 默认 display 属性值为 “inline”，是“行内”元素。</p><ul><li>行内元素有：a b span img input select strong（强调的语气）</li><li>块级元素有：div ul ol li dl dt dd h1 h2 h3 h4  p</li><li>常见的空元素： img input link meta br hr ，鲜为人知的是：area base col command embed keygen param source track wbr</li></ul><hr><p><strong>HTML5 有哪些新特性、移除了那些元素 ？如何处理 HTML5 新标签的浏览器兼容问题 ？如何区分 HTML 和 HTML5 ？</strong></p><p>HTML5 现在已经不是 SGML（标准通用标记语言）的子集，主要是关于图像，位置，存储，多任务等功能的增加。</p><p>新特性</p><ul><li>绘画 canvas;</li><li>用于媒介回放的 video 和 audio 元素;</li><li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;</li><li>sessionStorage 的数据在浏览器关闭后自动删除;</li><li>语意化更好的内容元素，比如 article、footer、header、nav、section;</li><li>表单控件：calendar、date、time、email、url、search;</li><li>新的技术：webworker, websocket, Geolocation;</li></ul><p>移除的元素</p><ul><li>纯表现的元素：basefont，big，center，font, s，strike，tt，u;  </li><li>对可用性产生负面影响的元素：frame，frameset，noframes；</li></ul><p>支持 HTML5 新标签</p><ul><li>IE8/IE7/IE6 支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式。</li><li>当然也可以直接使用成熟的框架、比如 html5shim;</li><li><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">&lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>简述一下你对 HTML 语义化的理解 ？</strong></p><ul><li>1、用正确的标签做正确的事情。</li><li>2、html 语义化让页面的内容结构化，结构更清晰，</li><li>3、便于对浏览器、搜索引擎解析;</li><li>4、即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的;</li><li>5、搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO;</li><li>6、使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</li></ul><hr><p><strong>HTML5 的离线储存怎么使用，工作原理能不能解释一下 ？</strong></p><p>在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。</p><p>原理</p><p>HTML5 的离线存储是基于一个新建的 .appcache 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像 cookie 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</p><p>如何使用</p><ul><li>1、页面头部像下面一样加入一个 manifest 的属性；</li><li>2、在 cache.manifest 文件的编写离线存储的资源；</li><li><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">#v0.11</span><br><span class="line">CACHE:</span><br><span class="line">js/app.js</span><br><span class="line">css/style.css</span><br><span class="line">NETWORK:</span><br><span class="line">resourse/logo.png</span><br><span class="line">FALLBACK:</span><br><span class="line"><span class="comment">//offline.html</span></span><br></pre></td></tr></table></figure></li><li>3、在离线状态时，操作 window.applicationCache 进行需求实现。</li></ul><hr><p><strong>浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的呢 ？</strong></p><p>在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。</p><p>如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。</p><p>离线的情况下，浏览器就直接使用离线存储的资源。</p><hr><p><strong>请描述一下 cookies，sessionStorage 和 localStorage 的区别 ？</strong></p><ul><li>cookie 是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。</li><li>cookie 数据始终在同源的 http 请求中携带（即使不需要），也会在浏览器和服务器间来回传递。</li><li>sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。</li></ul><p>存储大小</p><ul><li>cookie 数据大小不能超过 4k。</li><li>sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。</li></ul><p>有效期时间</p><ul><li>localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；</li><li>sessionStorage 数据在当前浏览器窗口关闭后自动删除。</li><li>cookie  设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。</li></ul><hr><p><strong>iframe 内嵌框架有那些缺点 ？</strong></p><p>内联框架 iframe一般用来包含别的页面，例如 我们可以在我们自己的网站页面加载别人网站的内容，为了更好的效果，可能需要使 iframe 透明效果；</p><ul><li>iframe 会阻塞主页面的 onload 事件；</li><li>搜索引擎的检索程序无法解读这种页面，不利于 SEO 搜索引擎优化（Search Engine Optimization）</li><li>iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</li></ul><p>如果需要使用 iframe，最好是通过 javascript 动态给 iframe 添加 src 属性值，这样可以绕开以上两个问题。</p><hr><p><strong>Label 的作用是什么？是怎么用的 ？</strong></p><p>label 标签来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;Name&quot;</span>&gt;</span>Number:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">“text“</span> <span class="attr">name</span>=<span class="string">&quot;Name&quot;</span>  <span class="attr">id</span>=<span class="string">&quot;Name&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>Date:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;B&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p><strong>HTML5 的 form 如何关闭自动完成功能 ？</strong></p><p>给不想要提示的 form 或某个 input 设置为 autocomplete=off。</p><hr><p><strong>如何实现浏览器内多个标签页之间的通信 ? (阿里)</strong></p><ul><li>WebSocket、SharedWorker；</li><li>也可以调用 localstorge、cookies 等本地存储方式；</li><li>localstorge 在另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，我们通过监听事件，控制它的值来进行页面信息通信；<br>注意 quirks：Safari 在无痕模式下设置 localstorge 值时会抛出 QuotaExceededError 的异常；</li></ul><hr><p><strong>webSocket 如何兼容低浏览器 ？(阿里)</strong></p><ul><li>Adobe Flash Socket 、</li><li>ActiveX HTMLFile (IE) 、</li><li>基于 multipart 编码发送 XHR 、</li><li>基于长轮询的 XHR。</li></ul><hr><p><strong>页面可见性（Page Visibility API） 可以有哪些用途 ？</strong></p><ul><li>通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;</li><li>在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放；</li></ul><hr><p><strong>网页验证码是干嘛的，是为了解决什么安全问题。</strong></p><ul><li>区分用户是计算机还是人的公共全自动程序；</li><li>可以防止恶意破解密码、刷票、论坛灌水；</li><li>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。</li></ul><hr><p><strong>title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别 ？</strong></p><ul><li><p>title 属性没有明确意义只表示是个标题，H1 则表示层次明确的标题，对页面信息的抓取也有很大的影响；</p></li><li><p>strong 是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：<code>strong 会重读，而 b 是展示强调内容</code>。</p></li><li><p>i 内容展示为斜体，em 表示强调的文本；</p></li><li><p>Physical Style Elements – 自然样式标签：b, i, u, s, pre</p></li><li><p>Semantic Style Elements – 语义样式标签：strong, em, ins, del, code</p></li><li><p>应该准确使用语义样式标签, 但不能滥用, 如果不能确定时，首选使用自然样式标签。</p></li></ul><hr><p><strong>谈谈以前端的角度出发，做好 SEO ，需要考虑什么 ？</strong></p><ul><li>了解搜索引擎如何抓取网页和如何索引网页。<br>你需要知道一些搜索引擎的基本工作原理，各个搜索引擎之间的区别，搜索机器人（SE robot 或叫 web cra何进行工作，搜索引擎如何对搜索结果进行排序等等。</li><li>Meta 标签优化<br>主要包括主题（Title)，网站描述(Description)，和关键词（Keywords）。还有一些其它的隐藏文字比如 Au 者），Category（目录），Language（编码语种）等。</li><li>如何选取关键词并在网页中放置关键词。<br>搜索就得用关键词。关键词分析和选择是 SEO 最重要的工作之一。首先要给网站确定主关键词（一般在 5 个上后针对这些关键词进行优化，包括关键词密度（Density），相关度（Relavancy），突出性（Prominency）等等。</li><li>了解主要的搜索引擎。<br>虽然搜索引擎有很多，但是对网站流量起决定作用的就那么几个。比如英文的主要有 Google，Yahoo，Bing 等有百度，搜狗，有道等。<br>不同的搜索引擎对页面的抓取和索引、排序的规则都不一样。<br>还要了解各搜索门户和搜索的关系，比如 AOL 网页搜索用的是 Google 的搜索技术，MSN 用的是 Bing 的技术。</li><li>主要的互联网目录。<br>Open Directory 自身不是搜索引擎，而是一个大型的网站目录，他和搜索引擎的主要区别是网站内容的收集方目录是人工编辑的，主要收录网站主页；搜索引擎是自动收集的，除了主页外还抓取大量的内容页面。</li><li>按点击付费的搜索引擎。<br>搜索引擎也需要生存，随着互联网商务的越来越成熟，收费的搜索引擎也开始大行其道。最典型的有 Overture 当然也包括 Google 的广告项目 Google Adwords。越来越多的人通过搜索引擎的点击广告来定位商业网站，这里面化和排名的学问，你得学会用最少的广告投入获得最多的点击。</li><li>搜索引擎登录。<br>网站做完了以后，别躺在那里等着客人从天而降。要让别人找到你，最简单的办法就是将网站提交（submit）擎。如果你的是商业网站，主要的搜索引擎和目录都会要求你付费来获得收录（比如 Yahoo 要 299 美元），但是好消少到目前为止）最大的搜索引擎 Google 目前还是免费，而且它主宰着 60％ 以上的搜索市场。</li><li>链接交换和链接广泛度（Link Popularity）。<br>网页内容都是以超文本（Hypertext）的方式来互相链接的，网站之间也是如此。除了搜索引擎以外，人们也不同网站之间的链接来 Surfing（“冲浪”）。其它网站到你的网站的链接越多，你也就会获得更多的访问量。更重你的网站的外部链接数越多，会被搜索引擎认为它的重要性越大，从而给你更高的排名。</li><li>标签的合理使用。</li></ul><hr><p><strong>前端页面有哪三层构成，分别是什么？作用是什么？</strong></p><p>网页分成三个层次，即：结构层、表示层、行为层。</p><ul><li>网页的结构层（structurallayer）由 HTML 或 XHTML 之类的标记语言负责创建。<br>标签，也就是那些出现在尖括号里的单词，对网页内容的语义含义做出这些标签不包含任何关于如何显示有关内容的信息。例如，P 标签表达了这样一种语义：“这是一个文本段。”</li><li>网页的表示层（presentationlayer）由 CSS 负责创建。CSS 对“如何显示有关内容”的问题做出了回答。</li><li>网页的行为层（behaviorlayer）负责回答 “内容应该如何对事件做出反应” 这一问题。<br>这是 Javascript 语言和 DOM 主宰的领域。</li></ul><hr><p><strong>有这么一段 HTML，请挑毛病</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">P</span>&gt;</span> 哥写的不是HTML，是寂寞。&lt; br&gt;&lt; br&gt; 我说：&lt; br&gt;不要迷恋哥，哥只是一个传说</span><br></pre></td></tr></table></figure><p>答案：缺少 p 标记的结束标记。</p><hr><h2 id="3-CSS"><a href="#3-CSS" class="headerlink" title="3. CSS"></a>3. CSS</h2><p><strong>盒子模型的理解 ?</strong></p><ul><li>标准模式和混杂模式（IE）。</li><li>在标准模式下浏览器按照规范呈现页面；</li><li>在混杂模式下，页面以一种比较宽松的向后兼容的方式显示。</li><li>混杂模式通常模拟老式浏览器的行为以防止老站点无法工作。</li></ul><p>CSS 盒子模型具有内容 (content)、填充 (padding)、边框 (border)、边界 (margin)这些属性。</p><p>我们所说的 width，height 指的是内容 (content) 的宽高。</p><p>一个盒子模型的中：</p><ul><li>宽度 = contentWidth+ pdding(宽) + border(宽)。</li><li>高度 = contentHeight + padding(高) + border(高)。</li></ul><hr><p><strong>如何在页面上实现一个圆形的可点击区域 ？</strong></p><ul><li>1、map+area 或者 svg</li><li>2、border-radius</li><li>3、纯 js 实现，需要求一个点在不在圆上简单算法、获取鼠标坐标等等</li></ul><hr><p><strong>实现不使用 border 画出 1px 高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;height:1px;overflow:hidden;background:red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><p><strong>CSS 中哪些属性可以同父元素继承 ?</strong></p><p>继承：(X)HTML 元素可以从其父元素那里继承部分 CSS 属性，即使当前元素并没有定义该属性，比如： color，font-size。</p><hr><p><strong>box-sizing 常用的属性有哪些 ？分别有什么作用 ？</strong></p><p>常用的属性：box-sizing: content-box border-box inherit;</p><p>作用</p><p>content-box(默认)：宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框(元素默认效果)。<br>border-box：元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。</p><hr><p><strong>页面导入样式时，使用 link 和 @import 有什么区别 ？</strong></p><ul><li>link 属于 XHTML 标签，除了加载 CSS 外，还能用于定义 RSS(是一种描述和同步网站内容的格式，是使用最广泛的 XML 应用), 定义 rel 连接属性等作用；</li><li>而 @import 是 CSS 提供的，只能用于加载 CSS;</li><li>页面被加载的时，link 会同时被加载，而 @import 引用的 CSS 会等到页面被加载完再加载;</li><li>import 是 CSS2.1 提出的，只在 IE5 以上才能被识别，而 link 是 XHTML 标签，无兼容问题。</li><li>总之，link 要优于 @import。</li></ul><hr><p><strong>常见兼容性问题？</strong></p><ul><li><p>浏览器默认的 margin 和 padding 不同。解决方案是加一个全局的 *{margin: 0; padding: 0;} 来统一。</p></li><li><p>IE下 event 对象有 event.x，event.y 属性，而 Firefox 下没有。Firefox 下有 event.pageX，event.PageY 属性，而 IE 下没有。<br>解决办法：var mx = event.x?event.x:event.pageX;</p></li><li><p>Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决.</p></li><li><p>超链接访问过后 hover 样式就不出现了，被点击访问过的超链接样式不在具有 hover 和 active 了，解决方法是改变 CSS 属性的排列顺序:<br>L-V-H-A : a:link {} a:visited {} a:hover {} a:active {}</p></li></ul><hr><p><strong>清除浮动，什么时候需要清除浮动，清除浮动都有哪些方法 ？</strong></p><p>一个块级元素如果没有设置 height，那么其高度就是由里面的子元素撑开，如果子元素使用浮动，脱离了标准的文档流，那么父元素的高度会将其忽略，如果不清除浮动，父元素会出现高度不够，那样如果设置 border 或者 background 都得不到正确的解析。</p><p>正是因为浮动的这种特性，导致本属于普通流中的元素浮动之后，包含框内部由于不存在其他普通流元素了，也就表现出高度为 0（<code>高度塌陷</code>）。在实际布局中，往往这并不是我们所希望的，所以需要闭合浮动元素，使其包含框表现出正常的高度。</p><p>清除浮动的方式</p><ul><li>父级 div 定义 height，原理：父级 div 手动定义 height，就解决了父级 div 无法自动获取到高度的问题。 </li><li>结尾处加空 div 标签 clear: both，原理：添加一个空 div，利用 css 提高的 clear: both 清除浮动，让父级 div 能自动获取到高度。</li><li>父级 div 定义 overflow: hidden，  原理：必须定义 width 或 zoom: 1，同时不能定义 height，使用 overflow: hidden 时，浏览器会自动检查浮动区域的高度。 </li><li>父级 div 也一起浮动 。</li><li>父级 div 定义 display: table 。</li><li>父级 div 定义 伪类 :after 和 zoom 。</li><li>结尾处加 br 标签 clear: both， 原理：父级 div 定义 zoom: 1 来解决 IE 浮动问题，结尾处加 br 标签 clear: both。</li></ul><p>总结：比较好的是倒数第 2 种方式，简洁方便。</p><hr><p><strong>如何保持浮层水平垂直居中 ？</strong></p><p>一、水平居中 </p><p>（1）行内元素解决方案</p><p>只需要把行内元素包裹在一个属性 display 为 block 的父层元素中，并且把父层元素添加如下属性即可。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）块状元素解决方案 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">    <span class="comment">/* 这里可以设置顶端外边距 */</span></span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）多个块状元素解决方案将元素的 display 属性设置为 inline-block，并且把父元素的 text-align 属性设置为 center 即可:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）多个块状元素解决方案</p><p>使用 flexbox 布局，只需要把待处理的块状元素的父元素添加属性 display: flex 及 justify-content: center 即可。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、垂直居中</p><p>（1）单行的行内元素解决方案</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#222</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以下代码中，将 a 元素的 height 和 line-height 设置的和父元素一样高度即可实现垂直居中 */</span></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>:<span class="number">200px</span>; </span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#FFF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）多行的行内元素解决方案组合</p><p>使用 display: table-cell 和 vertical-align: middle 属性来定义需要居中的元素的父容器元素生成效果，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    background: #222;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    &#x2F;* 以下属性垂直居中 *&#x2F;</span><br><span class="line">    display: table-cell;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）已知高度的块状元素解决方案</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">50px</span>;  <span class="comment">/* margin-top值为自身高度的一半 */</span></span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三、水平垂直居中</p><p>（1）已知高度和宽度的元素解决方案 1</p><p>这是一种不常见的居中方法，可自适应，比方案 2 更智能，如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">margin</span>:auto;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）已知高度和宽度的元素解决方案 2</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">75px</span>;  <span class="comment">/* 设置margin-left / margin-top 为自身高度的一半 */</span></span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">75px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）未知高度和宽度元素解决方案</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);  <span class="comment">/* 使用 css3 的 transform 来实现 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）使用 flex 布局实现</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="comment">/* 注意这里需要设置高度来查看垂直居中效果 */</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#AAA</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>position 、float 和 display 的取值和各自的意思和用法</strong></p><p>position</p><ul><li>position 属性取值：static(默认)、relative、absolute、fixed、inherit、sticky。</li><li>postision：static；始终处于文档流给予的位置。看起来好像没有用，但它可以快速取消定位，让 top，right，bottom，left 的值失效。在切换的时候可以尝试这个方法。</li><li>除了 static 值，在其他三个值的设置下，z-index 才会起作用。确切地说 z-index 只在定位元素上有效。</li><li>position：relative 和 absolute 都可以用于定位，区别在于前者的 div 还属于正常的文档流，后者已经是脱离了正常文档流，不占据空间位置，不会将父类撑开。<br>定位原点 relative 是相对于它在正常流中的默认位置偏移，它原本占据的空间任然保留；absolute 相对于第一个 position 属性值不为 static 的父类。所以设置了 position：absolute，其父类的该属性值要注意，而且 overflow：hidden 也不能乱设置，因为不属于正常文档流，不会占据父类的高度，也就不会有滚动条。</li><li>fixed 旧版本 IE 不支持，却是很有用，定位原点相对于浏览器窗口，而且不能变。<br>常用于 header，footer 或者一些固定的悬浮 div，随滚动条滚动又稳定又流畅，比 JS 好多了。fixed 可以有很多创造性的布局和作用，兼容性是问题。</li><li>position：inherit。<br>规定从父类继承 position 属性的值，所以这个属性也是有继承性的，但需要注意的是 IE8 以及往前的版本都不支持 inherit 属性。</li><li>sticky ：设置了sticky 的元素，在屏幕范围（viewport）时该元素的位置并不受到定位影响（设置是 top、left 等属性无效），当该元素的位置将要移出偏移范围时，定位又会变成 fixed，根据设置的 left、top 等属性成固定位置的效果。</li></ul><p>float</p><ul><li>float：left (或 right)，向左（或右）浮动，直到它的边缘碰到包含框或另一个浮动框为止。<br>且脱离普通的文档流，会被正常文档流内的块框忽略。不占据空间，无法将父类元素撑开。</li><li>任何元素都可以浮动，浮动元素会生成一个块级框，不论它本身是何种元素。因此，没有必要为浮动元素设置 display：block。</li><li>如果浮动非替换元素，则要指定一个明确的 width，否则它们会尽可能的窄。<br>什么叫替换元素 ？根据元素本身的特点定义的， (X)HTML中的 img、input、textarea、select、object 都是替换元素，这些元素都没有实际的内容。 (X)HTML 的大多数元素是不可替换元素，他们将内容直接告诉浏览器，将其显示出来。</li></ul><p>display</p><ul><li>display 属性取值：none、inline、inline-block、block、table 相关属性值、inherit。</li><li>display 属性规定元素应该生成的框的类型。文档内任何元素都是框，块框或行内框。</li><li>display：none 和 visiability：hidden 都可以隐藏 div，区别有点像 absolute 和 relative，前者不占据文档的空间，后者还是占据文档的位置。</li><li>display：inline 和 block，又叫行内元素和块级元素。<br>表现出来的区别就是 block 独占一行，在浏览器中通常垂直布局，可以用 margin 来控制块级元素之间的间距（存在 margin 合并的问题，只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。）；<br>而 inline 以水平方式布局，垂直方向的 margin 和 padding 都是无效的，大小跟内容一样，且无法设置宽高。<br>inline 就像塑料袋，内容怎么样，就长得怎么样；block 就像盒子，有固定的宽和高。</li><li>inline-block 就介于两者之间。</li><li>table 相关的属性值可以用来垂直居中，效果一般。</li><li>flex</li></ul><p>定位机制</p><p>上面三个属性都属于 CSS 定位属性。CSS 三种基本的定位机制：普通流、浮动、绝对定位。</p><hr><p><strong>css3 动画效果属性有哪些 ?</strong></p><ul><li>animation-name：规定需要绑定到选择器的 keyframe 名称。。</li><li>animation-duration：规定完成动画所花费的时间，以秒或毫秒计。</li><li>animation-timing-function：规定动画的速度曲线。</li><li>animation-delay：规定在动画开始之前的延迟。</li><li>animation-iteration-count：规定动画应该播放的次数。</li><li>animation-direction：规定是否应该轮流反向播放动画。</li></ul><hr><p><strong>会不会用 ps 扣图，png、jpg、gif 这些图片格式解释一下，分别什么时候用。如何优化图像、图像格式的区别 ?</strong></p><p>JPG 的特性</p><ul><li>支持摄影图像或写实图像的高级压缩，并且可利用压缩比例控制图像文件大小。</li><li>有损压缩会使图像数据质量下降，并且在编辑和重新保存 JPG 格式图像时，这种下降损失会累积。</li><li>JPG 不适用于所含颜色很少、具有大块颜色相近的区域或亮度差异十分明显的较简单的图片。</li></ul><p>PNG 的特性</p><ul><li>能在保证最不失真的情况下尽可能压缩图像文件的大小。</li><li>PNG 用来存储灰度图像时，灰度图像的深度可多到 16 位，存储彩色图像时，彩色图像的深度可多到 48 位，并且还可存储多到 16 位的 α 通道数据。</li><li>对于需要高保真的较复杂的图像，PNG 虽然能无损压缩，但图片文件较大，不适合应用在 Web 页面上。</li><li>另外还有一个原则就是用于页面结构的基本视觉元素，<strong>如容器的背景、按钮、导航的背景等应该尽量用 PNG 格式进行存储，这样才能更好的保证设计品质</strong>。而其他一些内容元素，<strong>如广告 Banner、商品图片 等对质量要求不是特别苛刻的，则可以用 JPG 去进行存储从而降低文件大小</strong>。</li></ul><p>GIF格式特点 </p><ul><li>透明性: Gif 是一种布尔透明类型，既它可以是全透明，也可以是全不透明，但是它并没有半透明（alpha 透明）。 </li><li>动画：Gif 这种格式支持动画。 </li><li>无损耗性：Gif 是一种无损耗的图像格式，这也意味着你可以对 gif 图片做任何操作也不会使得图像质量产生损耗。 </li><li>水平扫描：Gif 是使用了一种叫作 LZW 的算法进行压缩的，当压缩 gif 的过程中，像素是由上到下水平压缩的，这也意味着同等条件下，横向的 gif 图片比竖向的 gif 图片更加小。<br>例如 500<em>10 的图片比 10</em>500 的图片更加小。<br>间隔渐进显示：Gif 支持可选择性的间隔渐进显示。 </li></ul><p>由以上特点看出只有 256 种颜色的 gif 图片不适合作为照片，它适合做对颜色要求不高的图形。</p><hr><p><strong>我们知道可以以外链的方式引入 CSS 文件，请谈谈外链引入 CSS 有哪些方式，这些方式的性能有区别吗 ？</strong></p><p>CSS 的引入方式最常用的有三种</p><p>第一：外链式</p><p>这种方法可以说是现在占统治地位的引入方法。</p><p>如同 IE 与浏览器。这也是最能体现 CSS 特点的方法；</p><p>最能体现 DIV+CSS 中的内容离的思想，也最易改版维护，代码看起来也是最美观的一种。</p><p>第二：内部样式表</p><p>这种方法的使用情况要少的多，最长见得就是访问量大的门户网站。或者访问量较大的企业网站的首页。</p><p>与第一种方法比起来，优弊端也明显。</p><p>优点：速度快，所有的 CSS 控制都是针对本页面标签的，没有多余的 CSS 命令；再者不用外链 CSS 文件。直接在文档中读取样式。</p><p>缺点：就是改版麻烦些，单个页面显得臃肿，CSS 不能被其他 HTML 引用造成代码量相对较多，维护也麻烦些采用这种方法的公司大多有钱，对他们来说用户量是关键，他们不缺人进行复杂的维护工作。</p><p>第三：行内样式</p><p>认为 HTML 里不能出现 CSS 命令。其实有时候没有什么大不了。比如通用性差，效果特殊，使用 CSS 命令较少，并且不常改动的地方，使用这种方法反而是很好的选择。</p><p>第四、@import 引入方式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line"><span class="keyword">@import</span> url(my.css);</span><br><span class="line">&lt;/<span class="selector-tag">style</span>&gt;</span><br></pre></td></tr></table></figure><hr><p><strong>CSS Sprite 是什么，谈谈这个技术的优缺点。</strong></p><p>加速的关键，不是降低重量，而是减少个数。传统切图讲究精细，图片规格越小越好，重量越小越好，其实规格大小无计算机统一都按 byte 计算。客户端每显示一张图片都会向服务器发送请求。所以，图片越多请求次数越多，造成延迟的可越大。</p><ul><li>利用 CSS Sprites 能很好地减少了网页的 http 请求，从而大大的提高了页面的性能，这也是CSS Sprites 的优点，也是其被广泛传播和应用的主要原因；</li><li>CSS Sprites 能减少图片的字节，曾经比较过多次 3 张图片合并成 1 张图片的字节总是小于这 3 张图片的和。</li><li>解决了网页设计师在图片命名上的困扰，只需对一张集合的图片上命名就可以了，不需要对每一个小元素名，从而提高了网页的制作效率。</li><li>更换风格方便，只需要在一张或少张图片上修改图片的颜色或样式，整个网页的风格就可以改变。维护起方便。</li></ul><p>诚然 CSS Sprites 是如此的强大，但是也存在一些不可忽视的缺点，如下：</p><ul><li>在图片合并的时候，你要把多张图片有序的合理的合并成一张图片，还要留好足够的空间，防止板块内不不必要的背景；这些还好，最痛苦的是在宽屏，高分辨率的屏幕下的自适应页面，你的图片如果不够宽，很容背景断裂；</li><li>CSS Sprites 在开发的时候比较麻烦，你要通过 photoshop 或其他工具测量计算每一个背景单元的精确位是针线活，没什么难度，但是很繁琐；</li><li>CSS Sprites 在维护的时候比较麻烦，如果页面背景有少许改动，一般就要改这张合并的图片，无需改的好不要动，这样避免改动更多的 css，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字加了，还要改动 css。</li></ul><p>CSS Sprites 非常值得学习和应用，特别是页面有一堆 ico（图标）。总之很多时候大家要权衡一下再决定是不是应用 CSS Sprites。</p><hr><p><strong>以 CSS3 标准定义一个 webkit 内核浏览器识别的圆角（尺寸随意）</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-moz-border-radius</span>: 10<span class="selector-tag">px</span>; </span><br><span class="line"><span class="selector-tag">-webkit-border-radius</span>: 10<span class="selector-tag">px</span>;</span><br><span class="line"> <span class="selector-tag">border-radius</span>: 10<span class="selector-tag">px</span>;。</span><br></pre></td></tr></table></figure><hr><p><strong>优先级算法如何计算？内联和 important 哪个优先级高 ？</strong></p><ul><li>优先级就近原则，样式定义最近者为准</li><li>载入样式以最后载入的定位为准</li><li>优先级为 !important &gt; [ id &gt; class &gt; tag ]</li><li>!mportant 比内联优先级高</li></ul><hr><p><strong>css 的基本语句构成是 ？</strong></p><p>回答：选择器、属性和属性值。</p><hr><p><strong>如果让你来制作一个访问量很高的大型网站，你会如何来管理所有 CSS 文件、JS 与图片？</strong></p><p>回答：涉及到人手、分工、同步；</p><ul><li>先期团队必须确定好全局样式（globe.css），编码模式 (utf-8) 等</li><li>编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；</li><li>标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；</li><li>页面进行标注（例如页面模块开始和结束）；</li><li>CSS 跟 HTML 分文件夹并行存放，命名都得统一（例如 style.css）</li><li>JS 分文件夹存放，命名以该 JS 功能为准</li><li>图片采用整合的 png8 格式文件使用，尽量整合在一起使用，方便将来的管理。</li></ul><hr><p><strong>CSS 选择符有哪些 ？哪些属性可以继承 ？优先级算法如何计算 ？新增伪类有那些 ？</strong></p><p>CSS 选择符</p><ol><li>id选择器（ # myid）</li><li>类选择器（.myclassname）</li><li>标签选择器（div, h1, p）</li><li>相邻选择器（h1 + p）</li><li>子选择器（ul &gt; li）</li><li>后代选择器（li a）</li><li>通配符选择器（ * ）</li><li>属性选择器（a[rel = “external”]）</li><li>伪类选择器（a: hover, li: nth - child）</li></ol><p>可继承的样式</p><p>font-size，font-family，color，ul，li，dl，dd，dt；</p><p>不可继承的样式</p><p>border padding margin width height<br>事实上，宽度也不是继承的，而是如果你不指定宽度，那么它就是 100%。由于你子 DIV 并没有指定宽度，那它就是 100%，也就是与父 DIV 同宽，但这与继承无关，高度自然也没有继承一说。</p><p>优先级算法</p><p>优先级就近原则，同权重情况下样式定义最近者为准;<br>载入样式以最后载入的定位为准;<br>优先级为: !important &gt; id &gt; class &gt; tag , important 比 内联优先级高</p><hr><p><strong>CSS3 新增伪类举例</strong></p><ul><li>:root 选择文档的根元素，等同于 html 元素</li><li>:empty 选择没有子元素的元素</li><li>:target 选取当前活动的目标元素</li><li>:not(selector) 选择除 selector 元素以外的元素</li><li>:enabled 选择可用的表单元素</li><li>:disabled 选择禁用的表单元素</li><li>:checked 选择被选中的表单元素</li><li>:after 选择器在被选元素的内容后面插入内容</li><li>:before 选择器在被选元素的内容前面插入内容</li><li>:nth-child(n) 匹配父元素下指定子元素，在所有子元素中排序第 n</li><li>:nth-last-child(n) 匹配父元素下指定子元素，在所有子元素中排序第 n，从后向前数</li><li>:nth-child(odd) 奇数</li><li>:nth-child(even) 偶数</li><li>:nth-child(3n+1)</li><li>:first-child</li><li>:last-child</li><li>:only-child</li><li>:nth-of-type(n) 匹配父元素下指定子元素，在同类子元素中排序第 n</li><li>:nth-last-of-type(n) 匹配父元素下指定子元素，在同类子元素中排序第 n，从后向前数</li><li>:nth-of-type(odd)</li><li>:nth-of-type(even)</li><li>:nth-of-type(3n+1)</li><li>:first-of-type</li><li>:last-of-type</li><li>:only-of-type</li><li>::selection 选择被用户选取的元素部分</li><li>:first-line 选择元素中的第一行</li><li>:first-letter 选择元素中的第一个字符</li></ul><hr><p><strong>CSS3 有哪些新特性 ?</strong></p><ul><li>CSS3 实现圆角（border-radius:8px）</li><li>阴影（box-shadow:10px）</li><li>对文字加特效（text-shadow） </li><li>线性渐变（gradient） </li><li>旋转、缩放、定位、倾斜 <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transform</span>: <span class="selector-tag">rotate</span>(9<span class="selector-tag">deg</span>) <span class="selector-tag">scale</span>(0.85,0.90) <span class="selector-tag">translate</span>(0<span class="selector-tag">px</span>,<span class="selector-tag">-30px</span>) <span class="selector-tag">skew</span>(<span class="selector-tag">-9deg</span>,0<span class="selector-tag">deg</span>); </span><br></pre></td></tr></table></figure></li><li>增加了更多的 CSS 选择器 </li><li>多背景 rgba</li></ul><hr><p><strong>一个满屏 品字布局 如何设计 ？</strong></p><p>第一种方式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>满屏品字布局<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line">        *&#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        html,body&#123;</span><br><span class="line"><span class="css">            <span class="selector-tag">height</span>: 100%;<span class="comment">/*此设置非常关键，因为默认的 body，HTML 高度为 0，所以后面设置的 div 的高度无法用百分比显示*/</span></span></span><br><span class="line">        &#125;       </span><br><span class="line"><span class="css">        <span class="selector-class">.header</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">height</span><span class="selector-pseudo">:50</span>%; <span class="comment">/*此步结合 html,body 高度为 100%，解决元素相对窗口的定位问题*/</span></span></span><br><span class="line">            width: 50%;     </span><br><span class="line"><span class="css">            <span class="selector-tag">background</span>: <span class="selector-id">#ccc</span>;           </span></span><br><span class="line"><span class="css">            <span class="selector-tag">margin</span><span class="selector-pseudo">:0</span> <span class="selector-tag">auto</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.main</span>&#123;</span></span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 50%;</span><br><span class="line"><span class="css">            <span class="selector-tag">background</span>: <span class="selector-id">#ddd</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.main</span> <span class="selector-class">.left</span>,<span class="selector-class">.main</span> <span class="selector-class">.right</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">float</span>: <span class="selector-tag">left</span>;<span class="comment">/*采用 float 方式，对元素进行左右定位*/</span></span></span><br><span class="line"><span class="css">            <span class="selector-tag">width</span><span class="selector-pseudo">:50</span>%;<span class="comment">/*此步解决元素相对窗口的定位问题*/</span></span></span><br><span class="line"><span class="css">            <span class="selector-tag">height</span><span class="selector-pseudo">:100</span>%;<span class="comment">/*此步解决元素相对窗口的定位问题*/</span></span></span><br><span class="line">            background: yellow;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.main</span> <span class="selector-class">.right</span>&#123;</span></span><br><span class="line">            background: green;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下： </p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-14fd939f04b7ce27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><hr><p><strong>为什么要初始化 CSS 样式 ?</strong></p><p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对 CSS 初始化往往会出现浏览器之间的页面显示差异。<br>初始化样式会对 SEO 有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。</p><p>初始化 CSS 样式例子</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>; </span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line">...</span><br></pre></td></tr></table></figure><hr><p><strong>请解释一下CSS3 的 Flexbox（弹性盒布局模型），以及适用场景 ？</strong></p><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p><p>任何一个容器都可以指定为 Flex 布局，行内元素也可以使用 Flex 布局。</p><p>注意：设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。</p><hr><p><strong>flex 布局最常用的是什么场景 ？</strong></p><p>一般实现垂直居中是一件很麻烦的事，但 flex 布局轻松解决。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.demo</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;            </span><br><span class="line">  <span class="attribute">justify-content</span>: center;                    </span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>用纯 CSS 创建一个三角形的原理是什么？</strong></p><p>把上、左、右三条边隐藏掉（颜色设为 transparent）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#demo</span> &#123;</span><br><span class="line"> <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line"> <span class="attribute">border-width</span>: <span class="number">20px</span>;</span><br><span class="line"> <span class="attribute">border-style</span>: solid;</span><br><span class="line"> <span class="attribute">border-color</span>: transparent transparent red transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>absolute 的 containing block(容器块) 计算方式跟正常流有什么不同 ？</strong></p><p>无论属于哪种，都要先找到其祖先元素中最近的 position 值不为 static 的元素，然后再判断：</p><ul><li>若此元素为 inline 元素，则 containing block 为能够包含这个元素生成的第一个和最后一个 inline box 的 padding box (除 margin, border 外的区域) 的最小矩形；</li><li>否则，则由这个祖先元素的 padding box 构成。</li><li>如果都找不到，则为 initial containing block。</li></ul><p>补充：</p><ol><li>static / relative：简单说就是它的父元素的内容框（即去掉 padding 的部分）</li><li>absolute: 向上找最近的定位为 absolute / relative 的元素</li><li>fixed: 它的 containing block 一律为根元素(html / body)，根元素也是 initialcontaining block </li></ol><hr><p><strong>对 BFC 规范(块级格式化上下文：blockformatting context)的理解 ？</strong></p><p>W3C CSS 2.1 规范中的一个概念，它是一个独立容器，决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。</p><ul><li>一个页面是由很多个 Box 组成的，元素的类型和 display 属性，决定了这个 Box 的类型。</li><li>不同类型的 Box，会参与不同的 Formatting Context（决定如何渲染文档的容器），因此 Box 内的元素会以不同的方式渲染，也就是说 BFC 内部的元素和外部的元素不会互相影响。</li></ul><hr><p><strong>用 position: absolute 跟用 float 有什么区别吗 ？</strong></p><ul><li>都是脱离标准流，只是 position: absolute 定位用的时候，位置可以给的更精确(想放哪就放哪)，而 float 用的更简洁，向右，左，两个方向浮动，用起来就一句代码。</li><li>还有就是 position: absolute 不管在哪个标签里，都可以定位到任意位置，毕竟 top，left，bottom，right 都可以给正值或负值；</li><li>float 只是向左或向右浮动，不如 position: absolute 灵活，浮动后再想改变位置就要加各种 margin，padding 之类的通过间距的改变来改变位置，我自身觉得这样的话用起来不方便，也不太好。</li><li>但在菜单栏，或者一些图标的横向排列时，用起来特别方便，一个 float 就解决了，而且每个元素之间不会有任何间距(所以可以用 float 消除元素间的距离)；</li></ul><hr><p><strong>canvas 与 svg 的区别 ？</strong></p><ul><li>Canvas 是基于像素的即时模式图形系统，最适合较小的表面或较大数量的对象，Canvas 不支持鼠标键盘等事件。</li><li>SVG 是基于形状的保留模式图形系统，更加适合较大的表面或较小数量的对象。</li><li>Canvas 和 SVG 在修改方式上还存在着不同。绘制 Canvas 对象后，不能使用脚本和 CSS 对它进行修改。因为 SVG 对象是文档对象模型的一部分，所以可以随时使用脚本和 CSS 修改它们。</li></ul><p>现在对两种技术做对比归纳如下：</p><p>Canvas</p><ol><li>依赖分辨率</li><li>不支持事件处理器</li><li>弱的文本渲染能力</li><li>能够以 .png 或 .jpg 格式保存结果图像</li><li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li></ol><p>SVG</p><ol><li>不依赖分辨率</li><li>支持事件处理器</li><li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li><li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li><li>不适合游戏应用</li></ol><hr><p><strong>svg 与 canvas 的区别 ？</strong></p><ul><li>svg 绘制出来的每一个图形的元素都是独立的 DOM 节点，能够方便的绑定事件或用来修改，而 canvas 输出的是一整幅画布；</li><li>svg 输出的图形是矢量图形，后期可以修改参数来自由放大缩小，不会是真和锯齿。而 canvas 输出标量画布，就像一张图片一样，放大会失真或者锯齿。</li></ul><hr><p><strong>何时应当时用 padding 和 margin ？</strong></p><p>何时应当使用 margin</p><ul><li>需要在 border 外侧添加空白时。</li><li>空白处不需要背景（色）时。</li><li>上下相连的两个盒子之间的空白，需要相互抵消时。<br>如 15px + 20px 的 margin，将得到 20px 的空白。</li></ul><p>何时应当使用 padding</p><ul><li>需要在 border 内测添加空白时。</li><li>空白处需要背景（色）时。</li><li>上下相连的两个盒子之间的空白，希望等于两者之和时。<br>如 15px + 20px 的 padding，将得到 35px 的空白。</li></ul><p>个人认为：<code>margin 是用来隔开元素与元素的间距；padding 是用来隔开元素与内容的间隔，让内容（文字）与（包裹）元素之间有一段 呼吸距离</code>。</p><hr><p><strong>文字在超出长度时，如何实现用省略号代替 ? 超长长度的文字在省略显示后，如何在鼠标悬停时，以悬浮框的形式显示出全部信息 ?</strong></p><p>注意：设置 width，overflow: hidden, white-space: nowrap (规定段落中的文本不进行换行), text-overflow: ellipsis，四个属性缺一不可。这种写法在所有的浏览器中都能正常显示。</p><hr><p><strong>CSS 里的 visibility 属性有个 collapse 属性值 ？在不同浏览器下有什么区别 ？</strong></p><p>collapse</p><ul><li><p>当在表格元素中使用时，此值可删除一行或一列，但是它不会影响表格的布局，被行或列占据的空间会留给其他内容使用。</p></li><li><p>如果此值被用在其他的元素上，会呈现为 hidden。</p></li><li><p>当一个元素的 visibility 属性被设置成 collapse 值后，对于一般的元素，它的表现跟 hidden 是一样的。</p></li><li><p>chrome中，使用 collapse 值和使用 hidden 没有区别。</p></li><li><p>firefox，opera 和 IE，使用 collapse 值和使用 display：none 没有什么区别。</p></li></ul><hr><p><strong>position 跟 display、overflow、float 这些特性相互叠加后会怎么样 ？</strong></p><ul><li>display 属性规定元素应该生成的框的类型；</li><li>position 属性规定元素的定位类型；</li><li>float 属性是一种布局方式，定义元素在哪个方向浮动。</li><li>类似于优先级机制：position：absolute / fixed 优先级最高，有他们在时，float 不起作用，display 值需要调整。float 或者 absolute 定位的元素，只能是块元素或表格。</li></ul><hr><p><strong>对 BFC 规范(块级格式化上下文：block formatting context) 的理解 ？</strong></p><p>BFC 规定了内部的 Block Box 如何布局。</p><p>定位方案：</p><ul><li>内部的 Box 会在垂直方向上一个接一个放置。</li><li>Box 垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠。</li><li>每个元素的 margin box 的左边，与包含块 border box 的左边相接触。</li><li>BFC 的区域不会与 float box 重叠。</li><li>BFC 是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。</li></ul><p>计算 BFC 的高度时，浮动元素也会参与计算。</p><p>满足下列条件之一就可触发 BFC：</p><ul><li>1、根元素，即 html</li><li>2、float 的值不为 none（默认）</li><li>3、overflow 的值不为 visible（默认）</li><li>4、display 的值为 inline-block、table-cell、table-caption</li><li>5、position 的值为 absolute 或 fixed</li></ul><hr><p><strong>浏览器是怎样解析 CSS 选择器的 ？</strong></p><ul><li>CSS 选择器的解析是从右向左解析的。</li><li>若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。</li><li>若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。</li><li>两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。</li><li>而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。</li><li>在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。</li></ul><hr><p><strong>元素竖向的百分比设定是相对于容器的高度吗 ？</strong></p><p>当按百分比设定一个元素的宽度时，它是相对于父容器的宽度计算的。</p><hr><p><strong>全屏滚动的原理是什么 ？用到了 CSS 的哪些属性 ？</strong></p><p>原理</p><ul><li>有点类似于轮播，整体的元素一直排列下去，假设有 5  个需要展示的全屏页面，那么高度是 500%，只是展示 100%，剩下的可以通过 transform 进行 y 轴定位，也可以通过 margin-top 实现。</li><li>overflow：hidden；transition：all 1000ms ease；</li></ul><hr><p><strong>什么是响应式设计 ？响应式设计的基本原理是什么 ？如何兼容低版本的 IE ？</strong></p><ul><li>响应式网站设计( Responsive Web design ) 是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。</li><li>基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。</li><li>页面头部必须有 meta 声明的 viewport。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;” width=&quot;</span><span class="attr">device-width</span>&quot; <span class="attr">initial-scale</span>=<span class="string">&quot;1&quot;</span> <span class="attr">maximum-scale</span>=<span class="string">&quot;1&quot;</span> <span class="attr">user-scalable</span>=<span class="string">&quot;no&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><hr><p><strong>视差滚动效果 ？</strong></p><p>视差滚动（Parallax Scrolling）通过在网页向下滚动的时候，<code>控制背景的移动速度比前景的移动速度慢</code>来创建出令人惊叹的 3D 效果。</p><ul><li>CSS3 实现。<br>优点：开发时间短、性能和开发效率比较好，缺点是不能兼容到低版本的浏览器</li><li>jQuery 实现。<br>通过控制不同层滚动速度，计算每一层的时间，控制滚动效果。优点：能兼容到各个版本的，效果可控性好。缺点：开发起来对制作者要求高。</li><li>插件实现方式。<br>例如：parallax-scrolling，兼容性十分好。</li></ul><hr><p><strong>::before 和 :after 中双冒号和单冒号有什么区别 ？解释一下这 2 个伪元素的作用</strong></p><ul><li>单冒号 (:) 用于 CSS3 伪类，双冒号 (::) 用于 CSS3 伪元素。</li><li>::before 就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于 dom 之中，只存在在页面之中。</li></ul><p>:before 和 :after 这两个伪元素，是在 CSS2.1 里新出现的。<br>起初，伪元素的前缀使用的是单冒号语法，但随着 Web 的进化，在 CSS3 的规范里，伪元素的语法被修改成使用双冒号，成为 ::before、 ::after 。</p><hr><p><strong>怎么让 Chrome 支持小于 12px 的文字 ？</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">10px</span>;</span><br><span class="line">  -webkit-transform: scale(0.8);  // 0.8 是缩放比例</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><p><strong>让页面里的字体变清晰，变细用 CSS 怎么做 ？</strong></p><p>-webkit-font-smoothing 在 window 系统下没有起作用，但是在 IOS 设备上起作用 -webkit-font-smoothing：antialiased 是最佳的，灰度平滑。</p><hr><p><strong>如果需要手动写动画，你认为最小时间间隔是多久，为什么 ？</strong></p><p>多数显示器默认频率是 60Hz，即 1 秒刷新 60 次，所以理论上最小间隔为：1/60＊1000ms ＝ 16.7ms。</p><hr><p><strong>有一个高度自适应的 div，里面有两个 div，一个高度 100px，如何让另一个填满剩下的高度 ？</strong></p><ul><li>外层 div 使用 position：relative；</li><li>高度要求自适应的 div 使用 position: absolute; top: 100px; bottom: 0; left: 0</li></ul><hr><p><strong>style 标签写在 body 后与 body 前有什么区别？</strong></p><p>页面加载自上而下，当然是先加载样式。</p><p>写在 body 标签后，由于浏览器以逐行方式对 HTML 文档进行解析，当解析到写在尾部的样式表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在 windows 的 IE 下可能会出现 FOUC 现象（即样式失效导致的页面闪烁问题）</p><hr><p><strong>阐述一下CSS Sprites</strong></p><p>将一个页面涉及到的所有图片都包含到一张大图中去，然后利用 CSS 的 background-image，background-repeat，background-position 的组合进行背景定位。</p><p>利用 CSS Sprites 能很好地减少网页的 http 请求，从而大大的提高页面的性能；<br>CSS Sprites 能减少图片的字节。</p><hr><p><strong>用 css 实现左侧宽度自适应，右侧固定宽度 ？</strong></p><p>1、标准浏览器的方法</p><p>当然，以不折腾人为标准的 w3c 标准早就为我们提供了制作这种自适应宽度的标准方法。</p><ul><li>把 container 设为 display: table 并指定宽度 100%；</li><li>然后把 main + sidebar 设为 display: table-cell; </li><li>然后只给 sidebar 指定一个宽度，那么 main 的宽度就变成自适应了。</li></ul><p>代码很少，而且不会有额外标签。不过这是 IE7 及以下都无效的方法。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/12890819-ce4324bfc2c4f839.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>2、固定区域浮动，自适应区域不设置宽度但设置 margin</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">*zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">320px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#666</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，sidebar 让它浮动，并设置了一个宽度；而 main 没有设置宽度。</p><p>大家要注意 html 中必须使用 div 标签，不要妄图使用什么 p 标签来达到目的。因为 div 有个默认属性，即如果不设置宽度，那它会自动填满它的父标签的宽度。这里的 main 就是例子。</p><p>当然我们不能让它填满了，填满了它就不能和 sidebar 保持同一行了。我们给它设置一个 margin。由于 sidebar 在右边，所以我们设置 main 的 margin-right 值，值比 sidebar 的宽度大一点点——以便区分它们的范围，例子中是 320。</p><p>假设 main 的默认宽度是 100%，那么它设置了 margin 后，它的宽度就变成了 100% - 320，此时 main 发现自己的宽度可以与 sidebar 挤在同一行了，于是它就上来了。<br>而宽度 100% 是相对于它的父标签来的，如果我们改变了它父标签的宽度，那 main 的宽度也就会变——比如我们把浏览器窗口缩小，那 container  的宽度就会变小，而 main 的宽度也就变小，但它的实际宽度 100% - 320 始终是不会变的。</p><p>这个方法看起来很完美，只要我们记得清除浮动(这里我用了最简单的方法)，那 footer 也不会错位。而且无论 main 和 sidebar 谁更长，都不会对布局造成影响。</p><p>但实际上这个方法有个很老火的限制——html 中 sidebar 必须在 main 之前！<br>但我需要 sidebar 在 main 之后！因为我的 main 里面才是网页的主要内容，我不想主要内容反而排在次要内容后面。<br>但如果 sidebar 在 main 之后，那上面的一切都会化为泡影。</p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-47c872107fcc93aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>3、固定区域使用定位，自适应区域不设置宽度，但设置 margin</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">320px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#666</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/12890819-767262ae18002121.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>咦，好像不对，footer 怎么还是在那儿呢？怎么没有自动往下走呢？footer 说——我不给绝对主义者让位！<br>其实这与 footer 无关，而是因为 container 对 sidebar 的无视造成的——你再长，我还是没感觉。<br>看来这种定位方式只能满足 sidebar 自己，但对它的兄弟们却毫无益处。</p><p>4、左边浮动，右边 overflow: hidden;</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">*&#123;<span class="attribute">margin</span>:<span class="number">0</span>; <span class="attribute">padding</span>: <span class="number">0</span>;&#125;</span><br><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span>&#123;</span><br><span class="line">   <span class="attribute">height</span>: <span class="number">100%</span>;<span class="comment">/*高度百分百显示*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#eee</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法，我利用的是创建一个新的 BFC（块级格式化上下文）来防止文字环绕的原理来实现的。</p><p>BFC 就是一个相对独立的布局环境，它内部元素的布局不受外面布局的影响。<br>它可以通过以下任何一种方式来创建： </p><ul><li>float 的值不为 none </li><li>position 的值不为 static 或者 relative </li><li>display 的值为 table-cell , table-caption , inline-block , flex , 或者 inline-flex 中的其中一个 </li><li>overflow 的值不为 visible</li></ul><p>关于 BFC，在 w3c 里是这样描述的：在 BFC 中，每个盒子的左外边框紧挨着 包含块 的 左边框 （从右到左的格式化时，则为右边框紧挨）。<br>即使在浮动里也是这样的（尽管一个包含块的边框会因为浮动而萎缩），除非这个包含块的内部创建了一个新的 BFC。<br>这样，当我们给右侧的元素单独创建一个 BFC 时，它将不会紧贴在包含块的左边框，而是紧贴在左元素的右边框。</p><hr><p><strong>问：浮动的原理和工作方式，会产生什么影响呢，要怎么处理 ？</strong></p><p>工作方式：浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。</p><p>影响</p><ul><li>浮动会导致父元素无法被撑开，影响与父元素同级的元素。</li><li>与该浮动元素同级的非浮动元素，如果是块级元素，会移动到该元素下方，而块级元素内部的行内元素会环绕浮动元素；而如果是内联元素则会环绕该浮动元素。</li><li>与该元素同级的浮动元素，对于同一方向的浮动元素(同级)，两个元素将会跟在碰到的浮动元素后；而对于不同方向的浮动元素，在宽度足够时，将分别浮动向不同方向，在宽度不同是将导致一方换行(换行与 HTML 书写顺序有关，后边的将会浮动到下一行)。</li><li>浮动元素将被视作为块元素。</li><li>而浮动元素对于其父元素之外的元素，如果是非浮动元素，则相当于忽视该浮动元素，如果是浮动元素，则相当于同级的浮动元素。</li><li>而常用的清除浮动的方法，则如使用空标签，overflow，伪元素等。</li></ul><p>在使用基于浮动设计的 CSS 框架时，自会提供清除的方法，个人并不习惯使用浮动进行布局。</p><hr><p><strong>对 CSS Grid 布局的使用</strong></p><p><a href="http://www.css88.com/archives/8506">5 分钟学会 CSS Grid 布局</a></p><hr><p><strong>rem、em、px、vh 与 vw 的区别 ？</strong></p><p>一、 rem 的特点</p><ol><li>rem 的大小是根据 <code>html</code> 根目录下的字体大小进行计算的。</li><li>当我们改变根目录下的字体大小的时候，下面字体都改变。</li><li>rem 不仅可以设置字体的大小，也可以设置元素宽、高等属性。</li><li>rem 是 CSS3 新增的一个相对单位（root em，根em），这个单位与 em 区别在于使用 rem 为元素设定字体大小时，仍然是相对大小，但相对的只是 HTML 根元素。</li></ol><p>这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。<br>目前，除了 IE8 及更早版本外，所有浏览器均已支持 rem。<br>对于不支持它的浏览器，应对方法也很简单，就是多写一个绝对单位的声明。这些浏览器会忽略用 rem 设定的字体大小。</p><p>二、px 特点</p><ol><li>px 像素（Pixel）。相对长度单位。像素 px 是相对于显示器屏幕分辨率而言的。</li></ol><p>三、em 特点 </p><ol><li>em 的值并不是固定的；</li><li>em 会继承父级元素的字体大小。</li><li>em 是相对长度单位。当前对行内文本的字体尺寸未被人为设置，相对于当前对象内文本的字体尺寸。如则相对于浏览器的默认字体尺寸。</li><li>任意浏览器的默认字体高都是 16px。</li></ol><p>所有未经调整的浏览器一般都符合: 1em = 16px。那么 12px = 0.75em，10px = 0.625em。<br>为了简化 font-size 的换算，需要在 css 中的 body 选择器中声明 Fontsize = 62.5%，这就使 em 值变为 16px*62.5%=10px, 这样 12px = 1.2em, 10px = 1em, 也就是说只需要将你的原来的 px 数值除以 10，然后换上 em 作为单位就行了。</p><p>四、vh 与 vw </p><p>视口 </p><ul><li>在桌面端，指的是浏览器的可视区域；</li><li>在移动端，它涉及 3个 视口：Layout Viewport（布局视口），Visual Viewport（视觉视口），Ideal Viewport（理想视口）。</li><li>视口单位中的 “视口”，桌面端指的是浏览器的可视区域；移动端指的就是 Viewport 中的 Layout Viewport。</li></ul><p>vh / vw 与 % </p><table><thead><tr><th align="left">单位</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">vw</td><td align="left">1vw = 视口宽度的 1%</td></tr><tr><td align="left">vh</td><td align="left">1vh = 视口高度的 1%</td></tr><tr><td align="left">vmin</td><td align="left">选取 vw 和 vh 中最小的那个</td></tr><tr><td align="left">vmax</td><td align="left">选取 vw 和 vh 中最大的那个</td></tr></tbody></table><p>比如：浏览器视口尺寸为 370px，那么 1vw = 370px * 1% = 6.5px (浏览器会四舍五入向下取 7)</p><p>vh / vw 与 % 区别</p><table><thead><tr><th align="left">单位</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">%</td><td align="left">元素的祖先元素</td></tr><tr><td align="left">vh / vw</td><td align="left">视口的尺寸</td></tr></tbody></table><p>不过由于 vw 和 vh 是 css3 才支持的长度单位，所以在不支持 css3 的浏览器中是无效的。</p><hr><p><strong>什么叫优雅降级和渐进增强 ？</strong></p><ul><li>渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</li><li>优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</li></ul><p>区别</p><ul><li>优雅降级是从复杂的现状开始，并试图减少用户体验的供给；</li><li>渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要；</li><li>降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。</li></ul><hr><p><strong>width 和 height 的百分比是相对谁讲的 ？margin 和 padding 呢？</strong></p><ul><li>width 是相对于直接父元素的 width</li><li>height 是相对于直接父元素的 height</li><li>padding 是相对于直接父元素的 width</li><li>margin 是相对于直接父元素的 margin</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    #wrapper &#123;</span><br><span class="line">        width: 500px;</span><br><span class="line">        height: 800px;</span><br><span class="line">        background-color: #ccc;</span><br><span class="line">    &#125;</span><br><span class="line">    .parent &#123;</span><br><span class="line">        width: 300px;</span><br><span class="line">        height: 400px;</span><br><span class="line">        background-color: yellow;</span><br><span class="line">    &#125;</span><br><span class="line">    .son &#123;</span><br><span class="line">        &#x2F;* 90*40 *&#x2F;</span><br><span class="line">        width: 30%;</span><br><span class="line">        height: 10%;</span><br><span class="line">        &#x2F;* 30 30 *&#x2F;</span><br><span class="line">        padding-left: 10%;</span><br><span class="line">        margin-left: 10%;</span><br><span class="line">        background-color: green;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;wrapper&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;parent&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;son&quot;&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>相关文章：</p><ul><li><a href="https://segmentfault.com/a/1190000012698032">transform，transition，animation，keyframes区别</a></li><li><a href="https://www.jianshu.com/p/075839c8e2f2">width 和 height 的百分比是相对谁讲的 ？margin 和 padding 呢？</a></li><li><a href="https://juejin.im/post/5b876f86518825431079ddd6">彻底搞懂 CSS 层叠上下文、层叠等级、层叠顺序、z-index</a></li></ul><hr><h2 id="4-JavaScript"><a href="#4-JavaScript" class="headerlink" title="4. JavaScript"></a>4. JavaScript</h2><p><strong>常见的浏览器内核有哪些 ？</strong></p><ul><li>Trident 内核：IE, 360，搜狗浏览器 MaxThon、TT、The World,等。[又称 MSHTML]</li><li>Gecko 内核：火狐，FF，MozillaSuite / SeaMonkey 等</li><li>Presto 内核：Opera7 及以上。[Opera 内核原为：Presto，现为：Blink]</li><li>Webkit 内核：Safari，Chrome 等。 [ Chrome 的：Blink（WebKit 的分支）]</li></ul><hr><p><strong>try/catch 无法捕获 promise.reject 的问题</strong></p><p>try..catch 结构，它只能是同步的，无法用于异步代码模式。</p><p><a href="https://segmentfault.com/q/1010000014905440">https://segmentfault.com/q/1010000014905440</a></p><hr><p><strong>error 事件的事件处理程序</strong></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers/onerror">https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers/onerror</a></p><hr><p><strong>一个简易版的 Function.prototype.bind 实现</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.apply(context, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;前端架构师&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;.bind(obj);</span><br><span class="line">func();</span><br></pre></td></tr></table></figure><ul><li><a href="https://blog.csdn.net/w390058785/article/details/83185847">【JavaScript】Function.prototype.bind 实现原理</a></li></ul><hr><p><strong>call、apply、bind</strong></p><ol><li>怎么利用 call、apply 来求一个数组中最大或者最小值 ?</li><li>如何利用 call、apply 来做继承 ?</li><li>apply、call、bind 的区别和主要应用场景 ?</li></ol><ul><li>call 跟 apply 的用法几乎一样，唯一的不同就是传递的参数不同，call 只能一个参数一个参数的传入。</li><li>apply 则只支持传入一个数组，哪怕是一个参数也要是数组形式。最终调用函数时候这个数组会拆成一个个参数分别传入。</li><li>至于 bind 方法，他是直接改变这个函数的 this 指向并且返回一个新的函数，之后再次调用这个函数的时候 this 都是指向 bind 绑定的第一个参数。</li><li>bind 传参方式跟 call 方法一致。</li></ul><p>适用场景：</p><p>求一个数组中最大或者最小值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果一个数组我们已知里面全都是数字，想要知道最大的那个数，由于 Array 没有 max 方法，Math 对象上有</span></span><br><span class="line"><span class="comment">// 我们可以根据 apply 传递参数的特性将这个数组当成参数传入</span></span><br><span class="line"><span class="comment">// 最终 Math.max 函数调用的时候会将 apply 的数组里面的参数一个一个传入，恰好符合 Math.max 的参数传递方式</span></span><br><span class="line"><span class="comment">// 这样变相的实现了数组的 max 方法。min 方法也同理</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">const</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr)</span><br><span class="line"><span class="built_in">console</span>.log(max)    <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>参数都会排在之后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果你想将某个函数绑定新的`this`指向并且固定先传入几个变量可以在绑定的时候就传入，之后调用新函数传入的参数都会排在之后</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">...args</span>) </span>&#123; <span class="built_in">console</span>.log(args) &#125;</span><br><span class="line"><span class="keyword">const</span> newFn = test.bind(obj, <span class="string">&#x27;静态参数1&#x27;</span>, <span class="string">&#x27;静态参数2&#x27;</span>)</span><br><span class="line">newFn(<span class="string">&#x27;动态参数3&#x27;</span>, <span class="string">&#x27;动态参数4&#x27;</span>)</span><br></pre></td></tr></table></figure><p>利用 call 和 apply 做继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  Animal.call(<span class="built_in">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Animal.call(this) 的意思就是使用 this 对象代替 Animal 对象，那么</span></span><br><span class="line"><span class="comment">// Cat 中不就有 Animal 的所有属性和方法了吗，Cat 对象就能够直接调用 Animal 的方法以及属性了</span></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat(<span class="string">&quot;TONY&quot;</span>);</span><br><span class="line">cat.showName(); <span class="comment">//TONY</span></span><br></pre></td></tr></table></figure><p>将伪数组转化为数组（含有 length 属性的对象，dom 节点, 函数的参数 arguments）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// case1: dom节点：</span></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;div1&quot;</span>&gt;<span class="number">1</span>&lt;/div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;div1&quot;</span>&gt;<span class="number">2</span>&lt;/div&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;div1&quot;</span>&gt;<span class="number">3</span>&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(div); <span class="comment">// HTMLCollection(3) [div.div1, div.div1, div.div1] 里面包含length属性</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.prototype.slice.call(div);</span><br><span class="line"><span class="built_in">console</span>.log(arr2); <span class="comment">// 数组 [div.div1, div.div1, div.div1]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//case2：fn 内的 arguments</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn10</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn10(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)); <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// case3: 含有 length 属性的对象</span></span><br><span class="line"><span class="keyword">let</span> obj4 = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">&#x27;thomas&#x27;</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="number">13</span>,</span><br><span class="line">    length: <span class="number">3</span> <span class="comment">// 一定要有length属性</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.slice.call(obj4)); <span class="comment">// [1, &quot;thomas&quot;, 13]</span></span><br></pre></td></tr></table></figure><p>判断变量类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> str1 = <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;thomas&#x27;</span> &#125;;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">&#x27;[object Array]&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn1(arr1)); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断类型的方式，这个最常用语判断 array 和 object ，null( 因为 typeof null 等于 object )</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(arr1)); <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(str1)); <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(obj1)); <span class="comment">// [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>)); <span class="comment">// [object Null]</span></span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>当我们使用一个函数需要改变 this 指向的时候才会用到 <code>call</code> <code>apply</code> <code>bind</code></li><li>如果你要传递的参数不多，则可以使用 fn.call(thisObj, arg1, arg2 …)</li><li>如果你要传递的参数很多，则可以用数组将参数整理好调用 fn.apply(thisObj, [arg1, arg2 …])</li><li>如果你想生成一个新的函数长期绑定某个函数给某个对象使用，则可以使用 const newFn = fn.bind(thisObj); newFn(arg1, arg2…)</li></ol><p>参考文章：</p><ul><li><a href="https://www.jianshu.com/p/bbeadae6127e">call、apply、bind 的区别</a></li><li><a href="https://segmentfault.com/a/1190000012772040">聊一聊 call、apply、bind 的区别</a></li></ul><hr><p><a href="https://www.cnblogs.com/Grace-zyy/p/8206002.html">理解 js 继承的 6 种方式</a></p><hr><p><strong>mouseenter 和 mouseover 的区别</strong> </p><ul><li>不论鼠标指针穿过被选元素或其子元素，都会触发 mouseover 事件，对应 mouseout。</li><li>只有在鼠标指针穿过被选元素时，才会触发 mouseenter 事件，对应 mouseleave。</li></ul><hr><p><strong>用正则表达式匹配字符串，以字母开头，后面是数字、字符串或者下划线，长度为 9 - 20</strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;^[a-zA-Z][a-zA-Z0-9_]&#123;8,19&#125;$&quot;</span>);</span><br></pre></td></tr></table></figure><hr><p><strong>js 字符串两边截取空白的 trim 的原型方法的实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除左右两端的空格</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trim</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> str.replace(<span class="regexp">/(^\s*)|(\s*$)/g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除左边的空格 /(^\s*)/g</span></span><br><span class="line"><span class="comment">// 删除右边的空格 /(\s*$)/g</span></span><br></pre></td></tr></table></figure><hr><p><strong>介绍一下你对浏览器内核的理解 ?</strong></p><p>内核主要分成两部分：渲染引擎(layout engineer 或 Rendering Engine) 和 JS 引擎。</p><p>渲染引擎</p><p>负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。<br>浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。<br>所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</p><p>JS 引擎</p><p>解析和执行 javascript 来实现网页的动态效果。 </p><p>最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</p><hr><p><strong>哪些常见操作会造成内存泄漏 ？</strong></p><p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。 </p><p>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 </p><ul><li>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。</li><li>闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）。</li></ul><hr><p><strong>线程与进程的区别 ？</strong></p><ul><li>一个程序至少有一个进程，一个进程至少有一个线程。</li><li>线程的划分尺度小于进程，使得多线程程序的并发性高。 </li><li>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 </li></ul><p>线程在执行过程中与进程还是有区别的。</p><ul><li>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li><li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。<br>但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</li></ul><hr><p><strong>eval() 函数有什么用 ？</strong></p><p>eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。</p><hr><p><strong>实现一个方法，使得：add(2, 5) 和 add(2)(5) 的结果都为 7</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x, r</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x + r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>)(<span class="number">5</span>));  <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">2</span>,<span class="number">5</span>));  <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><hr><p><strong>alert(1 &amp;&amp; 2) 和 alert(1 || 0) 的结果是 ？</strong></p><p>alert(1 &amp;&amp;2 ) 的结果是 2</p><ul><li>只要 “&amp;&amp;” 前面是 false，无论 “&amp;&amp;” 后面是 true 还是 false，结果都将返 “&amp;&amp;” 前面的值;</li><li>只要 “&amp;&amp;” 前面是 true，无论 “&amp;&amp;” 后面是 true 还是 false，结果都将返 “&amp;&amp;” 后面的值;</li></ul><p>alert(0 || 1) 的结果是 1</p><ul><li>只要 “||” 前面为 false，不管 “||” 后面是 true 还是 false，都返回 “||” 后面的值。</li><li>只要 “||” 前面为 true，不管 “||” 后面是 true 还是 false，都返回 “||” 前面的值。</li></ul><blockquote><p>只要记住 0 与 任何数都是 0，其他反推。</p></blockquote><hr><p><strong>下面的输出结果是 ？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> out = <span class="number">25</span>,</span><br><span class="line">   inner = &#123;</span><br><span class="line">        out: <span class="number">20</span>,</span><br><span class="line">        func: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> out = <span class="number">30</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="built_in">console</span>.log((inner.func, inner.func)());</span><br><span class="line"><span class="built_in">console</span>.log(inner.func());</span><br><span class="line"><span class="built_in">console</span>.log((inner.func)());</span><br><span class="line"><span class="built_in">console</span>.log((inner.func = inner.func)());</span><br></pre></td></tr></table></figure><p>结果：25，20，20，25</p><p>代码解析：这道题的考点分两个 </p><ol><li>作用域</li><li>运算符（赋值预算，逗号运算）</li></ol><p>先看第一个输出：25，因为 ( inner.func, inner.func ) 是进行逗号运算符，逗号运算符就是运算前面的 ”,“ 返回最后一个，举个栗子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>, j = <span class="number">1</span>, k = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log((i++, j++, k)) <span class="comment">// 返回的是 k 的值 2 ，如果写成 k++ 的话  这里返回的就是 3</span></span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(j); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(k); <span class="comment">// 2   </span></span><br></pre></td></tr></table></figure><p>回到原题 ( inner.func, inner.func ) 就是返回 inner.func ，而 inner.func 只是一个匿名函数 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> out = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且这个匿名函数是属于 window 的，则变成了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> out = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.out;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>此刻的 this =&gt; window</p><p>所以 out 是 25。</p><p>第二和第三个 console.log 的作用域都是 inner，也就是他们执行的其实是 inner.func();<br>inner 作用域中是有 out 变量的，所以结果是 20。</p><p>第四个 console.log 考查的是一个等号运算 inner.func = inner.func ，其实返回的是运算的结果，<br>举个栗子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>, b = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a = b) <span class="comment">// 输出的是 3</span></span><br></pre></td></tr></table></figure><p>所以 inner.func = inner.func 返回的也是一个匿名函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> out = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此刻，道理就和第一个 console.log 一样了，输出的结果是 25。</p><hr><p><strong>下面程序输出的结果是 ？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> <span class="built_in">window</span>)) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">alert(a);</span><br></pre></td></tr></table></figure><p>代码解析：如果 window 不包含属性 a，就声明一个变量 a，然后赋值为 1。</p><p>你可能认为 alert 出来的结果是 1，然后实际结果是 “undefined”。</p><p>要了解为什么，需要知道 JavaScript 里的 3 个概念。</p><p>首先，在 es6 之前，所有的全局变量都是 window 的属性，语句 var a = 1; 等价于 window.a = 1;<br>你可以用如下方式来检测全局变量是否声明：”变量名称” in window。</p><p>第二，所有的变量声明都在范围作用域的顶部，看一下相似的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">&quot;b&quot;</span> <span class="keyword">in</span> <span class="built_in">window</span>);</span><br><span class="line"><span class="keyword">var</span> b;</span><br></pre></td></tr></table></figure><p>此时，尽管声明是在 alert 之后，alert 弹出的依然是 true，这是因为 JavaScript 引擎首先会扫描所有的变量声明，然后将这些变量声明移动到顶部，最终的代码效果是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">alert(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> <span class="built_in">window</span>);</span><br></pre></td></tr></table></figure><p>这样看起来就很容易解释为什么 alert 结果是 true 了。</p><p>第三，你需要理解该题目的意思是，变量声明被提前了，但变量赋值没有，因为这行代码包括了变量声明和变量赋值。</p><p>你可以将语句拆分为如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;    <span class="comment">//声明</span></span><br><span class="line">a = <span class="number">1</span>;    <span class="comment">//初始化赋值</span></span><br></pre></td></tr></table></figure><p>当变量声明和赋值在一起用的时候，JavaScript 引擎会自动将它分为两部以便将变量声明提前，<br>不将赋值的步骤提前，是因为他有可能影响代码执行出不可预期的结果。</p><p>所以，知道了这些概念以后，重新回头看一下题目的代码，其实就等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">if</span> (!(<span class="string">&quot;a&quot;</span> <span class="keyword">in</span> <span class="built_in">window</span>)) &#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">alert(a);</span><br></pre></td></tr></table></figure><p>这样，题目的意思就非常清楚了：首先声明 a，然后判断 a 是否在存在，如果不存在就赋值为1，很明显 a 永远在 window 里存在，这个赋值语句永远不会执行，所以结果是 undefined。</p><p>提前这个词语显得有点迷惑了，你可以理解为：预编译。</p><hr><p><strong>下面程序输出的结果是 ？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  x &amp;&amp; a(--x);</span><br><span class="line">&#125;;</span><br><span class="line">alert(a);</span><br></pre></td></tr></table></figure><p>这个题目看起来比实际复杂，alert 的结果是 1。</p><p>这里依然有 3 个重要的概念需要我们知道。</p><ul><li>首先，第一个是 <code>变量声明在进入执行上下文就完成了</code>；</li><li>第二个概念就是<code>函数声明也是提前的，所有的函数声明都在执行代码之前都已经完成了声明，和变量声明一样</code>。</li></ul><p>澄清一下，函数声明是如下这样的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span>(<span class="params">arg1, arg2</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下不是函数，而是函数表达式，相当于变量赋值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> functionName = <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>)</span>&#123;</span><br><span class="line">       <span class="comment">//函数体</span></span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><p>澄清一下，函数表达式没有提前，就相当于平时的变量赋值。</p><ul><li>第三需要知道的是，<code>函数声明会覆盖变量声明，但不会覆盖变量赋值</code>。</li></ul><p>为了解释这个，我们来看一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">value</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> value;</span><br><span class="line">alert(<span class="keyword">typeof</span> value);    <span class="comment">//&quot;function&quot;</span></span><br></pre></td></tr></table></figure><p>尽管变量声明在下面定义，但是变量 value 依然是 function，也就是说这种情况下，函数声明的优先级高于变量声明的优先级，但如果该变量 value 赋值了，那结果就完全不一样了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">value</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line">alert(<span class="keyword">typeof</span> value);    <span class="comment">//&quot;number&quot;</span></span><br></pre></td></tr></table></figure><p>该 value 赋值以后，变量赋值初始化就覆盖了函数声明。</p><p>重新回到题目，这个函数其实是一个有名函数表达式，函数表达式不像函数声明一样可以覆盖变量声明，但你可以注意到，变量 b 是包含了该函数表达式，而该函数表达式的名字是 a。</p><p>不同的浏览器对 a 这个名词处理有点不一样，在 IE 里，会将 a 认为函数声明，所以它被变量初始化覆盖了，就是说如果调用 a(–x) 的话就会出错，而其它浏览器在允许在函数内部调用 a(–x)，因为这时候 a 在函数外面依然是数字。<br>基本上，IE 里调用 b(2) 的时候会出错，但其它浏览器则返回 undefined。</p><p>理解上述内容之后，该题目换成一个更准确和更容易理解的代码应该像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>,</span><br><span class="line">    b = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">      x &amp;&amp; b(--x);</span><br><span class="line">    &#125;;</span><br><span class="line">alert(a);</span><br></pre></td></tr></table></figure><p>这样的话，就很清晰地知道为什么 alert 的总是 1 了。</p><hr><p><strong>下面程序输出的结果是 ？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">alert(a);</span><br></pre></td></tr></table></figure><p>alert 的值是下面的函数 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题目比较简单：即函数声明和变量声明的关系和影响，遇到同名的函数声明，不会重新定义。</p><hr><p><strong>下面程序输出的结果是 ？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">x, y, a</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">arguments</span>[<span class="number">2</span>] = <span class="number">10</span>;</span><br><span class="line">        alert(a);</span><br><span class="line">&#125;</span><br><span class="line">b(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>结果为 10。</p><p>活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。</p><hr><p><strong>三道判断输出的题都是经典的题</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">b();</span><br></pre></td></tr></table></figure><p>明显输出是 3，因为里面修改了 a 这个全局变量，那个 function a(){} 是用来干扰的，虽然函数声明会提升，就被 a 给覆盖掉了，这是我的理解。</p><p>不记得具体的，就类似如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> baz = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> bazz =&#123;</span><br><span class="line">  baz: <span class="number">2</span>,</span><br><span class="line">  getbaz: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.baz</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(bazz.getbaz())</span><br><span class="line"><span class="keyword">var</span> g = bazz.getbaz;</span><br><span class="line"><span class="built_in">console</span>.log(g()) ;</span><br></pre></td></tr></table></figure><p>第一个输出是 2，第二个输出是 3。</p><p>这题考察的就是 this 的指向，函数作为对象本身属性调用的时候，this 指向对象，作为普通函数调用的时候，就指向全局了。</p><p>还有下面的题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">  arr[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">3</span>]();</span><br></pre></td></tr></table></figure><p>典型的闭包，弹出 5 。</p><hr><p><strong>解释清楚 null 和 undefined</strong></p><p>null 用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。  null 表示”没有对象”，即该处不应该有值。<br>null 典型用法是： </p><ul><li>作为函数的参数，表示该函数的参数不是对象。 </li><li>作为对象原型链的终点。</li></ul><p>当声明的变量还未被初始化时，变量的默认值为 undefined。 undefined 表示”缺少值”，就是此处应该有一个值，但是还没有定义。 </p><ul><li>变量被声明了，但没有赋值时，就等于 undefined。 </li><li>调用函数时，应该提供的参数没有提供，该参数等于 undefined。 </li><li>对象没有赋值的属性，该属性的值为 undefined。 </li><li>函数没有返回值时，默认返回 undefined。</li></ul><p>未定义的值和定义未赋值的为 undefined，null 是一种特殊的 object，NaN 是一种特殊的 number。</p><hr><p>*<em>讲一下 1 和 Number(1) 的区别**</em></p><ul><li>1 是一个原始定义好的 number 类型；</li><li>Number(1) 是一个函数类型，是我们自己声明的一个函数（方法）。</li></ul><hr><p><strong>讲一下 prototype 是什么东西，原型链的理解，什么时候用 prototype ？</strong></p><p>prototype 是函数对象上面预设的对象属性。</p><hr><p><strong>实现 add(1)(2)(3) = 6</strong></p><p>这题考察的是柯里化,做这题之前呢,我们得知道柯里化的概念:</p><p>柯里化就是把接收多个参数的函数变换成接收一个单一参数(最初函数的第一个参数)的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curry = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span> </span><br><span class="line">            args.length &lt; fn.length </span><br><span class="line">            <span class="comment">// 参数长度不足时,重新柯里化函数,等待接受新参数</span></span><br><span class="line">            ? <span class="function">(<span class="params">...<span class="built_in">arguments</span></span>) =&gt;</span> curry(fn, ...args, ...arguments)</span><br><span class="line">            <span class="comment">// 函数长度满足时,执行函数</span></span><br><span class="line">             : fn(...args);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumFn</span>(<span class="params">a, b, c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sum = curry(sumFn);</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)); <span class="comment">//6</span></span><br></pre></td></tr></table></figure><hr><p><strong>script 标签的 defer 和 async</strong></p><ul><li>一个普通的 <code>&lt;script&gt;</code> 标签的加载和解析都是同步的，会阻塞 DOM 的渲染，这也就是我们经常会把 <code>&lt;script&gt;</code> 写在 <code>&lt;body&gt;</code>底部的原因之一，为了防止加载资源而导致的长时间的白屏。</li><li>另一个原因是 js 可能会进行 DOM 操作，所以要在 DOM 全部渲染完后再执行。</li></ul><p>defer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果 script 标签设置了该属性，则浏览器会异步的下载该文件并且不会影响到后续 DOM 的渲染；</span><br><span class="line">如果有多个设置了 defer 的 script 标签存在，则会按照顺序执行所有的 script；</span><br><span class="line">defer 脚本会在文档渲染完毕后，DOMContentLoaded 事件调用前执行。</span><br></pre></td></tr></table></figure><p>async</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">async 的设置，会使得 script 脚本异步的加载并在允许的情况下执行 async 的执行，</span><br><span class="line">并不会按着 script 在页面中的顺序来执行，而是谁先加载完谁执行。</span><br></pre></td></tr></table></figure><ul><li>概括来讲，就是这两个属性都会使 script 标签异步加载，然而执行的时机是不一样的。</li><li>也就是说 async 是乱序的，而 defer 是顺序执行，这也就决定了async 比较适用于百度分析或者谷歌分析这类不依赖其他脚本的库。</li></ul><p>推荐的应用场景</p><p>defer</p><p>如果你的脚本代码依赖于页面中的 DOM 元素（文档是否解析完毕），或者被其他脚本文件依赖。</p><p>例：</p><ul><li>评论框</li><li>代码语法高亮</li><li>polyfill.js</li></ul><p>async</p><p>如果你的脚本并不关心页面中的 DOM 元素（文档是否解析完毕），并且也不会产生其他脚本需要的数据。</p><p>例：百度统计</p><p>如果不太能确定的话，用 defer 总是会比 async 稳定。。。</p><p>参考：<a href="https://www.cnblogs.com/jiasm/p/7683930.html">浅谈 script 标签中的 async 和 defer</a></p><hr><p><strong>函数里的 this 什么含义，什么情况下，怎么用 ？</strong></p><ul><li>this 是 Javascript 语言的一个关键字。</li><li>它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。</li><li>随着函数使用场合的不同，this 的值会发生变化。</li><li>但是有一个总的原则，那就是 <code>this 指的是，调用函数的那个对象</code>。</li></ul><p>情况一：纯粹的函数调用 </p><p>这是函数的最通常用法，<code>属于全局性调用，因此 this 就代表全局对象 window</code>。    　　</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;    　　　</span><br><span class="line">  <span class="built_in">this</span>.x = <span class="number">1</span>;    　　　　</span><br><span class="line">  alert(<span class="built_in">this</span>.x);    　　</span><br><span class="line">&#125;    　　</span><br><span class="line">test(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>为了证明 this 就是全局对象，我对代码做一些改变：    　　</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;    　　</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;    　　　　</span><br><span class="line">  alert(<span class="built_in">this</span>.x);    　　</span><br><span class="line">&#125;    　　</span><br><span class="line">test(); <span class="comment">// 1    </span></span><br></pre></td></tr></table></figure><p>运行结果还是 1。</p><p>再变一下：    　　</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;    　　</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;    　　　　</span><br><span class="line">  <span class="built_in">this</span>.x = <span class="number">0</span>;    　　</span><br><span class="line">&#125;    　　</span><br><span class="line">test();</span><br><span class="line">alert(x); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>情况二：作为对象方法的调用    </p><p><code>函数还可以作为某个对象的方法调用，这时 this 就指这个上级对象</code>。    　　</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;    　　　　</span><br><span class="line">  alert(<span class="built_in">this</span>.x);    　　</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>    　　</span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;    　　</span><br><span class="line">o.x = <span class="number">1</span>;    　　</span><br><span class="line">o.m = test;    　　</span><br><span class="line">o.m(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>情况三： 作为构造函数调用   </p><p>所谓构造函数，就是通过这个函数生成一个新对象（object）。这时的 this 就指这个新对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>)</span>&#123;    　　　　</span><br><span class="line">  <span class="built_in">this</span>.x = <span class="number">1</span>;    　　</span><br><span class="line">&#125;    　　</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> Test();</span><br><span class="line">alert(o.x); <span class="comment">// 1    </span></span><br></pre></td></tr></table></figure><p>运行结果为 1。为了表明这时 this 不是全局对象，对代码做一些改变：    　　</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;    　　</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span>(<span class="params"></span>)</span>&#123;    　　　　</span><br><span class="line">  <span class="built_in">this</span>.x = <span class="number">1</span>;    　　</span><br><span class="line">&#125;    　　</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> Test();    　　</span><br><span class="line">alert(x); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>运行结果为 2，表明全局变量 x 的值没变。</p><p>情况四： apply 调用    </p><p>apply() 是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this 指的就是这第一个参数。    　　</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;    　　</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;    　　　　</span><br><span class="line">  alert(<span class="built_in">this</span>.x);    　　</span><br><span class="line">&#125;    　　</span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;    　　</span><br><span class="line">o.x = <span class="number">1</span>;    　　</span><br><span class="line">o.m = test;    　　</span><br><span class="line">o.m.apply(); <span class="comment">// 0    </span></span><br></pre></td></tr></table></figure><p>apply() 的参数为空时，默认调用全局对象。因此，这时的运行结果为 0，证明 this 指的是全局对象。<br>   <br>如果把最后一行代码修改为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o.m.apply(o); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>运行结果就变成了 1，证明了这时 this 代表的是对象 o。</p><hr><p><strong>apply 和 call  什么含义，什么区别 ？什么时候用 ？</strong></p><p>call，apply 都属于 Function.prototype 的一个方法，它是 JavaScript 引擎内在实现的，因为属于 Function.prototype，所以每个 Function 对象实例(就是每个方法)都有 call，apply 属性。</p><p>既然作为方法的属性，那它们的使用就当然是针对方法的了，这两个方法是容易混淆的，因为它们的作用一样，只是使用方式不同。</p><p>语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo.call(<span class="built_in">this</span>, arg1, arg2, arg3) == foo.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>) == <span class="built_in">this</span>.foo(arg1, arg2, arg3);</span><br></pre></td></tr></table></figure><ul><li>相同点：两个方法产生的作用是完全一样的。</li><li>不同点：方法传递的参数不同。</li></ul><p>每个函数对象会有一些方法可以去修改函数执行时里面的 this，比较常见得到就是 call 和 apply，通过 call 和 apply 可以重新定义函数的执行环境，即 this 的指向。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">c, d</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a + <span class="built_in">this</span>.b + c + d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">3</span> &#125;;</span><br><span class="line">add.call(o, <span class="number">5</span>, <span class="number">7</span>);    <span class="comment">//1+3+5+7=16</span></span><br><span class="line"><span class="comment">//传参的时候是扁平的把每个参数传进去</span></span><br><span class="line"></span><br><span class="line">add.apply(o, [<span class="number">10</span>, <span class="number">20</span>]);   <span class="comment">//1+3+10+20=34</span></span><br><span class="line"><span class="comment">//传参的时候是把参数作为一个数组传进去</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//什么时候使用 call 或者 apply</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">this</span>));</span><br><span class="line">  <span class="comment">// 用来调用一些无法直接调用的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.call(<span class="number">7</span>); <span class="comment">// &quot;[object Number]&quot;</span></span><br></pre></td></tr></table></figure><hr><p><strong>异步过程的构成要素有哪些？和异步过程是怎样的 ？</strong></p><p>总结一下，一个异步过程通常是这样的：</p><ul><li>主线程发起一个异步请求，相应的工作线程接收请求并告知主线程已收到(异步函数返回)；</li><li>主线程可以继续执行后面的代码，同时工作线程执行异步任务；</li><li>工作线程完成工作后，通知主线程；</li><li>主线程收到通知后，执行一定的动作(调用回调函数)。</li></ul><ol><li>异步函数通常具有以下的形式：A(args…, callbackFn)。</li><li>它可以叫做异步过程的发起函数，或者叫做异步任务注册函数。</li><li>args 和 callbackFn 是这个函数的参数。</li></ol><p>所以，从主线程的角度看，一个异步过程包括下面两个要素：</p><ul><li>发起函数(或叫注册函数) A。</li><li>回调函数 callbackFn。</li></ul><p>它们都是在主线程上调用的，其中注册函数用来发起异步过程，回调函数用来处理结果。</p><p>举个具体的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(fn, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>其中的 setTimeout 就是异步过程的发起函数，fn 是回调函数。</p><p>注意：前面说的形式 A(args…, callbackFn) 只是一种抽象的表示，并不代表回调函数一定要作为发起函数的参数。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange = xxx; <span class="comment">// 添加回调函数</span></span><br><span class="line">xhr.open(<span class="string">&#x27;GET&#x27;</span>, url);</span><br><span class="line">xhr.send(); <span class="comment">// 发起函数</span></span><br></pre></td></tr></table></figure><p>发起函数和回调函数就是分离的。</p><hr><p><strong>说说消息队列和事件循环</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-b606f7eed6ba42d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><ul><li>主线程在执行完当前循环中的所有代码后，就会到消息队列取出这条消息(也就是 message 函数)，并执行它。</li><li>完成了工作线程对主线程的通知，回调函数也就得到了执行。</li><li>如果一开始主线程就没有提供回调函数，AJAX 线程在收到 HTTP 响应后，也就没必要通知主线程，从而也没必要往消息队列放消息。</li></ul><blockquote><p>异步过程的回调函数，一定不在当前的这一轮事件循环中执行。</p></blockquote><hr><p><strong>session 与 cookie 的区别</strong></p><ul><li>session 保存在服务器，客户端不知道其中的信息；</li><li>cookie 保存在客户端，服务器能够知道其中的信息。 </li><li>session 中保存的是对象，cookie 中保存的是字符串。   </li><li>session 不能区分路径，同一个用户在访问一个网站期间，所有的 session 在任何一个地方都可以访问到。</li><li>而 cookie 中如果设置了路径参数，那么同一个网站中不同路径下的 cookie 互相是访问不到的。  </li></ul><hr><p><strong>cookies 是干嘛的，服务器和浏览器之间的 cookies 是怎么传的，httponly 的 cookies 和可读写的 cookie 有什么区别，有无长度限制 ?</strong></p><ul><li>cookies 是一些存储在用户电脑上的小文件。</li><li>它是被设计用来保存一些站点的用户数据，这样能够让服务器为这样的用户定制内容，后者页面代码能够获取到 cookie 值然后发送给服务器。</li><li>比如 cookie 中存储了所在地理位置，以后每次进入地图就默认定位到改地点即可。</li></ul><hr><p><strong>请描述一下 cookies，sessionStorage 和 localStorage 的区别</strong></p><p>共同点</p><ul><li>都是保存在浏览器端，且同源的。</li></ul><p>区别</p><ul><li>cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递。</li><li>而 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。</li><li>cookie 数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下。</li><li>存储大小限制也不同，cookie 数据不能超过 4k，同时因为每次 http 请求都会携带 cookie，所以 cookie 只适合保存很小的数据，如会话标识。</li><li>sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。</li><li>数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie 只在设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。</li><li>作用域不同，sessionStorage 在不同的浏览器窗口中<code>不共享</code>，即使是同一个页面；cookie 和 localStorage 在所有同源窗口中都是共享的。</li></ul><hr><p><strong>从敲入 URL 到渲染完成的整个过程，包括 DOM 构建的过程，说的约详细越好</strong></p><ul><li>用户输入 url 地址，浏览器根据域名寻找 IP 地址</li><li>浏览器向服务器发送 http 请求，如果服务器段返回以 301 之类的重定向，浏览器根据相应头中的 location 再次发送请求</li><li>服务器端接受请求，处理请求生成 html 代码，返回给浏览器，这时的 html 页面代码可能是经过压缩的</li><li>浏览器接收服务器响应结果，如果有压缩则首先进行解压处理，紧接着就是页面解析渲染</li><li> 解析渲染该过程主要分为以下步骤：解析 HTML、构建 DOM 树、DOM 树与 CSS 样式进行附着构造呈现树</li><li>布局</li><li>绘制</li></ul><p>详情：<a href="https://juejin.im/post/5b9ba9c15188255c8320fe27">面试题之从敲入 URL 到浏览器渲染完成</a></p><hr><p><strong>是否了解公钥加密和私钥加密。如何确保表单提交里的密码字段不被泄露。</strong></p><p>公钥用于对数据进行加密，私钥用于对数据进行解密。</p><p>很直观的理解：公钥就是公开的密钥，其公开了大家才能用它来加密数据。私钥是私有的密钥，谁有这个密钥才能够解密密文。</p><p>解决方案 1:</p><p>form 在提交的过程中，对密码字段是不进行加密而是以明码的形式进行数据传输的。<br>如果要对数据进行加密，你可以自己写一个脚本对内容进行编码后传输，只是这个安全性也并不高。</p><p>解决方案 2:</p><p>如果想对数据进行加密，你可以使用 HTTPS 安全传输协议，这个协议是由系统进行密码加密处理的，在数据传输中是绝对不会被拦截获取的，只是 HTTPS 的架设会相对麻烦点。一些大型网站的登录、银行的在线网关等都是走这条路。</p><hr><p><strong>验证码是干嘛的，是为了解决什么安全问题。</strong></p><p>所谓验证码，就是将一串随机产生的数字或符号，生成一幅图片， 图片里加上一些干扰象素（防止OCR），由用户肉眼识别其中的验证码信息，输入表单提交网站验证，验证成功后才能使用某项功能。</p><ul><li>验证码一般是防止批量注册的，人眼看起来都费劲，何况是机器。</li><li>像百度贴吧未登录发贴要输入验证码大概是防止大规模匿名回帖的发生。</li><li>目前，不少网站为了防止用户利用机器人自动注册、登录、灌水，都采用了验证码技术。</li></ul><hr><p><strong>截取字符串 abcdefg 的 efg。</strong></p><p>从第四位开始截取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">&#x27;abcdefg&#x27;</span>.substring(<span class="number">4</span>));</span><br><span class="line">alert (<span class="string">&#x27;abcdefg&#x27;</span>.slice(<span class="number">4</span>))</span><br></pre></td></tr></table></figure><hr><p><strong>判断一个字符串中出现次数最多的字符，统计这个次数</strong></p><p>步骤</p><ul><li>将字符串转化数组 </li><li>创建一个对象 </li><li>遍历数组，判断对象中是否存在数组中的值，如果存在值 +1，不存在赋值为 1</li><li>定义两个变量存储字符值，字符出现的字数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;abaasdffggghhjjkkgfddsssss3444343&#x27;</span>;</span><br><span class="line"><span class="comment">// 1.将字符串转换成数组</span></span><br><span class="line"><span class="keyword">var</span> newArr = str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// 2.创建一个对象</span></span><br><span class="line"><span class="keyword">var</span> json = &#123;&#125;;</span><br><span class="line"><span class="comment">// 3. 所有字母出现的次数，判断对象中是否存在数组中的值，如果存在值 +1，不存在赋值为 1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; newArr.length; i++)&#123;</span><br><span class="line">      <span class="comment">// 类似：json : &#123; ‘a’: 3, ’b’: 1 &#125;</span></span><br><span class="line">      <span class="keyword">if</span>(json[newArr[i]])&#123;</span><br><span class="line">         json[newArr[i]] +=<span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           json[newArr[i]] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4 定义两个变量存储字符值，字符出现的字数</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">0</span> ; <span class="comment">//次数</span></span><br><span class="line"><span class="keyword">var</span> element = <span class="string">&quot;&quot;</span>; <span class="comment">//最多的项</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> json)&#123;</span><br><span class="line">   <span class="keyword">if</span>(json[k] &gt; num)&#123;</span><br><span class="line">     num = json[k];</span><br><span class="line">     element = k ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;出现次数：&quot;</span>+num +<span class="string">&quot;最多的字符：&quot;</span>+ element);</span><br></pre></td></tr></table></figure><hr><p><strong>document.write 和 innerHTML 的区别</strong></p><ul><li>document.write 是直接写入到页面的内容流，如果在写之前没有调用 document.open, 浏览器会自动调用 open。每次写完关闭之后重新调用该函数，会导致页面被重写。</li><li>innerHTML 则是 DOM 页面元素的一个属性，代表该元素的 html 内容。你可以精确到某一个具体的元素来进行更改。如果想修改 document 的内容，则需要修改 document.documentElement.innerElement。</li><li>innerHTML 将内容写入某个 DOM 节点，不会导致页面全部重绘。</li><li>innerHTML 很多情况下都优于 document.write，其原因在于其允许更精确的控制要刷新页面的那一个部分。</li><li>document.write 是重写整个 document, 写入内容是字符串的 html；innerHTML 是 HTMLElement 的属性，是一个元素的内部 html 内容 </li></ul><hr><p><strong>JS 识别不同浏览器信息</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myBrowser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> userAgent = navigator.userAgent; <span class="comment">//取得浏览器的userAgent字符串  </span></span><br><span class="line">  <span class="keyword">var</span> isOpera = userAgent.indexOf(<span class="string">&quot;Opera&quot;</span>) &gt; -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (isOpera) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Opera&quot;</span></span><br><span class="line">  &#125;; <span class="comment">//判断是否Opera浏览器  </span></span><br><span class="line">  <span class="keyword">if</span> (userAgent.indexOf(<span class="string">&quot;Firefox&quot;</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Firefox&quot;</span>;</span><br><span class="line">  &#125;  <span class="comment">//判断是否Firefox浏览器  </span></span><br><span class="line">  <span class="keyword">if</span> (userAgent.indexOf(<span class="string">&quot;Chrome&quot;</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Chrome&quot;</span>;</span><br><span class="line">  &#125;   <span class="comment">//判断是否Google浏览器  </span></span><br><span class="line">  <span class="keyword">if</span> (userAgent.indexOf(<span class="string">&quot;Safari&quot;</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Safari&quot;</span>;</span><br><span class="line">  &#125; <span class="comment">//判断是否Safari浏览器  </span></span><br><span class="line">  <span class="keyword">if</span> (userAgent.indexOf(<span class="string">&quot;compatible&quot;</span>) &gt; -<span class="number">1</span> &amp;&amp; userAgent.indexOf(<span class="string">&quot;MSIE&quot;</span>) &gt; -<span class="number">1</span> &amp;&amp; !isOpera) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;IE&quot;</span>;</span><br><span class="line">  &#125;; <span class="comment">//判断是否IE浏览器  </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><p><strong>JavaScript 常见的内置对象</strong></p><p>有 Object、Math、String、Array、Number、Function、Boolean、JSON 等，其中 Object 是所有对象的基类，采用了原型继承方式。</p><hr><p><strong>编写一个方法，求一个字符串的字节长度</strong></p><p>假设：一个英文字符占用一个字节，一个中文字符占用两个字节</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBytes</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = str.length;</span><br><span class="line">    <span class="keyword">var</span> bytes = len;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (str.charCodeAt(i) &gt; <span class="number">255</span>)  bytes++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br><span class="line">alert(getBytes(<span class="string">&quot;你好,as&quot;</span>));</span><br></pre></td></tr></table></figure><hr><p><strong>JS 组成</strong></p><ul><li>核心（ECMAScript） 描述了该语言的语法和基本对象</li><li>文档对象模型(DOM) 描述了处理网页内容的方法和接口</li><li>浏览器对象模型(BOM) 描述了与浏览器进行交互的方法和接口</li></ul><hr><p><strong>new 操作符具体干了什么呢 ?</strong></p><ul><li>创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。</li><li>属性和方法被加入到 this 引用的对象中。</li><li>新创建的对象由 this 所引用，并且最后隐式的返回 this 。</li></ul><hr><p><strong>JSON 的了解？</strong></p><ul><li>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。</li><li>它是基于 JavaScript 的一个子集。</li><li>数据格式简单，易于读写，占用带宽小。 </li><li>格式：采用键值对。例如：{ “age‟: ‟12‟, ”name‟: ‟back‟ }</li></ul><hr><p><strong>你有哪些性能优化的方法 ？</strong></p><p>web 前端是应用服务器处理之前的部分，前端主要包括：HTML、CSS、javascript、image 等各种资源，针对不同的资源有不同的优化方式。</p><p>内容优化</p><ul><li>减少 HTTP 请求数。这条策略是最重要最有效的，因为一个完整的请求要经过 DNS 寻址，与服务器建立连接，发送数据，等待服务器响应，接收数据这样一个消耗时间成本和资源成本的复杂的过程。<br>常见方法：合并多个 CSS 文件和 js 文件，利用 CSS Sprites 整合图像，Inline Images (使用 data：URL scheme 在实际的页面嵌入图像数据 )，合理设置 HTTP 缓存等。</li><li>减少 DNS 查找</li><li>避免重定向</li><li>使用 Ajax 缓存</li><li>延迟加载组件，预加载组件</li><li>减少 DOM 元素数量。页面中存在大量 DOM 元素，会导致 javascript 遍历 DOM 的效率变慢。</li><li>最小化 iframe 的数量。iframes 提供了一个简单的方式把一个网站的内容嵌入到另一个网站中。但其创建速度比其他包括 JavaScript 和 CSS 的 DOM 元素的创建慢了 1-2 个数量级。</li><li>避免 404。HTTP 请求时间消耗是很大的，因此使用 HTTP 请求来获得一个没有用处的响应（例如 404 没有找到页面）是完全没有必要的，它只会降低用户体验而不会有一点好处。</li></ul><p>服务器优化</p><ul><li>使用内容分发网络（CDN）。把网站内容分散到多个、处于不同地域位置的服务器上可以加快下载速度。</li><li>GZIP 压缩</li><li>设置 ETag：ETags（Entity tags，实体标签）是 web 服务器和浏览器用于判断浏览器缓存中的内容和服务器中的原始内容是否匹配的一种机制。</li><li>提前刷新缓冲区</li><li>对 Ajax 请求使用 GET 方法</li><li>避免空的图像 src</li></ul><p>Cookie 优化</p><ul><li>减小 Cookie 大小</li><li>针对 Web 组件使用域名无关的 Cookie</li></ul><p>CSS 优化</p><ul><li>将 CSS 代码放在 HTML 页面的顶部</li><li>避免使用 CSS 表达式</li><li>使用 &lt; link&gt; 来代替 @import</li><li>避免使用 Filters</li></ul><p>javascript 优化</p><ul><li>将 JavaScript 脚本放在页面的底部。</li><li>将 JavaScript 和 CSS 作为外部文件来引用。<br>在实际应用中使用外部文件可以提高页面速度，因为 JavaScript 和 CSS 文件都能在浏览器中产生缓存。</li><li>缩小 JavaScript 和 CSS</li><li>删除重复的脚本</li><li>最小化 DOM 的访问。使用 JavaScript 访问 DOM 元素比较慢。</li><li>开发智能的事件处理程序</li><li>javascript 代码注意：谨慎使用 with，避免使用 eval Function 函数，减少作用域链查找。</li></ul><p>图像优化</p><ul><li>优化图片大小</li><li>通过 CSS Sprites 优化图片</li><li>不要在 HTML 中使用缩放图片</li><li>favicon.ico 要小而且可缓存</li></ul><hr><p><strong>JS 格式化数字（每三位加逗号）</strong></p><p>从后往前取。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toThousands</span>(<span class="params">num</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> num = (num || <span class="number">0</span>).toString(), result = <span class="string">&#x27;&#x27;</span>;  </span><br><span class="line">    <span class="keyword">while</span> (num.length &gt; <span class="number">3</span>) &#123;  </span><br><span class="line">        result = <span class="string">&#x27;,&#x27;</span> + num.slice(-<span class="number">3</span>) + result;  </span><br><span class="line">        num = num.slice(<span class="number">0</span>, num.length - <span class="number">3</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (num) &#123; result = num + result; &#125;  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><hr><p><strong>合并数组</strong></p><p>如果你需要合并两个数组的话，可以使用 Array.concat()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(array1.concat(array2)); <span class="comment">// [1,2,3,4,5,6];</span></span><br></pre></td></tr></table></figure><p>然而，这个函数并不适用于合并大的数组，因为它需要创建一个新的数组，而这会消耗很多内存。</p><p>这时，你可以使用 Array.push.apply(arr1, arr2) 来代替创建新的数组，它可以把第二个数组合并到第一个中，从而较少内存消耗。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(array1.push.apply(array1, array2)); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><hr><p><strong>把节点列表 (NodeList) 转换为数组</strong></p><p>如果你运行 document.querySelectorAll(“p”) 方法，它可能会返回一个 DOM 元素的数组 — 节点列表对象。<br>但这个对象并不具有数组的全部方法，如 sort()，reduce()， map()，filter()。<br>为了使用数组的那些方法，你需要把它转换为数组。</p><p>只需使用 [].slice.call(elements) 即可实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elements = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;p&quot;</span>); <span class="comment">// NodeList</span></span><br><span class="line"><span class="keyword">var</span> arrayElements = [].slice.call(elements); <span class="comment">// 现在 NodeList 是一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arrayElements = <span class="built_in">Array</span>.from(elements); <span class="comment">// 这是另一种转换 NodeList 到 Array  的方法</span></span><br></pre></td></tr></table></figure><hr><p><strong>打乱数组元素的顺序</strong></p><p>不适用 Lodash 等这些库打乱数组元素顺序，你可以使用这个技巧：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(list.sort(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">Math</span>.random() - <span class="number">0.5</span> &#125;)); <span class="comment">// [2, 1, 3]</span></span><br></pre></td></tr></table></figure><hr><p><strong>js 的 ready 和 onload 事件的区别</strong></p><ul><li>onload 是等 HTML 的所有资源都加载完成后再执行 onload 里面的内容，所有资源包括 DOM 结构、图片、视频 等资源;</li><li>ready 是当 DOM 结构加载完成后就可以执行了，相当于 jQuery 中的 $(function(){ js 代码 }); </li><li>另外，onload 只能有一个，ready 可以有多个。</li></ul><hr><p><strong>js 的两种回收机制</strong></p><p>标记清除（mark and sweep）</p><p>从语义上理解就比较好理解了，大概就是当变量进入到某个环境中的时候就把这个变量标记一下，比如标记为“进入环境”，当离开的时候就把这个变量的标记给清除掉，比如是“离开环境”。而在这后面还有标记的变量将被视为准备删除的变量。</p><ul><li>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（可以使用任何标记方式）。</li><li>然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。</li><li>而在此之后再被加上的标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。</li><li>最后，垃圾收集器完成内存清除工作。销毁那些带标记的值并回收它们所占用的内存空间。</li></ul><p>这是 javascript 最常见的垃圾回收方式。至于上面有说道的标记，到底该如何标记 ？<br>好像是有很多方法，比如特殊位翻转，维护一个列表什么的。</p><p>引用计数（reference counting）</p><ul><li>引用计数的含义是跟踪记录每个值被引用的次数，当声明一个变量并将一个引用类型的值赋给该变量时，这个时候的引用类型的值就会是引用次数 +1 了。如果同一个值又被赋给另外一个变量，则该值的引用次数又 +1。</li><li>相反如果包含这个值的引用的变量又取得另外一个值，即被重新赋了值，那么这个值的引用就 -1 。当这个值的引用次数编程 0 时，表示没有用到这个值，这个值也无法访问，因此环境就会收回这个值所占用的内存空间回收。</li><li>这样，当垃圾收集器下次再运行时，它就会释放引用次数为 0 的值所占用的内存。</li></ul><hr><p><strong><a href="https://www.cnblogs.com/shuiyi/p/5305435.html">三张图搞懂 JavaScript 的原型对象与原型链</a></strong></p><p>对于新人来说，JavaScript 的原型是一个很让人头疼的事情，一来 prototype 容易与 <strong><strong>proto</strong></strong> 混淆， </p><p>一、prototype 和 <strong><strong>proto</strong></strong>  的区别</p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-e1ef55b9143a3efc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a.prototype);  <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__);  <span class="comment">//Object &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b.prototype);  <span class="comment">//b &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b.__proto__);  <span class="comment">//function() &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-72e28fa1e97cb219.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-2b2dae330851635e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1、字面量方式*/</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a.__proto__ ：&quot;</span>, a.__proto__);  <span class="comment">// Object &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a.__proto__ === a.constructor.prototype：&quot;</span>, a.__proto__ === a.constructor.prototype); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*2、构造器方式*/</span></span><br><span class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> a2 = <span class="keyword">new</span> A();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a2.__proto__：&quot;</span>, a2.__proto__); <span class="comment">// A &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a2.__proto__ === a2.constructor.prototype：&quot;</span>, a2.__proto__ === a2.constructor.prototype); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*3、Object.create()方式*/</span></span><br><span class="line"><span class="keyword">var</span> a4 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> a3 = <span class="built_in">Object</span>.create(a4);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a3.__proto__：&quot;</span>, a3.__proto__); <span class="comment">// Object &#123;a: 1&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;a3.__proto__ === a3.constructor.prototype：&quot;</span>, a3.__proto__ === a3.constructor.prototype); <span class="comment">// false（此处即为图1中的例外情况）</span></span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-83632220f64d5ac8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-998ad2efae997f6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__); <span class="comment">// A &#123;&#125;（即构造器 function A 的原型对象）</span></span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__.__proto__); <span class="comment">// Object &#123;&#125;（即构造器 function Object 的原型对象）</span></span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__.__proto__.__proto__); <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-f0b646091fd42102.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><hr><p><strong>闭包的理解 ？</strong></p><p>一、变量的作用域</p><p>要理解闭包，首先必须理解 Javascript 特殊的变量作用域。<br>变量的作用域无非就是两种：全局变量和局部变量。</p><p>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(n);</span><br><span class="line">&#125;</span><br><span class="line">f1(); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure><p>另一方面，在函数外部自然无法读取函数内的局部变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;　　　　</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line">alert(n); <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>这里有一个地方需要注意，函数内部声明变量的时候，一定要使用 var 命令。<br>如果不用的话，你实际上声明了一个全局变量！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  n = <span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line">f1();</span><br><span class="line">alert(n); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure><p>二、如何从外部读取局部变量 ？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = f1();</span><br><span class="line">result(); <span class="comment">// 999</span></span><br></pre></td></tr></table></figure><p>既然 f2 可以读取 f1 中的局部变量，那么只要把 f2 作为返回值，我们不就可以在 f1 外部读取它的内部变量了吗！</p><p>三、闭包的概念</p><p>上一节代码中的 f2 函数，就是闭包。<br>我的理解是，<code>闭包就是能够读取其他函数内部变量的函数</code>。</p><p>由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成 <code>定义在一个函数内部的函数</code>。<br>所以，在本质上，<code>闭包就是将函数内部和函数外部连接起来的一座桥梁</code>。</p><p>四、闭包的用途</p><p>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p><p>怎么来理解呢 ？请看下面的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">  nAdd = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; n += <span class="number">1</span> &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = f1();</span><br><span class="line">result(); <span class="comment">// 999</span></span><br><span class="line">nAdd();</span><br><span class="line">result(); <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure><p>在这段代码中，result 实际上就是闭包 f2 函数。它一共运行了两次，第一次的值是 999，第二次的值是 1000。这证明了，函数 f1 中的局部变量 n 一直保存在内存中，并没有在 f1 调用后被自动清除。</p><p>为什么会这样呢 ？</p><p>原因就在于 f1 是 f2 的父函数，而 f2 被赋给了一个全局变量，这导致 f2 始终在内存中，而 f2 的存在依赖于 f1，因此 f1 也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。</p><p>这段代码中另一个值得注意的地方，就是 </p><ul><li>“nAdd=function(){ n+=1 }” 这一行，首先在 nAdd 前面没有使用 var 关键字，因此 nAdd 是一个全局变量，而不是局部变量。</li><li>其次，nAdd 的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以 nAdd 相当于是一个 setter，可以在函数外部对函数内部的局部变量进行操作。</li></ul><p>五、使用闭包的注意点</p><ul><li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</li><li>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</li></ul><hr><p><strong>闭包面试经典问题</strong></p><p>问题：想每次点击对应目标时弹出对应的数字下标 0~4 ，但实际是无论点击哪个目标都会弹出数字 5。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onMyLoad</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;p&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arr[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题所在：arr 中的每一项的 onclick 均为一个函数实例(Function 对象)，这个函数实例也产生了一个闭包域，这个闭包域引用了外部闭包域的变量，其 function scope 的 closure 对象有个名为 i 的引用，外部闭包域的私有变量内容发生变化，内部闭包域得到的值自然会发生改变。</p><p>解决办法一</p><p>解决思路：增加若干个对应的闭包域空间(这里采用的是匿名函数)，专门用来存储原先需要引用的内容(下标)，不过只限于基本类型(基本类型值传递，对象类型引用传递)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明一个匿名函数，若传进来的是基本类型则为值传递，故不会对实参产生影响,</span></span><br><span class="line"><span class="comment">//该函数对象有一个本地私有变量 arg(形参) ，该函数的 function scope 的 closure 对象属性有两个引用，一个是 arr，一个是 i</span></span><br><span class="line"><span class="comment">//尽管引用 i 的值随外部改变 ，但本地私有变量(形参) arg 不会受影响，其值在一开始被调用的时候就决定了</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    arr[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// onclick 函数实例的 function scope 的 closure 对象属性有一个引用 arg,</span></span><br><span class="line">      alert(arg);</span><br><span class="line">      <span class="comment">//只要 外部空间的 arg 不变，这里的引用值当然不会改变</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(i); <span class="comment">//立刻执行该匿名函数，传递下标 i (实参)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决办法二</p><p>解决思路：将事件绑定在新增的匿名函数返回的函数上，此时绑定的函数中的 function scope 中的 closure 对象的 引用 arg 是指向将其返回的匿名函数的私有变量 arg</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  arr[i].onclick = (<span class="function"><span class="keyword">function</span> (<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(arg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决办法三</p><p>使用 ES6 新语法 let 关键字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> j = i; <span class="comment">// 创建一个块级变量</span></span><br><span class="line">  arr[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(j);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>JavaScript 判断一个变量是对象还是数组 ？</strong></p><p>typeof 都返回 object</p><p>在 JavaScript 中所有数据类型严格意义上都是对象，但实际使用中我们还是有类型之分，如果要判断一个变量是数组还是对象使用 typeof 搞不定，因为它全都返回 object。</p><p>第一，使用 typeof 加 length 属性</p><p>数组有 length 属性，object 没有，而 typeof 数组与对象都返回 object，所以我们可以这么判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getDataType = <span class="function"><span class="keyword">function</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> o == <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>( <span class="keyword">typeof</span> o.length == <span class="string">&#x27;number&#x27;</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Array&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;Object&#x27;</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;param is no object type&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第二，使用 instanceof</p><p>利用 instanceof 判断数据类型是对象还是数组时应该优先判断 array，最后判断 object。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getDataType = <span class="function"><span class="keyword">function</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(o <span class="keyword">instanceof</span> <span class="built_in">Array</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Array&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( o <span class="keyword">instanceof</span> <span class="built_in">Object</span> )&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Object&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;param is no object type&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p><strong>ES5 的继承和 ES6 的继承有什么区别 ？</strong></p><p>ES5 的继承时通过 prototype 或构造函数机制来实现。</p><ul><li><code>ES5 的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到 this 上（Parent.apply(this)）</code>。</li><li><code>ES6 的继承机制完全不同，实质上是先创建父类的实例对象 this（所以必须先调用父类的 super()方法），然后再用子类的构造函数修改 this</code>。</li></ul><p>具体的：ES6 通过 class 关键字定义类，里面有构造方法，类之间通过 extends 关键字实现继承。子类必须在 constructor 方法中调用 super 方法，否则新建实例报错。因为子类没有自己的 this 对象，而是继承了父类的 this 对象，然后对其进行加工。如果不调用 super 方法，子类得不到 this 对象。</p><p>ps：super 关键字指代父类的实例，即父类的 this 对象。在子类构造函数中，调用 super 后，才可使用 this 关键字，否则报错。</p><hr><p><strong>JS 中数据类型的判断 typeof，instanceof，constructor，Object.prototype.toString.call() 的区别</strong></p><p>参考文章：</p><ol><li><a href="https://blog.csdn.net/zjy_android_blog/article/details/81023177">JS 中数据类型的判断</a></li><li><a href="https://juejin.im/post/5d99b56f518825222b5b6737">JS类型判断—typeof, constructor, instanceof, toString</a></li></ol><hr><p><strong>翻转一个字符串</strong></p><p>先将字符串转成一个数组，然后用数组的 reverse() + join() 方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&quot;hello word&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = [...str].reverse().join(<span class="string">&quot;&quot;</span>); <span class="comment">// drow olleh</span></span><br></pre></td></tr></table></figure><hr><p><strong>说说堆和栈的区别 ？</strong>　</p><p>一、堆栈空间分配区别　　</p><ul><li>栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；　　</li><li>堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由 OS 回收，分配方式倒是类似于链表。　　</li></ul><p>二、堆栈缓存方式区别</p><ul><li>栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放；　　</li><li>堆是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。　　</li></ul><p>三、堆栈数据结构区别</p><ul><li>堆（数据结构）：堆可以被看成是一棵树，如：堆排序；　　</li><li>栈（数据结构）：一种先进后出的数据结构。</li></ul><hr><h4 id="js-经典面试知识文章"><a href="#js-经典面试知识文章" class="headerlink" title="js 经典面试知识文章"></a>js 经典面试知识文章</h4><ul><li><a href="https://www.cnblogs.com/xiaozhumaopao/p/11066005.html">js 异步执行顺序</a></li><li><a href="https://github.com/biaochenxuying/blog/issues/8">JS 是单线程，你了解其运行机制吗 ？</a></li><li><a href="https://juejin.im/post/5b8de829f265da43623c4261">7 分钟理解 JS 的节流、防抖及使用场景</a></li><li><a href="https://juejin.im/post/5bb091a7e51d450e8477d9ba">JavaScript 常见的六种继承方式</a></li><li><a href="https://www.cnblogs.com/humin/p/4556820.html">JS 继承的 6 种实现方式</a></li><li><a href="https://juejin.im/post/5c23993de51d457b8c1f4ee1">九种跨域方式实现原理（完整版）</a></li><li><a href="https://juejin.im/post/5c446eb1e51d45517624f7db">常见六大Web安全攻防解析</a></li><li><a href="https://juejin.im/post/5c658309e51d4542331c442e">一文读懂 HTTP/2 及 HTTP/3 特性</a></li><li><a href="https://juejin.im/post/5ca6a109e51d4544e27e3048#heading-0">深入理解 HTTPS 工作原理</a></li><li><a href="https://juejin.im/post/5cb33660e51d456e811d2687">JavaScript 中的垃圾回收和内存泄漏</a></li><li><a href="https://juejin.im/post/5ca0c0abe51d4553a942c17d">你不知道的浏览器页面渲染机制</a></li><li><a href="https://juejin.im/post/59df4f74f265da430f311909">JavaScript设计模式</a></li><li><a href="https://segmentfault.com/a/1190000000602050">深入 javascript——构造函数和原型对象</a></li><li><a href="https://segmentfault.com/a/1190000018265172">高级函数技巧-函数柯里化</a></li><li><a href="https://blog.csdn.net/c__dreamer/article/details/79673725">JavaScript之bind及bind的模拟实现</a></li><li><a href="https://blog.csdn.net/aa5305123/article/details/83247041">Http Cookie 机制及 Cookie 的实现原理</a></li><li><a href="https://blog.csdn.net/u012129607/article/details/78117483">一个dom,点击事件触发两个事件是同步还是异步</a></li><li><a href="https://juejin.im/post/5c038df96fb9a04a0378f600">16种JavaScript设计模式（中）</a></li></ul><hr><h2 id="5-ES6"><a href="#5-ES6" class="headerlink" title="5. ES6 +"></a>5. ES6 +</h2><p><strong>ES6 函数默认参数和 es5 的实现有什么区别 ？es6 中又有什么需要注意的 ？</strong></p><p><a href="https://www.jianshu.com/p/e4ea0d43529c">ES6函数默认参数</a></p><hr><p><strong>ES6 声明变量的六种方法</strong></p><ul><li>ES5 只有两种声明变量的方法：var 和 function 。</li><li>ES6 除了添加 let 和 const 命令。</li><li>还有两种声明变量的方法：import 命令和 class 命令。</li></ul><hr><p><strong>Promise 的队列与 setTimeout 的队列有何关联 ？</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="number">4</span>) &#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; <span class="number">10000</span> ; i++ )&#123;</span><br><span class="line">        i == <span class="number">9999</span> &amp;&amp; resolve()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>为什么结果是：1, 2, 3, 5, 4；而不是：1, 2, 3, 4, 5 ？</p><p>js 里面有宏任务（macrotask）和微任务（microtask）。因为 setTimeout 是属于 macrotask 的，而整个 script 也是属于一个 macrotask，promise.then 回调是 microtask，执行过程大概如下：</p><ul><li>由于整个 script 也属于一个 macrotask，由于会先执行 macrotask 中的第一个任务，再加上 promise 构造函数因为是同步的，所以会先打印出 1 和 2；</li><li>然后继续同步执行末尾的 console.log(3) 打印出 3；</li><li>此时 setTimeout 被推进到 macrotask 队列中， promise.then 回调被推进到 microtask 队列中；</li><li>由于在第一步中已经执行完了第一个 macrotask ，所以接下来会顺序执行所有的 microtask，也就是 promise.then 的回调函数，从而打印出 5；</li><li>microtask 队列中的任务已经执行完毕，继续执行剩下的 macrotask 队列中的任务，也就是 setTimeout，所以打印出 4。</li></ul><hr><p><strong>防抖与节流</strong></p><p>节流</p><p>throttle 的中心思想在于：在某段时间内，不管你触发了多少次回调，我都只认第一次，并在计时结束时给予响应。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn 是我们需要包装的事件回调, delay 是时间间隔的阈值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// last 为上一次触发回调的时间</span></span><br><span class="line">  <span class="keyword">let</span> last = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将 throttle 处理结果当作函数返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 保留调用时的 this 上下文</span></span><br><span class="line">      <span class="keyword">let</span> context = <span class="built_in">this</span></span><br><span class="line">      <span class="comment">// 保留调用时传入的参数</span></span><br><span class="line">      <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">      <span class="comment">// 记录本次触发回调的时间</span></span><br><span class="line">      <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值</span></span><br><span class="line">      <span class="keyword">if</span> (now - last &gt;= delay) &#123;</span><br><span class="line">          <span class="comment">// 如果时间间隔大于我们设定的时间间隔阈值，则执行回调</span></span><br><span class="line">          last = now;</span><br><span class="line">          fn.apply(context, args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 throttle 来包装 scroll 的回调</span></span><br><span class="line"><span class="keyword">const</span> better_scroll = throttle(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;触发了滚动事件&#x27;</span>), <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, better_scroll)</span><br></pre></td></tr></table></figure><p>防抖</p><p>防抖的中心思想在于：我会等你到底。在某段时间内，不管你触发了多少次回调，我都只认最后一次。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn  是我们需要包装的事件回调, delay 是每次推迟执行的等待时间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定时器</span></span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将 debounce 处理结果当作函数返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 保留调用时的 this 上下文</span></span><br><span class="line">    <span class="keyword">let</span> context = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">// 保留调用时传入的参数</span></span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次事件被触发时，都去清除之前的旧定时器</span></span><br><span class="line">    <span class="keyword">if</span>(timer) &#123;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设立新定时器</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn.apply(context, args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 debounce 来包装 scroll 的回调</span></span><br><span class="line"><span class="keyword">const</span> better_scroll = debounce(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;触发了滚动事件&#x27;</span>), <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, better_scroll)</span><br></pre></td></tr></table></figure><p><code>用 Throttle 来优化 Debounce</code></p><p>思想：在 delay 时间内，我可以为你重新生成定时器；但只要 delay 的时间到了，我必须要给用户一个响应。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn 是我们需要包装的事件回调, delay 是时间间隔的阈值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// last 为上一次触发回调的时间, timer 是定时器</span></span><br><span class="line">  <span class="keyword">let</span> last = <span class="number">0</span>, timer = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 throttle 处理结果当作函数返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="comment">// 保留调用时的 this 上下文</span></span><br><span class="line">    <span class="keyword">let</span> context = <span class="built_in">this</span></span><br><span class="line">    <span class="comment">// 保留调用时传入的参数</span></span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="comment">// 记录本次触发回调的时间</span></span><br><span class="line">    <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值</span></span><br><span class="line">    <span class="keyword">if</span> (now - last &lt; delay) &#123;</span><br><span class="line">        <span class="comment">// 如果时间间隔小于我们设定的时间间隔阈值，则为本次触发操作设立一个新的定时器</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          last = now</span><br><span class="line">          fn.apply(context, args)</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果时间间隔超出了我们设定的时间间隔阈值，那就不等了，无论如何要反馈给用户一次响应</span></span><br><span class="line">        last = now</span><br><span class="line">        fn.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用新的 throttle 包装 scroll 的回调</span></span><br><span class="line"><span class="keyword">const</span> better_scroll = throttle(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;触发了滚动事件&#x27;</span>), <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, better_scroll)</span><br></pre></td></tr></table></figure><p>以上答案来自于：<a href="https://juejin.im/book/5b936540f265da0a9624b04b/section/5bb6212be51d451a3f4c3570">事件的节流（throttle）与防抖（debounce）</a></p><hr><h4 id="ES6-面试知识文章"><a href="#ES6-面试知识文章" class="headerlink" title="ES6+ 面试知识文章"></a>ES6+ 面试知识文章</h4><ul><li><a href="https://github.com/biaochenxuying/blog/issues/1">那些必会用到的 ES6 精粹</a></li><li><a href="https://blog.csdn.net/deng1456694385/article/details/83831931">promise、Generator 函数、async 函数的区别与理解</a></li><li><a href="https://blog.csdn.net/weixin_33724659/article/details/88040828">Typescript 中的 interface 和 type 到底有什么区别</a></li><li><a href="https://github.com/Geek-James/Blog/issues/27">进大厂必会 20 道 JS 原理题</a></li><li><a href="https://segmentfault.com/a/1190000016231512">AST 抽象语法树——最基础的 javascript 重点知识，99% 的人根本不了解</a></li></ul><hr><h2 id="6-webpack"><a href="#6-webpack" class="headerlink" title="6. webpack"></a>6. webpack</h2><p><strong>说下 webpack 的几大特色 ?</strong></p><ul><li>code splitting（可以自动完成）(根据代码的分割并对文件进行分块)</li><li>loader 可以处理各种类型的静态文件，并且支持串联操作</li><li>webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移</li><li>webpack 具有 requireJs 和 browserify 的功能，但仍有很多自己的新特性：</li><li>对 CommonJS 、 AMD 、ES6 的语法做了兼容</li><li>对 js、css、图片等资源文件都支持打包</li><li>串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如：提供对 CoffeeScript、ES6 的支持</li><li>有独立的配置文件 webpack.config.js</li><li>可以将代码切割成不同的 chunk，实现按需加载，降低了初始化时间</li><li>支持 SourceUrls 和 SourceMaps，易于调试</li><li>具有强大的 Plugin 接口，大多是内部插件，使用起来比较灵活</li><li>webpack 使用异步 IO 并具有多级缓存。这使得 webpack 很快且在增量编译上更加快</li></ul><hr><p><strong>说说对 webpack 的理解，优点、原理、打包的过程</strong></p><p>优点</p><ul><li>依赖管理：方便引用第三方模块、让模块更容易复用、避免全局注入导致的冲突、避免重复加载或加载不需要的模块。</li><li>合并代码：把各个分散的模块集中打包成大文件，减少 HTTP 的请求链接数，配合 UglifyJS 可以减少、优化代码的体积。</li><li>各路插件：babel 把 ES6+ 转译成 ES5 ，eslint 可以检查编译期的错误……</li></ul><p>原理</p><p>一切皆为模块，由于 webpack 并不支持除 .js 以外的文件，从而需要使用 loader 转换成 webpack 支持的模块，plugin 用于扩展 webpack 的功能，在 webpack 构建生命周期的过程在合适的时机做了合适的事情。</p><p>webpack 从构建到输出文件结果的过程</p><ul><li>解析配置参数，合并从 shell 传入和 webpack.config.js 文件的配置信息，输出最终的配置信息</li><li>注册配置中的插件，好让插件监听 webpack 构建生命周期中的事件节点，做出对应的反应</li><li>解析配置文件中 entry 入口文件，并找出每个文件依赖的文件，递归下去</li><li>在递归每个文件的过程中，根据文件类型和配置文件中 loader 找出相对应的 loader 对文件进行转换</li><li>递归结束之后得到每个文件最终的结果，根据 entry 配置生成代码 chunk</li><li>输出所有 chunk 到文件系统</li></ul><hr><ul><li><a href="https://www.cnblogs.com/chengxs/p/11022842.html">webpack 系列–浅析 webpack 的原理</a></li><li><a href="https://segmentfault.com/a/1190000020353337">一看就懂之 webpack 原理解析与实现一个简单的 webpack</a></li></ul><hr><h2 id="7-Vue"><a href="#7-Vue" class="headerlink" title="7. Vue"></a>7. Vue</h2><p><strong>对 MVC、MVP 、MVVM 的理解</strong></p><p>MVC 模式的意思是，软件可以分成三个部分。</p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-1cd8a44ad265101f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><ul><li>视图（View）：用户界面。</li><li>控制器（Controller）：业务逻辑。</li><li>模型（Model）：数据保存。</li></ul><p>各部分之间的通信方式如下。</p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-a6cb79a0ba433c50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><ul><li>View 传送指令到 Controller</li><li>Controller 完成业务逻辑后，要求 Model 改变状态</li><li>Model 将新的数据发送到 View，用户得到反馈</li><li>所有通信都是单向的（逆时针）。</li></ul><p>MVP 模式将 Controller 改名为 Presenter，同时改变了通信方向。</p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-480b96ff581e8cc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><ul><li>各部分之间的通信，都是双向的（顺时针）。</li><li>View 与 Model 不发生联系，都通过 Presenter 传递。</li><li>View 非常薄，不部署任何业务逻辑，称为 “被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。</li></ul><p>MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。</p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-51457e62e079b247.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>唯一的区别是，它采用双向绑定（data-binding）：View 的变动，自动反映在 ViewModel，反之亦然。Angular 和 Ember 都采用这种模式。</p><hr><p><strong>如何理解 Vue 是异步执行 DOM 更新的 ？</strong></p><ul><li>Vue 是异步执行 DOM 更新。</li><li>只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。</li><li>如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。</li><li>然后，在下一个的事件循环 <code>tick</code> 中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。</li></ul><p>例如，当你设置 vm.someData = ‘new value’ ，该组件不会立即重新渲染。</p><ul><li>当刷新队列时，组件会在事件循环队列清空时的下一个 <code>tick</code> 更新。</li><li>多数情况我们不需要关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。</li><li>虽然 Vue.js 通常鼓励开发人员沿着 “数据驱动” 的方式思考，避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。</li></ul><hr><p><strong>深入响应式原理</strong></p><p>如何追踪变化</p><ul><li>当你把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转 getter/setter。</li><li>Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因。</li><li>这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。这里需要注意的问题是浏览器控制台在打印数据对象时 getter/setter 的格式化并不同，所以你可能需要安装 vue-devtools 来获取更加友好的检查接口。</li><li>每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。</li><li>观察者订阅了可观察对象，当可观察对象发布事件，则就直接调度观察者的行为，所以这里观察者和可观察对象其实就产生了一个依赖的关系。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/12890819-ef98bb2a32114735.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><hr><p><strong>说下对 Virtual DOM 算法的理解 ？</strong></p><p>包括几个步骤：</p><ul><li>1、用 JavaScript 对象结构表示 DOM 树的结构，然后用这个树构建一个真正的 DOM 树，插到文档当中；</li><li>2、当状态变更的时候，重新构造一棵新的对象树，然后用新的树和旧的树进行比较，记录两棵树差异；</li><li>3、把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。</li></ul><p>Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）。</p><hr><p><strong>比较两棵虚拟 DOM 树的差异</strong></p><p>比较两棵 DOM 树的差异是 Virtual DOM 算法最核心的部分，这也是所谓的 Virtual DOM 的 diff 算法。<br>两个树的完全的 diff 算法是一个时间复杂度为 O(n^3) 的问题。但是在前端当中，你很少会跨越层级地移动 DOM 元素。</p><p>所以 Virtual DOM 只会对同一个层级的元素进行对比：</p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-56dd79f34cfb17e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>上面的 div 只会和同一层级的 div 对比，第二层级的只会跟第二层级对比。这样算法复杂度就可以达到 O(n)。</p><p>深度优先遍历，记录差异</p><p>在实际的代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记：</p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-6161f0fb0e562d6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。</p><p>Virtual DOM 算法主要是实现上面步骤的三个函数：element，diff，patch。然后就可以实际的进行使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 构建虚拟 DOM</span></span><br><span class="line"><span class="keyword">var</span> tree = el(<span class="string">&#x27;div&#x27;</span>, &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;container&#x27;</span>&#125;, [</span><br><span class="line">    el(<span class="string">&#x27;h1&#x27;</span>, &#123;<span class="attr">style</span>: <span class="string">&#x27;color: blue&#x27;</span>&#125;, [<span class="string">&#x27;simple virtal dom&#x27;</span>]),</span><br><span class="line">    el(<span class="string">&#x27;p&#x27;</span>, [<span class="string">&#x27;Hello, virtual-dom&#x27;</span>]),</span><br><span class="line">    el(<span class="string">&#x27;ul&#x27;</span>, [el(<span class="string">&#x27;li&#x27;</span>)])</span><br><span class="line">])</span><br><span class="line"><span class="comment">// 2. 通过虚拟 DOM 构建真正的 DOM</span></span><br><span class="line"><span class="keyword">var</span> root = tree.render()</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(root)</span><br><span class="line"><span class="comment">// 3. 生成新的虚拟 DOM</span></span><br><span class="line"><span class="keyword">var</span> newTree = el(<span class="string">&#x27;div&#x27;</span>, &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;container&#x27;</span>&#125;, [</span><br><span class="line">    el(<span class="string">&#x27;h1&#x27;</span>, &#123;<span class="attr">style</span>: <span class="string">&#x27;color: red&#x27;</span>&#125;, [<span class="string">&#x27;simple virtal dom&#x27;</span>]),</span><br><span class="line">    el(<span class="string">&#x27;p&#x27;</span>, [<span class="string">&#x27;Hello, virtual-dom&#x27;</span>]),</span><br><span class="line">    el(<span class="string">&#x27;ul&#x27;</span>, [el(<span class="string">&#x27;li&#x27;</span>), el(<span class="string">&#x27;li&#x27;</span>)])</span><br><span class="line">])</span><br><span class="line"><span class="comment">// 4. 比较两棵虚拟 DOM 树的不同</span></span><br><span class="line"><span class="keyword">var</span> patches = diff(tree, newTree)</span><br><span class="line"><span class="comment">// 5. 在真正的 DOM 元素上应用变更</span></span><br><span class="line">patch(root, patches)</span><br></pre></td></tr></table></figure><p>当然这是非常粗糙的实践，实际中还需要处理事件监听等；生成虚拟 DOM 的时候也可以加入 JSX 语法。这些事情都做了的话，就可以构造一个简单的 ReactJS 了。</p><hr><ul><li><a href="https://segmentfault.com/a/1190000004029168">深度剖析：如何实现一个 Virtual DOM 算法</a></li><li><a href="https://segmentfault.com/a/1190000010090659">virtual-dom(Vue实现)简析</a></li></ul><hr><p><strong>非父子组件如何通信 ？</strong></p><p>Vue 官网介绍了非父子组件通信方法：</p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-23f19b695d303662.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>在 bus.js 里面 写入下面信息 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vue;</span><br></pre></td></tr></table></figure><p>在需要通信的组件都引入 Bus.js    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">&quot;emit&quot;</span>&gt;</span><br><span class="line">    &lt;button @click=<span class="string">&quot;bus&quot;</span>&gt;按钮&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt; </span><br><span class="line">&lt;/template &gt; </span><br><span class="line"><span class="keyword">import</span> Bus <span class="keyword">from</span> <span class="string">&#x27;./bus.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">bus</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      Bus.$emit(<span class="string">&#x27;msg&#x27;</span>, <span class="string">&#x27;我要传给兄弟组件们，你收到没有&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在钩子函数中监听 msg 事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">&quot;on&quot;</span>&gt;</span><br><span class="line">      &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="keyword">import</span> Bus <span class="keyword">from</span> <span class="string">&#x27;./bus.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        message:  <span class="string">&#x27;&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;　　　</span><br><span class="line">       <span class="keyword">let</span> self = <span class="built_in">this</span></span><br><span class="line">       Bus.$on(<span class="string">&#x27;msg&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">         self.message = e</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">`传来的数据是：<span class="subst">$&#123;e&#125;</span>`</span>)</span><br><span class="line">       &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最后 p 会显示来自 $emit 传来的信息。</p><hr><p><strong>什么情况下我应该使用 Vuex ？</strong></p><ul><li>虽然 Vuex 可以帮助我们管理共享状态，但也附带了更多的概念和框架。这需要对短期和长期效益进行权衡。</li><li>如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此，如果您的应用够简单，您最好不要使用 Vuex。一个简单的 <a href="https://cn.vuejs.org/v2/guide/components.html#%E7%9B%91%E5%90%AC%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BA%8B%E4%BB%B6">global event bus</a> 就足够您所需了。</li><li>但是，如果您需要构建一个中大型单页应用，您很可能会考虑如何更好地在组件外部管理状态，Vuex 将会成为自然而然的选择。</li></ul><hr><h4 id="Vue-相关图解"><a href="#Vue-相关图解" class="headerlink" title="Vue 相关图解"></a>Vue 相关图解</h4><p>Vue 生命周期过程图解</p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-0a4ff52135d24d85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Vue 生命周期"></p><p>Vue 响应式原理</p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-95382ed485f4b937.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Vue 响应式原理"></p><p>Vue 过程图解</p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-4352ccf88d4c9e68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Vue 过程图解"></p><p>Vuex</p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-a4909259bd32ae9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Vuex"></p><h4 id="Vue-经典面试相关文章"><a href="#Vue-经典面试相关文章" class="headerlink" title="Vue 经典面试相关文章"></a>Vue 经典面试相关文章</h4><ul><li><a href="https://www.jianshu.com/p/304a44f7c11b">1. Vue 生命周期</a></li><li><a href="https://segmentfault.com/a/1190000011381906">2. 详解 Vue 生命周期</a></li><li><a href="https://juejin.im/post/5cde0b43f265da03867e78d3">3. Vue 组件间通信六种方式（完整版）</a></li><li><a href="https://blog.csdn.net/zhoulu001/article/details/79548350">4. Vue 组件之间 8 种组件通信方式总结</a></li><li><a href="https://www.jianshu.com/p/d17d8e35deda">5. Vue 学习笔记-实现一个分页组件</a></li><li><a href="https://www.jianshu.com/p/b1564296a78b">6. 30 道 Vue 面试题，内含详细讲解（涵盖入门到精通，自测 Vue 掌握程度）</a></li><li><a href="https://blog.csdn.net/qq_38021852/article/details/88640807">7. Vue 生命周期和详细的执行过程</a></li></ul><h2 id="8-React"><a href="#8-React" class="headerlink" title="8. React"></a>8. React</h2><p><a href="https://segmentfault.com/a/1190000018604138">必须要会的 50 道 React 面试题</a></p><h2 id="9-Node"><a href="#9-Node" class="headerlink" title="9. Node"></a>9. Node</h2><p><strong>为什么用 Nodejs，它有哪些优缺点 ？</strong></p><p>优点</p><ul><li>事件驱动，通过闭包很容易实现客户端的生命活期。</li><li>不用担心多线程，锁，并行计算的问题</li><li>V8 引擎速度非常快</li><li>对于游戏来说，写一遍游戏逻辑代码，前端后端通用</li></ul><p>缺点</p><ul><li>nodejs 更新很快，可能会出现版本兼容</li><li>nodejs 还不算成熟，还没有大制作</li><li>nodejs 不像其他的服务器，对于不同的链接，不支持进程和线程操作</li></ul><hr><p><strong>什么是错误优先的回调函数 ？</strong></p><p>错误优先(Error-first)的回调函数（Error-First Callback）用于同时返回错误和数据。<br>第一个参数返回错误，并且验证它是否出错；其他参数返回数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(filePath, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123; </span><br><span class="line">    <span class="comment">//handle the error</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// use the data object </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><p><strong>如何避免回调地狱 ？</strong></p><p>以下方式避免回调地狱 </p><ul><li>模块化：将回调函数转换为独立的函数</li><li>使用流程控制库，例如 [aync]</li><li>使用 Promise</li><li>使用 aync/await</li></ul><hr><p><strong>如何用 Node 监听 80 端口 ?</strong></p><ul><li>这题有陷阱！在类 Unix 系统中你不应该去监听 80 端口，因为这需要超级用户权限。因此不推荐让你的应用直接监听这个端口。</li><li>目前，如果你一定要让你的应用 80 端口的话，你可以有通过在 Node 应用的前方再添加一层反向代理（例如 nginx）来实现，如下图。否则，建议你直接监听大于 1024 的端口 </li><li>方向代理指的是以代理服务器来接收 Internet 上的连接请求，然后将请求转发给内部网络上的服务器， 并且将服务器返回的结果发送给客户端。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/12890819-6b84636562994190.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><hr><p><strong>什么是事件循环 ？</strong></p><ul><li><p>Node 采用的是单线程的处理机制(所有的 I/O 请求都采用非阻塞的工作方式)，至少从 Node.js 开发者的角度是这样的。而在底层，Node.js 借助 libuv 来作为抽象封装层，从而屏蔽不同操作系统的差异，Node 可以借助 livuv 来实现线程。下图表示 Node 和 libuv 的关系。<br><img src="https://upload-images.jianshu.io/upload_images/12890819-1fe94787d58e751d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p></li><li><p>Libuv 库负责 Node API 的执行。它将不同的任务分配给不同的线程，形成一个事件循环，以异步的方式将任务的执行结果返回给 V8 引擎。可以简单用下面这张图来表示。<br><img src="https://upload-images.jianshu.io/upload_images/12890819-8156dafea5e01e46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p></li><li><p>每一个 I/O 都需要一个回调函数 —– 一旦执行完便堆到事件循环上用于执行。</p></li></ul><hr><h2 id="10-HTTPS"><a href="#10-HTTPS" class="headerlink" title="10. HTTPS"></a>10. HTTPS</h2><p><strong>HTTP 是什么?</strong></p><ul><li>HTTP 是基于 TCP/IP（传输控制协议/因特网互联协议，又名网络通讯协议，是 Internet 最基本的协议）的关于数据如何在万维网中如何通信的协议。</li><li>HTTP 的底层是 TCP/IP。</li></ul><p>所以 GET 和 POST 的底层也是 TCP/IP，也就是说，GET/POST 都是 TCP 链接。<br>GET 和 POST 能做的事情是一样一样的。你要给 GET 加上 request body，给 POST 带上 url 参数，技术上是完全行的通的。</p><ul><li>业界不成文的规定是，(大多数) 浏览器通常都会限制 url 长度在 2K 个字节，而(大多数)服务器最多处理 64K 大小的 url。超过的部分，恕不处理。</li><li>如果你用 GET 服务，在 request body 偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然 GET 可以带 request body，也不能保证一定能被接收到哦。</li><li>GET 和 POST 本质上就是 TCP 链接，并无差别。但是由于 HTTP 的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</li></ul><hr><p><strong>HTTP 中 GET 与 POST 的区别</strong></p><ul><li>GET 在浏览器回退时是无害的，而 POST 会再次提交请求。 </li><li>GET 产生的 URL 地址可以被 Bookmark，而 POST 不可以。 </li><li>GET 请求会被浏览器主动 cache，而 POST 不会，除非手动设置。</li><li>GET 请求只能进行 url 编码，而 POST 支持多种编码方式。</li><li>GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。 </li><li>GET 请求在 URL 中传送的参数是有长度限制的，而 POST 么有。 </li><li>对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。</li><li>GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。</li><li>GET 参数通过 URL 传递，POST 放在 Request body 中。</li></ul><p>GET 和 POST 还有一个重大区别</p><p>简单的说：</p><ul><li>GET 产生一个 TCP 数据包;</li><li>POST 产生两个 TCP 数据包。</li></ul><p>长的说：</p><ul><li>对于 GET 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200 (返回数据);</li><li>而对于 POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok(返回数据)。</li></ul><p>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。<br>而在网络环境差的情况下，两次包的 TCP 在验证数据包完整性上，有非常大的优点。<br>并不是所有浏览器都会在 POST 中发送两次包，Firefox 就只发送一次。</p><hr><p><strong>浏览器缓存实现原理</strong></p><p>浏览器缓存将文件保存在客户端，好的缓存策略可以减少对网络带宽的占用，可以提高访问速度，提高用户的体验，还可以减轻服务器的负担。</p><p>当一个客户端请求 web 服务器, 请求的内容可以从以下几个地方获取：服务器、浏览器缓存中或缓存服务器中。这取决于服务器端输出的页面信息。页面文件有三种缓存状态。</p><ol><li>最新的：选择不缓存页面，每次请求时都从服务器获取最新的内容。</li><li>未过期的：在给定的时间内缓存，如果用户刷新或页面过期则去服务器请求，否则将读取本地的缓存，这样可以提高浏览速度。</li><li>过期的：也就是陈旧的页面，当请求这个页面时，必须进行重新获取。</li></ol><p>页面的缓存状态是由 http header 决定的，一个浏览器请求信息，一个是服务器响应信息。</p><p>主要包括 Pragma: no-cache、Cache-Control、 Expires、 Last-Modified、If-Modified-Since。</p><p>其中 Pragma: no-cache 由 HTTP/1.0 规定，Cache-Control 由 HTTP/1.1 规定。</p><p>Cache-Control 的主要参数：</p><ul><li>A、Cache-Control: private/public，Public 响应会被缓存，并且在多用户间共享。 Private 响应只能够作为私有的缓存，不能在用户间共享。</li><li>B、Cache-Control: no-cache，不进行缓存。</li><li>C、Cache-Control: max-age = x，缓存时间，以秒为单位。</li><li>D、Cache-Control: must-revalidate，如果页面是过期的，则去服务器进行获取。</li></ul><p>Expires：显示的设置页面过期时间。</p><p>Last-Modified：请求对象最后一次的修改时间，用来判断缓存是否过期，通常由文件的时间信息产生。</p><p>If-Modified-Since：客户端发送请求附带的信息，指浏览器缓存请求对象的最后修改日期，用来和服务器端的 Last-Modified 做比较。</p><hr><p><strong>说一下 HTTP 协议头字段说上来几个，是否尽可能详细的掌握 HTTP 协议。</strong></p><p>HTTP 协议头字段</p><ul><li>HTTP 的头域包括 <code>通用头，请求头，响应头和实体头</code> 四个部分。</li><li>每个头域由一个域名，冒号（:）和域值三部分组成。</li><li>域名是大小写无关的，域值前可以添加任何数量的空格符，头域可以被扩展为多行，在每行开始处，使用至少一个空格或制表符。</li></ul><p>HTTP 协议</p><ul><li>HTTP 是超文本传输协议的缩写，它用于传送 WWW 方式的数据。</li><li>HTTP 协议采用了请求/响应模型。</li><li>客户端向服务器发送一个请求，请求头包含请求的方法、URI、协议版本、以及包含请求修饰符、客户 信息和内容的类似于 MIME 的消息结构。</li><li>服务器以一个状态行作为响应，相应的内容包括消息协议的版本，成功或者错误编码加上包含服务器信息、实体元信息以及可能的实体内容。</li></ul><hr><p><strong>一次完整的 HTTP 事务是怎样的一个过程 ？</strong></p><ul><li>域名解析</li><li>发起 TCP 的 3 次握手 </li><li>建立 TCP 连接后发起 http 请求 </li><li>服务器响应 http 请求，浏览器得到 html 代码 </li><li>浏览器解析 html 代码，并请求 html 代码中的资源（如 js、css、图片等）</li><li>浏览器对页面进行渲染呈现给用户</li></ul><p>详情过程请看：<a href="https://juejin.im/post/5b9ba9c15188255c8320fe27">面试题之从敲入 URL 到浏览器渲染完成</a></p><hr><p><strong>HTTP 状态码知道哪些 ？</strong></p><ul><li>100 Continue 继续，一般在发送 post 请求时，已发送了 http header 之后服务端将返回此信息，表示确认，之后发送具体参数信息。 </li><li><code>200</code> OK 正常返回信息 。</li><li>201 Created 请求成功并且服务器创建了新的资源 。</li><li>202 Accepted 服务器已接受请求，但尚未处理 。</li><li>301 Moved Permanently 请求的网页已永久移动到新位置。 </li><li>302 Found 临时性重定向。 </li><li>303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。 </li><li>304 Not Modified 自从上次请求后，请求的网页未修改过。 </li><li><code>400</code> Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 </li><li><code>401</code> Unauthorized 请求未授权。 </li><li><code>403</code> Forbidden 禁止访问。 </li><li><code>404</code> Not Found 找不到如何与 URI 相匹配的资源。 </li><li><code>500</code> Internal Server Error 最常见的服务器端错误。 </li><li><code>503</code> Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</li></ul><hr><p><strong>axios 的特点有哪些 ？</strong></p><ul><li>axios 是一个基于 promise 的 HTTP 库，支持 promise 的所有 API</li><li>它可以拦截请求和响应</li><li>它可以转换请求数据和响应数据，并对响应回来的内容自动转换为 json 类型的数据</li><li>它安全性更高，客户端支持防御 XSRF</li></ul><hr><p>相关文章：</p><ul><li><a href="https://blog.csdn.net/lzj2504476514/article/details/81454754">TCP 协议和 UDP 协议的特点和区别</a></li><li><a href="https://www.cnblogs.com/NightTiger/p/11334314.html">(纯干货)HTTP／1.0／1.1／2.0的区别以及http和https的区别</a></li><li><a href="https://www.cnblogs.com/colima/p/7295771.html">http &amp; https &amp; http2.0</a></li></ul><h2 id="11-数据结构与算法"><a href="#11-数据结构与算法" class="headerlink" title="11. 数据结构与算法"></a>11. 数据结构与算法</h2><p><strong>实现两个变量交换值的方法有哪些 ？</strong></p><p>一、使用临时变量的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t; </span><br><span class="line">t = a; </span><br><span class="line">a = b; </span><br><span class="line">b = t;</span><br></pre></td></tr></table></figure><p>首先把 a 的值存储到临时变量中， <br>然后 b 赋值给 a， <br>最后拿出临时变量中的 a 值赋给 b。</p><p>二、一次加，两次减</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a + b; </span><br><span class="line">b = a - b; </span><br><span class="line">a = a - b;</span><br></pre></td></tr></table></figure><p>让 a 先变成 a 与 b 的 ‘和’（也可以换成 a 和 b 的差，一样的）， <br>‘和’ 减去 b ，巧妙的得到了 a 的变量值赋予 b ，<br>再通过 ‘和’ 减去 a 的值，得到了 b 的值赋予 a 。</p><p>三、复用对象 </p><p>把 a 先变成了一个对象， <br>这个对象保存着应该交换后的键值对， <br>最后赋值搞定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &#123; <span class="attr">a</span>: b, <span class="attr">b</span>: a &#125;; </span><br><span class="line">b = a.b; </span><br><span class="line">a = a.a;</span><br></pre></td></tr></table></figure><p>四、利用数组</p><p>和上面的方法很像，只不过对象换成了数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [a, b]; </span><br><span class="line">b = a[<span class="number">0</span>]; </span><br><span class="line">a = a[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>五、一行代码</p><p>简单粗暴一行代码交换了 a 和 b 的变量值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = [b, b = a][<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>根据运算符优先级，首先执行 b = a ，<br>此时的 b 直接得到了 a 的变量值 ，<br>然后一步数组索引让 a 得到了 b 的值（简直不能再厉害）。</p><p>六、ES6 的解构赋值语法 </p><p>最后我的方案是利用了 ES6 的解构赋值语法， <br>它允许我们提取数组和对象的值，对变量进行赋值 （旧版本浏览器不能使用ES6语法）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a, b] = [b, a];</span><br></pre></td></tr></table></figure><hr><p><strong>原生 js 实现斐波那契数列</strong></p><p>说明：<br>斐波那契数列，以兔子的繁殖的例子而引入，故又称“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、…；<br>在数学上，斐波那契数列以如下被以递归的方法定义：F(1)=1, F(2)=1, F(n)=F(n-1)+F(n-2)  (n&gt;2，n∈N*)。</p><p>一、递归方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span> || n === <span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">6</span>));</span><br></pre></td></tr></table></figure><p>二、动态规划方法（性能得到优化）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n1 = <span class="number">1</span>,</span><br><span class="line">        n2 = <span class="number">1</span>,</span><br><span class="line">        sum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i += <span class="number">1</span>) &#123;</span><br><span class="line">        sum = n1 + n2;</span><br><span class="line">        n1 = n2;    <span class="comment">// 往后移动一位数</span></span><br><span class="line">        n2 = sum</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">5</span>));</span><br></pre></td></tr></table></figure><hr><p><strong>求一个数组的最大差值</strong></p><p>原理：遍历一次数组，找到最大值和最小值，返回差值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getMaxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 定义两个变量，分别存贮最大值和最小值</span></span><br><span class="line">  <span class="keyword">let</span> maxNum = arr[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> minNum = arr[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] &gt; maxNum)&#123;</span><br><span class="line">      maxNum = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] &lt; minNum)&#123;</span><br><span class="line">      minNum = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxNum - minNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>var max = Math.max.apply(null, array)，这样就可以轻易的得到一个数组中最大的一项<br>注：在调用 apply 的时候第一个参数给了一个 null，这个是因为没有对象去调用这个方法，我们只需要用这个方法帮我们运算，得到返回的结果就行，所以就直接传递了一个 null 过去。</p><hr><p><strong>实现类似 getElementsByClassName 的功能</strong></p><p>自己实现一个函数，查找某个 DOM 节点下面的包含某个 class 的所有 DOM 节点？不允许使用原生提供的 getElementsByClassName、querySelectorAll 等原生提供 DOM 查找函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queryClassName</span>(<span class="params">node, name</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> starts = <span class="string">&#x27;(^|[ \n\r\t\f])&#x27;</span>,</span><br><span class="line">       ends = <span class="string">&#x27;([ \n\r\t\f]|$)&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> array = [],</span><br><span class="line">        regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(starts + name + ends),</span><br><span class="line">        elements = node.getElementsByTagName(<span class="string">&quot;*&quot;</span>),</span><br><span class="line">        length = elements.length,</span><br><span class="line">        i = <span class="number">0</span>,</span><br><span class="line">        element;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; length) &#123;</span><br><span class="line">        element = elements[i];</span><br><span class="line">        <span class="keyword">if</span> (regex.test(element.className)) &#123;</span><br><span class="line">            array.push(element);</span><br><span class="line">        &#125;</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>随机生成指定长度的字符串</strong></p><p>实现一个算法，随机生成指制定长度的字符串。比如给定 长度 8，输出 4ldkfg9j。</p><p>原理：可以手动指定字符库及随机字符长度 n，利用 Math.floor() 和 Math.random() 两个方法实现获取随机字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomString</span>(<span class="params">n</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz9876543210&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> tmp = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      i = <span class="number">0</span>,</span><br><span class="line">      l = str.length;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    tmp += str.charAt(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * l));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = randomString;</span><br></pre></td></tr></table></figure><hr><p><strong>判断一个单词是否是回文 ？</strong></p><p>回文是指把相同的词汇或句子，在下文中调换位置或颠倒过来，产生首尾回环的情趣，叫做回文，也叫回环。比如 mamam redivider 。</p><p>很多人拿到这样的题目非常容易想到用 for 将字符串颠倒字母顺序然后匹配就行了。</p><p>其实重要的考察的就是对于 reverse 的实现。</p><p>其实我们可以利用现成的函数，将字符串转换成数组，这个思路很重要，我们可以拥有更多的自由度去进行字符串的一些操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkPalindrom</span>(<span class="params">str</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> str == str.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>二分查找算法</strong></p><p>建立在已经排好序的情况下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binarySearch</span>(<span class="params">arr, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> end = arr.length - <span class="number">1</span>,</span><br><span class="line">        start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">var</span> middle = <span class="built_in">Math</span>.floor((start + end) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[middle] &gt; data) &#123;</span><br><span class="line">            end = middle - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[middle] &lt; data) &#123;</span><br><span class="line">            start = middle + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">console</span>.log(binarySearch(arr, <span class="number">2</span>));</span><br></pre></td></tr></table></figure><hr><p><strong>写一个方法将数组换成前端更易解析的树状结构</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getTree</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newData = [],</span><br><span class="line">        hash = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hash[data[i].province]) &#123;</span><br><span class="line">            hash[data[i].province] = &#123;</span><br><span class="line">                <span class="string">&#x27;province&#x27;</span>: data[i].province</span><br><span class="line">            &#125;;</span><br><span class="line">            hash[data[i].province][<span class="string">&#x27;city&#x27;</span>] = [&#123;</span><br><span class="line">                <span class="string">&#x27;name&#x27;</span>: data[i].city,</span><br><span class="line">                <span class="string">&#x27;code&#x27;</span>: data[i].code</span><br><span class="line">            &#125;]</span><br><span class="line">            newData.push(hash[data[i].province]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hash[data[i].province].province == data[i].province) &#123;</span><br><span class="line">            hash[data[i].province][<span class="string">&#x27;city&#x27;</span>].push(&#123;</span><br><span class="line">                <span class="string">&#x27;name&#x27;</span>: data[i].city,</span><br><span class="line">                <span class="string">&#x27;code&#x27;</span>: data[i].code</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newData;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> data = [&#123;</span><br><span class="line">    <span class="string">&#x27;province&#x27;</span>: <span class="string">&#x27;浙江&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;温州&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;code&#x27;</span>: <span class="string">&#x27;10010&#x27;</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="string">&#x27;province&#x27;</span>: <span class="string">&#x27;浙江&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;杭州&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;code&#x27;</span>: <span class="string">&#x27;10011&#x27;</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="string">&#x27;province&#x27;</span>: <span class="string">&#x27;安徽&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;合肥&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;code&#x27;</span>: <span class="string">&#x27;10012&#x27;</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="string">&#x27;province&#x27;</span>: <span class="string">&#x27;安徽&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;马鞍山&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;code&#x27;</span>: <span class="string">&#x27;10013&#x27;</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="string">&#x27;province&#x27;</span>: <span class="string">&#x27;浙江&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;宁波&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;code&#x27;</span>: <span class="string">&#x27;10014&#x27;</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(getTree(data));</span><br></pre></td></tr></table></figure><hr><p><strong>数组去重</strong></p><p>一、 使用 ES6 的 Set 去除数组的重复元素</p><p>Array.from() 方法可以将 Set 结构转化为数组结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupe</span>(<span class="params">array</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array)); </span><br><span class="line">&#125; </span><br><span class="line">dedupe([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure><p>二：扩展运算符（…），内部使用 for…of 循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> unique = [...new <span class="built_in">Set</span>(arr)];</span><br></pre></td></tr></table></figure><p>三：采用对象数组方法去重</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> newArr = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!obj[arr[i]])&#123;</span><br><span class="line">            obj[arr[i]] = <span class="number">1</span>;</span><br><span class="line">            newArr.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>字符串反转</strong></p><p>1、split() 字符串转成数组；<br>2、reverse() 翻转数组；<br>3、join() 数组转化成字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++)&#123;</span><br><span class="line">        <span class="keyword">return</span> str.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>产生随机数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">random</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">&#x27;123asdasdasrwer&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> obj = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> l = str.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">       <span class="keyword">return</span> obj += str.charAt(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*l));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>获取地址栏中某个参数的值</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUrl</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> url = <span class="built_in">window</span>.location.href();</span><br><span class="line">    <span class="keyword">let</span> Url = url.split(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(Url[<span class="number">0</span>] == url)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> arr = Url[<span class="number">1</span>].split(<span class="string">&#x27;&amp;&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">       <span class="keyword">let</span> arg = arr[i].split(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        obj[arg[<span class="number">0</span>]] = arg[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> href = getUrl();</span><br><span class="line"><span class="built_in">console</span>.log(href[<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p><strong>统计字符中出现次数最多的字母</strong></p><p>原理：这个和数组去重类似，也是利用一个对象 obj，将数组元素作为对象的属性名，如果不存在该属性名，则值赋为 1，如果存在，则值加 1。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findMaxDuplicateChar</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> charObj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 利用String的charAt()方法获取各个字符; charAt() 方法可返回指定位置的字符</span></span><br><span class="line">        <span class="keyword">if</span>(!charObj[str.charAt(i)]) &#123;</span><br><span class="line">            charObj[str.charAt(i)] = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            charObj[str.charAt(i)] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> maxChar = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            maxValue = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> charObj) &#123;</span><br><span class="line">        <span class="comment">// 在obj对象中寻找值最大的那个属性</span></span><br><span class="line">        <span class="keyword">if</span>(charObj[k] &gt;= maxValue) &#123;</span><br><span class="line">            maxChar = k;</span><br><span class="line">            maxValue = charObj[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxChar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试</title>
      <link href="/ZJY.github.io/2021/01/20/%E9%9D%A2%E8%AF%95/"/>
      <url>/ZJY.github.io/2021/01/20/%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="1-webpack优化："><a href="#1-webpack优化：" class="headerlink" title="1.webpack优化："></a>1.webpack优化：</h3><ul><li><p>优化开发体验（提升开发效率）</p><ul><li>优化构建速度 （配置时相关路径尽量写绝对路径，以减少查找，代码中写导入语句时，确定文件时带上文件后缀，以避免查找）</li><li>使用DllPlugin (动态链接库,原因在于包含大量复用模块的动态链接库只需要编译一次，在之后的构建过程中被动态链接库包含的模块将不会在重新编译，而是直接使用动态链接库中的代码)</li><li>使用HappyPack （在整个 Webpack 构建流程中，最耗时的流程可能就是 Loader 对文件的转换操作了，因为要转换的文件数据巨多，而且这些转换操作都只能一个个挨着处理。HappyPack的核心原理就是把这部分任务分解到多个进程去并行处理，从而减少了总的构建时间。）</li><li>使用ParallelUglifyPlugin (ParallelUglifyPlugin 会开启多个子进程，把对多个文件的压缩工作分配给多个子进程去完成，每个子进程其实还是通过 UglifyJS去压缩代码，但是变成了并行执行)</li></ul></li><li><p>优化使用体验</p><ul><li>使用自动刷新（使用 webpack 模块负责监听文件，webpack-dev-server 模块则负责刷新浏览器。）</li><li>使用模块热替换 （hot）</li></ul></li><li><p>优化输出质量</p><ul><li>减少用户能感知到的加载时间，也就是首屏加载<ul><li>区分环境 （开发和线上环境 代码压缩和提示日志）</li><li>压缩代码 （UglifyJsPlugin：通过封装 UglifyJS 实现压缩。ParallelUglifyPlugin：多进程并行处理压缩）</li><li>CDN加速 （CDN 又叫内容分发网络，通过把资源部署到世界各地，用户在访问时按照就近原则从离用户最近的服务器获取资源，从而加速资源的获取速度。要给网站接入 CDN，需要把网页的静态资源上传到 CDN 服务上去，在服务这些静态资源的时候需要通过 CDN 服务提供的 URL 地址去访问）</li><li>使用Tree Shaking (Tree Shaking 可以用来剔除 JavaScript 中用不上的死代码)</li><li>提取公共代码</li><li>按需加载</li></ul></li></ul></li></ul><h3 id="2-webpack如何区分环境？"><a href="#2-webpack如何区分环境？" class="headerlink" title="2.webpack如何区分环境？"></a>2.webpack如何区分环境？</h3><p>具体区分方法很简单，在源码中通过如下方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;你正在线上环境&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;你正在使用开发环境&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其大概原理是借助于环境变量的值去判断执行哪个分支</p><h3 id="3-小程序的生命周期和路由以及setData原理"><a href="#3-小程序的生命周期和路由以及setData原理" class="headerlink" title="3.小程序的生命周期和路由以及setData原理"></a>3.小程序的生命周期和路由以及setData原理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">onLaunch</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onLaunch监听小程序初始化&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">onShow</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onShow监听小程序显示&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">onHide</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onHide监听小程序隐藏&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小程序的生命周期函数的调用顺序为：onLaunch&gt;onShow&gt;onHide</p><p>页面生命周期：<br>页面生命周期函数就是当你每进入/切换到一个新的页面的时候，就会调用的生命周期函数。Page(Object) 函数用来注册一个页面。接受一个Object类型参数，其指定页面的初始数据、生命周期回调、事件处理函数等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">onLoad</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onLoad监听页面加载:首次进入页面加载时触发，可以在 onLoad 的参数中获取打开当前页面路径中的参数。&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">onReady</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onReady监听页面初次渲染完成&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">onShow</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onShow监听页面显示:加载完成后、后台切到前台或重新进入页面时触发&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">onHide</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onHide监听页面隐藏&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">onUnload</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onUnload监听页面卸载&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生命周期函数的调用顺序为：onLoad&gt;onShow&gt;onReady。</p><p>首次进入小程序会先触发应用生命周期中onLaunch方法和onShow方法，其次触发页面生命周期中onLoad、onShow和onReady方法。</p><p>前台切换到后台时，先触发页面生命周期中onHide方法，再触发应用生命周期的onHide方法。</p><p>后台切换到前台时，先触发应用生命周期中onShow方法，再触发页面生命周期的onShow方法。</p><p>setData:setData 函数用于将数据从逻辑层发送到视图层（异步），同时改变对应的 this.data 的值（同步）</p><p>setData工作原理<br>小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。当前，视图层和逻辑层的数据传输，实际上通过两边提供的 evaluateJavascript 所实现。即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。</p><p>而 evaluateJavascript 的执行会受很多方面的影响，数据到达视图层并不是实时的。</p><h3 id="4-哪些css属性可以继承？"><a href="#4-哪些css属性可以继承？" class="headerlink" title="4.哪些css属性可以继承？"></a>4.哪些css属性可以继承？</h3><p>可继承的有： font-size font-family color、<br>不可继承的有：border、padding、margin、width、height<br>与字体相关的样式通常可以继承，与尺寸相关的样式通常不能继承</p><h3 id="5-call-apply-bind都是用来重新定义this对象的"><a href="#5-call-apply-bind都是用来重新定义this对象的" class="headerlink" title="5.call/apply/bind都是用来重新定义this对象的"></a>5.call/apply/bind都是用来重新定义this对象的</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;wang&#x27;</span>,age = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;zhang&#x27;</span>,</span><br><span class="line">    objAag: <span class="built_in">this</span>.age,</span><br><span class="line">    myFun:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;年龄&#x27;</span> + <span class="built_in">this</span>.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.objAag; <span class="comment">//17</span></span><br><span class="line">obj.myFun(); <span class="comment">//zhang年龄undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用call/apply/bind</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db = &#123;</span><br><span class="line">    name:<span class="string">&#x27;dema&#x27;</span>,</span><br><span class="line">    age: <span class="number">99</span></span><br><span class="line">&#125;</span><br><span class="line">obj.myFun.call(db); <span class="comment">// dema年龄99</span></span><br><span class="line">obj.myFun.apply(db); <span class="comment">// dema年龄99</span></span><br><span class="line">obj.myFun.bind(db)(); <span class="comment">// dema年龄99</span></span><br></pre></td></tr></table></figure><p>以上除了bind多了个（）外，结果都一致，由此可知，bind返回的是一个新函数，必须调用它能执行</p><p>call/apply/bind 传参数区别</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;wang&#x27;</span>,age = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;zhang&#x27;</span>,</span><br><span class="line">    objAag: <span class="built_in">this</span>.age,</span><br><span class="line">    myFun:<span class="function"><span class="keyword">function</span>(<span class="params">fm,t</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;年龄&#x27;</span> + <span class="built_in">this</span>.age,<span class="string">&#x27;来自 &#x27;</span>+ fm+<span class="string">&#x27; 去往&#x27;</span>+t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> db = &#123;</span><br><span class="line">    name:<span class="string">&#x27;dema&#x27;</span>,</span><br><span class="line">    age: <span class="number">99</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.myFun.call(db,<span class="string">&#x27;成都&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>); <span class="comment">//dema年龄99 来自 成都 去往上海</span></span><br><span class="line">obj.myFun.apply(db,[<span class="string">&#x27;成都&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>]); <span class="comment">//dema年龄99 来自 成都 去往上海</span></span><br><span class="line">obj.myFun.bind(db,[<span class="string">&#x27;成都&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>])(); <span class="comment">//dema年龄99 来自 成都,上海 去往undefined</span></span><br><span class="line">obj.myFun.bind(db,<span class="string">&#x27;成都&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>)(); <span class="comment">//dema年龄99 来自 成都 去往上海</span></span><br><span class="line">obj.myFun.bind(db)(<span class="string">&#x27;成都&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>); <span class="comment">// dema年龄99 来自 成都 去往上海</span></span><br></pre></td></tr></table></figure><p>call 、bind 、 apply 这三个函数的第一个参数都是 this 的指向对象,第二个参数：<br>call的参数直接放进去，多个参数用逗号分隔<br>apply的第二个参数是数组<br>bind 除了返回是函数以外，它 的参数和 call 一样</p><h3 id="6-z-index属性"><a href="#6-z-index属性" class="headerlink" title="6.z-index属性"></a>6.z-index属性</h3><p>z-index 属性指定一个元素的堆叠顺序。</p><p>拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。</p><p>注释：元素可拥有负的 z-index 属性值。</p><p>注释：Z-index 仅能在定位元素上奏效（例如 position:absolute, position:relative, or position:fixed)</p><p>可能的值：</p><ul><li>auto ：默认。堆叠顺序与父元素相等。</li><li>number ：设置元素的堆叠顺序。</li><li>inherit： 规定应该从父元素继承 z-index 属性的值。</li></ul><p>默认的 z-index 是 0</p><h3 id="7-vue生命周期"><a href="#7-vue生命周期" class="headerlink" title="7.vue生命周期"></a>7.vue生命周期</h3><ul><li>beforeCreate：在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用</li><li>created：在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，property 和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el property 目前尚不可用。一般creadted钩子函数主要是用来初始化数据。</li><li>beforeMount：在挂载开始之前被调用：相关的 render 函数首次被调用。</li><li>mounted： 实例被挂载后调用，这时 el 被新创建的 vm.$el 替换了。如果根实例挂载到了一个文档内的元素上，当 mounted 被调用时 vm.$el 也在文档内。注意 mounted 不会保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 mounted 内部使用 vm.$nextTick。该钩子函数是在挂在完成以后也就是模板渲染完成以后才会被调用</li><li>beforeUpdate： 数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</li><li>updated:由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。</li><li>activated：被 keep-alive 缓存的组件激活时调用。</li><li>deactivated：被 keep-alive 缓存的组件停用时调用</li><li>beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用</li><li>destroyed： 实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁</li><li>errorCaptured：当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。</li></ul><h3 id="8-JavaScript的let和const"><a href="#8-JavaScript的let和const" class="headerlink" title="8.JavaScript的let和const"></a>8.JavaScript的let和const</h3><p>ES2015(ES6) 新增加了两个重要的 JavaScript 关键字: let 和 const。</p><p>let 声明的变量只能let命令所在代码块内有效<br>const声明一个只读的常量，一旦声明了值，该值就不能改变。</p><p>在 ES6 之前，JavaScript 只有两种作用域： 全局变量 与 函数内的局部变量。</p><p>全局变量：</p><p>在函数外声明的变量是全局的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> carName = <span class="string">&quot;Volvo&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这里可以使用 carName 变量</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里也可以使用 carName 变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局变量在js程序的任何地方都可用</p><p>局部变量：<br>在函数内部声明的变量的作用域是局部的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里不能使用 carName 变量</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> carName = <span class="string">&quot;Volvo&quot;</span>;</span><br><span class="line">    <span class="comment">// 这里可以使用 carName 变量</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这里不能使用 carName 变量</span></span><br></pre></td></tr></table></figure><p>函数内使用var声明的变量只能在函数内部可用，没有用var声明的变量全局可用</p><p>javascript的块级作用域：<br>使用var声明的变量不具有块级作用域的特性，在{}外仍然能使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">2</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里可以使用 x 变量</span></span><br></pre></td></tr></table></figure><p>在es6之前没有块级作用域的概念<br>es6可以使用let关键字来实现块级作用域<br>let 声明的变量只在 let 命令所在的代码块 {} 内有效，在 {} 之外不能访问。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里不能使用 x 变量</span></span><br></pre></td></tr></table></figure><p>重新定义变量：</p><p>使用var关键字重新声明变量会带来问题<br>在块中重新声明变量也会重新声明块外的变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 这里输出 x 为 10</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 这里输出 x 为 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里输出 x 为 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>let 关键字就可以解决这个问题，因为它只在 let 命令所在的代码块 {} 内有效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 这里输出 x 为 10</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 这里输出 x 为 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里输出 x 为 10</span></span><br></pre></td></tr></table></figure><p>循环作用域：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一些代码...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里输出 i 为 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一些代码...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里输出 i 为 5</span></span><br></pre></td></tr></table></figure><p>在第一个实例中，使用了 var 关键字，它声明的变量是全局的，包括循环体内与循环体外。</p><p>在第二个实例中，使用 let 关键字， 它声明的变量作用域只在循环体内，循环体外的变量不受影响。</p><p>局部变量：</p><p>在函数体内使用 var 和 let 关键字声明的变量有点类似。</p><p>它们的作用域都是 局部的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 var</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> carName = <span class="string">&quot;Volvo&quot;</span>;   <span class="comment">// 局部作用域</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 let</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> carName = <span class="string">&quot;Volvo&quot;</span>;   <span class="comment">//  局部作用域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局变量<br>在函数体外或代码块外使用 var 和 let 关键字声明的变量也有点类似。</p><p>它们的作用域都是 全局的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 var</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;       <span class="comment">// 全局作用域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 let</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">2</span>;       <span class="comment">// 全局作用域</span></span><br></pre></td></tr></table></figure><p>HTML 代码中使用全局变量:<br>在JavaScript中，全局作用域是针对JavaScript环境<br>在html中，全局作用域是指window对象</p><p>使用var关键字声明的全局作用域变量是属于 window 对象:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> carName = <span class="string">&quot;Volvo&quot;</span>;</span><br><span class="line"><span class="comment">// 可以使用 window.carName 访问变量</span></span><br></pre></td></tr></table></figure><p>使用let声明的全局作用域变量不属于window对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> carName = <span class="string">&quot;Volvo&quot;</span>;</span><br><span class="line"><span class="comment">// 不能使用 window.carName 访问变量</span></span><br></pre></td></tr></table></figure><p>重置变量：</p><p>使用var关键字声明的变量任何地方都可以修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// x 为 2</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 现在 x 为 3</span></span><br></pre></td></tr></table></figure><p>在相同的作用域下，不能使用let来重置var声明的变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;       <span class="comment">// 合法</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">3</span>;       <span class="comment">// 不合法</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">4</span>;   <span class="comment">// 合法</span></span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>   <span class="comment">// 不合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在相同的作用域下，不能使用let重置let声明的变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">2</span>;       <span class="comment">// 合法</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">3</span>;       <span class="comment">// 不合法</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">4</span>;   <span class="comment">// 合法</span></span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;   <span class="comment">// 不合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在相同作用域下，不能使用var关键字来重置let声明的变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">2</span>;       <span class="comment">// 合法</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;       <span class="comment">// 不合法</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">4</span>;   <span class="comment">// 合法</span></span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">5</span>;   <span class="comment">// 不合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>let 关键字在不同作用域，或不同块级作用域中是可以重新声明赋值的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">2</span>;       <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">3</span>;   <span class="comment">// 合法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">4</span>;   <span class="comment">// 合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量提升：</p><p>js中，var声明的变量可以先使用后声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在这里可以使用 carName 变量</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> carName;</span><br></pre></td></tr></table></figure><p>let声明的变量不可以先使用再声明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在这里不可以使用 carName 变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> carName;</span><br></pre></td></tr></table></figure><p>const关键字<br>const用来声明一个或多个常量值，声明时必须进行初始化，且初始化后不可以再修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.141592653589793</span>;</span><br><span class="line">PI = <span class="number">3.14</span>;      <span class="comment">// 报错</span></span><br><span class="line">PI = PI + <span class="number">10</span>;   <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>const和let定义变量的类似：</p><ul><li>二者都是块级作用域</li><li>都不能和所在作用域内其他变量或函数同名</li></ul><p>两者区别：</p><ul><li>const声明变量必须初始化，let可以不用初始化</li><li>const初始化后不可以修改，let初始化后可以修改</li></ul><p>const并非是一个真正的常量<br>const 的本质: const 定义的变量并非常量，并非不可变，它定义了一个常量引用一个值。使用 const 定义的对象或者数组，其实是可变的。下面的代码并不会报错：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建常量对象</span></span><br><span class="line"><span class="keyword">const</span> car = &#123;<span class="attr">type</span>:<span class="string">&quot;Fiat&quot;</span>, <span class="attr">model</span>:<span class="string">&quot;500&quot;</span>, <span class="attr">color</span>:<span class="string">&quot;white&quot;</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 修改属性:</span></span><br><span class="line">car.color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 添加属性</span></span><br><span class="line">car.owner = <span class="string">&quot;Johnson&quot;</span>;</span><br></pre></td></tr></table></figure><p>但不能对常量对象重新赋值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> car = &#123;<span class="attr">type</span>:<span class="string">&quot;Fiat&quot;</span>, <span class="attr">model</span>:<span class="string">&quot;500&quot;</span>, <span class="attr">color</span>:<span class="string">&quot;white&quot;</span>&#125;;</span><br><span class="line">car = &#123;<span class="attr">type</span>:<span class="string">&quot;Volvo&quot;</span>, <span class="attr">model</span>:<span class="string">&quot;EX60&quot;</span>, <span class="attr">color</span>:<span class="string">&quot;red&quot;</span>&#125;;    <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>在相同的作用域或块级作用域中，不能使用 const 关键字来重置 var 和 let关键字声明的变量:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;         <span class="comment">// 合法</span></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">2</span>;       <span class="comment">// 不合法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span>;     <span class="comment">// 合法</span></span><br><span class="line">    <span class="keyword">const</span> x = <span class="number">2</span>;   <span class="comment">// 不合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在相同的作用域或块级作用域中，不能使用 const 关键字来重置 const 关键字声明的变量:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">2</span>;       <span class="comment">// 合法</span></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">3</span>;       <span class="comment">// 不合法</span></span><br><span class="line">x = <span class="number">3</span>;             <span class="comment">// 不合法</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;         <span class="comment">// 不合法</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">3</span>;         <span class="comment">// 不合法</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> x = <span class="number">2</span>;   <span class="comment">// 合法</span></span><br><span class="line">    <span class="keyword">const</span> x = <span class="number">3</span>;   <span class="comment">// 不合法</span></span><br><span class="line">    x = <span class="number">3</span>;         <span class="comment">// 不合法</span></span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">3</span>;     <span class="comment">// 不合法</span></span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">3</span>;     <span class="comment">// 不合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>const 关键字在不同作用域，或不同块级作用域中是可以重新声明赋值的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">2</span>;       <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> x = <span class="number">3</span>;   <span class="comment">// 合法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> x = <span class="number">4</span>;   <span class="comment">// 合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>const 关键字定义的变量则不可以在使用后声明，也就是变量需要先声明再使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">carName = <span class="string">&quot;Volvo&quot;</span>;    <span class="comment">// 在这里不可以使用 carName 变量</span></span><br><span class="line"><span class="keyword">const</span> carName = <span class="string">&quot;Volvo&quot;</span></span><br></pre></td></tr></table></figure><h3 id="9-箭头函数"><a href="#9-箭头函数" class="headerlink" title="9.箭头函数"></a>9.箭头函数</h3><p>ES6 之前，JavaScript 的 this 对象一直很令人头大，回调函数，经常看到 var self = this 这样的代码，为了将外部 this 传递到回调函数中，那么有了箭头函数，就不需要这样做了，直接使用 this 就行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">&#x27;sayHello&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line">Person.sayHello();  <span class="comment">// 20</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> Person1 = &#123;</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">&#x27;sayHello&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line">Person1.sayHello();  <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>当我们需要维护this上下文的时候，使用箭头函数</p><p>箭头函数：<br>箭头函数提供了一种更加简洁的函数书写方式。基本语法是：<br>参数 =&gt; 函数体</p><p>基本用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>);  <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>当箭头函数没有参数或者有多个参数，要用 () 括起来:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">a,b</span>) =&gt;</span> a+b;</span><br><span class="line">f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">//8</span></span><br></pre></td></tr></table></figure><p>当箭头函数函数体有多行语句，用 {} 包裹起来，表示代码块，当只有一行语句，并且需要返回结果时，可以省略 {} , 结果会自动返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">a,b</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">let</span> result = a+b;</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p>当箭头函数要返回对象的时候，为了区分于代码块，要用 () 将对象包裹起来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">id,name</span>) =&gt;</span> &#123;<span class="attr">id</span>: id, <span class="attr">name</span>: name&#125;;</span><br><span class="line">f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">// SyntaxError: Unexpected token :</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">id,name</span>) =&gt;</span> (&#123;<span class="attr">id</span>: id, <span class="attr">name</span>: name&#125;);</span><br><span class="line">f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">// &#123;id: 6, name: 2&#125;</span></span><br></pre></td></tr></table></figure><p>注意点：没有 this、super、arguments 和 new.target 绑定。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 箭头函数里面没有 this 对象，</span></span><br><span class="line">  <span class="comment">// 此时的 this 是外层的 this 对象，即 Window </span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">func(<span class="number">55</span>)  <span class="comment">// Window </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> func = <span class="function">() =&gt;</span> &#123;    </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">func(<span class="number">55</span>);  <span class="comment">// ReferenceError: arguments is not defined</span></span><br></pre></td></tr></table></figure><p>箭头函数体中的 this 对象，是定义函数时的对象，而不是使用函数时的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 定义时，this 绑定的是 fn 中的 this 对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// fn 的 this 对象为 &#123;a: 19&#125;</span></span><br><span class="line">fn.call(&#123;<span class="attr">a</span>: <span class="number">18</span>&#125;);  <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>不可以作为构造函数，也就是不能使用 new 命令，否则会报错</p><h3 id="10-vuex页面刷新数据保持不变"><a href="#10-vuex页面刷新数据保持不变" class="headerlink" title="10.vuex页面刷新数据保持不变"></a>10.vuex页面刷新数据保持不变</h3><p>用vuex做全局状态管理的时候，页面刷新，数据会丢失，是因为store中的数据是保存在运行内存中的，页面刷新时就会重新加载vue实例，store会被重新赋值。<br>解决方法：</p><p>方案一：<br>由于state中的数据是响应式的，而数据又是通过mutation来修改的，所以在mutation修改state数据时调用localStorage.setItem()方法来进行数据的存储：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        orderList:[],</span><br><span class="line">        menuList:[]</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        <span class="function"><span class="title">orderList</span>(<span class="params">state,data</span>)</span>&#123;</span><br><span class="line">            state.orderList = data;</span><br><span class="line">            <span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;orderList&#x27;</span>, <span class="built_in">JSON</span>.stringify(data))</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">menuList</span>(<span class="params">state,data</span>)</span>&#123;</span><br><span class="line">            state.menuList = data;</span><br><span class="line">            <span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;menuList&#x27;</span>, <span class="built_in">JSON</span>.stringify(data))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在页面加载的时候再通过localStorage.getItem()方法将值取出放回vuex，可在app.vue的created方法中写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.localStorage.getItem(<span class="string">&#x27;orderList&#x27;</span>))&#123;</span><br><span class="line">        <span class="built_in">this</span>.$store.replaceState(<span class="built_in">Object</span>.assign(&#123;&#125;, <span class="built_in">this</span>.$store.state, <span class="built_in">JSON</span>.parse(<span class="built_in">window</span>.localStorage.getItem(<span class="string">&#x27;orderList&#x27;</span>))))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案二：<br>方案一能够顺利解决问题，但不断触发localStorage.setItem()方法对性能不是特别友好，而且一直将数据同步到localStorage中似乎就没必要再用vuex做状态管理，直接用localStorage即可，于是对以上解决方法进行了改进，通过监听beforeunload事件来进行数据的localStorage存储，beforeunload事件在页面刷新时进行触发，具体做法是在App.vue的created()周期函数中下如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.localStorage.getItem(<span class="string">&#x27;orderList&#x27;</span>))&#123;</span><br><span class="line">        <span class="built_in">this</span>.$store.replaceState(<span class="built_in">Object</span>.assign(&#123;&#125;, <span class="built_in">this</span>.$store.state, <span class="built_in">JSON</span>.parse(<span class="built_in">window</span>.localStorage.getItem(<span class="string">&#x27;orderList&#x27;</span>))))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;beforeunload&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.localStorage.setItem(<span class="string">&quot;orderList&quot;</span>,<span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>.$store.state.orderList))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-公众号openid和unionid的区别"><a href="#11-公众号openid和unionid的区别" class="headerlink" title="11.公众号openid和unionid的区别"></a>11.公众号openid和unionid的区别</h3><ul><li>微信openid和unionid长度是不一样的：openid=28，unionid=29</li><li>openid同一用户同一应用唯一，unionid同一用户不同应用唯一<ul><li>这里的不同应用是指在同一微信开发平台下的不同应用</li><li>为了识别用户，每个用户针对每个公众号会产生一个安全的openid</li><li>一个用户虽然对多个公众号和应用有多个不同的openid，但他对所有这些同一开放平台账号下的公众号和应用，只有一个unionid</li></ul></li></ul><h3 id="12-axios统一封装"><a href="#12-axios统一封装" class="headerlink" title="12.axios统一封装"></a>12.axios统一封装</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> _axios = axios.create();</span><br><span class="line"></span><br><span class="line">_axios.default.baseURL = <span class="string">&#x27;requesturl&#x27;</span>;</span><br><span class="line">_axios.interceptors.request.use(<span class="function"><span class="keyword">function</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 在发送请求前做些什么</span></span><br><span class="line">    config =&gt; &#123;</span><br><span class="line">        config.withCredentials = <span class="literal">true</span>; <span class="comment">// 允许携带token ,这个是解决跨域产生的相关问题</span></span><br><span class="line">        config.timeout = <span class="number">12000</span>;</span><br><span class="line">        config.headers = &#123;</span><br><span class="line">            <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    config.headers[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="string">`<span class="subst">$&#123;<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;token&#x27;</span>)&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加相应拦截器</span></span><br><span class="line">_axios.interceptors.response.use(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(response.data.code == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> response.data</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(response.data.message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 对相应错误做些什么</span></span><br><span class="line">    <span class="function"><span class="title">swtich</span>(<span class="params">error.response.status</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">401</span>:</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">403</span>:</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">500</span>:</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> _axios;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用axios</span></span><br><span class="line"><span class="keyword">import</span> _axios <span class="keyword">from</span> <span class="string">&#x27;./axios&#x27;</span>;</span><br><span class="line"><span class="comment">// 接口定义</span></span><br><span class="line"><span class="function"><span class="title">getList</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _axios(&#123;</span><br><span class="line">        method: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">        url:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        params:&#123;data&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">postList</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _axios(&#123;</span><br><span class="line">        method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">        url:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        data:&#123;data&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 页面接口调用</span></span><br><span class="line">getList(data).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>12.webpack</p><p>loader和plugin的使用</p><ul><li>loader：下载、使用</li><li>plugin: 下载、引入、使用</li></ul><p>配置文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;resolve&#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">&#x27;./src/index.js&#x27;</span>, <span class="comment">//打包的入口文件</span></span><br><span class="line">    output:&#123;</span><br><span class="line">        <span class="comment">// 输出的文件名，以及文件路径</span></span><br><span class="line">        filename: <span class="string">&#x27;build.js&#x27;</span>, <span class="comment">//输出的文件名</span></span><br><span class="line">        path: resolve(__dirname,<span class="string">&#x27;build&#x27;</span>) <span class="comment">//// 当前路径(__dirname)的build文件夹</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        <span class="comment">// 在此配置loader</span></span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>, <span class="comment">//表示匹配以css结尾的文件</span></span><br><span class="line">                use:[</span><br><span class="line">                    <span class="comment">// 使用以下loader进行编译从下往上</span></span><br><span class="line">                    <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test:<span class="regexp">/\.(png|svg|jpg|gif)&amp;/</span>,</span><br><span class="line">                use:[</span><br><span class="line">                    <span class="string">&#x27;file-loader&#x27;</span> <span class="comment">//在Css中有背景和图标等图片，需要安装file-loader来处理</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="comment">// 在此配置插件，插件的作用比loader要强，如压缩编译转换等</span></span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin(), <span class="comment">//清理 /dist 文件夹</span></span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">           title: <span class="string">&#x27;Output Management&#x27;</span></span><br><span class="line">        &#125;), <span class="comment">//生成html文件</span></span><br><span class="line">    ],</span><br><span class="line">      mode: <span class="string">&quot;development&quot;</span>  <span class="comment">//配置当前打包环境 development-开发环境、production-生产环境 （生产环境会压缩代码）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用loader(按顺序引入)</p><p>处理 css</p><ul><li>style-loader</li><li>css-loader</li></ul><p>处理 less</p><ul><li>style-loader</li><li>css-loader</li><li>less-loader(less-loader依赖less，要一起安装)</li></ul><p>处理css图片资源</p><ul><li>url-loader(依赖file-loader,可一并安装)</li></ul><p>处理html图片资源</p><ul><li>html-loader</li></ul><p>处理其他资源(如：字体文件等)</p><ul><li>file-loader</li></ul><p>常用plugins</p><ul><li>html-webpack-plugin</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hwp = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>)</span><br><span class="line"><span class="keyword">new</span> hwp(&#123;</span><br><span class="line">  template:<span class="string">&quot;./src/index.html&quot;</span>，  <span class="comment">//以该文件为模板进行复制打包</span></span><br><span class="line">  minify:&#123;</span><br><span class="line">    collapseWhitespace:<span class="literal">true</span>, <span class="comment">//压缩空格</span></span><br><span class="line">    removeComments:<span class="literal">true</span> <span class="comment">// 去除注释</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>clean-webpack-plugin</li></ul><h3 id="13-数组的toString方法"><a href="#13-数组的toString方法" class="headerlink" title="13.数组的toString方法"></a>13.数组的toString方法</h3><p>数组的toString方法会将数组的每个元素转换为字符串，有逗号拼接并且没有其他界定符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].toString()</span><br><span class="line"><span class="string">&quot;1,2,3&quot;</span></span><br><span class="line">[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>].toString()</span><br><span class="line"><span class="string">&quot;a,b,c&quot;</span></span><br><span class="line">[<span class="number">1</span>,[<span class="number">2</span>,<span class="string">&quot;c&quot;</span>]].toString()</span><br><span class="line"><span class="string">&quot;1,2,c&quot;</span></span><br></pre></td></tr></table></figure><h3 id="14-对象的toString方法"><a href="#14-对象的toString方法" class="headerlink" title="14.对象的toString方法"></a>14.对象的toString方法</h3><p>对象的toString方法没有任何参数，返回一个字符串，该方法返回的是调用它的对象的类型或值。<br>当使用“+”运算符把一个字符串和一个对象连接一起或把一个对象传递给alert()或document.write()时，会调用toString方法。</p><p>默认的toString方法返回的字符串形式总是[object class],class是对象的内部类型，通常对应的是该对象的构造函数名。例如，Array对象的class值是Array，Function对象的class值是“Function”，Date对象的class值是“Date”，内部Math对象的class值是“Math”，所有Error对象的的class值是“Error”，用户定义的对象（例如Complex）的class值是“Object”。</p><h3 id="15-怎样判断一个对象是不是数组？"><a href="#15-怎样判断一个对象是不是数组？" class="headerlink" title="15.怎样判断一个对象是不是数组？"></a>15.怎样判断一个对象是不是数组？</h3><ul><li>从原型入手，Array.prototype.isPrototypeOf(obj);<br>利用isPrototypeOf()方法判断Array是否在obj的原型链上</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.isPrototypeOf([]); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.isPrototypeOf(&#123;&#125;); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><ul><li>用instanceof, obj instanceof Array<br>instanceof检测构造函数的prototype属性是否存在实例对象的原型链上</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure><ul><li>Object.prototype.toString.call(obj)<br>根据对象的class属性，跨原型链调用toString方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]); <span class="comment">//&quot;[object Array]&quot;</span></span><br></pre></td></tr></table></figure><ul><li>Array.isArray()</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray([]); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="16-js解决苹果移动端300ms延迟的问题"><a href="#16-js解决苹果移动端300ms延迟的问题" class="headerlink" title="16.js解决苹果移动端300ms延迟的问题"></a>16.js解决苹果移动端300ms延迟的问题</h3><p>做移动端页面开发的可能会了解到，ios系统click事件会有卡顿的现象，这个问题的根源是苹果本身自带的safari有双击放大页面的功能，再次双击会返回到原始尺寸，所以在第一次点击的系统会延迟300ms来判断是不是双击操作，为了解决这个问题，网上也给了解决的办法，把click事件绑定到ontouchstart事件上，这样就解决了300ms延迟的问题，这个文件是fastclick.js</p><h3 id="17-tcp三次握手"><a href="#17-tcp三次握手" class="headerlink" title="17.tcp三次握手"></a>17.tcp三次握手</h3><p>为了准确无误将数据送达目标处，TCP协议采取了三次握手协议。<br>用tcp协议将数据包送出去后，tcp不会对发送后的情况置之不理，它一定向对方确认是否收到。</p><ul><li>1.发送端首先发送带SYN标志的数据给对方。</li><li>2.接收方收到后回传一个SYN/ACK标志的数据包以示传达确认信息。</li><li>3.最后，发送端再回传一个带ACK标志的字段，代表握手结束</li></ul><p>若在握手过程中某个阶段被打断，TCP会再次以相同的顺序发送数据包。</p><h3 id="18-四次挥手"><a href="#18-四次挥手" class="headerlink" title="18.四次挥手"></a>18.四次挥手</h3><p>第一次：客户端请求断开FIN,seq=u<br>第二次：服务器确认客户端的断开请求ACK,ack=u+1,seq=v<br>第三次：服务器请求断开FIN,seq=w,ACK,ack=u+1<br>第四次：客户端确认服务器的断开ACK,ack=w+1,seq=u+1</p><h3 id="19-osi模型"><a href="#19-osi模型" class="headerlink" title="19.osi模型"></a>19.osi模型</h3><ul><li>应用层：提供应用程序间通道</li><li>表示层：处理数据格式、数据加密等</li><li>会话层：建立、维护和管理会话</li><li>传输层：建立主机端到端的连接</li><li>网络层：寻址和路由选择</li><li>数据链路层：提供介质访问，链路管理等</li><li>物理层：比特流传输</li></ul><h3 id="20-vue-minxins"><a href="#20-vue-minxins" class="headerlink" title="20.vue minxins"></a>20.vue minxins</h3><p>mixins定义：mixins选项接受一个混入对象的数组，类型：Array<Object></p><p>mixins原理：真正的实现是靠mergeOptions函数实现的。</p><p>这个函数传进去的两个参数分别是this.options 和 mixin，而mergeOptions函数则实现了递归遍历this.options，然后执行mergeField，返回最终合并的this.options<br>mergeField函数：一般我们执行mergeField 里的key基本上就是上面strats的属性了，用的最多的可能就是data、methods、props了，所以如果我们在mixins中用到了data，其本质上就是合并当前vue实例对象里的data和我们传进去的mixin里的data，其他属性也是一样的</p><p>合并策略：<br>1.data<br>mixins中的data会合并到实例中的data中，有冲突的话，实例中data的数据会覆盖mixins中的数据</p><p><img src="/ZJY.github.io/images/minxins1.png" alt="image"></p><p>2.钩子函数<br>mixins中和实例中的钩子函数，都会执行，先执行mixins中的钩子函数</p><p><img src="/ZJY.github.io/images/minxins2.png" alt="image"></p><p>3.methods、components、directives<br>methods、components、directives会执行，当有冲突的时候，实例中的会覆盖mixins中的</p><p><img src="/ZJY.github.io/images/minxins3.png" alt="image"></p><h3 id="21-git常用命令"><a href="#21-git常用命令" class="headerlink" title="21.git常用命令"></a>21.git常用命令</h3><p>创建仓库：<br>git init</p><p>提交代码相关：</p><ul><li>把当工作区文件加到暂存区<ul><li>单个文件加入：git add x.js</li><li>全部文件加入: git add .</li></ul></li><li>把暂存区的内容提交到本地仓库: git commit -m “xxx”</li><li>克隆一下远程仓库到本地:<br>git clone <a href="mailto:&#x67;&#105;&#x74;&#64;&#103;&#105;&#x74;&#x68;&#117;&#98;&#46;&#x63;&#111;&#109;">&#x67;&#105;&#x74;&#64;&#103;&#105;&#x74;&#x68;&#117;&#98;&#46;&#x63;&#111;&#109;</a>:michaelliao/gitskills.git<br>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。</li><li>添加一个远程仓库:git remote add origin <a href="mailto:&#103;&#105;&#x74;&#x40;&#103;&#105;&#x74;&#x68;&#x75;&#x62;&#46;&#x63;&#x6f;&#109;">&#103;&#105;&#x74;&#x40;&#103;&#105;&#x74;&#x68;&#x75;&#x62;&#46;&#x63;&#x6f;&#109;</a>:michaelliao/learngit.git</li><li>本地库的所有内容推送到远程库上:git push -u origin master</li><li>提交日志查看（详细）:git log</li><li>提交查看（简洁版）:git log –pretty=oneline</li><li>指定本地dev分支与远程origin/dev分支的链接:git branch –set-upstream-to=origin/dev dev</li></ul><p>版本回退:</p><ul><li>回到上一个版本:git reset –hard HEAD^</li><li>回到上倒数第3个版本:git reset –hard HEAD^^^</li><li>回到指定版本:git reset –hard 1094a</li></ul><p>撤销更改:<br>丢弃修改，这个文件回到最近一次git commit或git add时的状态。类似svn revert命令。<br>git checkout – readme.txt</p><p>删除本地分支 :git branch -d 本地分支名<br>删除远程分支:<br>git push origin –delete 分支名<br>git branch -r -d origin/branchName<br>git push origin :branchName</p><h3 id="22-vue中的虚拟dom"><a href="#22-vue中的虚拟dom" class="headerlink" title="22.vue中的虚拟dom"></a>22.vue中的虚拟dom</h3><p>1.什么是虚拟DOM<br>虚拟DOM 表现为一个 Object对象。并且最少包含标签名 (tag)、属性 (attrs) 和子元素对象 (children) 三个属性<br>创建虚拟DOM就是为了更好将虚拟的节点渲染到页面视图中，所以虚拟DOM对象的节点与真实DOM的属性一一照应</p><p>2.为什么需要虚拟DOM<br>DOM是很慢的，其元素非常庞大，页面的性能问题，大部分都是由DOM操作引起的</p><p>真实的DOM节点，哪怕一个最简单的div也包含着很多属性<br>操作DOM的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户的体验</p><p>3.Diff原理<br>diff算法就是进行虚拟节点对比，并返回一个patch对象，用来存储两个节点不同的地方，最后用patch记录的消息去局部更新Dom。通俗的讲就是：diff的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的DOM打补丁<br>通过diff算法比较 新 旧 两个VDOM，将不同的地方进行修改，相同的地方就地复用，最后再通过render函数渲染页面</p><h3 id="23-vue双向绑定原理"><a href="#23-vue双向绑定原理" class="headerlink" title="23.vue双向绑定原理"></a>23.vue双向绑定原理</h3><p>vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p><h3 id="24-on-once-emit-off"><a href="#24-on-once-emit-off" class="headerlink" title="24.$on,$once,$emit,$off"></a>24.$on,$once,$emit,$off</h3><p>vm.$on( event, callback ):<br>监听当前实例上的自定义事件。事件可以由 vm.$emit 触发。回调函数会接收所有传入事件触发函数的额外参数</p><p>vm.$once( event, callback ):<br>监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除</p><p>vm.$off( [event, callback] ):<br>移除自定义事件监听器。</p><p>如果没有提供参数，则移除所有的事件监听器；</p><p>如果只提供了事件，则移除该事件所有的监听器；</p><p>如果同时提供了事件与回调，则只移除这个回调的监听器</p><p>vm.$emit( eventName, […args] ):<br>触发当前实例上的事件。附加参数都会传给监听器回调。</p><h3 id="25-vue的响应式原理，数组的变异检测"><a href="#25-vue的响应式原理，数组的变异检测" class="headerlink" title="25.vue的响应式原理，数组的变异检测"></a>25.vue的响应式原理，数组的变异检测</h3><p>当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。</p><p>这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更</p><p>每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。</p><p>检测变化的注意事项<br>由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。尽管如此我们还是有一些办法来回避这些限制并保证它们的响应性。</p><p>对于对象：<br>Vue 无法检测 property 的添加或移除。由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 data 对象上存在才能让 Vue 将它转换为响应式的</p><p>对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式 property</p><p>对于数组：<br>Vue 不能检测以下数组的变动：<br>当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue<br>当你修改数组的长度时，例如：vm.items.length = newLength</p><p>为了解决第一类问题，以下两种方式都可以实现和 vm.items[indexOfItem] = newValue 相同的效果，同时也将在响应式系统内触发状态更新：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line">Vue.set(vm.items, indexOfItem, newValue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.prototype.splice</span></span><br><span class="line">vm.items.splice(indexOfItem, <span class="number">1</span>, newValue)</span><br></pre></td></tr></table></figure><p>为了解决第二类问题，你可以使用 splice:vm.items.splice(indexOfItem, 1, newValue)</p><p>异步更新队列:</p><p>可能你还没有注意到，Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替</p><h3 id="26-vue-loader"><a href="#26-vue-loader" class="headerlink" title="26.vue-loader"></a>26.vue-loader</h3><p>vue-loader作用：<br>解析和转换.vue文件，提取出其中的逻辑代码script，样式代码style，以及html模版template，再分别把他们交给对应的loader去处理</p><p>用途：js可以写es6,style样式可以写scss或less</p><p>css-loader：加载由 vue-loader 提取出的 CSS 代码。<br>vue-template-compiler：把vue-loader提取出的HTML模板编译成可执行的jacascript代码</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试基础</title>
      <link href="/ZJY.github.io/2021/01/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
      <url>/ZJY.github.io/2021/01/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="一-HTML"><a href="#一-HTML" class="headerlink" title="一.HTML"></a>一.HTML</h2><h3 id="1-html语义化"><a href="#1-html语义化" class="headerlink" title="1.html语义化"></a>1.html语义化</h3><ul><li><p>使页面内容结构化，即使丢失样式也能使页面呈现清晰的结构</p></li><li><p>有利于SEO，搜索引擎根据标签确定上下文和关键字的权重有利于开发和维护</p></li><li><p>语义化更具有可读性，代码更好维护</p></li><li><p>方便其他设备解析，如配合盲人阅读器渲染页面易于用户阅读，<br>如：</p><p>  header  定义头部内容<br>  nav 定义导航区域<br>  main 定义主要文档内 容<br>  article 表示文章、博客等内容<br>  aside   侧边内容<br>  footer  尾部</p></li></ul><p>div、article、section</p><p>div、article、section是语义从无到有，逐渐增强的。<br>div无任何语义，仅仅用作样式化或脚本的标签。<br>对于一段主题性的内容，则适用于section元素。<br>对于可脱离上下文，作为一段完整独立内容的，适用于article。</p><ul><li><p>article元素代表文档、页面或应用程序中独立的、完整的、可以独自被外部引用的内容。它可以是一篇博客或报刊中的文章、一篇论坛帖子、一段用户评论或独立的插件，或其他任何独立的内容。除了内容部分，一个article元素通常有它自己的标题（一般放在一个header元素里面），有时还有自己的脚注</p></li><li><p>section元素的作用是对页面上的内容进行分块，或者说对文章进行分段；一个section元素通常由内容及其标题组成，通常不推荐为那些没有标题的内容使用section元素</p></li></ul><h3 id="2-HTML5新标签"><a href="#2-HTML5新标签" class="headerlink" title="2.HTML5新标签"></a>2.HTML5新标签</h3><pre><code>&lt;header&gt; &lt;footer&gt; &lt;nav&gt; &lt;aside&gt; &lt;aduio&gt; &lt;video&gt; &lt;canvas&gt;</code></pre><h3 id="3-html5语义化"><a href="#3-html5语义化" class="headerlink" title="3.html5语义化"></a>3.html5语义化</h3><p>表示选择合适的标签（语义化标签）便于开发者阅读和写出更优雅的代码</p><h3 id="4-html5新特性"><a href="#4-html5新特性" class="headerlink" title="4.html5新特性"></a>4.html5新特性</h3><p>HTML5新特性有哪些？</p><pre><code>语义化标签音视频处理canvas / webGLhistory APIrequestAnimationFrame地理位置webSocket</code></pre><h3 id="5-对WEB标准和W3C的理解认识"><a href="#5-对WEB标准和W3C的理解认识" class="headerlink" title="5.对WEB标准和W3C的理解认识"></a>5.对WEB标准和W3C的理解认识</h3><p>个人理解：</p><pre><code>html - 表示人的光身体 ---结构css - 表示给人穿的衣服 ---表现js - 表示人的行为，走路等 ---行为</code></pre><p>web简单来说可以分为结构、表现和行为。</p><ul><li>其中结构主要是由HTML标签组成。</li><li>表现是指css样式表，可用通过css使页面标签更具美感。</li><li>行为是指用户和页面有一定的交互，同时结构和表现也会发生变化，主要由js组成</li></ul><p>web标准一般是将该三部分独立分开，使其更具有模块化。但一般产生行为时，就会有结构或者表现的变化，也使这三者的界限并不那么清晰。</p><p>W3C对web标准提出了规范化的要求，也就是在实际编程中的<br>一些代码规范：</p><pre><code>1.对于结构要求（标签规范可以提高搜索引擎对页面的抓取率，对seo很有帮助）：    标签要小写    标签要闭合    标签不能随意嵌套2.对于css和js来说：    使用外链css和js，使结构、表现、行为三者分离。    提高页面渲染速度，提高用户体验    尽量少使用行内样式，使结构和表现分离，标签的id和class要见文知意，标签越少，加载越快，用户体验越高    不需要变动页面内容，便可提供打印版本而不需要复制内容，提高网站易用性。</code></pre><h3 id="6-什么是DOCTYPE及作用"><a href="#6-什么是DOCTYPE及作用" class="headerlink" title="6.什么是DOCTYPE及作用"></a>6.什么是DOCTYPE及作用</h3><p>DTD（document type definition，文档类型定义）是一系列的语法规则，用来定义XML或（X）HTML的文件类型。浏览器会使用它来判断文档类型，决定使用何种协议来解析以及切换浏览器模式。（DTD告诉浏览器我是什么文档类型，浏览器会根据这个来判断用什么引擎来解析和渲染他们）</p><p>DOCTYPE是用来声明文档类型和DTD规范的，一个主要的用途便是文件的合法性验证。如果文件代码不合法，那么浏览器解析时会出一些错误。（DOCTYPE告诉浏览器当前是哪个文档类型）</p><!DOCTYPE html><p>作用：<br>告诉浏览器用哪种HTML版本的规范来解析HTML文档</p><h2 id="二-CSS"><a href="#二-CSS" class="headerlink" title="二.CSS"></a>二.CSS</h2><h3 id="1-盒模型"><a href="#1-盒模型" class="headerlink" title="1.盒模型"></a>1.盒模型</h3><ul><li>组成：border+padding+content+margin</li><li>标准盒模型：width: content  box-sizing: content-box</li><li>怪异盒模型/IE：width: content+padding+border  box-sizing:border-box</li></ul><h3 id="2-rem和em的区别"><a href="#2-rem和em的区别" class="headerlink" title="2.rem和em的区别"></a>2.rem和em的区别</h3><p>rem是根据根元素的font-size变化，em是根据父元素的font-size变化</p><ul><li>rem：相对于根元素html的font-size，假如html为font-size：12px，那么，在其当中的div设置为font-size：2rem,就是当中的div为24px</li><li>em：相对于父元素计算，假如某个p元素为font-size:12px,在它内部有个span标签，设置font-size：2em,那么，这时候的span字体大小为：12*2=24px</li></ul><h3 id="3-常见单位"><a href="#3-常见单位" class="headerlink" title="3.常见单位"></a>3.常见单位</h3><ol><li>px：绝对单位，页面按精确像素展示</li><li>em：相对单位，基准点为父节点字体的大小，如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值</li><li>rem：相对单位，可理解为”root em”, 相对根节点html的字体大小来计算，CSS3新加属性，chrome/firefox/IE9+支持</li><li>vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%</li><li>vh：viewpoint height，视窗高度，1vh等于视窗高度的1%</li><li>vmin：vw和vh中较小的那个</li><li>vmax：vw和vh中较大的那个</li><li>%:百分比</li></ol><h3 id="4-移动端视口配置"><a href="#4-移动端视口配置" class="headerlink" title="4.移动端视口配置"></a>4.移动端视口配置</h3><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;&gt;initial-scale：初始的缩放比例minimum-scale：允许用户缩放到的最小比例maximum-scale：允许用户缩放到的最大比例user-scalable：用户是否可以手动缩放</code></pre><h3 id="5-渐进增强与优雅降级的理解及区别"><a href="#5-渐进增强与优雅降级的理解及区别" class="headerlink" title="5.渐进增强与优雅降级的理解及区别"></a>5.渐进增强与优雅降级的理解及区别</h3><ul><li><p>渐进增强（Progressive Enhancement）：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。</p></li><li><p>优雅降级（Graceful Degradation）：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行hack 使其可以在低版本浏览器上正常浏览。</p></li></ul><p>两者区别？</p><p>1、广义：<br>其实要定义一个基准线，在此之上的增强叫做渐进增强，在此之下的兼容叫优雅降级<br>2、狭义：<br>渐进增强一般说的是使用CSS3技术，在不影响老浏览器的正常显示与使用情形下来增强体验，而优雅降级则是体现html标签的语义，以便在js/css的加载失败/被禁用时，也不影响用户的相应功能</p><h3 id="6-cookie、sessionStorage、localStorage区别"><a href="#6-cookie、sessionStorage、localStorage区别" class="headerlink" title="6.cookie、sessionStorage、localStorage区别"></a>6.cookie、sessionStorage、localStorage区别</h3><p>相同点：</p><ul><li>都是保存在浏览器端、且同源的 </li></ul><p>不同点：</p><ul><li><p>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下 </p></li><li><p>存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M+</p></li></ul><ul><li><p>cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除</p></li><li><p>cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地</p></li><li><p>作用域不同，sessionStorage在不同的浏览器窗口中不共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的 </p></li></ul><h3 id="7-css选择器"><a href="#7-css选择器" class="headerlink" title="7.css选择器"></a>7.css选择器</h3><ul><li><p>常用css选择器</p><p>  id选择器   #header<br>  类选择器   .header<br>  元素选择器  div<br>  通配符     *<br>  后代选择器  div p, p a<br>  儿子选择器  div &gt; span<br>  兄弟选择器  div + p, h2 ~ h3<br>  伪类选择器  a:hover<br>  属性选择器  input[type=”text”]<br>  伪元素选择器  p::before  p::first-line</p></li><li><p>css选择器权重</p><p>  !important &gt; id &gt; class &gt; 元素和伪元素 &gt; * &gt; 继承 &gt;默认</p></li></ul><h3 id="8-css3新特性"><a href="#8-css3新特性" class="headerlink" title="8.css3新特性"></a>8.css3新特性</h3><ul><li>transition 过渡</li><li>transform   旋转 倾斜 移动 缩放</li><li>animation   动画</li><li>shadow  阴影</li><li>grdient 渐变</li><li>border-radius   圆角</li></ul><h3 id="9-行内元素和块级元素"><a href="#9-行内元素和块级元素" class="headerlink" title="9.行内元素和块级元素"></a>9.行内元素和块级元素</h3><ul><li><p>行内元素（display: inline）:</p><ul><li>设置宽高无效，宽度和高度由内容决定</li><li>设置margin左右有效，上下无效，padding都有效</li><li>不会自动换行</li><li>有span,img,input,a,b,sub,sup,i</li></ul></li><li><p>块级元素(display:block):</p><ul><li>可以设置宽高</li><li>margin和padding都有效</li><li>自动换行</li><li>多个块元素写一起，排列从上到下</li><li>由div,p,nav,h,footer,main,header等</li></ul></li><li><p>行内块元素（display:inline-block）</p><ul><li>能够设置宽高</li><li>margin/padding都有效</li><li>不会自动换行</li><li>默认排列方式从左到右 </li></ul></li></ul><h3 id="10-css的position的定位"><a href="#10-css的position的定位" class="headerlink" title="10.css的position的定位"></a>10.css的position的定位</h3><p>relative  absolute  fixed  static</p><ul><li>绝对定位： absolute和fiexed统称为绝对定位</li><li>相对定位： relative</li><li>默认值：static<br>相对定位和绝对定位的区别：</li><li>relative：<br>相对于自身位置定位，仍处于文档流中，元素的宽高不变，设置偏移量也不会影响其他元素的位置，如果最外层设置relative，在没有设置宽度情况，元素宽度是整个浏览器的宽度</li><li>absolute：<br>相对于离自己最近的设置了相对或绝对定位的父元素定位，如果没有父元素设置相对和绝对定位，则相对于跟元素html定位，设置了绝对定位的元素脱离了文档流，如果没有设置宽高由元素内容决定，脱离后元素位置是空的下面的元素会占据</li><li>fixed：<br>相对于浏览器窗口定位,如果没有设置宽高由元素内容决定。</li></ul><h3 id="11-Flex布局"><a href="#11-Flex布局" class="headerlink" title="11.Flex布局"></a>11.Flex布局</h3><p>Flexbox为Flexible box缩写，“弹性布局”，任何一个元素都能设置弹性布局包含两部分，一个为容器，一个为项目<br>水平的主轴（main axis）和垂直的交叉轴（cross axis）<br>主轴的排列方式：从左到右；交叉轴的排列方式：从上到下;</p><p>容器的属性：</p><ul><li>flex-direction:主轴的方向-row/row-reverse/column/column-reverse</li><li>flex-wrap:项目排列方式是否换行–nowrap/wrap/wrap-reverse</li><li>flex-flow:direction和wrap的缩写</li><li>justify-content:项目在主轴排列方式–flex-start/flex-end/center/space-between/space-around</li><li>align-items:项目在交叉轴的如何对齐-flex-start/flex-end/center/baseline/stretch</li></ul><p>项目属性：</p><ul><li>order：number （数值越小越靠前，默认为0）项目排列顺序</li><li>flex-grow ：number（默认0，如果有剩余空间也不放大，值为1放大，2是1的双倍大小，此类推）定义项目放大比例</li><li>flex-shrink ：number （默认为1，如果空间不足则会缩小，值为0不能缩小）项目缩小比例</li><li>flex-basis ：number/auto （默认auto，可设置固定的值50px/50%）定义项目自身的大小</li><li>flex：属性是flex-grow，flex-shrink ,flex-basis的简写，默认值为0、1、auto</li><li>align-self ：auto | flex-start | flex-end | center | baseline | stretch项目自身对齐</li></ul><h3 id="12-display有哪些值？说明他们的作用"><a href="#12-display有哪些值？说明他们的作用" class="headerlink" title="12.display有哪些值？说明他们的作用?"></a>12.display有哪些值？说明他们的作用?</h3><ul><li>inline（默认）–内联</li><li>none–隐藏</li><li>block–块显示</li><li>table–表格显示</li><li>list-item–项目列表</li><li>inline-block-内联块</li></ul><h3 id="13-BFC"><a href="#13-BFC" class="headerlink" title="13.BFC"></a>13.BFC</h3><p>BFC格式化上下文，它是一个独立的渲染区域，让处于 BFC 内部的元素和外部的元素相互隔离，使内外元素的定位不会相互影响</p><p>那些元素产生BFC？</p><pre><code>    根元素    position为absolute或fixed    display为flex，inline-flex，inline-block，table-cell    float属性不为none    overflow不为visible</code></pre><p>BFC布局规则：</p><pre><code>    内部的box会在垂直方向，一个一个排列    Box垂直方向的距离由margin决定，同一个BFC内相邻的两个box的margin值会重叠    每个元素的margin box的左边与border box的左边相接触，即使浮动也如此    BFC区域不和float box区域重叠    BFC是页面上一个独立的容器，内部子元素不回对外部元素产生影响    计算BFC高度时，浮动元素也参与计算</code></pre><p>BFC的使用场景？</p><pre><code>去除边距重叠现象清除浮动（让父元素的高度包含子浮动元素）避免某元素被浮动元素覆盖避免多列布局由于宽度计算四舍五入而自动换行</code></pre><h3 id="14-水平垂直居中"><a href="#14-水平垂直居中" class="headerlink" title="14.水平垂直居中"></a>14.水平垂直居中</h3><pre><code>水平居中： margin:0 auto;text-align:center;flex:justify-content垂直居中：line-height;flex:align-items水平垂直居中：flex;absolute+margin负；absolute+translate负</code></pre><h3 id="15-Sass、Less、Stylus区别"><a href="#15-Sass、Less、Stylus区别" class="headerlink" title="15.Sass、Less、Stylus区别"></a>15.Sass、Less、Stylus区别</h3><p>什么是CSS预处理器?<br>CSS预处理器是一种语言用来为CSS增加一些编程的特性，无需考虑浏览器兼容问题，例如你可以在CSS中使用变量，简单的程序逻辑、函数等在编程语言中的一些基本技巧，可以让CSS更加简洁，适应性更强，代码更直观等诸多好处</p><ul><li>基本语法区别<br>  Sass是以.sass为扩展名，Less是以.less为扩展名，Stylus是以.styl为扩展名</li></ul><ul><li>变量的区别<br>  Sass 变量必须是以$开头的，然后变量和值之间使用冒号（：）隔开，和css属性是一样的。<br>  Less 变量是以@开头的，其余sass都是一样的。<br>  Stylus 对变量是没有任何设定的，可以是以$开头或者任意字符，而且变量之间可以冒号，空格隔开，但是在stylus中不能用@开头</li></ul><p>三种预处理器都有：嵌套、运算符、颜色函数、导入、继承、混入。Stylus还有一些高级特性。例如循环、判断等</p><h3 id="16-display-none与visibility-hidden的区别"><a href="#16-display-none与visibility-hidden的区别" class="headerlink" title="16.display: none与visibility: hidden的区别"></a>16.display: none与visibility: hidden的区别</h3><pre><code>display：none 不显示对应的元素，在文档布局中不再分配空间（回流+重绘）visibility：hidden 隐藏对应元素，在文档布局中仍保留原来的空间（重绘）</code></pre><h3 id="17-重绘-amp-回流"><a href="#17-重绘-amp-回流" class="headerlink" title="17.重绘 &amp; 回流"></a>17.重绘 &amp; 回流</h3><p>浏览器渲染过程如下：</p><ul><li>解析HTML，生成DOM树，解析CSS，生成CSSOM树</li><li>将DOM树和CSSOM树结合，生成渲染树(Render Tree)</li><li>Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）</li><li>Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</li><li>Display:将像素发送给GPU，展示在页面上</li></ul><p>通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流</p><p>我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。</p><p>何时发生回流重绘</p><ul><li>添加或删除可见的DOM元素</li><li>元素的位置发生变化</li><li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li><li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。</li><li>页面一开始渲染的时候（这肯定避免不了）</li><li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</li></ul><p>注意：回流一定会触发重绘，而重绘不一定会回流根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。</p><p>当你获取布局信息的操作的时候，会强制队列刷新</p><p>最小化重绘和重排：</p><pre><code>    批量修改DOM：    使元素脱离文档流    对其进行多次修改    将元素带回到文档中。</code></pre><p>有三种方式可以让DOM脱离文档流：</p><pre><code>    隐藏元素，应用修改，重新显示    使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。    将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。</code></pre><h3 id="18-防抖（debounce）"><a href="#18-防抖（debounce）" class="headerlink" title="18.防抖（debounce）"></a>18.防抖（debounce）</h3><p>防抖就是在触发事件n秒内函数只执行一次，如果在n秒内又触发了事件，就重新计时<br>如下，鼠标移动时，计数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;content&quot;</span> style=<span class="string">&quot;height:150px;line-height:150px;text-align:center; color: #fff;background-color:#ccc;font-size:80px;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> content = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;content&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        content.innerHTML = num++;</span><br><span class="line">    &#125;;</span><br><span class="line">    content.onmousemove = count;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>防抖函数分为非立即执行版和立即执行版</p><p>非立即执行版：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func,wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(timeout)&#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        &#125;</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            func.apply(context,args)</span><br><span class="line">        &#125;,wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在触发事件后函数 1 秒后才执行，而如果我在触发事件后的 1秒内又触发了事件，则会重新计算函数执行时间<br>content.onmousemove = debounce(count,1000);</p><p>let context = this;<br>let args = arguments;<br>防抖函数的代码使用这两行代码来获取 this 和参数，是为了让 debounce 函数最终返回的函数 this指向不变以及依旧能接受到 e 参数</p><p>立即执行版：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func,wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(timeout)&#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> callNow = !timeout;</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            timeout = <span class="literal">null</span></span><br><span class="line">        &#125;,wait)</span><br><span class="line">        <span class="keyword">if</span> (callNow) func.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。</p><h3 id="19-节流（throttle）"><a href="#19-节流（throttle）" class="headerlink" title="19.节流（throttle）"></a>19.节流（throttle）</h3><p>连续触发函数在n秒内只执行一次，稀释了函数的执行频率<br>时间戳版：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func,wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span>(now-previous &gt; wait)&#123;</span><br><span class="line">            func.apply(context,args);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line">content.onmousemove = throttle(count,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>在持续触发事件的过程中，函数会立即执行，并且每 1s 执行一次</p><p>定时器版：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func,wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = argments;</span><br><span class="line">        <span class="keyword">if</span>(!timeout)&#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在持续触发事件的过程中，函数不会立即执行，并且每1s 执行一次，在停止触发事件后，函数还会再执行一次。</p><p>时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候。</p><h3 id="20-获取盒子宽高的几种方式及区别"><a href="#20-获取盒子宽高的几种方式及区别" class="headerlink" title="20.获取盒子宽高的几种方式及区别"></a>20.获取盒子宽高的几种方式及区别</h3><ul><li><p>dom.style.width/height<br>这种方式只能取到dom元素内联样式所设置的宽高，也就是说如果该节点的样式是在style标签中或外联的CSS文件中设置的话，通过这种方法是获取不到dom的宽高的</p></li><li><p>dom.currentStyle.width/height<br>获取渲染后的宽高。但是仅IE支持</p></li><li><p>window.getComputedStyle(dom).width/height<br>与2原理相似，但是兼容性，通用性更好一些</p></li><li><p>dom.getBoundingClientRect().width/height<br>计算元素绝对位置，获取到四个元素left,top,width,height</p></li></ul><p>扩展：获取浏览器高度和宽度的兼容性写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  w = <span class="built_in">window</span>.innerWidth || <span class="built_in">document</span>.documentElement.clientWidth || <span class="built_in">document</span>.body.clientWidth</span><br><span class="line"><span class="keyword">var</span>  h = <span class="built_in">window</span>.innerHeight || <span class="built_in">document</span>.documentElement.clientHeight || <span class="built_in">document</span>.body.clientHeight</span><br></pre></td></tr></table></figure><h3 id="21-link和import区别："><a href="#21-link和import区别：" class="headerlink" title="21.link和import区别："></a>21.link和import区别：</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line"><span class="keyword">@import</span> url(CSS文件路径地址);</span><br><span class="line">&lt;/<span class="selector-tag">style</span>&gt;</span><br><span class="line">&lt;link href=&quot;CSSurl路径&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;</span><br></pre></td></tr></table></figure><ul><li>import是css提供的语法规则，只有导入样式表的作用，link是html的标签，不仅可以加载样式还可以设置rel type等属性</li><li>import是css2才引入等，只支持ie5+，而link没有兼容问题</li><li>import在页面加载完毕才引入，link在加载页面时引入</li><li>link可用dom操作引入link加载样式</li></ul><h3 id="22-多行元素省略号："><a href="#22-多行元素省略号：" class="headerlink" title="22.多行元素省略号："></a>22.多行元素省略号：</h3><pre><code>overflow : hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 3;-webkit-box-orient: vertical</code></pre><h2 id="三-JS"><a href="#三-JS" class="headerlink" title="三.JS"></a>三.JS</h2><h3 id="1-JS的基本数据类型："><a href="#1-JS的基本数据类型：" class="headerlink" title="1.JS的基本数据类型："></a>1.JS的基本数据类型：</h3><p><code>Number</code>  <code>String</code>  <code>Boolean</code>  <code>Null</code>  <code>undefined</code> 新增<code>Symbol</code></p><h3 id="2-几种判断数据类型的优缺点"><a href="#2-几种判断数据类型的优缺点" class="headerlink" title="2.几种判断数据类型的优缺点"></a>2.几种判断数据类型的优缺点</h3><p>一、typeof</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">1</span>);               <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);            <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">&#x27;mc&#x27;</span>);           <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);    <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []);              <span class="comment">// object </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;);              <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);            <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>);       <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>优点：能够快速区分基本数据类型 缺点：不能将Object、Array和Null区分，都返回object</p><p>二、instanceof</p><p>instanceof用来检测构造函数的prototype属性是否存在某实例对象的原型链上</p><p>语法：object instanceof constructor<br>参数：<br>object:某个实例对象<br>constructor:某个构造函数<br>描述：二、instanceof用来检测constructor.prototype属性是否存在在object的原型链上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>);                    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);                <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>);                <span class="comment">// false  </span></span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>);                    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Function</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>);                   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>优点：能够区分Array、Object和Function，适合用于判断自定义的类实例对象 缺点：Number，Boolean，String基本数据类型不能判断</p><p>三、Object.prototype.toString.call()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="number">1</span>));                      <span class="comment">//[object Number]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="literal">true</span>));                   <span class="comment">//[object Boolean]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="string">&#x27;mc&#x27;</span>));                  <span class="comment">//[object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call([]));                     <span class="comment">//[object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(&#123;&#125;));                     <span class="comment">//[object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;));           <span class="comment">//[object Function]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="literal">undefined</span>));              <span class="comment">//[object Undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="literal">null</span>));                   <span class="comment">//[object Null]</span></span><br></pre></td></tr></table></figure><p>优点：精准判断数据类型 缺点：写法繁琐不容易记，推荐进行封装后使用</p><h3 id="3-null和undefined的区别"><a href="#3-null和undefined的区别" class="headerlink" title="3.null和undefined的区别"></a>3.null和undefined的区别</h3><pre><code>undefined是访问一个未初始化的变量时返回的值，而null是访问一个尚未存在的对象时所返回的值。undefined看作是空的变量，而null看作是空的对象</code></pre><h3 id="4-对象深浅拷贝"><a href="#4-对象深浅拷贝" class="headerlink" title="4.对象深浅拷贝"></a>4.对象深浅拷贝</h3><p>一、深拷贝</p><ul><li>1.1 最简单的方法就是JSON.parse(JSON.stringify())<br>但是这种拷贝方法不可以拷贝一些特殊的属性（例如正则表达式，undefine，function）</li><li>1.2 用递归去复制所有层级属性</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopyTwo</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> objClone = <span class="built_in">Array</span>.isArray(obj) ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (obj &amp;&amp; <span class="keyword">typeof</span> obj == <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            <span class="comment">//判断obj子元素是否为对象，如果是，递归复制</span></span><br><span class="line">            <span class="keyword">if</span> (obj[key] &amp;&amp; <span class="keyword">typeof</span> obj[key] === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">                objClone[key] = deepCopyTwo(obj[key]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果不是，简单复制</span></span><br><span class="line">                objClone[key] = obj[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objClone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、浅拷贝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(target, ...sources)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        result[i] = obj[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-数组基本方法："><a href="#5-数组基本方法：" class="headerlink" title="5.数组基本方法："></a>5.数组基本方法：</h3><ul><li><p>push()：将参数逐个添加到数组尾部，返回修改后的数组长度</p></li><li><p>unshift()：将参数逐个添加到数组前端，返回修改后的数组长度</p></li><li><p>pop()：移除数组中的最后一项，返回移除的项</p></li><li><p>shift()：移除数组中的第一项，返回移除的项</p></li></ul><p>push pop shift unshift 都会直接改变原数组</p><ul><li><p>map: 遍历数组，返回回调返回值组成的新数组</p></li><li><p>forEach: 无法break，可以用try/catch中throw new Error来停止</p></li><li><p>filter: 过滤</p></li><li><p>some: 有一项返回true，则整体为true</p></li><li><p>every: 有一项返回false，则整体为false</p></li><li><p>join: 通过指定连接符生成字符串</p></li><li><p>concat: 连接数组，不影响原数组， 浅拷贝</p></li><li><p>slice(start, end): 返回截断后的新数组，不改变原数组</p></li><li><p>splice(start, number, value…):返回删除元素组成的数组，value 为插入项，改变原数组</p></li><li><p>indexOf / lastIndexOf(value, fromIndex): 查找数组项，返回对应的下标</p></li><li><p>reduce / reduceRight(fn(prev, cur)， defaultPrev): 两两执行，prev 为上次化简函数的return值,cur 为当前值(从第二项开始)</p></li></ul><h3 id="6-js有那些内置对象："><a href="#6-js有那些内置对象：" class="headerlink" title="6.js有那些内置对象："></a>6.js有那些内置对象：</h3><p>Object是JavaScript中所有对象的父对象</p><p>数据封装对象：Object、Array、Boolean、Number和String<br>其他对象：Function、Arguments、Math、Date、RegExp、Error</p><h3 id="7-get请求传参长度的误区："><a href="#7-get请求传参长度的误区：" class="headerlink" title="7.get请求传参长度的误区："></a>7.get请求传参长度的误区：</h3><ul><li>HTTP 协议 未规定 GET 和POST的长度限制</li><li>GET的最大长度显示是因为 浏览器和 web服务器限制了 URI的长度</li><li>不同的浏览器和WEB服务器，限制的最大长度不一样</li><li>要支持IE，则最大长度为2083byte，若只支持Chrome，则最大长度 8182byte</li></ul><p>补充get和post请求在缓存方面的区别</p><ul><li>get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存</li><li>post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。</li></ul><h3 id="8-同步任务和异步任务"><a href="#8-同步任务和异步任务" class="headerlink" title="8.同步任务和异步任务"></a>8.同步任务和异步任务</h3><ul><li><p>同步任务：在主线程上执行的任务，只有前一个任务执行完，才能执行下一个任务</p></li><li><p>异步任务：不进入主线程而进入“任务队列”的任务，只有任务队列通知主线程，某个任务可以执行了，该任务才会进入主线程执行。</p><p>  异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）：<br>  1）所以同步任务都在主线程执行，形成一个执行栈<br>  2）主线程之外，还有一个任务队列，只要异步任务有了执行结果，就在任务队列放置一个事件<br>  3）一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列，看看有哪些事件，对应的事件就结束等待状态，进入执行栈进行执行<br>  4）主线程不断重复第三步</p><p>  主线程从“任务队列”中读取事件，这个事件是循环不断的，又称为事件循环（Event loop）</p></li></ul><h3 id="9-事件和回调函数"><a href="#9-事件和回调函数" class="headerlink" title="9.事件和回调函数"></a>9.事件和回调函数</h3><p>“任务队列”就是一个事件的队列，当IO设备完成一项任务，就在“任务队列”中添加一个事件，表示相关的异步任务可以进入执行栈了，主线程读取“任务队列”，就是读取有哪些事件</p><p>“回调函数”（callback）就是被主线程挂起来的代码。异步任务必须指定回调函数，主线程执行异步任务就是执行对应的回调函数。</p><h3 id="10-定时器"><a href="#10-定时器" class="headerlink" title="10.定时器"></a>10.定时器</h3><p>定时器功能主要由setTimeout()和setInterval()这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者则为反复执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">2</span>);&#125;,<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>上面代码的执行结果是1，3，2，因为setTimeout()将第二行推迟到1000毫秒之后执行。</p><p>如果将setTimeout()的第二个参数设为0，就表示当前代码执行完（执行栈清空）以后，立即执行（0毫秒间隔）指定的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>);&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>上面代码的执行结果总是2，1，因为只有在执行完第二行以后，系统才会去执行”任务队列”中的回调函数。</p><p>setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行</p><p>HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加.需要注意的是，setTimeout()只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行</p><p>除了setTimeout和setInterval这两个方法，Node.js还提供了另外两个与”任务队列”有关的方法：process.nextTick和setImmediate。</p><ul><li><p>process.nextTick方法可以在当前”执行栈”的尾部—-下一次Event Loop（主线程读取”任务队列”）之前—-触发回调函数。也就是说，它指定的任务总是发生在所有异步任务之前。setImmediate方法则是在当前”任务队列”的尾部添加事件，也就是说，它指定的任务总是在下一次EventLoop时执行，这与setTimeout(fn, 0)很像</p></li><li><p>process.nextTick和setImmediate的一个重要区别：多个process.nextTick语句总是在当前”执行栈”一次执行完，多个setImmediate可能则需要多次loop才能执行完</p></li></ul><p>另外，由于process.nextTick指定的回调函数是在本次”事件循环”触发，而setImmediate指定的是在下次”事件循环”触发，所以很显然，前者总是比后者发生得早，而且执行效率也高（因为不用检查”任务队列”）。</p><h3 id="11-进程和线程"><a href="#11-进程和线程" class="headerlink" title="11.进程和线程"></a>11.进程和线程</h3><p>进程和线程是操作系统的基本概念</p><p>单个cpu一次只能运行一个任务，任一时刻，CPU总是运行一个进程，其他进程处于非运行状态</p><ul><li>一个进程可用包含多个线程</li><li>一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。</li><li>一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。”互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。</li></ul><p>某些内存区域，只能供给固定数目的线程使用。”信号量”（Semaphore），用来保证多个线程不会互相冲突</p><p>操作系统的设计，因此可以归结为三点：</p><pre><code>（1）以多进程形式，允许多个任务同时运行；（2）以多线程形式，允许单个任务分成不同的部分运行；（3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源</code></pre><h3 id="12-axios在vue-js中应用和特点"><a href="#12-axios在vue-js中应用和特点" class="headerlink" title="12.axios在vue.js中应用和特点"></a>12.axios在vue.js中应用和特点</h3><p>axios是基于promise的http请求客户端，可用在浏览器和node。js中使用</p><p>使用场景：结合vue.js发送请求，拦截请求</p><p>特点：<br>    1.基于promise<br>    2.拦截请求和响应<br>    3.转换请求和响应的数据<br>    4.可在node.js中使用</p><p>安装：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save axios</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> ‘axios’</span><br></pre></td></tr></table></figure><p>结合Vue.js的请求响应拦截器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求拦截</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (config.url.indexOf(<span class="string">&#x27;/oauth/token?grant_type=password&#x27;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">    config.headers[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="string">&#x27;Basic Y2xpOnNlYw==&#x27;</span></span><br><span class="line">    <span class="comment">// config.headers[&#x27;Content-Type&#x27;] = &#x27;application/json;charset-UTF-8&#x27;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getToken()) &#123;</span><br><span class="line">    config.headers[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="string">&#x27;Bearer &#x27;</span> + getToken() + <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Do something with request error</span></span><br><span class="line">  <span class="built_in">console</span>.log(error) <span class="comment">// for debug</span></span><br><span class="line">  <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截</span></span><br><span class="line">axios.interceptors.response.use(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.data.code !== <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (res.data.code) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;401&#x27;</span>:</span><br><span class="line">        <span class="built_in">window</span>.location.href = <span class="string">&#x27;/login&#x27;</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;403&#x27;</span>:</span><br><span class="line">        Notification.error(&#123;</span><br><span class="line">          title: <span class="string">&#x27;错误：403&#x27;</span>,</span><br><span class="line">          message: <span class="string">&#x27;访问拒绝&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;404&#x27;</span>:</span><br><span class="line">        Notification.error(&#123;</span><br><span class="line">          title: <span class="string">&#x27;错误：404&#x27;</span>,</span><br><span class="line">          message: <span class="string">&#x27;找不到网络资源&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;500&#x27;</span>:</span><br><span class="line">        Notification.error(&#123;</span><br><span class="line">          title: <span class="string">&#x27;错误：500&#x27;</span>,</span><br><span class="line">          message: res.data.error.errorMsg</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.data</span><br><span class="line">&#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err.response) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (err.response.status) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;401&#x27;</span>:</span><br><span class="line">        <span class="built_in">window</span>.location.href = <span class="string">&#x27;/login&#x27;</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;403&#x27;</span>:</span><br><span class="line">        Notification.error(&#123;</span><br><span class="line">          title: <span class="string">&#x27;错误：403&#x27;</span>,</span><br><span class="line">          message: <span class="string">&#x27;访问拒绝&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;404&#x27;</span>:</span><br><span class="line">        Notification.error(&#123;</span><br><span class="line">          title: <span class="string">&#x27;错误：404&#x27;</span>,</span><br><span class="line">          message: <span class="string">&#x27;找不到网络资源&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;500&#x27;</span>:</span><br><span class="line">        Notification.error(&#123;</span><br><span class="line">          title: <span class="string">&#x27;错误：500&#x27;</span>,</span><br><span class="line">          message: <span class="string">&#x27;服务器出错&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求封装</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">_axios</span> (<span class="params">method, url, params</span>) </span>&#123;</span><br><span class="line">  method = method.toUpperCase()</span><br><span class="line">  <span class="keyword">var</span> options = &#123;</span><br><span class="line">    method: method,</span><br><span class="line">    url: url,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json;charset=UTF-8&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (method === <span class="string">&#x27;POST&#x27;</span> || method === <span class="string">&#x27;PATCH&#x27;</span> || method === <span class="string">&#x27;PUT&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (params) &#123;</span><br><span class="line">      options.data = params</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> axios(options)</span><br><span class="line">      .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">      &#125;, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> error</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (method === <span class="string">&#x27;GET&#x27;</span> || method === <span class="string">&#x27;DELETE&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (params) &#123;</span><br><span class="line">      options.params = params</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> axios(options)</span><br><span class="line">      .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">      &#125;, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> error</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-HTTP中定义请求方式"><a href="#13-HTTP中定义请求方式" class="headerlink" title="13.HTTP中定义请求方式"></a>13.HTTP中定义请求方式</h3><ul><li><p>get</p></li><li><p>post</p></li><li><p>put</p></li><li><p>delete</p></li><li><p>trace</p></li><li><p>options</p></li><li><p>head</p></li></ul><p>1.get</p><p>get请求只是查询数据，不对数据库进行删改操作；请求会把参数放在url后面；http协议对url长度没有限制，有限制的是浏览器和服务器</p><p>2.post</p><p>post请求一般是对服务器的数据做改变，比如数据的提交，新增操作，请求参数放在请求体中</p><p>3.put</p><p>put和post一样都是对服务器数据对修改，但是put侧重于对数据的修改，而post是对数据的新增</p><p>4.delete</p><p>用来请求删除服务器的资源，但有可能删除不成功（取消delete请求）</p><p>5.options</p><p>options请求属于浏览器的预检请求，查看服务器是否接受请求，预检通过后，浏览器才会去发get，post，put，delete等，响应报文包含一个 Allow 首部字段，该字段的值表明了服务器支持的所有 HTTP 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Allow: OPTIONS, GET, HEAD, POST</span><br><span class="line">Cache-Control: max-age=<span class="number">604800</span></span><br><span class="line"><span class="built_in">Date</span>: Thu, <span class="number">13</span> Oct <span class="number">2016</span> <span class="number">11</span>:<span class="number">45</span>:<span class="number">00</span> GMT</span><br><span class="line">Expires: Thu, <span class="number">20</span> Oct <span class="number">2016</span> <span class="number">11</span>:<span class="number">45</span>:<span class="number">00</span> GMT</span><br><span class="line">Server: EOS (lax004/<span class="number">2813</span>)</span><br><span class="line">x-ec-custom-error: <span class="number">1</span></span><br><span class="line">Content-Length: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>在 CORS 中，可以使用 OPTIONS 方法发起一个预检请求，以检测实际请求是否可以被服务器所接受。预检请求报文中的 Access-Control-Request-Method首部字段告知服务器实际请求所使用的 HTTP方法；Access-Control-Request-Headers首部字段告知服务器实际请求所携带的自定义首部字段。服务器基于从预检请求获得的信息来判断，是否接受接下来的实际请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS /resources/post-here/ HTTP/<span class="number">1.1</span> </span><br><span class="line">Host: bar.other </span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;</span><br><span class="line">Accept-Language: en-us,en;q=<span class="number">0.5</span> </span><br><span class="line">Accept-Encoding: gzip,deflate </span><br><span class="line">Accept-Charset: ISO-<span class="number">8859</span>-<span class="number">1</span>,utf-<span class="number">8</span>;</span><br><span class="line">Connection: keep-alive </span><br><span class="line">Origin: http:<span class="comment">//foo.example </span></span><br><span class="line">Access-Control-Request-Method: POST </span><br><span class="line">Access-Control-Request-Headers: X-PINGOTHER, Content-Type</span><br></pre></td></tr></table></figure><p>服务器所返回的 Access-Control-Allow-Methods 首部字段将所有允许的请求方法告知客户端。该首部字段与 Allow 类似，但只能用于涉及到 CORS 的场景中。</p><pre><code>    Access-Control-Allow-Methods: POST, GET, OPTIONS     Access-Control-Allow-Headers: X-PINGOTHER, Content-Type </code></pre><p>6.head</p><p>与GET方法的行为很类似，但服务器在响应中只返回实体的主体部分</p><p>7.trace</p><p>会在目的服务器端发起一个“回环”诊断。这样客户端就可以查看HTTP请求报文在发送的途中，是否被修改过了</p><h3 id="14-get和post区别"><a href="#14-get和post区别" class="headerlink" title="14.get和post区别"></a>14.get和post区别</h3><ul><li><p>GET参数通过URL传递，POST放在Request body中。</p></li><li><p>GET请求会被浏览器主动cache，而POST不会，除非手动设置</p></li><li><p>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留</p></li><li><p>Get 请求中有非 ASCII 字符，会在请求之前进行转码，POST不用，因为POST在Request body中，通过 MIME，也就可以传输非 ASCII 字符</p></li><li><p>一般我们在浏览器输入一个网址访问网站都是GET请求,HTTP的底层是TCP/IP。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。但是请求的数据量太大对浏览器和服务器都是很大负担。所以业界有了不成文规定，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。</p></li><li><p>GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）</p></li><li><p>在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。但并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次</p></li></ul><h3 id="15-http中content-type"><a href="#15-http中content-type" class="headerlink" title="15.http中content-type"></a>15.http中content-type</h3><p>MediaType，即是Internet Media Type，互联网媒体类型；也叫做MIME类型，在Http协议消息头中，使用Content-Type来表示具体请求中的媒体类型信息</p><p>常见的媒体格式类型如下：</p><ul><li>text/html ： HTML格式</li><li>text/plain ：纯文本格式      </li><li>text/xml ：  XML格式</li><li>image/gif ：gif图片格式    </li><li>image/jpeg ：jpg图片格式 </li><li>image/png：png图片格式</li></ul><p>以application开头的媒体格式类型：</p><ul><li>application/xhtml+xml ：XHTML格式</li><li>application/xml     ： XML数据格式</li><li>application/atom+xml  ：Atom XML聚合格式</li><li>application/json    ： JSON数据格式</li><li>application/pdf       ：pdf格式  </li><li>application/msword  ： Word文档格式</li><li>application/octet-stream ： 二进制流数据（如常见的文件下载）</li><li>application/x-www-form-urlencoded ： <form encType=””>中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）</li></ul><p>另外一种常见的媒体格式是上传文件之时使用的：</p><ul><li>multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式</li></ul><h3 id="16-import和require区别"><a href="#16-import和require区别" class="headerlink" title="16.import和require区别"></a>16.import和require区别</h3><ul><li><p>加载方式<br>require：运行时加载，所以require理论上可以运用在代码的任何地方<br>import：编译时加载，import是编译时调用，所以必须放在文件开头</p></li><li><p>遵循规范<br>require 是 AMD规范引入方式<br>import是es6的一个语法标准，如果要兼容浏览器的话必须转化成es5的语法</p></li><li><p>本质<br>require是赋值过程，其实require的结果就是对象、数字、字符串、函数等，再把require的结果赋值给某个变量import是解构过程，但是目前所有的引擎都还没有实现import，我们在node中使用babel支持ES6，也仅仅是将ES6转码为ES5再执行，import语法会被转码为require</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="built_in">exports</span>.fs = fs</span><br><span class="line"><span class="built_in">module</span>.exports = fs</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> fs&#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;readFile&#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;readFile <span class="keyword">as</span> read&#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> fs, &#123;readFile&#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> fs</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fs</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">readFile</span></span></span><br><span class="line"><span class="function"><span class="title">export</span> </span>&#123;readFile, read&#125;</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="17-ajax"><a href="#17-ajax" class="headerlink" title="17.ajax"></a>17.ajax</h3><p>ajax是异步javascript和xml；<br>Ajax是一种用于创建快速动态网页的技术。</p><p>ajax的使用及实现步骤：<br>1.创建XMLHttpRequest对象,也就是创建一个异步调用对象.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlHttp;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;  <span class="comment">//针对除IE6以外的浏览器</span></span><br><span class="line">    xmlHttp=<span class="keyword">new</span> XMLHttpRequest(); <span class="comment">//实例化一个XMLHttpRequest</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   xmlHttp=<span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);   <span class="comment">//针对IE5,IE6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(method,url,<span class="keyword">async</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure><p>3.设置响应HTTP请求状态变化的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xmlHttp.onreadystatechange()=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(xmlHttp.readyState === <span class="number">4</span> &amp;&amp; xmlHttp.status === <span class="number">200</span>)&#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>).innerHTML=xmlhttp.responseText;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//服务器响应<br>responseText:获得字符串形式的响应数据。<br>responseXML:获得 XML 形式的响应数据。<br>readyState:存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。</p><pre><code>0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪</code></pre><p>status:</p><pre><code>200: &quot;OK&quot;404: 未找到页面</code></pre><p>当 readyState 等于 4 且状态为 200 时，表示响应已就绪：<br>ajax步骤：</p><pre><code>创建XMLHttpRequest对象。设置请求方式。调用回调函数。发送请求。</code></pre><h3 id="18-闭包："><a href="#18-闭包：" class="headerlink" title="18.闭包："></a>18.闭包：</h3><p>函数A 里面包含了 函数B，而 函数B 里面使用了 函数A 的变量，那么 函数B 被称为闭包。</p><p>又或者：闭包就是能够读取其他函数内部变量的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特征：</p><ul><li>函数内再嵌套函数</li><li>内部函数可以引用外层的参数和变量</li><li>参数和变量不会被垃圾回收制回收  </li></ul><p>闭包的理解：使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。</p><p>在js中，函数即闭包，只有函数才会产生作用域的概念</p><p>闭包 的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中</p><ul><li>好处：能够实现封装和缓存等</li><li>坏处：消耗内存，使用不当造成内存泄漏；在退出函数之前，将不使用的局部变量全部删除</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：3个3<br>解析：首先，for 循环是同步代码，先执行三遍 for，i变成了 3；然后，再执行异步代码 setTimeout，这时候输出的 i，只能是 3 个 3 了<br>解决方法：<br>1.使用let i=0;每个 let 和代码块结合起来形成块级作用域，当 setTimeout() 打印时，会寻找最近的块级作用域中的 i，所以依次打印出 0 1 2<br>2.立即执行函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19-js作用域和作用域链"><a href="#19-js作用域和作用域链" class="headerlink" title="19.js作用域和作用域链"></a>19.js作用域和作用域链</h3><p>1.作用域</p><p>在JavaScript中，作用域分为 全局作用域 和 函数作用域</p><ul><li>全局作用域：<br>代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域</li><li>函数作用域：<br>在固定的代码片段才能被访问</li></ul><p>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</p><p>变量取值：到创建 这个变量 的函数的作用域中取值</p><p>2.作用域链</p><p>一般情况下，变量取值到 创建 这个变量 的函数的作用域中取值。</p><p>但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链</p><p>3.原型和原型链</p><p>概念：<br>每个对象在其内部都会初始化一个属性，这个属性就是prototype（原型），指向对象的原型对象，当访问一个对象的某个属性时，就会去对象中查找，如果对象中不存在这个属性就去prototype中查找，而prototype又有自己的prototype，</p><p>任何对象都有一个<code>__proto__</code>[[prototype]]）,它是一个指针，指向构造函数的原型对象。</p><p>原型和原型链的关系：</p><pre><code>instance.constructor.prototype =instance.__proto__构造函数的原型===实例化对象的原型链</code></pre><p>原型和原型链的特点:</p><pre><code>JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变</code></pre><p>当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性，如果没有的就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象</p><h3 id="20-组件化和模块化"><a href="#20-组件化和模块化" class="headerlink" title="20.组件化和模块化"></a>20.组件化和模块化</h3><p>1.组件化</p><ul><li>为什么要组件化?</li></ul><p>有时候页面代码量太大，逻辑太多或者同一个功能组件在许多页面均有使用，维护起来相当复杂，这个时候，就需要组件化开发来进行功能拆分、组件封装，已达到组件通用性，增强代码可读性，维护成本也能大大降低</p><ul><li>组件化开发的优点</li></ul><p>很大程度上降低系统各个功能的耦合性，并且提高了功能内部的聚合性，降低了开发成本</p><ul><li><p>组件化开发的准则：</p><p>  专一<br>  可配置性<br>  标准<br>  复用性<br>  可维护性</p></li></ul><p>2.模块化</p><ul><li>为什么要模块化?</li></ul><p>早期的javascript版本没有块级作用域、没有类、没有包、也没有模块，这样会带来一些问题，如复用、依赖、冲突、代码组织混乱等，随着前端的膨胀，模块化显得非常迫切</p><ul><li><p>模块化的好处</p><p>  提高代码可复用性<br>  避免变量污染，命名冲突<br>  提高可维护性<br>  方便依赖关系管理</p></li><li><p>模块化的几种方法：</p></li></ul><p>1)函数封装：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myModule = &#123;</span><br><span class="line">    var1: <span class="number">1</span>,</span><br><span class="line">    </span><br><span class="line">    var2: <span class="number">2</span>,</span><br><span class="line">    </span><br><span class="line">    fn1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    fn2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：这样避免了变量污染，只要保证模块名唯一即可，同时同一模块内的成员也有了关系</p><p>缺陷：外部可以睡意修改内部成员，这样就会产生意外的安全问题</p><p>2)立即执行函数表达式(IIFE)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myModule = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> var1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> var2 = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        fn1: fn1,</span><br><span class="line">        fn2: fn2</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>总结：这样在模块外部无法修改我们没有暴露出来的变量、函数</p><p>缺点：功能相对较弱，封装过程增加了工作量，仍会导致命名空间污染可能、闭包是有成本的</p><h3 id="21-图片的预加载和懒加载"><a href="#21-图片的预加载和懒加载" class="headerlink" title="21.图片的预加载和懒加载"></a>21.图片的预加载和懒加载</h3><ul><li>预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染</li><li>懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数<br>两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。预加载则会增加服务器前端压力，懒加载对服务器有一定的缓解压力作用。</li></ul><h3 id="22-mouseover和mouseenter的区别"><a href="#22-mouseover和mouseenter的区别" class="headerlink" title="22.mouseover和mouseenter的区别"></a>22.mouseover和mouseenter的区别</h3><ul><li>mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是mouseout</li><li>mouseenter：当鼠标移入元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是mouseleave</li></ul><p>解决异步回调地狱：promise、generator、async/await</p><h3 id="23-对This对象的理解"><a href="#23-对This对象的理解" class="headerlink" title="23.对This对象的理解"></a>23.对This对象的理解</h3><p>this总是指向函数的直接调用者（而非间接调用者）</p><p>如果有new关键字，this指向new出来的那个对象</p><p>在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window</p><p>this表示当前对象，this的指向是根据调用的上下文来决定的，默认指向window对象，指向window对象时可以省略不写</p><p>全局环境： this始终指向的是window对象<br>局部环境： 在全局作用域下直接调用函数，this指向window 对象函数调用，哪个对象调用就指向哪个对象 使用new实例化对象，在构造函数中的this指向实例化对象 使用call或apply改变this的指向<br>总结：this始终指向最后一个调用它的函数的对象</p><h3 id="24-ES6其他常用功能"><a href="#24-ES6其他常用功能" class="headerlink" title="24.ES6其他常用功能"></a>24.ES6其他常用功能</h3><ol><li>let/const</li><li>多行字符串/模板变量</li><li>解构赋值</li><li>块级作用域</li><li>函数默认参数</li><li>箭头函数</li></ol><h3 id="25-bind、call、apply用法及区别"><a href="#25-bind、call、apply用法及区别" class="headerlink" title="25.bind、call、apply用法及区别"></a>25.bind、call、apply用法及区别</h3><p>相同点： 三个函数的作用就是改变this的指向，将函数绑定到上下文中； 不同点： 三个函数的语法不同</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun.call(thisArg[, arg1[, arg2[, ...]]])</span><br><span class="line">fun.apply(thisArg, [argsArray])</span><br><span class="line"><span class="keyword">var</span> bindFn = fun.bind(thisArg[, arg1[, arg2[, ...]]])</span><br><span class="line">bindFn()</span><br></pre></td></tr></table></figure><h3 id="26-目前JS解决异步的方案有哪些"><a href="#26-目前JS解决异步的方案有哪些" class="headerlink" title="26.目前JS解决异步的方案有哪些"></a>26.目前JS解决异步的方案有哪些</h3><p>回调函数<br>事件监听<br>发布-订阅<br>Promise<br>Generator<br>Async/Await</p><h3 id="27-创建对象有几种方法"><a href="#27-创建对象有几种方法" class="headerlink" title="27.创建对象有几种方法"></a>27.创建对象有几种方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种：字面量</span></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;<span class="attr">name</span>: <span class="string">&quot;o1&quot;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;<span class="attr">name</span>: <span class="string">&quot;o2&quot;</span>&#125;)</span><br><span class="line"><span class="comment">// 第二种：通过构造函数</span></span><br><span class="line"><span class="keyword">var</span> M = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;<span class="built_in">this</span>.name = name&#125;</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="keyword">new</span> M(<span class="string">&quot;o3&quot;</span>)</span><br><span class="line"><span class="comment">// 第三种：Object.create()</span></span><br><span class="line"><span class="keyword">var</span> p = &#123;<span class="attr">name</span>: <span class="string">&quot;p&quot;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> o4 = <span class="built_in">Object</span>.create(p)</span><br></pre></td></tr></table></figure><h2 id="四-Vue"><a href="#四-Vue" class="headerlink" title="四.Vue"></a>四.Vue</h2><p>vue的生命周期：就是vue实例从创建到销毁的过程，也就是从开始创建，初始化数据，编译模版，挂载Dom，渲染更新，卸载等过程</p><h3 id="1-Vue生命周期的作用是什么？"><a href="#1-Vue生命周期的作用是什么？" class="headerlink" title="1.Vue生命周期的作用是什么？"></a>1.Vue生命周期的作用是什么？</h3><p>它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑</p><h3 id="2-Vue生命周期总共有几个阶段？"><a href="#2-Vue生命周期总共有几个阶段？" class="headerlink" title="2.Vue生命周期总共有几个阶段？"></a>2.Vue生命周期总共有几个阶段？</h3><p>它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后</p><h3 id="3-DOM渲染在哪个周期中就已经完成？"><a href="#3-DOM渲染在哪个周期中就已经完成？" class="headerlink" title="3.DOM渲染在哪个周期中就已经完成？"></a>3.DOM渲染在哪个周期中就已经完成？</h3><p>DOM 渲染在 mounted 中就已经完成了</p><h3 id="4-每个生命周期适合哪些场景？"><a href="#4-每个生命周期适合哪些场景？" class="headerlink" title="4.每个生命周期适合哪些场景？"></a>4.每个生命周期适合哪些场景？</h3><p>生命周期钩子的一些使用方法：<br>    beforecreate : 可以在这加个loading事件，在加载实例时触发<br>    created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用<br>    mounted : 挂载元素，获取到DOM节点<br>    updated : 如果对数据统一处理，在这里写上相应函数<br>    beforeDestroy : 销毁实例前做收尾清除工作<br>    nextTick : 更新数据后立即操作dom</p><h3 id="5-关于vue的keep-alive需要条件性缓存的解决"><a href="#5-关于vue的keep-alive需要条件性缓存的解决" class="headerlink" title="5.关于vue的keep-alive需要条件性缓存的解决"></a>5.关于vue的keep-alive需要条件性缓存的解决</h3><p>A&gt;B不缓存，C&gt;B需要缓存<br>在路由里面加上了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">&#x27;/b&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;B&#x27;</span>,</span><br><span class="line">    component: B,</span><br><span class="line">    meta:&#123;</span><br><span class="line">    keepAlive:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在app.vue写了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">    &lt;router-view v-<span class="keyword">if</span>=<span class="string">&quot;$route.meta.keepAlive&quot;</span>&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line">&lt;router-view v-<span class="keyword">if</span>=<span class="string">&quot;!$route.meta.keepAlive&quot;</span>&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure><p>A页面写了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">beforeRouteLeave</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span><br><span class="line">    to.meta.keepAlive = <span class="literal">false</span>;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C页面写了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">beforeRouteLeave</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span><br><span class="line">    to.meta.keepAlive = <span class="literal">true</span>;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>meta.keepAlive=true这种方法，解决不了条件缓存问题<br>原因：在keep-alive源码中，include和exclude是被watch的 ，当发生变化时，keep-alive会去校验cache里是否匹配，匹配不上的会被删除。也就是说，官方是为这种情况做了处理的。而meta这种方法，因为没有存在某种类似于watch的方法，导致这种方法天然是和实际cache里面的内容有出入的，所以可定会存在各种奇怪的bug</p><p>利用include,动态添加”B”<br>1、在app.vue下增加keep-alive</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">&quot;catchList&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><p>catchList，是vuex维护的需要缓存的组件名的一个数组</p><p>2、在路由中加入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to,next,<span class="keyword">from</span></span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (to.name === <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">        store.commit(<span class="string">&#x27;keepAlive&#x27;</span>, <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3、在b.vue中加入(A&gt;B不缓存，C&gt;B缓存)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteLeave(<span class="function">(<span class="params">to,next,<span class="keyword">from</span></span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (to.name !== <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">        store.commit(<span class="string">&#x27;noKeepAlive&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在vuex中mutation是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">keepAlive</span>(<span class="params">state, component</span>)</span> &#123;</span><br><span class="line">    !state.catchList.includes(component) &amp;&amp;</span><br><span class="line">      state.catchList.push(component)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">noKeepAlive</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">    state.catchList = []</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>只要是B的组件，都缓存。只有当从A&gt;B的时候，才让B不缓存。</p><h3 id="6-Vue-路由懒加载"><a href="#6-Vue-路由懒加载" class="headerlink" title="6.Vue 路由懒加载"></a>6.Vue 路由懒加载</h3><p>Vue项目中实现路由按需加载（路由懒加载）的3中方式：<br>一、Vue异步组件技术：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">path: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">name: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">component: <span class="function"><span class="params">resolve</span> =&gt;</span> reqire([<span class="string">&#x27;path路径&#x27;</span>], resolve)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、es6提案的import()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Home = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;path路径&#x27;</span>)</span><br></pre></td></tr></table></figure><p>三、webpack提供的require.ensure()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">path: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">name: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">component: <span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">require</span>.ensure([],<span class="function">() =&gt;</span>  r(<span class="built_in">require</span>(<span class="string">&#x27;path路径&#x27;</span>)), <span class="string">&#x27;demo&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-Proxy与Object-defineProperty-的对比"><a href="#7-Proxy与Object-defineProperty-的对比" class="headerlink" title="7.Proxy与Object.defineProperty()的对比"></a>7.Proxy与Object.defineProperty()的对比</h3><p>Proxy的优点：<br>         1. 可以直接监听对象而非属性,并返回一个新对象<br>        2. 可以直接监听数值的变化<br>        3. 可以劫持整个对象，并返回一个新对象</p><p>Proxy的缺点：<br>    Proxy是es6提供的新特性，兼容性不好，所以导致Vue3一致没有正式发布让让广大开发者使用，IE不兼容</p><p>Object.defineProperty的优点：<br>    IE9以下的版本不兼容</p><p>Object.defineProperty的缺点：<br>    只能劫持对象的属性，我们需要对每个对象的每个属性进行遍历，无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应</p><p>Proxy代理整个对象，Object.defineProperty只代理对象上的某个属性。<br>如果对象内部要全部递归代理，则Proxy可以只在调用时递归，而Object.defineProperty需要在一开始就全部递归，Proxy性能优于Object.defineProperty。<br>对象上定义新属性时，Proxy可以监听到，Object.defineProperty监听不到。<br>数组新增删除修改时，Proxy可以监听到，Object.defineProperty监听不到。<br>Proxy不兼容IE，Object.defineProperty不兼容IE8及以下。</p><h3 id="8-v-show与v-if区别"><a href="#8-v-show与v-if区别" class="headerlink" title="8.v-show与v-if区别"></a>8.v-show与v-if区别</h3><p>v-show是css切换，v-if是完整的销毁和重新创建</p><p>使用 频繁切换时用v-show，运行时较少改变时用v-if</p><p>v-if=’false’ v-if是条件渲染，当false的时候不会渲染</p><h3 id="9-vue有哪些指令"><a href="#9-vue有哪些指令" class="headerlink" title="9.vue有哪些指令"></a>9.vue有哪些指令</h3><ul><li><p>v-model //在表单控件或者组件上创建双向绑定</p></li><li><p>v-if  //根据表达式的值的 truthiness 来有条件地渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建</p></li><li><p>v-else-if </p></li><li><p>v-else</p></li><li><p>v-text //更新元素的 textContent</p></li><li><p>v-show //根据表达式之真假值，切换元素的 display CSS property。</p></li><li><p>v-html://更新元素的 innerHTML。注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译。如果试图使用 v-html 组合模板，可以重新考虑是否通过使用组件来替代。</p></li><li><p>v-on:绑定事件监听器</p></li><li><p>v-bind //动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。</p></li><li><p>v-for //基于源数据多次渲染元素或模板块</p></li><li><p>v-cloak //这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕</p></li><li><p>v-once //只渲染元素和组件一次</p></li><li><p>v-pre //跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。</p></li><li><p>v-slot //提供具名插槽或需要接收 prop 的插槽</p></li></ul><p>绑定class的数组用法</p><pre><code>对象方法: v-bind:class=&quot;&#123;&#39;orange&#39;: isRipe, &#39;green&#39;: isNotRipe&#125;&quot;数组方法:  v-bind:class=&quot;[class1, class2]&quot;行内: v-bind:style=&quot;&#123;color: color, fontSize: fontSize+&#39;px&#39; &#125;&quot;</code></pre><h3 id="10-组件之间的传值通信"><a href="#10-组件之间的传值通信" class="headerlink" title="10.组件之间的传值通信"></a>10.组件之间的传值通信</h3><ul><li><p>父组件给子组件传值:props</p></li><li><p>子组件向父组件通信:父组件向子组件传递事件方法，子组件通过$emit触发事件，回调给父组件</p></li><li><p>非父子，兄弟组件之间通信:<br>可以通过实例一个vue实例Bus作为媒介，要相互通信的兄弟组件之中，都引入Bus，然后通过分别调用Bus事件触发和监听来实现通信和参数传递</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;button @click=<span class="string">&quot;toBus&quot;</span>&gt;子组件传给兄弟组件&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> Bus <span class="keyword">from</span> <span class="string">&#x27;../common/js/bus.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        toBus () &#123;</span><br><span class="line">            Bus.$emit(<span class="string">&#x27;on&#x27;</span>, <span class="string">&#x27;来自兄弟组件&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>另一个组件也import Bus.js 在钩子函数中监听on事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Bus <span class="keyword">from</span> <span class="string">&#x27;../common/js/bus.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">        message: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        Bus.$on(<span class="string">&#x27;on&#x27;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.message = msg</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-子组件调用父组件的方法函数"><a href="#11-子组件调用父组件的方法函数" class="headerlink" title="11.子组件调用父组件的方法函数"></a>11.子组件调用父组件的方法函数</h3><ul><li>直接在子组件中通过this.$parent.event来调用父组件的方法</li><li>在子组件里用$emit向父组件触发一个事件，父组件监听这个事件就行了</li><li>父组件把方法传入子组件中，在子组件里直接调用这个方法</li></ul><h3 id="12-路由跳转方式"><a href="#12-路由跳转方式" class="headerlink" title="12.路由跳转方式"></a>12.路由跳转方式</h3><p><router-link to='home'> router-link标签会渲染为<a>标签</p><p>另一种是编程是导航 也就是通过js跳转 比如 router.push(‘/home’)</p><h3 id="13-mvvm"><a href="#13-mvvm" class="headerlink" title="13.mvvm"></a>13.mvvm</h3><ul><li><p>M - Model，Model 代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑</p></li><li><p>V - View，View 代表 UI 组件，它负责将数据模型转化为 UI 展现出来</p></li><li><p>VM - ViewModel，ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步 View 和 Model 的对象，连接 Model 和 View之间的桥梁，绑定数据到viewmodel层并自动更新渲染到页面上，视图变化通知到viewmodel层去更新数据</p></li></ul><h3 id="14-computed和watch有什么区别"><a href="#14-computed和watch有什么区别" class="headerlink" title="14.computed和watch有什么区别?"></a>14.computed和watch有什么区别?</h3><ul><li><p>computed:</p><ol><li>computed是计算属性,也就是计算值,它更多用于计算值的场景</li><li>computed具有缓存性,computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时才会重新调用对应的getter来计算</li><li>computed适用于计算比较消耗性能的计算场景</li></ol></li><li><p>watch：</p><ol><li>更多的是「观察」的作用,类似于某些数据的监听回调,用于观察props $emit或者本组件的值,当数据变化时来执行回调进行后续操作</li><li>无缓存性，页面重新渲染时值不变化也会执行</li></ol></li><li><p>小结：</p><ol><li>当我们要进行数值计算,而且依赖于其他数据，那么把这个数据设计为computed</li><li>如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化</li></ol></li></ul><h3 id="15-key"><a href="#15-key" class="headerlink" title="15.key"></a>15.key</h3><p>key是为Vue中的vnode标记的唯一id，通过这个key，我们的diff操作可以 更准确、更快速</p><ul><li><p>准确:<br>  如果不加key,那么vue会选择复用节点(Vue的就地更新策略),<br>  导致之前节点的状态被保留下来，会产生一系列的bug</p></li><li><p>快速:<br>  key的唯一性可以被Map数据结构充分利用</p></li></ul><p>预期：number | string</p><p>key 的特殊属性主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key的变化重新排列元素顺序，并且会移除 key 不存在的元素。</p><p>有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误。</p><p>最常见的用例是结合 v-for：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用：</p><ul><li>完整地触发组件的生命周期钩子</li><li>触发过渡</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">:key</span>=<span class="string">&quot;text&quot;</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当 text 发生改变时，<span> 总是会被替换而不是被修改，因此会触发过渡</p><h3 id="16-组件中的data为什么是函数？"><a href="#16-组件中的data为什么是函数？" class="headerlink" title="16.组件中的data为什么是函数？"></a>16.组件中的data为什么是函数？</h3><p>组件可以被多次复用，创建多个实例，这些实例本质是同一个构造函数，如果data是对象，对象是引用类型，修改对象会影响所有实例，因此data是一个函数</p><h3 id="17-Class-与-Style-如何动态绑定？"><a href="#17-Class-与-Style-如何动态绑定？" class="headerlink" title="17.Class 与 Style 如何动态绑定？"></a>17.Class 与 Style 如何动态绑定？</h3><p>1)class<br>对象语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;&#123; &#x27;active&#x27;: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  hasError: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  activeClass: <span class="string">&#x27;active&#x27;</span>,</span><br><span class="line">  errorClass: <span class="string">&#x27;text-danger&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2)style：</p><p>对象语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=<span class="string">&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  activeColor: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">  fontSize: <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=<span class="string">&quot;[styleColor, styleSize]&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  styleColor: &#123;</span><br><span class="line">     color: <span class="string">&#x27;red&#x27;</span></span><br><span class="line">   &#125;,</span><br><span class="line">  styleSize:&#123;</span><br><span class="line">     fontSize:<span class="string">&#x27;23px&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18-vue的单向数据流"><a href="#18-vue的单向数据流" class="headerlink" title="18.vue的单向数据流"></a>18.vue的单向数据流</h3><p>所有的 prop都使得其父子prop之间形成了一个单向下行绑定：<br>父级 prop的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解</p><p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。<br>这意味着你不应该在一个子组件内部改变prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。<br>子组件想修改时，只能通过 $emit派发一个自定义事件，父组件接收到后，由父组件修改</p><p>有两种常见的试图改变一个 prop 的情形 :</p><p>1)这个 prop 用来传递一个初始值:<br>这个子组件接下来希望将其作为一个本地的 prop 数据来使用，在这种情况下，最好定义一个本地的 data属性并将这个 prop 用作其初始值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">&#x27;initialCounter&#x27;</span>],</span><br><span class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter: <span class="built_in">this</span>.initialCounter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2)prop 以一种原始的值传入且需要进行转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">&#x27;size&#x27;</span>],</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedSize: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19-keep-alive"><a href="#19-keep-alive" class="headerlink" title="19.keep-alive"></a>19.keep-alive</h3><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p><ul><li><p>一般结合路由和动态组件一起使用，用于缓存组件；</p></li><li><p>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include表示只有名称匹配的组件会被缓存，exclude表示任何名称匹配的组件都不会被缓存 ，其中 exclude的优先级比 include 高；</p></li><li><p>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</p></li></ul><h3 id="20-v-model-的原理"><a href="#20-v-model-的原理" class="headerlink" title="20.v-model 的原理"></a>20.v-model 的原理</h3><p>vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p><ul><li>text 和 textarea 元素使用 value 属性和 input 事件；</li><li>checkbox 和 radio 使用 checked 属性和 change 事件；</li><li>select 字段将 value 作为 prop 并将 change 作为事件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&#x27;something&#x27;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 相当于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;something&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;something = $event.target.value&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件</p><h3 id="21-nextTick"><a href="#21-nextTick" class="headerlink" title="21.nextTick()"></a>21.nextTick()</h3><p>在下次DOM更新循环结束之后执行延迟回调。在修改数据之后，立即使用的这个回调函数，获取更新后的DOM</p><h3 id="22-vue插槽"><a href="#22-vue插槽" class="headerlink" title="22.vue插槽"></a>22.vue插槽</h3><ul><li><p>单个插槽：<br>  当子组件模板只有一个没有属性的插槽时，<br>  父组件传入的整个内容片段将插入到插槽所在的 DOM 位置，<br>  并替换掉插槽标签本身</p></li><li><p>命名插槽：<br>  solt元素可以用一个特殊的特性name来进一步配置如何分发内容。<br>  多个插槽可以有不同的名字。 这样可以将父组件模板中 slot 位置，<br>  和子组件 slot 元素产生关联，便于插槽内容对应传递</p></li><li><p>作用域插槽：<br>  可以访问组件内部数据的可复用插槽(reusable slot)<br>  在父级中，具有特殊特性 slot-scope 的<code>&lt;template&gt;</code> 元素必须存在，<br>  表示它是作用域插槽的模板。slot-scope 的值将被用作一个临时变量名，<br>  此变量接收从子组件传递过来的 prop 对象</p></li></ul><h3 id="23-导航守卫"><a href="#23-导航守卫" class="headerlink" title="23.导航守卫"></a>23.导航守卫</h3><p>vue-router提供的导航守卫主要通过跳转或取消的方式守卫导航<br>参数或查询的改变不会触发进入/离开的导航守卫<br>你可以通过观察 $route 对象来应对这些变化，或使用beforeRouteUpdate 的组件内守卫</p><ul><li>全局前置守卫：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 等待中</p><p>to: Route: 即将要进入的目标 路由对象</p><p>from: Route: 当前导航正要离开的路由</p><p>next: Function: 一定要调用该方法来 resolve这个钩子。执行效果依赖 next 方法的调用参数。<br>确保要调用 next 方法，否则钩子就不会被 resolved</p><ul><li>路由独享的守卫</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;/foo&#x27;</span>,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>组件内的守卫</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  template: <span class="string">`...`</span>,</span><br><span class="line">  beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在渲染该组件的对应路由被 confirm 前调用</span></span><br><span class="line">    <span class="comment">// 不！能！获取组件实例 `this`</span></span><br><span class="line">    <span class="comment">// 因为当守卫执行前，组件实例还没被创建</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span><br><span class="line">    <span class="comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span><br><span class="line">    <span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 导航离开该组件的对应路由时调用</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vue-router有哪几种导航钩子</p><pre><code>第一种：是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截第二种：组件内的钩子：beforeRouteEnter/beforeRouteUpdate/beforeRouteLeave第三种：单独路由独享组件：beforeEnter</code></pre><h3 id="24-vuex是什么？"><a href="#24-vuex是什么？" class="headerlink" title="24.vuex是什么？"></a>24.vuex是什么？</h3><p>vuex是专门为vuejs应用程序开发的状态管理插件，集中存储管理组件状态，通过显式提交mutation改变组件状态<br>vuex 就是一个仓库，仓库里放了很多对象。其中 state就是数据源存放地，对应于一般 vue 对象里面的 data</p><p>state 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新</p><p>它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性</p><p>Vuex有5种属性: 分别是 state、getter、mutation、action、module;</p><ul><li><p>state<br>  Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据</p></li><li><p>mutations<br>  mutations定义的方法动态修改Vuex 的 store 中的状态或数据</p></li><li><p>getters<br>  类似vue的计算属性，主要用来过滤一些数据</p></li><li><p>actions<br>  actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action</p></li><li><p>modules<br>  由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得复杂时，store对象就变得臃肿。为了解决以上问题，vuex允许将store分隔成模块。每个模块有自己的state/getter/mutation/action,甚至是嵌套子模块。<br>总结<br>vuex 一般用于中大型 web 单页应用中对应用的状态进行管理，对于一些组件间关系较为简单的小型应用，使用 vuex 的必要性不是很大，因为完全可以用组件 prop属性或者事件来完成父子组件之间的通信，vuex 更多地用于解决跨组件通信以及作为数据中心集中式存储数据</p></li></ul><p>vuex解决了什么？<br>    多个组件依赖同一个状态，多层组件间传值<br>    来自不同的组件的行为需要变更同一个状态</p><h3 id="25-优化SPA首屏加载速度"><a href="#25-优化SPA首屏加载速度" class="headerlink" title="25.优化SPA首屏加载速度"></a>25.优化SPA首屏加载速度</h3><ul><li><p>缩小webpack或者其他打包工具生成的包的大小</p><p>  用webpack-bundle-analyzer的分析工具哪个模块占空间大</p></li><li><p>第三方UI组件按需引入</p></li><li><p>使用服务端渲染方式（基于vue的nuxt.js开发）</p></li><li><p>使用预渲染的方式</p><p>  在打包时会预先运行一次js代码，将一部分静态页面直接渲染成html写在生成的index.html中，在加载完index.html后页面就能展示，无需等待加载js缺点是在需要预渲染的页面较多时，build打包的时间会十分漫长</p></li><li><p>使用gzip减小网络传输的流量大小</p><p>  HTTP协议上的gzip编码是一种用来改进web应用程序性能的技术，web服务器和客户端（浏览器）必须共同支持gzip，使用gzip可以将原静态文件压缩到30%，效果很明显，对于优化首屏加载时间非常适合在nginx中配置<br>  http{<br>  gzip on;<br>  }</p></li><li><p>组件懒加载</p></li></ul><h3 id="26-你有对-Vue-项目进行哪些优化？"><a href="#26-你有对-Vue-项目进行哪些优化？" class="headerlink" title="26.你有对 Vue 项目进行哪些优化？"></a>26.你有对 Vue 项目进行哪些优化？</h3><p>1)代码层面的优化</p><ul><li>v-if 和 v-show 区分使用场景</li><li>computed 和 watch  区分使用场景</li><li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li><li>长列表性能优化</li><li>事件的销毁</li><li>图片资源懒加载</li><li>路由懒加载</li><li>第三方插件的按需引入</li><li>优化无限列表性能</li><li>服务端渲染 SSR or 预渲染</li><li>减少data中数据</li><li>SPA采用keep-alive缓存组件</li></ul><p>2)Webpack 层面的优化</p><ul><li>Webpack 对图片进行压缩</li><li>减少 ES6 转为 ES5 的冗余代码</li><li>提取公共代码</li><li>模板预编译</li><li>提取组件的 CSS</li><li>优化 SourceMap</li><li>构建结果输出分析</li><li>Vue 项目的编译优化</li><li>压缩代码</li><li>tree shaking</li><li>cdn加载第三方模块</li><li>sourcemap优化</li></ul><p>3)基础的 Web 技术的优化</p><ul><li>开启 gzip 压缩</li><li>浏览器缓存</li><li>CDN 的使用</li><li>使用 Chrome Performance 查找性能瓶颈</li></ul><h2 id="五-ES6"><a href="#五-ES6" class="headerlink" title="五.ES6"></a>五.ES6</h2><h3 id="1-var-let-const区别"><a href="#1-var-let-const区别" class="headerlink" title="1.var let const区别"></a>1.var let const区别</h3><p>let、const声明的变量仅在块级作用域内有效，var声明变<br>量是全局的，没有块级作用域功能<br>let 、const 不存在变量提升 , var 存在变量提升<br>let 、const不能在同一块级作用域内重复申请</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">test();<span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">test();<span class="comment">//ReferenceError: Cannot access &#x27;name&#x27; before initialization</span></span><br></pre></td></tr></table></figure><p>通过 var 声明的变量有初始值 undefined，而通过 let声明的变量直到定义的代码被执行时才会初始化。在变量初始化前访问变量会导致 ReferenceError</p><h3 id="2-解构赋值"><a href="#2-解构赋值" class="headerlink" title="2.解构赋值"></a>2.解构赋值</h3><p>1)数组解构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]   <span class="comment">//a=1, b=2, c=3</span></span><br><span class="line"><span class="keyword">let</span> [d, [e], f] = [<span class="number">1</span>, [<span class="number">2</span>], <span class="number">3</span>]    <span class="comment">//嵌套数组解构 d=1, e=2, f=3</span></span><br><span class="line"><span class="keyword">let</span> [g, ...h] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]   <span class="comment">//数组拆分 g=1, h=[2, 3]</span></span><br><span class="line"><span class="keyword">let</span> [i,,j] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]   <span class="comment">//不连续解构 i=1, j=3</span></span><br><span class="line"><span class="keyword">let</span> [k,l] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]   <span class="comment">//不完全解构 k=1, l=2</span></span><br></pre></td></tr></table></figure><p>2)对象解构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a, b&#125; = &#123;<span class="attr">a</span>: <span class="string">&#x27;aaaa&#x27;</span>, <span class="attr">b</span>: <span class="string">&#x27;bbbb&#x27;</span>&#125;      <span class="comment">//a=&#x27;aaaa&#x27; b=&#x27;bbbb&#x27;</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">d</span>: <span class="string">&#x27;aaaa&#x27;</span>, <span class="attr">e</span>: &#123;<span class="attr">f</span>: <span class="string">&#x27;bbbb&#x27;</span>&#125;&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;d, <span class="attr">e</span>:&#123;f&#125;&#125; = obj    <span class="comment">//嵌套解构 d=&#x27;aaaa&#x27; f=&#x27;bbbb&#x27;</span></span><br><span class="line"><span class="keyword">let</span> g;</span><br><span class="line">(g = &#123;<span class="attr">g</span>: <span class="string">&#x27;aaaa&#x27;</span>&#125;)   <span class="comment">//以声明变量解构 g=&#x27;aaaa&#x27;</span></span><br><span class="line"><span class="keyword">let</span> [h, i, j, k] = <span class="string">&#x27;nice&#x27;</span>    <span class="comment">//字符串解构 h=&#x27;n&#x27; i=&#x27;i&#x27; j=&#x27;c&#x27; k=&#x27;e&#x27;</span></span><br></pre></td></tr></table></figure><p>函数参数的定义  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">personInfo</span>(<span class="params">name, age, address, gender</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name, age, address, gender)</span><br><span class="line">&#125;</span><br><span class="line">personInfo(<span class="string">&#x27;william&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;changsha&#x27;</span>, <span class="string">&#x27;man&#x27;</span>)</span><br></pre></td></tr></table></figure><p>上面这个例子在对用户信息的时候需要传递四个参数，且需要一一对应，这样就会极易出现参数顺序传错的情况，从而导致bug，接下来来看es6解构赋值是怎么解决这个问题的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">personInfo</span>(<span class="params">&#123;name, age, address, gender&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name, age, address, gender)</span><br><span class="line">&#125;</span><br><span class="line">personInfo(&#123;<span class="attr">gender</span>: <span class="string">&#x27;man&#x27;</span>, <span class="attr">address</span>: <span class="string">&#x27;changsha&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;william&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;)</span><br></pre></td></tr></table></figure><p>交换变量的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="number">1</span>, b=<span class="number">2</span>;</span><br><span class="line">[b, a] = [a, b]</span><br><span class="line"><span class="built_in">console</span>.log(a, b)</span><br></pre></td></tr></table></figure><p>函数默认参数</p><p>es5：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveInfo</span>(<span class="params">name, age, address, gender</span>) </span>&#123;</span><br><span class="line">  name = name || <span class="string">&#x27;william&#x27;</span></span><br><span class="line">  age = age || <span class="number">18</span></span><br><span class="line">  address = address || <span class="string">&#x27;changsha&#x27;</span></span><br><span class="line">  gender = gender || <span class="string">&#x27;man&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(name, age, address, gender)</span><br><span class="line">&#125;</span><br><span class="line">saveInfo()</span><br></pre></td></tr></table></figure><p>es6:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveInfo</span>(<span class="params">&#123;name= <span class="string">&#x27;william&#x27;</span>, age= <span class="number">18</span>, address= <span class="string">&#x27;changsha&#x27;</span>, gender= <span class="string">&#x27;man&#x27;</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name, age, address, gender)</span><br><span class="line">&#125;</span><br><span class="line">saveInfo()</span><br></pre></td></tr></table></figure><h3 id="3-forEach、for-in、for-of三者区别"><a href="#3-forEach、for-in、for-of三者区别" class="headerlink" title="3.forEach、for in、for of三者区别"></a>3.forEach、for in、for of三者区别</h3><ul><li><p>forEach更多的用来遍历数组，无法return或break</p></li><li><p>for in 一般常用来遍历对象或json，循环遍历的值都是数据结构的键值，也遍历数组</p></li><li><p>for of数组对象都可以遍历，遍历对象需要通过和Object.keys()一起使用<br>它是ES6中新增加的语法，用来循环获取一对键值对中的值<br>一个数据结构只有部署了 Symbol.iterator 属性, 才具有 iterator接口可以使用 for of循环<br>以下数据结构部署了 Symbol.iteratoer属性：</p><ul><li>数组</li><li>Map</li><li>Set</li><li>String</li><li>Nodelist</li><li>arguments对象<br>如果想让对象可以使用 for of循环怎么办?使用 Object.keys() 获取对象的 key值集合后,再使用 for of<br>或者使用内置的Object.values()方法获取对象的value值集合再使用for of</li></ul></li><li><p>for in循环出的是key，for of循环出的是value</p></li></ul><h3 id="4-使用箭头函数应注意什么？"><a href="#4-使用箭头函数应注意什么？" class="headerlink" title="4.使用箭头函数应注意什么？"></a>4.使用箭头函数应注意什么？</h3><ul><li>1、用了箭头函数，this就不是指向window，而是父级（指向是可变的）</li><li>2、不能够使用arguments对象</li><li>3、不能用作构造函数，这就是说不能够使用new命令，否则会抛出一个错误</li><li>4、不可以使用yield命令，因此箭头函数不能用作 Generator 函数</li></ul><h3 id="5-Set、Map的区别"><a href="#5-Set、Map的区别" class="headerlink" title="5.Set、Map的区别"></a>5.Set、Map的区别</h3><p>应用场景Set用于数据重组，Map用于数据储存</p><ul><li>Set：<br>  1，成员不能重复<br>  2，只有键值没有键名，类似数组<br>  3，可以遍历，方法有add, delete,has</li><li>Map:<br>  1，本质上是健值对的集合，类似集合<br>  2，可以遍历，可以跟各种数据格式转换</li></ul><h3 id="6-Ajax："><a href="#6-Ajax：" class="headerlink" title="6.Ajax："></a>6.Ajax：</h3><p>1.创建一个XmlHttpRequest对象，也就是创建一个异步调用对象<br>2.创建一个发送请求到方法，设置http请求方法，url和验证信息<br>3.设置请求状态变化到方法<br>4.发送请求<br>5.获取异步调用返回的数据<br>6.使用js和dom实现局部刷新</p><h3 id="7-同步和异步的区别"><a href="#7-同步和异步的区别" class="headerlink" title="7.同步和异步的区别"></a>7.同步和异步的区别</h3><ul><li>同步：<br>按照一定的顺序去执行，执行完一个才能执行下一个浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作</li><li>异步：<br>浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容执行顺序是不确定的，由触发条件决定，什么时间执行也是不确定的，即使是定时器（下面做解释），异步处理可以同时执行多个。</li></ul><h3 id="8-ajax的优点和缺点"><a href="#8-ajax的优点和缺点" class="headerlink" title="8.ajax的优点和缺点"></a>8.ajax的优点和缺点</h3><ul><li><p>ajax的优点<br>  1、无刷新更新数据（在不刷新整个页面的情况下维持与服务器通信）<br>  2、异步与服务器通信（使用异步的方式与服务器通信，不打断用户的操作）<br>  3、前端和后端负载均衡（将一些后端的工作交给前端，减少服务器与宽度的负担）<br>  4、界面和应用相分离（ajax将界面和应用分离也就是数据与呈现相分离）</p></li><li><p>ajax的缺点<br>  1、ajax不支持浏览器back按钮<br>  2、安全问题 Aajax暴露了与服务器交互的细节<br>  3、对搜索引擎的支持比较弱<br>  4、破坏了Back与History后退按钮的正常行为等浏览器机制</p></li></ul><h3 id="9-get和post的区别"><a href="#9-get和post的区别" class="headerlink" title="9.get和post的区别"></a>9.get和post的区别</h3><p>1、get和post在HTTP中都代表着请求数据，其中get请求相对来说更简单、快速，效率高些<br>2、get相对post安全性低<br>3、get有缓存，post没有<br>4、get体积小，post可以无限大<br>5、get的url参数可见，post不可见<br>6、get只接受ASCII字符的参数数据类型，post没有限制<br>7、get请求参数会保留历史记录，post中参数不会保留<br>8、get会被浏览器主动catch，post不会，需要手动设置<br>9、get在浏览器回退时无害，post会再次提交请求</p><h3 id="10-什么时候使用post？"><a href="#10-什么时候使用post？" class="headerlink" title="10.什么时候使用post？"></a>10.什么时候使用post？</h3><p>post一般用于修改服务器上的资源，对所发送的信息没有限制。比如<br>    1、无法使用缓存文件（更新服务器上的文件或数据库）<br>    2、向服务器发送大量数据（POST 没有数据量限制）<br>    3、发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</p><h3 id="11-同源策略"><a href="#11-同源策略" class="headerlink" title="11.同源策略"></a>11.同源策略</h3><p>同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能相互读取对方资源</p><p>同源策略限制了一个源的文档和脚本和另一个源的资源进行交互，是一个隔离潜在恶意文件攻击的安全机制</p><p>不受同源策略限制的：</p><p>1.页面中的连接，重定向和表单提交<br>2.第三方js的引入不受限制，但不能js读写加载的内容，script，link，img，iframe</p><h3 id="12-如何解决跨域问题"><a href="#12-如何解决跨域问题" class="headerlink" title="12.如何解决跨域问题?"></a>12.如何解决跨域问题?</h3><p>跨域的概念：协议、域名、端口都相同才同域，否则都是跨域</p><p>解决跨域问题：</p><p>1、 通过jsonp跨域<br>2、 document.domain + iframe跨域<br>3、 location.hash + iframe<br>4、 window.name + iframe跨域<br>5、 postMessage跨域<br>6、 跨域资源共享（CORS）<br>7、 nginx代理跨域<br>8、 nodejs中间件代理跨域<br>9、 WebSocket协议跨域</p><h2 id="六-浏览器"><a href="#六-浏览器" class="headerlink" title="六.浏览器"></a>六.浏览器</h2><h3 id="1-主流浏览器"><a href="#1-主流浏览器" class="headerlink" title="1.主流浏览器"></a>1.主流浏览器</h3><p>IE Google Chrome Firefox Opera Safari</p><h3 id="2-浏览器内核"><a href="#2-浏览器内核" class="headerlink" title="2.浏览器内核"></a>2.浏览器内核</h3><p>渲染引擎和js引擎<br>渲染引擎：用来解释网页语法并渲染到网页上</p><p>浏览器内核决定了如何显示网页内容和格式化的信息<br>Trident：IE、360<br>Gecko：火狐<br>Presto：Opera<br>Blink：Opera，Googlechrome<br>webkit：Safari</p><h3 id="3-浏览器兼容"><a href="#3-浏览器兼容" class="headerlink" title="3.浏览器兼容"></a>3.浏览器兼容</h3><p>1.不同浏览器默认内外边距不同：*{margin:0;padding:0}<br>2.图片默认有间距:img设置float<br>3. IE6双边距bug：块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大。hack：display:inline;将其转化为行内属性。<br>4. 设置较小高度标签（一般小于10px），在IE6，IE7中高度超出自己设置高度。hack：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。<br>5. Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。<br>6. 超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有hover和active了。解决方法是改变CSS属性的排列顺序:L-V-H-A ( love hate ): a:link {} a:visited {} a:hover {} a:active {}</p><h2 id="七-其他"><a href="#七-其他" class="headerlink" title="七.其他"></a>七.其他</h2><h3 id="1-前端组件化和模块化"><a href="#1-前端组件化和模块化" class="headerlink" title="1.前端组件化和模块化"></a>1.前端组件化和模块化</h3><p>组件化：组件化是具体的，按照一些功能的通用性和复用性来抽象组件侧重于UI部分，比如弹窗按钮</p><p>模块化：模块化是抽象的，按照项目业务划分的大块侧重于数据数据的封装</p><p>对于组件来说，其主要是提高代码的复用性，功能单一独立模块是将同一类型的代码整合在一起，例如用户信息，设置等，所以模块等功能相当复杂，但都同属于同一业务（提高内聚降低耦合）</p><h3 id="2-什么是Ajax和JSON，它们的优点和缺点"><a href="#2-什么是Ajax和JSON，它们的优点和缺点" class="headerlink" title="2.什么是Ajax和JSON，它们的优点和缺点"></a>2.什么是Ajax和JSON，它们的优点和缺点</h3><ul><li><p>Ajax：</p><p>  Ajax是异步JavaScript和XML，用于在Web页面中实现异步数据交互<br>  Ajax优点：<br>  异步请求响应快，用户体验好；页面无刷新、数据局部更新；按需取数据，减少了冗余请求和服务器的负担；<br>  Ajax缺点：<br>  异步回调问题、this指向问题、路由跳转back问题；对搜索引擎的支持比较弱，对于一些手机还不是很好的支持</p></li><li><p>JSON：</p><p>  是一种轻量级的数据交换格式，看着像对象，本质是字符串<br>  JSON优点：<br>  轻量级、易于人的阅读和编写，便于js解析，支持复合数据类型<br>  JSON缺点：<br>  没有XML格式这么推广的深入人心和使用广泛, 没有XML那么通用性。</p></li></ul><h3 id="3-Github"><a href="#3-Github" class="headerlink" title="3.Github"></a>3.Github</h3><p>git常用的命令<br>从远程库克隆到本地：git clone 网站上的仓库地址<br>新增文件的命令：git add .<br>提交文件的命令：git commit –m或者git commit –a<br>查看工作区状况：git status –s<br>拉取合并远程分支的操作：git fetch/git merge或者git pull<br>查看提交记录命令：git reflog</p><h3 id="4-webpack"><a href="#4-webpack" class="headerlink" title="4.webpack"></a>4.webpack</h3><p>webpack打包原理：<br>webpack只是一个打包模块的机制，只是把依赖的模块转化成可以代表这些包的静态文件。webpack就是识别你的入口文件。识别你的模块依赖，来打包你的代码。至于你的代码使用的是commonjs还是amd或者es6的import。webpack都会对其进行分析。来获取代码的依赖。webpack做的就是分析代码，转换代码，编译代码，输出代码。webpack本身是一个node的模块，所以webpack.config.js是以commonjs形式书写的(node中的模块化是commonjs规范的)</p><p>webpack 核心概念<br>1.entry<br>入口起点(entry point)指示 webpack 应该使用哪个模块,来作为构建其内部依赖图的开始. 进入入口起点后,webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。 每个依赖项随即被处理,最后输出到称之为 bundles 的文件中。</p><p>2.output<br>output 属性告诉 webpack 在哪里输出它所创建的bundles,以及如何命名这些文件,默认值为 ./dist。 基本上整个应用程序结构,都会被编译到你指定的输出路径的文件夹中。</p><p>3.Module 模块<br>在 Webpack 里一切皆模块,一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块</p><p>4.chunk 代码块<br>一个 Chunk 由多个模块组合而成,用于代码合并与分割。</p><p>5.loader<br>loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。 loader 可以将所有类型的文件转换为 webpack能够处理的有效模块,然后你就可以利用 webpack 的打包能力,对它们进行处理。 本质上,webpack loader将所有类型的文件,转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。</p><p>6.Plugin<br>loader 被用于转换某些类型的模块,而插件则可以用于执行范围更广的任务。 插件的范围包括,从打包优化和压缩,一直到重新定义环境中的变量。插件接口功能极其强大,可以用来处理各种各样的任务。</p><p>模块热更新<br>模块热更新是webpack的一个功能，他可以使代码修改过后不用刷新就可以更新，是高级版的自动刷新浏览器</p><p>devServer中通过hot属性可以控制模块的热替换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> env = process.env.NODE_ENV == <span class="string">&quot;development&quot;</span> ? <span class="string">&quot;development&quot;</span> : <span class="string">&quot;production&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  mode: env,</span><br><span class="line"> devServer: &#123;</span><br><span class="line">     hot:<span class="literal">true</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">  plugins: [</span><br><span class="line">     <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(), <span class="comment">//热加载插件</span></span><br><span class="line">  ],</span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure><p>webpack的优点</p><pre><code>专注于处理模块化的项目，能做到开箱即用，一步到位可通过plugin扩展，完整好用又不失灵活使用场景不局限于web开发社区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展良好的开发体验</code></pre><p>webpack的缺点</p><pre><code>webpack的缺点是只能用于采用模块化开发的项目</code></pre><h3 id="5-微信小程序"><a href="#5-微信小程序" class="headerlink" title="5.微信小程序"></a>5.微信小程序</h3><ul><li>onLoad()：页面加载时触发。</li><li>onReady()：页面初次渲染完成时触发。</li><li>onShow()：页面显示/切入前台时触发。</li><li>onHide()：页面隐藏/切入后台时触发。</li><li>onUnload()：页面卸载时触发。</li></ul><p>小程序运行环境分为渲染层和逻辑层，其中wxml和wxss工作在渲染层，js工作在逻辑层</p><p>小程序的渲染层和逻辑层分别由两个线程来管理：渲染层的界面使用webview来管理，逻辑层使用jscore来运行js脚本，一个小程序存在多个界面，所以渲染层有多个webview，两个线程通过微信客户端做中转，逻辑层请求网络经由客户端转发</p><h3 id="6-微信小程序支付流程："><a href="#6-微信小程序支付流程：" class="headerlink" title="6.微信小程序支付流程："></a>6.微信小程序支付流程：</h3><ul><li>1.wx.login用code换取openid</li><li>2.生成商户订单</li><li>3.调用支付统一下单api，返回预付单信息prepay_id</li><li>4.将组合数据再次签名，返回5个参数和sign</li><li>5.小程序获取参数后，鉴权调起支付</li><li>6.返回支付结果给小程序，推送支付结果给商户，修改订单状态</li></ul><p><img src="/ZJY.github.io/timages/weappPay.png" alt="image"></p><h3 id="7-微信网页授权流程"><a href="#7-微信网页授权流程" class="headerlink" title="7.微信网页授权流程"></a>7.微信网页授权流程</h3><p>前置条件：<br>        公众平台设置授权回调域名，在域名内页面可进行OAuth2.0鉴权</p><p>关于网页授权的两种scope的区别说明<br>1.以snsapi_base为scope发起的网页授权，是用来获取进入页面的用户的openid的，并且是静默授权跳转到回调页面的<br>2.snsapi_userinfo为scope发起的网页授权，是用来获取用户基本信息的，但是需要用户手动同意，由于用户同意过所以无需关注就可获取用户基本信息<br>3、用户管理类接口中的“获取用户基本信息接口”，是在用户和公众号产生消息交互或关注后事件推送后，才能根据用户OpenID来获取用户基本信息。这个接口，包括其他微信接口，都是需要该用户（即openid）关注了公众号后，才能调用成功的。</p><p>网页授权流程分为四步：<br>        1.引导用户进入授权页面，同意授权，获取code<br>        2.通过code换取网页授权access_token<br>        3.如果需要，刷新access_token<br>        4.通过access_token和opened获取用户基本信息</p><h3 id="8-小程序登录流程"><a href="#8-小程序登录流程" class="headerlink" title="8.小程序登录流程"></a>8.小程序登录流程</h3><p>1.wx.login()获取code，传给开发者服务器<br>2.开发者服务器用appid,appsecret,code调用登录凭证校验<br>（ auth.code2Session ）向微信服务器获取openid和sessionkey<br>3.发者服务器可以根据用户标识来生成自定义登录态，用于后<br>续业务逻辑中前后端交互时识别用户身份。</p><h3 id="9-小程序授权"><a href="#9-小程序授权" class="headerlink" title="9.小程序授权"></a>9.小程序授权</h3><p>如果用户未接受或拒绝过此权限，会弹窗询问用户，用户点击同意后方可调用接口；</p><p>如果用户已授权，可以直接调用接口；</p><p>如果用户已拒绝授权，则不会出现弹窗，而是直接进入接口fail 回调。请开发者兼容用户拒绝授权的场景。（wx.openSetting引导用户进行授权）</p><p>开发者可以使用 wx.getSetting 获取用户当前的授权状态。</p><p>微信小程序分为两个部分：webview 和 appService。其中 webview 主要用来展示 UI，appService 用来处理业务逻辑、数据及接口调用。它们在两个进程中进行，通过系统层 JSBridge 实现通信，实现 UI 的渲染、事件的处理</p><h3 id="10-网络协议"><a href="#10-网络协议" class="headerlink" title="10.网络协议"></a>10.网络协议</h3><p>网络分层<br>目前网络分层可分为两种：OSI 模型和 TCP/IP 模型<br>OSI模型</p><pre><code>应用层（Application）表示层（Presentation）会话层（Session）传输层（Transport）网络层（Network）数据链路层（Data Link）物理层（Physical）</code></pre><p>TCP/IP模型</p><pre><code>应用层（Application）传输层（Host-to-Host Transport）互联网层（Internet）网络接口层（Network Interface）</code></pre><h3 id="11-HTTP-HTTPS"><a href="#11-HTTP-HTTPS" class="headerlink" title="11.HTTP/HTTPS"></a>11.HTTP/HTTPS</h3><p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用<br>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议<br>3、http和https使用的是完全不同的连接方式，用的端口也不一样，默认前者是80，后者是443<br>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><h3 id="12-从输入URL到页面加载到过程？"><a href="#12-从输入URL到页面加载到过程？" class="headerlink" title="12.从输入URL到页面加载到过程？"></a>12.从输入URL到页面加载到过程？</h3><p>1.浏览器地址栏输入URL并回车<br>2.通过DNS将域名解析成IP地址。在解析过程中，按照浏览器缓存、系统缓存、路由器缓存、ISP(运营商)DNS缓存、根域名服务器、顶级域名服务器、主域名服务器的顺序，逐步读取缓存，直到拿到IP地址。（应用层）<br>3.根据获取IP进行tcp连接（三次握手）（传输层）<br>4.发送http请求<br>5.服务器处理请求，浏览器接收http的响应<br>6.渲染页面，构造dom树<br>7.关闭tcp连接（四次挥手）</p><h3 id="13-HTTP状态码"><a href="#13-HTTP状态码" class="headerlink" title="13.HTTP状态码"></a>13.HTTP状态码</h3><p>区分状态码<br>    1××开头  - 临时响应<br>    2××开头  - 请求成功<br>    3××开头  - 请求被重定向<br>    4××开头  - 请求错误<br>    5××开头  - 服务器错误<br>常见状态码<br>    200 - 请求成功，Ajax 接受到信息了<br>    400 - 服务器不理解请求<br>    403 - 服务器拒绝请求<br>    404 - 请求页面错误<br>    500 - 服务器内部错误，无法完成请求</p><h3 id="14-性能优化"><a href="#14-性能优化" class="headerlink" title="14.性能优化"></a>14.性能优化</h3><ul><li><p>HTML优化<br>  1、避免 HTML 中书写 CSS 代码，因为这样难以维护。<br>  2、使用 Viewport 加速页面的渲染。<br>  3、使用语义化标签，减少 CSS 代码，增加可读性和 SEO。<br>  4、减少标签的使用，DOM 解析是一个大量遍历的过程，减少不必要的标签，能降低遍历的次数。<br>  5、避免 src、href 等的值为空，因为即时它们为空，浏览器也会发起 HTTP 请求。</p></li><li><p>CSS优化<br>  1、优化选择器路径：使用 .c {} 而不是 .a .b .c {}。<br>  2、选择器合并：共同的属性内容提起出来，压缩空间和资源开销。<br>  3、精准样式：使用 padding-left: 10px 而不是 padding: 0 0 0 10px。<br>  4、雪碧图：将小的图标合并到一张图中，这样所有的图片只需要请求一次。<br>  5、避免通配符：.a .b * {} 这样的选择器，根据从右到左的解析顺序在解析过程中遇到通配符 * {} 会遍历整个 DOM，性能大大损耗。<br>  6、少用 float：float 在渲染时计算量比较大，可以使用 flex 布局。<br>  7、为 0 值去单位：增加兼容性。<br>  8、压缩文件大小，减少资源下载负担。</p></li><li><p>JavaScript优化<br>  1、尽可能把 <code>&lt;script&gt;</code> 标签放在 body 之后，避免 JS 的执行卡住 DOM 的渲染，最大程度保证页面尽快地展示出来<br>  2、尽可能合并 JS 代码：提取公共方法，进行面向对象设计等……<br>  3、CSS 能做的事情，尽量不用 JS 来做，毕竟 JS 的解析执行比较粗暴，而 CSS 效率更高。<br>  4、尽可能逐条操作 DOM，并预定好 CSs 样式，从而减少 reflow 或者 repaint 的次数。<br>  5、尽可能少地创建 DOM，而是在 HTML 和 CSS 中使用 display: none 来隐藏，按需显示。<br>  6、压缩文件大小，减少资源下载负担。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-symbol原始数据类型</title>
      <link href="/ZJY.github.io/2021/01/20/javascript-symbol%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/ZJY.github.io/2021/01/20/javascript-symbol%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：</p><p>undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p><p>Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> s</span><br><span class="line"><span class="comment">// &quot;symbol&quot;</span></span><br></pre></td></tr></table></figure><p>注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p><p>Symbol函数可以接受一个字符串作为参数，表示对 Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p><p>注意，Symbol函数的参数只是表示对当前 Symbol值的描述，因此相同参数的Symbol函数的返回值是不相等的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript this 关键字</title>
      <link href="/ZJY.github.io/2021/01/20/javasctipt%E7%9A%84this%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/ZJY.github.io/2021/01/20/javasctipt%E7%9A%84this%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript-this-关键字"><a href="#JavaScript-this-关键字" class="headerlink" title="JavaScript this 关键字"></a>JavaScript this 关键字</h2><p>面向对象语言中this表示对对象的一个引用。</p><p>但在javascript中，this不是固定不变的，它随执行环境的改变而改变。</p><ul><li>在方法中，this表示该方法所属的对象。</li><li>如果单独使用，this代表全局对象</li><li>在函数中，this代表全局对象</li><li>在函数中，严格模式下，this是未定义的undefined</li><li>在事件中，this表示接收事件的元素</li><li>类似call(),apply(),bind()可以将this引用到任何对象</li></ul><p>实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  lastName : <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">  id       : <span class="number">5566</span>,</span><br><span class="line">  fullName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法中的this"><a href="#方法中的this" class="headerlink" title="方法中的this"></a>方法中的this</h3><p>在对象方法中，this指向调用它所在方法的对象。</p><p>上面实例中，this指person对象。<br>fullName 方法所属的对象就是 person。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.fullName(); <span class="comment">// John Doe</span></span><br></pre></td></tr></table></figure><h3 id="单独使用this"><a href="#单独使用this" class="headerlink" title="单独使用this"></a>单独使用this</h3><p>单独使用this，this指全局对象</p><p>在浏览器中，全局对象指window</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(this &#x3D;&#x3D;&#x3D; window); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><p>严格模式下，单独使用this，也是指全局对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#39;use strict&#39;</span><br><span class="line">console.log(this &#x3D;&#x3D;&#x3D; window); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><h3 id="函数中使用this"><a href="#函数中使用this" class="headerlink" title="函数中使用this"></a>函数中使用this</h3><p>在函数中，函数的所属者默认绑定到this<br>在浏览器中，this指全局对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">myFunction(); <span class="comment">//window</span></span><br></pre></td></tr></table></figure><h3 id="严格模式下函数中使用this"><a href="#严格模式下函数中使用this" class="headerlink" title="严格模式下函数中使用this"></a>严格模式下函数中使用this</h3><p>严格模式下，函数是没有绑定到this的，this是undefined</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">myFunction(); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><h3 id="事件中的this"><a href="#事件中的this" class="headerlink" title="事件中的this"></a>事件中的this</h3><p>在html事件柄中，this指向了接收事件的html元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;this.style.display=&#x27;none&#x27;&quot;</span>&gt;</span></span><br><span class="line">点我后我就消失了</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="对象方法中绑定"><a href="#对象方法中绑定" class="headerlink" title="对象方法中绑定"></a>对象方法中绑定</h3><p>下面实例中，this 是 person 对象，person 对象是函数的所有者：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstName  : <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  lastName   : <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">  id         : <span class="number">5566</span>,</span><br><span class="line">  myFunction : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.myFunction(); <span class="comment">//&#123;firstName: &quot;John&quot;, lastName: &quot;Doe&quot;, id: 5566, myFunction: ƒ&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  lastName : <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">  id       : <span class="number">5566</span>,</span><br><span class="line">  fullName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.fullName(); <span class="comment">//John Doe</span></span><br></pre></td></tr></table></figure><p> this.firstName 表示 this (person) 对象的 firstName 属性。</p><h3 id="显式函数绑定"><a href="#显式函数绑定" class="headerlink" title="显式函数绑定"></a>显式函数绑定</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  fullName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">  firstName:<span class="string">&quot;John&quot;</span>,</span><br><span class="line">  lastName: <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">person1.fullName.call(person2);  <span class="comment">// 返回 &quot;John Doe&quot;</span></span><br></pre></td></tr></table></figure><p>在 JavaScript 中函数也是对象，对象则有方法，apply 和 call 就是函数对象的方法。这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 this 绑定的对象。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>promise理解</title>
      <link href="/ZJY.github.io/2021/01/20/promise%E7%90%86%E8%A7%A3/"/>
      <url>/ZJY.github.io/2021/01/20/promise%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p>Promise 是异步编程的一种解决方案<br>Promise 是一个对象，从它可以获取异步操作的消息</p><h3 id="Promise特点"><a href="#Promise特点" class="headerlink" title="Promise特点"></a>Promise特点</h3><p>Promise对象有以下两个特点。</p><ul><li><p>对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功<br>）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p></li><li><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p></li></ul><h3 id="Promise的缺点："><a href="#Promise的缺点：" class="headerlink" title="Promise的缺点："></a>Promise的缺点：</h3><ul><li>1.无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li><li>2.如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li><li>3.当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li></ul><p>promise是一个构造函数，用来生成promise实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        resolve(value)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>promise构造函数接收一个函数作为参数，该函数的两个参数为resovle和reject，由js引擎提供，不用自己部署</p><p>resovle函数的作用是，将promise对象的状态从“未完成”变为“成功”（pending变为fullfilled），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。</p><p>reject函数的作用是，将promise对象的状态从“未完成”变为“失败”（pending变为rejected），在异步操作失败时调用，并将异步操作返回的结果作为参数传递出去</p><h3 id="Promise-then方法"><a href="#Promise-then方法" class="headerlink" title="Promise.then方法"></a>Promise.then方法</h3><p>promise生成以后，可用then方法分别指定为resolve和reject状态的回调函数：</p><p>promise.then(function(value){},function(error){})</p><p>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</p><p>promise.then(onFulfilled, onRejected)</p><p>promise简化了对error的处理，上面的代码我们也可以这样写：</p><p>promise.then(onFulfilled).catch(onRejected)</p><h3 id="Promise-all方法"><a href="#Promise-all方法" class="headerlink" title="Promise.all方法"></a>Promise.all方法</h3><p>Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。<br>var p = Promise.all([p1,p2,p3]);</p><p>上面代码中，Promise.all 方法接受一个数组作为参数，p1、p2、p3 都是 Promise 对象的实例。（Promise.all 方法的参数不一定是数组，但是必须具有 iterator 接口，且返回的每个成员都是 Promise 实例。）</p><p>p 的状态由 p1、p2、p3 决定，分成两种情况。</p><p>（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。<br>（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</p><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成一个Promise对象的数组</span></span><br><span class="line"><span class="keyword">var</span> promises = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(<span class="string">&quot;/post/&quot;</span> + id + <span class="string">&quot;.json&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="keyword">function</span>(<span class="params">posts</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...  </span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Promise-race方法"><a href="#Promise-race方法" class="headerlink" title="Promise.race方法"></a>Promise.race方法</h3><p>Promise.race 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例</p><p>var p = Promise.race([p1,p2,p3]);</p><p>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的返回值。</p><p>如果Promise.all方法和Promise.race方法的参数，不是Promise实例，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。</p><h3 id="Promise-resolve-方法"><a href="#Promise-resolve-方法" class="headerlink" title="Promise.resolve 方法"></a>Promise.resolve 方法</h3><p>有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果 Promise.resolve 方法的参数，不是具有 then 方法的对象（又称 thenable 对象），则返回一个新的 Promise 对象，且它的状态为fulfilled。</p><p>上面代码生成一个新的Promise对象的实例p，它的状态为fulfilled，所以回调函数会立即执行，Promise.resolve方法的参数就是回调函数的参数。</p><p>如果Promise.resolve方法的参数是一个Promise对象的实例，则会被原封不动地返回。</p><h3 id="Promise-reject方法"><a href="#Promise-reject方法" class="headerlink" title="Promise.reject方法"></a>Promise.reject方法</h3><p>Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected。Promise.reject方法的参数reason，会被传递给实例的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">p.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>上面代码生成一个Promise对象的实例，状态为rejected，回调函数会立即执行。</p><p>promise实现ajax：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">URL</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest(); </span><br><span class="line">        req.open(<span class="string">&#x27;GET&#x27;</span>, URL, <span class="literal">true</span>);</span><br><span class="line">        req.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (req.status === <span class="number">200</span>) &#123; </span><br><span class="line">                resolve(req.responseText);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;;</span><br><span class="line">        req.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">        &#125;;</span><br><span class="line">        req.send(); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> URL = <span class="string">&quot;/try/ajax/testpromise.php&quot;</span>; </span><br><span class="line">ajax(URL).then(<span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">&#x27;内容是：&#x27;</span> + value); </span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">&#x27;错误：&#x27;</span> + error); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>async/await的使用</title>
      <link href="/ZJY.github.io/2021/01/20/async-await%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/ZJY.github.io/2021/01/20/async-await%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><p>async 是 ES7 才有的与异步操作有关的关键字，和 Promise ， Generator 有很大关联的</p><p>语法：async function name([param[, param[, … param]]]) { statements }</p><ul><li>name: 函数名称。</li><li>param: 要传递给函数的参数的名称。</li><li>statements: 函数体语句。</li></ul><p>返回值：async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">helloAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;helloAsync&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">console</span>.log(helloAsync())  <span class="comment">// Promise &#123;&lt;resolved&gt;: &quot;helloAsync&quot;&#125;</span></span><br><span class="line"> </span><br><span class="line">helloAsync().then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(v);         <span class="comment">// helloAsync</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>async 函数中可能会有 await 表达式，async 函数执行时，如果遇到 await 就会先暂停执行 ，等到触发的异步操作完成后，恢复 async 函数的执行并返回解析值。</p><p>await 关键字仅在 async function 中有效。如果在 async function 函数体外使用 await ，你只会得到一个语法错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testAwait</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&quot;testAwait&quot;</span>);</span><br><span class="line">          resolve();</span><br><span class="line">       &#125;, <span class="number">1000</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">helloAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">await</span> testAwait();</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;helloAsync&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">helloAsync();</span><br><span class="line"><span class="comment">// testAwait</span></span><br><span class="line"><span class="comment">// helloAsync</span></span><br></pre></td></tr></table></figure><h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>await 操作符用于等待一个 Promise 对象, 它只能在异步函数 async function 内部使用。</p><p>语法:[return_value] = await expression;<br>expression: 一个 Promise 对象或者任何要等待的值</p><p>返回值:</p><p>返回 Promise 对象的处理结果。如果等待的不是 Promise 对象，则返回该值本身。</p><p>如果一个 Promise 被传递给一个 await 操作符，await 将等待 Promise 正常处理完成并返回其处理结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testAwait</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(x);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">helloAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="keyword">await</span> testAwait (<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(x); </span><br><span class="line">&#125;</span><br><span class="line">helloAsync ();</span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>正常情况下，await 命令后面是一个 Promise 对象，它也可以跟其他值，如字符串，布尔值，数值以及普通函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testAwait</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;testAwait&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">helloAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">await</span> testAwait();</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;helloAsync&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">helloAsync();</span><br><span class="line"><span class="comment">// testAwait</span></span><br><span class="line"><span class="comment">// helloAsync</span></span><br></pre></td></tr></table></figure><p>await针对所跟不同表达式的处理方式：</p><ul><li>Promise 对象：await 会暂停执行，等待 Promise 对象 resolve，然后恢复 async 函数的执行并返回解析值。</li><li>非 Promise 对象：直接返回对应的值</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序性能优化</title>
      <link href="/ZJY.github.io/2021/01/20/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/"/>
      <url>/ZJY.github.io/2021/01/20/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/</url>
      
        <content type="html"><![CDATA[<p>小程序优化性能从两点出发：</p><p>1.提高加载性能<br>2.提高渲染性能</p><h3 id="1-提高加载性能"><a href="#1-提高加载性能" class="headerlink" title="1.提高加载性能"></a>1.提高加载性能</h3><p>用户点击小程序：<br><img src="/ZJY.github.io/images/webapp.png" alt="image"></p><p>它们分别对应小程序的下面三个状态：</p><ul><li>有三个点的白屏（左侧）： 下载代码包的阶段</li><li>没有三个点的白屏（中间）： 业务代码注入和渲染的阶段</li><li>加载中（右边）： 业务代码中异步请求数据</li></ul><p>1.控制包的大小<br>提升体验最直接的方法是控制小程序包的大小，基本上可以说，1M的代码包，下载耗时1秒左右。</p><ul><li>压缩代码，清理无用的代码</li><li>图片放在cdn</li><li>采用分包策略<ul><li>分包预加载</li><li>独立分包（版本要求有点高）</li></ul></li></ul><p>2.对异步请求的优化</p><ul><li>onLoad 阶段就可以发起请求，不用等ready</li><li>请求结果放在缓存中, 下次接着用</li><li>请求中可以先展示骨架图</li><li>先反馈，再请求。比如说，点赞的按钮，可以先改变按钮的样式，再发起异步请求</li></ul><h3 id="2-提升渲染性能"><a href="#2-提升渲染性能" class="headerlink" title="2.提升渲染性能"></a>2.提升渲染性能</h3><p>setData：每调用一次setData, 都是逻辑层向渲染层的一次通讯，这个通信还不是直接传给webView, 而是通过走了native层，通讯的开销很大。</p><p>渲染层收到通讯后，还需要重新渲染出来，所以，一次setData带来两次开销：通信的开销 + webview更新的开销。</p><ul><li>1.减少setData的数据量<ul><li>如果一个数据不会影响渲染层，则不用放在setData里面</li></ul></li><li>2.合并setData的请求，减少通讯的次数</li><li>3.列表的局部更新</li><li>4.清理定时器等</li><li>5.只在必要时候监听pageScroll，避免在pageScroll中频繁setData，避免在pagescroll中写复杂逻辑</li></ul><h3 id="3-html和小程序页面加载的不同"><a href="#3-html和小程序页面加载的不同" class="headerlink" title="3.html和小程序页面加载的不同"></a>3.html和小程序页面加载的不同</h3><p>传统HTML5在加载的时候受限于网络环境，需要顺序加载HTML、CSS、JS，然后返回数据，最后渲染页面显示在浏览器中。用户经常需要等待很长时间，体验会受到影响。</p><p>相比之下，小程序的两个线程：Appservice Thread和ViewThread会同时进行、并行加载，甚至AppserviceThread会更早执行，当视图线程加载完，通知Appservice，Appservice 会把准备好的数据用setData的方法返回给视图线程。</p><p>小程序的这种优化策略，可以减少用户的等待时间、加快小程序的响应速度。</p><h3 id="4-小程序性能优化"><a href="#4-小程序性能优化" class="headerlink" title="4.小程序性能优化"></a>4.小程序性能优化</h3><ul><li><p>控制包体积的大小，减少包文件个数</p></li><li><p>分包加载</p></li><li><p>图片优化:除icon外图片可以放在cdn，不建议把所有图片放在包内，加大包的体积，影响包的下载速度和解压速度;选择合适的图片格式;适当降低图片质量压缩图片;</p></li><li><p>其他资源文件的优化，压缩json文件</p></li><li><p>请求数据的优化:关键的早请求，不关键的晚请求，可使页面所需数据尽早可能的处于ready状态，不必等到ready状态后才去请求数据</p></li><li><p>setdata的优化:不要过于频繁的调用setdata，应考虑多次合并请求;不在视图层使用的数据不要使用setdata;通过setdata<br>的key值优化</p></li><li><p>清理页面定时器</p></li><li><p>合理使用自定义组件(不需要逻辑功能时可使用模板)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http状态码</title>
      <link href="/ZJY.github.io/2021/01/20/http%E7%8A%B6%E6%80%81%E7%A0%81/"/>
      <url>/ZJY.github.io/2021/01/20/http%E7%8A%B6%E6%80%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h3 id="1xx-（临时响应）"><a href="#1xx-（临时响应）" class="headerlink" title="1xx （临时响应）"></a>1xx （临时响应）</h3><p>表示临时响应并需要请求者继续执行操作的状态代码。</p><ul><li>100 （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。</li><li>101 （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。</li><li>102 由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</li></ul><h3 id="2xx-（成功）"><a href="#2xx-（成功）" class="headerlink" title="2xx （成功）"></a>2xx （成功）</h3><p>表示成功处理了请求的状态代码。</p><ul><li>200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</li><li>201 （已创建） 请求成功并且服务器创建了新的资源。</li><li>202 （已接受） 服务器已接受请求，但尚未处理。</li><li>203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。</li><li>204 （无内容） 服务器成功处理了请求，但没有返回任何内容。</li><li>205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。</li><li>206 （部分内容） 服务器成功处理了部分 GET 请求。</li><li>207 由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</li></ul><h3 id="3xx-（重定向）"><a href="#3xx-（重定向）" class="headerlink" title="3xx （重定向）"></a>3xx （重定向）</h3><p>表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向。</p><ul><li>300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (useragent)选择一项操作，或提供操作列表供请求者选择。</li><li>301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或HEAD请求的响应）时，会自动将请求者转到新位置。</li><li>302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li><li>303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</li><li>304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</li><li>305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</li><li>307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li></ul><h3 id="4xx-（请求错误）"><a href="#4xx-（请求错误）" class="headerlink" title="4xx （请求错误）"></a>4xx （请求错误）</h3><p>这些状态代码表示请求可能出错，妨碍了服务器的处理。</p><ul><li>400 （错误请求） 服务器不理解请求的语法。</li><li>401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</li><li>402 该状态码是为了将来可能的需求而预留的。</li><li>403 （禁止） 服务器拒绝请求。</li><li>404 （未找到） 服务器找不到请求的网页。</li><li>405 （方法禁用） 禁用请求中指定的方法。</li><li>406 （不接受） 无法使用请求的内容特性响应请求的网页。</li><li>407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</li><li>408 （请求超时）服务器等候请求时发生超时。</li><li>409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。</li><li>410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。</li><li>411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。</li><li>412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。</li><li>413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</li><li>414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。这比较少见，通常的情况包括：本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。</li><li>415 （不支持的媒体类型） 请求的格式不受请求页面的支持。</li><li>416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。</li><li>417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。</li></ul><h3 id="5xx-（服务器错误）"><a href="#5xx-（服务器错误）" class="headerlink" title="5xx （服务器错误）"></a>5xx （服务器错误）</h3><p>这些状态代码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。</p><ul><li>500 （服务器内部错误） 服务器遇到错误，无法完成请求。</li><li>501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</li><li>502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。</li><li>503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。</li><li>504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。</li><li>505 （HTTP 版本不受支持）服务器不支持请求中所用的 HTTP 协议版本。</li></ul><h3 id="600"><a href="#600" class="headerlink" title="600"></a>600</h3><p>源站没有返回响应头部，只返回实体内容</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript基础题</title>
      <link href="/ZJY.github.io/2021/01/20/javascript%E5%9F%BA%E7%A1%80%E9%A2%98/"/>
      <url>/ZJY.github.io/2021/01/20/javascript%E5%9F%BA%E7%A1%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-js基础"><a href="#1-js基础" class="headerlink" title="1.js基础"></a>1.js基础</h3><ul><li>基本类型：<ul><li>number</li><li>string</li><li>boolean</li><li>null</li><li>undefined</li><li>symbol  </li></ul></li></ul><p>基本类型的比较就是值的比较，访问的是值的本身，没有属性和方法，保存在栈内存中</p><ul><li>引用类型<ul><li>Array</li><li>Function</li><li>Date</li><li>Object</li></ul></li></ul><p>引用类型有属性和方法，同时保存在栈内存和堆内存中；引用类型的比较是内存地址的比较。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> address = &#123;<span class="attr">details</span>:<span class="string">&#x27;a&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">let</span> one = address</span><br><span class="line"><span class="keyword">let</span> tow = address</span><br><span class="line">one === tow <span class="comment">//true</span></span><br><span class="line"><span class="comment">// 虽然one、tow是两枚不同的指针，但它们都同时指向了堆内存里的address的内容，所以它们是相等的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数参数是引用类型（对象）的时候会发生什么</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  person.age = <span class="number">26</span></span><br><span class="line">  person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;aaa&#x27;</span>,</span><br><span class="line">    age: <span class="number">30</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> person</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;bbb&#x27;</span>,</span><br><span class="line">  age: <span class="number">25</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p2 = test(p1)</span><br><span class="line">p1 <span class="comment">// &#123;age:26,name:&#x27;bbb&#x27;&#125;</span></span><br><span class="line">p2 <span class="comment">// &#123;age:30,name:&#x27;aaa&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>函数传递参数时，实际上是传递指针的副本。<br>test(p1)实际上传递的就是p1的副本，这时指针仍然指向{name: ‘bbb’,age: 25}<br>person.age = 26 这时修改的还是原来内存位置的内容，所以这时p1的age变成了26<br>当person = {} .. 相当于重新开辟了一块堆内存，赋值{name:’aaa’,age:30},最后返回这个对象，而这个对象的指针就是p2</p><h3 id="2-字符串翻转："><a href="#2-字符串翻转：" class="headerlink" title="2.字符串翻转："></a>2.字符串翻转：</h3><p>console.log(str1.split(‘’).reverse().join(‘’))</p><p>判断字符串出现次数最多元素，并统计次数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str2 = <span class="string">&#x27;asdfasdfasdfasdfjkjkljlkjssss&#x27;</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> num2 = str2.length</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num2; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj[str2.charAt(i)]) &#123;</span><br><span class="line">    obj[str2.charAt(i)] = <span class="built_in">parseInt</span>(obj[str2.charAt(i)]) + <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    obj[str2.charAt(i)] = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"><span class="keyword">let</span> maxNum = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> maxDocument = <span class="literal">null</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j <span class="keyword">in</span> obj) &#123;<span class="comment">//循环对象</span></span><br><span class="line">  <span class="keyword">if</span> (obj[j] &gt; maxNum) &#123;</span><br><span class="line">    maxNum = obj[j]</span><br><span class="line">    maxDocument = j</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-数组去重"><a href="#3-数组去重" class="headerlink" title="3.数组去重"></a>3.数组去重</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;e&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(arr2.indexOf(arr[i])== -<span class="number">1</span>)&#123;</span><br><span class="line">    arr2.push(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr2)</span><br></pre></td></tr></table></figure><h3 id="4-replace字符串替换"><a href="#4-replace字符串替换" class="headerlink" title="4.replace字符串替换"></a>4.replace字符串替换</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;hello china&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> str2 = str.replace(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;hi&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str2,str);<span class="comment">//hi china,hello china</span></span><br></pre></td></tr></table></figure><h3 id="5-toUpperCase-大写-toLocaleUpperCase"><a href="#5-toUpperCase-大写-toLocaleUpperCase" class="headerlink" title="5.toUpperCase()大写/toLocaleUpperCase"></a>5.toUpperCase()大写/toLocaleUpperCase</h3><h3 id="6-toLowerCase-小写-toLocalLowerCase"><a href="#6-toLowerCase-小写-toLocalLowerCase" class="headerlink" title="6.toLowerCase()小写/toLocalLowerCase"></a>6.toLowerCase()小写/toLocalLowerCase</h3><h3 id="7-repeat-count-number-字符串重复次数"><a href="#7-repeat-count-number-字符串重复次数" class="headerlink" title="7.repeat(count:number)字符串重复次数"></a>7.repeat(count:number)字符串重复次数</h3><h3 id="8-Math-ceil-向上舍入-4-1结果5"><a href="#8-Math-ceil-向上舍入-4-1结果5" class="headerlink" title="8.Math.ceil()向上舍入 4.1结果5"></a>8.Math.ceil()向上舍入 4.1结果5</h3><h3 id="9-Math-floor-向下舍入-4-9结果4"><a href="#9-Math-floor-向下舍入-4-9结果4" class="headerlink" title="9.Math.floor()向下舍入  4.9结果4"></a>9.Math.floor()向下舍入  4.9结果4</h3><h3 id="10-Math-round-把数四舍五入为最接近的整数。"><a href="#10-Math-round-把数四舍五入为最接近的整数。" class="headerlink" title="10.Math.round()把数四舍五入为最接近的整数。"></a>10.Math.round()把数四舍五入为最接近的整数。</h3><h3 id="11-数组-和length-0的区别："><a href="#11-数组-和length-0的区别：" class="headerlink" title="11.数组[]和length=0的区别："></a>11.数组[]和length=0的区别：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> bar = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> foo2 = foo;</span><br><span class="line"><span class="keyword">var</span> bar2 = bar;</span><br><span class="line">foo=[];</span><br><span class="line">bar.length = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo,foo2,bar,bar2);<span class="comment">//[]  [1,2,3]  []  []</span></span><br></pre></td></tr></table></figure><p>[]是创建了一个新数组，重新分配了内存空间，任何其他引<br>用不受影响，仍指向其原始数据<br>length=0 修改数组本身。如果通过不同的变量访问它，那<br>么仍然可以获得修改后的数组</p><h3 id="12-typeof"><a href="#12-typeof" class="headerlink" title="12.typeof"></a>12.typeof</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">//&quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span> <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">Infinity</span> <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;  <span class="comment">//&quot;function&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;aaa&quot;</span>) <span class="comment">//&quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">String</span>(<span class="string">&#x27;aaa&#x27;</span>) <span class="comment">//&quot;string&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> object <span class="comment">//false</span></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> 任何类型 <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span>可以用来检查一个没有声明的变量，而不报错:</span><br><span class="line"><span class="keyword">typeof</span> v <span class="comment">//&quot;undefined&quot;</span></span><br></pre></td></tr></table></figure><h3 id="13-变量提升"><a href="#13-变量提升" class="headerlink" title="13.变量提升"></a>13.变量提升</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;World!&#x27;</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> name = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Goodbye &#x27;</span> + name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Hello &#x27;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 结果：Goodbye Jack</span></span><br><span class="line"><span class="comment">// 注意js的var hoisting变量声明提升，虽然声明提升，但是初始化并不提升</span></span><br><span class="line"><span class="comment">// 这段代码相当于：</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;World!&#x27;</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">        name = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Goodbye &#x27;</span> + name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Hello &#x27;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="14-splice"><a href="#14-splice" class="headerlink" title="14.splice"></a>14.splice</h3><p>splice(index,number,value)向数组中添加或删除数目，返回被删除的数目<br>    index：必须，要添加或删除的起始位置，为负时，从数组尾部开始<br>    number：必须，要删除的数量，为0时则不删除<br>    value：可选，要添加的数目</p><p>删除：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line"><span class="built_in">console</span>.log(a.splice(<span class="number">0</span>,a.length)); <span class="comment">//[1,2,3]</span></span><br><span class="line"><span class="built_in">console</span>.log(a,b); <span class="comment">//[] []</span></span><br></pre></td></tr></table></figure><p>添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr1 = arr;</span><br><span class="line"><span class="built_in">console</span>.log(arr.splice(<span class="number">1</span>,<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>)); <span class="comment">//[]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr,arr1);<span class="comment">// [1,&#x27;a&#x27;,&#x27;b&#x27;,2,3]   [1,&#x27;a&#x27;,&#x27;b&#x27;,2,3]</span></span><br></pre></td></tr></table></figure><h3 id="15-slice"><a href="#15-slice" class="headerlink" title="15.slice"></a>15.slice</h3><p>slice(start,end)向数组中选出指定数组，返回被截选的子数组<br>（start到end，不包含end），并不改变原数组</p><ul><li>start：必须，规定从何处开始，为负时，从数组尾部算起,-1为尾部第一个元素</li><li>end：可选，规定截取到何处，没有此参数则到数组结尾所有元素，<br>  为负时，从尾部开始算起元素</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> d = c;</span><br><span class="line"><span class="built_in">console</span>.log(c.slice(<span class="number">0</span>,<span class="number">2</span>));<span class="comment">//[1,2]</span></span><br><span class="line"><span class="built_in">console</span>.log(c,d);<span class="comment">//[1,2,3]  [1,2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以截取字符串：不包含end元素</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="string">&#x27;hello,world&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(test.slice(<span class="number">1</span>,<span class="number">5</span>),test);<span class="comment">// ello   hello,world</span></span><br><span class="line"><span class="built_in">console</span>.log(test.slice(-<span class="number">3</span>),test);<span class="comment">// rld  hello,world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// substring:不包含end元素</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="string">&#x27;hello,world&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(test.substring(<span class="number">1</span>,<span class="number">5</span>),test);<span class="comment">// ello   hello,world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// substr:包含end元素</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="string">&#x27;hello,world&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(test.substr(<span class="number">1</span>,<span class="number">5</span>),test);<span class="comment">// ello,   hello,world</span></span><br></pre></td></tr></table></figure><h3 id="16-js判断数据类型"><a href="#16-js判断数据类型" class="headerlink" title="16.js判断数据类型"></a>16.js判断数据类型</h3><p>typeof:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;ls&#x27;</span> <span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">123</span> <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// bollean</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// function</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(<span class="number">1</span>) <span class="comment">// symbol</span></span><br></pre></td></tr></table></figure><p>instanceof</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">instanceof</span> 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。其意思就是判断对象是否是某一数据类型（如<span class="built_in">Array</span>）的实例</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> A);<span class="comment">//true,因为 Object.getPrototypeOf(a) === A.prototype;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;srr&#x27;</span> intanceof <span class="built_in">String</span>) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>) <span class="comment">// false</span></span><br><span class="line">在这里字面量值，<span class="number">2</span>， <span class="literal">true</span> ，<span class="string">&#x27;str&#x27;</span>不是实例，所以判断值为<span class="literal">false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">2</span>) <span class="keyword">instanceof</span> <span class="built_in">Number</span>)<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;2&#x27;</span>) <span class="keyword">instanceof</span> <span class="built_in">String</span>)<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>) <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>)<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Function</span>)<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null和undefined</span></span><br><span class="line">conosle.log(<span class="literal">null</span> <span class="keyword">instanceof</span> Null) <span class="comment">// Null is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> <span class="keyword">instanceof</span> Undefined) <span class="comment">//Undefined is not undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="literal">null</span> <span class="keyword">instanceof</span> Null) <span class="comment">// null is not a constructor</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="literal">undefined</span> <span class="keyword">instanceof</span> Undefined) <span class="comment">//undefined is not a constructor</span></span><br><span class="line">浏览器认为<span class="literal">null</span>，<span class="literal">undefined</span>不是构造器</span><br></pre></td></tr></table></figure><p>constructor</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">2</span>).constructor === <span class="built_in">Number</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">true</span>).constructor === <span class="built_in">Boolean</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="string">&#x27;str&#x27;</span>).constructor === <span class="built_in">String</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(([]).constructor === <span class="built_in">Array</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log((&#123;&#125;).constructor === <span class="built_in">Object</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;).constructor === <span class="built_in">Function</span>);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用costructor来判断类型看起来是完美的，然而，如果</span></span><br><span class="line"><span class="comment">// 我创建一个对象，更改它的原型，这种方式也变得不可</span></span><br><span class="line"><span class="comment">// 靠了</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Fn.prototype = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Fn();</span><br><span class="line"><span class="built_in">console</span>.log(f.constructor === Fn);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(f.constructor=== <span class="built_in">Array</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>Object.prototype.toString.call</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常用于判断浏览器内置对象,对于所有基本的数据类型都能进行判断，即使是 null 和 undefined</span></span><br><span class="line"><span class="keyword">var</span>  test = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"><span class="built_in">console</span>.log(test.call(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(test.call(<span class="literal">true</span>));</span><br><span class="line"><span class="built_in">console</span>.log(test.call(<span class="string">&#x27;123&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(test.call([]));</span><br><span class="line"><span class="built_in">console</span>.log(test.call(&#123;&#125;));</span><br><span class="line"><span class="built_in">console</span>.log(test.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;));</span><br><span class="line"><span class="built_in">console</span>.log(test.call(<span class="literal">null</span>));</span><br><span class="line"><span class="built_in">console</span>.log(test.call(<span class="literal">undefined</span>));</span><br><span class="line">[object <span class="built_in">Number</span>]</span><br><span class="line">[object <span class="built_in">Boolean</span>]</span><br><span class="line">[object <span class="built_in">String</span>]</span><br><span class="line">[object <span class="built_in">Array</span>]</span><br><span class="line">[object <span class="built_in">Object</span>]</span><br><span class="line">[object <span class="built_in">Function</span>]</span><br><span class="line">[object Null]</span><br><span class="line">[object Undefined]</span><br></pre></td></tr></table></figure><p>Array.isArray</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray([]))<span class="comment">// true</span></span><br><span class="line">     </span><br><span class="line"> <span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;123&#x27;</span>);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> str); <span class="comment">//object</span></span><br><span class="line"> <span class="built_in">console</span>.log(str <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">//true</span></span><br><span class="line"> <span class="built_in">console</span>.log(str.constructor===<span class="built_in">String</span>); <span class="comment">//true</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(str));[object <span class="built_in">String</span>]</span><br></pre></td></tr></table></figure><h3 id="17-闭包的概念"><a href="#17-闭包的概念" class="headerlink" title="17.闭包的概念"></a>17.闭包的概念</h3><p>闭包就是能访问其他函数内部的变量的函数</p><ul><li>优点：<br>  避免全局变量的污染<br>  变量长期存储在内存中（缓存变量）</li><li>缺点：<br>  常驻内存，加大内存使用<br>  内存泄漏<br>闭包实现了私有变量和参数</li></ul><h3 id="18-深拷贝和浅拷贝"><a href="#18-深拷贝和浅拷贝" class="headerlink" title="18.深拷贝和浅拷贝"></a>18.深拷贝和浅拷贝</h3><ul><li>基础数据类型（number string boolean null undefined）存储在栈内存中</li><li>引用数据类型（Function Array Object）变量名与内存地址存储在栈内存中，值作为对象保存在堆内存中</li><li>基础数据类型的比较是值比较</li><li>引用数据类型的比较是内存地址比较</li></ul><p>浅拷贝：只复制指向某个对象的指针，而不复制对象本身，新旧对象共享同一块内存<br>深拷贝：复制并创建一个一摸一样的对象，不共享内存，修改新对象，旧对象保持不变</p><ul><li>浅拷贝：<pre><code>  Object.assign()  扩展运算符...  Array.prototype.slice()//数组浅拷贝</code></pre></li><li>深拷贝：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify())</span><br><span class="line"><span class="comment">// 递归克隆</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现深拷贝：浅拷贝+递归</span></span><br><span class="line"><span class="comment">// 浅拷贝：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneShallow</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">            target[key] = source[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name: <span class="string">&quot;muyiy&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;You Don&#x27;t Know JS&quot;</span>,</span><br><span class="line">        price: <span class="string">&quot;45&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    a1: <span class="literal">undefined</span>,</span><br><span class="line">    a2: <span class="literal">null</span>,</span><br><span class="line">    a3: <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = cloneShallow(a);</span><br><span class="line"></span><br><span class="line">a.name = <span class="string">&quot;高级前端进阶&quot;</span>;</span><br><span class="line">a.book.price = <span class="string">&quot;55&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123; </span></span><br><span class="line"><span class="comment">//   name: &#x27;muyiy&#x27;, </span></span><br><span class="line"><span class="comment">//   book: &#123; title: &#x27;You Don\&#x27;t Know JS&#x27;, price: &#x27;55&#x27; &#125;,</span></span><br><span class="line"><span class="comment">//   a1: undefined,</span></span><br><span class="line"><span class="comment">//   a2: null,</span></span><br><span class="line"><span class="comment">//   a3: 123</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 以上只能拷贝一层，只要稍微改动下，加上是否是对象</span></span><br><span class="line"><span class="comment">// 的判断并在相应的位置使用递归就可以实现简单深拷贝。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep1</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> source[key] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">                target[key] = cloneDeep1(source[key]); <span class="comment">// 注意这里</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                target[key] = source[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用上面测试用例测试一下</span></span><br><span class="line"><span class="keyword">var</span> b = cloneDeep1(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123; </span></span><br><span class="line"><span class="comment">//   name: &#x27;muyiy&#x27;, </span></span><br><span class="line"><span class="comment">//   book: &#123; title: &#x27;You Don\&#x27;t Know JS&#x27;, price: &#x27;45&#x27; &#125;, </span></span><br><span class="line"><span class="comment">//   a1: undefined,</span></span><br><span class="line"><span class="comment">//   a2: &#123;&#125;,</span></span><br><span class="line"><span class="comment">//   a3: 123</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>一个简单的深拷贝就完成了，但是这个实现还存在很多问题。</p><p>1、没有对传入参数进行校验，传入 null 时应该返回 null 而不是 {}</p><p>2、对于对象的判断逻辑不严谨，因为 typeof null === ‘object’</p><p>3、没有考虑数组的兼容</p><p>判断是否是object</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span> &amp;&amp; obj != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 所以兼容数组的写法如下：</span></span><br><span class="line">functoin <span class="function"><span class="title">cloneDeep2</span>(<span class="params">source</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!isObject(source)) <span class="keyword">return</span> source;<span class="comment">//非对象返回自身</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> target = <span class="built_in">Array</span>.isArray(source) ? []: &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> source)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source,key))&#123;</span><br><span class="line">            <span class="keyword">if</span>(isObject(source[key]))&#123;</span><br><span class="line">                target[key] = cloneDeep2(source[key])</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                target[key] = source[key]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>赋值、浅拷贝、深拷贝区别：</p><ul><li>赋值：赋值就是将某一数值或某一对象赋给某个变量的过程，分为如下两个部分：<pre><code>  基本数据类型：赋值，赋值之后两个变量互不影响  引用数据类型：赋址，两个变量具有相同的引用，指向同一个对象，互相有影响</code></pre></li></ul><p>对基本类型进行赋值操作，两个变量互不影响：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&quot;muyiy&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// muyiy</span></span><br><span class="line"></span><br><span class="line">a = <span class="string">&quot;change&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// change</span></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// muyiy</span></span><br></pre></td></tr></table></figure><p>对引用类型进行赋址操作，两个变量指向同一个对象，改变变量 a 之后会影响变量 b，哪怕改变的只是对象 a中的基本类型数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    name: <span class="string">&quot;muyiy&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;You Don&#x27;t Know JS&quot;</span>,</span><br><span class="line">        price: <span class="string">&quot;45&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;muyiy&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line">a.name = <span class="string">&quot;change&quot;</span>;</span><br><span class="line">a.book.price = <span class="string">&quot;55&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;change&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;change&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br></pre></td></tr></table></figure><ul><li><p>浅拷贝（Shallow Copy）：<br>创建一个对象，这个对象有原始对象属性值的一份精确拷贝。如果属性值是基本数据类型，拷贝的就是基本数据类型的值，如果属性值是引用类型，拷贝的就是内存的地址，所以两个对象会相互影响。浅拷贝只解决了第一层的问题，拷贝第一层的基本类型值，以及第一层的引用类型地址</p><p>  浅拷贝使用场景：</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">Object</span>.assign()方法将所有可枚举属性的值从一个或多个源对象复制到目标对象</span><br><span class="line"><span class="comment">// 木易杨</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    name: <span class="string">&quot;muyiy&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;You Don&#x27;t Know JS&quot;</span>,</span><br><span class="line">        price: <span class="string">&quot;45&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;, a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;muyiy&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line">a.name = <span class="string">&quot;change&quot;</span>;</span><br><span class="line">a.book.price = <span class="string">&quot;55&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;change&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;muyiy&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br></pre></td></tr></table></figure><p>上面代码改变对象 a 之后，对象 b 的基本属性保持不变。但是当改变对象 a 中的对象 book 时，对象 b 相应的位置也发生了变化</p><p>2.展开语法 Spread</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    name: <span class="string">&quot;muyiy&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;You Don&#x27;t Know JS&quot;</span>,</span><br><span class="line">        price: <span class="string">&quot;45&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;...a&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;muyiy&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line">a.name = <span class="string">&quot;change&quot;</span>;</span><br><span class="line">a.book.price = <span class="string">&quot;55&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;change&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;muyiy&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br></pre></td></tr></table></figure><p>通过代码可以看出实际效果和 Object.assign() 是一样的。</p><p>3.Array.prototype.slice()</p><p>slice() 方法返回一个新的数组对象，这一对象是一个由 begin和 end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">0</span>, <span class="string">&quot;1&quot;</span>, [<span class="number">2</span>, <span class="number">3</span>]];</span><br><span class="line"><span class="keyword">let</span> b = a.slice(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// [&quot;1&quot;, [2, 3]]</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">1</span>] = <span class="string">&quot;99&quot;</span>;</span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// [0, &quot;99&quot;, [4, 3]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">//  [&quot;1&quot;, [4, 3]]</span></span><br></pre></td></tr></table></figure><p>深拷贝（Deep Copy）</p><p>复制并创建一个一摸一样的对象，不共享内存，修改新对象，旧对象保持不变;</p><p>深拷贝使用场景：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>。<span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(object))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    name: <span class="string">&quot;muyiy&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;You Don&#x27;t Know JS&quot;</span>,</span><br><span class="line">        price: <span class="string">&quot;45&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a));</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;muyiy&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line">a.name = <span class="string">&quot;change&quot;</span>;</span><br><span class="line">a.book.price = <span class="string">&quot;55&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;change&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;muyiy&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br></pre></td></tr></table></figure><p>对数组深拷贝效果如何：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">0</span>, <span class="string">&quot;1&quot;</span>, [<span class="number">2</span>, <span class="number">3</span>]];</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify( a.slice(<span class="number">1</span>) ));</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// [&quot;1&quot;, [2, 3]]</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">1</span>] = <span class="string">&quot;99&quot;</span>;</span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// [0, &quot;99&quot;, [4, 3]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">//  [&quot;1&quot;, [2, 3]]</span></span><br></pre></td></tr></table></figure><p>对数组深拷贝之后，改变原数组不会影响到拷贝之后的数组但是该方法有以下几个问题：<br>会忽略 undefined/symbol，不能处理正则/new Date<br>undefined、symbol 和函数这三种情况，会直接忽略</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;muyiy&#x27;</span>,</span><br><span class="line">    a: <span class="literal">undefined</span>,</span><br><span class="line">    b: <span class="built_in">Symbol</span>(<span class="string">&#x27;muyiy&#x27;</span>),</span><br><span class="line">    c: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;muyiy&quot;, </span></span><br><span class="line"><span class="comment">// a: undefined, </span></span><br><span class="line"><span class="comment">//  b: Symbol(muyiy), </span></span><br><span class="line"><span class="comment">//  c: ƒ ()</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;name: &quot;muyiy&quot;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="19-数组去重："><a href="#19-数组去重：" class="headerlink" title="19.数组去重："></a>19.数组去重：</h3><p>1.for循环嵌套for循环，使用splice去重更改原数组 正向遍历循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">distinct</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.length ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] === arr[j]) &#123;</span><br><span class="line">                    arr.splice(j, <span class="number">1</span>)</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    distinct(arr)</span><br><span class="line">    <span class="built_in">console</span>.log(arr) <span class="comment">// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：该方法可以顾虑到重复的 String、Boolean、 Number、undefined、null，返回的是去重后的原数组。<br>缺点：不能过滤掉 NaN、Object</p><p>2.for循环嵌套for循环，使用splice去重更改原数组 逆向遍历循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">distinct</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = arr.length; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j = i - <span class="number">1</span>; j &gt; -<span class="number">1</span> ; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] === arr[j]) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(arr[j])</span><br><span class="line">                    arr.splice(j, <span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    distinct(arr)</span><br><span class="line">    <span class="built_in">console</span>.log(arr) <span class="comment">// [1, &quot;true&quot;, true, 15, false, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点同方法一</p><p>3.includes去重 返回新数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">distinct</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> newArr = []</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!newArr.includes(arr[i])) &#123;</span><br><span class="line">                newArr.push(arr[i])</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newArr</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(distinct(arr)) <span class="comment">// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点是可以过滤重复的NaN了，但是返回的是个新数组，对比方法一二，该方法多消耗了一些存储空间。</p><p>优点：该方法可以顾虑到重复的 String、Boolean、Number、undefined、null、NaN，返回的是去重后的新数组。<br>缺点：不能过滤掉 Object</p><p>4.indexOf去重 返回新数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">distinct</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> newArr = []</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(newArr.indexOf(arr[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                newArr.push(arr[i])</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newArr</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(distinct(arr)) <span class="comment">//  [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：该方法可以顾虑到重复的 String、Boolean、 Number、undefined、null，返回的是去重后的新数组。<br>缺点：不能过滤掉 NaN、Object</p><p>5.利用对象的属性key唯一的特性去重</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">distinct</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">        <span class="keyword">let</span> newArr = []</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!obj[arr[i]])&#123;</span><br><span class="line">                obj[arr[i]] = <span class="number">1</span></span><br><span class="line">                newArr.push(arr[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newArr</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(distinct(arr)) <span class="comment">// [1, &quot;true&quot;, 15, false, undefined, null, NaN, 0, &quot;a&quot;, &#123;…&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法不仅可以过滤掉重复的NaN,还是可以过滤掉Object。</p><p>优点：该方法可以顾虑到重复的 String、Boolean、 Number、undefined、null、NaN、Object，返回的是去重后的新数组。<br>缺点：针对 NaN和’NaN’, 对象的key会视为一个key，区分不了NaN和’NaN’</p><p>6.利用ES6的Set数据结构的特性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">distinct</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(distinct(arr)) <span class="comment">// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：该方法可以顾虑到重复的 String、Boolean、 Number、undefined、null、NaN，返回的是去重后的新数组。<br>缺点：不能过滤重复的Object</p><p>7.利用ES6的Map数据结构的特性去重</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">distinct</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">        <span class="keyword">let</span> newArr = []</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!map.has(arr[i])) &#123;</span><br><span class="line">                map.set(arr[i])</span><br><span class="line">                newArr.push(arr[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newArr</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(distinct(arr)) <span class="comment">// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：该方法可以顾虑到重复的 String、Boolean、 Number、undefined、null、NaN，返回的是去重后的新数组。<br>缺点：不能过滤重复的Object</p><p>总结：</p><ul><li><p>splice、indexof（不能过滤NaN、object）：</p><pre><code>  双重for循环，判断arr[i] 和 arr[j](j=i+1)是否相等利  用splice去重数组，正向遍历数组，不能过滤掉 NaN、Object  双重for循环，判断arr[i]和arr[j](j=i-1)是否相等利  用splice去重数组，逆向遍历数组，不能过滤掉 NaN、Object  定义新数组，for循环判断新数组是否包含indexOf当前循环值，  利用indexOf去重，不能过滤掉 NaN、Object</code></pre></li><li><p>includes、set、map（不能过滤object）：</p><pre><code>  定义新数组，for循环判断新数组是否includes当  前循环值，利用includes去重，不能过滤掉 Object  利用ES6的Set数据结构的特性：return Array.from  (new Set(arr))，不能过滤掉 Object  利用ES6的Map数据结构的特性去重：      let map = new Map()      for循环中判断：map.has(arr[i])  不能过滤掉 Object</code></pre></li><li><p>利用对象的属性key唯一的特性去重:</p><pre><code>  let obj = &#123;&#125;  for循环判断：obj[arr[i]]不存在将当前循环元素push新数组  可以过滤掉 NaN、Object，不可以区分&#39;NaN&#39;和NaN</code></pre></li></ul><h3 id="20-DOM-事件有哪些阶段？谈谈对事件代理的理解"><a href="#20-DOM-事件有哪些阶段？谈谈对事件代理的理解" class="headerlink" title="20.DOM 事件有哪些阶段？谈谈对事件代理的理解"></a>20.DOM 事件有哪些阶段？谈谈对事件代理的理解</h3><p>捕获阶段-目标阶段-冒泡阶段</p><p>事件代理简单说就是：事件不直接绑定到某元素上，而是绑定到该元素的父元素上，进行触发事件操作时(例如’click’)，再通过条件判断，执行事件触发后的语句(例如’alert(e.target.innerHTML)’)</p><p>好处：(1)使代码更简洁；(2)节省内存开销</p><h3 id="21-async-await"><a href="#21-async-await" class="headerlink" title="21.async/await"></a>21.async/await</h3><p>async用于声明一个函数是异步的，await用来等待一个异步<br>方法执行完成，await只能出现在async函数中</p><p>async函数会返回一个promise对象，如果async函数直接<br>return一个直接量，async函数会把这个直接量用promise.resolve()<br>封装成promise对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello async&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = testAsync();</span><br><span class="line"><span class="built_in">console</span>.log(result);<span class="comment">//Promise &#123;resolved： &#x27;hello async&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p>所以如果不能用await取其返回值情况下可用：<br>then()链来处理这个promise对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">testAsync().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res); <span class="comment">//hello async</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果async没有返回值，它会返回Promise.resolve(undefined)</p><p>await等待的是一个表达式，这个表达式的结果是promise对<br>象或其他值（直接量或者普通函数）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;something&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">&quot;hello async&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> v1 = <span class="keyword">await</span> getSomething();</span><br><span class="line">    <span class="keyword">const</span> v2 = <span class="keyword">await</span> testAsync();</span><br><span class="line">    <span class="built_in">console</span>.log(v1, v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();<span class="comment">//something hello async</span></span><br></pre></td></tr></table></figure><p>如果await等待的不是promise对象，那await表达式的结果就是它等到的东西<br>如果await等待的是promise对象，那它就阻塞后面的代码，等着<br>promise对象resolve，resolve的值就是await表达式的运算结果</p><p>async会将其后的函数的返回值封装成一个promise对象，而await会等待这个promise完成，并将resolve结果返回</p><p>await函数结果可能是rejected，所以最好把await命令放<br>在try…catch块中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">await</span> getSomething();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">await</span> getSomething().catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err)</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="22-协程"><a href="#22-协程" class="headerlink" title="22.协程"></a>22.协程</h3><p>意思是多个线程互相协作，完成异步任务。<br>协程有点像函数，又有点像线程。它的运行流程大致如下：<br>第一步，协程A开始执行。</p><p>第二步，协程A执行到一半，进入暂停，执行权转移到协程B。</p><p>第三步，（一段时间后）协程B交还执行权。</p><p>第四步，协程A恢复执行。</p><h3 id="23-Generator"><a href="#23-Generator" class="headerlink" title="23.Generator"></a>23.Generator</h3><p>Generator函数就是协程再es6的实现，最大的特点就是可用交出函数的执行权（暂停执行）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码就是一个 Generator 函数。它不同于普通函数，是可以暂停执行的，所以函数名之前要加星号，以示区别。整个generator函数就是一个异步任务，需要操作暂停地方就用yeild语句注明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>generator函数返回一个内部指针g，执行generator函数不会返回结果，而是返回一个指针对象，调用g的next方法会移动内部指针移动到yeild语句</p><p>next 方法的作用是分阶段执行 Generator 函数，每次调用next方法会返回一个对象，表示当前阶段信息（value和done）value是yeild语句后表达式的值，done 属性是一个布尔值，表示Generator 函数是否执行完毕，即是否还有下一个阶段。</p><p>Generator函数可以暂停执行和恢复执行，这是可用异步任务的原因，除此外还有两个特效：函数体内数据交换和错误处理机制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.next(<span class="number">2</span>) <span class="comment">// &#123; value: 2, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>第二个 next 方法带有参数2，这个参数可以传入 Generator函数，作为上个阶段异步任务的返回结果，被函数体内的变量 y 接收。因此，这一步的 value 属性，返回的就是2</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js事件执行机制-事件循环</title>
      <link href="/ZJY.github.io/2021/01/20/js%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
      <url>/ZJY.github.io/2021/01/20/js%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="1-javascript是单线程语言"><a href="#1-javascript是单线程语言" class="headerlink" title="1.javascript是单线程语言"></a>1.javascript是单线程语言</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;定时器开始啦&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;马上开始执行for循环&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        i==<span class="number">99</span> &amp;&amp; resolve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;执行then函数&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;代码执行结束&#x27;</span>);</span><br></pre></td></tr></table></figure><p>结果：<br>马上开始执行for循环<br>代码执行结束<br>执行then函数<br>定时器开始啦</p><h3 id="2-Js事件循环："><a href="#2-Js事件循环：" class="headerlink" title="2.Js事件循环："></a>2.Js事件循环：</h3><ul><li>同步任务</li><li>异步任务</li></ul><p>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。<br>当指定的事情完成时，Event Table会将这个函数移入Event Queue。<br>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。<br>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [];</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url:www.javascript.com,</span><br><span class="line">    data:data,</span><br><span class="line">    success:<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;发送成功!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;代码执行结束&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>ajax进入Event Table，注册回调函数success。</li><li>执行console.log(‘代码执行结束’)。</li><li>ajax事件完成，回调函数success进入Event Queue。</li><li>主线程从Event Queue读取回调函数success并执行</li></ul><p>除了广义的同步任务和异步任务，我们对任务有更精细的定义：</p><ul><li>macro-task(宏任务)：包括整体代码script，setTimeout，setInterval</li><li>micro-task(微任务)：Promise，process.nextTick</li></ul><p>事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;   <span class="comment">//宏任务timeout1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//微任务process2</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//微任务then2</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//微任务process1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;7&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//微任务then1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//宏任务timeout2</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; 微任务process3</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;10&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;11&#x27;</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//微任务then3</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;12&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>宏任务：timeout1—timeout2<br>微任务：process1—then1—process2—then2—process3—then3<br>输出顺序：1—7—整个script宏任务执行完毕，执行所有微任务process1，then1，—6—8—执行宏任务timeout1—2—4—执行所有微任务process2，then2—3—5—执行宏任务timout2—9—11—执行所有微任务process3，then3—10—12</p><p>1、7、6、8、2、4、3、5、9、11、10、12</p><p>事件循环Event loop是js实现异步的一种方法，也是js的执行机制</p><p>Javascript是一门单线程语言，事件循环是javascript的执行机制</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-面试点</title>
      <link href="/ZJY.github.io/2021/01/20/vue-%E9%9D%A2%E8%AF%95%E7%82%B9/"/>
      <url>/ZJY.github.io/2021/01/20/vue-%E9%9D%A2%E8%AF%95%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="1-mvvm"><a href="#1-mvvm" class="headerlink" title="1.mvvm"></a>1.mvvm</h3><p>m,指数据模型（data）,v,指视图，UI组件，vm视图模型，把传统的mvc中controller演变成viewModel.<br>viewModel是view和model的桥梁，数据会绑定到viewModel并自动将数据渲染到页面，视图变化时会<br>通知viewModel层更新数据。</p><h3 id="2-vue2中响应式原理"><a href="#2-vue2中响应式原理" class="headerlink" title="2.vue2中响应式原理"></a>2.vue2中响应式原理</h3><p>在初始化数据时，会使用Object.defineProperty()方法重新定义data中到所有属性，在使用对于属性时，<br>首先进行依赖收集（收集当前组件到watcher），如果属性发生变化时会通知相关依赖进行更新操作（订阅/发布）</p><h3 id="3-vue3响应式原理"><a href="#3-vue3响应式原理" class="headerlink" title="3.vue3响应式原理"></a>3.vue3响应式原理</h3><p>vue3使用proxy替代了object.defineproperty，proxy可直接检测到数组和对象到变化。并且有13中拦截方法。</p><h3 id="4-vue3只会监测数组到第一层，vue3怎么解决？"><a href="#4-vue3只会监测数组到第一层，vue3怎么解决？" class="headerlink" title="4.vue3只会监测数组到第一层，vue3怎么解决？"></a>4.vue3只会监测数组到第一层，vue3怎么解决？</h3><p>判断Reflect.get到返回值类型是否为object，如果式用Reactive方法继续进行代理，实现数组到深度监测</p><h3 id="5-监测数组可能多次触发get-set方法，如何防止？"><a href="#5-监测数组可能多次触发get-set方法，如何防止？" class="headerlink" title="5.监测数组可能多次触发get/set方法，如何防止？"></a>5.监测数组可能多次触发get/set方法，如何防止？</h3><p>判断key是否为当前被代理对象target自身属性，或者新值和旧值是否相等，两者满足其一可触发trigger</p><h3 id="6-vue2如何监测数组变化？"><a href="#6-vue2如何监测数组变化？" class="headerlink" title="6.vue2如何监测数组变化？"></a>6.vue2如何监测数组变化？</h3><p>使用了函数劫持，并重新了数组方法。vue对data中数组进行了原型链重写，并指向了自己定义的数组原型方法，<br>当调用数组api时，进行依赖更新，当数组中存在引用类型时，会对引用类型再次递归遍历进行监控属性监测数组。</p><h3 id="7-nextTick"><a href="#7-nextTick" class="headerlink" title="7.nextTick"></a>7.nextTick</h3><p>在下次Dom更新循环之后执行延迟回调。主要使用了宏任务和微任务，根据执行环境分别尝试采用：<br>promise/mutationobserve/setimmediate/settimeout定义了一个异步方法，多次调用nextTick会将方法存入队列中，<br>通过这个异步方法清空队列。</p><h3 id="8-vue生命周期"><a href="#8-vue生命周期" class="headerlink" title="8.vue生命周期"></a>8.vue生命周期</h3><ul><li>beforeCreate:new Vue()后第一个钩子函数，在此阶段data/methods/computed/watch中方法和数据都不能被访问；</li><li>created:实例被创建之后，此时已完成数据观测，可以访问，更改数据，此时更改数据不回触发update函数，此时<br>可初始化数据，不可访问Dom，或者vm.$nextTick中进行访问</li><li>beforeMount:实例被挂载之前，template模版已导入渲染函数编译，此时虚拟dom已创建完成，即将开始渲染，可更新数据</li><li>mounted:实例被挂载之后，dom已挂载，数据完成双向绑定，可更新数据，通过ref访问真是dom</li><li>beforeUpdate:数据更新之前，响应式数据更新之前，虚拟dom重新渲染之前触发，可更新数据不触发update</li><li>updated:完成更新之后，dom已完成更新，避免此阶段更新数据，造成重复渲染</li><li>beforeDestory：实例销毁之前，实例扔可用，可做收尾清除工作</li><li>destoryed:实例被销毁后，实例不可用</li></ul><h3 id="9-接口请求放在哪个生命周期？"><a href="#9-接口请求放在哪个生命周期？" class="headerlink" title="9.接口请求放在哪个生命周期？"></a>9.接口请求放在哪个生命周期？</h3><p>mounted和created中都可，根据是否需要访问dom决定，但是服务器渲染不支持mounted,需要放在created中</p><h3 id="10-computed和watch区别？"><a href="#10-computed和watch区别？" class="headerlink" title="10.computed和watch区别？"></a>10.computed和watch区别？</h3><p>computed本质上是一个具有缓存的watcher,依赖的属性发生变化就会更新视图，使用于消耗性能的场景<br>watch没有缓存，起到观察的作用，可以监听数据执行回调，深度监听，deep：true</p><h3 id="11-v-if和v-show的区别？"><a href="#11-v-if和v-show的区别？" class="headerlink" title="11.v-if和v-show的区别？"></a>11.v-if和v-show的区别？</h3><p>v-if条件不成立时，不会渲染dom，v-show是display属性样式切换当前dom的显示和隐藏，<br>v-if有更高的切换消耗；v-show有更高的初始渲染消耗</p><h3 id="12-组件中的data为什么是一个函数？"><a href="#12-组件中的data为什么是一个函数？" class="headerlink" title="12.组件中的data为什么是一个函数？"></a>12.组件中的data为什么是一个函数？</h3><p>组件可以被多次复用，创建多个实例，这些实例本质是同一个构造函数，如果data是对象，对象是引用类型，<br>修改对象会影响所有实例，因此data是一个函数</p><h3 id="13-v-model的原理"><a href="#13-v-model的原理" class="headerlink" title="13.v-model的原理"></a>13.v-model的原理</h3><p>v-model是一个语法糖，是value+input的语法糖，根据model属性的prop和event属性来进行定义。原生的v-model会根据<br>标签的不同生成不同的事件和属性</p><h3 id="14-vue事件绑定原理"><a href="#14-vue事件绑定原理" class="headerlink" title="14.vue事件绑定原理"></a>14.vue事件绑定原理</h3><p>原生绑定事件通过addEventlistener绑定给真实原素的，组件事件绑定通过vue自定义的$on实现的</p><h3 id="15-vue模版编译的原理？"><a href="#15-vue模版编译的原理？" class="headerlink" title="15.vue模版编译的原理？"></a>15.vue模版编译的原理？</h3><p>vue的编译过程就是将template转化为render函数的过程，经历以下阶段：</p><ul><li>转化成AST树</li><li>优化</li><li>codegen</li></ul><p>首先解析模版，生成AST树，使用正则对模版进行解析，对不同标签文本用不同钩子进行处理<br>vue数据是响应式对，但不是所有数据都是响应式的，有一些数据渲染后就不会发生变化，其Dom也不会<br>发生变化，深度遍历AST树，标记这些静态节点就可以跳过比对<br>将优化过后的AST树转化为可执行的代码</p><h3 id="16-keep-alive"><a href="#16-keep-alive" class="headerlink" title="16.keep-alive"></a>16.keep-alive</h3><p>keep-alive可以实现组件缓存，当组件切换时不会对当前组件进行卸载<br>通过include/exclued实现组件有条件对进行缓存<br>两个生命周期activated/deactivated，用来判断当前组件是否处于活跃状态</p><h3 id="17-vue组件生命周期调用顺序？"><a href="#17-vue组件生命周期调用顺序？" class="headerlink" title="17.vue组件生命周期调用顺序？"></a>17.vue组件生命周期调用顺序？</h3><ul><li>组件调用顺序是先父后子，渲染完成顺序是先子后父</li><li>组件销毁顺序是先父后子，销毁完成顺序是先子后父</li></ul><p>加载渲染过程：<br>父beforeCreate-&gt;父created-&gt;父beforeMount-子beforecreate-子created-》子beforeMounted-》子mounted-》父mounted</p><p>子组件更新过程：<br>父beforeUpdated-》子beforeUpdated-》子updated-》父updated</p><p>父组件更新过程：<br>父beforeUpdated-》父updated</p><p>销毁过程：<br>父beforeDestory-》子beforeDestory-》子destoryed-》父destoryed</p><h3 id="18-vue2组件通信"><a href="#18-vue2组件通信" class="headerlink" title="18.vue2组件通信"></a>18.vue2组件通信</h3><ul><li>父子间通信： 父-》子： props       子-》父：$on  $emit<br>获取父子组件实例 ：$parent  $children<br>Ref获取实例的方式调用组件的属性或方法</li><li>兄弟组件通信： Event Bus</li><li>跨级组件通信：vuex      $attrs  $listeners    Provide  inject</li></ul><h3 id="19-SSR"><a href="#19-SSR" class="headerlink" title="19.SSR"></a>19.SSR</h3><p>SSR服务端渲染，就是在客户端把标签渲染成html的工作放在服务端完成，然后将html返回给客户端<br>SSR有更好的SEO，首屏加载速度快，缺点是服务端渲染只支持beforeCreate和created两个钩子，需要nodejs环境，<br>对服务器有更大对负载需求</p><h3 id="20-vue性能优化"><a href="#20-vue性能优化" class="headerlink" title="20.vue性能优化"></a>20.vue性能优化</h3><ul><li><p>编码阶段：</p><ul><li>减少data中数据</li><li>v-if和v-show不能连用</li><li>SPA采用keep-alive缓存组件</li><li>使用路由懒加载，异步组件</li><li>第三模块按需引入</li><li>图片懒加载</li><li>防抖、节流</li></ul></li><li><p>SEO优化：</p><ul><li>预渲染</li><li>服务端渲染</li></ul></li><li><p>打包优化：</p><ul><li>压缩代码</li><li>tree shaking</li><li>cdn加载第三方模块</li><li>sourcemap优化</li></ul></li></ul><h3 id="21-hash路由和history路由的实现原理"><a href="#21-hash路由和history路由的实现原理" class="headerlink" title="21.hash路由和history路由的实现原理"></a>21.hash路由和history路由的实现原理</h3><p>location.hash的值实际上就是url中#后面的值<br>history采用懒H5中提供的API来实现，主要有history.pushState() history.replaceState()</p><h3 id="22-vuex"><a href="#22-vuex" class="headerlink" title="22.vuex"></a>22.vuex</h3><p>vuex和全局对象的区别：<br>vuex的状态存储是响应式的，组件从store中读取状态，当store中的状态变化时，会更新组件<br>不能直接改变store中状态，必须显式提交mutation</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        count:<span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutation:&#123;</span><br><span class="line">        <span class="function"><span class="title">increment</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">            state.count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">store.commit(<span class="string">&#x27;increment&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(store.state.count); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>由于 store 中的状态是响应式的，在组件中调用 store 中的状态简单到仅需要在计算属性中返回即可。触发变化也仅仅是在组件的 methods 中提交 mutation</p><h3 id="23-什么是vuex"><a href="#23-什么是vuex" class="headerlink" title="23.什么是vuex"></a>23.什么是vuex</h3><p>vuex是专门为vuejs应用程序开发的状态管理插件，集中存储管理组件状态，通过显式提交mutation改变组件状态</p><h3 id="24-vuex解决了什么？"><a href="#24-vuex解决了什么？" class="headerlink" title="24.vuex解决了什么？"></a>24.vuex解决了什么？</h3><p>多个组件依赖同一个状态，多层组件间传值<br>来自不同的组件的行为需要变更同一个状态</p><p>怎么引用vuex？<br>1.安装依赖 npm install vuex –save<br>2.在项目目录创建store文件夹<br>3.在store文件夹下新建index。js文件，创建vuex实例<br>4.在main文件中引入vuex和store</p><p>vuex的5个核心属性？<br>state    mutation        getter        actions        modules</p><p>vuex的状态管理存储在state中，通过提交mutation改变状态</p><p>vuex中状态是对象时，使用时，要深度克隆赋值对象再修改，防止影响原始数据</p><p>vuex中action和mutation有什么区别？<br>action提交的是mutation，而不是直接变更状态，mutation可以直接变更状态<br>action是this.$store.dispatch()来提交，而mutation是this.$store.commit来提交<br>接收参数不同，mutation第一个参数是state，action是context</p><h3 id="25-重定向页面："><a href="#25-重定向页面：" class="headerlink" title="25.重定向页面："></a>25.重定向页面：</h3><p>routes:[{path:’/a’, redirect: ‘/b’ }]<br>配置404页面：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">&quot;/404&quot;</span>,</span><br><span class="line">    name: <span class="string">&quot;notFound&quot;</span>,</span><br><span class="line">    component: notFound</span><br><span class="line">&#125;, </span><br><span class="line">&#123;</span><br><span class="line">    path: <span class="string">&quot;*&quot;</span>, <span class="comment">// 此处需特别注意置于最底部</span></span><br><span class="line">    redirect: <span class="string">&quot;/404&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="26-路由几种模式，区别是什么？"><a href="#26-路由几种模式，区别是什么？" class="headerlink" title="26.路由几种模式，区别是什么？"></a>26.路由几种模式，区别是什么？</h3><ul><li>hash：兼容所有浏览器，但不支持H5 history api hash值为#后面的内容，通过监听hashChange事件<br>来完成操作实现前端路由，hash值变化不会请求服务器</li><li>history：依赖H5 history API实现前端路由，和正常url一样，但是初次请求或刷新会请求服务器，没有<br>请求到对于资源会返回404</li><li>abstract：支持所有js运行环境，如果发现没有浏览器到api路由会强制进入此模式</li></ul><h3 id="27-发布-订阅者模式："><a href="#27-发布-订阅者模式：" class="headerlink" title="27.发布/订阅者模式："></a>27.发布/订阅者模式：</h3><p>vue内部实现了双向绑定机制，可以不再操作dom，此机制是通过数据劫持结合发布/订阅者模式实现的：通过object.defineProperty()来劫持各个属性的getter,setter属性，在数据变动时发布消息给订阅者，触发相应的监听回调。<br>订阅模式和观察者模式不一致，订阅模式有一个调度中心，对订阅事件统一进行管理。而观察者模式可以随意注册事件，调用事件。</p><h3 id="28-数据双向绑定基础：Object-defineProperty"><a href="#28-数据双向绑定基础：Object-defineProperty" class="headerlink" title="28.数据双向绑定基础：Object.defineProperty()"></a>28.数据双向绑定基础：Object.defineProperty()</h3><ul><li>数据属性：</li></ul><p>configurable—能否用delete删除属性从而重新定义属性<br>enumerable—能否通过for-in遍历，即是否可枚举<br>writable—能否修改属性的值，默认为true<br>value—属性的数据值，默认为undefined<br>若要修改上述4个数据属性，需要Object.defineProperty(属性所在对象，属性名，描述符对象)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name:’’</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person,”name”,&#123;</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    name:”test”</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>访问器属性：</li></ul><p>访问器属性不包含数据值value，包含一对getter,setter函数（非必须）。value和writable和get/set不能共存。<br>configurable—能否用delete删除属性从而重新定义属性<br>enumerable—能否通过for-in遍历，即是否可枚举<br>get—读取属性调用的函数，默认为undefined<br>value—读取属性调用的函数，默认为undefined</p><p>Object.create(null): this.set = Object.create(null)这样赋值，这样写不需要考虑原型链上的属性，可以真正创建一个纯净的对象。</p><h3 id="29-es6"><a href="#29-es6" class="headerlink" title="29.es6"></a>29.es6</h3><p>export default和export的区别：<br>1.在一个文件或模块中，可以有多个export，而export default只能有一个<br>2.通过export方式导出，在导入时要加{},而export default则不需要</p><p>箭头函数：<br>1.箭头函数中的this的指向时固定不变的，即是定义函数时的指向<br>2.普通函数中的this的指向是变化的，即是使用函数时的指向<br>class继承：<br>可通过extends关键字实现继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.company=‘A’;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">testA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.company;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.exployee=<span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>super关键字，表示父类的构造函数，用来新建父类的this对象。super虽然代表类父类A的构造函数，但是返回的是子类B的实例，即super内部的this指向的是B，因此 super()在这里相当于A.prototype.constructor.call(this)</p><ul><li>es5和es6实现继承的不同：</li></ul><p>es5的继承，实质上是先创建子类的实例对象this,然后将父类的方法添加到this上，Parent.apply(this)<br>es6的继承，实质上是先创建父类的实例对象this，然后再用子类的构造函数修改this。</p><ul><li>proxy:</li></ul><p>vue3将会用proxy代替object.defineProperty()完成数据劫持工作，会使初始化速度加倍，内存占用减半。<br>var proxy = new Proxy(target,handler);target表示要拦截的对象，handler用来定制拦截的行为。</p><h3 id="30-闭包"><a href="#30-闭包" class="headerlink" title="30.闭包"></a>30.闭包</h3><p>闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常用方式，就是一个函数中创建另一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一段：</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">con</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="built_in">this</span>.num )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> funOne = fun();</span><br><span class="line"></span><br><span class="line">funOne();  <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二段</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">con</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( num )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> funOne = fun();</span><br><span class="line"></span><br><span class="line">funOne(); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h3 id="31-函数柯里化"><a href="#31-函数柯里化" class="headerlink" title="31.函数柯里化"></a>31.函数柯里化</h3><p>就是把多个参数的函数，转化为单参数函数。<br>add(2)(3)(4)(5)输出14:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum=<span class="number">0</span>;</span><br><span class="line">    sum= sum+num;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">tempFun</span>(<span class="params">numB</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">arguments</span>.length===<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sum= sum+ numB;</span><br><span class="line">            <span class="keyword">return</span> tempFun;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-大文件上传</title>
      <link href="/ZJY.github.io/2021/01/19/javascript-%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/ZJY.github.io/2021/01/19/javascript-%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<p>整体思路：</p><ul><li>前端：<br>前端大文件上传网上的大部分文章已经给出了解决方案，核心是利用 Blob.prototype.slice 方法，和数组的 slice 方法相似，调用的 slice 方法可以返回原文件的某个切片<br>这样我们就可以根据预先设置好的切片最大数量将文件切分为一个个切片，然后借助 http 的可并发性，同时上传多个切片，这样从原本传一个大文件，变成了同时传多个小的文件切片，可以大大减少上传时间<br>另外由于是并发，传输到服务端的顺序可能会发生变化，所以我们还需要给每个切片记录顺序</li><li>服务端：<br>服务端需要负责接受这些切片，并在接收到所有切片后合并切片</li></ul><p>上传控件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> @<span class="attr">change</span>=<span class="string">&quot;handleFileChange&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">&quot;handleUpload&quot;</span>&gt;</span>上传<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    data: <span class="function">() =&gt;</span> (&#123;</span></span><br><span class="line">        container: &#123;</span><br><span class="line"><span class="javascript">        file: <span class="literal">null</span></span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;),</span><br><span class="line">methods: &#123;</span><br><span class="line"><span class="javascript">    <span class="keyword">async</span> <span class="function"><span class="title">handleFileChange</span>(<span class="params">e</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> [file] = e.target.files;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (!file) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">Object</span>.assign(<span class="built_in">this</span>.$data, <span class="built_in">this</span>.$options.data());</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.container.file = file;</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        <span class="keyword">async</span> <span class="function"><span class="title">handleUpload</span>(<span class="params"></span>)</span> &#123;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>请求逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">request(&#123;</span><br><span class="line">    url,</span><br><span class="line">    method = <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    data,</span><br><span class="line">    headers=&#123;&#125;,</span><br><span class="line">    requestList</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        xhr.open(method,url);</span><br><span class="line">        <span class="built_in">Object</span>.keys(headers).forEach(<span class="function"><span class="params">key</span>=&gt;</span>&#123;</span><br><span class="line">            xhr.setRequestHeader(key, headers[key])</span><br><span class="line">        &#125;);</span><br><span class="line">        xhr.send(data),</span><br><span class="line">        xhr.onload = <span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">            resolve(&#123;</span><br><span class="line">                data: e.target.response</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上传切片：</p><p>上传需要做两件事：<br>1.对文件进行切片<br>2.将切片传给服务器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"> <span class="keyword">const</span> LENGTH = <span class="number">10</span>; <span class="comment">// 切片数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">data: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    container: &#123;</span><br><span class="line">        file: <span class="literal">null</span>,</span><br><span class="line">         data: []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;),</span><br><span class="line">methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">request</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">handleFileChange</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">    <span class="comment">// 生成文件切片</span></span><br><span class="line">    <span class="function"><span class="title">createFileChunk</span>(<span class="params">file, length= LENGTH</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> fileChunkList = [];</span><br><span class="line">        <span class="keyword">const</span> chunkSize = <span class="built_in">Math</span>.ceil(file.size / length);<span class="comment">//切片大小</span></span><br><span class="line">        <span class="keyword">let</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="title">whilte</span>(<span class="params">cur &lt; file.size</span>)</span> &#123;</span><br><span class="line">            fileChunkList.push(&#123;<span class="attr">file</span>:file.slice(cur,curchunkSize)&#125;);</span><br><span class="line">            cur=chunkSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fileChunkList;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 上传切片</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">uploadChunks</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> requestList = <span class="built_in">this</span>.data.map(<span class="function">(<span class="params">&#123;chunk&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> formData = <span class="keyword">new</span> formData();</span><br><span class="line">            formData.append(<span class="string">&quot;chunk&quot;</span>,chunk);</span><br><span class="line">            formData.append(<span class="string">&quot;hash&quot;</span>,hash);</span><br><span class="line">            formData.append(<span class="string">&quot;filename&quot;</span>,<span class="built_in">this</span>.container.file.name);</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                formData;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).map(<span class="keyword">async</span> (&#123;formData&#125;)=&gt;&#123;</span><br><span class="line">            <span class="built_in">this</span>.request(&#123;</span><br><span class="line">                url:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                data: formData</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">await</span> <span class="built_in">Promise</span>.all(requestList);<span class="comment">//并发切片</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">handleUpload</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!<span class="built_in">this</span>.container.file) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">const</span> fileChunkList = <span class="built_in">this</span>.createFileChunk(<span class="built_in">this</span>.container.file);</span><br><span class="line">        <span class="built_in">this</span>.data = fileChunkList.map(<span class="function">(<span class="params">&#123;file&#125;,index</span>)=&gt;</span>&#123;</span><br><span class="line">            chunk: file,</span><br><span class="line">            hash: <span class="built_in">this</span>.container.file.name  <span class="string">&#x27;-&#x27;</span> index, <span class="comment">//文件名数组下标</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">await</span> <span class="built_in">this</span>.uploadChunks();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>当点击上传按钮时，调用 createFileChunk 将文件切片，切片数量通过一个常量 Length 控制，这里设置为 10，即将文件分成 10 个切片上传<br>createFileChunk 内使用 while 循环和 slice 方法将切片放入 fileChunkList 数组中返回<br>在生成文件切片时，需要给每个切片一个标识作为 hash，这里暂时使用文件名  下标，这样后端可以知道当前切片是第几个切片，用于之后的合并切片<br>随后调用 uploadChunks 上传所有的文件切片，将文件切片，切片 hash，以及文件名放入 FormData 中，再调用上一步的 request 函数返回一个 proimise，最后调用 Promise.all 并发上传所有的切片</p><p>发送合并请求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">await</span> <span class="built_in">Promise</span>.all(requestList);</span><br><span class="line"> <span class="comment">// 合并切片</span></span><br><span class="line"><span class="keyword">await</span> <span class="built_in">this</span>.mergeRequest();</span><br><span class="line"> <span class="keyword">async</span> <span class="function"><span class="title">mergeRequest</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="keyword">await</span> <span class="built_in">this</span>.request(&#123;</span><br><span class="line">         url: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">         headers: &#123;</span><br><span class="line">             <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">         &#125;,</span><br><span class="line">         data: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">             filename: <span class="built_in">this</span>.container.file.name</span><br><span class="line">         &#125;)</span><br><span class="line">     &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>服务端部分：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&quot;request&quot;</span>, <span class="keyword">async</span>(req, res)=&gt;&#123;</span><br><span class="line">    res.retHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>,<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    res.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>,<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(res.method == <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">        res.status = <span class="number">200</span>;</span><br><span class="line">        res.end();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function">()=&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;listening on port:3000&quot;</span>));</span><br></pre></td></tr></table></figure><p>接受切片：</p><p>使用multiparty包处理前端传来的formdata,在 multiparty.parse 的回调中，files 参数保存了 FormData 中文件，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">fields 参数保存了 FormData 中非文件的字段.</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fse = <span class="built_in">require</span>(<span class="string">&quot;fs-extra&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> multiparty = <span class="built_in">require</span>(<span class="string">&quot;multiparty&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"> <span class="keyword">const</span> UPLOAD_DIR = path.resolve(__dirname, <span class="string">&quot;..&quot;</span>, <span class="string">&quot;target&quot;</span>); <span class="comment">// 大文件存储目录</span></span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&quot;request&quot;</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">res.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">res.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (req.method === <span class="string">&quot;OPTIONS&quot;</span>) &#123;</span><br><span class="line">    res.status = <span class="number">200</span>;</span><br><span class="line">    res.end();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> multipart = <span class="keyword">new</span> multiparty.Form();</span><br><span class="line"></span><br><span class="line">  multipart.parse(req, <span class="keyword">async</span> (err, fields, files) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> [chunk] = files.chunk;</span><br><span class="line">    <span class="keyword">const</span> [hash] = fields.hash;</span><br><span class="line">    <span class="keyword">const</span> [filename] = fields.filename;</span><br><span class="line">    <span class="keyword">const</span> chunkDir = <span class="string">`<span class="subst">$&#123;UPLOAD_DIR&#125;</span>/<span class="subst">$&#123;filename&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 切片目录不存在，创建切片目录</span></span><br><span class="line">    <span class="keyword">if</span> (!fse.existsSync(chunkDir)) &#123;</span><br><span class="line">      <span class="keyword">await</span> fse.mkdirs(chunkDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重命名文件</span></span><br><span class="line">    <span class="keyword">await</span> fse.rename(chunk.path, <span class="string">`<span class="subst">$&#123;chunkDir&#125;</span>/<span class="subst">$&#123;hash&#125;</span>`</span>);</span><br><span class="line">    res.end(<span class="string">&quot;received file chunk&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;正在监听 3000 端口&quot;</span>));</span><br></pre></td></tr></table></figure><p>合并切片：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fse = <span class="built_in">require</span>(<span class="string">&quot;fs-extra&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"><span class="keyword">const</span> UPLOAD_DIR = path.resolve(__dirname, <span class="string">&quot;..&quot;</span>, <span class="string">&quot;target&quot;</span>); <span class="comment">// 大文件存储目录</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> resolvePost = <span class="function"><span class="params">req</span> =&gt;</span></span><br><span class="line">   <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">let</span> chunk = <span class="string">&quot;&quot;</span>;</span><br><span class="line">     req.on(<span class="string">&quot;data&quot;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">       chunk = data;</span><br><span class="line">     &#125;);</span><br><span class="line">     req.on(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">       resolve(<span class="built_in">JSON</span>.parse(chunk));</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 合并切片</span></span><br><span class="line"> <span class="keyword">const</span> mergeFileChunk = <span class="keyword">async</span> (filePath, filename) =&gt; &#123;</span><br><span class="line">   <span class="keyword">const</span> chunkDir = <span class="string">`<span class="subst">$&#123;UPLOAD_DIR&#125;</span>/<span class="subst">$&#123;filename&#125;</span>`</span>;</span><br><span class="line">   <span class="keyword">const</span> chunkPaths = <span class="keyword">await</span> fse.readdir(chunkDir);</span><br><span class="line">   <span class="keyword">await</span> fse.writeFile(filePath, <span class="string">&quot;&quot;</span>);</span><br><span class="line">   chunkPaths.forEach(<span class="function"><span class="params">chunkPath</span> =&gt;</span> &#123;</span><br><span class="line">     fse.appendFileSync(filePath, fse.readFileSync(<span class="string">`<span class="subst">$&#123;chunkDir&#125;</span>/<span class="subst">$&#123;chunkPath&#125;</span>`</span>));</span><br><span class="line">     fse.unlinkSync(<span class="string">`<span class="subst">$&#123;chunkDir&#125;</span>/<span class="subst">$&#123;chunkPath&#125;</span>`</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">   fse.rmdirSync(chunkDir); <span class="comment">// 合并后删除保存切片的目录</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&quot;request&quot;</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">res.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">res.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (req.method === <span class="string">&quot;OPTIONS&quot;</span>) &#123;</span><br><span class="line">    res.status = <span class="number">200</span>;</span><br><span class="line">    res.end();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (req.url === <span class="string">&quot;/merge&quot;</span>) &#123;</span><br><span class="line">     <span class="keyword">const</span> data = <span class="keyword">await</span> resolvePost(req);</span><br><span class="line">     <span class="keyword">const</span> &#123; filename &#125; = data;</span><br><span class="line">     <span class="keyword">const</span> filePath = <span class="string">`<span class="subst">$&#123;UPLOAD_DIR&#125;</span>/<span class="subst">$&#123;filename&#125;</span>`</span>;</span><br><span class="line">     <span class="keyword">await</span> mergeFileChunk(filePath, filename);</span><br><span class="line">     res.end(</span><br><span class="line">       <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">         code: <span class="number">0</span>,</span><br><span class="line">         message: <span class="string">&quot;file merged success&quot;</span></span><br><span class="line">       &#125;)</span><br><span class="line">     );</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;正在监听 3000 端口&quot;</span>));</span><br></pre></td></tr></table></figure><p>总结：<br>前端上传大文件时使用blob.prototype.slice将文件切片，并发上传多个切片，最后发送一个合并的请求通知服务端合并切片。<br>服务端接收切片并存储，收到合并请求后使用fs.appendFileSync对多个切片进行合并<br>原生XMLHttpRequest的upload.onpropgress对切片上传进度的监听<br>使用vue计算属性根据每个切片的进度算出整个文件的上传进度</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-前端路由</title>
      <link href="/ZJY.github.io/2021/01/19/javascript-%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/"/>
      <url>/ZJY.github.io/2021/01/19/javascript-%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由?"></a>什么是路由?</h3><p>简单的说 路由就是根据不同的url地址来展示不同的内容或页面.</p><h3 id="前端路由的来源"><a href="#前端路由的来源" class="headerlink" title="前端路由的来源"></a>前端路由的来源</h3><p>在很久很久以前~ 用户的每次更新操作都需要重新刷新页面,非常的影响交互体验,后来,为了解决这个问题,便有了Ajax(异步加载方案),Ajax给体验带来了极大的提升。<br>虽然Ajax解决了用户交互时体验的痛点,但是多页面之间的跳转一样会有不好的体验,所以便有了spa(single-page application)使用的诞生。而spa应用便是基于前端路由实现的,所以便有了前端路由<br>如今比较火的vue-router/react-router 也是基于前端路由的原理实现的~</p><h3 id="前端路由的两种实现原理"><a href="#前端路由的两种实现原理" class="headerlink" title="前端路由的两种实现原理"></a>前端路由的两种实现原理</h3><p>1.Hash模式</p><pre><code>window对象提供了onhashchange事件来监听hash值的改变,一旦url中的hash值发生改变,便会触发该事件。window.onhashchange = function()&#123;&#125;</code></pre><p>2.history模式</p><pre><code>HTML5的History API 为浏览器的全局history对象增加的扩展方法。简单来说,history其实就是浏览器历史栈的一个接口window对象提供了onpopstate事件来监听历史栈的改变,一旦历史栈信息发生改变,便会触发该事件。需要特别注意的是,调用history.pushState()或history.replaceState()不会触发popstate事件。只有在做出浏览器动作时，才会触发该事件。window.onpopstate = function()&#123;// 历史栈 信息改变// do you want&#125;history提供了两个操作历史栈的API:history.pushState 和 history.replaceState：history.pushState(data[,title][,url]);//向历史记录中追加一条记录history.replaceState(data[,title][,url]);//替换当前页在历史记录中的信息。// data: 一个JavaScript对象，与用pushState()方法创建的新历史记录条目关联。无论何时用户导航到新创建的状态，popstate事件都会被触发，并且事件对象的state属性都包含历史记录条目的状态对象的拷贝。//title: FireFox浏览器目前会忽略该参数，虽然以后可能会用上。考虑到未来可能会对该方法进行修改，传一个空字符串会比较安全。或者，你也可以传入一个简短的标题，标明将要进入的状态。//url: 新的历史记录条目的地址。浏览器不会在调用pushState()方法后加载该地址，但之后，可能会试图加载，例如用户重启浏览器。新的URL不一定是绝对路径；如果是相对路径，它将以当前URL为基准；传入的URL与当前URL应该是同源的，否则，pushState()会抛出异常。该参数是可选的；不指定的话则为文档当前URL。pushState操作：    history.pushState(&#123;&quot;foo&quot;:bar&#125;,&quot;page 2&quot;,&quot;apply&quot;)    history.state;   //输出 &#123;foo:&quot;bar&quot;&#125;    window.onpopstate = function()&#123;        console.log(&#39;router&#39;);    &#125;    history.pushState(&#123;&quot;foo&quot;:&quot;bar1&quot;&#125;,&quot;page2&quot;,&quot;apply&quot;);// 此时执行不触发onpopstate方法    history.state； //输出 &#123;foo:&#39;bar1&#39;&#125;    history.back(); //做出后退操作，触发onpopstate事件，此时输出 &#39;router&#39;    history.state; //输出 &#123;foo:&quot;bar&quot;&#125;    history.forward(); //做前进操作，触发onpopstate事件，此时输出 &#39;router&#39;    history.state; //输出 &#123;foo:&quot;bar1&quot;&#125;replaceState操作：    history.back();    history.state; //输出 &#123;foo:bar&#125; 当前是bar    history.replaceState(&#123;&quot;foo&quot;:&quot;barreplace&quot;&#125;,&quot;page2&quot;,&quot;test&quot;);//不触发onpopstate事件， 此时浏览器地址改为test,并不重新加载    history.state; //输出：&#123;foo:&quot;barreplace&quot;&#125;    history.forward(); //触发onpopstate事件，输出&#39;router&#39;    history.state;  //输出： &#123;foo:&quot;bar1&quot;&#125;    history.back();//触发onpopstate事件，输出&#39;router&#39;,重新加载test    history.state; //输出：&#123;foo:&quot;barreplace&quot;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-小程序云开发</title>
      <link href="/ZJY.github.io/2021/01/19/javascript-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91/"/>
      <url>/ZJY.github.io/2021/01/19/javascript-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>1.云开发：</p><p>云开发是原生Serverless云服务。<br>云开发与传统模式相比少了后端开发这一块。</p><p>2.云开发能力：</p><p>存储<br>云函数<br>云数据库<br>音视频服务<br>智能图像服务<br>一天多交付，快速迭代产品</p><p>3.初始化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wx.cloud.init(&#123;</span><br><span class="line">    <span class="comment">// env 参数说明：</span></span><br><span class="line">    <span class="comment">//   env 参数决定接下来小程序发起的云开发调用（wx.cloud.xxx）会默认请求到哪个云环境的资源</span></span><br><span class="line">    <span class="comment">//   此处请填入环境 ID, 环境 ID 可打开云控制台查看</span></span><br><span class="line">    <span class="comment">//   如不填则使用默认环境（第一个创建的环境）</span></span><br><span class="line">    env: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    traceUser: <span class="literal">true</span>, <span class="comment">//是否在云开发控制台可见用户信息</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>4.数据库</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> db = wx.cloud.database();</span><br><span class="line"><span class="keyword">const</span> _ = db.command</span><br><span class="line">db.collection(<span class="string">&#x27;集合名&#x27;</span>).get().then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p>1.get()查询<br>2.where条件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">counter不等于<span class="number">1</span>  <span class="number">3</span>  <span class="number">4</span>的记录</span><br><span class="line">where(&#123;</span><br><span class="line">    counter: _.nin([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">&#125;)</span><br><span class="line">counter等于<span class="number">1</span>  <span class="number">3</span>  <span class="number">4</span>的记录</span><br><span class="line">where(&#123;</span><br><span class="line">    counter: _.in([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3.字段类型查询</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.collection(<span class="string">&quot;data&quot;</span>)</span><br><span class="line">.field(&#123;</span><br><span class="line">    desc: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">.get().then(<span class="built_in">console</span>.log)</span><br><span class="line">查询所有数据但只显示有desc字段的内容，例如：</span><br><span class="line"><span class="number">0</span>: &#123;<span class="attr">_id</span>: <span class="string">&quot;dbbb40a0-a4e0-479d-8432-926d05b002a8&quot;</span>&#125;</span><br><span class="line"><span class="number">1</span>: &#123;<span class="attr">_id</span>: <span class="string">&quot;37aa3ea0-db49-4c12-849f-34e5342966da&quot;</span>, <span class="attr">desc</span>: <span class="string">&quot;name2&quot;</span>&#125;</span><br><span class="line"><span class="number">2</span>: &#123;<span class="attr">_id</span>: <span class="string">&quot;1d6ff516-5714-4970-9a28-a0f8b3f7a3e6&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>4.正则查询<br>可以使用原生的正则对象：<br>    /miniprogram/i<br>db.RegExp对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.RegExp(&#123;</span><br><span class="line">    regexp: <span class="string">&#x27;miniprogram&#x27;</span>,</span><br><span class="line">    options: <span class="string">&#x27;i&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>查询name值以name-0开头的数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    db.collection(<span class="string">&quot;data&quot;</span>)</span><br><span class="line">    .where(&#123;</span><br><span class="line">        name: <span class="keyword">new</span> db.RegExp(&#123;</span><br><span class="line">            regexp: <span class="string">&#x27;name-0[1-9]&#x27;</span>,</span><br><span class="line">            options: <span class="string">&#x27;i&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .get().then(<span class="built_in">console</span>.log)</span><br><span class="line"><span class="number">0</span>: &#123;<span class="attr">_id</span>: <span class="string">&quot;dbbb40a0-a4e0-479d-8432-926d05b002a8&quot;</span>, <span class="attr">counter</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;name-01&quot;</span>&#125;</span><br><span class="line"><span class="number">1</span>: &#123;<span class="attr">_id</span>: <span class="string">&quot;37aa3ea0-db49-4c12-849f-34e5342966da&quot;</span>, <span class="attr">counter</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&quot;name-02&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>5.地理位置查询</p><p>添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.collection(<span class="string">&#x27;location&#x27;</span>).add(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        location: db.Geo.Point(<span class="number">100.2333</span>,<span class="number">10.9978</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>查询：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.collection(<span class="string">&#x27;location&#x27;</span>).get().then( <span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res.data[<span class="number">0</span>].location)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>6.云开发数据库权限：</p><p>1.仅创建者可写，所有人可读<br>2.仅创建者可读写<br>3.仅管理端可写，所有人可读<br>4.仅管理端可读写</p><p>存储：</p><p>可使用fileid引用存储的资源</p><p>生成文件的临时链接：</p><p>为什么生成临时链接： fileid无法在小程序以外的平台使用<br>如何生成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wx.cloud.getTempFileURL(&#123;</span><br><span class="line">    fileList: [<span class="string">&#x27;cloud://zjy20200115-8v2oc.7a6a-zjy20200115-8v2oc-1258009129/oL40f5Rxp9wplmcEtUO3Av-4Yr9M/0.5019968125178349_1579073268192.jpg&#x27;</span>],<span class="comment">//fileid</span></span><br><span class="line">    success:<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res.fileList[<span class="number">0</span>].tempFileURL)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用云函数定时器：</p><p>1.在云函数目录下创建config.json文件，并设置触发器<br>2.上传触发器<br>步骤：<br>    1.创建云函数trigger<br>    2.上传云函数<br>    3.云函数目录下trigger创建config.json文件：添加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;triggers&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;trigger&quot;</span>, <span class="comment">//触发器名字</span></span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;timer&quot;</span>, <span class="comment">//类型：定时器</span></span><br><span class="line">            <span class="string">&quot;config&quot;</span>: <span class="string">&quot;* * * * * * *&quot;</span> <span class="comment">//触发事件配置，七位从右到左代表：年 星期 月 日 时 分 秒 ；七个*代表每秒钟执行一次</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.上传触发器<br>5.在云开发控制台-云函数-日志可查看</p><p>获取集合中指定记录的引用</p><p>db.collection(‘todos’).doc(‘my-todo-id’)<br>方法接受一个 id 参数，指定需引用的记录的 _id</p><p>limit(number):指定查询结果集数量上限:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.collection(<span class="string">&#x27;todos&#x27;</span>).limit(<span class="number">10</span>)</span><br><span class="line">.get()</span><br><span class="line">.then(<span class="built_in">console</span>.log)</span><br><span class="line">.catch(<span class="built_in">console</span>.error)</span><br></pre></td></tr></table></figure><p>skip(offset:number): 指定查询返回结果时从指定序列后的结果开始返回，常用于分页</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.collection(<span class="string">&#x27;todos&#x27;</span>).skip(<span class="number">10</span>)</span><br><span class="line">.get()</span><br><span class="line">.then(<span class="built_in">console</span>.log)</span><br><span class="line">.catch(<span class="built_in">console</span>.error)</span><br></pre></td></tr></table></figure><p>云上传：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wx.chooseImage(&#123;</span><br><span class="line">    success: <span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        wx.cloud.uploadFile(&#123;</span><br><span class="line">            cloudPath: <span class="string">&#x27;images/xx.png&#x27;</span>,</span><br><span class="line">            filePath: res.tempFilePaths[<span class="number">0</span>],</span><br><span class="line">        &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res.fileID)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>定位：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wx.chooseLocation(&#123;</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">        that.setData(&#123;</span><br><span class="line">            location:&#123;</span><br><span class="line">                name: res.name,</span><br><span class="line">                latitude: res.latitude,</span><br><span class="line">                longitude: res.longitude,</span><br><span class="line">                address: res.address</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>查看定位：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wx.openLocation(&#123;</span><br><span class="line">    latitude: <span class="built_in">this</span>.data.todoInfo.location.latitude,</span><br><span class="line">    longitude: <span class="built_in">this</span>.data.todoInfo.location.longitude,</span><br><span class="line">    name: <span class="built_in">this</span>.data.todoInfo.location.name,</span><br><span class="line">    address: <span class="built_in">this</span>.data.todoInfo.location.address   </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>report-submit： true,给表单此属性设置为true,会返回formId,用于发送模板消息</p><p>云函数查询数据：</p><p>新建云函数：query：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cloud = <span class="built_in">require</span>(<span class="string">&#x27;wx-server-sdk&#x27;</span>)</span><br><span class="line">cloud.init()</span><br><span class="line"><span class="keyword">const</span> db = cloud.database()</span><br><span class="line"><span class="comment">// 云函数入口函数</span></span><br><span class="line"><span class="built_in">exports</span>.main = <span class="keyword">async</span> (event, context) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> db.collection(<span class="string">&#x27;todos&#x27;</span>).get();</span><br><span class="line">&#125;</span><br><span class="line">页面查询触发：</span><br><span class="line">wx.cloud.callFunction(&#123;</span><br><span class="line">    name: <span class="string">&#x27;query&#x27;</span>,</span><br><span class="line">&#125;).then(<span class="built_in">console</span>.log)</span><br><span class="line"></span><br><span class="line">添加： add(&#123;<span class="attr">data</span>:&#123;&#125;&#125;)</span><br><span class="line">删除： remove()</span><br><span class="line">编辑： update(&#123;</span><br><span class="line">    data:&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在云函数中使用存储资源：</p><p>1.上传文件： uploadFile</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.main = <span class="keyword">async</span> (event, context) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> fileStream = fs.createReadStream(path.join(__dirname, <span class="string">&#x27;demo.jpg&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> cloud.uploadFile(&#123;</span><br><span class="line">        cloudPath: <span class="string">&#x27;demo.jpg&#x27;</span>,</span><br><span class="line">        fileContent: fileStream,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.下载文件： downloadFile<br>3.获取临时文件链接： getTempFileURL<br>4.删除文件： deleteFile</p><p>云函数访问第三方服务器:</p><p>1.安装got （版本9.6.0，10以上版本调用失败）<br>2.开启npm 模块<br>3.云函数修改后需重新上传</p><p>云函数访问数据库：</p><p>1.安装mysql2: npm i mysql2<br>2.引入： const mysql2 = require(‘mysql2’);<br>3.连接：<br>    const connection = await mysql.createConnection({<br>        host: ‘192.168.3.66’,<br>        port: ‘3306’,<br>        user: ‘root’,<br>        database: ‘sample’,<br>        password: ‘123456’<br>    })<br>    await connection.execute(“SELECT version();”)</p><p>云函数中生成小程序二维码：</p><p>1.引用安装wx-js-utils：npm install wx-js-utils<br>2.获取token和小程序id等信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    WXMINIUser,</span><br><span class="line">    WXMINIQR</span><br><span class="line">&#125; = <span class="built_in">require</span>(<span class="string">&#x27;wx-js-utils&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> appId = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 小程序 appId</span></span><br><span class="line"><span class="keyword">const</span> secret = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 小程序 secret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取小程序码，A接口</span></span><br><span class="line"><span class="keyword">let</span> wXMINIUser = <span class="keyword">new</span> WXMINIUser(&#123;</span><br><span class="line">    appId,</span><br><span class="line">    secret</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般需要先获取 access_token</span></span><br><span class="line"><span class="keyword">let</span> access_token = <span class="keyword">await</span> wXMINIUser.getAccessToken();</span><br><span class="line"><span class="keyword">let</span> wXMINIQR = <span class="keyword">new</span> WXMINIQR();</span><br></pre></td></tr></table></figure><p>3.获取二维码api: getQR</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">options: &#123;</span><br><span class="line">    access_token,</span><br><span class="line">    path,<span class="comment">//</span></span><br><span class="line">    width</span><br><span class="line">&#125;</span><br><span class="line">示例：</span><br><span class="line"><span class="keyword">let</span> qrResult = <span class="keyword">await</span> wXMINIQR.getQR(&#123;</span><br><span class="line">    access_token,</span><br><span class="line">    path: <span class="string">&#x27;pages/index/index&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line">上传：</span><br><span class="line">wx.cloud.uploadFile(&#123;bn </span><br><span class="line">    cloudPath: <span class="string">&#x27;qr/qr.png&#x27;</span>,</span><br><span class="line">    fileConent: qrResult</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>腾讯云短信sdk: qcloudsms_js</p><p>npm i qcloudsms_js</p><p>微信支付： node tenpay</p><p>npm i tenpay</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack-webpack基础使用</title>
      <link href="/ZJY.github.io/2021/01/19/webpack-webpack%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
      <url>/ZJY.github.io/2021/01/19/webpack-webpack%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h5 id="使用lodash-是一个一致性、模块化、高性能的-JavaScript-实用工具库。"><a href="#使用lodash-是一个一致性、模块化、高性能的-JavaScript-实用工具库。" class="headerlink" title="使用lodash:是一个一致性、模块化、高性能的 JavaScript 实用工具库。"></a>使用lodash:是一个一致性、模块化、高性能的 JavaScript 实用工具库。</h5><p>要使用lodash 需要本地安装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--npm install --save lodash</span><br></pre></td></tr></table></figure><h5 id="在安装一个要打包到生产环境的安装包时，你应该使用-npm-install-–save，如果你在安装一个用于开发环境的安装包（例如，linter-测试库等），你应该使用-npm-install-–save-dev。请在-npm-文档-中查找更多信息。"><a href="#在安装一个要打包到生产环境的安装包时，你应该使用-npm-install-–save，如果你在安装一个用于开发环境的安装包（例如，linter-测试库等），你应该使用-npm-install-–save-dev。请在-npm-文档-中查找更多信息。" class="headerlink" title="在安装一个要打包到生产环境的安装包时，你应该使用 npm install –save，如果你在安装一个用于开发环境的安装包（例如，linter, 测试库等），你应该使用 npm install –save-dev。请在 npm 文档 中查找更多信息。"></a>在安装一个要打包到生产环境的安装包时，你应该使用 npm install –save，如果你在安装一个用于开发环境的安装包（例如，linter, 测试库等），你应该使用 npm install –save-dev。请在 npm 文档 中查找更多信息。</h5><h5 id="加载css"><a href="#加载css" class="headerlink" title="加载css"></a>加载css</h5><p>为了从 JavaScript 模块中 import 一个 CSS 文件，你需要在 module 配置中 安装并添加 style-loader 和 css-loader：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--npm install --save-dev style-loader css-loader</span><br></pre></td></tr></table></figure><p>在webpack.config.js中配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">                user:[</span><br><span class="line">                    <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="加载图片：-在Css中有背景和图标等图片，需要安装file-loader来处理："><a href="#加载图片：-在Css中有背景和图标等图片，需要安装file-loader来处理：" class="headerlink" title="加载图片：  在Css中有背景和图标等图片，需要安装file-loader来处理："></a>加载图片：  在Css中有背景和图标等图片，需要安装file-loader来处理：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev file-loader</span><br></pre></td></tr></table></figure><p>在配置文件中配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test:<span class="regexp">/\.(png|svg|jpg|gif)&amp;/</span>,</span><br><span class="line">        use:[</span><br><span class="line">            <span class="string">&#x27;file-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="加载字体：-file-loader-和-url-loader-可以接收并加载任何文件，然后将其输出到构建目录"><a href="#加载字体：-file-loader-和-url-loader-可以接收并加载任何文件，然后将其输出到构建目录" class="headerlink" title="加载字体： file-loader 和 url-loader 可以接收并加载任何文件，然后将其输出到构建目录"></a>加载字体： file-loader 和 url-loader 可以接收并加载任何文件，然后将其输出到构建目录</h3><p>在配置文件中配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test:<span class="regexp">/\.(woff|woff2|eot|ttf|otf)$/</span>,</span><br><span class="line">        use:[</span><br><span class="line">            <span class="string">&#x27;file-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此外，可以加载的有用资源还有数据，如 JSON 文件，CSV、TSV 和 XML。类似于 NodeJS，JSON 支持实际上是内置的，也就是说 import Data from ‘./data.json’ 默认将正常运行。要导入 CSV、TSV 和 XML，你可以使用 csv-loader 和 xml-loader：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev csv-loader xml-loader</span><br></pre></td></tr></table></figure><p>在配置文件中配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test:<span class="regexp">/\.(csv|tsv)$/</span>,</span><br><span class="line">        use:[</span><br><span class="line">            <span class="string">&#x27;csv-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        test:<span class="regexp">/\.xml$/</span>,</span><br><span class="line">        use:[</span><br><span class="line">            <span class="string">&#x27;xml-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><p>如果我们更改了我们的一个入口起点的名称，甚至添加了一个新的名称，会发生什么？生成的包将被重命名在一个构建中，但是我们的index.html文件仍然会引用旧的名字。我们用 HtmlWebpackPlugin 来解决这个问题。首先安装插件，并且调整 webpack.config.js 文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev html-webpack-plugin</span><br><span class="line">webpack.config.js:</span><br><span class="line">    <span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line">    plugins: [</span><br><span class="line">       <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">       title: <span class="string">&#x27;Output Management&#x27;</span></span><br><span class="line">     &#125;)</span><br><span class="line">   ],</span><br></pre></td></tr></table></figure><h3 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h3><p>清理 /dist 文件夹:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install clean-webpack-plugin --save-dev</span><br><span class="line">webpack.config.js:</span><br><span class="line">    <span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> CleanWebpackPlugin(), /+</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><p>通过 manifest，webpack 能够对「你的模块映射到输出 bundle 的过程」保持追踪</p><h3 id="source-map"><a href="#source-map" class="headerlink" title="source map"></a>source map</h3><p>使用 source map: 为了更容易地追踪错误和警告，JavaScript 提供了 source map 功能，将编译后的代码映射回原始源代码。如果一个错误来自于 b.js，source map 就会明确的告诉你。ource map 有很多不同的选项可用,对于本指南，我们使用 inline-source-map 选项</p><p>devtool: ‘inline-source-map’</p><h3 id="webpack编译模式"><a href="#webpack编译模式" class="headerlink" title="webpack编译模式"></a>webpack编译模式</h3><p>每次要编译代码时，手动运行 npm run build 就会变得很麻烦,webpack 中有几个不同的选项，可以帮助你在代码发生变化后自动编译代码：</p><ul><li><p>1.webpack’s Watch Mode 使用观察模式 依赖图中的所有文件以进行更改。如果其中一个文件被更新，代码将被重新编译，所以你不必手动运行整个构建。<br>  scripts中添加”watch”: “webpack –watch”,唯一的缺点是，为了看到修改后的实际效果，你需要刷新浏览器。如果能够自动刷新浏览器就更好了，<br>  可以尝试使用 webpack-dev-server，恰好可以实现我们想要的功能</p></li><li><p>2.webpack-dev-server: 为你提供了一个简单的 web 服务器，并且能够实时重新加载(live reloading)让我们设置以下：npm install –save-dev webpack-dev-server<br>  修改配置文件，告诉开发服务器(dev server)，在哪里查找文件,webpack.config.js:<br>  devServer: {<br>   contentBase: ‘./dist’<br>  },<br>  以上配置告知 webpack-dev-server，在 localhost:8080 下建立服务，将 dist 目录   下的文件，作为可访问文件。在package.json中添加一个script脚本可直接运行开发服务器。</p></li><li><p>3.webpack-dev-middleware 是一个容器(wrapper)，它可以把 webpack 处理后的文件传递给一个服务器(server)。 webpack-dev-server 在内部使用了它，同时，它也可以作为一个单独的包来使用，以便进行更多自定义设置来实现更多的需求。接下来是一个 webpack-dev-middleware 配合 express server 的示例:<br>  首先，安装 express 和 webpack-dev-middleware:<br>  npm install –save-dev express webpack-dev-middleware<br>  webpack.config.js: output:{publicPath:’/‘}<br>  新建server.js,再添加一个npm script :”server”: “node server.js”,运行npm run server</p></li></ul><h3 id="tree-shaking是一个术语，通常用于描述移除-JavaScript-上下文中的未引用代码-dead-code"><a href="#tree-shaking是一个术语，通常用于描述移除-JavaScript-上下文中的未引用代码-dead-code" class="headerlink" title="tree shaking是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)"></a>tree shaking是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)</h3><h3 id="glifyJsPlugin-用来对js文件进行压缩，从而减小js文件的大小，加速load速度。"><a href="#glifyJsPlugin-用来对js文件进行压缩，从而减小js文件的大小，加速load速度。" class="headerlink" title="glifyJsPlugin 用来对js文件进行压缩，从而减小js文件的大小，加速load速度。"></a>glifyJsPlugin 用来对js文件进行压缩，从而减小js文件的大小，加速load速度。</h3><p>uglifyJsPlugin会拖慢webpack的编译速度，所有建议在开发简单将其关闭，部署的时候再将其打开。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--npm install uglifyjs-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure><p>通过webpack-merge配置不同环境的构建配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--npm install --save-dev webpack-merge</span><br></pre></td></tr></table></figure><p>多数情况下，你也可以进行 CSS 分离，以便在生产环境中节省加载时间:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--npm install --save-dev extract-text-webpack-plugin</span><br></pre></td></tr></table></figure><p>它会将所有的入口 chunk(entry chunks)中引用的 *.css，移动到独立分离的 CSS 文件。因此，你的样式将不再内嵌到 JS bundle 中，而是会放到一个单独的 CSS 文件（即 styles.css）当中。 如果你的样式文件大小较大，这会做更快提前加载，因为 CSS bundle 会跟 JS bundle 并行加载。</p><p>代码分离是 webpack 中最引人注目的特性之一。此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。有三种常用的代码分离方法：</p><ul><li><p>1.入口起点：使用 entry 配置手动地分离代码。</p></li><li><p>2.防止重复(prevent duplication): 通过使用 CommonsChunkPlugin 来移除重复的模块</p></li><li><p>3.动态导入(dynamic imports):</p><p>  涉及到动态代码拆分时，webpack 提供了两个类似的技术。对于动态导入，第一种，也是优先选择的方式是，使用符合 ECMAScript 提案 的 import() 语法。第二种，则是使用 webpack 特定的 require.ensure<br>  import() 调用会在内部用到 promises:使用： import().then(),由于import（）会返回一个promise函数，因此可以和async函数一起使用，但是需要使用像babel这样的预处理器和Syntax Dynamic Import Babel Plugin：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--npm install --save-dev @babel/plugin-syntax-dynamic-<span class="keyword">import</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-vue基础知识点</title>
      <link href="/ZJY.github.io/2021/01/19/vue-vue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/ZJY.github.io/2021/01/19/vue-vue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="vue渐进式JavaScript框架"><a href="#vue渐进式JavaScript框架" class="headerlink" title="vue渐进式JavaScript框架"></a>vue渐进式JavaScript框架</h3><p>核心库和插件，核心库很小，需要其他插件时添加进来</p><p>核心库只关注视图层，动态构建用户界面</p><p>框架顺序：angluar(数据绑定和模板)、react（组件化和虚拟Dom技术）、vue</p><p>1、vue的特点<br>遵循MVVM模式<br>编码简洁、体积小、运行效率高<br>本身只关注UI，可以轻松引入插件（依赖vue)或第三方库(不依赖vue)开发项目</p><p>2、vue借鉴  </p><p>angluar(数据绑定和模板)<br>react（组件化和虚拟Dom技术）</p><p>3、vue扩展插件</p><p>vue-cli:vue脚手架<br>vue-resources(axios):ajax请求<br>vue-router:路由<br>vue-scroll:页面滑动<br>vue-lazyload：图片懒加载<br>vuex:状态管理模式<br>mint-ui：基于vue的UI组件库（移动端）<br>element-UI：基于vue的UI组件库（pc端）</p><p>4、vue的使用</p><p>1.引入vue.js<br>2.创建vue实例,el指定选择器范围，data初始化数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> vue(&#123;</span><br><span class="line">    el:<span class="string">&#x27;app&#x27;</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        message:<span class="string">&#x27;hello&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>5.MVVM<br>model:模型、数据对象（data）<br>view:视图、模板页面（指令、<code>&#123;&#123;&#125;&#125;`显示数据）viewmodel:视图模型（vue的实例）<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">                    viewmodel</span><br><span class="line">view-------------dom listener--------------&gt;model</span><br><span class="line">view&lt;------------data bindings--------------model</span><br><span class="line">(DOM)              (vue实例)              (js objects)</span><br></pre></td></tr></table></figure>6、数据绑定：Mustache语法（双大括号）`&#123;&#123;msg&#125;&#125;</code></p><p>7、v-once一次性的插值，当数据改变时，内容不会更新</p><p>8、v-html输入真正的HTML</p><p>9、v-bind：href将mustache语法作用于HTML特性上可简写：href</p><p>10、使用JavaScript表达式<code>&#123;&#123;msg.toUpperCase()&#125;&#125;</code></p><p>11、指令：带有v-前缀的特殊特性  v-if  v-for</p><p>12、v-on:click简写为：@click</p><p>13、计算属性computed和侦听属性watch<br>computed的set监听方法，值改变时调用set回调方法，需要显示值时，调用get回调方法<br>计算属性存在缓存，多次读取只执行一次getter计算</p><p>14、class和style绑定</p><ul><li>:class=”classA”(字符串）</li><li>:class=”{classA:isA,classB:isB}”(对象)</li><li>:class=”[‘classA;,’classB’]”(数组）</li><li>:style=”{color:activeColor,fontSize:fontSize+’px’}”(样式JS写法）</li></ul><p>15、条件渲染</p><p>v-if v-else-if v-else v-show<br>v-if是惰性的如果初始条件为假则什么都不做，直到条件第一次变为真时，v-show不管初始条件真假，元素总被渲染，并且知识简单地基于css切换<br>v-if有更高的切换开销，v-show有更高的初始渲染开销，因此，需频繁切换则使用v-show较好，如果运行时条件很少改变，则使用v-if</p><p>16、不建议v-if和v-show同时使用，v-for具有比v-if更高的优先级</p><p>17、列表渲染</p><p>v-for=”item in items”/v-for=”(item,index) in items”<br>可用of代替in<br>遍历对象按Object.keys()结果遍历</p><p>18、数组更新检测-变异方法</p><p>vue包含一组观察数组的变异方法，也会触发视图更新：<br>push()向数组末尾添加一个或多个元素，返回新的长度<br>pop()删除并返回数组的最后一个元素<br>shift()删除数组第一个元素并返回第一个元素的值<br>unshift()向数组开头添加一个或更多元素，并返回新的长度<br>splice()增、删、改数组项目，返回被删除的项目，改变原数组<br>sort()数组排序<br>reverse()颠倒数组的元素顺序，会改变原数组</p><p>19、filter数组过滤 sort排序</p><p>20、绑定事件@click=’test($event)’,$event代表当前绑定事件标签</p><p>test(event){ var text = event.target.innerHTML}</p><p>21、事件冒泡：从子到父依次执行，阻止事件冒泡，事件修饰符@click.stop=”test”原生写法:event.stopPropagation()</p><p>22、阻止事件的默认行为(比如跳转），@click.prevent=”test”原生写法：event.preventDefault</p><p>23、按键修饰符@click.enter .tab .deleter .esc .space .up .down .left .right</p><p>24、使用v-model对表单数据自动收集 双向绑定</p><p>26、vue实例的生命周期</p><p>new vue 创建vue实例<br>初始化显示（执行一次）：</p><pre><code>beforeCreate    初始化设置：observe data  init eventscreatedbeforeMountmounted</code></pre><p>更新状态（执行n次）：</p><pre><code>beforeUpdateupdated</code></pre><p>销毁vue实例（执行n次）：</p><pre><code>beforeDestorydestroyed</code></pre><p>常用生命周期：<br>mounted：请求ajax请求，设置定时器等<br>beforeDestroyed:销毁vue实例前，清除定时器等</p><p>27、transition过渡动画</p><p>在目标元素外包裹<code>&lt;transition name=&quot;xxx&quot;&gt;&lt;/transition&gt;</code><br>定义class样式：<br>    xxx-enter-active   xxx-leave-active<br>    xxx-enter          xxx-leave-to</p><p>28、自定义过滤器</p><p>1.在组件的选项中定义本地过滤器<br>2.在创建vue实例前定义全局过滤器<br>页面使用：<br><code>&#123;&#123;date | filterDate('YYYY-MM-DD')&#125;&#125;</code><br>js:<br>引入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> format <span class="keyword">from</span> <span class="string">&#x27;date-fns/format&#x27;</span></span><br><span class="line">filters:&#123;</span><br><span class="line">    filterDate:<span class="function"><span class="keyword">function</span>(<span class="params">value,fmt</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> format(value,fmt || <span class="string">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>29、指令</p><p>v-text:更新元素的textContext<br>v-html:更新元素的innerHTML<br>v-show:条件为true，切换元素的display属性<br>v-if<br>v-else-if<br>v-else<br>v-for:列表渲染<br>v-on/@:绑定事件监听器<br>v-bind:简写：，绑定Dom属性<br>v-model:在表单控件上双向绑定<br>v-pre:跳过这个元素和它的子元素的编译过程<br>v-cloak:<code>&lt;div v-cloak&gt;``&#123;&#123; message &#125;&#125;</code></div>这个指令保持在元素上直到关联实例结束编译 防止闪现, 与 css 配合:[v-cloak]{display:none}<br>v-once:只渲染元素和组件一次<br>$ref:指定唯一标识,vue 对象通过$refs 属性访问这个元素对象</p><p>30.自定义指令</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-upper-text</span>=<span class="string">&quot;msg&quot;</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-lower-text</span>=<span class="string">&quot;msg&quot;</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注册全局指令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">&#x27;upper-text&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">el,binding</span>)</span>&#123;</span><br><span class="line">    el.innerHTML= binding.value.toUpperCase()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册局部指令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">directives:&#123;</span><br><span class="line">    <span class="string">&#x27;lower-text&#x27;</span>:<span class="function"><span class="keyword">function</span>(<span class="params">el,binding</span>)</span>&#123;</span><br><span class="line">        el.innerHTML= binding.value.toLowerCase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>31.创建vue项目</p><p>npm install -g vue-cli<br>vue init webpack vueProjectname<br>cd vueProjectname<br>npm install<br>npm run dev<br>访问：<a href="http://localhost:8080/">http://localhost:8080/</a></p><p>32.模板项目结构</p><p>|–build:webpack 相关的配置文件夹(基本不需要修改)<br>|–dev-server.js: 通过 express 启动后台服务器<br>|–config:webpack 相关的配置文件夹(基本不需要修改)<br>|–index.js: 指定的后台服务的端口号和静态资源文件夹<br>|–node_modules<br>|–src: 源码文件夹<br>|–components:vue 组件及其相关资源文件夹<br>|–App.vue: 应用根主组件<br>|–main.js: 应用入口 js<br>|–static: 静态资源文件夹<br>|–.babelrc:babel 的配置文件<br>|–.eslintignore:eslint 检查忽略的配置 |–.eslintrc.js:eslint 检查的配置<br>|–.gitignore:git 版本管制忽略的配置<br>|–index.html: 主页面文件<br>|–package.json: 应用包配置文件<br>|–README.md: 应用描述说明的 readme 文件</p><p>33、项目打包和发布</p><p>1.打包：npm run build<br>2.发布：npm install -g serve<br>3.访问：<a href="http://localhost:5000/">http://localhost:5000</a></p><p>34.组件使用</p><p>1.引入组件  import List from ‘’<br>2.映射成标签：components:{}<br>3.使用<code>&lt;List&gt;&lt;/List&gt;</code></p><p>35、数据代理</p><p>数据代理是通过一个对象代理（A)对另一个对象（B,B在A中）中属性的操作</p><p>36、vue数据代理</p><p>通过MVVM对象代理data对象中所有属性的操作<br>基本流程：<br>    通过Object.defineProperty()给VM添加与data对象的属性相对应的属性描述符<br>    所有添加的属性都包含getter/setter<br>    getter/setter内部去操作data中对象属性数据</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>taro-taro的基本使用</title>
      <link href="/ZJY.github.io/2021/01/19/taro-taro%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/ZJY.github.io/2021/01/19/taro-taro%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行:"></a>项目运行:</h3><pre><code>微信小程序：npm run dev:weappH5:npm run dev:h5</code></pre><h3 id="项目打包"><a href="#项目打包" class="headerlink" title="项目打包"></a>项目打包</h3><pre><code>微信小程序：npm run build:weappH5:npm run build:h5</code></pre><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>在 Taro 中尺寸单位建议使用 px、 百分比 %，Taro 默认会对所有单位进行转换。在 Taro 中书写尺寸按照 1:1 的关系来进行书写</p><p>如果你希望部分 px 单位不被转换成 rpx 或者 rem ，最简单的做法就是在 px 单位中增加一个大写字母，例如 Px 或者 PX 这样，则会被转换插件忽略</p><p>Taro 默认以 750px 作为换算尺寸标准</p><p>Taro 提供了 API Taro.pxTransform 来做运行时的尺寸转换:Taro.pxTransform(10) // 小程序：rpx，H5：rem</p><p>对于头部包含注释 /<em>postcss-pxtransform disable</em>/ 的文件，插件不予处理。</p><p>externalClasses 需要使用 短横线命名法 (kebab-case)，而不是 React 惯用的 驼峰命名法 (camelCase)。否则无效。</p><p> Taro 中，所有组件都应当首字母大写并且使用大驼峰式命名法（Camel-Case）</p><p> Taro只能使用map,forEach,reduce等无效</p><p> setState() 函数是唯一能够更新 this.state 的地方。taro的状态更新一定是异步的，可以在回调中取得更新后的值，react的setState不总是异步的</p><p> 在 Taro 中不能使用 catchEvent 的方式阻止事件冒泡。你必须明确的使用 stopPropagation</p><p> 在 Taro 的页面和组件类中，this 指向的是 Taro 页面或组件的实例,要获取对应的小程序原生页面和组件的实例，通过this.$scope</p><h3 id="react组件的生命周期："><a href="#react组件的生命周期：" class="headerlink" title="react组件的生命周期："></a>react组件的生命周期：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructor，顾名思义，组件的构造函数。一般会在这里进行 state 的初始化，事件的绑定等等</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是当组件在进行挂载操作前，执行的函数，一般紧跟着 constructor 函数后执行</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentWillMount</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是当组件挂载在 dom 节点后执行。一般会在这里执行一些异步数据的拉取等动作</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当组件在进行更新之前，会执行的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentWillUpdate</span>(<span class="params">nextProps, nextState</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当组件收到新的 props 时会执行的函数，传入的参数就是 nextProps ，你可以在这里根据新的 props 来执行一些相关的操作，例如某些功能初始化等</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentWillReceiveProps</span>(<span class="params">nextProps</span>)</span> &#123;&#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当组件完成更新时，会执行的函数，传入两个参数是 prevProps 、prevState</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentDidUpdate</span>(<span class="params">prevProps, prevState</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 false 时，组件将不会进行更新，可用于渲染优化</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当组件准备销毁时执行。在这里一般可以执行一些回收的工作，例如 clearInterval(this.timer) 这种对定时器的回收操作</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line"></span><br><span class="line">        &lt;div&gt;</span><br><span class="line"></span><br><span class="line">            &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">            &lt;h2&gt;It is &#123;<span class="built_in">this</span>.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>props：父组件传给子组件的数据，会挂载在子组件的 this.props 上</p><p>state：与 props 不同，是属于组件自己内部的数据状态，一般在 constructor 构造函数里初始化定义 state</p><p>react组件的三个声明周期状态：</p><pre><code>*Mount: 插入真实Dom*Update: 被重新渲染*Unmount：被移除真实Dom</code></pre><h3 id="生命周期流程"><a href="#生命周期流程" class="headerlink" title="生命周期流程"></a>生命周期流程</h3><pre><code>第一次初始化渲染显示：ReactDom.render()    *constructor: 创建对象初始化state    *componentWillMount(): 将要插入回调    * render() : 用于插入虚拟 DOM 回调    * componentDidMount() : 已经插入回调每次更新 state: this.setSate()     * componentWillUpdate() : 将要更新回调    * render() : 更新(重新渲染    * componentDidUpdate() : 已经更新回调</code></pre><h3 id="taro-ui使用方式："><a href="#taro-ui使用方式：" class="headerlink" title="taro-ui使用方式："></a>taro-ui使用方式：</h3><pre><code>在页面test.tsx中：    import &#123; AtButton &#125; from &#39;taro-ui&#39;    按需引入：@import &quot;~taro-ui/dist/style/components/button.scss&quot;;全局引入使用：    在app.scss中：@import &quot;~taro-ui/dist/style/index.scss&quot;;    在页面：import &#123; AtButton &#125; from &#39;taro-ui&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> taro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css-scss的基本使用</title>
      <link href="/ZJY.github.io/2021/01/19/css-scss%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/ZJY.github.io/2021/01/19/css-scss%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="scss基础使用"><a href="#scss基础使用" class="headerlink" title="scss基础使用"></a>scss基础使用</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量:"></a>变量:</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$primary-color: #341234;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: $primary-color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">nav</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span> &#123;</span><br><span class="line">        left:<span class="number">0</span>;</span><br><span class="line">        <span class="attribute">right</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="混合属性"><a href="#混合属性" class="headerlink" title="混合属性:"></a>混合属性:</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span>  alert &#123;</span><br><span class="line">    <span class="selector-tag">color</span>: <span class="selector-id">#723899</span>;</span><br><span class="line">    background-color: $primary-color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@mixin</span>  alert-a &#123;</span><br><span class="line">    <span class="selector-tag">color</span>: <span class="selector-id">#723899</span>;</span><br><span class="line">    background-color: $primary-color;</span><br><span class="line">    <span class="selector-tag">a</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>:$primary-color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@mixin</span> alert-b($text-color,$background) &#123;</span><br><span class="line">    color: $text-color;</span><br><span class="line">    background-color: $background;</span><br><span class="line">    <span class="selector-tag">span</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>: <span class="built_in">darken</span>($text-color,<span class="number">10%</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span>&#123;</span><br><span class="line">    @include alert</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span>&#123;</span><br><span class="line">    @include alert-a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line">    @include alert-b(#786789,#000 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承"><a href="#继承" class="headerlink" title="继承:"></a>继承:</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.alert</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.alert-info</span> &#123;</span><br><span class="line">    @extend .alert;</span><br><span class="line">    <span class="selector-tag">background</span>: <span class="selector-id">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色:"></a>颜色:</h4><p>rgb(255,255,255)<br>rgba(255,255,255,1)<br>红绿蓝透明度</p><p>hsl(50,100%,50%)<br>hsla(50,100%,50%,0.5)<br>色相 饱和度 明度 透明度</p><p>adjust-hue调整颜色 background: adjust-hue(#fff, 123deg)</p><p>lighten darken函数 $lighten-color: lighten(#fff,30%) $darken-color: darken(#fff,20%)</p><p>saturate增加颜色的纯度 desaturate减少颜色的纯度<br>$saturate-color: saturate(#000,40%)<br>$desaturate-color: desaturate(#000,40%)</p><p>opacify添加透明度(让颜色更不透明)  transparentize减少透明度(让颜色更透明)</p><h4 id="interpolation插入值"><a href="#interpolation插入值" class="headerlink" title="interpolation插入值 :"></a>interpolation插入值 :</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$text: &#x27;info&#x27;;</span><br><span class="line">.alert-#&#123;$text&#125; &#123;</span><br><span class="line">    background:$primary-color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">results</span>:</span><br><span class="line"><span class="selector-class">.alert-info</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="if条件判断"><a href="#if条件判断" class="headerlink" title="if条件判断:"></a>if条件判断:</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@if</span> condition&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$conditon: 2 &gt; 1;</span><br><span class="line"><span class="selector-class">.rounded</span> &#123;</span><br><span class="line">    @if $conditon &#123;</span><br><span class="line">        <span class="selector-tag">-webkit-animation-name</span>: <span class="selector-tag">taro</span>;</span><br><span class="line">        <span class="selector-tag">-moz-animation-name</span>: <span class="selector-tag">taro</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">border-radius</span>: 5<span class="selector-tag">px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$color : &quot;dark&quot;;</span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    @if $color == dark &#123;</span><br><span class="line">        <span class="selector-tag">background-color</span>: <span class="selector-tag">darkblue</span>;</span><br><span class="line">    &#125; <span class="keyword">@else</span> if $color == lighten &#123;</span><br><span class="line">        <span class="selector-tag">background-color</span>: <span class="selector-tag">lightblue</span>;</span><br><span class="line">    &#125; <span class="keyword">@else</span> &#123;</span><br><span class="line">        <span class="selector-tag">background</span>: <span class="selector-tag">gray</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环:"></a>for循环:</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@for</span> $var from &lt;begain&gt; through &lt;end&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$columns: 4;</span><br><span class="line"><span class="keyword">@for</span> $i from <span class="number">1</span> through $columns &#123;</span><br><span class="line">    .col-#&#123;$i&#125; &#123;</span><br><span class="line">        width: 100% / $columns * $i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">results</span>:</span><br><span class="line"><span class="selector-class">.col-1</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">25%</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-2</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-3</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">75%</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-4</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@for</span> $i from <span class="number">1</span> to $columns &#123;</span><br><span class="line">    .col-#&#123;$i&#125; &#123;</span><br><span class="line">        width: 100% / $columns * $i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">results</span>:</span><br><span class="line"><span class="selector-class">.col-1</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">25%</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-2</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-3</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">75%</span>; &#125;</span><br></pre></td></tr></table></figure><h4 id="each语句"><a href="#each语句" class="headerlink" title="each语句"></a>each语句</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@each</span> $var in $lists &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$icons: success error warning;</span><br><span class="line"><span class="keyword">@each</span> $icon in $icons &#123;</span><br><span class="line">    .icon-#&#123;$icon&#125;&#123;</span><br><span class="line">        background-image: url(../image/icons/#&#123;$icon&#125;.png);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">results</span>:</span><br><span class="line"><span class="selector-class">.icon-success</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(../image/icons/success.png); &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.icon-error</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(../image/icons/error.png); &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.icon-warning</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(../image/icons/warning.png); &#125;</span><br></pre></td></tr></table></figure><h4 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@while</span> condition &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$i : 6;</span><br><span class="line"><span class="keyword">@while</span> $i &gt; <span class="number">0</span> &#123;</span><br><span class="line">    .item-#&#123;$i&#125; &#123;</span><br><span class="line">        width: 5px * $i;</span><br><span class="line">    &#125;</span><br><span class="line">    $i : $i - 2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">results</span>:</span><br><span class="line"><span class="selector-class">.item-6</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">30</span>rpx; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item-4</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20</span>rpx; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item-2</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">10</span>rpx; &#125;</span><br></pre></td></tr></table></figure><h4 id="用户自定义函数"><a href="#用户自定义函数" class="headerlink" title="用户自定义函数:"></a>用户自定义函数:</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$colors: (light: #fff, dark: #000);</span><br><span class="line"><span class="keyword">@function</span> color($key)&#123;</span><br><span class="line">    // <span class="keyword">@if</span> <span class="keyword">not</span> map-has-key($colors, $key)&#123;</span><br><span class="line">    //     <span class="keyword">@warn</span> <span class="string">&quot;在colors中没有这个属性&quot;</span></span><br><span class="line">    // &#125;</span><br><span class="line">    @return map-get($colors,$key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.test</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">color</span>(gray);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">results</span>:</span><br><span class="line">    <span class="selector-class">.test</span> &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="warn-警告信息-error错误信息"><a href="#warn-警告信息-error错误信息" class="headerlink" title="@warn 警告信息  @error错误信息"></a>@warn 警告信息  @error错误信息</h4><h4 id="sass编译输入四种格式"><a href="#sass编译输入四种格式" class="headerlink" title="sass编译输入四种格式:"></a>sass编译输入四种格式:</h4><p>1.nested,嵌套<br>2.compact,紧凑<br>3.expander,扩展<br>4.compressed,压缩</p><p>.sass缩进式写法  .scss嵌套写法</p><h4 id="partials与-import"><a href="#partials与-import" class="headerlink" title="partials与@import:"></a>partials与@import:</h4><p>文件名以_下划线开头的是partials,不会编译 _base.scss<br>可以通过@import “base”;将文件引入</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongodb-MongoDB的安装使用</title>
      <link href="/ZJY.github.io/2021/01/19/mongodb-MongoDB%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
      <url>/ZJY.github.io/2021/01/19/mongodb-MongoDB%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>MongoDB非关系数据库、键值对数据、文档型数据库、快速开发<br>存储的是各种各样的json</p><p>1.安装MongoDB（官网下载，版本号偶数稳定版，奇数开发版）</p><p>2.配置环境变量</p><p>path中添加安装路径的bin文件夹 例E:\MongoDB\bin</p><p>3.在c盘根目录</p><p>存储数据的目录：创建data目录-》创建db目录</p><p>4.打开cmd命令窗口</p><ul><li>输入mongod 启动mongdb服务器 等待连接</li><li>32位电脑第一次启动时：mongod –storageEngine==mmapv1</li><li>可以通过mongod –dbpath url(启动指定数据库路径)</li><li>默认端口27017</li><li>指定端口号mongod –dbpath url(启动指定数据库路径c:\data\db) –port 1234</li></ul><p>5.再打开cmd窗口</p><p>输入mongo  连接</p><p>6.数据库</p><ul><li>数据库的服务器（保存数据） mongod 启动服务器</li><li>数据库的客户端（操作数据） mongo  启动客户端</li></ul><p>7.将MongoDB设置为系统服务，自动后台启动</p><p>c盘根目录data下创建log日志文件<br>在安装路径bin上一级目录创建配置文件mongod.cfg</p><pre><code>systemLog:    destination:file    path: c:\data\log\mongod.logstorage:    dbPath: c:\data\db</code></pre><p>以管理员身份打开命令窗口<br>执行如下命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc.exe create MongoDB binPath=<span class="string">&quot;\&quot;E:\MongoDB\bin\mongod.exe\&quot; --service --config=\&quot;E:\MongoDB\mongod.cfg\&quot;&quot;</span> DisplayName=<span class="string">&quot;MongoDB&quot;</span> start=<span class="string">&quot;auto&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>target和currentTarget区别</title>
      <link href="/ZJY.github.io/2021/01/19/javascript-target%E5%92%8CcurrentTarget%E5%8C%BA%E5%88%AB/"/>
      <url>/ZJY.github.io/2021/01/19/javascript-target%E5%92%8CcurrentTarget%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="target和currentTarget区别"><a href="#target和currentTarget区别" class="headerlink" title="target和currentTarget区别"></a>target和currentTarget区别</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;ulT&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item3&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item4&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item5&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时target和currentTarget是一样的 都是点击的li标签</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lis = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>;i&lt;lis.length;i++)&#123;</span><br><span class="line">    lis[i].onclick= <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e.target);  <span class="comment">//&lt;li class=&quot;item1&quot;&gt;1&lt;/li&gt;</span></span><br><span class="line">        <span class="built_in">console</span>.log(e.currentTarget); <span class="comment">//&lt;li class=&quot;item1&quot;&gt;1&lt;/li&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时是不一样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line">ul.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.target);  <span class="comment">//当前的li</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.currentTarget); <span class="comment">//元素的ul</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECMAScript和JavaScript的区别以及小程序区别</title>
      <link href="/ZJY.github.io/2021/01/19/javascript-ECMAScript%E5%92%8CJavaScript%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8C%BA%E5%88%AB/"/>
      <url>/ZJY.github.io/2021/01/19/javascript-ECMAScript%E5%92%8CJavaScript%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h3><p>ECMAScript是一种由Ecma国际通过ECMA-262标准化的脚本程序设计语言， JavaScript 是 ECMAScript 的一种实现.</p><p>小程序中的 JavaScript同浏览器中的 JavaScript 以及 NodeJS 中的 JavaScript 是不相同的</p><h3 id="ECMA-262-规定了-ECMAScript-语言的几个重要组成部分："><a href="#ECMA-262-规定了-ECMAScript-语言的几个重要组成部分：" class="headerlink" title="ECMA-262 规定了 ECMAScript 语言的几个重要组成部分："></a>ECMA-262 规定了 ECMAScript 语言的几个重要组成部分：</h3><ul><li>语法</li><li>类型</li><li>语句</li><li>关键字</li><li>操作符</li><li>对象</li></ul><h3 id="浏览器中JavaScript-构成如下-ECMAScript-DOM（文档对象模型）-BOM（浏览器对象模型）"><a href="#浏览器中JavaScript-构成如下-ECMAScript-DOM（文档对象模型）-BOM（浏览器对象模型）" class="headerlink" title="浏览器中JavaScript 构成如下: ECMAScript + DOM（文档对象模型） + BOM（浏览器对象模型）"></a>浏览器中JavaScript 构成如下: ECMAScript + DOM（文档对象模型） + BOM（浏览器对象模型）</h3><h3 id="NodeJS中JavaScript-构成如下-ECMAScript-NPM-包管理系统-Native"><a href="#NodeJS中JavaScript-构成如下-ECMAScript-NPM-包管理系统-Native" class="headerlink" title="NodeJS中JavaScript 构成如下: ECMAScript + NPM (包管理系统) + Native"></a>NodeJS中JavaScript 构成如下: ECMAScript + NPM (包管理系统) + Native</h3><h3 id="小程序中-JavaScript-构成如下-ECMAScript-小程序框架-小程序-API"><a href="#小程序中-JavaScript-构成如下-ECMAScript-小程序框架-小程序-API" class="headerlink" title="小程序中 JavaScript 构成如下: ECMAScript + 小程序框架 + 小程序 API"></a>小程序中 JavaScript 构成如下: ECMAScript + 小程序框架 + 小程序 API</h3><p>同浏览器中的JavaScript 相比没有 BOM 以及 DOM 对象，所以类似 JQuery、Zepto这种浏览器类库是无法在小程序中运行起来的，同样的缺少 Native 模块和NPM包管理的机制，小程序中无法加载原生库，也无法直接使用大部分的 NPM 包。</p><h3 id="小程序的执行环境"><a href="#小程序的执行环境" class="headerlink" title="小程序的执行环境"></a>小程序的执行环境</h3><ul><li>小程序目前可以运行在三大平台：</li><li>iOS平台，包括iOS9、iOS10、iOS11</li><li>Android平台</li><li>小程序IDE</li></ul><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>浏览器中，所有 JavaScript 是在运行在同一个作用域下的，定义的参数或者方法可以被后续加载的脚本访问或者改写。同浏览器不同，小程序中可以将任何一个JavaScript 文件作为一个模块，通过module.exports 或者 exports 对外暴露接口。</p><h3 id="脚本的执行顺序"><a href="#脚本的执行顺序" class="headerlink" title="脚本的执行顺序"></a>脚本的执行顺序</h3><p>浏览器中，脚本严格按照加载的顺序执行;而在小程序中的脚本执行顺序有所不同。小程序的执行的入口文件是 app.js 。并且会根据其中 require 的模块顺序决定文件的运行顺序.当 app.js 执行结束后，小程序会按照开发者在 app.json 中定义的 pages 的顺序，逐一执行</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>同浏览器中运行的脚本文件有所不同，小程序的脚本的作用域同 NodeJS 更为相似。在文件中声明的变量和函数只在该文件中有效，不同的文件中可以声明相同名字的变量和函数，不会互相影响</p><h3 id="小程序通信模型"><a href="#小程序通信模型" class="headerlink" title="小程序通信模型"></a>小程序通信模型</h3><p>小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了WebView 进行渲染；逻辑层采用JsCore线程运行JS脚本。一个小程序存在多个界面，所以渲染层存在多个WebView线程，这两个线程的通信会经由微信客户端（下文中也会采用Native来代指微信客户端）做中转，逻辑层发送网络请求也经由Native转发</p><h3 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h3><p>WXML可以先转成JS对象，然后再渲染出真正的Dom树</p><h3 id="双线程下的界面渲染"><a href="#双线程下的界面渲染" class="headerlink" title="双线程下的界面渲染"></a>双线程下的界面渲染</h3><p>小程序的逻辑层和渲染层是分开的两个线程。在渲染层，宿主环境会把WXML转化成对应的JS对象，在逻辑层发生数据变更的时候，我们需要通过宿主环境提供的setData方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的Dom树上，渲染出正确的UI界面</p><h3 id="所有页面的脚本逻辑都跑在同一个JsCore线程，页面使用setTimeout或者setInterval的定时器，然后跳转到其他页面时，这些定时器并没有被清除，需要开发者自己在页面离开的时候进行清理"><a href="#所有页面的脚本逻辑都跑在同一个JsCore线程，页面使用setTimeout或者setInterval的定时器，然后跳转到其他页面时，这些定时器并没有被清除，需要开发者自己在页面离开的时候进行清理" class="headerlink" title="所有页面的脚本逻辑都跑在同一个JsCore线程，页面使用setTimeout或者setInterval的定时器，然后跳转到其他页面时，这些定时器并没有被清除，需要开发者自己在页面离开的时候进行清理"></a>所有页面的脚本逻辑都跑在同一个JsCore线程，页面使用setTimeout或者setInterval的定时器，然后跳转到其他页面时，这些定时器并没有被清除，需要开发者自己在页面离开的时候进行清理</h3><h3 id="Page构造器的参数"><a href="#Page构造器的参数" class="headerlink" title="Page构造器的参数"></a>Page构造器的参数</h3><ul><li>data:   Object   页面的初始数据</li><li>onLoad: Function 生命周期函数–监听页面加载，触发时机早于onShow和onReady 在页面没被销毁前只会触发1次</li><li>onShow: Function 生命周期函数–监听页面显示，触发事件早于onReady 一般从别的页面返回到当前页面时，当前页的+ onShow方法都会被调用</li><li>onReady:Function 生命周期函数–监听页面初次渲染完成  在页面没被销毁前只会触发1次</li><li>onHide: Function 生命周期函数–监听页面隐藏</li><li>onUnload:Function 生命周期函数–监听页面卸载</li><li>onPullDownRefresh:Function 页面相关事件处理函数–监听用户下拉动作</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gulp-gulp基础使用</title>
      <link href="/ZJY.github.io/2021/01/19/gulp-gulp%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
      <url>/ZJY.github.io/2021/01/19/gulp-gulp%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>1.前置条件：测试node /npm /npx是否安装<br>2.安装gulp命令行工具</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --<span class="built_in">global</span> gulp-cli</span><br></pre></td></tr></table></figure><p>3.创建项目目录</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npx mkdirp my-project</span><br><span class="line">cd my-project</span><br></pre></td></tr></table></figure><p>4.在项目目录下创建package.json文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><p>5.安装gulp,作为开发时依赖项</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev gulp</span><br></pre></td></tr></table></figure><p>6.检查gulp版本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp --version</span><br></pre></td></tr></table></figure><p>7.创建gulpfile文件</p><p>8.测试</p><p>在项目根目录下执行 gulp 命令：gulp</p><p>9.创建任务（task）:</p><p>每个 gulp 任务（task）都是一个异步的 JavaScript 函数，此函数是一个可以接收 callback 作为参数的函数，或者是一个返回 stream、promise、event emitter、child process 或 observable (后面会详细讲解) 类型值的函数</p><p>10.导出任务：</p><p>任务可以是公开或私有的：<br>公开任务： 从gulpfile中被导出，可以通过gulp命令直接调用<br>私有任务：被设计在内部使用，通常作为series（）或parallel()组合的组成部分。<br>一个私有（private）类型的任务（task）在外观和行为上和其他任务（task）是一样的，但是不能够被用户直接调用。如需将一个任务（task）注册为公开（public）类型的，只需从 gulpfile 中导出（export）即可</p><p>11.组合任务</p><p>两个组合方法： series()和parallel(),允许多个独立的任务组合为一个更大的操作。这两个方法都可以接受任意数目的任务函数和已组合的操作。<br>series()和parallel()可以互相嵌套至任意深度。<br>如果需要让任务按顺序执行，请使用series()方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; series &#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transpile</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bundle</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exports</span>.build = series(transpile, bundle);</span><br></pre></td></tr></table></figure><p>对于希望以最大并发来允许的任务，可以使用parallel()方法将他们组合：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cosnt &#123; parallel &#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">javascript</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line">functin <span class="function"><span class="title">css</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exports</span>.build = parallel(javascript, css);</span><br></pre></td></tr></table></figure><p>当series()和parallel()被调用时，任务会被立即组合在一起，这就允许在组合中进行改变，而不需要在单个任务中进行条件判断：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; series &#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minify</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">overload</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transpile</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(process.env.NODE_ENV == <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">exports</span>.build = series(minify, overload);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">exports</span>.build = series(transpile,overload);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>series()和parallel()可以被嵌套任意深度：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; series, parallel &#125; = requier(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exports</span>.build = series(</span><br><span class="line">    a,</span><br><span class="line">    parallel(b</span><br><span class="line">    ,</span><br><span class="line">    series(c,d)</span><br><span class="line">    ),</span><br><span class="line">    e</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果在两个不同任务间调用同一个任务将被执行两次，并产生不可预期结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; series, parallel&#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> clean = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> javascript = series(clean,<span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> css = series(clean, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">exports</span>.build = parallel(javascript,css)</span><br></pre></td></tr></table></figure><p>重构为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; series, parallel &#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clean</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">css</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">javascript</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exports</span>.build = series(clean, parallel(css, javascript));</span><br></pre></td></tr></table></figure><p>12.异步执行：</p><p>异步执行方式：<br>1.返回stream</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; src, dest&#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">streanTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&quot;*.js&quot;</span>)</span><br><span class="line">    .pipe(dest(<span class="string">&#x27;output&#x27;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.返回promise:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseTask</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.返回event emitter</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; EventEmitter &#125; = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eventEmitterTask</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> emitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123; emitter.emit(<span class="string">&#x27;finish&#x27;</span>)&#125;,<span class="number">250</span>);</span><br><span class="line">    <span class="keyword">return</span> emitter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.返回 child process</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; exec &#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">childProcessTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exec(<span class="string">&#x27;date&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.返回observable</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Observale&#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observaleTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.使用callback<br>如果任务不返回任何内容，则必须用callback来指示任务已完成</p><p>7.使用async/await</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncAwaitTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; version &#125; = fs.readFileSync(<span class="string">&#x27;package.json&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(version);</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;some result&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>13.处理文件</p><p>gulp暴露了src()和dest()方法用于处理计算机上存放的文件<br>src()接受glob参数，并从文件系统中读取文件然后生成一个node流<br>dest()接收一个输入目录作为参数，并且会产生一个node流作为终止流，当他接受到管道pipe传输的文件时，他会将文件内容及属性写到目录中</p><p>14.glob</p><p> glob 是由普通字符和/或通配字符组成的字符串，用于匹配文件路径。可以利用一个或多个 glob 在文件系统中定位文件</p><p> src() 方法接受一个 glob 字符串或由多个 glob 字符串组成的数组作为参数，用于确定哪些文件需要被操作。glob 或 glob 数组必须至少匹配到一个匹配项，否则 src() 将报错</p><ul><li>分隔符： /</li><li>特殊符号： *<br>在一个字符串片段中匹配任意数量的字符，包括零个匹配。对于匹配单级目录下的文件很有用： ‘*.js’</li><li>特殊字符： ** (两个星号)<br>在多个字符串片段中匹配任意数量的字符，包括零个匹配。 对于匹配嵌套目录下的文件很有用 ‘scripts/*<em>/</em>.js’</li><li>特殊字符： ! (取反)<br>由于 glob 匹配时是按照每个 glob 在数组中的位置依次进行匹配操作的，所以 glob 数组中的取反（negative）glob 必须跟在一个非取反（non-negative）的 glob 后面<pre><code>  [&#39;script/**/*.js&#39;, &#39;!scripts/vendor/&#39;]</code></pre></li><li>匹配重叠：<br>两个或多个 glob 故意或无意匹配了相同的文件就被认为是匹配重叠（overlapping）了。如果在同一个 src() 中使用了会产生匹配重叠的 glob，gulp 将尽力去除重叠部分，但是在多个 src() 调用时产生的匹配重叠是不会被去重的</li></ul><p>15.使用插件</p><p>Gulp 插件实质上是 Node 转换流（Transform Streams），它封装了通过管道（pipeline）转换文件的常见功能，通常是使用 .pipe() 方法并放在 src() 和 dest() 之间。他们可以更改经过流（stream）的每个文件的文件名、元数据或文件内容</p><p>16.文件监控</p><p>ulp api 中的 watch() 方法利用文件系统的监控程序（file system watcher）将 globs 与 任务（task） 进行关联。它对匹配 glob 的文件进行监控，如果有文件被修改了就执行关联的任务（task）。如果被执行的任务（task）没有触发 异步完成 信号，它将永远不会再次运行了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">css</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line">watch(<span class="string">&#x27;src/*.css&#x27;</span>,css);</span><br></pre></td></tr></table></figure><p>与文件监控程序关联的任务不能时同步任务<br>默认情况下，只要创建、更改或删除文件，文件监控程序就会执行关联的任务（task）。 如果你需要使用不同的事件，你可以在调用 watch() 方法时通过 events 参数进行指定。可用的事件有 ‘add’、’addDir’、’change’、’unlink’、’unlinkDir’、’ready’、’error’。此外，还有一个 ‘all’ 事件，它表示除 ‘ready’ 和 ‘error’ 之外的所有事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; watch &#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有事件都将被监控</span></span><br><span class="line">watch(<span class="string">&#x27;src/*.js&#x27;</span>, &#123; <span class="attr">events</span>: <span class="string">&#x27;all&#x27;</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>初次执行：<br>调用watch之后，关联的任务是不会被立即执行，要等到第一次文件修改之后才执行<br>如果需要在第一次文件修改之前执行，也就是调用watch之后立即执行，设置参数： ignoreInitial: false</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch(<span class="string">&#x27;src/*.js&#x27;</span>, &#123; <span class="attr">ignoreInitial</span>: <span class="literal">false</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>队列： queue: false//禁止队列<br>延迟： delay: Nubmer //文件更改之后延迟多久被执行</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> gulp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6-模块化</title>
      <link href="/ZJY.github.io/2021/01/19/es6-%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>/ZJY.github.io/2021/01/19/es6-%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="es5中，用module-exports-和-exports导出模块，用require引入模块"><a href="#es5中，用module-exports-和-exports导出模块，用require引入模块" class="headerlink" title="es5中，用module.exports 和 exports导出模块，用require引入模块"></a>es5中，用module.exports 和 exports导出模块，用require引入模块</h3><h3 id="es6中，新增export-和-export-default-导出模块，import引入模块"><a href="#es6中，新增export-和-export-default-导出模块，import引入模块" class="headerlink" title="es6中，新增export 和 export default 导出模块，import引入模块"></a>es6中，新增export 和 export default 导出模块，import引入模块</h3><ol><li>module.exports 和 exports 的区别：</li></ol><p>module.exports 和 exports 导出的对象，可以在另一个文件中通过require引用</p><p>module 和 exports 是node.js给每个js文件内置的两个对象，初始值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">exports</span>):  &#123;&#125;  空对象</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>): &#123;..., <span class="attr">exports</span>: &#123;&#125; &#125;  ...代表其他属性如：id,filename...</span><br></pre></td></tr></table></figure><p>一开始这两个对象都是空对象{}，实际上这两个对象指向同一块内存<br>exports.age = 18 和 module.exports.age = 18 两者是等价的</p><p>但是require引入的本质是module.exports，所有当module.exports 和exports<br>指向的不是同一块内存时，exports的内容就会失效：例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a.js:</span><br><span class="line"><span class="built_in">exports</span> = &#123;<span class="attr">name</span>:<span class="string">&#x27;lily&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;<span class="attr">name</span>:<span class="string">&#x27;lucy&#x27;</span> &#125;</span><br><span class="line">b.js:</span><br><span class="line"><span class="keyword">let</span> test = <span class="built_in">require</span>(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">consle.log(test)  <span class="comment">// &#123;name:&#x27;lucy&#x27;&#125;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>export default 和 export 的区别：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> People = &#123; <span class="attr">name</span>: <span class="string">&#x27;lucy&#x27;</span> ,<span class="attr">age</span>: <span class="number">18</span> &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> = People</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>):</span><br><span class="line">&#123;<span class="attr">exports</span>:&#123;<span class="attr">default</span>:&#123;<span class="attr">name</span>:<span class="string">&#x27;lucy&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;&#125;&#125;</span><br><span class="line"><span class="keyword">import</span> Peole <span class="keyword">from</span> <span class="string">&#x27;.a&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">name</span>:<span class="string">&#x27;aaa&#x27;</span>,age,<span class="number">12</span>&#125;</span><br><span class="line"><span class="keyword">const</span> b = &#123; <span class="attr">name</span>:<span class="string">&#x27;bbb&#x27;</span>, <span class="attr">age</span>:<span class="number">23</span>&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; a, b&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>):</span><br><span class="line">&#123;<span class="attr">exports</span>: &#123;<span class="attr">a</span>:&#123;<span class="attr">name</span>:<span class="string">&#x27;aaa&#x27;</span>,<span class="attr">age</span>:<span class="number">12</span>&#125;,<span class="attr">b</span>:&#123;<span class="attr">name</span>:<span class="string">&#x27;bbb&#x27;</span>,<span class="attr">age</span>:<span class="number">23</span>&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>导入： import {a,b} from ‘./a’</p><p>导出时， export 相当于将对象添加到module 的 exports中，<br>export default 相当于将对象添加到module 的 exports ，对象key 为default</p><p>导入时：<br>不带{}的导入，本质上就是导入exports的default属性，若default属性不存在，<br>则导入exports对象<br>带{}的导入，按key值导入exports中对应的属性值</p><p>一般来说，module.exports和exports与require对应。也就是用module.exports和exports<br>导出的模块，则用require导入。（不是绝对，如果代码支持es6，也可以用import引入）。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dart-dart基础</title>
      <link href="/ZJY.github.io/2021/01/19/dart-dart%E5%9F%BA%E7%A1%80/"/>
      <url>/ZJY.github.io/2021/01/19/dart-dart%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="1-安装dart-sdk"><a href="#1-安装dart-sdk" class="headerlink" title="1.安装dart sdk"></a>1.安装dart sdk</h3><p><a href="https://dart.dev/get-dart">https://dart.dev/get-dart</a><br>终端输入dart –version 测试是否安装成功</p><h3 id="2-配置vscode支持dart语法提示："><a href="#2-配置vscode支持dart语法提示：" class="headerlink" title="2.配置vscode支持dart语法提示："></a>2.配置vscode支持dart语法提示：</h3><p>1.安装插件dart<br>2.安装插件code runner  可以运行文件</p><h3 id="3-vscode运行dart文件中文乱码："><a href="#3-vscode运行dart文件中文乱码：" class="headerlink" title="3.vscode运行dart文件中文乱码："></a>3.vscode运行dart文件中文乱码：</h3><p>1.在settings.json添加：”code-runner.runInTerminal”: true,<br>2.重启vscode</p><h3 id="4-入口方法"><a href="#4-入口方法" class="headerlink" title="4.入口方法"></a>4.入口方法</h3><p>main(){};<br>void main(){};//没有返回值</p><h3 id="5-注释"><a href="#5-注释" class="headerlink" title="5.注释"></a>5.注释</h3><p>//注释<br>///注释<br>/<em>注释</em>/</p><h3 id="6-声明变量："><a href="#6-声明变量：" class="headerlink" title="6.声明变量："></a>6.声明变量：</h3><p>1.通过var声明： var str = “aaa”; //dart强类型校验，可以不预先声明变量类型，自行判断类型<br>2.通过类型声明  String str = “aaa”</p><p>变量命名规则：<br>        1.必须由数字/字母/下划线和$组成<br>        2.不能以数字开头<br>        3.不能是保留字和关键字<br>        4.区分大小写</p><h3 id="7-常量：-const-和-final"><a href="#7-常量：-const-和-final" class="headerlink" title="7.常量： const 和 final"></a>7.常量： const 和 final</h3><p>1.const 和finnal 赋值都不可以修改<br>2.区别： final可以开始不赋值，只能赋值一次，final不仅有const的编译时常量的特性，最重要的是它是编译时赋值<br>        例如：<br>        final date = new DateTime.now(); //正常 编译时赋值，只能赋值一次<br>        const date = new DateTime.now(); //报错 定义时赋值</p><h3 id="8-dart-数据类型："><a href="#8-dart-数据类型：" class="headerlink" title="8.dart 数据类型："></a>8.dart 数据类型：</h3><p>常用数据类型：</p><pre><code>    Numbers(数值)：int double    Strings(字符串)： String    Booleans(布尔值): bool    List(数组): 列表对象    Maps(字典)： Map是一个键值对相关的对象</code></pre><p>1.字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> str = <span class="string">&quot;falds&quot;</span></span><br><span class="line"><span class="built_in">String</span> str = <span class="string">&quot;&quot;</span><span class="string">&quot;flasjd</span></span><br><span class="line"><span class="string">flad</span></span><br><span class="line"><span class="string">d;fja&quot;</span><span class="string">&quot;&quot;</span> <span class="comment">//三个单引号或者三个双引号字符串可换行</span></span><br><span class="line"><span class="comment">// &lt;!-- 字符串拼接： --&gt;</span></span><br><span class="line">    print(<span class="string">&quot;$str $str&quot;</span>);</span><br><span class="line">    print(str +<span class="string">&quot; &quot;</span>+ str);</span><br></pre></td></tr></table></figure><p>2.数值类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = <span class="number">12</span>; <span class="comment">//只可以是整型</span></span><br><span class="line">double = <span class="number">12.23</span>  <span class="comment">//既可以是整型也可以是浮点型</span></span><br></pre></td></tr></table></figure><p>3.布尔类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool flag = <span class="literal">true</span>/<span class="literal">false</span> ; <span class="comment">//布尔类型的值只能是true/false</span></span><br><span class="line">条件判断不会对变量进行类型转换： <span class="number">123</span> != <span class="string">&#x27;123&#x27;</span></span><br></pre></td></tr></table></figure><p>4.数组类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> List();</span><br><span class="line">arr2.add(<span class="string">&quot;a&quot;</span>)</span><br></pre></td></tr></table></figure><p>3.指定数组元素类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr3 = <span class="keyword">new</span> List&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">arr3.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">arr3.add(<span class="number">1</span>); <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><p>5.Maps</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:<span class="string">&quot;test&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问： person[“name”]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">p[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;test&quot;</span></span><br></pre></td></tr></table></figure><p>6.is关键词判断数据类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;ad&#x27;</span>;</span><br><span class="line">print(str is <span class="built_in">String</span>)</span><br></pre></td></tr></table></figure><h3 id="9-运算符"><a href="#9-运算符" class="headerlink" title="9.运算符"></a>9.运算符</h3><ul><li><p>算术运算符</p><ol><li>+</li><li>-</li><li>*</li><li>/</li><li>% 取余</li><li>~/ 取整</li></ol></li><li><p>关系运算符：</p><ol><li>==</li><li>!=</li><li>&lt;</li><li><code>&gt;</code></li><li>&lt;=</li><li><code> &gt;=</code></li></ol></li><li><p>逻辑运算符：<br>  !<br>  &amp;&amp;<br>  ||</p></li><li><p>赋值运算符：<br>  <code>=</code><br>  <code>??=</code>  // int b; b??=23 如果b等于空的话，把23赋值给b</p></li><li><p>复合赋值运算符：<br>  +=<br>  -=<br>  *-<br>  /=<br>  ~/=</p></li><li><p>条件表达式：<br>  if… else<br>  if… else if<br>  swtich… case</p><p>  三目运算符 ? :<br>  ??运算符 b= a ?? 10 //a不为空时b等于a，a为空时b等于10</p><p>  b=a++ 赋值运算中： ++写在后面 先赋值后运算 ++a 写在前面先运算后赋值</p></li></ul><h3 id="10-类型转换："><a href="#10-类型转换：" class="headerlink" title="10.类型转换："></a>10.类型转换：</h3><ul><li>int.parse</li><li>double.parge</li><li>toString</li><li>str.isEmpty</li><li>num.isNaN</li></ul><h3 id="11-List属性："><a href="#11-List属性：" class="headerlink" title="11.List属性："></a>11.List属性：</h3><ul><li>length</li><li>isEmpty</li><li>isNotEmpty</li><li>reversed 翻转列表 [1,2,3].reversed //(3,2,1) [1,2,3].reversed.toList() //[3,2,1]</li></ul><h3 id="12-List方法："><a href="#12-List方法：" class="headerlink" title="12.List方法："></a>12.List方法：</h3><ul><li>add 数组添加 add(1)</li><li>addAll([1,2]) //拼接数组</li><li>indexOf 返回索引值</li><li>remove 移除值，参数为值</li><li>removeAt 参数为索引值</li><li>fillRange int start,int end,修改后的值</li><li>insert(int index,value)指定位置插入值</li><li>insertAll(index,interable)  insertAll(1,[1,2]) </li><li>join(分割符) 以分隔符拼接转换成字符串</li><li>split(分隔符) 将string以分隔符切割成数组</li><li>toList() 将其他类型对象转换为数组</li></ul><h3 id="13-Set主要功能是数组去重"><a href="#13-Set主要功能是数组去重" class="headerlink" title="13.Set主要功能是数组去重"></a>13.Set主要功能是数组去重</h3><p>set是不能重复且没有顺序的对象</p><h3 id="14-Maps-映射"><a href="#14-Maps-映射" class="headerlink" title="14.Maps 映射"></a>14.Maps 映射</h3><ul><li>key   var person={“a”:1,”b”:2} person.keys.toList()</li><li>value</li><li>isEmpty</li><li>isNotEmpty</li><li>addAll() 添加多个</li><li>remove(key)</li><li>containsValue(value) 是否存在某个值</li></ul><h3 id="15-循环："><a href="#15-循环：" class="headerlink" title="15.循环："></a>15.循环：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">forEach</span><br><span class="line">map  用于修改数据 <span class="keyword">var</span> newList = list.map((value)&#123; <span class="keyword">return</span> value*<span class="number">2</span>&#125;)</span><br><span class="line">where  <span class="keyword">var</span> newList = list.where((value)&#123; <span class="keyword">return</span> value &gt; <span class="number">5</span>&#125;) 返回符合条件的数组</span><br><span class="line">any  <span class="keyword">var</span> newList = list.any((value)&#123; <span class="keyword">return</span> value &gt; <span class="number">5</span>&#125;) 有一个满足条件返回<span class="literal">true</span></span><br><span class="line">some ar newList = list.some((value)&#123; <span class="keyword">return</span> value &gt; <span class="number">5</span>&#125;) 满足所有条件返回<span class="literal">true</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> dart </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css-grid布局</title>
      <link href="/ZJY.github.io/2021/01/19/css-grid%E5%B8%83%E5%B1%80/"/>
      <url>/ZJY.github.io/2021/01/19/css-grid%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<p>Flex是轴线布局，只能指定“项目” 针对轴线的位置，可以看作是一维布局。</p><p>Grid布局则是将容器分成行和列，产生单元格，然后指定项目所在单元格，可以看作是二维布局</p><h3 id="1-容器和项目："><a href="#1-容器和项目：" class="headerlink" title="1.容器和项目："></a>1.容器和项目：</h3><p>采用网格布局的区域，称为“容器” container， 容器内采用网格定位的子元素，称为“项目” item</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最外层的div元素就是容器， 内层的三个div 是项目<br>注意： 项目只能是容器的顶层子元素，不包含项目的子元素，grid布局只对项目生效</p><h3 id="2-行和列"><a href="#2-行和列" class="headerlink" title="2.行和列"></a>2.行和列</h3><p>容器里水平区域称为”行”row,垂直区域称为“列”column</p><h3 id="3-单元格"><a href="#3-单元格" class="headerlink" title="3.单元格"></a>3.单元格</h3><p>行和列的交叉区域，称为“单元格”cell<br>正常情况下，N行M列，会产生N*M个单元格</p><h3 id="4-网格线"><a href="#4-网格线" class="headerlink" title="4.网格线"></a>4.网格线</h3><p>划分网格的线，称为”网格线”（grid line）。水平网格线划分出行，垂直网格线划分出列<br>正常情况下，n行有n + 1根水平网格线，m列有m + 1根垂直网格线</p><p>Grid 布局的属性分成两类。一类定义在容器上面，称为容器属性；另一类定义在项目上面，称为项目属性。这部分先介绍容器属性</p><h3 id="5-容器属性"><a href="#5-容器属性" class="headerlink" title="5.容器属性"></a>5.容器属性</h3><h4 id="5-1-display属性"><a href="#5-1-display属性" class="headerlink" title="5.1 display属性"></a>5.1 display属性</h4><p>display: grid指定一个容器采用网格布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，容器元素都是块级元素，但也可以设成行内元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。</p><h4 id="5-2-grid-template-rows属性和grid-template-columns属性"><a href="#5-2-grid-template-rows属性和grid-template-columns属性" class="headerlink" title="5.2 grid-template-rows属性和grid-template-columns属性"></a>5.2 grid-template-rows属性和grid-template-columns属性</h4><p>容器指定了网格布局以后，接着就要划分行和列。grid-template-columns属性定义每一列的列宽，grid-template-rows属性定义每一行的行高。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了使用绝对单位,还可使用百分比：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: 33.33% 33.33% 33.33%;</span><br><span class="line"><span class="selector-tag">grid-template-rows</span>: 33.33% 33.33% 33.33%;</span><br></pre></td></tr></table></figure><p>1.repeat() 接受两个参数，第一个参数是重复的次数,第二个参数是所要重复的值:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: <span class="selector-tag">repeat</span>(3, 33.33%)</span><br></pre></td></tr></table></figure><p>重复某种模式：定义了6列，第一列和第四列的宽度为100px，第二列和第五列为20px，第三列和第六列为80px</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: <span class="selector-tag">repeat</span>(2, 100<span class="selector-tag">px</span> 20<span class="selector-tag">px</span> 80<span class="selector-tag">px</span>)</span><br></pre></td></tr></table></figure><p>2.auto-fill关键字<br>    有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用auto-fill关键字表示自动填充</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: <span class="selector-tag">repeat</span>(<span class="selector-tag">auto-fill</span>, 100<span class="selector-tag">px</span>)</span><br></pre></td></tr></table></figure><p>表示每列宽度100px，然后自动填充，直到容器不能放置更多的列</p><p>3.fr关键字</p><p>为了方便表示比例关系，网格布局提供了fr关键字（fraction 的缩写，意为”片段”）。如果两列的宽度分别为1fr和2fr，就表示后者是前者的两倍</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: 1<span class="selector-tag">fr</span> 1<span class="selector-tag">fr</span></span><br></pre></td></tr></table></figure><p>表示两个相同宽度的列。<br>fr可以与绝对长度的单位结合使用，这时会非常方便</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: 150<span class="selector-tag">px</span> 1<span class="selector-tag">fr</span> 2<span class="selector-tag">fr</span></span><br></pre></td></tr></table></figure><p>表示第一列宽度未150像素，第二列宽度是第三列的一半</p><p>4.minmax()函数产生一个长度范围，表示长度就在这个范围内，接收两个参数，分别为最小值和最大值</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: 1<span class="selector-tag">fr</span> 1<span class="selector-tag">fr</span> <span class="selector-tag">minmax</span>(100<span class="selector-tag">px</span>, 1<span class="selector-tag">fr</span>);</span><br></pre></td></tr></table></figure><p>5.auto关键字表示由浏览器自己决定长度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: 100<span class="selector-tag">px</span> <span class="selector-tag">auto</span> 100<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure><p>第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了min-width，且这个值大于最大宽度</p><p>6.网格线的名称</p><p>grid-template-columns属性和grid-template-rows属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: <span class="selector-attr">[c1]</span> 100<span class="selector-tag">px</span> <span class="selector-attr">[c2]</span> 100<span class="selector-tag">px</span> <span class="selector-attr">[c3]</span> <span class="selector-tag">auto</span> <span class="selector-attr">[c4]</span>;</span><br><span class="line"><span class="selector-tag">grid-template-rows</span>: <span class="selector-attr">[r1]</span> 100<span class="selector-tag">px</span> <span class="selector-attr">[r2]</span> 100<span class="selector-tag">px</span> <span class="selector-attr">[r3]</span> <span class="selector-tag">auto</span> <span class="selector-attr">[r4]</span></span><br></pre></td></tr></table></figure><p>7.布局实例</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: 70% 30%;</span><br></pre></td></tr></table></figure><p>上面代码将左边栏设为70%，右边栏设为30%。<br>传统的十二网格布局，写起来也很容易。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: <span class="selector-tag">repeat</span>(12, 1<span class="selector-tag">fr</span>);</span><br></pre></td></tr></table></figure><h4 id="5-3-grid-row-gap属性-grid-column-gap属性-grid-gap属性"><a href="#5-3-grid-row-gap属性-grid-column-gap属性-grid-gap属性" class="headerlink" title="5.3 grid-row-gap属性 grid-column-gap属性 grid-gap属性"></a>5.3 grid-row-gap属性 grid-column-gap属性 grid-gap属性</h4><p>grid-row-gap属性设置行与行的间隔（行间距），grid-column-gap属性设置列与列的间隔（列间距）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-row-gap</span>: 20<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">grid-column-gap</span>: 20<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">grid-gap</span>: &lt;<span class="selector-tag">grid-row-gap</span>&gt; &lt;<span class="selector-tag">grid-column-gap</span>&gt;</span><br><span class="line"><span class="selector-tag">grid-gap</span><span class="selector-pseudo">:20px</span>; <span class="comment">/* 如果省略了第二个值，则默认第二个值等于第一个值 */</span></span><br></pre></td></tr></table></figure><p>注： 根据最新标准，上面三个属性名的grid-前缀已经删除，grid-column-gap和grid-row-gap写成column-gap和row-gap，grid-gap写成gap。</p><h3 id="5-4-grid-template-areas属性"><a href="#5-4-grid-template-areas属性" class="headerlink" title="5.4 grid-template-areas属性"></a>5.4 grid-template-areas属性</h3><p>网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。grid-template-areas属性用于定义区域。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grid-template-areas: &#x27;a b c&#x27;</span><br><span class="line">                   &#x27;d e f&#x27;</span><br><span class="line">                   &#x27;g h i&#x27;;</span><br></pre></td></tr></table></figure><p>上面代码先划分出9个单元格，然后将其定名为a到i的九个区域，分别对应这九个单元格。<br>多个单元格合并成一个区域的写法如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grid-template-areas: &#x27;a a a&#x27;</span><br><span class="line">                 &#x27;b b b&#x27;</span><br><span class="line">                 &#x27;c c c&#x27;;</span><br></pre></td></tr></table></figure><p>上面代码将9个单元格分成a、b、c三个区域。<br>如果某些区域不需要利用，则使用”点”（.）表示</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grid-template-areas: &#x27;a . c&#x27;</span><br><span class="line">                 &#x27;d . f&#x27;</span><br><span class="line">                 &#x27;g . i&#x27;;</span><br></pre></td></tr></table></figure><p>注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end。</p><h3 id="5-5-grid-auto-flow属性"><a href="#5-5-grid-auto-flow属性" class="headerlink" title="5.5 grid-auto-flow属性"></a>5.5 grid-auto-flow属性</h3><p>划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行，即下图数字的顺序。<br>这个顺序由grid-auto-flow属性决定，默认值是row，即”先行后列”。也可以将它设成column，变成”先列后行”。<br>grid-auto-flow: row/row dense/column/column dense</p><h3 id="5-6-justify-items属性-align-items属性-place-items属性"><a href="#5-6-justify-items属性-align-items属性-place-items属性" class="headerlink" title="5.6 justify-items属性 align-items属性 place-items属性"></a>5.6 justify-items属性 align-items属性 place-items属性</h3><p>justify-items属性设置单元格内容的水平位置（左中右），align-items属性设置单元格内容的垂直位置（上中下）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">justify-items: start | end | center | stretch;</span><br><span class="line">align-items: start | end | center | stretch;</span><br><span class="line">    <span class="selector-tag">start</span>：对齐单元格的起始边缘。</span><br><span class="line">    <span class="selector-tag">end</span>：对齐单元格的结束边缘。</span><br><span class="line">    <span class="selector-tag">center</span>：单元格内部居中。</span><br><span class="line">    <span class="selector-tag">stretch</span>：拉伸，占满单元格的整个宽度（默认值）。</span><br><span class="line"><span class="selector-tag">place-items</span>属性是<span class="selector-tag">align-items</span>属性和<span class="selector-tag">justify-items</span>属性的合并简写形式。</span><br></pre></td></tr></table></figure><h4 id="5-7-justify-content属性-align-content-属性-place-content-属性"><a href="#5-7-justify-content属性-align-content-属性-place-content-属性" class="headerlink" title="5.7 justify-content属性 align-content 属性 place-content 属性"></a>5.7 justify-content属性 align-content 属性 place-content 属性</h4><p>justify-content属性是整个内容区域在容器里面的水平位置（左中右），align-content属性是整个内容区域的垂直位置（上中下）。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">justify-content: start | end | center | stretch | space-around | space-between | space-evenly;</span><br><span class="line">align-content: start | end | center | stretch | space-around | space-between | space-evenly; </span><br></pre></td></tr></table></figure><h3 id="5-8-grid-auto-rows-属性和-grid-auto-columns属性"><a href="#5-8-grid-auto-rows-属性和-grid-auto-columns属性" class="headerlink" title="5.8 grid-auto-rows 属性和 grid-auto-columns属性"></a>5.8 grid-auto-rows 属性和 grid-auto-columns属性</h3><p>有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目<br>grid-auto-columns属性和grid-auto-rows属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与grid-template-columns和grid-template-rows<br>完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-auto-rows</span>: 50<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-class">.item8</span>&#123;</span><br><span class="line">    <span class="attribute">grid-row-start</span>: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定第8个项目位于第四行行高50像素</p><h3 id="6-项目属性"><a href="#6-项目属性" class="headerlink" title="6.项目属性"></a>6.项目属性</h3><h4 id="6-1-grid-column-start-grid-column-end-grid-row-start-grid-row-end"><a href="#6-1-grid-column-start-grid-column-end-grid-row-start-grid-row-end" class="headerlink" title="6.1 grid-column-start grid-column-end grid-row-start grid-row-end"></a>6.1 grid-column-start grid-column-end grid-row-start grid-row-end</h4><p>项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。</p><pre><code>grid-column-start属性：左边框所在的垂直网格线grid-column-end属性：右边框所在的垂直网格线grid-row-start属性：上边框所在的水平网格线grid-row-end属性：下边框所在的水平网格线</code></pre><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">    <span class="attribute">grid-column-start</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">grid-column-end</span>: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线。<br>这四个属性的值，除了指定为第几个网格线，还可以指定为网格线的名字。<br>这四个属性的值还可以使用span关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-column-start</span>: <span class="selector-tag">span</span> 2;</span><br></pre></td></tr></table></figure><h4 id="6-2-grid-column-属性-grid-row-属性"><a href="#6-2-grid-column-属性-grid-row-属性" class="headerlink" title="6.2 grid-column 属性 grid-row 属性"></a>6.2 grid-column 属性 grid-row 属性</h4><p>grid-column属性是grid-column-start和grid-column-end的合并简写形式，grid-row属性是grid-row-start属性和grid-row-end的合并简写形式。</p><pre><code>grid-column: 1/3grid-column 1/span 2占据两列</code></pre><h4 id="6-3-grid-area"><a href="#6-3-grid-area" class="headerlink" title="6.3 grid-area"></a>6.3 grid-area</h4><p>grid-area属性指定项目放在哪一个区域</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">grid-template-areas</span>: <span class="string">&#x27;a b c&#x27;</span></span><br><span class="line">                            <span class="string">&#x27;d e f&#x27;</span></span><br><span class="line">                            <span class="string">&#x27;g h i&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item1</span>&#123;</span><br><span class="line">    <span class="attribute">grid-area </span>:e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-4-justify-self-属性，align-self-属性，place-self-属性"><a href="#6-4-justify-self-属性，align-self-属性，place-self-属性" class="headerlink" title="6.4 justify-self 属性，align-self 属性，place-self 属性"></a>6.4 justify-self 属性，align-self 属性，place-self 属性</h4><p>justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。<br>align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css-flex布局</title>
      <link href="/ZJY.github.io/2021/01/19/css-flex%E5%B8%83%E5%B1%80/"/>
      <url>/ZJY.github.io/2021/01/19/css-flex%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="flexbox-布局"><a href="#flexbox-布局" class="headerlink" title="flexbox 布局"></a>flexbox 布局</h3><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p><p>任何一个容器都可以指定为 Flex 布局</p><p>flex:包含两部分：flex-container容器 和 flex-item</p><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。</p><p>主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p><h3 id="container属性"><a href="#container属性" class="headerlink" title="container属性:"></a>container属性:</h3><pre><code>flex-directionflex-wrapflex-flowjustify-contentalign-itemsalign-content</code></pre><p>1.display属性：</p><pre><code>flexinline-flex 行内容器-webkit-flex Webkit 内核的浏览器，必须加上-webkit前缀。</code></pre><p>注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效</p><p>2.flex-direction:</p><pre><code>row 水平方向从左向右column 垂直方向 从上往下row-reverse 水平方向从右向左column-reverse 垂直方向 从下向上</code></pre><p>3.flex-wrap: 默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行</p><pre><code>nowrap 不换行 默认值wrap 换行,第一行在上方。wrap-reverse 换行，第一行在下方。</code></pre><p>4.flex-flow: flex-direction 和 flex-wrap 结合</p><pre><code>row nowrap 两个参数对应</code></pre><p>5.justify-content： 定义了项目在主轴上的对齐方式</p><pre><code>centerspace-betweenspace-aroundspace-evenlyflex-startflex-end</code></pre><!-- ![avatar](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png) --><p>6.align-item：属性定义项目在交叉轴上如何对齐</p><pre><code>stretch 拉伸 如果项目未设置高度或设为auto，将占满整个容器的高度。flex-start 交叉轴的起点对齐。flex-end 交叉轴的终点对齐。center 交叉轴的中点对齐baseline 项目的第一行文字的基线对齐</code></pre><p>7.align-content: 多行显示设置垂直对齐方式 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用</p><pre><code>stretchflex-startflex-endcenterspace-between 行与行之间添加间隔space-around 行周围间隔</code></pre><h3 id="item属性："><a href="#item属性：" class="headerlink" title="item属性："></a>item属性：</h3><p>1.order: 控制item在容器里的位置 给item设置</p><pre><code>默认为0值越大排越后</code></pre><p>2.flex-grow： 控制item的宽度 值越大，宽度越宽,定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p><pre><code>flex-grow: 1; </code></pre><p>3.flex-basies: 设置item的宽度,定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p><pre><code>flex-basies: 100pxauto 默认值</code></pre><p>4.flex-shrink: 设置item缩小的比例,默认为1，即如果空间不足，该项目将缩小</p><pre><code>flex-shrink: 0; 设置不缩小设置比1大的数可设置缩小比例更大些如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小</code></pre><p>5.flex: 0 1 auto;分别对应 flex-grow flex-shrink flex-basies</p><p>6.align-self: 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p><pre><code>align-self: auto/flex-start/flex-end/center/stretch/baseline </code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css-css3选择器</title>
      <link href="/ZJY.github.io/2021/01/19/css-css3%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>/ZJY.github.io/2021/01/19/css-css3%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="类型选择器：-标签名进行选择"><a href="#类型选择器：-标签名进行选择" class="headerlink" title="类型选择器： 标签名进行选择"></a>类型选择器： 标签名进行选择</h3><ul><li>h1{}</li><li>h1,h2{} 选择器群组</li></ul><h3 id="通用选择器："><a href="#通用选择器：" class="headerlink" title="通用选择器： *"></a>通用选择器： *</h3><h3 id="类选择器："><a href="#类选择器：" class="headerlink" title="类选择器："></a>类选择器：</h3><ul><li>.content{}</li></ul><h3 id="ID选择器"><a href="#ID选择器" class="headerlink" title="ID选择器"></a>ID选择器</h3><ul><li>#title{}</li></ul><h3 id="属性选择器："><a href="#属性选择器：" class="headerlink" title="属性选择器："></a>属性选择器：</h3><ul><li>[attribute]</li><li>[attribute1][attribute2]</li><li>[attribute = value]</li><li>[attribute ~= value] 选择器用于选取属性值中包含指定词汇的元素 [title ~= ‘flower’]</li><li>[attribute |= value] 选择器用于选取带有以指定值开头的属性值的元素 [leng | en]</li><li>[attribute ^= value] 以value开头的值 [class ^=”test”]</li><li>[attribute $= value] 以value结尾的值</li><li>[attribute *= value] 选择器匹配属性值包含指定值的每个元素</li></ul><h3 id="伪类："><a href="#伪类：" class="headerlink" title="伪类："></a>伪类：</h3><ul><li><p>a:link a:visited a:hover a:active :focus </p></li><li><p>:target 选择器可用于选取当前活动的目标元素</p></li><li><p>:disabled 用于添加禁用样式</p></li><li><p>:nth-child(n) 选择器匹配属于其父元素的第 N 个子元素，不论元素的类</p></li><li><p>:nth-last-child() 同上，从最后一个子元素开始计数</p></li><li><p>:first-child  p:first-child 选择属于父元素的第一个子元素的每个<code>&lt;p&gt;</code>元素</p></li><li><p>:last-child  p:last-child    选择属于其父元素最后一个子元素每个<code>&lt;p&gt;</code>元素。</p></li><li><p>:nth-of-type() p:nth-of-type(2) 选择属于其父元素第二个<code>&lt;p&gt;</code>元素的每个<code>&lt;p&gt;</code>元素</p></li><li><p>:nth-last-of-type() 同上，但是从最后一个子元素开始计数</p></li><li><p>:first-of-type  p:first-of-type    选择属于其父元素的首个<code>&lt;p&gt;</code>元素的每个<code>&lt;p&gt;</code>元素</p></li><li><p>:last-of-type  p:last-of-type    选择属于其父元素的最后<code>&lt;p&gt;</code>元素的每个<code>&lt;p&gt;</code>元素</p></li><li></li><li><p>:only-child  p:only-child    选择属于其父元素的唯一子元素的每个<code>&lt;p&gt;</code>元素。</p></li><li><p>:only-of-type  p:only-of-type    选择属于其父元素唯一的<code>&lt;p&gt;</code>元素的每个<code>&lt;p&gt;</code>元素</p></li><li><p>:empty p:empty    选择没有子元素的每个<code>&lt;p&gt;</code>元素（包括文本节点）</p></li><li><p>:not :not(p)    选择非<code>&lt;p&gt;</code>元素的每个元素。</p></li></ul><h3 id="伪元素选择器："><a href="#伪元素选择器：" class="headerlink" title="伪元素选择器："></a>伪元素选择器：</h3><ul><li><p>::first-line p::first-line    选择每个<code>&lt;p&gt;</code>元素的首行。</p></li><li><p>::first-letter    p::first-letter    选择每个<code>&lt;p&gt;</code>元素的首字母。</p></li><li><p>::before    p::before    在每个<code>&lt;p&gt;</code>元素的内容之前插入内容。</p></li><li><p>::after    p::after    在每个<code>&lt;p&gt;</code>元素的内容之后插入内容。</p></li></ul><h3 id="组合选择器："><a href="#组合选择器：" class="headerlink" title="组合选择器："></a>组合选择器：</h3><ul><li>div img  以空格隔开 后裔选择器</li></ul><h3 id="儿子选择器："><a href="#儿子选择器：" class="headerlink" title="儿子选择器："></a>儿子选择器：</h3><ul><li>div &gt; img</li></ul><h3 id="兄弟选择器："><a href="#兄弟选择器：" class="headerlink" title="兄弟选择器："></a>兄弟选择器：</h3><ul><li>div + img</li><li>h2 ~ h3 h2 后面的h3 元素</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css-css3动画</title>
      <link href="/ZJY.github.io/2021/01/19/css-css3%E5%8A%A8%E7%94%BB/"/>
      <url>/ZJY.github.io/2021/01/19/css-css3%E5%8A%A8%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="过渡动画transition"><a href="#过渡动画transition" class="headerlink" title="过渡动画transition:"></a>过渡动画transition:</h3><pre><code>transition-property:动画属性：width height  border-radius ...transition-delay: 动画延迟时间transition-timing-function: 运动曲线函数transition-duration: 过渡时间transition: all 1s ease 0s</code></pre><h3 id="transform"><a href="#transform" class="headerlink" title="transform:"></a>transform:</h3><pre><code>rotate:旋转translate:移动scale: 缩放skew: 倾斜</code></pre><h3 id="阴影：shadow"><a href="#阴影：shadow" class="headerlink" title="阴影：shadow"></a>阴影：shadow</h3><pre><code>box-shadow:     h-shadow水平阴影位置（必须）     v-shadow垂直阴影的位置（必须）     blur可选。模糊距离。     spread可选。阴影的尺寸。     color可选。阴影的颜色。    inset可选。将外部阴影 (outset) 改为内部阴影。</code></pre><h3 id="渐变：linear-gradient"><a href="#渐变：linear-gradient" class="headerlink" title="渐变：linear-gradient:"></a>渐变：linear-gradient:</h3><pre><code>linear-gradient:    direction:用角度值指定渐变的方向（或角度） top left...    color-stop1,color-stop2,...</code></pre><h3 id="animation"><a href="#animation" class="headerlink" title="animation:"></a>animation:</h3><pre><code>-webkit-animation-name: hover ; //名字-webkit-animation-duration: 1s; //时间-webkit-animation-timing-function: ease-in; //变速曲线-webkit-animation-iteration-count: infinite; //次数</code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css-BFC块级格式化上下文</title>
      <link href="/ZJY.github.io/2021/01/14/css-BFC/"/>
      <url>/ZJY.github.io/2021/01/14/css-BFC/</url>
      
        <content type="html"><![CDATA[<h3 id="BOX：-css布局的基本单位-amp-盒模型"><a href="#BOX：-css布局的基本单位-amp-盒模型" class="headerlink" title="BOX： css布局的基本单位&amp;盒模型"></a>BOX： css布局的基本单位&amp;盒模型</h3><ul><li><p>盒模型–块级盒/行内盒<br>一个盒包含：内容（content）/边（border）/内边距（padding）/外边距（margin）<br>盒的尺寸（width和height–计算得到offsetWidth和offsetHeight）定义受到box-sizing属性的影响<br>w3c标准盒模型-块级盒-border-box：width = content + padding + margin<br>IE盒子模型-块级盒-content-box：width = content</p></li><li><p>行内盒：</p><ul><li>width/height 不起作用，盒子高度由内容决定（font-size/line-height）</li><li>margin-top/margin-bottom padding-top/padding-bottom不起作用</li></ul></li></ul><p>tips：</p><ul><li>两类块级盒子可用过设置box-sizing转换</li><li>行内盒与块级盒转换可通过设置display属性来修改</li><li>行内盒参与IFC布局，块级盒参与BFC布局，如果块级盒包含行内盒，但是由于BFC内只有块级盒参与，因此行内盒会被匿名块级盒包含</li></ul><h3 id="BOX"><a href="#BOX" class="headerlink" title="BOX"></a>BOX</h3><p>Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。<br>不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染</p><ul><li>block-level：box的display 属性为block, list-item, table 的元素，会生成 block-level box。并且参与（BFC）block fomatting context；</li><li>inline-level：box的display 属性为inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context；</li></ul><h3 id="格式化上下文："><a href="#格式化上下文：" class="headerlink" title="格式化上下文："></a>格式化上下文：</h3><ul><li>块级格式化上下文( Block formatting contexts )( BFC )</li><li>行内格式化上下文( Inline formatting contexts ) ( IFC )</li><li>自适应格式化上下文( Flex Formatting Contexts )( FFC )</li><li>网格布局格式化上下文( GridLayout Formatting Contexts )( GFC )</li></ul><p>有一类盒被称为块容器，它们能够包含块级盒。块容器要么创建BFC，这样它内部仅仅包含块级盒，要么创建一个IFC，这样它内部仅仅包含行内级元素。</p><p>（也就是说，块容器中不可能既包含块级盒，又包含行内级盒，一旦他的子盒中有块级盒，所有行内级盒都会被自动创建匿名盒包裹）。</p><p>在非块级格式化上下文中的块容器总是会创建新的BFC：如display为inline-blocks, table-cells, 和table-captions所生成的盒。</p><p>而自身也在块级格式化上下文中的块容器，则只有overflow不为visible的情形下才会创建新的BFC</p><ul><li>绝对定位和浮动的块容器则总是会创建新的块级格式化上下文。</li><li>display值为table或者inline-table的元素将会生成表格（table），表格内部会使用特殊的格式化方式来排布其内部元素。</li><li>display值为grid或者inline-grid的元素将会生成格元素（grid element），与table情形类似，它内部也是使用特殊的格式化方式来排布其内部元素，</li><li>display值为flex或者inline-flex的元素将会生成自适应容器（flex container），自适应容器在其内部产生自适应格式化上下文（flex formatting context）</li></ul><p>FC的全称是：Formatting Contexts，是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p><p>BFC:BFC(Block Formatting Contexts)直译为”块级格式化上下文”。<br>Block Formatting Contexts就是页面上的一个隔离的渲染区域，容器里面的子元素不会在布局上影响到外面的元素，反之也是如此。<br>浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。</p><p>BFC布局规则：</p><ul><li>内部的Box会在垂直方向，一个接一个地放置。</li><li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li><li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li><li>BFC的区域不会与float box重叠。</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li><li>计算BFC的高度时，浮动元素也参与计算</li></ul><p>那些元素生成BFC</p><ul><li>根元素</li><li>float属性不为none</li><li>position为absolute或fixed</li><li>display为inline-block, table-cell, table-caption, flex, inline-flex</li><li>overflow不为visible</li></ul><p>元素与盒</p><ul><li>在HTML中常常使用的概念是元素，而在CSS中，布局的基本单位是盒，盒总是矩形的。</li><li>元素与盒并非一一对应的关系，一个元素可能生成多个盒，CSS规则中的伪元素也可能生成盒，display属性为none的元素则不生成盒。</li><li>除了元素之外，HTML中的文本节点也可能会生成盒。</li></ul><p>正常流</p><ul><li>正常流是页面，大部分盒排布于正常流中。正常流中的盒必定位于某一格式化上下文中，正常流中有两种格式化上下文：块级格式化上下文（block formatting context，简称BFC）和行内格式化上下文（inline formatting context,IFC）。</li><li>在块级格式化上下文中，盒呈纵向排布，在行内格式化上下文中，盒则呈横向排布。</li><li>正常流根容器中是块级格式化上下文，不同的盒可能会在内部产生行内格式化上下文或者块级格式化上下文。</li></ul><p>块级与行内级</p><ul><li><p>正常流中的盒分为块级与行内级两种，任何一个行内级盒都不能够直接被放入块级格式化上下文中。如果有一个HTML元素生成了一个行内盒，而其所在的上下文是块级的话，那么应当为它生成一个匿名块级盒，匿名块级盒会在内部生成行内格式化上下文。</p></li><li><p>元素的display属性会决定盒是行内级还是块级：<br>block, table, flex, grid, list-item 为块级<br>inline, inline-block, inline-table, inline-flex, inline-grid 为行内级</p></li></ul><p>产生垂直外边距合并的必备条件,两个margin是邻接的必须满足以下条件:</p><ul><li>必须是处于常规文档流（非float和绝对定位）的块级盒子,并且处于同一个BFC当中<br>没有线盒，没有空隙（clearance，下面会讲到），没有padding和border将他们分隔开,都属于垂直方向上相邻的外边距，可以是下面任意一种情况:<ul><li>元素的margin-top与其第一个常规文档流的子元素的margin-top</li><li>元素的margin-bottom与其下一个常规文档流的兄弟元素的margin-top</li><li>height为auto的元素的margin-bottom与其最后一个常规文档流的子元素的margin-bottom</li><li>高度为0并且最小高度也为0，不包含常规文档流的子元素，并且自身没有建立新的BFC的元素的margin-top和margin-bottom</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css-BEM块元素修饰符</title>
      <link href="/ZJY.github.io/2021/01/14/css-BEM/"/>
      <url>/ZJY.github.io/2021/01/14/css-BEM/</url>
      
        <content type="html"><![CDATA[<h2 id="BlockElementModifier其实是块（block）、元素（element）、修饰符（modifier）。"><a href="#BlockElementModifier其实是块（block）、元素（element）、修饰符（modifier）。" class="headerlink" title="BlockElementModifier其实是块（block）、元素（element）、修饰符（modifier）。"></a>BlockElementModifier其实是块（block）、元素（element）、修饰符（modifier）。</h2><p>这三个部分使用__ 与<code>--</code>连接:<br>.块__元素–修饰符{}</p><p>block 代表了更高级别的抽象或组件<br>block__element 代表 block 的后代，用于形成一个完整的 block 的整体<br>block<code>--</code>modifier代表 block 的不同状态或不同版本</p><p>css引擎查找样式表，对每条规则都按从右到做的顺序去匹配<br>在scss中使用：使用@at-root内联选择器模式，编译出来的CSS无任何嵌套（这是关键）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.person</span> &#123;</span><br><span class="line">  @at-root #&#123;&amp;&#125;__hand &#123;</span><br><span class="line">    <span class="selector-tag">color</span>: <span class="selector-tag">red</span>;</span><br><span class="line">    <span class="keyword">@at-root</span> #&#123;&amp;&#125;<span class="selector-tag">--left</span> &#123;</span><br><span class="line">     <span class="attribute">color</span>: yellow;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">@at-root</span> #&#123;&amp;&#125;<span class="selector-tag">--female</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">    @at-root #&#123;&amp;&#125;__hand &#123;</span><br><span class="line">      <span class="selector-tag">color</span>: <span class="selector-tag">green</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*生成的css*/</span></span><br><span class="line"><span class="selector-class">.person__hand</span> &#123;</span><br><span class="line">   <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.person__hand--left</span> &#123;</span><br><span class="line">   <span class="attribute">color</span>: yellow; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.person--female</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.person--female__hand</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css-background属性使用</title>
      <link href="/ZJY.github.io/2021/01/14/css-background/"/>
      <url>/ZJY.github.io/2021/01/14/css-background/</url>
      
        <content type="html"><![CDATA[<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>Background 是一种 CSS 简写属性，一次性定义了所有的背景属性，包括 color, image, origin 还有 size, repeat 方式等等。</p><p>语法：</p><ul><li><p>background: background-color，background-image，background-repeat，background-attachment，background-position;(不强制要求书写顺序)</p><ul><li><p>background-color 指定要使用的背景颜色 transparent </p></li><li><p>background-position 指定背景图像的位置 0%, 0% </p></li><li><p>background-image 指定要使用的一个或多个背景图像 none </p></li><li><p>background-repeat 指定如何重复背景图像 repeat</p></li><li><p>background-attachment 设置背景图像是否固定或者随着页面的其余部分滚动。 croll</p></li><li><p>background-size 指定背景图片的大小 auto CSS3</p></li><li><p>background-origin 指定背景图像的定位区域 padding-box CSS3</p></li><li><p>background-clip 指定背景图像的绘画区域 border-box CSS3</p></li></ul></li></ul><p>多背景图片 background-image：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">background-image: url(<span class="string">&#x27;img1&#x27;</span>), url(<span class="string">&#x27;img2&#x27;</span>);</span><br><span class="line">background-size: <span class="number">50</span>%, <span class="number">100</span>%;</span><br><span class="line">background-repeat: repeat-x, no-repeat;</span><br></pre></td></tr></table></figure><p>多背景图片总结：</p><ul><li>背景图片所生效的样式，是属性值中与图片位置对应的值；</li><li>如果属性值比背景图片的个数要少，那么没有对应的值的图片样式以第一个值为准；</li><li>背景图片的层级按着从左往右，依次减小。当然，层级最低的还是 background-color；</li></ul><p>背景渐变 background-image: linear-gradient：路径渐变（可手动设置方向，默认自下向上）</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">background: linear-gradient(to left, #333, #333 50%, #eee 75%, #333 75%);</span><br><span class="line">background-image: linear-gradient(#71c9ce, #e3fdfd);</span><br></pre></td></tr></table></figure><p>background-image: radial-gradient 径向渐变：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-image: radial-gradient( #71c9ce, #e3fdfd);</span><br></pre></td></tr></table></figure><p>background-image: repeating-linear-gradient 重复路径渐变：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-image: repeating-linear-gradient(45deg, #71c9ce 20px, #a6e3e9 30px, #e3fdfd 40px);</span><br></pre></td></tr></table></figure><p>background-image: repeating-radial-gradient 重复径向渐变：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-image: repeating-radial-gradient(circle, #90ade4 ,#3350ba 20%);</span><br></pre></td></tr></table></figure><p>背景定位 background-position：</p><p>三个盒子：</p><ul><li>border-box  即所设置元素的 border 所占的区域，位于 padding 和 content 的外层</li><li>padding-box  即所设置元素的 padding 所占的区域，位于 border的内层、content 的外层</li><li>content-box 元素的 padding 所占区域包围着的即为 content</li></ul><p>background-position 默认的定位为 padding-box 盒子的左上角。其属性值可设置为：百分比 / 像素 /位置</p><p>背景重复 background-repeat：</p><p>除了常见的几个 repeat、repeat-x，repeat-y 以及 no-repeat 以外，还在CSS3 中新加了两个值： space 和 round：</p><ul><li>1.背景图片小于容器时<ul><li>background-repeat:space 在保证不缩放的前提下尽可能多的重复图片，并等分图片中间的空隙</li><li>background-repeat:round 在尽可能多的重复图片的前提下，拉伸图片以铺满容器</li></ul></li><li>2.背景图片大于容器时<ul><li>background-repeat:space 在不缩放的前提下裁剪图片，只保留在容器内的部分</li><li>background-repeat:round 缩小图片以铺满容器，长宽与容器尺寸一致（未按比例缩放，图片极有可能变形）</li></ul></li></ul><p>背景相对位置 background-origin：</p><ul><li>background-origin 属性规定 background-position 属性相对于什么位置来定位。属性值有 content-box 、padding-box 、border-box 三个，默认为 padding-box</li></ul><p>背景绘制区域 background-clip：</p><ul><li>background-clip 属性规定背景的绘制区域。默认值为 border-box，其属性值同 background-origin 一样，不过表现大不相同</li></ul><p>背景大小 background-size：</p><ul><li>background-size 除了常见的设置大小和百分比之外，还有两个特殊的属性：contain 和 cover</li><li>background-size: contain 图片长宽不相同时，把图片按比例缩小至较长的一方完全适应内容区域为止，多用于背景图片比元素大的情况</li><li>background-size: cover 图片长宽不相同时，把图片按比例放大至较短的一方完全适应内容区域为止，以使背景图像完全覆盖背景区域，多用于背景图片比元素小的情况。</li></ul><p>背景固定 background-attachment：fixed 背景固定/scroll 背景随页面滚动而滚动（默认）</p><p>扩展属性 background: element</p><ul><li>一个特殊的扩展属性，可以将某个元素设置为另一元素的背景。惊不惊喜，意不意外！不过这个属性只有 FireFox 4+ 的浏览器可以使用，并且需要加上浏览器前缀。<br>  background: element(#id)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-第十一章-javascript更多主题</title>
      <link href="/ZJY.github.io/2021/01/14/javascript-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-javascript%E6%9B%B4%E5%A4%9A%E4%B8%BB%E9%A2%98/"/>
      <url>/ZJY.github.io/2021/01/14/javascript-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-javascript%E6%9B%B4%E5%A4%9A%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript的更多主题"><a href="#JavaScript的更多主题" class="headerlink" title="JavaScript的更多主题"></a>JavaScript的更多主题</h2><h3 id="1-数据类型转换"><a href="#1-数据类型转换" class="headerlink" title="1. 数据类型转换"></a>1. 数据类型转换</h3><p>JavaScript是一种无类型语言，如果某个类型的值需要用于其他类型的值的环境中，JavaScript就会自动将    这个值转换成所需要的类型。例如，如果一个数字用于布尔值环境中，它就会被转换成布尔值。如果一个对象用于字符串类型中，那么它就会被转换为字符串。<br>自动数据类型转换：</p><table style="text-align:center">   <tr >      <td rowspan="2">值</td>      <td colspan="4">使用值的环境</td>   </tr>   <tr>      <td>字符串</td>      <td>数字</td>      <td>布尔值</td>      <td>对象</td>   </tr>   <tr>      <td>未定义的值</td>      <td>“undefined”</td>      <td>NaN</td>      <td>false</td>      <td>Error</td>   </tr>   <tr>      <td>null</td>      <td>“null”</td>      <td>0</td>      <td>false</td>      <td>Error</td>   </tr>   <tr>      <td>非空字符串</td>      <td>原内容</td>      <td>非空字符串对应数字或ASCLL码</td>      <td>true</td>      <td>String对象</td>   </tr>   <tr>      <td>空字符串</td>      <td>原内容</td>      <td>0</td>      <td>false</td>      <td>String对象</td>   </tr>   <tr>      <td>0</td>      <td>“0”</td>      <td>原值</td>      <td>false</td>      <td>Number对象</td>   </tr>   <tr>      <td>NaN</td>      <td>“NaN”</td>      <td>NaN</td>      <td>false</td>      <td>Number对象</td>   </tr>   <tr>      <td>无穷大</td>      <td>“Infinity”</td>      <td>原值</td>      <td>true</td>      <td>Number对象</td>   </tr>   <tr>      <td>负无穷大</td>      <td>“-Infinity”</td>      <td>原值</td>      <td>true</td>      <td>Number对象</td>   </tr>   <tr>      <td>其他所有数字</td>      <td>数字对应字符串</td>      <td>原值</td>      <td>true</td>      <td>Number对象</td>   </tr>   <tr>      <td>true</td>      <td>“true”</td>      <td>1</td>      <td>true</td>      <td>Boolean对象</td>   </tr>   <tr>      <td>false</td>      <td>“false”</td>      <td>0</td>      <td>false</td>      <td>Boolean对象</td>   </tr>   <tr>      <td>对象</td>      <td>toString()</td>      <td>valueOf()或toString()或NaN</td>      <td>true</td>      <td>原值</td>   </tr></table><h4 id="1-1-对象到基本数据类型的转换"><a href="#1-1-对象到基本数据类型的转换" class="headerlink" title="1.1 对象到基本数据类型的转换"></a>1.1 对象到基本数据类型的转换</h4><p>只要把非空对象用在布尔值环境中，它就会被转换为true。这适用于所有对象，即使是被转换成false的表示原始值的包装对象也不例外。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>))</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">0</span>))</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="keyword">new</span> <span class="built_in">Array</span>())</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>把对象转为数字是通过首先调用该对象的valueOf()方法来完成的。大多数对象继承了Object对象的默认valueOf()方法。它只是返回对象本身。由于默认的valueOf()方法不返回原始值，所有接下来javascript会通过调用对象的toString()方法，再将字符串转为数字来把对象转为数字。</p><p>对于数组，数组的toString()方法把数组元素逐一的转换成字符串，用逗号分隔符分隔连接起来，返回连接后的字符串。因此，没有元素的空数组，被转换为空字符串，空字符串被转换为数字0。如果数组只有一个为n的数字元素，则被转换为n本身，如果数组含有多个元素，则被转换为NaN。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>([])</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="literal">NaN</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"><span class="literal">NaN</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="number">1</span>])</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="string">&#x27;1&#x27;</span>])</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>运算符“+”和比较运算符(&lt;、&lt;=、&gt;和&gt;=)既能作用于数字，又能作用于字符串。所以当这两个运算符作用于对象时，就不太清楚应将该对象转换为数字还是字符串。在大多数情况下，JavaScript会先尝试调用对象的valueOf ()方法对它进行转换。如果该方法返回了原始值(通常是一个数字)，就使用那个值。但是valueOf ()方法通常返回的都是未被转换的对象，在这种情况下，JavaScript 将调用对象的tostring()方法对它进行转换。<br>对于这种转换规则，只有“+”运算符是例外的当“+”作用于Date对象时，首先调用toString()方法进行转换。存在这一例外的原因是Date对象既有toString又有valueOf方法。当“+”作用于一个Date对象时，你想执行的几乎都是连接操作，但是当用于比较运算符时想执行的几乎都是数字比较，以判断时间大小。</p><p>大多数对象没有valueOf()方法，或者没有能够返回有用的结果的valueOf()方法。当将“+”运算符作用于一个对象时，通常进行的是字符串的连接而不是加法运算。当将比较运算符作用于一个对象时，通常进行的则是字符串的比较，而不是数字比较。</p><h4 id="1-2-显示类型转换"><a href="#1-2-显示类型转换" class="headerlink" title="1.2 显示类型转换"></a>1.2 显示类型转换</h4><p>Number(),String(),Boolean(),Object()可以把它们参数转换为合适的类型。<br>还有别的技巧可以显式类型转换。<br>要把一个值转换为字符串，可以把它连接到一个空串上：<br>var str = x + “”;<br>要把一个值强制转换为数字，就用它减去0:<br>var number = x - 0;<br>要把一个值转换为布尔值，需要连用两次”!”：<br>var bool = !!x;</p><h4 id="1-3-从数字到字符串的转换"><a href="#1-3-从数字到字符串的转换" class="headerlink" title="1.3 从数字到字符串的转换"></a>1.3 从数字到字符串的转换</h4><p>将数字转换为字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="built_in">String</span>(number);</span><br><span class="line"><span class="keyword">var</span> str = number + ‘’;</span><br></pre></td></tr></table></figure><p>另一种方法是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = number.toString();</span><br><span class="line"><span class="comment">// Number的toString()方法又一个可选的参数，说明了转换的基数，如果省略默认是10，也可以是2-36之间的整数</span></span><br></pre></td></tr></table></figure><h4 id="1-4-从字符串到数字的转换"><a href="#1-4-从字符串到数字的转换" class="headerlink" title="1.4 从字符串到数字的转换"></a>1.4 从字符串到数字的转换</h4><p>从字符串到数字的转换，可以显式的使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="built_in">Number</span>(str);</span><br><span class="line"><span class="keyword">var</span> num = str - <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这种转换只适用于基数10，且允许字符串数字前面有空格，不允许字符串数字后面出现任何非空字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">‘ <span class="number">123</span>’ - <span class="number">0</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line">‘<span class="number">123</span> ’ - <span class="number">0</span></span><br><span class="line">‘a123’ - <span class="number">0</span></span><br><span class="line"><span class="literal">NaN</span></span><br><span class="line">‘<span class="number">123</span> a’ - <span class="number">0</span></span><br><span class="line"><span class="literal">NaN</span></span><br></pre></td></tr></table></figure><p>可以适用parseInt()/parseFloat()函数，这两个函数转换并返回字符串开头的所有数字，并忽略其后的所有非数字后缀。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;aq123&#x27;</span>)</span><br><span class="line"><span class="literal">NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;123a&#x27;</span>)</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="comment">// parseInt()只能解析整数，parseFloat()既能解析整数又能解析浮点数，如果一个字符串以’ox’或’0X’开头，那么parseInt()就将它解释为16进制。</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;3.14 meters&#x27;</span>)</span><br><span class="line"><span class="number">3.14</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;3.14 meters&#x27;</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;0xff&#x27;</span>)</span><br><span class="line"><span class="number">255</span></span><br></pre></td></tr></table></figure><p>parseInt()第二个参数指定要被解析的基数，是2-36之间的整数。<br>如果不能将字符串转换为数字，就返回NaN。</p><h3 id="2-使用值和使用引用"><a href="#2-使用值和使用引用" class="headerlink" title="2. 使用值和使用引用"></a>2. 使用值和使用引用</h3><p>在JavaScript中可以使用三种方式来操作数值：<br>1.可以复制它，把它赋值个一个新的变量<br>2.把它作为参数传递给一个函数或方法<br>3.可以把它和其他值比较来看是否相等<br>操作数值时，有2种根本不同的方式，一种“使用值”一种是“使用引用”。<br>当使用值来操作数据时，重要的是那个值。在一个赋值语句中，会生成一个实际值的副本，这个副本存储在变量中，对象的属性或数组元素中。副本和原始数据是两个分别存放的，独立的值。当使用值将一个数据传递给函数时，传递的是这个数据的副本。如果函数修改了这个值，改变的只是这个数据的副本，并不会修改原始的数据。</p><p>另一种操作数值的方式是使用引用。采用这个方式时，数据的实际副本只有一份，操作的是那个数值的引用。如果操作数据时使用的是引用，那么变量保存的并不是那个值，而是数值的引用，复制的，传递的以及比较的都是值的引用。因此在使用引用的赋值语句中，赋予的是数值的引用而不是值的副本更不是值本身。进行了赋值后，新的变量保存的也是对值的引用，这两个引用具有同等效力，如果其中一个修改了数值，那么原始引用也会改变。当使用引用将值传递给函数时，传递的也是值的引用。使用引用将一个数值和另一个数值比较时，比较的是两个引用，看它们是否引用的是同一个数值的唯一副本。<br>使用值和使用引用</p><table style="text-align:center">   <tr>      <td>操作</td>      <td>使用值</td>      <td>使用引用</td>   </tr>   <tr>      <td>复制</td>      <td>实际复制的是值，是2个不同的独立的副本</td>      <td>复制的只是对数值的引用，如果通过新的引用修改了值，也会改变原始引用</td>   </tr>   <tr>      <td>传递</td>      <td>传递的是一个独立的副本，对他的改变在函数外部没有影响</td>      <td>传递的是值的引用，如果通过函数传递的引用修改了值，这个改变在函数外部可见</td>   </tr>   <tr>      <td>比较</td>      <td>比较的两个独立的值，以判断是否相等</td>      <td>比较的是2个引用，以判断它们引用的是否是同一个数值，对两个不同的数值的引用不相等，即使这两个数值的是由相同的字节构成的。</td>   </tr></table><h4 id="2-1-基本类型和引用类型"><a href="#2-1-基本类型和引用类型" class="headerlink" title="2.1 基本类型和引用类型"></a>2.1 基本类型和引用类型</h4><p>基本类型使用值操作，引用类型使用引用来操作。<br>在JavaScript中，数字和布尔值是基本类型，说它们基本，是因为它们只是由小的、固定数量的字节构成的，这些字节是在JavaScript解释器的低层(基本层)进行操作的。另一方面，对象就是引用类型。作为特殊对象类型的数组和函数因此也是引用类型。由于这些数据类型可以包含任意多个属性或元素，所以它们不像固定大小的基本数值那样易于操作。因为对象和数组的值可能变得非常大，所以使用值来操作这些数据很不合理，这样做可能会产生大量低效率的内存复制和比较。<br>那么字符串又是什么类型的呢?由于字符串的长度是任意的，所以看起来它好像应该属于引用类型。但事实上在JavaScrip中它们通常被当作基本类型，因为它们并不是对象。<br>例：使用值进行复制，传递，比较</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> m = n;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add_to_total</span>(<span class="params">total, x</span>)</span>&#123;</span><br><span class="line">    total = total + x;</span><br><span class="line">&#125;</span><br><span class="line">add_to_total(n,m);</span><br><span class="line"><span class="built_in">console</span>.log(n,m); <span class="comment">//1 1</span></span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>) m = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(n,m);<span class="comment">//1  2</span></span><br></pre></td></tr></table></figure><p>例：使用引用进行复制，传递，比较</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmas = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2001</span>,<span class="number">11</span>,<span class="number">25</span>);</span><br><span class="line"><span class="keyword">var</span> solstice = xmas; <span class="comment">//赋值的是值的引用</span></span><br><span class="line">solstice.setDate(<span class="number">21</span>);</span><br><span class="line">xmas.getDate(); <span class="comment">//返回21，而不是原始值25</span></span><br><span class="line">(xmas == solstice) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xmas1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2001</span>,<span class="number">11</span>,<span class="number">25</span>);</span><br><span class="line"><span class="keyword">var</span> solstice1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2001</span>,<span class="number">11</span>,<span class="number">25</span>); </span><br><span class="line">(xmas1 == solstice1) <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h4 id="2-2-使用值和使用引用：总结"><a href="#2-2-使用值和使用引用：总结" class="headerlink" title="2.2 使用值和使用引用：总结"></a>2.2 使用值和使用引用：总结</h4><p>操作不同类型时所采取的方式。</p><table style="text-align:center">   <tr>      <td>类型</td>      <td>复制所使用的</td>      <td>传递所引用的</td>      <td>比较所引用的</td>   </tr>   <tr>      <td>数字</td>      <td>值</td>      <td>值</td>      <td>值</td>   </tr>   <tr>      <td>布尔值</td>      <td>值</td>      <td>值</td>      <td>值</td>   </tr>   <tr>      <td>字符串</td>      <td>不可变的值</td>      <td>不可变的</td>      <td>值</td>   </tr>   <tr>      <td>对象</td>      <td>引用</td>      <td>引用</td>      <td>引用</td>   </tr></table><h3 id="3-无用存储单元收集"><a href="#3-无用存储单元收集" class="headerlink" title="3. 无用存储单元收集"></a>3. 无用存储单元收集</h3><p>JavaScript·使用无用存储单元来回收那些由字符串、对象、数组和函数占用的而且不再使用的内存。</p><h4 id="3-1-标记和清除的无用存储单元"><a href="#3-1-标记和清除的无用存储单元" class="headerlink" title="3.1 标记和清除的无用存储单元"></a>3.1 标记和清除的无用存储单元</h4><p>一个标记 和清除的无用存储单元回收器会周期性地遍历javascript环境中的所有变量的列表，并且给这些变量所引用的值做标记。如果被引用的值是对象或数组，那么对象的属性或者数组的元素就会被递归地做上标记。通过递归地遍历所有值的树或者图，无用存储单元收集器就能够找到(并标记)仍旧使用的每个值。那些没有标记的值就是无用的存储单元。当采用标记和清除算法的无用单元收集器给所有正在使用的变量做完了标记之后，它就会开始进行清除。在这个阶段中，它将遍历环境中所有值的列表，同时释放那些没有标记的值。经典的标记和清除无用存储单元收集器每次都进行一次完整的标记和一次完整的清除工作，这在使用无用存储单元收集过程的系统中会大大降低系统的速度。该算法较为复杂的变形使效率相对提高，它们在后台执行收集，并不影响系统的性能。</p><h4 id="3-2-采用引用计数的无用存储单元收集"><a href="#3-2-采用引用计数的无用存储单元收集" class="headerlink" title="3.2 采用引用计数的无用存储单元收集"></a>3.2 采用引用计数的无用存储单元收集</h4><p>当一个对象被创建，而且它的一个引用被存储在变量中，引用计数就为1。当这个对象的引用被复制，并且存储在另一个变量中时，引用计数就增加到2。当保存这些引用的其中一个变量被某个新值覆盖了时，该象的引用计数就减为1。如果引用计数达到了0，那么就没有对这个对象的引用了。由于没有了对副本的引用，所以在程序中也就不会再有对这个对象的引用。因此， Javascript知道此时销毀对象并且收集与之关联的内存是安全的。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-第十章-正则表达式</title>
      <link href="/ZJY.github.io/2021/01/13/javascript-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/ZJY.github.io/2021/01/13/javascript-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="第十章-正则表达式"><a href="#第十章-正则表达式" class="headerlink" title="第十章-正则表达式"></a>第十章-正则表达式</h2><p>正则表达式（regular expression）是一个描述字符模式的对象。javascript的RegExp类表示正则表达式。而String和RegExp都定义了使用正则表达式进行强大的模式匹配和文本检索与替换的函数。</p><h3 id="1-正则表达式的定义"><a href="#1-正则表达式的定义" class="headerlink" title="1. 正则表达式的定义"></a>1. 正则表达式的定义</h3><p>在javascript中，正则表达式由RegExp对象表示，当然可以使用RegExp()构造函数创建RegExp对象，不过通常用直接量语法来创建RegExp对象。被定义在一堆斜杠之间的字符，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/s$/</span>; <span class="comment">//匹配所有以字母‘s’结尾的字符串</span></span><br></pre></td></tr></table></figure><p>也可用构造函数表示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(‘s$’);</span><br></pre></td></tr></table></figure><h4 id="1-1-直接量字符"><a href="#1-1-直接量字符" class="headerlink" title="1.1 直接量字符"></a>1.1 直接量字符</h4><p>正则表达式的直接量字符</p><table><thead><tr><th align="center">字符</th><th align="center">匹配</th></tr></thead><tbody><tr><td align="center">字母数字字符</td><td align="center">匹配自己本身</td></tr><tr><td align="center">\o</td><td align="center">NUL字符(\u0000)</td></tr><tr><td align="center">\t</td><td align="center">制表符</td></tr><tr><td align="center">\n</td><td align="center">换行符</td></tr><tr><td align="center">\v</td><td align="center">垂直制表符</td></tr><tr><td align="center">\v</td><td align="center">换页符</td></tr><tr><td align="center">\r</td><td align="center">回车</td></tr><tr><td align="center">\xnn</td><td align="center">由十六进制数nn指定的拉丁字符</td></tr><tr><td align="center">\uxxxx</td><td align="center">由十六进制xxxx指定的unicode字符</td></tr><tr><td align="center">\cX</td><td align="center">控制字符^X</td></tr></tbody></table><p>在正则中，许多标点符号具有特殊的含义：<br> ^ $ . * + ? = ! : | \ / () [] {}</p><h4 id="1-2-字符类"><a href="#1-2-字符类" class="headerlink" title="1.2 字符类"></a>1.2 字符类</h4><p>正则表达式的字符类</p><table><thead><tr><th align="center">字符</th><th align="center">匹配</th></tr></thead><tbody><tr><td align="center">[…]</td><td align="center">位于括号之内的任意字符</td></tr><tr><td align="center">[^…]</td><td align="center">不在括号之中的任意字符</td></tr><tr><td align="center">.</td><td align="center">除换行符和其他unicode行终止符之外的任意字符</td></tr><tr><td align="center">\w</td><td align="center">任何ASCLL单字字符，等价于[a-zA-Z0-9]</td></tr><tr><td align="center">\W</td><td align="center">任何ASCLL非单字字符，等价于[^a-zA-Z0-9]</td></tr><tr><td align="center">\s</td><td align="center">任何unicode空白符</td></tr><tr><td align="center">\S</td><td align="center">任何非unicode空白符</td></tr><tr><td align="center">\d</td><td align="center">任何ASCLL数字，等价于[0-9]</td></tr><tr><td align="center">\D</td><td align="center">任何ASCLL数字之外的任何字符，等价于[^0-9]</td></tr><tr><td align="center">[\b]</td><td align="center">退格直接量</td></tr></tbody></table><h4 id="1-3-重复"><a href="#1-3-重复" class="headerlink" title="1.3 重复"></a>1.3 重复</h4><p>正则表达式的重复字符</p><table><thead><tr><th align="center">字符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">{n,m}</td><td align="center">匹配前一项至少n次，但是不能超过m次</td></tr><tr><td align="center">{n,}</td><td align="center">匹配前一项n次或更多次</td></tr><tr><td align="center">{n}</td><td align="center">匹配前一项正好n次</td></tr><tr><td align="center">?</td><td align="center">匹配前一项0次或1次，等价于{0,1}</td></tr><tr><td align="center">+</td><td align="center">匹配前一项一次或多次，等价于{1,}</td></tr><tr><td align="center">*</td><td align="center">匹配前一项0次或多次，等价于{0,}</td></tr></tbody></table><h4 id="1-4-选择-分组和引用"><a href="#1-4-选择-分组和引用" class="headerlink" title="1.4 选择/分组和引用"></a>1.4 选择/分组和引用</h4><p>字符“｜”用于分隔供选择的字符，例如，/ab|cd|ef/既匹配字符串”ab”,又匹配”cd”,又或者是”ef”. 选择项从左到右考虑，直到发现了匹配项，如果左边选项匹配，就忽略右边的匹配项。</p><h4 id="1-5指定匹配的位置"><a href="#1-5指定匹配的位置" class="headerlink" title="1.5指定匹配的位置"></a>1.5指定匹配的位置</h4><table><thead><tr><th align="center">字符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">^</td><td align="center">匹配字符串的开头</td></tr><tr><td align="center">$</td><td align="center">匹配字符串的结尾</td></tr><tr><td align="center">\b</td><td align="center">匹配一个词语的边界</td></tr><tr><td align="center">\B</td><td align="center">匹配非词语边界的字符</td></tr></tbody></table><h4 id="1-6标志"><a href="#1-6标志" class="headerlink" title="1.6标志"></a>1.6标志</h4><table><thead><tr><th align="center">字符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">i</td><td align="center">执行大小写不敏感的匹配</td></tr><tr><td align="center">g</td><td align="center">执行全局匹配</td></tr><tr><td align="center">m</td><td align="center">多行模式</td></tr></tbody></table><h3 id="2-用于匹配模式的String方法"><a href="#2-用于匹配模式的String方法" class="headerlink" title="2. 用于匹配模式的String方法"></a>2. 用于匹配模式的String方法</h3><p>类String支持四种利用正则表达式的方法</p><ul><li>search(),该方法以正则表达式为参数，返回第一个与之匹配的子串的开始字符的位置，没有没有匹配子串，返回-1，例如：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“JavaScript”.search(<span class="regexp">/script/i</span>); <span class="comment">//4</span></span><br></pre></td></tr></table></figure><p>如果参数不是正则表达式，会传递给RegExp构造函数转换成正则表达式。search不支持全局检索。</p><ul><li><p>方法replace()执行检索和替换操作，第一个参数是正则表达式，第二个参数是要进行替换的字符串。如果正则表达式中设置类标记g，将用替换字符串替换被检索的字符串中所有与模式匹配的子串，否则只替换第一个与模式匹配的子串。如果第一个参数是字符串，则直接检索该字符串。例如：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text.replace(<span class="regexp">/javascript/gi</span>,”JavaScript”);</span><br></pre></td></tr></table></figure><p>  第二个参数可以是函数，能够动态地计算替换字符串。</p></li><li><p>方法match()，唯一的参数就是正则表达式（或者参数传递给构造函数RegExp以转换成正则表达式），返回包含匹配结果的数组，例如：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“<span class="number">1</span> plus <span class="number">2</span> equals <span class="number">3</span>”.match(<span class="regexp">/\d+/g</span>); <span class="comment">//[“1”,”2”,”3”]</span></span><br></pre></td></tr></table></figure><p>  如果不设置标志g，只检索第一个匹配，返回的也是数组</p></li><li><p>split()方法可以把调用它的字符串分解为一个子串数组，使用分隔符作为参数，例如：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“<span class="number">123</span>,<span class="number">456</span>,<span class="number">789</span>”.split(‘,’); <span class="comment">//[“123”,”456”,”789”]</span></span><br></pre></td></tr></table></figure><p>  也可以用正则表达式为参数，指定分隔符，允许两个有任意多个空白符：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“<span class="number">1</span>,<span class="number">2</span>, <span class="number">3</span> , <span class="number">4</span> ,<span class="number">5</span>”.split(<span class="regexp">/\s*,\s*/</span>); <span class="comment">//[“1”,”2”,”3”,”4”,”5”]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-RegExp对象"><a href="#3-RegExp对象" class="headerlink" title="3. RegExp对象"></a>3. RegExp对象</h3><p>构造函数RegExp()有一个或2个字符串参数，第一个是包含正则表达式主体的字符串，即正则表达式斜杠之间的文本，用<code>\\</code>代表转义的\字符，第二个参数可选，是表达式的标志，“g”,”i”,”m”或它们的组合，例如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> zipcode = <span class="keyword">new</span> <span class="built_in">RegExp</span>(“\\d&#123;<span class="number">5</span>&#125;”,”g”);<span class="comment">//找到字符串中5个数字</span></span><br></pre></td></tr></table></figure><h4 id="3-1-用于模式匹配的RegExp方法"><a href="#3-1-用于模式匹配的RegExp方法" class="headerlink" title="3.1 用于模式匹配的RegExp方法"></a>3.1 用于模式匹配的RegExp方法</h4><p>RegExp对象定义类2个用于执行模式匹配操作的方法。</p><ul><li><p>exec()对一个指定的字符串执行正则表达式，就是在一个字符串中检索匹配，如果没有找到就返回null，如果找到一个匹配就返回一个数组。这个数组的元素0包含的是正则表达式相匹配的字符串，余下的所有元素包含的是与括号扩起来的子表达式相匹配的子串。而且，属性index包含类匹配发生的字符的位置，属性input引用的是被检索的字符串。</p></li><li><p>test()参数是一个字符串，如果这个字符串包含正则表达式的一个匹配就返回true</p></li></ul><h4 id="3-2-RegExp的实例属性"><a href="#3-2-RegExp的实例属性" class="headerlink" title="3.2 RegExp的实例属性"></a>3.2 RegExp的实例属性</h4><p>每个RegExp对象都有5个属性.</p><ul><li>属性source是一个只读字符串，存放的是正则表达式的文本。</li><li>属性global是一个只读的布尔值，说明该表达式是否有标志g。</li><li>属性ignoreCase是一个只读的布尔值，说明该表达式是否有标志i。</li><li>属性multiline是一个只读的布尔值，说明该表达式是否有标志m。</li><li>最后一个属性是lastIndex，可读写的整数。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-第九章-数组</title>
      <link href="/ZJY.github.io/2021/01/13/javascript-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%95%B0%E7%BB%84/"/>
      <url>/ZJY.github.io/2021/01/13/javascript-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="第九章-数组"><a href="#第九章-数组" class="headerlink" title="第九章-数组"></a>第九章-数组</h2><p>对象类型是一种包含已命名的的值的复合数据类型，数组即一种包含已编码的值的复合数据类型</p><h3 id="1-数组和数组元素"><a href="#1-数组和数组元素" class="headerlink" title="1. 数组和数组元素"></a>1. 数组和数组元素</h3><p>数组（array）是一种数据类型，它包含或者存储了编码的值。每个编码的值称作该数组的一个元素（element），每个元素的编码成为数组的下标（index）。</p><h4 id="1-1-数组的创建"><a href="#1-1-数组的创建" class="headerlink" title="1.1 数组的创建"></a>1.1 数组的创建</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">a</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,’a’]</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line">a.length; <span class="comment">//3, 每个元素都是undefined</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>();<span class="comment">//[] 创建了一个空数组</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="keyword">var</span> a = [‘a’,’b’,<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><h4 id="1-2-数组元素的读和写"><a href="#1-2-数组元素的读和写" class="headerlink" title="1.2 数组元素的读和写"></a>1.2 数组元素的读和写</h4><p>可以用[]来存取数组元素。方括号左边是对数组的引用，方括号中是具有非负整数的任意表达式。数组的下标必须是大于等于0并小于2<sup>23-1</sup>的整数，如果你使用的数字过大或者使用了小数负数，浮点数，会转化为字符串作为对象属性的名字，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">a[-<span class="number">12</span>] = <span class="number">12</span></span><br><span class="line">a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, &#123;-<span class="number">12</span>:<span class="number">12</span>&#125;]</span><br></pre></td></tr></table></figure><h4 id="1-3-数组的长度"><a href="#1-3-数组的长度" class="headerlink" title="1.3 数组的长度"></a>1.3 数组的长度</h4><p>所有的数组都有length属性，用来说明这个数组包含的元素个数。数组的length是自动更新的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">a.length</span><br><span class="line"><span class="number">0</span></span><br><span class="line">a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>);</span><br><span class="line">a.length</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>数组的length属性既可以读又可以写，当length设置了一个比他小的值，之后的值会被截断，值就会丢失。如果length设置的值比当前值大，那么未定义的元素就会被添加到数组末尾以使数组增加到指定长度。<br>通过设置数组length是唯一缩短数组长度的方法。如果使用delete来删除元素，虽然元素变成未定义的，但是数组的length属性不会变。</p><h3 id="2-数组的方法"><a href="#2-数组的方法" class="headerlink" title="2. 数组的方法"></a>2. 数组的方法</h3><h4 id="2-1-join方法"><a href="#2-1-join方法" class="headerlink" title="2.1 join方法"></a>2.1 join方法</h4><p>方法Array.join()方法可以将一个数组元素都转换成字符串，然后拼接起来。你可以指定一个可选的字符串来隔离结果字符串中的元素，如果没有指定，用逗号分割。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">a.join(<span class="string">&quot;*&quot;</span>)</span><br><span class="line"><span class="string">&quot;1*2&quot;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-reverse方法"><a href="#2-2-reverse方法" class="headerlink" title="2.2.reverse方法"></a>2.2.reverse方法</h4><p>方法Array.reverse()方法将颠倒数组顺序并返回颠倒后的结果。他在原数组上操作，并不是新建一个数组进行操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a.reverse();</span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">a</span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h4 id="2-3-sort方法"><a href="#2-3-sort方法" class="headerlink" title="2.3 sort方法"></a>2.3 sort方法</h4><p>Array.sort()方法是在原数组上对数组元素进行排序，返回排序后的结果，如果调用时不传参数，将按照字母顺序进行排序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;banan&#x27;</span>,<span class="string">&#x27;apple&#x27;</span>,<span class="string">&#x27;orange&#x27;</span>];</span><br><span class="line">a.sort();</span><br><span class="line">a.join();</span><br><span class="line"><span class="string">&quot;apple,banan,orange&quot;</span></span><br><span class="line">a</span><br><span class="line">[<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banan&quot;</span>, <span class="string">&quot;orange&quot;</span>]</span><br></pre></td></tr></table></figure><p>如果含有未定义的元素，这些元素将被放在数组的末尾<br>如果要按照别的顺序排序，需要传递给sort方法一个比较函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>];</span><br><span class="line">a.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;)</span><br><span class="line"> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>];</span><br><span class="line">a.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b-a;</span><br><span class="line">&#125;)</span><br><span class="line"> [<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h4 id="2-4-concat"><a href="#2-4-concat" class="headerlink" title="2.4 concat"></a>2.4 concat</h4><p>方法Array.concat()能创建并返回一个数组,这个数组包含了调用concat()的原始数组的元素，其后跟随的是concat()的参数。如果其中有些参数是数组,那么它将被展开,其元素将被添加到返回的数组中。但是要注意concat()并不能递归地展开一个元素为数组的数组。下面是一些例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.concat(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment">//[1,2,3.4,5]</span></span><br><span class="line">a.concat([<span class="number">4</span>,<span class="number">5</span>]);</span><br><span class="line"><span class="comment">//返回[1,2,3,4,5]</span></span><br><span class="line">a.concat([<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>])</span><br><span class="line"><span class="comment">//[1,2,3,4,5,6,7]</span></span><br><span class="line">a.concat(<span class="number">4</span>,[<span class="number">5</span>,[<span class="number">6</span>,<span class="number">7</span>]])<span class="comment">//返回[1,2,3,4,5,[6,7]]</span></span><br></pre></td></tr></table></figure><h4 id="2-5-slice-方法"><a href="#2-5-slice-方法" class="headerlink" title="2.5 slice()方法"></a>2.5 slice()方法</h4><p>方法Array.slice()方法返回的是指定的一个数组片段，它的两个参数指定要返回数组的起止点，返回的值是包含第一个参数指定的元素和第二个参数指定元素的上一个元素为止的元素，但是并不包含第二个参数包含的元素。如果只传递一个参数，那么返回从第一个元素到末尾之间的元素，如果参数含有负数，那么从数组末尾开始算，例如，-1指的是数组最后一个元素。例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">a.slice(<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line"> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">a.slice(<span class="number">1</span>,-<span class="number">1</span>)</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">a.slice(-<span class="number">3</span>,-<span class="number">2</span>)</span><br><span class="line">[<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h4 id="2-6-splice方法"><a href="#2-6-splice方法" class="headerlink" title="2.6 splice方法"></a>2.6 splice方法</h4><p>方法Array.splice()在原数组上插入或删除数组元素，修改原数组。<br>第一个参数指定了要插入或删除的的元素在数组中的位置。第二个参数指定了要删除的元素个数。如果第二个参数省略，将删除从开始元素到末尾之间的元素，splice返回的是删除了的数组元素数组，如果没有删除，返回空数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">a.splice(<span class="number">4</span>)</span><br><span class="line">[<span class="number">5</span>]</span><br><span class="line">a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">a.splice(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">a</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">a.splice(<span class="number">1</span>,<span class="number">0</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">[]</span><br><span class="line">a</span><br><span class="line">[<span class="number">1</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">a.splice(<span class="number">1</span>,<span class="number">0</span>,[<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">[]</span><br><span class="line">a</span><br><span class="line">[<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],’A’,’B’]</span><br><span class="line"><span class="comment">// splice并不将插入的元素展开</span></span><br></pre></td></tr></table></figure><h4 id="2-7-push方法和pop方法"><a href="#2-7-push方法和pop方法" class="headerlink" title="2.7 push方法和pop方法"></a>2.7 push方法和pop方法</h4><p>push和pop可以像栈那样使用数组，push可以向数组末尾添加一个或多个数组元素，并返回数组的新长度，pop可以删除数组最后一个元素，返回删除的值，这两个方法都修改原数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stack = [];</span><br><span class="line">stack.push(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line">stack.pop()</span><br><span class="line"><span class="number">2</span></span><br><span class="line">stack.push(<span class="number">3</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line">stack.pop()</span><br><span class="line"><span class="number">3</span></span><br><span class="line">stack.push([<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="number">2</span></span><br><span class="line">stack.pop()</span><br><span class="line"> [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">stack.pop()</span><br><span class="line"><span class="number">1</span></span><br><span class="line">stack</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><h4 id="2-8-unshift和shift方法"><a href="#2-8-unshift和shift方法" class="headerlink" title="2.8 unshift和shift方法"></a>2.8 unshift和shift方法</h4><p>和push和pop类似，只不过是在数组头部插入和删除元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = []</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">a.unshift(<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">a.unshift(<span class="number">22</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line">a.shift()</span><br><span class="line"><span class="number">22</span></span><br><span class="line">a</span><br><span class="line">[<span class="number">1</span>]<span class="number">0</span>: 1length: 1__proto__: <span class="built_in">Array</span>(<span class="number">0</span>)</span><br><span class="line">a.unshift([<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="number">2</span></span><br><span class="line">a</span><br><span class="line"> [[<span class="number">4</span>, <span class="number">5</span>], <span class="number">1</span>]</span><br><span class="line">a.shift()</span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">a.shift()</span><br><span class="line"><span class="number">1</span></span><br><span class="line">a</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><h4 id="2-9-toString方法"><a href="#2-9-toString方法" class="headerlink" title="2.9 toString方法"></a>2.9 toString方法</h4><p>数组的toString将数组每个元素转换为字符串，用逗号拼接，并且没有其他的界定符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].toString()</span><br><span class="line"><span class="string">&quot;1,2,3&quot;</span></span><br><span class="line">[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>].toString()</span><br><span class="line"><span class="string">&quot;a,b,c&quot;</span></span><br><span class="line">[<span class="number">1</span>,[<span class="number">2</span>,<span class="string">&quot;c&quot;</span>]].toString()</span><br><span class="line"><span class="string">&quot;1,2,c&quot;</span></span><br></pre></td></tr></table></figure><p>注意toString的返回值和无参数的join方法返回值相等：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,[<span class="number">2</span>,<span class="string">&quot;c&quot;</span>]].join()</span><br><span class="line"><span class="string">&quot;1,2,c&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-第八章-对象</title>
      <link href="/ZJY.github.io/2021/01/13/javascript-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1/"/>
      <url>/ZJY.github.io/2021/01/13/javascript-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="第八章-对象"><a href="#第八章-对象" class="headerlink" title="第八章-对象"></a>第八章-对象</h2><h3 id="1-对象和属性"><a href="#1-对象和属性" class="headerlink" title="1. 对象和属性"></a>1. 对象和属性</h3><p>对象是一种复合数据类型，将多个数据值存储在一个单元中，并使用名字来存取这些值。<br>解释对象的另一种方式就是，对象是一个无序的属性集合，每个属性都有自己的名字和值，存储在对象中已命名的值既可以是数字字符串也可以是对象。</p><h4 id="1-1-对象的创建"><a href="#1-1-对象的创建" class="headerlink" title="1.1 对象的创建"></a>1.1 对象的创建</h4><p>对象是由运算符new创建的，在这个运算符之后必须有用于初始化对象的构造函数名，可以用如下代码创建空对象（没有属性的对象）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure><p>javascript还支持内部构造函数，例如： var now  = new Date();<br>对象直接量定义了另一种初始化对象的方式。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    x:<span class="number">0</span>,</span><br><span class="line">    y:<span class="number">0</span>,</span><br><span class="line">    radius:<span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-属性的设置和查询"><a href="#1-2-属性的设置和查询" class="headerlink" title="1.2 属性的设置和查询"></a>1.2 属性的设置和查询</h4><p>通常使用“.”运算符来存取对象的属性。位于“.”运算符左边的是对象的引用，右边的是对象的属性，是一个标识符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">book.title = <span class="string">&#x27;javascript高级程序设计&#x27;</span>;<span class="comment">//设置属性</span></span><br><span class="line">book.title ; <span class="comment">//属性查询</span></span><br></pre></td></tr></table></figure><h4 id="1-3-属性的枚举"><a href="#1-3-属性的枚举" class="headerlink" title="1.3 属性的枚举"></a>1.3 属性的枚举</h4><p>可以通过for/in来遍历对象的属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getObjNames</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> names = “”;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> name <span class="keyword">in</span> obj) names+= name ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for/in循环属性并没有特定的顺序，虽然能枚举出用户定义的属性，但不能枚举出某些预定义的属性和方法</p><h4 id="1-4-未定义的属性"><a href="#1-4-未定义的属性" class="headerlink" title="1.4 未定义的属性"></a>1.4 未定义的属性</h4><p>如果要读取一个未定义的属性，那么读取的值是undefined.<br>可以用运算符delete来删除对象的属性：<br>delete book.title;<br>删除一个属性不仅仅是将属性值设置为undefined,而是真正从该对象中移除该属性。用for/in循环可以证明两者区别，它只能枚举出来被设定为undefined的属性，不能枚举已删除的属性。</p><h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2. 构造函数"></a>2. 构造函数</h3><p>在javascript中，使用new运算符和预定义的构造函数（Date(),Object(),Function()等）可以创建并初始化一个对象。</p><p>要创建已经定义了属性的对象，需要编写一个构造函数在新的对象中创建并初始化这些属性。构造函数是具有2个特性的javascript函数：</p><ul><li>由new运算符调用</li><li>传递给它的是对一个新创建的空对象的引用，将该引用作为关键字this的值，而且还要对新创建的对象进行初始化</li></ul><p>如下例子说明如何定义并调用Rectangle对象的构造函数<br>Rectangle对象的构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/定义构造函数</span><br><span class="line"><span class="comment">//注意如何初始化this引用的对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">w,h</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.width = w;</span><br><span class="line">    <span class="built_in">this</span>.height = h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用构造函数创建2个Rectangle对象</span></span><br><span class="line"><span class="comment">//注意把宽和高传递给构造函数，这样就能初始化对象</span></span><br><span class="line"><span class="keyword">var</span> rect1 = <span class="keyword">new</span> Rectangle(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">var</span> rect2 = <span class="keyword">new</span> Rectangle(<span class="number">8</span>,<span class="number">9</span>);</span><br></pre></td></tr></table></figure><p>构造函数只是初始化了对象，并不返回这个对象。构造函数通常没有返回值，只是初始化由this值传递进来的对象。<br>但是，构造函数可以返回一个对象值，如果这样做，被返回的对象就成了new表达式的值，this所引用的对象就被丢弃了。</p><h3 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h3><p>所谓方法（method）就是通过对象调用的javascript函数。函数就是数值，可以将函数赋值给任何变量，设置对象的属性。如果一个函数f和一个对象o，可以定义一个名为m的方法：o.m = f;<br>定义m方法之后可以通过o.m()调用它。</p><p>方法有一个重要的属性，即函数主体内部，关键字this变成了调用该方法的对象。例如，在o.m()中，主体可以使用关键字this来引用对象o.</p><p>任何一个用作方法的函数都会得到一个额外的实际参数，即调用该方法的对象。</p><p>由于方法通常是对对象执行某种操作，要表达函数作用于对象，最好采用方法的调用的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rect.setSize(width,height);</span><br><span class="line">setRectSize(rect, width, height);</span><br></pre></td></tr></table></figure><p>虽然这两行代码都是对对象做同样的操作，但第一行采用方法的调用语法。表达rect是操作的焦点。</p><p>虽然有区别地对特函数和方法比较有用，但实际上它们之间的差别井没有最初时那么大了。<br>回忆一下，函数是储存在变量中的值，而那个变量也不过是全局对象的一个属性。因此，当你调用一个函数时，实际上调用的是全局对象的一个方法。<br>在这样的函数中，关键字this引用的是全局对象。所以在函数和方法之间井设有件么技术上的差别。<br>真正的差别存在于设计和目的上，方法是用来对上this对象进行操作的，而函数通常是独立的，并不需要使用this对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例8-2方法的定义和调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compute_area</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.width * <span class="built_in">this</span>.height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> page = <span class="keyword">new</span> Rectangle(<span class="number">9</span>,<span class="number">88</span>);</span><br><span class="line">page.area = compute_area; <span class="comment">//通过把函数赋予对象的属性，来定义一个方法。</span></span><br><span class="line"><span class="keyword">var</span> a = page.area();</span><br></pre></td></tr></table></figure><p>在例8-2中有一个明显的缺点，那就是在调用rect对象的方法area()之前，必须先将该方法赋给rect对象的一个属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">8</span>-<span class="number">3</span> 用构造函数定义方法</span><br><span class="line"><span class="comment">//首页定义一些函数，它们将被用作方法。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle_area</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>.width * <span class="built_in">this</span>.height; &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle_perimeter</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">2</span>*<span class="built_in">this</span>.width + <span class="number">2</span>*<span class="built_in">this</span>.height; &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle_set_size</span>(<span class="params">w,h</span>) </span>&#123; <span class="built_in">this</span>.width = w; <span class="built_in">this</span>.height = h; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为Rectangle对象定义一个构造函数，不仅要初始化属性还要给方法赋值。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">w,h</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//初始化对象的属性</span></span><br><span class="line">    <span class="built_in">this</span>.width = w;</span><br><span class="line">    <span class="built_in">this</span>.height = h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义对象的方法</span></span><br><span class="line">    <span class="built_in">this</span>.area = Rectangle;</span><br><span class="line">    <span class="built_in">this</span>.perimeter = Rectangle_perimeter;</span><br><span class="line">    <span class="built_in">this</span>.set_size = Rectangle_set_size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一旦创建Rectangle对象，就可以直接调用它的方法</span></span><br><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> Rectangle(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> a = r.area();</span><br><span class="line"><span class="keyword">var</span> p = r.perimeter();</span><br></pre></td></tr></table></figure><p>例8-3说明的方法还是有缺点，构造函数Rectangle()要对它所有属性都进行设置。由于每个属性都占用一定内存空间，所以给每个Rectangle类添加方法，内存占用就会增加。</p><h3 id="4-原型对象和继承"><a href="#4-原型对象和继承" class="headerlink" title="4.原型对象和继承"></a>4.原型对象和继承</h3><p>我们已经知道，用构造函数把方法赋予它要初始化的对象效率低下。<br>javascript对象都继承原型对象的属性。每个对象都有原型对象，原型对象的所有属性都是以它为原型的对象的属性。也就是说，每个对象都继承原型对象的所有属性。</p><p>一个对象的原型是由创建并初始化该对象的构造函数定义的。<br>javascript中所有函数都有prototype属性，它引用了一个对象。虽然原型对象初始化是空的，但你在其中定义的任何属性都会被该构造函数创建的所有对象继承。<br>因为原型对象的属性被一个类的所有对象共享，所有通常只用它们来定义类中所有相同的属性。这使得原型对象适用于方法定义，另外原型属性还适合于那些具有常量值的属性定义。</p><h4 id="4-1-原型和内部类"><a href="#4-1-原型和内部类" class="headerlink" title="4.1 原型和内部类"></a>4.1 原型和内部类</h4><p>不只是用户定义的类具有原型对象，像String和Date这样的内部类同样具有原型对象，也可以给它们赋值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.endsWith = <span class="function"><span class="keyword">function</span>(<span class="params">c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (c == <span class="built_in">this</span>.charAt(<span class="built_in">this</span>.length - <span class="number">1</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> message = “hello world”;</span><br><span class="line">message.endsWith(‘h’); <span class="comment">//false</span></span><br><span class="line">message.endsWith(‘d’); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="5-面向对象的javascript"><a href="#5-面向对象的javascript" class="headerlink" title="5. 面向对象的javascript"></a>5. 面向对象的javascript</h3><p>javascript采取以原型对象为基础的继承机制，而不是采取类为基础的继承机制。</p><h4 id="5-1-实例的属性"><a href="#5-1-实例的属性" class="headerlink" title="5.1 实例的属性"></a>5.1 实例的属性</h4><p>每个对象都有它自己单独的属性副本。如果有10个给定的类的对象，那么每个实例属性就有10个副本。<br>在默认情况下，javascript对象的属性都是实例属性，但是为了更真实的模拟面向对象的设计语言，我们说javascript的实例属性都是在对象中用构造函数创建的或初始化的属性。</p><h4 id="5-2-实例方法"><a href="#5-2-实例方法" class="headerlink" title="5.2 实例方法"></a>5.2 实例方法</h4><p>实例方法和实例属性十分相似，只不过是方法而不是数值。实例方法由特定方法和实例对象调用的。<br>实例方法使用了this来引用它们要操作的对象或实例。虽然类的任何实例都可以调用实例方法，但是并不意味着每个对象都像实例属性那样含有自己专有的方法副本。相反，每个实例方法都是由类的所有实例所共享的。<br>在javascript中，给类定义一个实例方法，是通过把构造函数的原型对象的一个属性设置为函数值来实现的。</p><h4 id="5-3-类属性"><a href="#5-3-类属性" class="headerlink" title="5.3 类属性"></a>5.3 类属性</h4><p>在Java中，类属性是和类相关联的的变量。而不是和类的每个实例相关联的变量。无论类创建多少个实例，每个类属性就只有一个副本。就像实例属性是通过实例存取一样，类属性是通过类存取的。在javascript中，Number.MAX_VALUE就是类属性的一个例子，因为MAX_VALUE就是通过类Number存取的.</p><h4 id="5-4-类方法"><a href="#5-4-类方法" class="headerlink" title="5.4 类方法"></a>5.4 类方法</h4><p>类方法是一个与类关联的一起的方法，而不是和类的实例关联在一起的方法。要调用类方法就必须使用类本身，而不能使用类的实例。方法Date.parse()就是一个类方法。和类属性一样，类方法是全局性的。<br>因为类方法不是对特定对象进行操作的所以类方法更容易被认为是由类调用的函数。在javascript中，要定义一个类方法，只需要用合适的函数作为构造函数的属性即可。</p><h4 id="5-5-例子，类Circle"><a href="#5-5-例子，类Circle" class="headerlink" title="5.5 例子，类Circle()"></a>5.5 例子，类Circle()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义构造函数本身</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.r = radius;</span><br><span class="line">    <span class="comment">//r是构造函数定义并初始化的一个实例属性</span></span><br><span class="line">&#125;</span><br><span class="line">Circle.PI = <span class="number">3.14159</span>;<span class="comment">//定义类属性，是构造函数的一个属性</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cricle_area</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Circle.PI * <span class="built_in">this</span>.r * <span class="built_in">this</span>.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Circle.prototype.area = Cricle_area();<span class="comment">//通过把函数赋给构造函数的原型对象来定义一个实例方法。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle_max</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.r &gt; b.r) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line">Circle.max = Circle_max;<span class="comment">//将函数赋给构造函数的属性，使之成为类方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Circle(<span class="number">1.0</span>);<span class="comment">//创建Circle类的一个实例</span></span><br><span class="line">c.r = <span class="number">2.2</span>; <span class="comment">//修改类实例属性值</span></span><br><span class="line"><span class="keyword">var</span> a = c.crea(); <span class="comment">//调用实例方法</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> Circle(<span class="number">1.2</span>);</span><br><span class="line"><span class="keyword">var</span> bigger = Circle.max(c,d); <span class="comment">//调用类方法</span></span><br></pre></td></tr></table></figure><h4 id="5-6-例子，类Complex复数"><a href="#5-6-例子，类Complex复数" class="headerlink" title="5.6 例子，类Complex复数"></a>5.6 例子，类Complex复数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">复数就是一个实数和一个虚数的和</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 定义类的第一步就是定义该类的构造函数</span></span><br><span class="line"><span class="comment">* 这个构造函数要初始化对象的所有实例属性</span></span><br><span class="line"><span class="comment">* 这些属性是核心的状态变量，是它们使每个类实例不同</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Complex</span>(<span class="params">real, imaginary</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.x = real;<span class="comment">//复数的实数部分</span></span><br><span class="line">    <span class="built_in">this</span>.y = imaginary; <span class="comment">//复数的虚数部分</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 定义类的第二部是在构造函数的原型对象定义他的实例方法（或属性）</span></span><br><span class="line"><span class="comment">* 该对象定义的任何属性都被类的实例所继承</span></span><br><span class="line"><span class="comment">* 返回复数的大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Complex.prototype.maginary = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(<span class="built_in">this</span>.x * <span class="built_in">this</span>.x,<span class="built_in">this</span>.y * <span class="built_in">this</span>.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回复数的相反数</span></span><br><span class="line">Complex.prototype.negative = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Complex(-<span class="built_in">this</span>.x, -<span class="built_in">this</span>.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将Complex对象转化成一个字符串</span></span><br><span class="line">Complex.prototyoe.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&quot;</span>+ <span class="built_in">this</span>.x+<span class="string">&#x27;,&#x27;</span>+<span class="built_in">this</span>.y+<span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个复数的实数部分</span></span><br><span class="line">Complex.prototyoe.valueOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 定义类的第二部是定义类方法</span></span><br><span class="line"><span class="comment">* 常量和其他必要属性作为构造函数的属性而不是构造函数原型对象的属性</span></span><br><span class="line"><span class="comment">* 注意，类方法没有使用this关键字，因为它们只对实际参数进行操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Complex.add = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Complex(a.x+b.x,a.y+b.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex.subtract = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Complex(a.x-b.x,a.y-b.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 下面是预定义复数</span></span><br><span class="line"><span class="comment">* 被定义为类属性，可以被用作常量，实际上并不是只读的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Complex.zero = <span class="keyword">new</span> Complex(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">Complex.one = <span class="keyword">new</span> Complex(<span class="number">1</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="5-7-超类和子类"><a href="#5-7-超类和子类" class="headerlink" title="5.7 超类和子类"></a>5.7 超类和子类</h4><p>在javascript中，类Object是最通用的类，其他所有类都是专用化了的类，或者说是Object的子类。<br>另一种解释就是Object是所有内部类的超类。所有类都继承类Object的基本方法。<br>对象从他的构造函数的原型对象中继承属性，原型对象本身就是一个对象，由构造函数Object()创建。这就意味着原型对象继承了Object.prototype属性，因此类Complex就继承了Complex.prototype的属性，而后者又继承了Object.prototype属性。因此，Complex继承了两个对象的属性，在Complex中查询某个属性时，首先查询这个对象本身，如果没有查询到，就查询Complex.prototype的对象，如果还未查询到，就查询Object.prototype对象。</p><h3 id="6-对象的属性和方法"><a href="#6-对象的属性和方法" class="headerlink" title="6. 对象的属性和方法"></a>6. 对象的属性和方法</h3><p>在javascript中，所有对象都是Object类创建而来，虽然一些专用的类比如String和用户自定义的类Complex都定义了自己的属性和方法，但是都支持Object类定义的属性和方法。</p><h4 id="6-1-constructor属性"><a href="#6-1-constructor属性" class="headerlink" title="6.1 constructor属性"></a>6.1 constructor属性</h4><p>每个对象都有constructor属性，它引用的是初始化该对象的构造函数，例如用构造函数Complex创建类一个对象o，那么o.constructor引用的就是Complex，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> Complex(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">o.constructor == Complex;</span><br></pre></td></tr></table></figure><h4 id="6-2-toString方法"><a href="#6-2-toString方法" class="headerlink" title="6.2 toString方法"></a>6.2 toString方法</h4><p>方法toString没有任何实际参数，它返回的是一个字符串，该方法返回的是调用它的对象的类型或值。当使用“+”运算符把一个字符串和一个对象连接一起或把一个对象传递给alert()或document.write()时，会调用toString方法。</p><p>由类Object定义的默认的toString方法揭示了有关内置对象的内部类型信息。<br>默认的toString方法返回的字符串形式总是[object class]，class是对象的内部类型，通常对应于该对象的构造函数名。例如，Array对像的class值是Array，Function对象的class值是“Function”，Date对象的class值是“Date”，内部Math对象的class值是“Math”，所有Error对象的的class值是“Error”，用户定义的对象（例如Complex）的class值是“Object”。</p><h4 id="6-3-toLocaelString方法"><a href="#6-3-toLocaelString方法" class="headerlink" title="6.3 toLocaelString方法"></a>6.3 toLocaelString方法</h4><p>除了toString外，Object类还定义了toLocaleString方法，该方法返回该对象局部化的字符串表示。Object类默认定义的toLocaelString方法，本身并不做任何局部化，返回值和toString一样。但是Object的子类可以定义自己的toLocaleString方法，Array，Number,Date都定义了自己的toLocaelString方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let now &#x3D; new Date();</span><br><span class="line">now.toString()</span><br><span class="line">&quot;Fri Jan 08 2021 14:05:09 GMT+0800 (中国标准时间)&quot;</span><br><span class="line">now.toLocaleString()</span><br><span class="line">&quot;2021&#x2F;1&#x2F;8 下午2:05:09&quot;</span><br><span class="line"></span><br><span class="line">let num &#x3D; new Number(1);</span><br><span class="line">num.toString()</span><br><span class="line">&quot;1&quot;</span><br><span class="line">num.toLocaleString()</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure><h4 id="6-4-valueOf方法"><a href="#6-4-valueOf方法" class="headerlink" title="6.4 valueOf方法"></a>6.4 valueOf方法</h4><p>valueOf方法和toString方法非常相似，当需要把对象转化为非字符串之外的原始类型（通常是数字）时，就需要调用它。这个函数返回的是能代表this关键字所引用的对象的值的类型。</p><p>由于对象没有定义为原始类型的值，所以大多数对象都没有等价的原始值，因此由Object定义的valueOf方法不执行任何转换，只是返回调用它的对象。像Number和Boolean这样的类具有明显的原始等价值。</p><p>有时你可以定义一个合理的原始等价类型的类，需要为类定义一个valueOf方法，例如Complex，就定义了一个valueOf方法，返回实数部分。定义valueOf方法时，当某些环境中，当执行对象转字符串时，方法valueOf的优先级比toString高，这样当你定义了一个valueOf方法时，如果想转为字符串需要明确的调用toString方法，以Complex为例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Complex(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">alert(“c”+c);<span class="comment">//调用valueOf方法显示“c=3”</span></span><br><span class="line">alert(“c”+c.toString);<span class="comment">//显示“c=&#123;3,3&#125;”</span></span><br></pre></td></tr></table></figure><h4 id="6-5-hasOwnProperty"><a href="#6-5-hasOwnProperty" class="headerlink" title="6.5 hasOwnProperty"></a>6.5 hasOwnProperty</h4><p>如果对象局部定义了一个非继承的属性，属性名是由字符串实际参数指定的，那么该值返回true，否则返回false，例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.hasOwnProperty(“unde”);<span class="comment">//false</span></span><br><span class="line">o.hasOwnProperty(“toString”);<span class="comment">//false,toString 是一个继承属性</span></span><br><span class="line"><span class="built_in">Math</span>.hasOwnProperty(“cos”);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="6-6-propertyIsEnumerable-方法"><a href="#6-6-propertyIsEnumerable-方法" class="headerlink" title="6.6 propertyIsEnumerable()方法"></a>6.6 propertyIsEnumerable()方法</h4><p>如果对象定义了一个属性，由字符串实际参数指定的，而且该属性可以用for/in遍历出来，那么该方法返回true，否则返回false，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</span><br><span class="line">o.propertyIsEnumerable(“x”); <span class="comment">//true</span></span><br><span class="line">o.propertyIsEnumerable(“y”); <span class="comment">//false</span></span><br><span class="line">o.propertyIsEnumerable(“valueOf”); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>ECMAScript标准规定该方法只考虑对象直接定义的属性，不考虑对象的继承属性。</p><h4 id="6-7-isPrototypeOf方法"><a href="#6-7-isPrototypeOf方法" class="headerlink" title="6.7 isPrototypeOf方法"></a>6.7 isPrototypeOf方法</h4><p>如果调用对象是实际参数指定对象的原型对象，那么返回true，否则返回false，该方法用途和constructor属性相似：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(o);<span class="comment">//true  o.constructor == Object</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.isPrototypeOf(<span class="built_in">Object</span>); <span class="comment">//true  Object.constructor == Function</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-第七章-函数</title>
      <link href="/ZJY.github.io/2021/01/13/javascript-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%87%BD%E6%95%B0/"/>
      <url>/ZJY.github.io/2021/01/13/javascript-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="第七章-函数"><a href="#第七章-函数" class="headerlink" title="第七章-函数"></a>第七章-函数</h2><h3 id="1-函数定义和调用"><a href="#1-函数定义和调用" class="headerlink" title="1. 函数定义和调用"></a>1. 函数定义和调用</h3><p>定义函数最常用方法是function语句，该语句由function关键字构成，后面跟：</p><ul><li>函数名</li><li>一个括号括起来的参数列表，参数可选，多个参数用逗号分隔</li><li>构成函数主体的javascript语句，大括号括起来</li></ul><p>定义函数时可以使用个数可变的参数，而且函数既可以有return语句，也可以没有return语句，return语句使函数停止运行，并把结果返回给函数调用者。如果没有return语句，返回给调用者undefined.</p><h3 id="1-1-嵌套的函数"><a href="#1-1-嵌套的函数" class="headerlink" title="1.1 嵌套的函数"></a>1.1 嵌套的函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    funtion <span class="function"><span class="title">add</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> add(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-Function构造函数"><a href="#1-2-Function构造函数" class="headerlink" title="1.2 Function构造函数"></a>1.2 Function构造函数</h3><p>function语句并不是创建函数的唯一方式，在ECMAScript v1和javascript 1.1中还可以使用Function()构造函数和new运算符。<br>var f = new Function(“x”,”y”,”return x*y;”)<br>Function构造函数可以接收任意数量参数，最后一个参数是函数主体，没有参数可只传函数主体字符串参数。</p><h3 id="1-3-函数直接量"><a href="#1-3-函数直接量" class="headerlink" title="1.3 函数直接量"></a>1.3 函数直接量</h3><p>函数直接量是一个表达式，可以定义一个匿名函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">funtion <span class="function"><span class="title">f</span>(<span class="params">x,y</span>)</span>&#123;<span class="keyword">return</span> x*y；&#125; <span class="comment">//function语句</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Function</span>(“x”,”y”,”<span class="keyword">return</span> x*y;”)   <span class="comment">//Function构造函数</span></span><br><span class="line"><span class="keyword">var</span>  f = <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>) </span>&#123; <span class="keyword">return</span> x*y; &#125; <span class="comment">//函数直接量</span></span><br></pre></td></tr></table></figure><p>虽然函数直接量定义的是未命名函数，但也可以指定名称，在递归函数非常有用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = funtion <span class="function"><span class="title">fact</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x*fact(x-<span class="number">1</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码虽然定义了一个未命名函数，并把对他引用存储在变量f中，但并没有真正创建一个fact函数，只允许用这个名称引用自身</p><p>和Function构造函数一样，函数直接量创建的是匿名函数，而且不会自动地将这个函数存储在属性中。但是比起构造函数来，函数直接量又一个明显的优点。由Function构造函数创建的函数的主体，必须用一个字符串说明，用这种方式表达一个长而复杂的函数是非常笨拙的。<br>但是函数直接量的主体确是使用了javascript的语法。而且函数直接量只被解析和编译一次，而作为字符串传递给Function()函数的javascript代码则在每次调用该构造函数时只需被解析和编译一次。</p><h3 id="2-作为数据的函数"><a href="#2-作为数据的函数" class="headerlink" title="2. 作为数据的函数"></a>2. 作为数据的函数</h3><p>除了作为变量的值，还可以作为对象的属性，称为方法</p><h3 id="3-函数的作用域：调用对象"><a href="#3-函数的作用域：调用对象" class="headerlink" title="3. 函数的作用域：调用对象"></a>3. 函数的作用域：调用对象</h3><p>javascript函数的主体是在局部作用域中执行的，这个作用域通过把调用对象添加到作用域的头部创建的。<br>因为调用对象是作用域链的一部分，所以在函数体内可以把这个对象属性作为变量来访问。<br>var语句声明的变量作为调用对象的属性，函数形参也可用于对象的属性。</p><p>除了局部变量和形式参数外，调用对象还定义了一个属性：arguments，这个属性引用了另外一个Arguments对象。arguments应作为保留字。</p><h3 id="4-函数的实际参数：Arguments对象"><a href="#4-函数的实际参数：Arguments对象" class="headerlink" title="4. 函数的实际参数：Arguments对象"></a>4. 函数的实际参数：Arguments对象</h3><p>在一个函数体内，标识符arguments具有特殊含义。他是调用对象的一个属性，用来引用Arguments对象。Arguments对象就像一个数组，可以通过数字获取传递给函数的参数值。<br>但它并非真正但Array对象。用参数名改变参数值也会改变通过arguments[]取的值。</p><h4 id="4-1-属性callee"><a href="#4-1-属性callee" class="headerlink" title="4.1 属性callee"></a>4.1 属性callee</h4><p>除了数组元素，arguments对象还定义了callee属性。用来引用当前正在执行的函数。对未命名的函数非常有用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="built_in">arguments</span>.callee(x-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-函数的属性和方法"><a href="#5-函数的属性和方法" class="headerlink" title="5. 函数的属性和方法"></a>5. 函数的属性和方法</h3><p>在javascript程序中，函数可以用作数值，也可以通过Function()构造函数创建函数，所以函数是对象，Function对象，拥有属性和方法。</p><h4 id="5-1-属性length"><a href="#5-1-属性length" class="headerlink" title="5.1 属性length"></a>5.1 属性length</h4><p>在函数主体中，arguments数组的length属性指定了函数实际参数数目。<br>但是函数自身的length属性并非如此，它是只读特性，返回的是函数形式参数列表中声明的形式参数的数目。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = args.length; <span class="comment">//实际的参数个数</span></span><br><span class="line">    <span class="keyword">var</span> actualLen = args.callee.length <span class="comment">//声明的参数个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-属性prototype"><a href="#5-2-属性prototype" class="headerlink" title="5.2 属性prototype"></a>5.2 属性prototype</h4><p>每个函数都有一个prototype属性，引用的是预定义的原型对象。原型对象在使用new运算符把函数作为构造函数时起作用。它在定义新的对象类型时起着非常重要的作用。</p><h4 id="5-3-定义你自己的函数属性"><a href="#5-3-定义你自己的函数属性" class="headerlink" title="5.3 定义你自己的函数属性"></a>5.3 定义你自己的函数属性</h4><p>当函数需要在调用过程中始终不变的一个值时，使用Function对象的属性比定义一个全局变量更加方便。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test.counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> test.counter++;</span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">//0</span></span><br><span class="line">test(); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><h4 id="5-4-方法apply-和call"><a href="#5-4-方法apply-和call" class="headerlink" title="5.4 方法apply()和call()"></a>5.4 方法apply()和call()</h4><p>所有函数都定义了apply()和call()方法。<br>第一个参数都是要调用的函数对象，在函数体内这个关键词是this的值。<br>call()的剩余参数是传递给调用函数的值，例如要把两个数字传递给函数f，并把它作为对象o的方法调用，可以使用如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.call(o, <span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>apply()要传递的参数是一个数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.apply(o, [<span class="number">1</span>, <span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p>比如要找到数字数组中最大值，可以用apply方法把数组传递给Math.max:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> biggest = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, array_number);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-第六章-语句</title>
      <link href="/ZJY.github.io/2021/01/13/javascript-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%AF%AD%E5%8F%A5/"/>
      <url>/ZJY.github.io/2021/01/13/javascript-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="第六章-语句"><a href="#第六章-语句" class="headerlink" title="第六章-语句"></a>第六章-语句</h2><h3 id="1-表达式语句"><a href="#1-表达式语句" class="headerlink" title="1. 表达式语句"></a>1. 表达式语句</h3><p>递增（++）和递减（–）运算符，delete运算符，函数调用，被作为语句使用，因为都改变了值，而不仅仅是表达式的一部分。</p><h3 id="2-复合语句"><a href="#2-复合语句" class="headerlink" title="2. 复合语句"></a>2. 复合语句</h3><p>复合语句就是用花括号括起来，将几个语句联合起来形成语句块。js语句可以包含别的语句，这样的语句叫复合语句。<br>正式的javascript语法规定每个复合语句可以包含一个子语块。那么使用语句块可以将任意数量语句放在子语块中。<br>javascript解释器执行复合语句时，按照编写顺序执行语句。通常javascript语句会执行完所有语句，但复合语句中若含有break语句、continue语句、return或throw语句，或它引发了错误等会被终止。</p><h3 id="3-if语句"><a href="#3-if语句" class="headerlink" title="3. if语句"></a>3. if语句</h3><p>条件控制语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(express) <span class="comment">//null、undefined、0、“”、NaN值为false</span></span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><h3 id="4-else-if语句"><a href="#4-else-if语句" class="headerlink" title="4. else if语句"></a>4. else if语句</h3><p>用来执行多个条件语句，实际上是if/else嵌套</p><h3 id="5-switch语句"><a href="#5-switch语句" class="headerlink" title="5. switch语句"></a>5. switch语句</h3><p>用于重复检测同一个变量的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(express)&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span>(n)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        statement</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        statement</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数调用中可以用return替换break语句.<br>case使用===等同运算符匹配的，如果没有匹配值就执行default:，如果没有default：就跳过主体，default:语句可以放置任何位置。</p><h3 id="6-while语句"><a href="#6-while语句" class="headerlink" title="6. while语句"></a>6. while语句</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(express)</span><br><span class="line">    statement</span><br><span class="line">    <span class="comment">//express表达式值为true，执行statement循环体</span></span><br></pre></td></tr></table></figure><h3 id="7-do-while语句"><a href="#7-do-while语句" class="headerlink" title="7. do/while语句"></a>7. do/while语句</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">while</span>(express);</span><br></pre></td></tr></table></figure><p>循环体至少会被执行一次。用分号结尾.</p><h3 id="8-for语句"><a href="#8-for语句" class="headerlink" title="8. for语句"></a>8. for语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(initalize; test ; increment) &#x2F;&#x2F;初始化、检测、更新</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><h3 id="9-for-in语句"><a href="#9-for-in语句" class="headerlink" title="9. for/in语句"></a>9. for/in语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(variable in object)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><p>variable是一个变量名，声明一个变量的var语句或者对象的一个属性或者数组的一个元素。</p><p>object是一个对象名或者计算结果为对象的表达式。for/in循环主体对object对象对每个属性执行一次，循环体执行之前，对象的属性名会被作为字符串赋值给variable.在循环体内部可以通过object[varible]访问属性的值    。variable可以是任意表达式。</p><p>for/in循环体并没有指定将对象属性赋给循环变量的顺序。for/in会遍历对象所有可能属性。对象属性被标记为可读的、永久的（不可删除的）、不可枚举的不可被遍历出来。</p><h3 id="10-标签语句"><a href="#10-标签语句" class="headerlink" title="10. 标签语句"></a>10. 标签语句</h3><p>identifier：statement，标签语句：标识符加冒号<br>标识符identifier可以是合法的js标识符，不能是保留字，标识符不同于变量名和函数名，所以不用担心重名。给语句添加标识符，起一个名字可以在任意地方引用。</p><h3 id="11-break语句"><a href="#11-break语句" class="headerlink" title="11. break语句"></a>11. break语句</h3><p>break语句会使包含在最内层的循环体立即结束或退出switch语句。语句很简单：<br>    break;<br>当break后面跟标签时，它会跳到标签语句结尾或者终止这个语句。break labelname；</p><h3 id="12-continue语句"><a href="#12-continue语句" class="headerlink" title="12. continue语句"></a>12. continue语句</h3><ul><li><p>continue语句退出当前循环，执行下一次循环，continue;</p></li><li><p>continue语句可以和标签一起使用在ecmascript v3和js1.2中，continue labelname;</p></li><li><p>continue语句只可以出现在while、for、do/while、for/in循环语句体中。<br>执行continue语句时，当前迭代就会终止，开始下一次迭代，这对不同循环是不同的：</p><ul><li>while循环中，会再次检测循环条件，如果是true，继续下一次迭代</li><li>do/while循环中，会跳到循环的底部，开始下一次迭代前首先判断循环条件</li><li>for循环中，会先更新循环变量值，再判断循环条件是否继续下一次迭代</li><li>for/in循环中，以下一个循环属性赋值给变量开始新的迭代</li></ul></li></ul><h3 id="13-var语句"><a href="#13-var语句" class="headerlink" title="13. var语句"></a>13. var语句</h3><p>var语句允许你明确的声明一个或多个变量。如果声明多个变量，用逗号隔开，并可选的初始化声明的变量值。</p><p>var语句通过在封闭函数的调用对象中创建同名的属性来定义变量，如果不在函数内，就在全局对象中创建同名属性来定义变量。</p><p>由var语句创建的特性不能被delete运算符删除。</p><h3 id="14-function语句"><a href="#14-function语句" class="headerlink" title="14. function语句"></a>14. function语句</h3><p>function语句定义了js函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcname</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数体内语句定义时不会被执行，在使用函数调用（）运算符调用时才执行编译。<br>函数定义在解析时发生而不是在运行时发生。<br>函数定义通常出现在代码顶层，它们也可以嵌套在其他函数定义中，但是只能嵌套在函数顶层定义中，也就是说函数定义不能出现在if语句，while循环或其他语句中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(f(<span class="number">4</span>)); <span class="comment">//16，可以在定义f()前调用它</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="number">0</span>; <span class="comment">//该语句重写属性f</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x*x&#125;</span><br><span class="line">alert(f); <span class="comment">//0，函数f已经被变量f覆盖</span></span><br></pre></td></tr></table></figure><h3 id="15-return语句"><a href="#15-return语句" class="headerlink" title="15. return语句"></a>15. return语句</h3><p>运算符()调用函数是一个表达式，表达式的值通过return语句返回。return只能出现在函数体内，出现在其他地方会造成语法错误。return expression;<br>在执行return语句时，会先计算表达式的值，然后返回它的值作为函数的值</p><h3 id="16-throw语句"><a href="#16-throw语句" class="headerlink" title="16. throw语句"></a>16. throw语句</h3><p>所谓异常（exception）就是一个信号，说明发生了某种异常状况或错误。<br>抛出（throw）一个异常，就是用信号通知发生了错误或异常状况。<br>捕获（catch）一个异常就是处理它，即采取必要或适当的行为从异常恢复。在js中，当发生了运行时错误或用throw语句就会抛出异常。<br>throw expression;expression可以是任意类型，通常是Error类或子类的实例。<br>在抛出异常时，javascript解释器会立即停止正常的程序执行，跳到距离最近的异常处理器，即catch语句中。<br>如果抛出的异常中没有catch语句，即会检测次高级封闭代码块，查看是否有异常处理器，直到没有找到为止。</p><h3 id="17-try-catch-finally语句"><a href="#17-try-catch-finally语句" class="headerlink" title="17. try/catch/finally语句"></a>17. try/catch/finally语句</h3><p>try/catch/finally是javascript的异常处理机制。<br>try语句定义异常需要被处理的代码块。<br>catch发生异常时调用的语句块。<br>finally存放清除代码，无论try发生什么，都会被执行。<br>catch和finally都是可选的。但是try块至少跟一个catch或finally块。</p><p>通常情况下,控制流到达try块的尾部,然后开始执行 finally块,以便进行清除操作。如果由于 return语句、 continue句或 break语句使控制流离开了try块,那么在控制流转移到新目的地前, finally块就会被执行。</p><p>如果异常发生在try块中,而且存在一个相关的 catch块处理异常,控制流首先将转移到 catch块,然后再转移到fina1l块。如果没有处理异常的局部 catch块,控制流首先将转移到 finally块,然后向上传播到最近的能够处理异常的 catch从句。</p><p>如果 finally块自身用 return语句、 continue语句、 break语句或 throw语句转移了控制流,或者调用了抛出异常的方法改变了控制流,那么等待的控制流转移将被舍弃,并进行新的转移。例如,如果 finally从句抛出了一个异常,那么该异常将代替处于抛出过程中的异常。如果 finally从句运行到了 return语句,那么即使已经抛出了一个异常,而且该异常还没有被处理,该方法也会正常返回。</p><h3 id="18-with语句"><a href="#18-with语句" class="headerlink" title="18. with语句"></a>18. with语句</h3><p>with语句用于暂时修改作用域链。with (object) statement<br>这一语句能够有效的将object添加到作用域链的顶部，然后执行statement语句，再把作用域链恢复到初始状态。<br>在实际应用中,使用with语句可以减少大量的输入。例如,在客户端的 JavaScript中,深度嵌套的对象层次很常用。例如,可以输入如下的表达式来访问一个HTML表单的元素:</p><p> frames[1].document.forms[0].address.value</p><p>如果需要多次访问这个表单,可以使用with语句将这个表单添加到作用域链中:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">with</span>(<span class="params">frames [<span class="number">1</span>].<span class="built_in">document</span>.forms[<span class="number">0</span>]</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//此处直接访问表单元素</span></span><br><span class="line">    name.value = ‘’;</span><br><span class="line">    address.value = ‘’;</span><br><span class="line">    email.value = ‘’;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然有时使用with语句比较方便,但是人们反对使用它。使用了with语句的javaScript代码很难优化,因为它的运行速度比不使用with语句的等价代码要慢得多。而且,在with语句中的函数定义和变量初始化可能会产生令人惊讶的、相抵触的行为。因此,我们建议避免使用with语句。</p><p>注意,还有其他的、极为合理的方法可以用来节省输入。例如,上面使用with语句可重写为:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> form= frames[<span class="number">1</span>]. <span class="built_in">document</span>. forms[<span class="number">0</span>]</span><br><span class="line">form.name. value=<span class="string">&quot;</span></span><br><span class="line"><span class="string">form. address. value =&quot;</span><span class="string">&quot; form. email. value =&quot;</span><span class="string">&quot;</span></span><br></pre></td></tr></table></figure><h3 id="19-空语句"><a href="#19-空语句" class="headerlink" title="19. 空语句"></a>19. 空语句</h3><p>javascript中最后一个合法语句是空语句: ;</p><p>执行空语句显然不会产生任何作用,也不会执行任何动作。你可能认为使用这样一个语句是毫无意义的,但实践证明,当你想创建一个具有空主体的循环时,空语句是有用的。例如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化数组a</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt; a. length; a[i++] =<span class="number">0</span>) ;</span><br></pre></td></tr></table></figure><p>注意,在for循环、 while循环或者if语句的右括号后加分号会产生bug,这些bug很难被检测出来。例如,下面的代码产生的结果并不是作者想要的:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((a==<span class="number">0</span>) || (b==<span class="number">0</span>));/这行什么都不做</span><br><span class="line">o =<span class="literal">null</span>; <span class="comment">//这行总会被执行</span></span><br></pre></td></tr></table></figure><p>当你打算使用空语句时,最好在代码中使用注释,以清楚地说明是有目的地这样做。例如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;a. length;a[i++]=<span class="number">0</span>)<span class="comment">/*空函数体*/</span> ;</span><br></pre></td></tr></table></figure><h3 id="20-javascript语句小结"><a href="#20-javascript语句小结" class="headerlink" title="20.javascript语句小结"></a>20.javascript语句小结</h3><table><thead><tr><th align="center">语句</th><th align="center">语法</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">break</td><td align="center">break; <br> break labelname;</td><td align="center">退出最内层循环或者退出switch语句，又或者退出label指定的语句</td></tr><tr><td align="center">case</td><td align="center">case expression</td><td align="center">在switch语句中标记一个语句</td></tr><tr><td align="center">continue</td><td align="center">continue;<br>  continue labelname;</td><td align="center">重新开始新的循环或开始指定的label循环</td></tr><tr><td align="center">default</td><td align="center">default:</td><td align="center">在switch语句中指定默认语句</td></tr><tr><td align="center">do/while</td><td align="center">do statement <br> while(expression)</td><td align="center">while循环另一种形式</td></tr><tr><td align="center">空语句</td><td align="center">;</td><td align="center">什么都不做</td></tr><tr><td align="center">for</td><td align="center">for(init;test;increment) statement</td><td align="center">循环</td></tr><tr><td align="center">for/in</td><td align="center">for(variable in object) statement</td><td align="center">遍历一个对象的属性</td></tr><tr><td align="center">function</td><td align="center">function funname(expression){statement}</td><td align="center">函数声明</td></tr><tr><td align="center">if/else</td><td align="center">if(expression){statement} <br> else{}</td><td align="center">条件控制</td></tr><tr><td align="center">label</td><td align="center">identifier: statement</td><td align="center">给语句块指定一个标识符</td></tr><tr><td align="center">return</td><td align="center">return expression</td><td align="center">返回函数值</td></tr><tr><td align="center">switch</td><td align="center">switch(expression){statement}</td><td align="center">由case或default语句标记的多分支语句</td></tr><tr><td align="center">throw</td><td align="center">throw exception</td><td align="center">抛出一个异常</td></tr><tr><td align="center">try</td><td align="center">try{statement} <br> catch(e){statement}<br>  finally{statement}</td><td align="center">捕捉一个异常</td></tr><tr><td align="center">var</td><td align="center">var name1 = value</td><td align="center">声明或初始化变量</td></tr><tr><td align="center">while</td><td align="center">while(expression){statement}</td><td align="center">循环</td></tr><tr><td align="center">with</td><td align="center">with(object) statement</td><td align="center">扩展当前作用域链（不支持使用）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-第五章-表达式和运算符</title>
      <link href="/ZJY.github.io/2021/01/10/javascript-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/ZJY.github.io/2021/01/10/javascript-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="第五章-表达式和运算符"><a href="#第五章-表达式和运算符" class="headerlink" title="第五章-表达式和运算符"></a>第五章-表达式和运算符</h2><h3 id="1-表达式"><a href="#1-表达式" class="headerlink" title="1. 表达式"></a>1. 表达式</h3><p>最简单的表达式可以是直接量或者变量名。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">‘javascript’</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line">num</span><br></pre></td></tr></table></figure><p>直接量表达式的值是直接量本身，变量表达式的值是变量存放的值或引用的值。</p><h3 id="2-运算符概述"><a href="#2-运算符概述" class="headerlink" title="2. 运算符概述"></a>2. 运算符概述</h3><p>有些运算符由标点符号表示+ -，有些是由关键字表示，delete /instanceof</p><table><thead><tr><th align="center">P（运算符优先级）</th><th align="center">A（结合性：L/R）</th><th align="center">运算符</th><th align="center">运算数类型</th><th align="center">所执行的操作</th></tr></thead><tbody><tr><td align="center">15</td><td align="center">L</td><td align="center">.</td><td align="center">对象，标识符</td><td align="center">属性存取</td></tr><tr><td align="center"></td><td align="center">L</td><td align="center">[]</td><td align="center">数组，整数</td><td align="center">数组下标</td></tr><tr><td align="center"></td><td align="center">L</td><td align="center">()</td><td align="center">函数，参数</td><td align="center">函数调用</td></tr><tr><td align="center"></td><td align="center">R</td><td align="center">new</td><td align="center">构造函数调用</td><td align="center">创建新对象</td></tr><tr><td align="center">14</td><td align="center">R</td><td align="center">++</td><td align="center">lvalue</td><td align="center">先递增或后递增的运算（一元的）</td></tr><tr><td align="center"></td><td align="center">R</td><td align="center">–</td><td align="center">lvalue</td><td align="center">先递减或后递减的运算（一元的）</td></tr><tr><td align="center"></td><td align="center">R</td><td align="center">-</td><td align="center">数字</td><td align="center">一元减法（负）</td></tr><tr><td align="center"></td><td align="center">R</td><td align="center">+</td><td align="center">数字</td><td align="center">一元加法）</td></tr><tr><td align="center"></td><td align="center">R</td><td align="center">~</td><td align="center">数字</td><td align="center">按位取补码的操作（一元的）</td></tr><tr><td align="center"></td><td align="center">R</td><td align="center">!</td><td align="center">布尔值</td><td align="center">取逻辑补码的操作（一元的）</td></tr><tr><td align="center"></td><td align="center">R</td><td align="center">delete</td><td align="center">lvalue</td><td align="center">删除一个属性（一元的）</td></tr><tr><td align="center"></td><td align="center">R</td><td align="center">typeof</td><td align="center">任意</td><td align="center">返回数据类型（一元的）</td></tr><tr><td align="center"></td><td align="center">R</td><td align="center">void</td><td align="center">任意</td><td align="center">返回未定义的值（一元的）</td></tr><tr><td align="center">13</td><td align="center">L</td><td align="center">*,/,%</td><td align="center">数字</td><td align="center">乘法，除法， 取余运算</td></tr><tr><td align="center">12</td><td align="center">L</td><td align="center">+,-</td><td align="center">数字</td><td align="center">加法，减法运算</td></tr><tr><td align="center"></td><td align="center">L</td><td align="center">+</td><td align="center">字符串</td><td align="center">连接字符串</td></tr><tr><td align="center">11</td><td align="center">L</td><td align="center">&lt;&lt;</td><td align="center">整数</td><td align="center">左移</td></tr><tr><td align="center"></td><td align="center">L</td><td align="center">&gt;&gt;</td><td align="center">整数</td><td align="center">带符号扩展的右移</td></tr><tr><td align="center"></td><td align="center">L</td><td align="center">&gt;&gt;&gt;</td><td align="center">整数</td><td align="center">带零扩展的右移</td></tr><tr><td align="center">10</td><td align="center">L</td><td align="center">&lt;, &lt;=</td><td align="center">数字或字符串</td><td align="center">小于或小于等于</td></tr><tr><td align="center"></td><td align="center">L</td><td align="center">&gt;, &gt;=</td><td align="center">数字或字符串</td><td align="center">大于或大于等于</td></tr><tr><td align="center"></td><td align="center">L</td><td align="center">instanceof</td><td align="center">对象，构造函数</td><td align="center">检测对象类型</td></tr><tr><td align="center"></td><td align="center">L</td><td align="center">in</td><td align="center">字符串，对象</td><td align="center">检查一个属性是否存在</td></tr><tr><td align="center">9</td><td align="center">L</td><td align="center">==</td><td align="center">任意</td><td align="center">测试相等性</td></tr><tr><td align="center"></td><td align="center">L</td><td align="center">!=</td><td align="center">任意</td><td align="center">测试非相等性</td></tr><tr><td align="center"></td><td align="center">L</td><td align="center">===</td><td align="center">任意</td><td align="center">测试等同性</td></tr><tr><td align="center"></td><td align="center">L</td><td align="center">!==</td><td align="center">任意</td><td align="center">测试非等同性</td></tr><tr><td align="center">8</td><td align="center">L</td><td align="center">&amp;</td><td align="center">整数</td><td align="center">按位与操作</td></tr><tr><td align="center">7</td><td align="center">L</td><td align="center">^</td><td align="center">整数</td><td align="center">按位异或操作</td></tr><tr><td align="center">6</td><td align="center">L</td><td align="center">`</td><td align="center">`</td><td align="center">整数</td></tr><tr><td align="center">5</td><td align="center">L</td><td align="center">&amp;&amp;</td><td align="center">布尔值</td><td align="center">逻辑与操作</td></tr><tr><td align="center">4</td><td align="center">L</td><td align="center">`</td><td align="center"></td><td align="center">`</td></tr><tr><td align="center">3</td><td align="center">R</td><td align="center">？：</td><td align="center">布尔值、任意、任意</td><td align="center">条件运算符</td></tr><tr><td align="center">2</td><td align="center">R</td><td align="center">=</td><td align="center">任意</td><td align="center">赋值运算</td></tr><tr><td align="center"></td><td align="center">R</td><td align="center">*=，/=，%=，+=，-=，&lt;&lt;=,&gt;&gt;=,&gt;&gt;&gt;=,&amp;=,</td><td align="center">=</td><td align="center">任意</td></tr><tr><td align="center">1</td><td align="center">L</td><td align="center"></td><td align="center">任意</td><td align="center">多重计算的操作</td></tr></tbody></table><h4 id="2-1-运算数的个数"><a href="#2-1-运算数的个数" class="headerlink" title="2.1 运算数的个数"></a>2.1 运算数的个数</h4><p>一元运算符: -3 //取反<br>二元运算符： +<br>三元运算符： ?:</p><h4 id="2-2-运算数的优先级"><a href="#2-2-运算数的优先级" class="headerlink" title="2.2 运算数的优先级"></a>2.2 运算数的优先级</h4><p>乘法和除法是优先与加法和减法执行的，赋值的操作优先级很低，几乎最后执行。用括号可以提高优先级。</p><h4 id="2-3-运算数的结合性"><a href="#2-3-运算数的结合性" class="headerlink" title="2.3 运算数的结合性"></a>2.3 运算数的结合性</h4><p>L表示结合性从左到右，R表示结合性从右到左，一个运算符的结合性说明了优先级相等时执行操作的顺序。</p><h3 id="3-算术运算符"><a href="#3-算术运算符" class="headerlink" title="3. 算术运算符"></a>3. 算术运算符</h3><p><b>加法运算符（+）：</b><br>    运算符“+”可以对数字进行加法运算，也可以对字符串进行连接操作。如果一个运算数是字符串，那么另一个运算数会被转换成字符串，进行连接操作。如果“+”运    算符对一个运算数是对象，那么它会把对象转换成可以进行加法运算或者连接操作对数字或字符串，这一转换通过调用对象的valueOf()/toString()来执行的。</p><p><b>减法运算符（-）：</b><br>    把运算符“-”用于二元操作时，它将从第一个运算数减取第二个运算数。如果运算数是非数字的，会将它们转换成数字。</p><p><b>乘法运算符（<em>）：</b><br>    运算符“</em>”会把两个运算数相乘，如果运算数是非数字的，运算符“*”会将它们转换成数字。</p><p><b>除法运算符（/）：</b><br>    运算符“/”将用第一个运算数除以第二个运算数。如果运算数为非数字，则运算符“/”会将它们转为数字。除数为0的结果为正无穷或负无穷。0/0结果为NaN。<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>/<span class="number">0</span> <span class="comment">// Infinity</span></span><br><span class="line">-<span class="number">4</span>/<span class="number">0</span> <span class="comment">//-Infinity</span></span><br><span class="line"><span class="number">0</span>/<span class="number">0</span> <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure><br><b>模运算符（%）：</b><br>    模运算符计算的是第一个运算数对第二个运算数对模，即余数。如果运算数是非数字的，运算符“%”会将它们转换为数字。结果和第一个运算数符号相同。<br>    5%2 // 1<br>    -5%2 //-1<br>    取模运算符也适用于浮点型数字。</p><p><b>一元减法运算符（-）：</b><br>    当“-”被用于一元操作前（一个运算数前），它将执行一元取反操作。如果运算数是非数字的，运算符“-”会将它们转换为数字</p><p><b>一元加法运算符（+）：</b><br>    var a = +10000;”+”什么都没做，只计算参数的值。对于非数字型的运算符，会将运算数转为数字，如果不能被转换，将返回NaN.<br>    +’123’ //123<br>    +’1we’ //NaN</p><p><b>递增运算符（++）：</b><br>    运算符“++”对唯一运算数进行递增操作，如果运算数为非数字，会转为数字。<br>    i = 1; j = ++i;  // i:2,j:2<br>    i = 1; k = i++; //i:2, k:1<br>    如果运算符位于运算数前，即先递增，然后用运算数增长后值计算。<br>    如果运算符位于运算数后，即先运算，后递增，运算的是递增前的值。</p><p><b>递减运算符（–）：</b><br>    运算符“–”是对它惟一的数字运算数进行逆减操作的(如每次减1)，这个运算数必须是一个变量、数组的一个元素或者对象的一个属性。如果该变量元素或属性的值不是数字，运算符“-”首先会将它转换成一个数字。和运算符“++”一样，运算符“-”的实际行为是由它相对于运算数的位置决定的。<br>    如果它位于运算数之前，它就先减少运算数的值，并且返回减少后的运算数的直。如果它位于运算数之后，它将减少运算数的值，但是返回的却是没有减少的值。</p><h3 id="4-相等运算符"><a href="#4-相等运算符" class="headerlink" title="4. 相等运算符"></a>4. 相等运算符</h3><p>相等运算符“==”和等同运算符“===”用于计算两个值是否相等，根据结果返回布尔值。</p><h4 id="4-1-相等运算符（-）和等同运算符（-）"><a href="#4-1-相等运算符（-）和等同运算符（-）" class="headerlink" title="4.1 相等运算符（==）和等同运算符（===）"></a>4.1 相等运算符（==）和等同运算符（===）</h4><p>“==”和“===”都用于检测两个值是否相等。这两个运算符都接受任意类型都运算数。“===”是等同运算符，它采用严格都同一性定义检测两个运算数是否相同。“==”是相等运算符，它采用比较宽松的同一性（允许类型转换）定义检测两个数是否相等。</p><p><b>判断===运算符比较的两个值是否完全相等：</b></p><ul><li><p>如果两个值的类型不同，它们就不相等.</p></li><li><p>如果两个值是数字，而且值相同，那么除非其中一个或两个值都为NaN，否则它们是等同的。值NaN永远不会与其他任何值等同，包括它自身。可用全局函数isNaN（）检测值是否是NaN。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span>==<span class="literal">NaN</span> <span class="comment">//false   NaN===NaN //false</span></span><br></pre></td></tr></table></figure></li><li><p>如果两个值是字符串，而且串中同一位置上字符完全相同，那么它们就是完全等同。如果字符串内容或长度不同，它们就不是等同的。</p></li><li><p>如果两个值都是布尔值true或false，那么它们等同。</p></li><li><p>如果两个值引用的是同一个对象，数组或函数，那么它们完全等同。如果它们引用是不同的对象，即使这两个对象具有完全相同的属性或具有完全相同的元素，它们也不等同。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;<span class="keyword">var</span> b = a; <span class="keyword">var</span> c = &#123;&#125;; <span class="keyword">var</span> d = c; b == d; <span class="comment">//false</span></span><br></pre></td></tr></table></figure></li><li><p>如果两个值都是null或undefined，那么它们完全相同。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true null === undefined //false </span></span><br></pre></td></tr></table></figure></li></ul><p><b>判断==运算符比较的两个值是否相等：</b></p><ul><li>如果两个值具有相同的类型，判断两个值是否相同，如果相同就相等</li><li>如果两个值类型不同，仍然有可能相等。<ul><li>如果一个值是null，另一个值是undefined，它们相等</li><li>如果一个值是数字，另一个值是字符串，把字符串转为数字，再用转换后值比较。</li><li>如果一个值是true,将它转换为1，再进行比较，如果是false，转换为0再比较</li><li>如果一个值是对象，另一个值是数字或字符串，将对象转换为原始类型的值再进行比较。可以使用对象的toString()方法或valueOf()方法将对象转换为原始类型的值。javascript核心语言的内部类通常先尝试valueOf()转换，再尝试toString()转换，但对于Date类，则先执行toString()转换。不属于javascript核心语言的对象可以采用js实现定义的方式把自身转换为原始数值。</li><li>其他的数值组合是不相等的。</li></ul></li></ul><p>如下代码是一个测试相等性的例子，带有类型转换： “1” == true ,true会先转换为1，字符串“1”会转为数字1，结果为true</p><h4 id="4-2-不等运算符（-）和不等同运算符（-）"><a href="#4-2-不等运算符（-）和不等同运算符（-）" class="headerlink" title="4.2 不等运算符（!=）和不等同运算符（!==）"></a>4.2 不等运算符（!=）和不等同运算符（!==）</h4><p>运算符（!=）和（！==）检测情况和（==）和（===）结果相反</p><h3 id="5-关系运算符"><a href="#5-关系运算符" class="headerlink" title="5. 关系运算符"></a>5. 关系运算符</h3><h4 id="5-1-比较运算符"><a href="#5-1-比较运算符" class="headerlink" title="5.1 比较运算符"></a>5.1 比较运算符</h4><p>比较运算符用来确定两个值的相对顺序。包括：</p><ul><li>小于运算符(＜）<ul><li>如果运算符＜的第一个运算数小于它的第二个运算数，它计算的值就为true否则它计算的值为fa1se</li></ul></li><li>大于运算符(＞)<ul><li>如果运算符＞的第一个运算数大于它的第二个运算数，它计算的值就为true，否则计算的值为 false</li></ul></li><li>小于等于运算符(＜=）<ul><li>如果运算符≤=的第一个运算数小于或等于第二个运算数，那么它计算的值就为true，否则计算的值为 false。</li></ul></li><li>大于等于运算符(&gt;=）<ul><li>如果运算符&gt;=的第一个运算数大于或等于第二个运算数，那么它计算的值就为true，否则计算的值为 false。</li></ul></li></ul><p>这些比较运算符的运算数可以是任意类型的，但是只能在数字和字符串上执行比较操作，所有不是数字或字符串的类型将会被转换为数字或字符串。比较和转换规则如下：</p><ul><li>如果两个运算数是数字或者都被转换成了数字，那么将采取数字比较。</li><li>如果两个运算数是字符串或都被转换成了字符串，那么将作为字符串进行比较。</li><li>如果一个运算数是字符串，或者被转换成了字符串，另一个运算数是数字，或者被转换成了数字，那么运算符将会把字符串转换为数字，执行数字比较。如果字符串不代表数字，它将会转换为NaN，比较结果是false。</li><li>如果对象可以被转换为数字或字符串，那么将执行数字转换。例如，比较date对象，可以从数字角度比较。</li><li>如果运算数都不能被转换为数字或字符串，那么结果返回false。</li><li>如果某个运算数是NaN，或者被转换成了NaN，那么结果返回false。</li></ul><h4 id="5-2-in运算符"><a href="#5-2-in运算符" class="headerlink" title="5.2 in运算符"></a>5.2 in运算符</h4><p>in运算符要求做不运算数是一个字符串，或可以被转为字符串，右边的运算数是一个对象或数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> point = &#123; <span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">1</span>&#125;</span><br><span class="line">“x” <span class="keyword">in</span> point;<span class="comment">//true</span></span><br><span class="line">“y” <span class="keyword">in</span> point;<span class="comment">//true</span></span><br><span class="line">“z” <span class="keyword">in</span> point; <span class="comment">//false</span></span><br><span class="line">“toString” <span class="keyword">in</span> point; <span class="comment">//继承属性，true</span></span><br></pre></td></tr></table></figure><h4 id="5-3-instanceof运算符"><a href="#5-3-instanceof运算符" class="headerlink" title="5.3 instanceof运算符"></a>5.3 instanceof运算符</h4><p>instanceof要求左边运算数是一个对象，右边运算数是对象类的名字。所有对象都是Object类的实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">d <span class="keyword">instanceof</span> <span class="built_in">Date</span>; <span class="comment">//true</span></span><br><span class="line">d <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">//true</span></span><br><span class="line">d <span class="keyword">instanceof</span> <span class="built_in">Number</span>; <span class="comment">//false</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">//true</span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">//true</span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>; <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>如果instanceof运算符的左边不是对象，或者右边运算数是一个对象，而不是构造函数，他将返回false. 另外，如果它右边运算数不是一个对象，他将返回运行时错误。</p><h3 id="6-字符串运算符"><a href="#6-字符串运算符" class="headerlink" title="6. 字符串运算符"></a>6. 字符串运算符</h3><p>有几个运算符在运算数是字符串时具有特殊的作用。<br>运算符“+”将连接两个字符串运算数：</p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“hello”+“ ”+“there”； <span class="comment">//hello there</span></span><br></pre></td></tr></table></figure></code></pre><p>运算符&lt;,&lt;=,&gt;,&gt;=将通过比较两个字符串来确定它们顺序。比较采用字母顺序，基于unicode编码标准。所有Latin字母表的大写字母都位于小写字母之前（即小于）。<br>运算符+比较特殊，它给予字符串运算数的优先级比数字运算数高。如果该运算符的一个运算数是字符串，那么另一个将被转换为字符串。进行连接操作。另一方面，如果比较运算符的两个运算数都是字符串，将进行字符串比较;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span> ； <span class="comment">//加法：3</span></span><br><span class="line">“<span class="number">1</span>”+ <span class="number">2</span>;  <span class="comment">//连接运算：“12”</span></span><br><span class="line">“<span class="number">1</span>”+ <span class="number">2</span>； <span class="comment">//连接运算： “12”</span></span><br><span class="line"><span class="number">11</span> &lt; <span class="number">3</span>；<span class="comment">//数字比较运算： false</span></span><br><span class="line">“<span class="number">11</span>” &lt; “<span class="number">3</span>”; <span class="comment">//字符串比较运算； true</span></span><br><span class="line">“<span class="number">11</span>” &lt; <span class="number">3</span>； <span class="comment">//数字比较运算：“11”被转换为11，false，如果只有一个是字符串，那么js会把它转换为数字。</span></span><br><span class="line">“one” &lt; <span class="number">3</span> <span class="comment">//数字比较运算：“one”转换为NaN,false</span></span><br></pre></td></tr></table></figure><h3 id="7-逻辑运算符"><a href="#7-逻辑运算符" class="headerlink" title="7. 逻辑运算符"></a>7. 逻辑运算符</h3><h4 id="7-1-逻辑与运算符（-amp-amp-）"><a href="#7-1-逻辑与运算符（-amp-amp-）" class="headerlink" title="7.1 逻辑与运算符（&amp;&amp;）"></a>7.1 逻辑与运算符（&amp;&amp;）</h4><p>当运算符&amp;&amp;的两个运算数都是布尔值时,它对这两个运算数执行布尔AND操作,即当且仅当它的两个运算数都是true时,它才返回true如果其中一个或两个运算数值为 false,它就返回 false。</p><p>这个运算符的实际行为比较复杂。首先,它将计算第一个运算数,也就是位于它左边的表达式。如果这个表达式的值可以被转换成 false(例如,左边运算数的值为null、0或 undefined),那么运算符将返回左边表达式的值。否则,它将计算第二个运算数,也就是位于它右边的表达式,并且返回这个表达式的值。</p><p>if( a == b) stop(); 等价于(a==b) &amp;&amp; stop();</p><h4 id="7-2-逻辑或运算符（-）"><a href="#7-2-逻辑或运算符（-）" class="headerlink" title="7.2 逻辑或运算符（||）"></a>7.2 逻辑或运算符（||）</h4><p>当运算符Ⅱ的两个运算数都是布尔值时，它对这两个运算数执行布尔或操作，即如果它的两个运算数中有一个值为为true(或者两个都为为true)，那么它就返回为true。如果它的两个运算数值都为false、它就返回false.</p><p>虽然 || 运算符常用为布尔或运算符，但是它和&amp;&amp;运算符一样，行为是比较复杂的.首先，它要计算第一个运算数，即它左边的表达式的值.如果这个表达式的值可以被转换成是真的，那么它就返回左边这个表达式的值。否则，它将计算第二个运算数，即位于它右边的表达式，并且返回该表达式的值.</p><h4 id="7-3-逻辑非运算符"><a href="#7-3-逻辑非运算符" class="headerlink" title="7.3 逻辑非运算符(!)"></a>7.3 逻辑非运算符(!)</h4><p>逻辑非运算符是一个一元运算符，它放在一个运算数之前。它用来对运算数对布尔值取反。对任意值x应用两次该运算符（即!!x）都可以将它转换为一个布尔值。</p><h3 id="8-逐位运算符"><a href="#8-逐位运算符" class="headerlink" title="8. 逐位运算符"></a>8. 逐位运算符</h3><ul><li>按位与运算符(&amp;)<br>运算符&amp;对它的整型参数逐位执行布尔AND操作只有两个运算数中相应的位都为1、那么结果中的这一位才为1。例如，0x1234 &amp; 0x00FF=0×0034</li><li>按位或运算符(｜)<br>运算符｜对它的整型参数逐位执行布尔或操作。如果其中一个运算数中的相应位为%1或者两个运算数中的相应位都为1，那么结果中的这一位就为1。例如，9｜10=11</li><li>按位异或运算符(^)<br>运算符^对它的整型参数逐位执行布尔异或操作.异或是指第一个运算数是true，或者第二个运算数是true，但是两者不能同时为true如果两个运算数中只有一个数的相应位为1(但不能同时为1)，那么结果中的这一位就为1例如，9^10=3。</li><li>按位非运算符(<code>~</code>)<br>运算符<code>~</code>是个一元运算符，它位于一个整型参数之前，它将运算数的所有位取反.根据javascript中带符号的整数的表示方法，对一个值使用<code>~</code>运算符相当于改变它的符号并且减1例如，<code>~</code>0x0f = Oxfffff00或-16</li><li>左移运算符(&lt;&lt;)<br>运算符&lt;&lt;左移第一个运算数中的所有位移动的位数由第二个运算数指定,移动的位数应该是一个0到31的整数。例如,在表达式a&lt;&lt;1中,a的第一位变成了它的第二位,a的第二位变成了它的第三位,以此类推新的第一位用0来补充,舍弃第32位的值。将一个值左移1位相当于对它乘2,左移2位相当于对它乘4,以此类推。例如,7&lt;&lt;1=14</li><li>带符号的右移运算符(&gt;&gt;)<br>运算符&gt;&gt;右移第一个运算数中的所有位,移动的位数由第二个运算数指定,移动的位数应该是一个0到31的整数。舍弃右边移出的位,填补在左边的位由原运算数的符号位决定,以便保持结果的符号与原操作数一致。如果第一个运算数是正的,就用O填补结果的高位;如果第一个运算数是负的,就用1填补结果的高位。将一个值右移1位,相当于用2除它(丢弃余数)右移2位,相当于用4除它,以此类推。例如,7&gt;1=3,-7&gt;&gt;1=-4</li><li>用0补足的右移运算符(&gt;&gt;&gt;)<br>运算符&gt;&gt;&gt;和运算符&gt;一样,只是从左边移入总是0,与原运算数的符号无关。例如,-1&gt;&gt;4=-1,但是-1&gt;&gt;4=268435455(0x0fffffff0)</li></ul><h3 id="9-赋值运算符"><a href="#9-赋值运算符" class="headerlink" title="9. 赋值运算符"></a>9. 赋值运算符</h3><p>运算符=要求它左边对运算数是一个变量，数组的一个元素，或是对象的一个属性，右边的运算数是一个任意的值，任意类型。</p><h4 id="9-1-带操作的运算符"><a href="#9-1-带操作的运算符" class="headerlink" title="9.1 带操作的运算符"></a>9.1 带操作的运算符</h4><p>运算符+=可以作用于数字和字符串，如果它的运算数是数字，执行加法运算和赋值操作，如果是字符串，将执行连接操作和赋值操作。还有-=,*=,&amp;=等。</p><h3 id="10-其他运算符"><a href="#10-其他运算符" class="headerlink" title="10. 其他运算符"></a>10. 其他运算符</h3><h4 id="10-1-条件运算符"><a href="#10-1-条件运算符" class="headerlink" title="10.1 条件运算符(?)"></a>10.1 条件运算符(?)</h4><p>条件运算符是 JavaScript中惟一的三元运算符(带有三个运算数)有时就称它为三元运算符。这个运算符常被写为?:,但是在代码中它却不是这样的,因为这个运算符具有三个运算数,第一个位于?之前,第二个位于?和:之间,第三个位于:之后。可以用如下方式来使用它:</p><p> x&gt;0 ? x<em>y : -x</em>y</p><p>条件运算符的第一个运算数必须是一个布尔值(或能够被转换为布尔值),通常它是一个比较表达式的结果。第二个和第三个运算数可以是任何类型的值。条件运算符的返回值是由第一个运算数的布尔值决定的。如果这个运算数的值为true,那么条件表达式的值就是第二个运算数的值。如果第一个运算数的值为 false,那么条件表达式的值就是第三个运算数的值。</p><h4 id="10-2-typeof运算符"><a href="#10-2-typeof运算符" class="headerlink" title="10.2 typeof运算符"></a>10.2 typeof运算符</h4><p>typeof是个一元运算符,放在一个运算数之前,这个运算数可以是任意类型的。它的返回值是一个字符串,该字符串说明了运算数的类型。</p><p>如果 typeof的运算数是数字、字符串或者布尔值,它返回的结果就是“number”、“string”或“boolean。对对象、数组和null,它返回的是“object。对函数运算数它返回的是“function”。如果运算数是未定义的,它将返回“undefined”</p><p>当 typeof的运算数是 Number、 String或 Boolean这样的包装对象时,它返回的是“object。此外,对Date和 RegExp对象,它也返回“object。对于那些不属于JavaScript核心语言,而是由 JavaScript嵌入的环境提供的对象, typeof的返回值是由实现决定的。但是,在客户端 JavaScript中, typeof对所有的客户端对象返回的都是“object”,这与它对所有核心对象的处理是一样的。</p><p>由于 typeof对所有的对象和数组类型返回的都是“object”,所以它只在区别对象和原始类型时才有用。要区别一种对象类型和另一种对象类型,必须使用其他的方法。例如instanceof运算符和 constructor属性.</p><h4 id="10-3-对象创建运算符-new"><a href="#10-3-对象创建运算符-new" class="headerlink" title="10.3 对象创建运算符(new)"></a>10.3 对象创建运算符(new)</h4><p>new运算符用来创建一个新对象,并调用构造函数初始化它。new是一个一元运算符,出现在构造函数的调用之前。它的语法如下:</p><p>new constructor(arguments)</p><p>constructor必须是一个构造函数表达式其后应该有一个用括号括起来的参数列表,列表中有零或多个参数,参数之间用逗号分隔。 JavaScript简化了该语法,即如果函数调用时没有参数,就可以省去括号这种简化了的语法只适用于运算符new.下面是一些使用new运算符的例子:</p><p> o=new Object; //此处省略了可选的括号</p><p> d=new Date();//返回一个表示当前时间的Date对象</p><p>c= new Rectangle(3.0.4.0,1.52.75);//创建 Rectangle类的对象<br>obj[i]=new constructors[i] ();</p><p>运算符new首先创建一个新对象,该对象的属性都未被定义接下来,它将调用特定的构造函数,传递指定的参数,此外还要把新创建的对象传递给关键字this这样构造函数就可以使用关键字this来初始化新对象.</p><h4 id="10-4-delete运算符"><a href="#10-4-delete运算符" class="headerlink" title="10.4 delete运算符"></a>10.4 delete运算符</h4><p>delete运算符是个一元运算符,它将删除运算数所指定的对象的属性、数组元素或变量(注3)。如果删除操作成功,它将返回true,如果运算数不能被删除,它将返回 false。并非所有的属性和变量都是可以删除的,某些内部的核心属性和客户端属性不能删除,用var语句声明的变量也不能被删除。如果 delete使用的运算数是一个不存在的属性,它将返回true(令人吃惊的是, ECMAScript标准规定,当 delete运算的运算数不是属性、数组元素或变量时,它返回true.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"><span class="keyword">delete</span> o.x</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="keyword">typeof</span> o.x</span><br><span class="line"><span class="string">&quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">delete</span> o.x</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="keyword">delete</span> o</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="keyword">delete</span> <span class="number">1</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">y = <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">delete</span> y</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>delete所能影响的只是属性值，并不能影响这些属性引用的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> my = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">my.a = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">my.b = my.a;</span><br><span class="line"><span class="keyword">delete</span> my.a;</span><br><span class="line"><span class="built_in">console</span>.log(my.b);<span class="comment">//时间值 Mon Jan 11 2021 17:54:58 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure><h4 id="10-5-void运算符"><a href="#10-5-void运算符" class="headerlink" title="10.5 void运算符"></a>10.5 void运算符</h4><p>void是一个一元运算符,它可以出现在任何类型操作数之前。这个运算符的用途比较特殊,它总是舍弃运算数的值,然后返回undefined这种运算符常用在客户端的 javascript:URL中。在这里可以计算表达式的值,而浏览器不会显示出这个值</p><p>例如,可以在HTML的标记中以如下方式使用void运算符:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;javascript: void window.open () &quot;</span>&gt;Open New Window&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>void另一个用途是专门生成undefined值</p><h4 id="10-6-逗号运算符"><a href="#10-6-逗号运算符" class="headerlink" title="10.6 逗号运算符(,)"></a>10.6 逗号运算符(,)</h4><p>逗号运算符非常简单。它先计算其左边的参数,再计算其右边的参数,然后返回右边参数的值。因此,如下的代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">0</span>,j=<span class="number">1</span>,k=<span class="number">2</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">i=<span class="number">0</span>;</span><br><span class="line">j=<span class="number">1</span>;</span><br><span class="line">k=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>这个奇怪的运算符只在个别环境中使用,一般是在只允许出现一个表达式的地方计算几个不同的表达式时才使用的。在实际应用中,逗号运算符只和for循环语句联合使用。</p><h4 id="10-7-数组和对象存取运算符"><a href="#10-7-数组和对象存取运算符" class="headerlink" title="10.7 数组和对象存取运算符"></a>10.7 数组和对象存取运算符</h4><p>运算符“.”左边是一个对象，右边是一个标识符<br>运算符“[]”用于存取数组元素，还可以存取对象的属性。</p><h4 id="10-8-函数调用运算符（）"><a href="#10-8-函数调用运算符（）" class="headerlink" title="10.8 函数调用运算符（）"></a>10.8 函数调用运算符（）</h4><!-- * @Description: javascript-第五章-表达式和运算符 * @version::  * @Author: zhao * @Date: 2021-01-10 22:43:09 * @LastEditors: zhao * @LastEditTime: 2021-01-11 11:37:15-->]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-第四章-变量</title>
      <link href="/ZJY.github.io/2021/01/10/javascript-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%8F%98%E9%87%8F/"/>
      <url>/ZJY.github.io/2021/01/10/javascript-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="第四章-变量"><a href="#第四章-变量" class="headerlink" title="第四章 变量"></a>第四章 变量</h2><h3 id="1-变量的类型"><a href="#1-变量的类型" class="headerlink" title="1.变量的类型"></a>1.变量的类型</h3><p>js是无类型的，变量可以存放任意类型的值</p><h3 id="2-变量的声明"><a href="#2-变量的声明" class="headerlink" title="2.变量的声明"></a>2.变量的声明</h3><p>要使用一个变量，要使用var关键字声明。<br>    var i;<br>    var num;<br>    也可以一次声明多个变量：var i,num;<br>    也可以将变量声明和初始化绑到一块：var message = ‘hello’;<br>    var i=0,k=1;</p><p>var 声明的变量是永久性的，用delete运算符删除变量会引发错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">delete</span> i; <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 10</span></span><br><span class="line">a=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">delete</span> a; <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// a is not defined </span></span><br></pre></td></tr></table></figure><p>重复声明同一个变量是合法的，且不会报错。<br>如果尝试读取一个未声明的变量的值，会引发错误。<br>如果给未用var声明的变量赋值，js会隐式的声明该变量，隐式声明变量会使该变量为全局变量。</p><h3 id="3-变量的作用域"><a href="#3-变量的作用域" class="headerlink" title="3.变量的作用域"></a>3.变量的作用域</h3><p>变量的作用域就是程序中定义变量的区域。全局变量的作用域全局性的，在js中处处有定义。而在函数内部定义的变量只能在函数内部使用，是局部性的。函数的参数也是局部作用域，只在函数内部有定义。<br>在函数内部，局部变量的优先级比同名的全局变量高.</p><h4 id="3-1-没有块级作用域"><a href="#3-1-没有块级作用域" class="headerlink" title="3.1 没有块级作用域"></a>3.1 没有块级作用域</h4><p>即函数中声明的所用变量在整个函数中有定义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> o==<span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> k=<span class="number">0</span>; k&lt;<span class="number">10</span>;k++)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">document</span>.write(k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(i,j,k);</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="literal">null</span>); <span class="comment">// 0 0  10  i,j,k在整个函数中有定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> scope=<span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(scope);</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&#x27;local&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(scope);</span><br><span class="line">&#125;</span><br><span class="line">f(); <span class="comment">// undefined  local</span></span><br></pre></td></tr></table></figure><h4 id="3-2-未定义的变量和未赋值的变量"><a href="#3-2-未定义的变量和未赋值的变量" class="headerlink" title="3.2 未定义的变量和未赋值的变量"></a>3.2 未定义的变量和未赋值的变量</h4><p>var x;  //声明一个未赋值的变量<br>alert(u); //使用未声明的变量将引发错误<br>u=3; //给未声明的变量赋值，将创建该变量</p><h3 id="4-基本类型"><a href="#4-基本类型" class="headerlink" title="4.基本类型"></a>4.基本类型</h3><p>变量具有或存放了值，存放的具体内容就是js所支持的数据类型。<br>基本数据类型：null,number,string,bool,undefined<br>引用数据类型：对象，数组和函数。</p><p>基本类型在内存中具有固定的大小。引用类型没有固定的大小。<br>引用类型，变量存储的是对这个值的引用，通常是指针或内存地址。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//3.14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">A[<span class="number">0</span>]=<span class="number">99</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//[99,2,3]</span></span><br></pre></td></tr></table></figure><p>变量保存了基本数据类型的值，而只保存了对引用类型的引用。</p><h3 id="5-无用存储单元的收集"><a href="#5-无用存储单元的收集" class="headerlink" title="5.无用存储单元的收集"></a>5.无用存储单元的收集</h3><p>由于引用类型没有固定的大小，所以引用类型可能非常的大。由于字符串、数组、对象没有固定大小，所以当知道他们的大小时，才能为他们进行动态的内存分配。</p><p>js程序每次创建字符串、对象和数组时，解释器都要分配内存来储存实体，只要像这样动态的分配了内存，最终都要释放内存以便它们能够被再用。否则，js解释器会消耗所有系统内存，造成系统崩溃。</p><p>js不要求手动释放内存，它使用一种无用存储单元收集方法。当js检测到一个对象不再使用时，就会把它所占用内存释放掉。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = ‘hello’;</span><br><span class="line"><span class="keyword">var</span> u = s.toUppercase();</span><br><span class="line">s = u;</span><br></pre></td></tr></table></figure><p>程序检测到’hello’字符串不再使用，就会释放掉这块内存.</p><h3 id="6-作为属性的变量"><a href="#6-作为属性的变量" class="headerlink" title="6.作为属性的变量"></a>6.作为属性的变量</h3><p>变量和对象的属性基本是一样的，赋值和用法都相同。</p><h4 id="6-1-全局对象"><a href="#6-1-全局对象" class="headerlink" title="6.1 全局对象"></a>6.1 全局对象</h4><p>在js解释器执行前，首先要做的事情之一在任何代码执行之前，创建一个全局对象（global object）。这个对象的属性就是全局变量。</p><p>当js声明一个全局变量时，实际上就是定义了那个全局对象的一个属性。</p><p>在程序的顶层代码中，可以用this代替那个全局对象。<br>在客户端js中，window对象代表浏览器窗口，是包含在窗口中所有js代码的全局对象。这个全局Window对象具有自我引用的window属性，它代替了this属性。可以用来引用全局对象。Window对象定义了全局的核心属性，例如Infinity,parseInt,Math,除此之外还定义了全局的客户端属性，navigator和 screen.</p><h4 id="6-2-局部变量：调用对象"><a href="#6-2-局部变量：调用对象" class="headerlink" title="6.2 局部变量：调用对象"></a>6.2 局部变量：调用对象</h4><p>全局变量是特殊的全局对象的属性，局部变量是调用对象（call object）的属性。</p><p>在执行一个函数时，局部变量和参数是作为调用对象的属性存储的。用一个完全独立的对象存储局部变量可以使js防止同名变量覆盖全局变量的值。</p><h4 id="6-3-javascript的执行环境"><a href="#6-3-javascript的执行环境" class="headerlink" title="6.3 javascript的执行环境"></a>6.3 javascript的执行环境</h4><p>javascript的解释器每次开始执行一个函数时，就会为那个函数创建一个执行环境（execution context）。显然，这个执行环境就是js代码段执行时所在环境。</p><p>所用js函数都有自己的执行环境，有自己的调用对象，调用对象定义了局部变量。运行不属于任何js代码的环境使用的就是全局对象。</p><p>js允许有多个全局执行环境，每个全局执行环境有不同的全局对象（但在在这种情况下，全局对象就不完全是全局的了）。</p><p>一个显而易见的例子就是，每个独立的浏览器窗口或同一窗口不同框架中都定义了独立的全局执行环境。每个框架或窗口中的客户端js代码都运行在自己的执行环境中，具有自己的全局对象。但是这些独立的客户端全局对象，具有将其他对象连接起来的属性。因此，一个框架可以通过parent.frames[1]来引用另一个框架的代码，在第二个框架中可以用表达式parent.frames[0].x来引用第一个框架的全局变量x。</p><h3 id="7-变量的作用域"><a href="#7-变量的作用域" class="headerlink" title="7.变量的作用域"></a>7.变量的作用域</h3><p><img src="/ZJY.github.io/images/scope.png" alt="变量的作用域"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-第三章-数据类型和值</title>
      <link href="/ZJY.github.io/2021/01/10/javascript-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%80%BC/"/>
      <url>/ZJY.github.io/2021/01/10/javascript-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="第三章-数据类型和值"><a href="#第三章-数据类型和值" class="headerlink" title="第三章 数据类型和值"></a>第三章 数据类型和值</h2><p>计算机程序是通过操作值来运行的。能够表示并操作的值的类型称为数据类型。</p><p>javascript允许使用3种基本数据类型：数字、字符串、布尔。此外还支持另外2种小数据类型：null（空）和undefined（未定义），只定义了一个值。</p><p>除了基本数据类型外，javascript还支持复合数据类型-对象，是值的集合。对象有两种，一种是已命名的值的无序集合，另一种是有编号的值的有序集合。后者称为数组。</p><p>javascript还定义了另一种特殊的类型-函数，是具有可执行代码的对象。js为函数定义了专用的语法。</p><p>除了数组和函数还定义了其他专用的对象，这些对象不是新的数据类型而是新的对象类。Date类定义的表示日期的对象。</p><p>RegExp类定义的表示正则表达式的对象。Error类定义的是js程序中发生的语法和运行时错误的对象。</p><h3 id="1-数字"><a href="#1-数字" class="headerlink" title="1.数字"></a>1.数字</h3><p>在js中，不区分整点型和浮点型数字，所有数字都是浮点型的，采用ieee 754标准的64位浮点格式表示</p><h4 id="1-1-整型直接量-十进制"><a href="#1-1-整型直接量-十进制" class="headerlink" title="1.1 整型直接量(十进制)"></a>1.1 整型直接量(十进制)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>   <span class="number">3</span>   <span class="number">1000</span></span><br></pre></td></tr></table></figure><p>整数表示从2<sup>-53</sup> 到2 <sup>53</sup>,使用超过尾数范围的数字，就会失去精确性，<br>有些整数的运算，是对32位进行的，（2<sup>-31</sup> 到 2<sup>31-1</sup>)</p><h4 id="1-2八进制和十六进制直接量"><a href="#1-2八进制和十六进制直接量" class="headerlink" title="1.2八进制和十六进制直接量"></a>1.2八进制和十六进制直接量</h4><p>除了10进制的整型直接量，js还支持8进制和16进制直接量。</p><p>16进制中数字可以用0-9表示，字母可以用a(A)-f(F)表示，代表0-15之间数字。16进制直接量由’0x’ 或‘0X’开头，后面跟16进制数字串。</p><p>0x123 基数是16 //1<em>16</em>16+2*16+3</p><p>尽管ECMAScript标准不支持8进制的直接量，但是javascript的某些实现却允许你使用8进制的直接量。8进制是以0开头，后面跟随0-7直接的数字，</p><p>0377 基数是8 // 3<em>8</em>8+7*8+7</p><p>由于某些js实现支持8进制有些不支持，所以尽量不要使用0开头的整型直接量。</p><h4 id="1-3浮点型直接量"><a href="#1-3浮点型直接量" class="headerlink" title="1.3浮点型直接量"></a>1.3浮点型直接量</h4><p>由整数部分，小数点，小数部分组成，此外还可以用指数计数法表示浮点型直接量，即实数后面跟字母e或者E，后面跟正号和负号，再加一个整型指数。表示前面的实数乘以10的指数次幂。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.14</span></span><br><span class="line"><span class="number">344.89</span></span><br><span class="line"><span class="number">6.34e12</span> <span class="comment">//6.34*1012</span></span><br></pre></td></tr></table></figure><h4 id="1-4特殊数值"><a href="#1-4特殊数值" class="headerlink" title="1.4特殊数值"></a>1.4特殊数值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">Infinity</span>  无穷大</span><br><span class="line">-<span class="literal">Infinity</span>  负无穷大</span><br><span class="line"><span class="literal">NaN</span>    非数字的特殊值，和任何值都不相等，包括自己，用专门的<span class="built_in">isNaN</span>()函数来检测这个值。</span><br><span class="line"><span class="built_in">isFinite</span>()函数来测试一个值是否是<span class="literal">NaN</span>，正无穷大或负无穷大。</span><br><span class="line"><span class="built_in">Number</span>.MAX_VALUE  可表示的最大数字</span><br><span class="line"><span class="built_in">Number</span>.MIN_VALUE   可表示的最小数字（接近于<span class="number">0</span>）</span><br><span class="line"><span class="built_in">Number</span>.NaN  非数字的特殊值</span><br><span class="line"><span class="built_in">Number</span>.POSITION_INFINITY 表示正无穷大的特殊值</span><br><span class="line"><span class="built_in">Number</span>.NEGATIVE_INFINITY 表示负无穷大的特殊值</span><br></pre></td></tr></table></figure><h3 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2.字符串"></a>2.字符串</h3><p>由unicode字符、数字和标点符号组成的序列，表示文本的数据类型。</p><h4 id="2-1-字符串直接量"><a href="#2-1-字符串直接量" class="headerlink" title="2.1 字符串直接量"></a>2.1 字符串直接量</h4><p>由单引号或者双引号扩起来的unicdoe字符序列。可以包含0个或多个字符序列</p><h4 id="2-2-字符串直接量中的转义字符"><a href="#2-2-字符串直接量中的转义字符" class="headerlink" title="2.2 字符串直接量中的转义字符"></a>2.2 字符串直接量中的转义字符</h4><p>反斜杠\后加一个字母就可以表示特殊的用法。\n表示换行符<br>‘you&#39;re right’, \’表示单引号或者撇号</p><h3 id="3-布尔值"><a href="#3-布尔值" class="headerlink" title="3.布尔值"></a>3.布尔值</h3><p>true和false两个值，通常用于控制结果</p><h3 id="4-函数"><a href="#4-函数" class="headerlink" title="4.函数"></a>4.函数</h3><p>一段可执行的代码段，由js定义或由js预定义，可多次执行和调用。js函数是一个真正的数据类型，可以对函数进行操作。</p><p>Math.sin()预定义函数</p><h4 id="4-1-函数直接量"><a href="#4-1-函数直接量" class="headerlink" title="4.1 函数直接量"></a>4.1 函数直接量</h4><p>有关键字function和可选对参数名、用括号括起来对参数列表和花括号括起来定义的。</p><p>除了用函数定义来定义函数：</p><p>function square(x){ return x*x }</p><p>还可以用函数直接量类定义：</p><p>var square = funtion(x) { return x*x }</p><p>如果一个函数值存储在某个对象的属性中，那个这个函数通常被称为方法，属性名称被称为方法名。</p><h3 id="5-对象"><a href="#5-对象" class="headerlink" title="5.对象"></a>5.对象</h3><p>已命名的数据的集合，每个数值都有一个名字,称为对象的属性，通过”.”操作符和属性名访问。</p><h4 id="5-1-创建对象"><a href="#5-1-创建对象" class="headerlink" title="5.1 创建对象"></a>5.1 创建对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/javascript/gi</span>);</span><br></pre></td></tr></table></figure><h4 id="5-2-对象直接量"><a href="#5-2-对象直接量" class="headerlink" title="5.2 对象直接量"></a>5.2 对象直接量</h4><p>var point = {x: 1,y:3}，<br>对象直接量可以嵌套，属性值可以不是常量。</p><h3 id="6-数组"><a href="#6-数组" class="headerlink" title="6.数组"></a>6.数组</h3><p>数值的集合，数组的每个数值都有一个下标，js不支持多维数组，但数组元素可以是数组。数组下标是非负整数</p><h4 id="6-1-数组的创建"><a href="#6-1-数组的创建" class="headerlink" title="6.1 数组的创建"></a>6.1 数组的创建</h4><p>可以通过构造函数Array()创建:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1.2</span>;</span><br><span class="line">arr[<span class="number">1</span>] = ‘javascript’;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1.2</span>,’javascript’);</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>); 创建的是表示<span class="number">10</span>个未定义的数组</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-2-数组直接量"><a href="#6-2-数组直接量" class="headerlink" title="6.2 数组直接量"></a>6.2 数组直接量</h4><p>var arr = [1,2,3,4];<br>数组可以嵌套，var arr = [[1,2,3],2];<br>数组元素不局限于常量：var arr = [1024,1024+1]<br>数组可以存放未定义的元素：var arr = [1,,,,5]</p><h3 id="7-null"><a href="#7-null" class="headerlink" title="7.null"></a>7.null</h3><p>表示“无”值，尝被看作对象类型的特殊值，表示“无对象”的值。js保留字</p><h3 id="8-undefined"><a href="#8-undefined" class="headerlink" title="8.undefined"></a>8.undefined</h3><p>当你使用一个未定义的值，或已定义未赋值的值，或不存在的对象属性时，返回这个值。</p><p>null == undefined  //true</p><p>如果要区分null和undefined可用 === 或者typeof区分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// “object”  </span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// undefined</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> 不是js保留字</span><br><span class="line">ECMAScript v3 定义了名为<span class="literal">undefined</span>的全局变量，值为<span class="literal">undefined</span></span><br></pre></td></tr></table></figure><h3 id="9-Date对象"><a href="#9-Date对象" class="headerlink" title="9.Date对象"></a>9.Date对象</h3><p>表示日期和时间的对象类。可以用运算符new和构造函数Date()创建Date对象</p><h3 id="10-正则表达式"><a href="#10-正则表达式" class="headerlink" title="10.正则表达式"></a>10.正则表达式</h3><p>用于模式匹配和查找替换操作，正则表达式直接量：/^html/</p><h3 id="11-Error"><a href="#11-Error" class="headerlink" title="11.Error"></a>11.Error</h3><p>表示错误的类,每个Error对象都有一个message属性，存放js特定错误消息。预定义的错误对象的类型有Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError和URIError.</p><h3 id="12-基本数据类型的包装对象"><a href="#12-基本数据类型的包装对象" class="headerlink" title="12.基本数据类型的包装对象"></a>12.基本数据类型的包装对象</h3><p>var str =”lfjlajdfasd”;<br>var result = str.substring(1,4);<br>三个基本的数据类型都有一个相应的对象类，js不仅有数字、字符串、布尔类型，还有Number、String、Bool类，这些类是基本数据类型的包装，这些类不仅有基本数据类型的值，还定义了用来运算的属性和方法</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-第二章-词法结构</title>
      <link href="/ZJY.github.io/2021/01/10/javascript-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%AF%8D%E6%B3%95%E7%BB%93%E6%9E%84/"/>
      <url>/ZJY.github.io/2021/01/10/javascript-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%AF%8D%E6%B3%95%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="第二章-词法结构"><a href="#第二章-词法结构" class="headerlink" title="第二章 词法结构"></a>第二章 词法结构</h2><h3 id="1-字符集"><a href="#1-字符集" class="headerlink" title="1.字符集"></a>1.字符集</h3><p>采用16位的unicode编码可以表示任意一种书面语言，javascript是采用unicode字符集编写的。js中任意字符都是用2个字节表示。</p><h3 id="2-区分大小写"><a href="#2-区分大小写" class="headerlink" title="2.区分大小写"></a>2.区分大小写</h3><p>在html中标记和性质名可以任意大小写方式输入，但是在js中通常是小写的。例如，在html中事件处理性质名是onClick，但是在js中只能用onclick。</p><h3 id="3-空白符和换行符"><a href="#3-空白符和换行符" class="headerlink" title="3.空白符和换行符"></a>3.空白符和换行符</h3><p>js会忽略空白符号、制表符、换行符，除非是字符串或正则表达式中。</p><h3 id="4-分号可选"><a href="#4-分号可选" class="headerlink" title="4.分号可选"></a>4.分号可选</h3><p>但是省略分号并不是一个良好的编程习惯，应习惯于使用分号。</p><h3 id="5-注释"><a href="#5-注释" class="headerlink" title="5.注释"></a>5.注释</h3><p>单行： //  多行： /****/</p><h3 id="6-直接量"><a href="#6-直接量" class="headerlink" title="6.直接量"></a>6.直接量</h3><p>就是程序中直接显示的数据值，以下都是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1.2</span></span><br><span class="line">“hello,world”</span><br><span class="line"><span class="literal">null</span>,</span><br><span class="line">True,</span><br><span class="line">False,</span><br><span class="line">/javascript/gi,</span><br><span class="line">&#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:<span class="number">1</span>&#125;, <span class="comment">//对象直接量</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] <span class="comment">//数组直接量</span></span><br></pre></td></tr></table></figure><h3 id="7-标识符"><a href="#7-标识符" class="headerlink" title="7.标识符"></a>7.标识符</h3><p>一个名字，用来命名变量和函数，或者代码中某些循环的标签。<br>命名规则：首字符以字母、下划线和美元符号开头，后面可以是数字、字母、下划线、美元符号</p><h3 id="8-保留字"><a href="#8-保留字" class="headerlink" title="8.保留字"></a>8.保留字</h3><p>不能用作标识符，有特殊意义</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript-第一章-Javascript的概述</title>
      <link href="/ZJY.github.io/2021/01/10/javascript-%E7%AC%AC%E4%B8%80%E7%AB%A0-Javascript%E7%9A%84%E6%A6%82%E8%BF%B0/"/>
      <url>/ZJY.github.io/2021/01/10/javascript-%E7%AC%AC%E4%B8%80%E7%AB%A0-Javascript%E7%9A%84%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Javascript的概述"><a href="#Javascript的概述" class="headerlink" title="Javascript的概述"></a>Javascript的概述</h3><p>JavaScript是一种轻型的，解释型的程序设计语言。具有面向对象的能力。是一种无类型的语言，也就是说变量不必具有明确的类型。<br>除了能够动态的生成浏览器要显示的html文档，js不具备任何图形处理能力。<br>处于安全考虑，客户端javascript不允许对文件进行读写操作。<br>除了能够引发浏览器下载任意url所指对文档以及把html表单内容发送给服务器脚本、电子邮件外，javascript不支持任意形式的联网技术。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
