<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>css-笔记</title>
      <link href="/ZJY.github.io/2022/07/14/css-%E7%AC%94%E8%AE%B0/"/>
      <url>/ZJY.github.io/2022/07/14/css-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="第一章-层叠、优先级和继承"><a href="#第一章-层叠、优先级和继承" class="headerlink" title="第一章 层叠、优先级和继承"></a>第一章 层叠、优先级和继承</h3><p>css里的c代表cascade,层叠，层叠决定了如何解决冲突，是css语言的基础。层叠会依据三种条件解决冲突。</p><p>(1) 样式表的来源：样式是从哪里来的，包括你的样式和浏览器默认样式等。</p><p>(2) 选择器优先级：哪些选择器比另一些选择器更重要。</p><p>(3) 源码顺序：样式在样式表里的声明顺序。</p><p>声明：color: black;<br>包含在大括号内的一组声明被称作一个声明块。<br>声明块前面有一个选择器.<br>选择器和声明块一起组成了规则集（ruleset）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>样式表的来源</p><p>你添加到网页里的样式表并不是浏览器唯一使用的样式表，还有其他类型或来源的样式表。你的样式表属于作者样式表，除此之外还有用户代理样式表，即浏览器默认样式。用户代理样式表优先级低，你的样式会覆盖它们.</p><p>! important声明会被当作更高优先级的来源，因此总体的优先级按照由高到低排列如下所示：<br>(1) 作者的！important<br>(2) 作者的样式表<br>(3) 用户代理样式表</p><p>层叠规则顺序：不同来源的声明-内联声明-选择器优先级声明-源码顺序声明</p></li><li><p>理解优先级</p><p>浏览器将优先级分为两部分：HTML的行内样式和选择器的样式。</p></li><li><p>行内样式<br>如果用HTML的style属性写样式，这个声明只会作用于当前元素。实际上行内元素属于“带作用域的”声明，它会覆盖任何来自样式表或者<code>&lt;style&gt;</code>标签的样式。行内样式没有选择器，因为它们直接作用于所在的元素</p></li><li><p>选择器优先级<br>伪类选择器（:hover）和属性选择器（[type=”input”]）与一个类选择器的优先级相同。<br>通用选择器（*）和组合选择器（&gt;,+,~）对优先级无影响。</p></li><li><p>源码顺序<br>层叠的第三步，也是最后一步，是源码顺序。如果两个声明的来源和优先级相同，其中一个声明在样式表中出现较晚，或者位于页面较晚引入的样式表中，则该声明胜出。</p></li><li><p>层叠值<br>浏览器遵循三个步骤，即来源，优先级，源码顺序来解析网页上每个元素的每个属性。<br>处理层叠的两条通用法则：<br>1.在选择器中不要使用ID<br>2.不要使用!important</p></li><li><p>继承</p><p>如果一个元素的某个属性没有层叠值，则可能继承祖先元素的值。比如给<code>&lt;body&gt;</code>元素加上font-family,<br>就不必给每个元素明确指定字体。但不是所有属性都能被继承。只有特定属性能被继承，主要和文本相关的<br>属性：<br> color、font、font-family、font-size、font-weight、font-variant、font-style、<br> line-height、letter-spacing、text-align、text-indent、text-transform、white-space<br> word-spacing</p><p>还有一些其他属性能被继承，比如列表属性：<br> list-style、list-style-type、list-style-position、list-style-image</p><p>表格的边框属性: border-collapse、border-spacing 也能被继承</p></li><li><p>特殊值</p><p>有两个特殊值可以赋给任意属性，用于控制层叠：inherit和initial</p></li><li><p>inherit关键字<br>可以用继承代替一个层叠值，比如覆盖另一个值，这样该元素就会继承其父元素的值。</p></li><li><p>initial关键字<br>每个css属性都有初始默认值，给属性设置initial会有效将其重置为默认值，比如给<code>&lt;body&gt;</code>设置color: #111; 那么默认的其子元素文本颜色都继承这个属性值，给其设置color: initial，会使其文本颜色变为<br>color: black; 因为黑色是color属性的初始值。</p><p>注：声明display: initial等价于display: inline。不管应用于哪种类型的元素，他都不会等于display:block。因为initial重置的是属性的初始值，而不是元素的初始值。inline才是display属性<br>的初始值。</p></li><li><p>简写属性</p><p>简写属性是用于同时给多个属性赋值的属性。比如font是一个简写属性，还有：background,border,border-width</p></li><li><p>简写属性会默默覆盖其他样式<br>大多数简写可以省略一些值，只指定我们关注的值，但这样仍然会设置省略的值，即它们会被隐式的设置为初始值initial.这样会覆盖其他定义的样式</p></li><li><p>理解简写值的顺序<br>可以设置border: 1px solid black或者border: black 1pxsolid，两者都会生效。这是因为浏览器知道宽度、颜色、边框样式分别对应什么类型的值。但是有很多属性的值很模糊。在这种情况下，值的顺序很关键</p><p>（1）上、右、下、左<br>margin、padding、边框属性<br>（2）水平、垂直<br>上右下左只适合给盒子设置四个方向的值的属性。还有一些属性只支持最多指定两个值，这些属性包括background-position、box-shadow、text-shadow，比如box-shadow: 10px 2px #000;<br>指定水平方向偏移量10px，垂直方向偏移量2px，先水平再垂直</p></li></ol><h3 id="第二章-相对单位"><a href="#第二章-相对单位" class="headerlink" title="第二章 相对单位"></a>第二章 相对单位</h3><p>1.em<br>em的复杂之处在于同时用它指定一个元素的字号和其他属性。这时，浏览器必须先计算字号，然后使用这个计算值去算出其余的属性值。这两类属性可以拥有一样的声明值，但是计算值不一样。<br>例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">  font-size: 1.2em; // 计算值为16*1.2=19.2px</span><br><span class="line">  padding: 1.2em; // 计算值为19.2*1.2=23.04px</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字体缩小的问题</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0.8em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span> <span class="comment">&lt;!-- font-size: 16px * 0.8 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>top level<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="comment">&lt;!-- font-size: 16px * 0.8 * 0.8 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>second level<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="comment">&lt;!-- font-size: 16px * 0.8 * 0.8 * 0.8--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>third level<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.rem<br>在文档中，根节点是所有其他元素的祖先节点。根节点有一个伪类选择器（:root），可以用来选中它自己。这等价于类型选择器html，但是html的优先级相当于一个类名，而不是一个标签.<br>rem是root em的缩写。rem不是相对于当前元素，而是相对于根元素的单位.不管在文档的什么位置使用rem,1.2rem都会有相同的计算值：1.2乘以根元素的字号.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;  <span class="comment">/*  :root伪类相当于类型选择器html */</span></span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1em</span>; <span class="comment">/* 根元素上的em是相对于浏览器默认值的，16px  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0.8rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿不准的时候，用rem设置字号，用px设置边框，用em设置其他大部分属性.</p><p>em和rem都是相对于font-size定义的。</p><p>3.视口的相对单位<br>视口——浏览器窗口里网页可见部分的边框区域。它不包括浏览器的地址栏、工具栏、状态栏。</p><p>vh：视口高度的1/100。<br>vw：视口宽度的1/100。<br>vmin：视口高度的1/100。1. vw：视口宽度的1/100。<br>vmax：视口宽、高中较大的一方的1/100。</p><p>当一个元素的宽和高为90vmin时，不管视口的大小或者方向是什么，总会显示成一个稍小于视口的正方形</p><p>vw可以结合calc()设置字号，对于iphone6 375到1200px，字号从11.75到20px</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="built_in">calc</span>(<span class="number">0.5em</span> + <span class="number">1vw</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.自定义属性即css变量</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attribute">--main-foot</span>: Arial, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="built_in">var</span>(--main-foot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>var()函数接受第二个参数，它指定了备用值。如果第一个参数指定的变量未定义，那么就会使用第二个值</p><p>如果var()函数算出来的是一个非法值，对应的属性就会设置为其初始值。比如，如果在padding: var(–brand-color)中的变量算出来是一个颜色，它就是一个非法的内边距值。这种情况下，内边距会设置为0.</p><p>自定义属性就像作用域变量一样,自定义属性就像作用域变量一样</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attribute">--main-color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.panel</span> &#123;</span><br><span class="line">  <span class="attribute">--main-color</span>: white</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--main-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>黑色<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>白色<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用js改变属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rootElement = <span class="built_in">document</span>.documentElement;</span><br><span class="line">rootElement.style.setProperty(<span class="string">&#x27;--main-color&#x27;</span>, <span class="string">&#x27;#ccc&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="第3章-盒模型"><a href="#第3章-盒模型" class="headerlink" title="第3章 盒模型"></a>第3章 盒模型</h3><p>1.盒模型<br>box-sizing: content-box; 设置元素宽高只设置内容盒子大小<br>box-sizing: border-box; width和height属性会设置内容、内边距及边框的大小总和。</p><figure class="highlight plain"><figcaption><span>&#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  box-sizing: border-box;</span><br><span class="line">&#125;</span><br><span class="line">*,</span><br><span class="line">::before,</span><br><span class="line">::after &#123;</span><br><span class="line">  box-sizing: .inherit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>盒模型通常不会被继承，但是使用inherit关键字可以强制继承.这样可以不覆盖第三方组件的盒模型.</p><p>2.垂直居中<br>如果给块级元素设置vertical-align:middle;块级元素的内容不会垂直居中，vertical-align声明只会影响行内元素或者table-cell元素。对于行内元素，它控制着该元素跟同一行内其他元素之间的对齐关系。比如一行内图片和文字对齐方式。</p><p>3.负外边距<br>负外边距的具体行为取决于设置在元素的哪边。如果设置左边或顶部的负外边距，元素就会相应地向左或向上移动，导致元素与它前面的元素重叠，如果设置右边或者底部的负外边距，并不会移动元素，而是将它后面的元素拉过来。给元素底部加上负外边距并不等同于给它下面的元素顶部加上负外边距</p><p>4.外边距折叠<br>所有相邻的顶部和底部外边距会折叠到一起，即使两个元素不是相邻的兄弟节点也会产生外边距折叠。只有上下外边距会产生折叠，左右外边距不会折叠。<br>折叠外边距的大小等于相邻外边距中的最大值</p><h1 id="第7章-定位和层叠上下文"><a href="#第7章-定位和层叠上下文" class="headerlink" title="第7章 定位和层叠上下文"></a>第7章 定位和层叠上下文</h1><p>1.固定和绝对定位可以设置top,right,bottom,left改变定位元素的大小，相对定位不可以<br>2.固定定位相对于视口定位，绝对定位相对于最近定位父元素定位，如果没有定位父元素，则相对于初始包含块定位<br>3.初始包含块是视口和html根元素之间的内容<br>4.相对定位，left和right， top和bottom不能同时使用，left和right一起使用时，right会被忽略，top和bottom一起使用时right会被忽略<br>5.通常情况下（使用定位之前），元素在HTML里出现的顺序决定了绘制的顺序。<br>6.浏览器会先绘制所有非定位的元素，然后绘制定位元素。默认情况下，所有的定位元素会出现在非定位元素前面。<br>7.相对定位依赖于文档流，绝对定位元素依赖于它的定位祖先节点。这时候需要用z-index属性来控制它们的层叠行为。<br>8.z-index属性的值可以是任意整数（正负都行）。z表示的是笛卡儿x-y-z坐标系里的深度方向。拥有较高z-index的元素出现在拥有较低z-index的元素前面。拥有负数z-index的元素出现在静态元素后面<br>9.z-index只在定位元素上生效，不能控制静态元素；给一个定位元素添加z-index属性可以创建层叠上下文。<br>10.一个层叠上下文包含一个元素或由浏览器一起绘制的一组元素。其中一个元素作为层叠上下文的根，比如给一个定位元素设置z-index属性，该元素就是新的层叠上下问的根。<br>11.层叠上下文负责决定哪些元素出现在另一些元素前面，而BFC负责处理文档流，以及元素是否会重叠<br>12.创建层叠上下文方式：给定位元素添加z-index属性，opacity属性小于1，transform、，filter属性，跟节点html<br>13.所有层叠上下文内的元素会按照以下顺序，从后到前叠放：</p><p>  1.层叠上下文的根<br>  2.z-index为负的定位元素（及其子元素）<br>  3.非定位元素<br>  4.z-index为auto的定位元素（及其子元素）<br>  5.z-index为正的定位元素（及其子元素）</p><h1 id="第8章-响应式设计"><a href="#第8章-响应式设计" class="headerlink" title="第8章 响应式设计"></a>第8章 响应式设计</h1><p>1.响应式设计的三大原则如下</p><p>  (1) 移动优先。这意味着在实现桌面布局之前先构建移动版的布局。不要忘记给视口添加meta标签。<br>  (2) @media规则。使用这个样式规则，可以为不同大小的视口定制样式。用这一语法，通常叫作媒体查询（media queries），写的样式只在特定条件下才会生效。使用媒体查询，按照视口从小到大的顺序渐进增强网页。<br>  (3) 流式布局（fluid layout）。这种方式允许容器根据视口宽度缩放尺寸。</p><h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><h3 id="1-基础选择器"><a href="#1-基础选择器" class="headerlink" title="1.基础选择器"></a>1.基础选择器</h3><ol><li>tagname——类型选择器或者标签选择器。该选择器匹配目标元素的标签名。它的优先级是0,0,1。例如：p、h1、strong。</li><li>class——类选择器。该选择器匹配class属性中有指定类名的元素。它的优先级是0,1,0。例如：.media、.nav-menu。</li><li>#id——ID选择器。该选择器匹配拥有指定ID属性的元素。它的优先级是1,0,0。例如：#sidebar。</li><li>＊——通用选择器。该选择器匹配所有元素。它的优先级是0,0,0。</li></ol><h3 id="2-组合器"><a href="#2-组合器" class="headerlink" title="2.组合器"></a>2.组合器</h3><ol><li>子组合器（&gt;）——匹配的目标元素是其他元素的直接后代。例如：.parent &gt; .child。</li><li>相邻兄弟组合器（+）——匹配的目标元素紧跟在其他元素后面。例如：p + h2。</li><li>通用兄弟组合器（~）——匹配所有跟随在指定元素之后的兄弟元素。注意，它不会选中目标元素之前的兄弟元素。例如：li.active ~ li。</li></ol><h3 id="3-伪类选择器"><a href="#3-伪类选择器" class="headerlink" title="3.伪类选择器"></a>3.伪类选择器</h3><p>伪类选择器用于选中处于某个特定状态的元素。伪类选择器始终以一个冒号（:）开始。优先级等于一个类选择器（0,1,0）</p><ol><li>:first-child——匹配的元素是其父元素的第一个子元素。</li><li>:last-child——匹配的元素是其父元素的最后一个子元素。</li><li>:only-child——匹配的元素是其父元素的唯一一个子元素（没有兄弟元素）。</li><li>:nth-child(an+b)——匹配的元素在兄弟元素中间有特定的位置。</li><li>:nth-last-child(an+b)——类似于：nth-child()，但不是从第一个元素往后数，而是从最后一个元素往前数。</li><li>:first-of-type——类似于：first-child，但不是根据在全部子元素中的位置查找元素，而是根据拥有相同标签名的子元素中的数字顺序查找第一个元素。</li><li>:last-of-type——匹配每种类型的最后一个子元素。</li><li>:only-of-type——该选择器匹配的元素是满足该类型的唯一一个子元素。</li><li>:nth-of-type(an+b)——根据目标元素在特定类型下的数字顺序以及特定公式选择元素，类似于：nth-child。</li><li>nth-last-of-type(an+b)——根据元素类型以及特定公式选择元素，从其中最后一个元素往前算，类似于：nth-last-child。</li><li>:not(<code>&lt;selector&gt;</code>)——匹配的元素不匹配括号内的选择器。括号内的选择器必须是基础选择器，它只能指定元素本身，无法用于排除祖先元素，同时不允许包含另一个排除选择器。</li><li>:empty——匹配的元素必须没有子元素。注意，如果元素包含空格就无法由该选择器匹配，因为空格在DOM中属于文本节点。</li><li>:focus——匹配通过鼠标点击、触摸屏幕或者按Tab键导航而获得焦点的元素。</li><li>:hover——匹配鼠标指针正悬停在其上方的元素。</li><li>:root——匹配文档根元素.</li><li>:disabled——匹配已禁用的元素，包括input、select以及button元素。</li><li>:enabled——匹配已启用的元素，即那些能够被激活或者接受焦点的元素。</li><li>:checked——匹配已经针对选定的复选框、单选按钮或选择框选项。</li><li>:invalid——根据输入类型中的定义，匹配有非法输入值的元素。例如，当<input type="email">的值不是一个合法的邮箱地址时，该元素会被匹配（Level4）。</li><li>:valid——匹配有合法值的元素（Level4）。</li><li>:required——匹配设置了required属性的元素（Level4）。</li><li>:optional——匹配没有设置required属性的元素</li></ol><h3 id="4-伪元素选择器"><a href="#4-伪元素选择器" class="headerlink" title="4.伪元素选择器"></a>4.伪元素选择器</h3><p>伪元素类似于伪类，但是它不匹配特定状态的元素，而是匹配在文档中没有直接对应HTML元素的特定部分.<br>以双冒号（::）开头，尽管大多数浏览器也支持单冒号的语法以便向后兼容。伪元素选择器的优先级与类型选择器（0,0,1）相等</p><ol><li>::before——创建一个伪元素，使其成为匹配元素的第一个子元素。该元素默认是行内元素，可用于插入文字、图片或其他形状。必须指定content属性才能让元素出现，例如：.menu::before。</li><li>::after——创建一个伪元素，使其成为匹配元素的最后一个子元素。该元素默认是行内元素，可用于插入文字、图片或其他形状。必须指定content属性才能让元素出现，例如：.menu::after。1.</li><li>::first-letter——用于指定匹配元素的第一个文本字符的样式，例如：h2::first-letter。</li><li>::first-line——用于指定匹配元素的第一行文本的样式。</li><li>::selection——用于指定用户使用鼠标高亮选择的任意文本的样式。通常用于改变选中文本的background-color。只有少数属性可以使用，包括color、background-color、cursor、text-decoration。</li></ol><h3 id="5-属性选择器"><a href="#5-属性选择器" class="headerlink" title="5.属性选择器"></a>5.属性选择器</h3><p>属性选择器用于根据HTML属性匹配元素。其优先级与一个类选择器（0,1,0）相等</p><p>以下选择器区分大小写：</p><ol><li>[attr]——匹配的元素拥有指定属性attr，无论属性值是什么，例如：input[disabled]。</li><li>[attr=”value”]——匹配的元素拥有指定属性attr，且属性值等于指定的字符串值，例如：input[type=”radio”]。</li><li>[attr^=”value”]——“开头”属性选择器。该选择器匹配的元素拥有指定属性attr，且属性值的开头是指定的字符串值，例如：a[href^=”https”]。</li><li>[attr$=”value”]——“结尾”属性选择器。该选择器匹配的元素拥有指定属性attr，且属性值的结尾是指定的字符串值，例如：a[href$= “.pdf”]。</li><li>[attr＊=”value”]——“包含”属性选择器。该选择器匹配的元素拥有指定属性attr，且属性值包含指定的字符串值，例如：[class＊=”sprite-“]。</li><li>[attr~=”value”]——“空格分隔的列表”属性选择器。该选择器匹配的元素拥有指定属性attr，且属性值是一个空格分隔的值列表，列表中的某个值等于指定的字符串值，例如：a[rel=”author”]。</li><li>[attr|=”value”]——匹配的元素拥有指定属性attr，且属性值要么等于指定的字符串值，要么以该字符串开头且紧跟着一个连字符（-）。适用于语言属性，因为该属性有时候会指定一种语言的子集（比如墨西哥西班牙语，es-MX，或者普通的西班牙语，es），例如：[lang|=”es”]。</li></ol><p>不区分大小写的属性选择器：将i添加到结束方括号前面，input[value=”search”i]</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题</title>
      <link href="/ZJY.github.io/2022/03/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/ZJY.github.io/2022/03/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-js中-和-的区别？"><a href="#1-js中-和-的区别？" class="headerlink" title="1.js中 ?? 和 || 的区别？"></a>1.js中 ?? 和 || 的区别？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value1  ??  value2</span><br><span class="line">value1  ||  value2</span><br></pre></td></tr></table></figure><p>相同点：</p><p>  用法相同，都是符号前后是值，中间是符号。根据前面的值判断返回value1还是value2。</p><p>不同点：</p><p>  1.使用??时，只有当value1的值为null或undefined时才返回value2，否则返回value1<br>  2.使用||时，value1会转换为bool值，为true时返回value1,  false时返回value2</p><p>??更适合不知道变量是否有值时使用</p><h3 id="2-URI和URL的区别"><a href="#2-URI和URL的区别" class="headerlink" title="2.URI和URL的区别"></a>2.URI和URL的区别</h3><p>1.URI：统一资源标识符（Uniform Resource Identifier,URI）是一个标识某个互联网资源的字符串。表示Web上可用的每种资源-html文档、图像、视频片段、程序等由一个URI进行标识。</p><p>URI格式：[协议名]://[用户名]:[密码]@[服务器地址]:[端口号]/[路径]?[查询字符串]#[片段id]</p><p>2.URL：统一资源定位符（Uniform Resource Locator），采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL是URI概念的一种实现方式。</p><p>URL下列三部分组成:第一部分是协议（或称为服务方式）；第二部分是存有该资源的主机IP地址（有时也包括端口号）；第三部分是主机资源的具体地址。</p><p>3.URI和URL之间的区别</p><p>URI和URL都定义了资源是什么，但URL还定义了该如何访问资源。URL是一种具体的URI，它是URI的一个子集，它不仅唯一标识资源，而且还提供了定位该资源的信息。URI 是一种语义上的抽象概念，可以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位，是绝对的。</p><h3 id="3-Http中的301，302，303，307，308相应状态码"><a href="#3-Http中的301，302，303，307，308相应状态码" class="headerlink" title="3.Http中的301，302，303，307，308相应状态码"></a>3.Http中的301，302，303，307，308相应状态码</h3><ol><li><p>301 Move Permanently</p><p>表明资源永久的移动到了一个新的URI，任何未来对这个资源的引用都应该使用新的URI</p></li><li><p>302 Found</p><p>表明资源临时的移动到了一个新的URI，由于重定向是临时的，所以之后的请求还应该使用原本的URI<br>服务器会在响应头的Location字段放上这个不同的URI，浏览器可以使用这个URI进行自动重定向<br>注：由于历史原因，用户代理可能会在重定向后把请求的post改为get方法。</p></li><li><p>303 See Other</p><p>303 状态码表示服务器要将浏览器重定向到另一个资源，这个资源的 URI 会被写在响应 Header 的 Location 字段。从语义上讲，重定向到的资源并不是你所请求的资源，而是对你所请求资源的一些描述。<br>303 常用于将 POST 请求重定向到 GET 请求，比如你上传了一份个人信息，服务器发回一个 303 响应，将你导向一个“上传成功”页面。<br>不管原请求是什么方法，重定向请求的方法都是 GET（或 HEAD，不常用）</p></li><li><p>307 Temporary Redirect</p><p>307 的定义实际上和 302 是一致的，唯一的区别在于，307 状态码不允许浏览器将原本为 POST 的请求重定向到 GET 请求上</p></li><li><p>308 Permanent Redirect</p><p>308 的定义实际上和 301 是一致的，唯一的区别在于，308 状态码不允许浏览器将原本为 POST 的请求重定向到 GET 请求上</p></li></ol><h4 id="302和303、307的关系"><a href="#302和303、307的关系" class="headerlink" title="302和303、307的关系"></a>302和303、307的关系</h4><p>302允许各种各样的重定向，一般情况下都会重定向到get，但不能确保post重定向到post<br>303只允许任意请求重定向到get<br>307和302一样，但不允许post到get的重定向</p>]]></content>
      
      
      <categories>
          
          <category> 问题&amp;总结 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记nuxt服务端请求接口无法通过store获取token</title>
      <link href="/ZJY.github.io/2021/12/31/%E8%AE%B0nuxt%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%B7%E6%B1%82%E6%8E%A5%E5%8F%A3%E6%97%A0%E6%B3%95%E9%80%9A%E8%BF%87store%E8%8E%B7%E5%8F%96token/"/>
      <url>/ZJY.github.io/2021/12/31/%E8%AE%B0nuxt%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%B7%E6%B1%82%E6%8E%A5%E5%8F%A3%E6%97%A0%E6%B3%95%E9%80%9A%E8%BF%87store%E8%8E%B7%E5%8F%96token/</url>
      
        <content type="html"><![CDATA[<p>1.问题</p><p>使用nuxt框架,接口在fetch或者asyncData中调用时,导致无法获取登录凭证token</p><p>2.原因</p><p>页面正常跳转进入或第一次加载时,asyncData和fetch方法都是在客户端执行,页面手动刷新时asyncData和fetch是在服务端执行,因此获取不到存储在客户端数据</p><p>3.解决</p><p>在store状态树中指定nuxtServerInit 方法, Nuxt.js 调用它的时候会将页面的上下文对象作为第2个参数传给它（服务端调用时才会）.可以将数据存储在服务端在nuxtServerInit中将数据传到客户端.</p><p>假设登录后将登录凭证token存在cookie中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">login(params).then(res &#x3D;&gt; &#123;</span><br><span class="line">  this.$store.commit(&#39;setToken&#39;, token)</span><br><span class="line">  this.$cookies.set(&#39;token&#39;, token)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在store中actions中添加nuxtServerInit</span><br><span class="line">nuxtServerInit(&#123; commit &#125;, &#123; app, req, store &#125;) &#123;</span><br><span class="line">  console.log(</span><br><span class="line">    &#39;打印nuxtServerInit3&#39;,</span><br><span class="line">    req.headers.cookie,</span><br><span class="line">    app.$cookies.getAll()</span><br><span class="line">  )</span><br><span class="line">  store.commit(&#39;setToken&#39;, app.$cookies.get(&#39;token&#39;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在axios请求拦截中设置authroization</span><br><span class="line">$axios.onRequest((config) &#x3D;&gt; &#123;</span><br><span class="line">  config.headers[&#39;authroization&#39;] &#x3D; store.state.token</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>4.nuxt 使用cookie持久化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.安装</span></span><br><span class="line">yarn add cookie-universal-nuxt</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.config.nuxt.js</span></span><br><span class="line">modules: [</span><br><span class="line">  <span class="string">&#x27;cookie-universal-nuxt&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 问题&amp;总结 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令</title>
      <link href="/ZJY.github.io/2021/12/17/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/ZJY.github.io/2021/12/17/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>1.克隆项目 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone url</span><br></pre></td></tr></table></figure><p>2.创建分支</p><p>创建dev分支对应远程dev分支,并切换到dev分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev origin&#x2F;dev</span><br></pre></td></tr></table></figure><p>创建本地分支并切换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev</span><br></pre></td></tr></table></figure><p>提交本地分支到远程仓库,创建远程分支dev</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin dev</span><br></pre></td></tr></table></figure><p>3.切换分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev</span><br></pre></td></tr></table></figure><p>4.提交代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;暂存代码</span><br><span class="line">git add .</span><br><span class="line">&#x2F;&#x2F;提交暂存代码到本地仓库</span><br><span class="line">git commit -m &quot;commit info&quot;</span><br><span class="line">&#x2F;&#x2F;将本地仓库代码推送到远程仓库</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>5.删除分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 首先要切换到别的分支</span><br><span class="line">git branch -d dev</span><br><span class="line">git branch -D dev &#x2F;&#x2F; 强制删除</span><br><span class="line">git push origin --delete dev &#x2F;&#x2F; 删除远程分支</span><br></pre></td></tr></table></figure><p>6.打标签</p><p>列出标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure><p>创建轻量标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0</span><br></pre></td></tr></table></figure><p>后期打标签,可以对过去的提交打标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 先查看提交历史</span><br><span class="line">git log --pretty</span><br><span class="line"></span><br><span class="line">7d58683af833a44637800f89f2ee5fbacec436d8 (HEAD -&gt; develop, origin&#x2F;develop) 🐞 fix(input): 修复input-confirm-type:search时出现搜索图标</span><br><span class="line">aa3b910be51a9e682e5646f108f340d1248d6233 (tag: v1.0.0, origin&#x2F;build, build) 🐞 fix(招标公告详情): 公告进度样式处理16f0d68366724fcbc7b9121522d71724bdc70251 ✨ feat(注册): 1.新增注册功能 2.我的名称兼容</span><br><span class="line">648e1ef9701ec3bd8f48ec9f9dd9c97468dba3cc ✨ feat(app): 1.去掉耳机页面下拉刷新 2.去掉调试工具</span><br><span class="line">c2a3a051ef35e3babe39ef5127db78d337cc4f4e ✨ feat(设置): 去掉手机号</span><br><span class="line">7acae11b4aab2276efcec9ca54a4e7b100e8cd37 🐞 fix(tabbar页面): 1.修复tabbar页面接口执行2次</span><br><span class="line">b9975fca9ee199dd59b48457d37fd782e9be7721 🐞 fix(工作台): 招标列表详情取招标名称</span><br><span class="line">e3686c0c9892d205a44e1e9379ea546d50f38cb6 🐞 fix(时间格式化): 修复时间戳转换</span><br><span class="line">da2e37df1aabf25af302160db7596b55370bc58f 🐞 fix(资质认证): 认证状态处理</span><br><span class="line">281b56bc78d79782fcd1eb42ae98721cea2ac49c ✨ feat(tabar页面): 添加下拉刷新功能</span><br></pre></td></tr></table></figure><p>给最新一次提交打上v1.2标签,也就是7d58683af833a44637800f89f2ee5fbacec436d8,需要再命令的末尾指定提交的校验和(或部分校验和):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.2 7d58683af833</span><br></pre></td></tr></table></figure><p>可以看到打上标签了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br><span class="line">v1.1</span><br><span class="line">v1.2</span><br></pre></td></tr></table></figure><p>默认情况下,git push不会传送标签到远程仓库,创建完标签后必须显示推送到服务器上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin v1.2</span><br></pre></td></tr></table></figure><p>如果想要一次性推送很多标签，也可以使用带有 –tags 选项的 git push 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure><p>7.删除标签</p><p>删除本地仓库的标签,用git tag -d <tagname></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d v1.2</span><br></pre></td></tr></table></figure><p>上述命令不会从远程仓库删除这个标签,需用git push <remote> :refs/tags/<tagname>来更新远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :refs&#x2F;tags&#x2F;v1.2</span><br></pre></td></tr></table></figure><p>或者用以下命令删除远程标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete &lt;tagname&gt;</span><br></pre></td></tr></table></figure><p>8.回退已经提交(git push)到远程仓库的代码</p><p>git log找到commit id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br><span class="line">commit 7d58683af833a44637800f89f2ee5fbacec436d8 (HEAD -&gt; develop, origin&#x2F;develop)</span><br><span class="line">Author: zhaojunyan &lt;zhao.junyan@hxss.com.cn&gt;</span><br><span class="line">Date:   Fri Dec 3 09:40:22 2021 +0800</span><br><span class="line">...</span><br><span class="line">commit aa3b910be51a9e682e5646f108f340d1248d6233 (tag: v1.0.0, origin&#x2F;build, build)</span><br><span class="line">Author: zhaojunyan &lt;zhao.junyan@hxss.com.cn&gt;</span><br><span class="line">Date:   Wed Dec 1 15:35:20 2021 +0800</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>将代码回退到aa3b910be51a9e682e5646f108f340d1248d6233</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard aa3b910be51a9e682e5646f108f340d1248d6233 &#x2F;&#x2F; 回退本地提交</span><br><span class="line">git push --force &#x2F;&#x2F; 本地修改强制推送到远程仓库</span><br></pre></td></tr></table></figure><p>9.撤销git commit</p><p>1.git reset –soft 版本号<commit></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD^  &#x2F;&#x2F;回到上一个版本</span><br></pre></td></tr></table></figure><p>不删除工作区改动的代码，撤销commit，不撤销git add .</p><p>2.git reset –mixed 版本号 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --mixed HEAD^  &#x2F;&#x2F;回到上一个版本</span><br></pre></td></tr></table></figure><p>不删除工作区改动的代码，撤销commit，撤销git add .</p><p>3.git reset –hard 版本号 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^  &#x2F;&#x2F;回到上一个版本</span><br></pre></td></tr></table></figure><p>删除工作区的代码，撤销commit，撤销git add . 回到上一次commit的状态</p><p>10.仓库b 分支a同步 仓库a 分支a 的代码</p><p>1.仓库b添加仓库a连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add 仓库a的项目名 仓库a的git地址</span><br></pre></td></tr></table></figure><p>2.仓库b 拉取仓库a分支a 的最新代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull 仓库a的项目名 branch-a</span><br></pre></td></tr></table></figure><p>3.仓库b根据仓库a的分支a创建分支a</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b branch-a 仓库a的项目名&#x2F;branch-a</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add storeA storeA.git</span><br><span class="line">git pull storeA branch-a</span><br><span class="line">git checkout -b branch-a storeA&#x2F;branch-a</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记git have diverged</title>
      <link href="/ZJY.github.io/2021/12/17/%E8%AE%B0git-have-diverged/"/>
      <url>/ZJY.github.io/2021/12/17/%E8%AE%B0git-have-diverged/</url>
      
        <content type="html"><![CDATA[<h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h3><p>git出现Your branch and ‘origin/branch’ have diverged</p><p>如果不需要保留本地的修改:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git reset --hard origin&#x2F;branch</span><br></pre></td></tr></table></figure><p>如果需要保留本地的修改:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git rebase origin&#x2F;branch</span><br><span class="line">git pull --rebase</span><br><span class="line">解决冲突</span><br><span class="line">git rebase --continue</span><br><span class="line">git push origin branch</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 问题&amp;总结 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记Clipboard.js触发多次复制成功问题</title>
      <link href="/ZJY.github.io/2021/12/17/%E8%AE%B0Clipboard.js%E8%A7%A6%E5%8F%91%E5%A4%9A%E6%AC%A1%E5%A4%8D%E5%88%B6%E6%88%90%E5%8A%9F%E9%97%AE%E9%A2%98/"/>
      <url>/ZJY.github.io/2021/12/17/%E8%AE%B0Clipboard.js%E8%A7%A6%E5%8F%91%E5%A4%9A%E6%AC%A1%E5%A4%8D%E5%88%B6%E6%88%90%E5%8A%9F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h3><p>复制文字到剪切板,触发多次成功事件,导致多次提示复制成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const that &#x3D; this</span><br><span class="line">clipboard &#x3D; new Clipboard(&#39;#copyBtn&#39;)</span><br><span class="line">clipboard.on(&#39;success&#39;, function(e) &#123;</span><br><span class="line">  console.log(&#39;success&#39;, e.text)</span><br><span class="line">  that.$message.success(&#39;复制成功&#39;)</span><br><span class="line">  e.clearSelection()</span><br><span class="line">&#125;)</span><br><span class="line">clipboard.on(&#39;error&#39;, function(e) &#123;</span><br><span class="line">  that.$message.error(&#39;复制失败&#39;)</span><br><span class="line">  e.clearSelection()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-原因"><a href="#2-原因" class="headerlink" title="2.原因"></a>2.原因</h3><p>因项目是单页应用,没有及时清理事件及创建的对象.</p><h3 id="3-解决"><a href="#3-解决" class="headerlink" title="3.解决"></a>3.解决</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">beforeDestroy() &#123;</span><br><span class="line">  console.log(&#39;打印&#39;, &#39;destory&#39;)</span><br><span class="line">  clipboard.destroy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-clipboard简单使用"><a href="#4-clipboard简单使用" class="headerlink" title="4.clipboard简单使用"></a>4.clipboard简单使用</h3><p><a href="https://www.kancloud.cn/luponu/clipboardjs_zh/988266">clipboard.js中文文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记element table组件固定高度滑动底部数据渲染问题</title>
      <link href="/ZJY.github.io/2021/12/17/%E8%AE%B0element-table%E7%BB%84%E4%BB%B6%E5%9B%BA%E5%AE%9A%E9%AB%98%E5%BA%A6%E6%BB%91%E5%8A%A8%E5%BA%95%E9%83%A8%E6%95%B0%E6%8D%AE%E6%B8%B2%E6%9F%93%E9%97%AE%E9%A2%98/"/>
      <url>/ZJY.github.io/2021/12/17/%E8%AE%B0element-table%E7%BB%84%E4%BB%B6%E5%9B%BA%E5%AE%9A%E9%AB%98%E5%BA%A6%E6%BB%91%E5%8A%A8%E5%BA%95%E9%83%A8%E6%95%B0%E6%8D%AE%E6%B8%B2%E6%9F%93%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h3><p>element中table组件,设置固定高度height后,数据渲染超出设置高度后,鼠标向下滑动,此时包裹table元素<code>&lt;div class=&quot;el-table__body-wrapper is-scrolling-left/right/middle/none&quot;&gt;</code>scrollTop值为滚动距离,若此时切换到第二页,数据渲染未超出设置height,再切换到第一页,数据渲染超出设置高度后,此时table应有滚动条,但是table组件只渲染部分数据,没有出现滚动条,固定高度区域仍有空白.</p><h3 id="2-原因"><a href="#2-原因" class="headerlink" title="2.原因"></a>2.原因</h3><p>该元素<code>&lt;div class=&quot;el-table__body-wrapper is-scrolling-left/right/middle/none&quot;&gt;</code>scrollTop值仍为上一次滚动距离,没有重新归0,导致table只渲染部分数据,表格固定高度区域有空白,需要鼠标向下滚动才会重新渲染剩余数据</p><h3 id="3-解决"><a href="#3-解决" class="headerlink" title="3.解决"></a>3.解决</h3><p>每次数据改变时,判断该元素<code>&lt;div class=&quot;el-table__body-wrapper is-scrolling-left/right/middle/none&quot;&gt;</code>scrollTop值不为0时,强制归0.</p><p>给<code>&lt;el-table ref=&quot;baseTable&quot; /&gt;</code>组件设置ref属性值<br>打印$refs.baseTable组件,其$refs下有bodyWrapper组件,处理该组件scrollTop值即可<br>this.$refs.baseTable.$refs.bodyWrapper.scrollTop = 0</p>]]></content>
      
      
      <categories>
          
          <category> 问题&amp;总结 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nodejs 基础</title>
      <link href="/ZJY.github.io/2021/11/09/Nodejs-%E5%9F%BA%E7%A1%80/"/>
      <url>/ZJY.github.io/2021/11/09/Nodejs-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM操作性能提升</title>
      <link href="/ZJY.github.io/2021/06/09/DOM%E6%93%8D%E4%BD%9C%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/"/>
      <url>/ZJY.github.io/2021/06/09/DOM%E6%93%8D%E4%BD%9C%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/</url>
      
        <content type="html"><![CDATA[<p>在浏览器中DOM和Javascript通常是独立实现的，因此通过Javascript操作DOM会产生很大的性能消耗，因此需要尽可能地减少DOM操作</p><p>主要有以下几种方式：</p><h3 id="1-使用innerHTML代替DOM方法"><a href="#1-使用innerHTML代替DOM方法" class="headerlink" title="1.使用innerHTML代替DOM方法"></a>1.使用innerHTML代替DOM方法</h3><p>将多次DOM操作转换为字符串拼接，并一次性插入页面</p><h3 id="2-节点克隆"><a href="#2-节点克隆" class="headerlink" title="2.节点克隆"></a>2.节点克隆</h3><p>对于一些相同的节点，使用节点克隆(element.cloneNode)而不是节点创建(element.createElement)来创建</p><h3 id="3-尽可能少地使用HTML集合"><a href="#3-尽可能少地使用HTML集合" class="headerlink" title="3.尽可能少地使用HTML集合"></a>3.尽可能少地使用HTML集合</h3><p>以下方法返回的就是一个集合：</p><ul><li>document.getElementsByName()</li><li>document.getElementsByClassName()</li><li>document.getElementsByTagName()</li><li>document.images</li><li>document.links</li><li>document.forms</li><li>document.forms[0].elements</li></ul><p>HTML集以一种”假定实时态”实时存在，当底层文档对象更新时，它也会自动更新</p><p>一种可行的方法是将集的属性存入缓存变量中，或者将HTML集拷贝到普通数组</p><h3 id="4-减少渲染树的排队和刷新"><a href="#4-减少渲染树的排队和刷新" class="headerlink" title="4.减少渲染树的排队和刷新"></a>4.减少渲染树的排队和刷新</h3><p>获取页面布局信息的操作会导致队列刷新，如以下方法：</p><ul><li>offsetTop，offsetLeft，offsetWidth，offsetHeight</li><li>scrollTop，scrollLeft，scrollWith，scrollHeight</li><li>clientTop，clientLeft，clientWidth，clientHeight</li><li>getComputedStyle()</li></ul><p>尽量避免使用以上的方法</p><p>即使需要获取布局信息，也要将它保存在局部变量中，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 低效的</span></span><br><span class="line">element.style.left = <span class="number">1</span> + element.offsetLeft + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">element.style.top = <span class="number">1</span> + element.offsetTop + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (element.offsetLeft &gt;= <span class="number">500</span>) &#123;</span><br><span class="line">  <span class="comment">// dosomething();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高效的</span></span><br><span class="line"><span class="keyword">let</span> currentLeft = element.offsetLeft,</span><br><span class="line">    currentTop = element.offsetTop;</span><br><span class="line">currentLeft ++;</span><br><span class="line">currentTop ++;</span><br><span class="line">element.style.left = current + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">element.style.top = current + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (currentLeft &gt;= <span class="number">500</span>) &#123;</span><br><span class="line">  <span class="comment">// dosomething();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-批量修改dom"><a href="#5-批量修改dom" class="headerlink" title="5.批量修改dom"></a>5.批量修改dom</h3><p>提升方式：</p><ul><li>使元素脱离文档流</li><li>对其应用多重改变</li><li>把元素带回文档中</li></ul><p>使DOM脱离文档的方式：</p><ul><li>隐藏元素，应用修改，重新显示</li><li>使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档</li><li>将原始元素拷贝到一个脱离文档的节点中，修改副本，完成后再替换元素元素</li></ul><p>推荐尽可能地使用第二种方式，因为所产生的DOM遍历和重排次数最少</p><h3 id="6-事件委托"><a href="#6-事件委托" class="headerlink" title="6.事件委托"></a>6.事件委托</h3><p>当页面中有大量元素需要绑定事件处理器，尽可能使用事件委托。它基于这样一个事实：事件逐层冒泡并能被父级元素捕获。使用事件代理，只需给外层元素绑定一个处理器，就可以处理在其子元素上触发的所有事件。</p><p>每个事件经历的阶段：</p><ul><li>捕获阶段</li><li>目标阶段</li><li>冒泡阶段</li></ul>]]></content>
      
      
      <categories>
          
          <category> 问题&amp;总结 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>监听页面关闭</title>
      <link href="/ZJY.github.io/2021/06/09/%E7%9B%91%E5%90%AC%E9%A1%B5%E9%9D%A2%E5%85%B3%E9%97%AD/"/>
      <url>/ZJY.github.io/2021/06/09/%E7%9B%91%E5%90%AC%E9%A1%B5%E9%9D%A2%E5%85%B3%E9%97%AD/</url>
      
        <content type="html"><![CDATA[<h3 id="1-beforeunload"><a href="#1-beforeunload" class="headerlink" title="1.beforeunload"></a>1.beforeunload</h3><p>当浏览器窗口刷新或关闭时，会触发beforeunload事件。当前页面可见，不会直接关闭，可以点击确定按钮关闭或刷新页面，也可以取消刷新和关闭。</p><p>事件使网页能够触发一个确认对话框，询问用户是否真的要离开该页面。如果用户确认，浏览器将导航到新页面，否则导航将会取消。</p><p>根据规范，要显示确认对话框，事件处理程序需要在事件上调用preventDefault()。</p><p>HTML规范指出应该使用 Event.preventDefault() 而非 Event.returnValue，然而，不是所有浏览器都支持这么做。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;beforeunload&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Cancel the event as stated by the standard.</span></span><br><span class="line">  event.preventDefault();</span><br><span class="line">  <span class="comment">// Chrome requires returnValue to be set.</span></span><br><span class="line">  event.returnValue = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-unload事件"><a href="#2-unload事件" class="headerlink" title="2.unload事件"></a>2.unload事件</h3><p>当文档或一个子资源正在被卸载时, 触发 unload事件</p><p>它在下面两个事件后被触发:<br>1.beforeunload (可取消默认行为的事件)<br>2.pagehide</p><p>文档处于以下状态：</p><ul><li>所有资源仍存在（图片，iframe等）</li><li>对于用户所有资源均不可见</li><li>界面交互无效（window.open,alert,confirm等）</li><li>错误不会停止卸载文档的过程</li></ul><h3 id="3-上报请求"><a href="#3-上报请求" class="headerlink" title="3.上报请求"></a>3.上报请求</h3><p>如果我们在监听事件中发送ajax来上报数据，请求会被浏览器abort。因为在页面卸载的时候，浏览器并不能保证异步的请求能够成功<br>对于这个行为，我们可以使用下面的方式：<br>1.发送同步ajax</p><p>此种方式用户需要等待请求结束才可以关闭页面，会影响用户体验</p><p>2.发送异步ajax，但在服务端忽略ajax的abort</p><p>此种方式需要后台进行改造，成本太大</p><p>3.使用navigator.sendBeacon发送异步请求</p><p>使用：navigator.sendBeason(url [,data]);<br>其中data可以是 ArrayBufferView、Blob、DOMString、FormData等类型</p>]]></content>
      
      
      <categories>
          
          <category> 问题&amp;总结 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DomContentLoaded事件解析</title>
      <link href="/ZJY.github.io/2021/06/09/DomContentLoaded%E4%BA%8B%E4%BB%B6%E8%A7%A3%E6%9E%90/"/>
      <url>/ZJY.github.io/2021/06/09/DomContentLoaded%E4%BA%8B%E4%BB%B6%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="1-DOMContentLoaded事件"><a href="#1-DOMContentLoaded事件" class="headerlink" title="1.DOMContentLoaded事件"></a>1.DOMContentLoaded事件</h3><p>当初始的HTML文档被完全加载和解析完成之后，DOMContentLoaded事件被触发，而无需等待样式表、图像和子框架的完全加载。</p><h3 id="2-load事件"><a href="#2-load事件" class="headerlink" title="2.load事件"></a>2.load事件</h3><p>当整个页面及所有依赖资源如样式表和图片都已完成加载时，将触发load事件</p><p><b>DOMContentLoaded事件和load事件区别：</b><br>DOMContentLoaded在HTML文档被解析完成之后触发，而load是在HTML所有相关资源被加载完成后触发</p><h3 id="3-HTML解析过程与DOMContentLoaded触发时机"><a href="#3-HTML解析过程与DOMContentLoaded触发时机" class="headerlink" title="3.HTML解析过程与DOMContentLoaded触发时机"></a>3.HTML解析过程与DOMContentLoaded触发时机</h3><h4 id="1-在既没有css也没有js情况下，HTML文档的解析过程为："><a href="#1-在既没有css也没有js情况下，HTML文档的解析过程为：" class="headerlink" title="1.在既没有css也没有js情况下，HTML文档的解析过程为："></a>1.在既没有css也没有js情况下，HTML文档的解析过程为：</h4><p><img src="/ZJY.github.io/images/domcontentload/domcontentload1.jpg" alt="image"></p><p>DOMContentLoaded事件的触发时机为:HTML解析为DOM之后</p><h4 id="2-有css无js情况下，HTML文档的解析过程为："><a href="#2-有css无js情况下，HTML文档的解析过程为：" class="headerlink" title="2.有css无js情况下，HTML文档的解析过程为："></a>2.有css无js情况下，HTML文档的解析过程为：</h4><p><img src="/ZJY.github.io/images/domcontentload/domcontent2.jpg" alt="image"></p><p>渲染树的生成是基于DOM和CSSOM的。但是触发DOMContentLoaded的时间依然是在HTML解析为DOM后，无论此时CSS解析为CSSOM的过程是否完成</p><h4 id="3-当有js和css时，HTML文档的解析过程为："><a href="#3-当有js和css时，HTML文档的解析过程为：" class="headerlink" title="3.当有js和css时，HTML文档的解析过程为："></a>3.当有js和css时，HTML文档的解析过程为：</h4><p><img src="/ZJY.github.io/images/domcontentload/domcontent3.jpg" alt="image"></p><p>网页从空白到出现内容所花费的时间，就是html文档加载和解析的时间，也就是DOMContentLoaded事件触发之前所经历的时间。<br>所以对于首屏时间而言，js放在html文档的开头和结尾效果是一样的。而js放在结尾的目的并不是为了减少首屏时间，而是由于js经常需要操作dom，放在后面才更能保证找到dom节点。</p><h4 id="4-同步-异步脚本"><a href="#4-同步-异步脚本" class="headerlink" title="4.同步/异步脚本"></a>4.同步/异步脚本</h4><p>同步脚本：<br>html文档解析时如果遇见同步脚本，则停止解析，先加载脚本再执行，执行结束后继续解析HTML文档。HTML文档解析完毕后触发DOMContentLoaded事件</p><p>异步脚本：</p><ul><li>defer</li></ul><p>当 HTML 文档被解析时如果遇见 defer 脚本，则在后台加载脚本，文档解析过程不中断，而等文档解析结束之后，defer 脚本执行。另外，defer 脚本的执行顺序与定义时的位置有关。在前面的script会先执行</p><ul><li>async</li></ul><p>当 HTML 文档被解析时如果遇见 async 脚本，则在后台加载脚本，文档解析过程不中断。脚本加载完成后，文档停止解析，脚本执行，执行结束后文档继续解析</p><p>带async的脚本一定会在load事件之前执行，可能会在DOMContentLoaded之前或之后执行。</p><p>1.当HTML还没有被解析完的时候，async脚本已经加载完了，那么HTML停止解析，去执行脚本，脚本执行完后继续解析HTML文档，然后触发DOMContentLoaded事件</p><p><img src="/ZJY.github.io/images/domcontentload/domcontent4.jpg" alt="image"></p><p>2.HTML 解析完了之后，async脚本才加载完，然后再执行脚本，那么在HTML解析完毕、async脚本还没加载完的时候就触发DOMContentLoaded事件。如下图所示：</p><p><img src="/ZJY.github.io/images/domcontentload/domcontent5.jpg" alt="image"></p><p>总之， DomContentLoaded 事件只关注 HTML 是否被解析完，而不关注 async 脚本。</p><p>defer<br>如果script标签含有defer，那么这一块脚本将不会影响 HTML 文档的解析，而是等到 HTML 解析完成后才会执行。而 DOMContentLoaded 只有在 defer 脚本执行结束后才会被触发。</p><p>defer脚本同样包含两种情况：</p><p>1.HTML还没解析完成时，defer脚本已经加载完毕，那么defer脚本将等待HTML解析完成后再执行。defer脚本执行完毕后触发DOMContentLoaded事件。如下图所示</p><p><img src="/ZJY.github.io/images/domcontentload/domcontent6.png" alt="image"></p><p>2.HTML解析完成时，defer脚本还没加载完毕，那么defer脚本继续加载，加载完成后直接执行，执行完毕后触发DOMContentLoaded事件。如下图所示:</p><p><img src="/ZJY.github.io/images/domcontentload/domcontent7.png" alt="image"></p><p><b>defer与DOMContentLoaded</b></p><p>如果 script 标签中包含 defer，那么这一块脚本将不会影响 HTML 文档的解析，而是等到 HTML 解析完成后才会执行。而 DOMContentLoaded 只有在 defer 脚本执行结束后才会被触发。 所以这意味着什么呢？HTML 文档解析不受影响，等 DOM 构建完成之后 defer 脚本执行，但脚本执行之前需要等待 CSSOM 构建完成。在 DOM、CSSOM 构建完毕，defer 脚本执行完成之后，DOMContentLoaded 事件触发。</p><p><b>async与DOMContentLoaded</b><br> DomContentLoaded 事件只关注 HTML 是否被解析完，而不关注 async 脚本。</p>]]></content>
      
      
      <categories>
          
          <category> 问题&amp;总结 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域问题总结</title>
      <link href="/ZJY.github.io/2021/06/08/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/ZJY.github.io/2021/06/08/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="1-浏览器的同源策略"><a href="#1-浏览器的同源策略" class="headerlink" title="1.浏览器的同源策略"></a>1.浏览器的同源策略</h3><p>浏览器的同源策略，它用于限制一个源的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。</p><h3 id="2-同源的定义"><a href="#2-同源的定义" class="headerlink" title="2.同源的定义"></a>2.同源的定义</h3><p>如果两个url的协议/端口/主机都相同的话，则这两个url是同源，这个方案也被称为“协议/主机/端口元组”，或者直接是“元组”</p><p>下表给出与url：”<a href="http://store.company.com/dir/page.html&quot;">http://store.company.com/dir/page.html&quot;</a> 的源进行对比示例：</p><table><thead><tr><th align="center">URL</th><th align="center">结果</th><th align="center">原因</th></tr></thead><tbody><tr><td align="center"><a href="http://store.company.com/dir2/other.html">http://store.company.com/dir2/other.html</a></td><td align="center">同源</td><td align="center">只有路径不同</td></tr><tr><td align="center"><a href="http://store.company.com/dir/inner/another.html">http://store.company.com/dir/inner/another.html</a></td><td align="center">同源</td><td align="center">只有路径不同</td></tr><tr><td align="center"><a href="https://store.company.com/secure.html">https://store.company.com/secure.html</a></td><td align="center">失败</td><td align="center">协议不同</td></tr><tr><td align="center"><a href="http://store.company.com:81/dir/etc.html">http://store.company.com:81/dir/etc.html</a></td><td align="center">失败</td><td align="center">端口不同 ( http:// 默认端口是80)</td></tr><tr><td align="center"><a href="http://news.company.com/dir/other.html">http://news.company.com/dir/other.html</a></td><td align="center">失败</td><td align="center">主机不同</td></tr></tbody></table><p>一下是可能嵌入跨域资源的示例：</p><ul><li><code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code>标签嵌入跨域脚本</li><li><code> &lt;link rel=&quot;stylesheet&quot; href=&quot;&quot;&gt;</code>标签嵌入css</li><li>通过<code>&lt;img&gt;</code>展示的图片</li><li>通过<code>&lt;video&gt;</code>和<code>&lt;audio&gt;</code>播放的多媒体资源</li><li>通过<code>&lt;object&gt;</code> <code>&lt;embed&gt;</code> <code>&lt;applet&gt;</code>嵌入的插入就</li><li>通过<code>@font-face</code> 引入的字体。一些浏览器允许跨域字体，一些需要同源字体</li><li>通过<code>&lt;iframe&gt;</code>载入的任何资源。站点可以使用 X-Frame-Options 消息头来阻止这种形式的跨域交互。</li></ul><h3 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h3><p>1.jsonp<br>2.ajax<br>3.CORS<br>4.document.domain + iframe<br>5.window.postMessage()<br>6.window.name + iframe<br>7.nginx代理</p><p>1.jsonp跨域<br>原理：动态生成一个script标签，插入head中，浏览器会执行script标签中的代码，但是只能失效get请求</p><p>具体实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">  script.type = <span class="string">&#x27;text/javascript&#x27;</span></span><br><span class="line"></span><br><span class="line">  script.src = <span class="string">&#x27;http://www.example.com?name=michael&amp;callback=onCallback&#x27;</span></span><br><span class="line">  <span class="built_in">document</span>.head.appendChild(script)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onCallback</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(res))</span><br><span class="line">    <span class="comment">// 处理数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>服务器返回后执行onCallback 函数</p><p>2.Ajax请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url: <span class="string">&#x27;http://www.example.com&#x27;</span>,</span><br><span class="line">  type: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">  dataType: <span class="string">&#x27;jsonp&#x27;</span>,</span><br><span class="line">  jsonpCallback: <span class="string">&#x27;onCallback&#x27;</span>,</span><br><span class="line">  data: &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3.CORS方式</p><p>Cross-Origin Resource Sharing可以使用cors来允许跨域访问。cors是http的一部分，它阴虚服务端来指定哪些主机可以从这个服务端加载资源。</p><p>前端配置withCredentials:true,设置提供凭据信息(cookie、HTTP认证及客户端SSL证明等)，当前请求为跨域类型时是否在请求中协带cookie。</p><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）<br>只要同时满足以下两大条件，就属于简单请求。<br>（1) 请求方法是以下三种方法之一：</p><ul><li>HEAD</li><li>GET</li><li>POST</li></ul><p>（2）HTTP的头信息不超出以下几种字段：</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain<br>凡是不同时满足上面两个条件，就属于非简单请求。</li></ul><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。origin字段用来说明本次请求用哪个源（协议，端口，域名），服务器根据这个值判断是否接受这次请求。<br>Access-Control-Allow-Origin：它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求<br>Access-Control-Allow-Credentials：它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器</p><p>withCredentials 属性：<br>CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。Access-Control-Allow-Credentials: true。另一方面，开发者必须在AJAX请求中打开withCredentials属性，xhr.withCredentials = true;<br>需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。</p><p>非简单请求：非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。</p><p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。<br>“预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。除了Origin字段，”预检”请求的头信息包括两个特殊字段。Access-Control-Request-Method用来列出浏览器的CORS请求会用到哪些HTTP方法</p><p>CORS与JSONP的使用目的相同，但是比JSONP更强大。</p><p>JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据</p><p>4.Document.domain + iframe</p><p>条件：<br>页面 <a href="http://www.example.com/a.html">http://www.example.com/a.html</a></p><p>页面中有一个iframe <a href="http://iframe.com/b.html">http://iframe.com/b.html</a></p><p>方式：<br>将两个页面的document.domain 设置成相同的域名，就可以在页面中拿到iframe中的数据</p><p>限制：<br>只能把document.domain设置成自身或更高一级的父域</p><p>实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.html</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">&#x27;example.com&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">iframe.src = <span class="string">&#x27;http://iframe.com/b.html&#x27;</span>;</span><br><span class="line">iframe.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line">iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> doc = iframe.contentDocument || iframe.contentWindow.document;</span><br><span class="line">    <span class="built_in">console</span>.log(doc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//b.html</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">&#x27;example.com&#x27;</span>;</span><br></pre></td></tr></table></figure><p>5.window.postMessage()<br>HTML5的新特性，允许来自不同源的脚本采用异步方式进行通信，实现跨域传递消息</p><p>使用方法：</p><p>postMessage(data, origin)</p><p>data: html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化</p><p>origin: 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“</p><p>实现:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://www.example.com/a.html</span></span><br><span class="line">&lt;iframe src=<span class="string">&quot;http://www.example2.com/b.html&quot;</span> style=<span class="string">&quot;display: none;&quot;</span> id=<span class="string">&quot;ifr&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;ifr&#x27;</span>);</span><br><span class="line">iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> data = &#123;&#125;;</span><br><span class="line">        iframe.contentWindow.postMessage(<span class="built_in">JSON</span>.stringify(data), <span class="string">&#x27;http://www.example2.com&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受传输的数据</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.data);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://www.example2.com/b.html</span></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.data);</span><br><span class="line">&#125;)    </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>6.window.name + iframe<br>原理：window.name 在不同的页面加载后依然存在，最大为2M</p>]]></content>
      
      
      <categories>
          
          <category> 问题&amp;总结 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6</title>
      <link href="/ZJY.github.io/2021/05/08/ES6/"/>
      <url>/ZJY.github.io/2021/05/08/ES6/</url>
      
        <content type="html"><![CDATA[<h3 id="1-let和const命令"><a href="#1-let和const命令" class="headerlink" title="1.let和const命令"></a>1.let和const命令</h3><p>1.let命令</p><p><b>基本用法</b><br>let用来声明变量，和var语法类似，但声明的变量只在let命令所在代码块中有效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line"><span class="comment">//ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure><p><b>不存在变量提升</b><br>var声明的变量会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。<br>为了纠正这种现象，let命令改变了语法行为。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 输出undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// 报错ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><b>暂时性死区</b></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码块中，使用let命令声明变量之前，该变量是不可用的，在语法上称为“暂时性死区”（TDZ）。</p><p>ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// TDZ开始</span></span><br><span class="line">  tmp = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> tmp; <span class="comment">// TDZ结束</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">123</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在let命令声明tmp变量之前，都属于变量tmp的死区。</p><p>“暂时性死区”意味着typeof不再是一个安全的操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> x; <span class="comment">// ReferenceError:x is not defined</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br></pre></td></tr></table></figure><p>如果一个变量没有被声明，使用typeof反而不会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> undeclared_variable <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">var</span> x = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> x = x; <span class="comment">// 使用let声明变量时，只要变量声明没有完成之前使用就会报错，在变量x声明语句还没有执行完成前就去取x的值，导致报错</span></span><br><span class="line"><span class="comment">// ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure><p>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p><p><b>不允许重复声明</b><br>let不允许在同一个作用域，重复声明已被var和let声明过的变量</p><p><b>块级作用域</b><br>ES5 只有全局作用域和函数作用域，没有块级作用域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(n); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><b>块级作用域与函数声明</b><br>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错</p><p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am outside!&#x27;</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am inside!&#x27;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>在ES5中会得到’I am inside!’，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am outside!&#x27;</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am inside!&#x27;</span>); &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>ES6规定浏览器的实现可以不遵守上面的规定：</p><ul><li>允许在块级作用域内声明函数。</li><li>函数声明类似于var，即会提升到全局作用域或函数作用域的头部。</li><li>同时，函数声明还会提升到所在的块级作用域的头部</li></ul><p>上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。<br>根据这三条规则，在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器的 ES6 环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am outside!&#x27;</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am inside!&#x27;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure><p>上面代码在符合es6的浏览器中都会报错，实际运行下面代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器的 ES6 环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am outside!&#x27;</span>); &#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am inside!&#x27;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure><p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明语句</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">&#x27;secret&#x27;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">&#x27;secret&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>2.const命令<br><b>基本用法</b><br>const声明一个只读的常量。一旦声明，常量的值就不能改变。<br>const声明的常量，也与let一样不可重复声明。</p><p><b>本质</b><br>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了</p><p><b>顶层对象的属性</b><br>顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.a = <span class="number">1</span>;</span><br><span class="line">a <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性</p><h3 id="2-变量的解构赋值"><a href="#2-变量的解构赋值" class="headerlink" title="2.变量的解构赋值"></a>2.变量的解构赋值</h3><p><b>数组的解构赋值</b><br>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a <span class="comment">//1</span></span><br><span class="line">b <span class="comment">//2</span></span><br><span class="line">c <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line">foo <span class="comment">// 1</span></span><br><span class="line">bar <span class="comment">// 2</span></span><br><span class="line">baz <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>];</span><br><span class="line">third <span class="comment">// &quot;baz&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">head <span class="comment">// 1</span></span><br><span class="line">tail <span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">x <span class="comment">// &quot;a&quot;</span></span><br><span class="line">y <span class="comment">// undefined</span></span><br><span class="line">z <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>如果解构不成功，变量的值就等于undefined.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo] = []; <span class="comment">//foo:undefined</span></span><br><span class="line"><span class="keyword">let</span> [bar, foo] = [<span class="number">1</span>]; <span class="comment">//foo:undefined</span></span><br></pre></td></tr></table></figure><p>等号左边的模式，只匹配一部分的等号右边的数组，叫不完全解构，也可以解构成功</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br><span class="line">d <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构），那么将会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>对于 Set 结构，也可以使用数组的解构赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y, z] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]);</span><br><span class="line">x <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure><p><b>默认值</b><br>解构赋值允许指定默认值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="literal">undefined</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br></pre></td></tr></table></figure><p>ES6内部采用严格相等运算符===，判断一个位置是否有值，所以一个数组成员不严格等于undefined，默认值不会生效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [];     <span class="comment">// x=1; y=1</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">2</span>];    <span class="comment">// x=2; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// x=1; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = [];     <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><p><b>对象的解构赋值</b><br>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;aaa&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;bbb&quot;</span> &#125;;</span><br><span class="line">foo <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">bar <span class="comment">// &quot;bbb&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;aaa&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;bbb&quot;</span> &#125;;</span><br><span class="line">baz <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>如果变量名和属性名不一致，必须写出下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">baz <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">&#x27;hello&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;world&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">first</span>: f, <span class="attr">last</span>: l &#125; = obj;</span><br><span class="line">f <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line">l <span class="comment">// &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure><p>对象的解构赋值是下面形式的简写:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: foo, <span class="attr">bar</span>: bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;aaa&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;bbb&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><p>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;aaa&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;bbb&quot;</span> &#125;;</span><br><span class="line">baz <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">foo <span class="comment">// error: foo is not defined</span></span><br></pre></td></tr></table></figure><p>对象的解构赋值也可以指定默认值。默认值生效的条件是，对象的属性值严格等于undefined。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">x <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">null</span>&#125;;</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p><b>字符串的解构赋值</b><br>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">a <span class="comment">// &quot;h&quot;</span></span><br><span class="line">b <span class="comment">// &quot;e&quot;</span></span><br><span class="line">c <span class="comment">// &quot;l&quot;</span></span><br><span class="line">d <span class="comment">// &quot;l&quot;</span></span><br><span class="line">e <span class="comment">// &quot;o&quot;</span></span><br></pre></td></tr></table></figure><p>类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">len <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p><b>数值和布尔值的解构赋值</b><br>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mock基本使用</title>
      <link href="/ZJY.github.io/2021/05/07/mock%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/ZJY.github.io/2021/05/07/mock%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Mock：生成随机数据，拦截-Ajax-请求"><a href="#Mock：生成随机数据，拦截-Ajax-请求" class="headerlink" title="Mock：生成随机数据，拦截 Ajax 请求"></a>Mock：生成随机数据，拦截 Ajax 请求</h2><h3 id="1-安装使用"><a href="#1-安装使用" class="headerlink" title="1.安装使用"></a>1.安装使用</h3><p>Bower</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g bower</span><br><span class="line">bower install --save mockjs</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;./bower_components/mockjs/dist/mock.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="2-基础使用"><a href="#2-基础使用" class="headerlink" title="2.基础使用"></a>2.基础使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String</span></span><br><span class="line"><span class="keyword">var</span> data = Mock.mock(&#123;</span><br><span class="line">  <span class="string">&quot;String|1-10&quot;</span>: <span class="string">&quot;*&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line"><span class="comment">// &#123;String:&#x27;***&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = Mock.mock(&#123;</span><br><span class="line">  <span class="string">&#x27;string|3&#x27;</span>: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line"><span class="comment">// &#123;string: &quot;aaa&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Number</span></span><br><span class="line"><span class="keyword">var</span> data = Mock.mock(&#123;</span><br><span class="line">  <span class="string">&quot;number|1-100&quot;</span>: <span class="number">202</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line"><span class="comment">// &#123;number:57&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = Mock.mock(&#123;</span><br><span class="line">  <span class="string">&quot;number|1-100.1-10&quot;</span>: <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line"><span class="comment">// &#123;number: 22.772934&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Boolean</span></span><br><span class="line"><span class="keyword">var</span> data = Mock.mock(&#123;</span><br><span class="line">  <span class="string">&quot;boolean|1&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line"><span class="comment">// &#123;boolean:true&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object</span></span><br><span class="line"><span class="keyword">var</span> data = Mock.mock(&#123;</span><br><span class="line">  <span class="string">&quot;object|2&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;310000&quot;</span>: <span class="string">&quot;上海市&quot;</span>,</span><br><span class="line">    <span class="string">&quot;320000&quot;</span>: <span class="string">&quot;江苏省&quot;</span>,</span><br><span class="line">    <span class="string">&quot;330000&quot;</span>: <span class="string">&quot;浙江省&quot;</span>,</span><br><span class="line">    <span class="string">&quot;340000&quot;</span>: <span class="string">&quot;安徽省&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   &quot;object&quot;: &#123;</span></span><br><span class="line"><span class="comment">//     &quot;330000&quot;: &quot;浙江省&quot;,</span></span><br><span class="line"><span class="comment">//     &quot;340000&quot;: &quot;安徽省&quot;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = Mock.mock(&#123;</span><br><span class="line">  <span class="string">&quot;object|2-4&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;110000&quot;</span>: <span class="string">&quot;北京市&quot;</span>,</span><br><span class="line">    <span class="string">&quot;120000&quot;</span>: <span class="string">&quot;天津市&quot;</span>,</span><br><span class="line">    <span class="string">&quot;130000&quot;</span>: <span class="string">&quot;河北省&quot;</span>,</span><br><span class="line">    <span class="string">&quot;140000&quot;</span>: <span class="string">&quot;山西省&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   &quot;object&quot;: &#123;</span></span><br><span class="line"><span class="comment">//     &quot;110000&quot;: &quot;北京市&quot;,</span></span><br><span class="line"><span class="comment">//     &quot;120000&quot;: &quot;天津市&quot;,</span></span><br><span class="line"><span class="comment">//     &quot;140000&quot;: &quot;山西省&quot;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array</span></span><br><span class="line"><span class="keyword">var</span> data = Mock.mock(&#123;</span><br><span class="line">  <span class="string">&quot;array|2&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;AMD&quot;</span>,</span><br><span class="line">    <span class="string">&quot;CMD&quot;</span>,</span><br><span class="line">    <span class="string">&quot;UMD&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line"><span class="comment">// 随机产生一个元素</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   &quot;array&quot;: &quot;AMD&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = Mock.mock(&#123;</span><br><span class="line">  <span class="string">&quot;array|1-10&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;Mock.js&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line"><span class="comment">// 随机产生1-10个数组元素</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   &quot;array&quot;: [</span></span><br><span class="line"><span class="comment">//     &quot;Mock.js&quot;,</span></span><br><span class="line"><span class="comment">//     &quot;Mock.js&quot;</span></span><br><span class="line"><span class="comment">//   ]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// RegExp</span></span><br><span class="line"><span class="keyword">var</span> data = Mock.mock(&#123;</span><br><span class="line">  <span class="string">&#x27;regexp&#x27;</span>: <span class="regexp">/[a-z][A-Z][0-9]/</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line"><span class="comment">// &#123;regexp: &quot;jS2&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = Mock.mock(&#123;</span><br><span class="line">  <span class="string">&#x27;regexp&#x27;</span>: <span class="regexp">/\d&#123;5,10&#125;/</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line"><span class="comment">// &#123;regexp: &quot;78998&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = Mock.mock(&#123;</span><br><span class="line">  <span class="string">&#x27;regexp|3&#x27;</span>: <span class="regexp">/\d&#123;5,10&#125;\-/</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   &quot;regexp&quot;: &quot;28739-1401541809-15613-&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据占位符定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机布尔值</span></span><br><span class="line">Random.boolean()</span><br><span class="line">Mock.mock(<span class="string">&#x27;@boolean&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@boolean()&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机自然数</span></span><br><span class="line">Random.natural()</span><br><span class="line">Mock.mock(<span class="string">&#x27;@natural&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@natural()&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Random.integer()</span><br><span class="line">Mock.mock(<span class="string">&#x27;@integer&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@integer()&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Random.float()</span><br><span class="line">Mock.mock(<span class="string">&#x27;@float&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@float()&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Random.character()</span><br><span class="line">Mock.mock(<span class="string">&#x27;@character&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@character()&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Random.string()</span><br><span class="line">Mock.mock(<span class="string">&#x27;@string&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@string()&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Random.range(<span class="number">10</span>) <span class="comment">//[0,1,2,3,4,5,6,7,8,9]</span></span><br><span class="line">Mock.mock(<span class="string">&#x27;@range(10)&#x27;</span>) <span class="comment">//[0,1,2,3,4,5,6,7,8,9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Date</span></span><br><span class="line">Random.date()</span><br><span class="line">Mock.mock(<span class="string">&#x27;@date&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@date()&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Random.date( format )</span></span><br><span class="line">Random.date(<span class="string">&#x27;yyyy-MM-dd&#x27;</span>)</span><br><span class="line">Random.date(<span class="string">&#x27;yy-MM-dd&#x27;</span>)</span><br><span class="line">Random.date(<span class="string">&#x27;y-MM-dd&#x27;</span>)</span><br><span class="line">Random.date(<span class="string">&#x27;y-M-d&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Mock.mock(<span class="string">&#x27;@date(&quot;yyyy-MM-dd&quot;)&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@date(&quot;yy-MM-dd&quot;)&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@date(&quot;y-MM-dd&quot;)&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@date(&quot;y-M-d&quot;)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Mock.mock(<span class="string">&#x27;@date(&quot;yyyy yy y MM M dd d&quot;)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Random.time()</span><br><span class="line">Mock.mock(<span class="string">&#x27;@time&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@time()&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Random.time( format )</span></span><br><span class="line">Random.time(<span class="string">&#x27;A HH:mm:ss&#x27;</span>)</span><br><span class="line">Random.time(<span class="string">&#x27;a HH:mm:ss&#x27;</span>)</span><br><span class="line">Random.time(<span class="string">&#x27;HH:mm:ss&#x27;</span>)</span><br><span class="line">Random.time(<span class="string">&#x27;H:m:s&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Mock.mock(<span class="string">&#x27;@time(&quot;A HH:mm:ss&quot;)&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@time(&quot;a HH:mm:ss&quot;)&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@time(&quot;HH:mm:ss&quot;)&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@time(&quot;H:m:s&quot;)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Mock.mock(<span class="string">&#x27;@datetime(&quot;HH H hh h mm m ss s SS S A a T&quot;)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Random.datetime()</span><br><span class="line">Mock.mock(<span class="string">&#x27;@datetime&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@datetime()&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Random.now()</span><br><span class="line">Mock.mock(<span class="string">&#x27;@now&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@now()&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图片</span></span><br><span class="line"><span class="comment">// Random.image( size?, background?, foreground?, format?, text? )</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Random.color()</span><br><span class="line">Mock.mock(<span class="string">&#x27;@color&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@color()&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Random.rgb()</span><br><span class="line">Random.hex()</span><br><span class="line">Random.rgba()</span><br><span class="line">Random.hsl()</span><br><span class="line"></span><br><span class="line">Random.paragraph() <span class="comment">// &quot;Oksf fvugvxa oujindgp kmqyw iashota cdmukan tglfyxsfi kxbughdzn jvwt vepovtdog phnnjp nftibvwbw uqau. Xebwbu vpvrsff nxk cagcub fmglp svbpmajru dddi kvtuoggxm qpj ovheukv httjfkfir fpnhofukk. Lgtwosm riquhht ympctsdx yytczkwe tojuedety sdiysovrx wlutvml emmmjtmf yumoe jyiloiq cefuxpt mgefihrjbn wipsrenplw sskutcs mvfnjg mxdfv vsmcn cwneh. Mhcxlol hfhxcrvnm lzunjwn zeuvck nygd augt nfdafqsob awxrl bttybubefn rnricwwob xmqmng vxygxs qbfcv. Tnrugszs wjis qirkpf xiwrza hhmff wkmzpm xnswqsup jrhoyv ifc ufnsasp fagcgtcl vtmqoqunb ggeeftc qktbmf flritae wbq tudrsrb xoxqvqlb.&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Web</span></span><br><span class="line">Random.url()</span><br><span class="line">Mock.mock(<span class="string">&#x27;@url&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@url()&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;wais://gelm.gf/tqkuz&quot;</span></span><br><span class="line"><span class="comment">// &quot;news://lkvi.so/nacax&quot;</span></span><br><span class="line"><span class="comment">// &quot;tn3270://zbxqguresa.fk/qguefcsa&quot;</span></span><br><span class="line"></span><br><span class="line">Random.domain()</span><br><span class="line">Random.protocol()</span><br><span class="line">Random.tld()</span><br><span class="line">Random.email()</span><br><span class="line">Random.ip()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Address</span></span><br><span class="line">Random.region() <span class="comment">//&quot;东北&quot;</span></span><br><span class="line">Random.province()</span><br><span class="line"><span class="comment">// Random.city( prefix? )</span></span><br><span class="line">Random.city()</span><br><span class="line">Mock.mock(<span class="string">&#x27;@city&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@city()&#x27;</span>)</span><br><span class="line"><span class="comment">// Random.city( prefix )</span></span><br><span class="line">Random.city(<span class="literal">true</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@city(true)&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;桃园县&quot;</span></span><br><span class="line"><span class="comment">// &quot;南昌市&quot;</span></span><br><span class="line"><span class="comment">// &quot;枣庄市&quot;</span></span><br><span class="line"><span class="comment">// // Random.city( prefix )</span></span><br><span class="line"><span class="comment">// &quot;广西壮族自治区 来宾市&quot;</span></span><br><span class="line"><span class="comment">// &quot;北京 北京市&quot;</span></span><br><span class="line">Random.county([prefix])</span><br><span class="line"></span><br><span class="line">Random.zip() <span class="comment">// &quot;216873&quot;</span></span><br><span class="line"></span><br><span class="line">Random.guid() <span class="comment">//&quot;5D36E3Fb-dcF1-6CC3-d5A3-9feD7b2f4f52&quot;</span></span><br><span class="line">Random.id() <span class="comment">// &quot;500000200806155373&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = Mock.mock(&#123;</span><br><span class="line">  <span class="string">&#x27;array|1-10&#x27;</span>:[&#123;</span><br><span class="line">      <span class="string">&#x27;name&#x27;</span>: Mock.mock(<span class="string">&#x27;@name&#x27;</span>),</span><br><span class="line">      <span class="string">&#x27;age|18-69&#x27;</span>:<span class="number">1</span>,</span><br><span class="line">      <span class="string">&#x27;imageUrl&#x27;</span>: Mock.Random.image(<span class="string">&#x27;200x100&#x27;</span>, <span class="string">&#x27;#894FC4&#x27;</span>, <span class="string">&#x27;#FFF&#x27;</span>, <span class="string">&#x27;png&#x27;</span>, <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line"><span class="comment">// Array:6</span></span><br><span class="line"><span class="comment">// 0: &#123;name: &quot;Mark Hall&quot;, age: 28, imageUrl: &quot;http://dummyimage.com/200x100/894FC4/FFF.png&amp;text=!&quot;&#125;</span></span><br><span class="line"><span class="comment">// 1: &#123;name: &quot;Mark Hall&quot;, age: 24, imageUrl: &quot;http://dummyimage.com/200x100/894FC4/FFF.png&amp;text=!&quot;&#125;</span></span><br><span class="line"><span class="comment">// 2: &#123;name: &quot;Mark Hall&quot;, age: 37, imageUrl: &quot;http://dummyimage.com/200x100/894FC4/FFF.png&amp;text=!&quot;&#125;</span></span><br><span class="line"><span class="comment">// 3: &#123;name: &quot;Mark Hall&quot;, age: 31, imageUrl: &quot;http://dummyimage.com/200x100/894FC4/FFF.png&amp;text=!&quot;&#125;</span></span><br><span class="line"><span class="comment">// 4: &#123;name: &quot;Mark Hall&quot;, age: 48, imageUrl: &quot;http://dummyimage.com/200x100/894FC4/FFF.png&amp;text=!&quot;&#125;</span></span><br><span class="line"><span class="comment">// 5: &#123;name: &quot;Mark Hall&quot;, age: 34, imageUrl: &quot;http://dummyimage.com/200x100/894FC4/FFF.png&amp;text=!&quot;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>https和ssl证书概要</title>
      <link href="/ZJY.github.io/2021/04/30/https%E5%92%8Cssl%E8%AF%81%E4%B9%A6%E6%A6%82%E8%A6%81/"/>
      <url>/ZJY.github.io/2021/04/30/https%E5%92%8Cssl%E8%AF%81%E4%B9%A6%E6%A6%82%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<h3 id="1-HTTPS简介"><a href="#1-HTTPS简介" class="headerlink" title="1.HTTPS简介"></a>1.HTTPS简介</h3><p>超文本传输安全协议是一种网络安全传输协议。<br>http协议传输的数据都是未加密的，明文传输。<br>http使用80端口通讯，https占用443端口通讯。<br>https经由http进行通信，用ssl/tls加密数据包。<br>https主要用于提供网络服务器的身份认证，保护数据的隐私和完整性。</p><h3 id="2-https工作原理"><a href="#2-https工作原理" class="headerlink" title="2.https工作原理"></a>2.https工作原理</h3><p>工作流程：<br>1、TCP 三次同步握手<br>2、客户端验证服务器数字证书<br>3、DH 算法协商对称加密算法的密钥、hash 算法的密钥<br>4、SSL 安全加密隧道协商完成<br>5、网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。</p><p>1、客户端发起 HTTPS 请求</p><p>这个没什么好说的，就是用户在浏览器里输入一个 https 网址，然后连接到 server 的 443 端口。</p><p>2、服务端的配置</p><p>采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl 就是个不错的选择，有 1 年的免费服务)。</p><p>这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</p><p>3、传送证书</p><p>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间，网站地址，加密公钥等等。</p><p>4、客户端解析证书</p><p>这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。</p><p>如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</p><p>5、传送加密信息</p><p>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p><p>6、服务端解密信息</p><p>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</p><p>7、传输加密后的信息</p><p>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。</p><p>8、客户端解密信息</p><p>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。</p><h3 id="3-HTTP-与-HTTPS-区别"><a href="#3-HTTP-与-HTTPS-区别" class="headerlink" title="3.HTTP 与 HTTPS 区别"></a>3.HTTP 与 HTTPS 区别</h3><p>HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。<br>使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。<br>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。<br>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。<br>HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源</p><h3 id="4-TCP三次握手"><a href="#4-TCP三次握手" class="headerlink" title="4.TCP三次握手"></a>4.TCP三次握手</h3><p>第一次握手：客户端尝试连接服务器，向服务器发送 syn 包（同步序列编号Synchronize Sequence Numbers），syn=j，客户端进入 SYN_SEND 状态等待服务器确认<br>第二次握手：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个 SYN包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态<br>第三次握手：第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器缓存机制</title>
      <link href="/ZJY.github.io/2021/04/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
      <url>/ZJY.github.io/2021/04/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="1-缓存"><a href="#1-缓存" class="headerlink" title="1.缓存"></a>1.缓存</h3><p>好的缓存策略可以缩短网页请求资源的距离，减少延迟，并且缓存文件可以重复利用，可以减少带宽，降低网络负荷。</p><p>一个数据请求，可以分为发起网络请求、后端处理、浏览器响应三个步骤。缓存可以帮我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但存储的数据和前端一致，那么就没有必要再将数据回传回来，减少响应。</p><h3 id="2-缓存位置"><a href="#2-缓存位置" class="headerlink" title="2.缓存位置"></a>2.缓存位置</h3><p>缓存位置上分4种，并各有优先级，当一次查找都没有命中的时候才去请求网络。</p><ul><li>Service Worker</li><li>Memory Cache</li><li>Disk Cache</li><li>Push Cache</li></ul><h4 id="1-Service-Worker"><a href="#1-Service-Worker" class="headerlink" title="1.Service Worker"></a>1.Service Worker</h4><p>运行在浏览器的独立线程，可以实现缓存功能。<br>使用Service Worker，传输协议必须为HTTPS。<br>Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。</p><h4 id="2-Memory-Cache"><a href="#2-Memory-Cache" class="headerlink" title="2.Memory Cache"></a>2.Memory Cache</h4><p>内存中的缓存，主要包含当前页面中已经抓取的资源，例如页面上已经下载的样式，脚本，图片等。读取内存中的数据肯定比磁盘块，内存缓存虽然读取高校，但是可持续性短，会随着进程的释放而释放。一旦我们关闭tab页面，内存中的缓存就被释放了。</p><h4 id="3-Disk-Cache"><a href="#3-Disk-Cache" class="headerlink" title="3.Disk Cache"></a>3.Disk Cache</h4><p>存储在硬盘中的缓存，虽然读取慢，但什么都能存储，比Memory Cache胜在存储的容量和存储时效上。</p><p>在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。</p><h4 id="4-Push-Cache"><a href="#4-Push-Cache" class="headerlink" title="4.Push Cache"></a>4.Push Cache</h4><p>推送缓存是http/2中的内容，当以上3中缓存都没有命中时，才会使用。它只在会话（session）中存在，一旦会话结束就被释放，并且缓存时间很短。</p><p>如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。</p><p>通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。</p><h3 id="3-强缓存"><a href="#3-强缓存" class="headerlink" title="3.强缓存"></a>3.强缓存</h3><p>强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。</p><h4 id="1-Expires"><a href="#1-Expires" class="headerlink" title="1.Expires"></a>1.Expires</h4><p>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</p><p>Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。Expires: Wed, 22 Oct 2018 08:41:00 GMT表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求.</p><h4 id="2-Cache-Control"><a href="#2-Cache-Control" class="headerlink" title="2.Cache-Control"></a>2.Cache-Control</h4><ul><li>public:所有内容都将被缓存（客户端和代理服务器都可缓存），中间的代理服务器proxy也可以缓存资源</li><li>private：所有内容只有客户端可以缓存，cache-control的默认取值</li><li>no-cache：客户端缓存内容，是否使用缓存需要经过协商缓存来验证决定。</li><li>no-store：不使用缓存，既不使用强制缓存也不使用协商缓存</li><li>max-age：max-age=3000，单位秒，缓存内容将在3000秒后失效</li><li>s-maxage：同max-age一样，但只在代理服务器中生效（比如cdn缓存）。比如当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。s-maxage的优先级高于max-age。如果存在s-maxage，则会覆盖掉max-age和Expires header。</li><li>max-stale：能容忍的最大的过期时间，max-stale指令标示了客户端愿意接收一个已经过期了的响应。如果指定了max-stale的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何age的响应</li><li>min-fresh:指定客户端需要的响应是最新的指定的秒数的缓存数据。例如 Cache-Control:min-fresh=60，这就要求缓存服务器发送60秒内的数据</li><li>immutable：客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 ，即使用户做了刷新操作，也不向服务器发起http请求</li></ul><h3 id="4-协商缓存"><a href="#4-协商缓存" class="headerlink" title="4.协商缓存"></a>4.协商缓存</h3><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</p><ul><li>协商缓存生效，返回304和Not Modified</li><li>协商缓存失效，返回200和请求结果</li></ul><p>协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag</p><h4 id="1-Last-modified和If-modified-Since"><a href="#1-Last-modified和If-modified-Since" class="headerlink" title="1.Last-modified和If-modified-Since"></a>1.Last-modified和If-modified-Since</h4><p>浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header；</p><p>浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200</p><p>但是 Last-Modified 存在一些弊端：<br>如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源<br>因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源.</p><h4 id="2-ETag和If-None-Match"><a href="#2-ETag和If-None-Match" class="headerlink" title="2.ETag和If-None-Match"></a>2.ETag和If-None-Match</h4><p>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。<br>如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。</p><h4 id="3-Etag和Last-modified对比"><a href="#3-Etag和Last-modified对比" class="headerlink" title="3.Etag和Last-modified对比"></a>3.Etag和Last-modified对比</h4><ul><li><p>首先在精确度上，Etag要优于Last-Modified。<br>Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。</p></li><li><p>第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。</p></li><li><p>第三在优先级上，服务器校验优先考虑Etag</p></li></ul><h3 id="5-场景应用"><a href="#5-场景应用" class="headerlink" title="5.场景应用"></a>5.场景应用</h3><ul><li>1.频繁变动的资源<br>Cache-Control: no-cache</li></ul><p>对于频繁变动的资源，首先需要使用Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。</p><ul><li>2.不常变化的资源<br>Cache-Control: max-age=31536000</li></ul><p>通常在处理这类资源时，给它们的 Cache-Control 配置一个很大的 max-age=31536000 (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效 (其实并未立即失效，只是不再使用了而已）。</p><p>触发缓存策略：</p><ul><li>打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。</li><li>普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。</li><li>强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache(为了兼容，还带了 Pragma: no-cache),服务器直接返回 200 和最新内容。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 问题&amp;总结 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript作用域</title>
      <link href="/ZJY.github.io/2021/04/24/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84javascript-1/"/>
      <url>/ZJY.github.io/2021/04/24/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84javascript-1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-作用域是什么"><a href="#1-作用域是什么" class="headerlink" title="1.作用域是什么"></a>1.作用域是什么</h2><h3 id="1-编译原理"><a href="#1-编译原理" class="headerlink" title="1. 编译原理"></a>1. 编译原理</h3><p>尽管将JavaScript归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。</p><p>JavaScript引擎进行编译的步骤和传统的编译语言非常相似，但它不是提前编译的，编译结果也不能在分布式系统中移植。</p><p>传统编译语言，程序中的一段源代码在执行之前会经过三个步骤，统称为“编译”。</p><ul><li><p>分词/词法分析（Tokenizing/Lexing）<br>这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（ token ）。例如，考虑程序 var a = 2; 。这段程序通常会被分解成为下面这些词法单元： var 、 a 、 = 、 2 、 ; 。空格是否会被当作词法单元，取决于空格在这门语言中是否具有意义。</p></li><li><p>解析/语法分析(Parsing)<br>这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（ Abstract Syntax Tree ， AST ）。 var a = 2; 的抽象语法树中可能会有一个叫作 VariableDeclaration 的顶级节点，接下来是一个叫作 Identifier （它的值是 a ）的子节点，以及一个叫作 AssignmentExpression 的子节点。 AssignmentExpression 节点有一个叫作 NumericLiteral （它的值是 2 ）的子节点。 •</p></li><li><p>代码生成<br>将 AST 转换为可执行代码的过程称被称为代码生成。这个过程与语言、目标平台等息息相关。抛开具体细节，简单来说就是有某种方法可以将 var a = 2; 的 AST 转化为一组机器指令，用来创建一个叫作 a 的变量（包括分配内存等），并将一个值储存在 a 中。</p></li></ul><p>简单地说，任何 JavaScript 代码片段在执行前都要进行编译（通常就在执行前）。因此， JavaScript 编译器首先会对 var a = 2; 这段程序进行编译，然后做好执行它的准备，并且通常马上就会执行它。</p><h3 id="2-理解作用域"><a href="#2-理解作用域" class="headerlink" title="2.理解作用域"></a>2.理解作用域</h3><ul><li><p>引擎<br>负责整个JavaScript程序的编译和执行过程。</p></li><li><p>编译器<br>引擎的好朋友之一，负责语法分析和代码生成等。</p></li><li><p>作用域<br>引擎的另一位好朋友，负责收集并维护所有声明的标识符组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。</p></li></ul><p>当你看到var a = 2;这段程序时，认为这是一句声明。但引擎确不是这样处理。</p><p>编译器首先会将这段程序拆分为词法单元，然后将词法单元解析成一个树结构。但是当编译器开始进行代码生成时，对这段程序的处理会和预期有所不同。</p><p>可以用伪代码概括：“为一个变量分配内存，将其命名为a，然后将值2保存进这个变量。”然而并不完全正确。</p><p>事实上编译器会进行如下处理：</p><p>1.遇到var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，命名为a。</p><p>2.接下来编译器会为引擎生成运行时所需代码，这段代码被用来处理a = 2这个赋值操作。引擎运行时会先询问作用域，在当前作用域集合中是否存在一个叫做a的变量。如果是引擎就使用这个变量；如果不是引擎继续查找该变量。如果引擎最终找到了该变量，就将2赋值给它，否则就抛出一个异常。</p><p><b>总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时会在该作用域中查找该变量，如果能找到就对它赋值。</b></p><h3 id="3-引擎查询"><a href="#3-引擎查询" class="headerlink" title="3.引擎查询"></a>3.引擎查询</h3><p>编译器生成代码后，引擎执行它时，会通过查找变量a来判断它是否已声明过。引擎查询分为LHS查询和RHS查询。“L”和“R”表示赋值操作的左侧和右侧。</p><p>当变量出现在赋值操作的左侧时进行LHS查询，出现在右侧时进行RHS查询。</p><p>console.log(a);其中对a的引用是RHS引用，这里a并没有赋予任何值。要查找并取得a的值并将值传递给console.log()<br>a=2;对a的引用是LHS引用，并不关心当前值是什么，只是想要为=2这个赋值操作找到一个目标。</p><p>LHS 和 RHS 的含义是“赋值操作的左侧或右侧”并不一定意味着就是“=赋值操作符的左侧或右侧”。赋值操作还有其他几种形式，因此在概念上最好将其理解为“赋值操作的目标是谁（ LHS ）”以及“谁是赋值操作的源头（ RHS ）”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> b = a; <span class="keyword">return</span> a + b; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> c = foo( <span class="number">2</span> ); </span><br></pre></td></tr></table></figure><ol><li>找出所有的 LHS 查询（这里有 3 处！）<br> c = ..; 、 a = 2 （隐式变量分配）、 b = .. </li><li>找出所有的 RHS 查询（这里有 4 处！） foo(2..) 、 = a; 、 a .. 、 .. b</li></ol><h3 id="4-作用域嵌套"><a href="#4-作用域嵌套" class="headerlink" title="4.作用域嵌套"></a>4.作用域嵌套</h3><p>作用域是根据名称查找变量的一套规则。<br>当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。</p><p>遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。</p><h3 id="5-异常"><a href="#5-异常" class="headerlink" title="5.异常"></a>5.异常</h3><p>区分LHS和RHS很重要，因为变量在还没有声明的情况下这两种查询行为是不一样的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log( a + b ); </span><br><span class="line">  b = a; </span><br><span class="line">&#125; </span><br><span class="line">foo( <span class="number">2</span> ); </span><br></pre></td></tr></table></figure><p>第一次对 b 进行 RHS 查询时是无法找到该变量的。也就是说，这是一个“未声明”的变量，因为在任何相关的作用域中都无法找到它。<br>如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError 异常。值得注意的是， ReferenceError 是非常重要的异常类型。相较之下，当引擎执行 LHS 查询时，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非“严格模式”下。</p><p>接下来，如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作TypeError 。 </p><p>ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。</p><h3 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h3><p>作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。赋值操作符会导致 LHS 查询。＝操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。 </p><p>JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 var a = 2 这样的声明会被分解成两个独立的步骤：</p><ol><li>首先， var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。 </li><li>接下来， a = 2 会查询（ LHS 查询）变量 a 并对其进行赋值。 </li></ol><p>LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。</p><p>不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛出 ReferenceError 异常（严格模式下）。</p><h2 id="2-词法作用域"><a href="#2-词法作用域" class="headerlink" title="2.词法作用域"></a>2.词法作用域</h2><h3 id="1-词法阶段"><a href="#1-词法阶段" class="headerlink" title="1.词法阶段"></a>1.词法阶段</h3><p>大部分标准语言编译器的第一个工作阶段叫作词法化（也叫单词化）。</p><p>简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下）。</p><p>作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。</p><p>全局变量会自动成为全局对象（比如浏览器中的 window 对象）的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引用来对其进行访问。<br>window.a 通过这种技术可以访问那些被同名变量所遮蔽的全局变量。但非全局的变量如果被遮蔽了，无论如何都无法被访问到。<br>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。</p><h3 id="2-欺骗词法"><a href="#2-欺骗词法" class="headerlink" title="2.欺骗词法"></a>2.欺骗词法</h3><p>如果词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来“修改”（也可以说欺骗）词法作用域呢？ JavaScript 中有两种机制来实现这个目的。</p><h4 id="2-1-eval"><a href="#2-1-eval" class="headerlink" title="2.1 eval"></a>2.1 eval</h4><p>JavaScript 中的 eval(..) 函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。换句话说，可以在你写的代码中用程序生成代码并运行，就好像代码是写在那个位置的一样。<br>在执行 eval(..) 之后的代码时，引擎并不“知道”或“在意”前面的代码是以动态形式插入进来，并对词法作用域的环境进行修改的。引擎只会如往常地进行词法作用域查找。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str, a</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">eval</span>( str ); <span class="comment">// 欺骗！ </span></span><br><span class="line">  <span class="built_in">console</span>.log( a, b ); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>; </span><br><span class="line">foo( <span class="string">&quot;var b = 3;&quot;</span>, <span class="number">1</span> ); <span class="comment">// 1, 3</span></span><br></pre></td></tr></table></figure><p>eval(..) 调用中的 “var b = 3;” 这段代码会被当作本来就在那里一样来处理。由于那段代码声明了一个新的变量 b ，因此它对已经存在的 foo(..) 的词法作用域进行了修改。事实上，和前面提到的原理一样，这段代码实际上在 foo(..) 内部创建了一个变量 b ，并遮蔽了外部（全局）作用域中的同名变量。<br>当 console.log(..) 被执行时，会在 foo(..) 的内部同时找到 a 和 b ，但是永远也无法找到外部的 b 。因此会输出“1, 3” 而不是正常情况下会输出的“1, 2” 。</p><p>在这个例子中，为了展示的方便和简洁，我们传递进去的“代码”字符串是固定不变的。而在实际情况中，可以非常容易地根据程序逻辑动态地将字符拼接在一起之后再传递进去。 eval(..) 通常被用来执行动态创建的代码，因为像例子中这样动态地执行一段固定字符所组成的代码，并没有比直接将代码写在那里更有好处。</p><h4 id="2-2-with"><a href="#2-2-with" class="headerlink" title="2.2 with"></a>2.2 with</h4><p>JavaScript 中另一个难以掌握（并且现在也不推荐使用）的用来欺骗词法作用域的功能是 with 关键字。可以有很多方法来解释 with ，在这里我选择从这个角度来解释它：它如何同被它所影响的词法作用域进行交互。<br>with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。<br>比如： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;; </span><br><span class="line"><span class="comment">// 单调乏味的重复 &quot;obj&quot; </span></span><br><span class="line">obj.a = <span class="number">2</span>; </span><br><span class="line">obj.b = <span class="number">3</span>; </span><br><span class="line">obj.c = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的快捷方式 </span></span><br><span class="line"><span class="keyword">with</span> (obj) &#123; </span><br><span class="line">  a = <span class="number">3</span>; </span><br><span class="line">  b = <span class="number">4</span>; </span><br><span class="line">  c = <span class="number">5</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//但实际上这不仅仅是为了方便地访问对象属性。</span></span><br><span class="line"><span class="comment">//考虑如下代码： </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">obj</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">with</span> (obj) &#123; </span><br><span class="line">    a = <span class="number">2</span>; </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">a</span>: <span class="number">3</span> &#125;; </span><br><span class="line"><span class="keyword">var</span> o2 = &#123; <span class="attr">b</span>: <span class="number">3</span> &#125;; </span><br><span class="line">foo( o1 ); </span><br><span class="line"><span class="built_in">console</span>.log( o1.a ); <span class="comment">// 2 </span></span><br><span class="line">foo( o2 );</span><br><span class="line"> <span class="built_in">console</span>.log( o2.a ); <span class="comment">// undefined </span></span><br><span class="line"> <span class="built_in">console</span>.log( a ); <span class="comment">// 2—— 不好， a 被泄漏到全局作用域上了！</span></span><br></pre></td></tr></table></figure><p>这个例子中创建了 o1 和 o2 两个对象。其中一个具有 a 属性，另外一个没有。<br>foo(..) 函数接受一个 obj 参数，该参数是一个对象引用，并对这个对象引用执行了 with(obj) {..} 。在 with 块内部，我们写的代码看起来只是对变量 a 进行简单的词法引用，实际上就是一个 LHS 引用并将 2 赋值给它。当我们将 o1 传递进去， a ＝ 2 赋值操作找到了 o1.a 并将 2 赋值给它，这在后面的 console. log(o1.a) 中可以体现。而当 o2 传递进去， o2 并没有 a 属性，因此不会创建这个属性， o2.a 保持 undefined 。但是可以注意到一个奇怪的副作用，实际上 a = 2 赋值操作创建了一个全局变量a。</p><p>尽管 with 块可以将一个对象处理为词法作用域，但是这个块内部正常的 var 声明并不会被限制在这个块的作用域中，而是被添加到 with 所处的函数作用域中。</p><h3 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h3><p>词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。</p><p>JavaScript 中有两个机制可以“欺骗”词法作用域： eval(..) 和 with 。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。</p><p>这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-4.变化侦测相关api实现原理</title>
      <link href="/ZJY.github.io/2021/04/20/vue-4-%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B%E7%9B%B8%E5%85%B3api%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/ZJY.github.io/2021/04/20/vue-4-%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B%E7%9B%B8%E5%85%B3api%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="vue-4-变化侦测相关api实现原理"><a href="#vue-4-变化侦测相关api实现原理" class="headerlink" title="vue-4.变化侦测相关api实现原理"></a>vue-4.变化侦测相关api实现原理</h2><h3 id="4-1-vm-watch"><a href="#4-1-vm-watch" class="headerlink" title="4.1 vm.$watch"></a>4.1 vm.$watch</h3><h4 id="4-1-1-用法"><a href="#4-1-1-用法" class="headerlink" title="4.1.1 用法"></a>4.1.1 用法</h4><p>vm.$watch(expOrFn, callback, [options]);<br>参数：</p><ul><li><p>{string | Function} expOrFn</p></li><li><p>{Function | Object } callback</p></li><li><p>{object} [options]</p><ul><li>{boolean} deep</li><li>{boolean} immediate</li></ul></li><li><p>返回值：{Function} unwatch</p></li><li><p>用法：用于观察一个表达式或computed函数在vue.js实例上的变化。回调函数调用时会得到新数据和旧数据。表达式只接受以点分隔的路径，例如a.b.c,如果是一个比较负责的表达式，可以用函数代替表达式。</p></li></ul><p>例如：<br>vm.$watch(‘a.b.c’, function(newVal,oldVal){});</p><p>返回一个取消观察函数，用来停止触发回调：<br>var unwatch = vm.$watch(‘a.b.c’, function(newVal,oldVal){});<br>//取消观察<br>unwatch();</p><p>deep:true,发现对象内部值的变化<br>immediate:true,立即以表达式的当前值触发回调</p><h4 id="4-1-2-watch的内部原理"><a href="#4-1-2-watch的内部原理" class="headerlink" title="4.1.2 watch的内部原理"></a>4.1.2 watch的内部原理</h4><p>vm.$watch其实是对Watcher的一种封装，加上参数deep和immediate</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$watch = <span class="function"><span class="keyword">function</span> (<span class="params">expOrFn, cb, options</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="built_in">this</span>;</span><br><span class="line">  options = options || &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> watcher = <span class="keyword">new</span> Watcher(vm,expOrFn, cb, options);</span><br><span class="line">  <span class="keyword">if</span>(options.immediate)&#123;</span><br><span class="line">    cb.call(vm,watcher.value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unwatch</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    watcher.teardown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先执行new Watcher实现vm.$watch的基本功能。<br>expOrFn是支持函数的，需要对Watcher进行简单的修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> calss Watcher&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">vm, expOrFn, cb</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.vm = vm;</span><br><span class="line">    <span class="comment">//expOrFn函数处理</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> expOrFn === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = expOrFn;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = parsePath(expOrFn)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.cb = cb;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增判断expOrFn类型：如果是函数则直接赋值给getter；如果不是函数，使用parsePath函数来读取keypath中数据。keypath指的是属性路径，例如a.b.c,从vm.a.b.c读取数据。</p><p>当expOrFn是函数时，它不只可以动态返回数据，其中读取的所有数据都会被Watcher观察。当expOrFn只是keypath时，Watcher只会读取keypath所指向的数据并观察这个数据的变化。</p><p>执行new Watcher后判断是否使用immediate参数，如果使用立即执行一次cb</p><p>最后返回一个函数unwatch，取消观察数据。实际上执行watcher.teardown()来取消数据，实质上把watcher实例从正在观察的状态的依赖列表中移除。</p><p>首先需要在watcher中记录自己都订阅来谁，也就是watcher实例被收集进来哪些dep，然后当watcher不想继续订阅dep时，循环自己记录的订阅列表来通知他们Dep将自己从他们的依赖列表中移除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> calss Watcher&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">vm, expOrFn, cb</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.vm = vm;</span><br><span class="line">    <span class="built_in">this</span>.deps = [];<span class="comment">//新增</span></span><br><span class="line">    <span class="built_in">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">//新增</span></span><br><span class="line">    <span class="comment">//expOrFn函数处理</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> expOrFn === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = expOrFn;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = parsePath(expOrFn)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.cb = cb;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.get();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 新增：记录watcher中记录自己都订阅过哪些Dep</span></span><br><span class="line">  <span class="function"><span class="title">addDep</span>(<span class="params">dep</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> id = dep.id;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.depIds.has(id))&#123;</span><br><span class="line">      <span class="built_in">this</span>.depIds.add(id);</span><br><span class="line">      <span class="built_in">this</span>.deps.push(dep);</span><br><span class="line">      dep.addSub(<span class="built_in">this</span>); <span class="comment">//将自己订阅到Dep</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有第一次触发getter时候才会收集依赖。</p><p>在Watcher中新增addDep方法后，Dep中收集依赖的逻辑也需要改变：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    thid.id = uid++; <span class="comment">//新增</span></span><br><span class="line">    <span class="built_in">this</span>.subs = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">depend</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.target)&#123;</span><br><span class="line">      <span class="comment">// this.addSub(window.target); //废弃</span></span><br><span class="line">      <span class="built_in">window</span>.target.addDep(<span class="built_in">this</span>); <span class="comment">//新增</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，Dep会记录数据发送变化时，需要通知哪些Watcher，而Watcher中也同样记录了自己会被哪些Dep通知。他们是多对多的关系。</p><p>在watcher中新增teardown方法来通知订阅的Dep把自己从依赖列表中移除：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">teardown</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="built_in">this</span>.deps.length;</span><br><span class="line">  <span class="keyword">while</span>(i--)&#123;</span><br><span class="line">    <span class="built_in">this</span>.deps[i].removeSub(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行Dep的removeSub方法将watcher从依赖列表中移除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="title">removeSub</span>(<span class="params">sub</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> index = <span class="built_in">this</span>.subs.indexOf(sub);</span><br><span class="line">    <span class="keyword">if</span>(index &gt; -<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.subs.splice(index,<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-3-deep参数的实现原理"><a href="#4-1-3-deep参数的实现原理" class="headerlink" title="4.1.3 deep参数的实现原理"></a>4.1.3 deep参数的实现原理</h4><p>deep就是除了要触发当前这个被监听数据的收集依赖逻辑以外还要把当前监听的这个值内的所以子值都触发一遍收集依赖逻辑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> calss Watcher&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">vm, expOrFn, cb</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.vm = vm;</span><br><span class="line">    <span class="comment">//新增</span></span><br><span class="line">    <span class="keyword">if</span>(options)&#123;</span><br><span class="line">      <span class="built_in">this</span>.deep = !!options.deep</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.deep = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.deps = [];</span><br><span class="line">    <span class="built_in">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>(); </span><br><span class="line">    <span class="comment">//expOrFn函数处理</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> expOrFn === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = expOrFn;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = parsePath(expOrFn)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.cb = cb;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.get();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.target = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="built_in">this</span>.getter.call(vm,vm);</span><br><span class="line">    <span class="comment">//新增 </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.deep)&#123;</span><br><span class="line">      traverse(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.target = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用deep参数在window.target = undefined之前调用traverse来处理deep逻辑。</p><p>递归value的所有子值来触发他们的收集依赖功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> seenObjects = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">traverse</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">  _traverse_(val,seenObjects);</span><br><span class="line">  seenObjects.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_traverse_</span>(<span class="params">val,seen</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i,keys;</span><br><span class="line">  <span class="keyword">const</span> isA = <span class="built_in">Array</span>.isArray(val);</span><br><span class="line">  <span class="keyword">if</span>((!isA &amp;&amp; !isObject(val)) || <span class="built_in">Object</span>.isFrozen(val))&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(val.__ob__)&#123;</span><br><span class="line">    <span class="keyword">const</span> depId = val.__ob__.dep.id;</span><br><span class="line">    <span class="keyword">if</span>(seen.has(depId))&#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    seen.add(depId)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(isA)&#123;</span><br><span class="line">    i = val.length;</span><br><span class="line">    <span class="keyword">while</span>(i--) _traverse(val[i], seen)</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    keys = <span class="built_in">Object</span>.keys(val);</span><br><span class="line">    i = keys.length</span><br><span class="line">    <span class="keyword">while</span>(i--) _traverse(val[keys[i]], seen)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们先判断val的类型,如果它不是Array和 Object,或者已经被冻结,那么直接返回,什么都不干。</p><p>然后拿到val的dep.id,用这个id来保证不会重复收集依赖<br>如果是数组,则循环数组,将数组中的每一项递归调用 _traverse。<br>最后,重点来了,如果是 Object类型的数据,则循环 Object中的所有key,然后执行一次读取操作,再递归子值<br>while (i–) _traverse(val[keys[il], seen)<br>其中val[keys[i]]会触发 getter,也就是说会触发收集依赖的操作,这时 window.target还没有被清空,会将当前的 Watcher收集进去。<br>而 _traverse函数其实是一个递归操作,所以这个 value的子值也会触发同样的逻辑,这<br>羊就可以实现通过deep参数来监听所有子值的变化。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-3.Array的变化侦测</title>
      <link href="/ZJY.github.io/2021/04/20/vue-3-Array%E7%9A%84%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/"/>
      <url>/ZJY.github.io/2021/04/20/vue-3-Array%E7%9A%84%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="vue-3-Array的变化侦测"><a href="#vue-3-Array的变化侦测" class="headerlink" title="vue-3.Array的变化侦测"></a>vue-3.Array的变化侦测</h2><h3 id="3-1-如何追踪变化？"><a href="#3-1-如何追踪变化？" class="headerlink" title="3.1 如何追踪变化？"></a>3.1 如何追踪变化？</h3><p>使用自定义的方法覆盖原生的原型方法。<br>我们可以用一个拦截器覆盖Array.prototype.之后每当使用Array原型上的方法操作数组时，其实执行的都是拦截器中提供的方法，比如push方法。然后在拦截器中使用原生Array的原型方法去操作数组。</p><h3 id="3-2-拦截器"><a href="#3-2-拦截器" class="headerlink" title="3.2 拦截器"></a>3.2 拦截器</h3><p>拦截器其实就是一个和Array.prototype一样的object，里面包含的属性一摸一样，只不过这个object中某些可以改变数组自身内容的方法是我们处理过的。</p><p>Array原型中可以改变数组自身内容的方法有7个，分别是push,pop,unshift,shift,splice,sort,reverse.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto);</span><br><span class="line">[</span><br><span class="line"><span class="string">&#x27;push&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> original = arrayProto[method]; <span class="comment">//缓存原始方法</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(arrayMethods, method, &#123;</span><br><span class="line">  value: <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> original.apply(<span class="built_in">this</span>, args);</span><br><span class="line">  &#125;,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>变量arrayMethods继承自Array.prototype，具备其所有功能，在arrayMethods上使用Object.defineProperty方法将那些可以改变数组自身内容的方法进行封装。<br>所以当使用push方法，实际上使用的是arrayMethods.push，也就是函数mutator。因此我们就可以在mutator函数作一些其他的事，比如发送变化通知。</p><h3 id="3-3-使用拦截器覆盖Array原型"><a href="#3-3-使用拦截器覆盖Array原型" class="headerlink" title="3.3 使用拦截器覆盖Array原型"></a>3.3 使用拦截器覆盖Array原型</h3><p>有了拦截器之后，想要使他生效，需要去覆盖Array.prototype，但是又不能直接去覆盖，因为这样会污染全局Array。我们只希望拦截那些响应式数组的原型。将数据转换为响应式的，需要通过Observer，所以只需要在Observer中使用拦截器覆盖那些即将被转换成响应式Array类型的数据的原型就好了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(value))&#123;</span><br><span class="line">      value.__proto__ = arrayMethods;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.walk(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-将拦截器方法挂载到数组的属性上"><a href="#3-4-将拦截器方法挂载到数组的属性上" class="headerlink" title="3.4 将拦截器方法挂载到数组的属性上"></a>3.4 将拦截器方法挂载到数组的属性上</h3><p>因为不是所以浏览器都支持__proto__属性，因此，如果不能使用__proto__属性，就直接将arrayMethods身上的这些方法设置到被侦测的数组上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; arrayMethods &#125; <span class="keyword">from</span> <span class="string">&#x27;./array&#x27;</span></span><br><span class="line"><span class="comment">//__proto__是否可用</span></span><br><span class="line"><span class="keyword">const</span> hasProto = <span class="string">&#x27;__proto__&#x27;</span> <span class="keyword">in</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> arrayKeys = <span class="built_in">Object</span>.getOwnPropertyNames(arrayMethods);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.value = value;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(value))&#123;</span><br><span class="line">    <span class="comment">//修改</span></span><br><span class="line">    <span class="keyword">const</span> augment = hasProto ? protoAugment : copyAugment;</span><br><span class="line">    augment(value, arrayMethods, arrayKeys );</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.walk(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">protoAugment</span>(<span class="params">target, src, keys</span>)</span>&#123;</span><br><span class="line">  target.__proto__ = src</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyAugment</span>(<span class="params">target, src, keys</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>,l=keys.length; i&lt;l; i++)&#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i];</span><br><span class="line">    def(target, key, src[key])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用hasProto判断浏览器是否支持__proto__：如果支持，则使用protoAugment函数来覆盖原型；如果不支持，则调用copyAugment函数将拦截器中的方法挂载到value上。</p><h3 id="3-5-如何收集依赖？"><a href="#3-5-如何收集依赖？" class="headerlink" title="3.5 如何收集依赖？"></a>3.5 如何收集依赖？</h3><p>list:[1,2,3,4,5]<br>不管value是什么，想要获取一个object某个属性的数据，要通过key来读取value，因此在读取list的时候，会触发这个名字叫做list的属性的getter，比如：this.list<br>Array的依赖和Object一样，也在defineReactive中收集：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, val</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">new</span> Observer(val)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">  <span class="built_in">Object</span>.definedProperty(data, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      dep.depend();</span><br><span class="line">      <span class="comment">//这里收集Array的依赖</span></span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(val === newVal)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal;</span><br><span class="line">      dep.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，Array在getter中收集依赖，在拦截器中触发依赖</p><h3 id="3-6-依赖列表存在哪儿？"><a href="#3-6-依赖列表存在哪儿？" class="headerlink" title="3.6 依赖列表存在哪儿？"></a>3.6 依赖列表存在哪儿？</h3><p>vue.js把Array的依赖存放在Observer中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep(); <span class="comment">//新增dep</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(value))&#123;</span><br><span class="line">      <span class="keyword">const</span> augment = hasProto ? protoAugment : copyAugment;</span><br><span class="line">      augment(value, arrayMethods, arrayKeys );</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.walk(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组在getter中收集依赖，在拦截器中触发依赖，所以这个依赖保存位置很关键，必须在getter和拦截器中都可以访问到。<br>之所以将依赖保存在Observer，是因为在getter中可以访问到Observer实例，在Array拦截中可以访问到Observer实例。</p><h3 id="3-7-收集依赖"><a href="#3-7-收集依赖" class="headerlink" title="3.7 收集依赖"></a>3.7 收集依赖</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, val</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> childOb = observe(val); <span class="comment">//修改</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">  <span class="built_in">Object</span>.definedProperty(data, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      dep.depend();</span><br><span class="line">      <span class="comment">//这里收集Array的依赖</span></span><br><span class="line">      <span class="keyword">if</span>(childOb)&#123;</span><br><span class="line">        childOb.dep.depend();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(val === newVal)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal;</span><br><span class="line">      dep.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//尝试为value创建一个Observer实例</span></span><br><span class="line">  <span class="comment">//如果创建成功直接然后新创建的实例</span></span><br><span class="line">  <span class="comment">//如果value已经存在一个observer实例则直接返回它</span></span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">value, asRootData</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!isObject(value)) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> ob;</span><br><span class="line">    <span class="keyword">if</span>(hasOwn(value, <span class="string">&#x27;__ob__&#x27;</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer)&#123;</span><br><span class="line">      ob = value.__ob__;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      ob = <span class="keyword">new</span> Observer(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ob</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="3-8-在拦截器中获取Observer实例"><a href="#3-8-在拦截器中获取Observer实例" class="headerlink" title="3.8 在拦截器中获取Observer实例"></a>3.8 在拦截器中获取Observer实例</h3><p>因为Array拦截器是对原型的一种封装，所以可以在拦截器中访问到this。而dep保存在Observer中，所以需要在this上读到Observer的实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">def</span>(<span class="params">obj, key, val, enumerable</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    value: val,</span><br><span class="line">    enumerable: !!enumerable,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep();</span><br><span class="line">    def(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="built_in">this</span>);<span class="comment">//新增</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(value))&#123;</span><br><span class="line">      <span class="keyword">const</span> augment = hasProto ? protoAugment : copyAugment;</span><br><span class="line">      augment(value, arrayMethods, arrayKeys);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.walk(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>def函数在value上新增一个不可枚举的属性__ob__，这个属性就是当前Observer实例。这个属性既可以用来在拦截器中访问Observer实例，还可用来标记是否已被Observer转换成响应式数据。<br>当value被标记来__ob__后可以通过value.__ob__来访问observer实例，如果是Array拦截器，拦截器是原型方法，可以通过this.__ob__来访问Observer实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line"><span class="string">&#x27;push&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> original = arrayProto[method]; <span class="comment">//缓存原始方法</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(arrayMethods, method, &#123;</span><br><span class="line">  value: <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="built_in">this</span>.__ob__; <span class="comment">//新增</span></span><br><span class="line">    <span class="keyword">return</span> original.apply(<span class="built_in">this</span>, args);</span><br><span class="line">  &#125;,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在mutator函数中可以通过this.__ob__来获取Observer实例。</p><h3 id="3-9-向数组的依赖发送通知"><a href="#3-9-向数组的依赖发送通知" class="headerlink" title="3.9 向数组的依赖发送通知"></a>3.9 向数组的依赖发送通知</h3><p>当侦测到数组变化时，需要向依赖发送通知，首先要能访问到依赖。前面已可以在拦截器中访问Observer实例，只需要在Observer实例中拿到dep属性就可以发送通知了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line"><span class="string">&#x27;push&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> original = arrayProto[method]; <span class="comment">//缓存原始方法</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(arrayMethods, method, &#123;</span><br><span class="line">  value: <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = original.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="built_in">this</span>.__ob__; </span><br><span class="line">    ob.dep.notify();<span class="comment">//向依赖发送消息</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="3-10-侦测数组元素的变化"><a href="#3-10-侦测数组元素的变化" class="headerlink" title="3.10 侦测数组元素的变化"></a>3.10 侦测数组元素的变化</h3><p>前面说侦测数组的变化指的是数组自身的变化，比如是否新增一个元素，是否删除一个元素，其实数组中object上某个属性发送变化也需要发送通知。比如使用push新增一个元素，这个元素的变化也需要侦测。</p><p>在observer新增一些处理，让它可以将array也转换响应式的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    def(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新增</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(value))&#123;</span><br><span class="line">      <span class="built_in">this</span>.observerArray(value);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.walk(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 侦测Array中的每一项</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observerArray</span>(<span class="params">items</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++)&#123;</span><br><span class="line">    observe(items[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>observerArray方法作用是循环Array中的每一项，执行observe函数来侦测变化。<br>observe函数就是将数组的每个元素都执行一遍new Observer，是一个递归过程。</p><h3 id="3-11-侦测新增元素的变化"><a href="#3-11-侦测新增元素的变化" class="headerlink" title="3.11 侦测新增元素的变化"></a>3.11 侦测新增元素的变化</h3><p>数组中一些方法比如push可以新增内容，新增的内容也需要转换成响应式的来侦测变化，否则出现修改数组无法触发消息等问题。</p><p>只需要获取新增元素并使用Observer来侦测他们就行。</p><h4 id="3-11-1-获取新增元素"><a href="#3-11-1-获取新增元素" class="headerlink" title="3.11.1 获取新增元素"></a>3.11.1 获取新增元素</h4><p>获取新增元素需要在拦截器中数组方法的类型进行判断。如果数组方法是push，unshift,splice（可以新增数组元素的方法），则把参数中新增的元素拿过来，用Observer侦测：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line"><span class="string">&#x27;push&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> original = arrayProto[method]; <span class="comment">//缓存原始方法</span></span><br><span class="line"></span><br><span class="line">def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = original.apply(<span class="built_in">this</span>,args);</span><br><span class="line">  <span class="keyword">const</span> ob = <span class="built_in">this</span>.__ob__;</span><br><span class="line">  <span class="keyword">let</span> inserted;</span><br><span class="line">  <span class="keyword">switch</span>(method)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line">      inserted = args;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">      inserted = args.slice(<span class="number">2</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ob.dep.notify();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过swtich对method进行判断，将新增元素取处理，暂存在inserted中</p><h4 id="3-11-2-使用observer侦测新增元素"><a href="#3-11-2-使用observer侦测新增元素" class="headerlink" title="3.11.2 使用observer侦测新增元素"></a>3.11.2 使用observer侦测新增元素</h4><p>Observer会将自身实例附加到value的<strong>ob__属性上，所以被侦测了变化的数据都有一个__ob__属性，数组元素也不例外。<br>因此可以在拦截器中访问到this.__ob</strong>,然后调用__ob__上的observeArray方法就可以了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line"><span class="string">&#x27;push&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> original = arrayProto[method]; <span class="comment">//缓存原始方法</span></span><br><span class="line"></span><br><span class="line">def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = original.apply(<span class="built_in">this</span>,args);</span><br><span class="line">  <span class="keyword">const</span> ob = <span class="built_in">this</span>.__ob__;</span><br><span class="line">  <span class="keyword">let</span> inserted;</span><br><span class="line">  <span class="keyword">switch</span>(method)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line">      inserted = args;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">      inserted = args.slice(<span class="number">2</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(inserted) ob.observeArray(inserted); <span class="comment">//新增</span></span><br><span class="line">  ob.dep.notify();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="3-12-关于Array的问题"><a href="#3-12-关于Array的问题" class="headerlink" title="3.12 关于Array的问题"></a>3.12 关于Array的问题</h3><p>Array的变化侦测是通过拦截原型的方式实现的。所以：<br>this.list[0] = 2;<br>this.list.length = 0;<br>以上2中修改数组不会触发重新渲染和watch。<br>vue.js的实现方法决定了无法对以上2中作拦截也就没办法响应。但可以通过:<br>this.list.splice(0,0,item);<br>vm.$set(list,0,item);<br>实现数据响应</p><h3 id="3-13-总结"><a href="#3-13-总结" class="headerlink" title="3.13 总结"></a>3.13 总结</h3><p>Array追踪变化的方式和Object不一样，他是通过创建拦截器去覆盖数组原型的方式来追踪变化。</p><p>为了不污染全局Array.prototype，在Observer中只针对需要侦测数据变化的数组使用__proto__来覆盖原型方法。但__proto__不是所有浏览器都支持它，针对不支持它的浏览，直接循环拦截器，把拦截器中方法设置到数组身上来拦截Array.prototype上的原生方法。</p><p>Array收集依赖方式和Object一样，都在getter中收集。但是因为数组要在拦截器中向依赖发送消息，所以把依赖保存在来Observer实例上。</p><p>在Observer中对每个侦测数据变化的数据加上__ob__标记，并把this保存在__ob__上，一方面为了标记数据已被侦测（防止重复侦测），另一方面可以通过__ob__拿到Observer实例，从而获取实例上的依赖，以便在拦截器中发送通知向依赖。</p><p>除了数组自身变化外，使用observeArray方法将数组每个元素都转换为响应式的并侦测变化。</p><p>除了侦测已有数据外，当新增元素时也需要进行变化侦测，根据数组方法提取新增元素，然后使用observeArray方法对新增元素进行变化侦测。</p><p>根据下标修改数组元素或者使用length清空数组操作无法拦截。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-2.Object的变化侦测</title>
      <link href="/ZJY.github.io/2021/04/20/vue-2-Object%E7%9A%84%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/"/>
      <url>/ZJY.github.io/2021/04/20/vue-2-Object%E7%9A%84%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="vue-2-Object的变化侦测"><a href="#vue-2-Object的变化侦测" class="headerlink" title="vue-2.Object的变化侦测"></a>vue-2.Object的变化侦测</h2><h3 id="2-1-什么是变化侦测？"><a href="#2-1-什么是变化侦测？" class="headerlink" title="2.1 什么是变化侦测？"></a>2.1 什么是变化侦测？</h3><p>从状态生成dom，再输出到用户界面显示的一整套流程叫渲染，应用在运行时会不停的进行重新渲染。<br>响应式系统的核心是变化侦测，侦测数据的变化，数据变化时，会通知视图进行响应的更新。</p><p>vue.js会自动通过状态生成dom，并将其输出到页面显示出来，这个过程叫做渲染。vue<br>.js的渲染是声明式的，通过模版来描述状态与dom之间的映射关系。<br>变化侦测分为两种类型：一种是“推”（push），一种是“拉”（pull）。</p><p>Angular和React中的变化都属于“拉”，这就是说当状态发生变化时，他不知道哪个状态变来，只知道状态可能变了，然后发送一个信号告诉框架，框架内部接收到信号后，会进行一个暴力对比来找出哪些dom节点需要重新渲染。在Angular中是脏检查的流程，在React中使用的是虚拟dom。</p><p>而Vue.js的变化侦测属于“推”。当状态变化时，vue.js就立刻知道了，且在一定程序上知道哪些状态变了。因此它知道的信息更多，就可以进行更细粒度的更新。</p><p>更细粒度的更新：如果一个状态绑定着好多个依赖，每个依赖表示一个具体的dom节点，那么当这个状态发送变化时，向这个状态的所有依赖发送通知，让他们进行dom更新操作。相比较而言，“拉”的粒度是最粗的。</p><p>但是有一定的代价，粒度越细，绑定的依赖就越多，依赖追踪在内存上的开销就越大。因此，从vue.js2.0开始它引入了虚拟dom，将粒度调整为中等粒度，即一个状态所绑定的依赖不再是dom节点，而是一个组件，这样状态变化后，会通知到组件，组件内部在使用虚拟dom进行对比。这可以大大降低依赖数量，从而降低依赖追踪所消耗的内存。</p><h3 id="2-2如何追踪变化"><a href="#2-2如何追踪变化" class="headerlink" title="2.2如何追踪变化"></a>2.2如何追踪变化</h3><p>如何侦测一个对象的变化？<br>使用Object.definedProperty和es6的Proxy</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, val</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">    eumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(val === newVal)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当从data中key读取数据时，get函数被触发；当往data的key中设置数据时，set函数被触发。</p><h3 id="2-3-如何收集依赖？"><a href="#2-3-如何收集依赖？" class="headerlink" title="2.3 如何收集依赖？"></a>2.3 如何收集依赖？</h3><p>在getter中收集依赖，在setter中触发依赖。</p><h3 id="2-4-依赖收集到哪里？"><a href="#2-4-依赖收集到哪里？" class="headerlink" title="2.4 依赖收集到哪里？"></a>2.4 依赖收集到哪里？</h3><p>每个key都有一个数组，用来存储当前key的依赖。假设依赖是一个函数，保存在window.target上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dep = []; <span class="comment">//新增</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">        eumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            dep.push(<span class="built_in">window</span>.target); <span class="comment">//新增</span></span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (val === newVal) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//新增</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dep.length; i++) &#123;</span><br><span class="line">                dep[i](newVal, val);</span><br><span class="line">            &#125;</span><br><span class="line">            val = newVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增数组dep，用来存储被收集的依赖，然后在set被触发时，循环dep以触发收集到的依赖。</p><p>将收集依赖的代码封装到一个Dep类，专门用来帮助我们管理依赖。使用这个类。可以收集依赖、删除依赖、通知依赖等。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subs = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">addSub</span>(<span class="params">sub</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subs.push(sub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">removeSub</span>(<span class="params">sub</span>)</span> &#123;</span><br><span class="line">        remove(<span class="built_in">this</span>.subs, sub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">depend</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">window</span>.target) &#123;</span><br><span class="line">            <span class="built_in">this</span>.addSub(<span class="built_in">window</span>.target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> subs = <span class="built_in">this</span>.subs.slice();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">            subs[i].update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length) &#123;</span><br><span class="line">            <span class="keyword">let</span> index = arr.indexOf(item);</span><br><span class="line">            <span class="keyword">if</span> (index &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> arr.splice(index, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再改造下definedReactive：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep(); <span class="comment">//修改</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">        eumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            dep.depend(); <span class="comment">//修改</span></span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (val === newVal) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            val = newVal;</span><br><span class="line">            dep.notify(); <span class="comment">//新增</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将依赖收集到Dep中。</p><h3 id="2-5-依赖是谁？"><a href="#2-5-依赖是谁？" class="headerlink" title="2.5 依赖是谁？"></a>2.5 依赖是谁？</h3><p>在上面代码中，我们收集的依赖是window.target，那么它到底是谁呢？<br>当属性发送变化时，通知谁，就是收集的依赖。</p><p>我们要通知到用到数据的地方，这个用到数据的地方很多，而且类型还不一样，有可能是模版，也有可能是用户写的一个watch，这时需要抽象出一个集中处理这些情况的类。然后在收集依赖阶段只收集这个封装好的类的实例进来，通知也只通知它一个，接着，它负责通知其他地方。这个类就是Watcher,收集的就是watcher。</p><h3 id="2-6-什么是Watcher？"><a href="#2-6-什么是Watcher？" class="headerlink" title="2.6 什么是Watcher？"></a>2.6 什么是Watcher？</h3><p>Watcher是一个中介角色，当数据变化时通知它，它再通知其他地方。<br>关于Watcher，看一个经典的使用方式：<br>vm.$watch(‘data.b.c’, function (newVal, oldVal){});<br>当data.b.c属性发生变化时，触发第二个参数中的函数。<br>把这个watcher实例添加到data.b.c的属性依赖Dep中，当data.b.c的值发生变化时，通知watcher，接着，watcher再执行回调函数。<br>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">vm, expOrFn, cb</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.vm = vm;</span><br><span class="line">    <span class="comment">//执行this.getter()可以读取data.b.c的内容</span></span><br><span class="line">    <span class="built_in">this</span>.getter = parsePath(expOrFn);</span><br><span class="line">    <span class="built_in">this</span>.cb = cb;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.get();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.target = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="built_in">this</span>.getter.call(<span class="built_in">this</span>.vm, <span class="built_in">this</span>.vm);</span><br><span class="line">    <span class="built_in">window</span>.target = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">update</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> oldValue = <span class="built_in">this</span>.value;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.get();</span><br><span class="line">    <span class="built_in">this</span>.cb.call(<span class="built_in">this</span>.vm, <span class="built_in">this</span>.value, oldValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在get方法中将this也就是watcher实例添加到window.target，然后读取data.b.c的值，会触发getter，然后触发依赖收集。这就导致将watcher实例赋给window.target然后再读取以下值触发getter就能将this添加到Dep依赖中。</p><p>依赖注入到Dep后，当data.b.c发生变化时，就会让依赖列表中的依赖循环触发update方法，也就是watcher中的update方法，而update方法会执行参数中的回调函数将value和oldValue传到参数中。</p><p>所以不管是用户执行vm.$watch还是模版中的data都是通过watcher来通知自己是否需要发生变化。</p><h3 id="2-7-递归侦测所有的key"><a href="#2-7-递归侦测所有的key" class="headerlink" title="2.7 递归侦测所有的key"></a>2.7 递归侦测所有的key</h3><p>前面介绍代码只能侦测数据中的一个属性，如果希望将数据中的所以属性都侦测到，所以要封装一个Observer类，将数据内的所以属性都转换成getter/setter形式，然后去追踪他们的变化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.walk(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//walk会将每一个属性都转换成getter/setter形式来追踪变化，只有数据类型为object时被调用</span></span><br><span class="line">    <span class="function"><span class="title">walk</span>(<span class="params">obj</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">            defineReactive(obj, keys[i], obj[keys[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> Observer(val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">    <span class="built_in">Object</span>.definedProperty(data, key, &#123;</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            dep.depend();</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (val === newVal) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            val = newVal;</span><br><span class="line">            dep.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Observer类可以将一个object对象转换为可侦测的object（通过walk方法将属性转换getter/setter形式），在defineReactive中用new Observer(val)来递归子属性，这样可以把data中所以属性都转换为getter/setter形式来追踪变化。当data中属性发生变化时，就会通知对于依赖进行更新。</p><h3 id="2-8-关于Object的问题"><a href="#2-8-关于Object的问题" class="headerlink" title="2.8 关于Object的问题"></a>2.8 关于Object的问题</h3><p>vue.js通过Object.definedProperty来将对象的key转换为getter/setter形式来追踪变化，但getter/setter只追踪一个数据是否被修改，无法追踪属性的新增和删除。为来解决这个问题，vue.js提供来2个api：vm.$set和vm.$delete。</p><h3 id="2-9-总结"><a href="#2-9-总结" class="headerlink" title="2.9 总结"></a>2.9 总结</h3><p>Object可以通过Object.definedProperty将属性转换成getter/setter的形式来追踪变化。读取数据时会触发getter，修改数据时会触发setter。</p><p>我们需要在getter中收集有哪些依赖发生了变化。当setter触发时，去通知getter中收集的依赖数据发生了变化。</p><p>收集依赖需要为依赖找一个存储的地方，即Dep，它用来收集依赖、删除依赖、通知依赖更新等。</p><p>所谓的依赖，其实就是Watcher，只有watcher触发的getter才会被收集，哪个watcher触发了getter，就把它收集到Dep中，当数据发生变化，就循环依赖列表通知所有watcher。</p><p>Watcher的原理是先把自己设置到全局唯一指定的地方（window.target），然后读取数据，触发getter，接着，getter中就会从全局唯一指定的地方去获取当前正在读取数据的watcher，并把这个watcher收集到Dep中，通过这样方式，Watcher可以主动去订阅任意一个数据的变化。</p><p>此外，Observer类把一个object中给的所有数据包括子数据都转换成响应式的。但是在对象上新增或删除属性都无法被追踪到。</p><p>如下图，Data、Observer、Dep、Watcher之间关系。</p><p><img src="/ZJY.github.io/images/vue-data.png" alt="image"></p><p>Data通过Observer转换成getter/setter形式来追踪变化。<br>当外界通过Watcher读取数据时，会触发getter从而将watcher添加到依赖中。<br>当数据发生变化，会触发setter，从而向Dep中的依赖（Watcher）发送通知。<br>Watcher接收到通知后，会向外界发送通知，变化通知到外界可能会触发视图更新，也有可能触发用户某个回调函数。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css中position属性</title>
      <link href="/ZJY.github.io/2021/04/14/css%E4%B8%ADposition%E5%B1%9E%E6%80%A7/"/>
      <url>/ZJY.github.io/2021/04/14/css%E4%B8%ADposition%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="position"><a href="#position" class="headerlink" title="position"></a>position</h2><p>position属性用于指定一个元素在文档中定位方式。top,left,right,bottom属性则决定了元素的最终位置。</p><h3 id="1-定位类型"><a href="#1-定位类型" class="headerlink" title="1.定位类型"></a>1.定位类型</h3><p>定位元素是定位为relative,absolute,fixed,sticky的一个元素，也就是除static外的定位元素。</p><p>相对定位：relative<br>绝对定位：absolute/fixed<br>粘性定位：sticky</p><p>如果top和bottom都指定了，top优先<br>如果left和right都指定了，当direction设置为ltr时，left优先，当directin设置rtl时，right优先。</p><h3 id="2-取值"><a href="#2-取值" class="headerlink" title="2.取值"></a>2.取值</h3><p><b>static</b><br>该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。</p><p><b>relative</b><br>该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。position:relative 对 table-*-group, table-row, table-column, table-cell, table-caption 元素无效。</p><p>相对定位的元素是在文档中的正常位置偏移给定的值，但是不影响其他元素的偏移。</p><p><b>absolute</b><br>元素会被移出正常文档流，并不为元素预留空间，通过指定元素相对于最近的非static定位的父元素进行偏移，来确定元素的位置。绝对定位元素可以设置margin外边距且不会与其他边距合并。</p><p>相对定位的元素并未脱离文档流，而绝对定位的元素则脱离了文档流。在布置文档流中其它元素时，绝对定位元素不占据空间。绝对定位元素相对于最近的非 static 祖先元素定位。当这样的祖先元素不存在时，则相对于ICB（inital container block, 初始包含块）</p><p><b>fixed</b><br>元素会被移出正常文档流，并不为元素预留空间。通过指定元素相对于视窗来进行定位，元素的位置在页面滚动时不会改变。打印时，元素出现在每页的固定位置。fixed会创建新的层叠上下文，当元素祖先的transform,perspective或filter属性不为none时，容器定位由视窗变为该祖先。</p><p>固定定位与绝对定位相似，但元素的包含块为 viewport 视口</p><p><b>sticky</b><br>元素根据正常文档流进行定位，然后相对它的最近滚动祖先和最近块级祖先，包括table-related元素，基于top, right, bottom, 和 left的值进行偏移。偏移值不会影响任何其他元素的位置。该值总是创建一个新的层叠上下文（stacking context）</p><p>粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。</p><p>#one { position: sticky; top: 10px; }</p><p>在 viewport 视口滚动到元素 top 距离小于 10px 之前，元素为相对定位。之后，元素将固定在与顶部距离 10px 的位置，直到 viewport 视口回滚到阈值以下</p><p>粘性定位常用于定位字母列表的头部元素。标示 B 部分开始的头部元素在滚动 A 部分时，始终处于 A 的下方。而在开始滚动 B 部分时，B 的头部会固定在屏幕顶部，直到所有 B 的项均完成滚动后，才被 C 的头部替代。</p><p>须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css中的z-index属性</title>
      <link href="/ZJY.github.io/2021/04/11/css%E4%B8%AD%E7%9A%84z-index%E5%B1%9E%E6%80%A7/"/>
      <url>/ZJY.github.io/2021/04/11/css%E4%B8%AD%E7%9A%84z-index%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="1-z-index基础概念"><a href="#1-z-index基础概念" class="headerlink" title="1.z-index基础概念"></a>1.z-index基础概念</h3><p>通过设置定位及 top，left，bottom 和 right 的值，你可以在二维空间中对元素进行定位，但 CSS 同时也允许你使用 z-index 属性把它放置在三维空间中。</p><p>x 轴代表水平方向，y 轴代表垂直方向，z 轴则代表我们的目光向页面（屏幕）看进去的时候，各元素的布局情况</p><p>为了决定某个元素在 z 轴方向上的位置，CSS 允许我们为 z-index 属性设置三种值：</p><ul><li>auto默认值</li><li>整数</li><li>inherit</li></ul><p>看整数值：它可以是正整数、负整数或者 0，值越大，元素就离我们“越近”，值越小，元素自然也就离我们“越远”</p><h3 id="2-层叠上下文"><a href="#2-层叠上下文" class="headerlink" title="2.层叠上下文"></a>2.层叠上下文</h3><p>每个网页都会默认创建一个层叠上下文，这个上下文的根部就是html元素，html元素的所有子元素都会默认在上下文中的某个层叠等级。</p><p>当你个某个元素设置z-index值非auto时，就会创建一个新的层叠上下文。它和它所包含的层叠等级都是独立于其他层叠上下文和层叠等级的。</p><p>在一个层叠上下文中，一共可能出现七个层叠等级，从低到高排序依次是：</p><ul><li>1.背景和边框：形成层叠上下文的元素的背景和边框，它是整个上下文中层叠等级最低的。</li><li>2.z-index为负数：设置了 z-index 为负数的子元素以及由它所产生的层叠上下文</li><li>3.块级盒模型：位于正常文档流中的、块级的、非定位的子元素</li><li>4.浮动盒模型：浮动的、非定位的子元素</li><li>5.内联盒模型：位于正常文档流中的、内联的、非定位的子元素</li><li>6.z-index为0：设置了 z-index 为 0 的、定位的子元素以及由它所产生的层叠上下文</li><li>7.z-index为正数:设置了 z-index 为正数的、定位的子元素以及由它所产生的层叠上下文，它是整个上下文中层叠等级最高的</li></ul><p>大部分元素的层级都要低于 z-index:0。</p><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;one&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;two&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;three&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;four&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.one</span>, <span class="selector-class">.two</span>, <span class="selector-class">.three</span>, <span class="selector-class">.four</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f00</span>;</span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">5px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="selector-class">.two</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#0f0</span>;</span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">5px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">75px</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.three</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#0ff</span>;</span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">5px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">125px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">25px</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">150</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.four</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#00f</span>;</span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">5px</span> solid <span class="number">#ff0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">350px</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">50</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管 div.two 有更高的 z-index（100），但在页面上，它的层级实际上比 div.four （z-index 为50）要低<br>由于 div.two  位于 div.one 中，所以它的 z-index 是和 div.one 的层叠上下文相关的，也就是说，实际表现出来的 z-index 是下面这样的：</p><ul><li>.one —— z-index = 10</li><li>.two —— z-index = 10.100</li><li>.three —— z-index = 10.150</li><li>.four —— z-index = 50</li></ul><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><p>定位元素可以创建新的层叠上下文，在这个上下文中的所有层叠等级，都会高于或者低于另一个层叠上下文的所有层叠等级</p><h3 id="4-补充"><a href="#4-补充" class="headerlink" title="4.补充"></a>4.补充</h3><p>fixed 属性会创建新的层叠上下文。当元素祖先的 transform, perspective 或 filter 属性非 none 时，容器由视口改为该祖先，相对于该祖先进行定位。</p><h3 id="5-堆叠上下文"><a href="#5-堆叠上下文" class="headerlink" title="5.堆叠上下文"></a>5.堆叠上下文</h3><p>以下情况可形成堆叠上下文：</p><ul><li>文档的根元素(hmtl)</li><li>position为absolute/relative且z-index不为auto的元素</li><li>position为fixed或sticky的元素</li><li>flex容器的子元素且z-index不为auto</li><li>grid容器的子元素且z-index不为auto</li><li>opacity属性值小于 1 的元素</li><li>mix-blend-mode 属性值不为 normal 的元素；</li><li>以下任意属性值不为 none 的元素：<ul><li>transform</li><li>filter</li><li>perspective</li><li>clip-path</li><li>mask / mask-image / mask-border</li></ul></li><li>isolation 属性值为 isolate 的元素；</li><li>-webkit-overflow-scrolling 属性值为 touch 的元素；</li><li>will-change 值设定了任一属性而该属性在 non-initial 值时会创建层叠上下文的元素（参考这篇文章）；</li><li>contain 属性值为 layout、paint 或包含它们其中之一的合成值（比如 contain: strict、contain: content）的元素。</li></ul><p>总结:</p><p>层叠上下文可以包含在其他层叠上下文中，并且一起创建一个层叠上下文的层级。<br>每个层叠上下文都完全独立于它的兄弟元素：当处理层叠时只考虑子元素。<br>每个层叠上下文都是自包含的：当一个元素的内容发生层叠后，该元素将被作为整体在父级层叠上下文中按顺序进行层叠。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css中的文档流/浮动/定位</title>
      <link href="/ZJY.github.io/2021/04/11/css%E4%B8%AD%E7%9A%84%E6%96%87%E6%A1%A3%E6%B5%81-%E6%B5%AE%E5%8A%A8-%E5%AE%9A%E4%BD%8D/"/>
      <url>/ZJY.github.io/2021/04/11/css%E4%B8%AD%E7%9A%84%E6%96%87%E6%A1%A3%E6%B5%81-%E6%B5%AE%E5%8A%A8-%E5%AE%9A%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="1-标准流"><a href="#1-标准流" class="headerlink" title="1.标准流"></a>1.标准流</h3><p>在标准流中有两种排版方式, 一种是垂直排版, 一种是水平排版<br>（1）垂直排版, 如果元素是块级元素, 那么就会垂直排版<br>（2）水平排版, 如果元素是行内元素/行内块级元素, 那么就会水平排版</p><h3 id="2-浮动流"><a href="#2-浮动流" class="headerlink" title="2.浮动流"></a>2.浮动流</h3><p>浮动流只有一种排版方式, 就是水平排版. 它只能设置某个元素左对齐或者右对齐<br>浮动元素碰到包含它的边框或者浮动元素的边框停留。<br>注意：如果浮动元素的父元素设置了padding值，那么浮动元素不会占用父元素的padding区域</p><p>float属于半脱离文档流，float和position:absolute/fixed一样会脱离文档流，但浮动脱离文档流仍然占据位置，其后的文本内容会按照顺序排列。</p><h3 id="3-定位"><a href="#3-定位" class="headerlink" title="3.定位"></a>3.定位</h3><ul><li>postision：static;始终处于文档流给予的位置。看起来好像没有用，但它可以快速取消定位，让 top，right，bottom，left 的值失效。在切换的时候可以尝试这个方法。</li><li>postision:relative;相对于自身位置定位，仍处于文档流中，元素的宽高不变，设置偏移量也不会影响其他元素的位置，如果最外层设置relative，在没有设置宽度情况，元素宽度是整个浏览器的宽度</li><li>postision:absolute;相对于离自己最近的设置了相对或绝对定位的父元素定位，如果没有父元素设置相对和绝对定位，则相对于跟元素html定位，设置了绝对定位的元素脱离了文档流，如果没有设置宽高由元素内容决定，脱离后元素位置是空的下面的元素会占据.</li><li>postision:fixed：相对于浏览器窗口定位,如果没有设置宽高由元素内容决定。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>script标签的加载和执行</title>
      <link href="/ZJY.github.io/2021/04/11/script%E6%A0%87%E7%AD%BE%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/"/>
      <url>/ZJY.github.io/2021/04/11/script%E6%A0%87%E7%AD%BE%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="1-script标签是如何加载的？"><a href="#1-script标签是如何加载的？" class="headerlink" title="1.script标签是如何加载的？"></a>1.script标签是如何加载的？</h3><ul><li>当浏览器遇到一个script标签时，会暂停页面渲染，运行javascript代码，然后再继续解析渲染页面；</li><li>当遇到外部javascript脚本时，浏览器首先下载外部js代码，会占用一部分时间，然后运行js代码，此过程中，页面解析渲染和用户交互是阻塞的。</li></ul><h3 id="2-script标签应放在何处？"><a href="#2-script标签应放在何处？" class="headerlink" title="2.script标签应放在何处？"></a>2.script标签应放在何处？</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;file1.js&quot;</span> /&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;file2.js&quot;</span> /&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;file3.js&quot;</span> /&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span></span><br></pre></td></tr></table></figure><p>可以看出，在head中引入3个外部js文件，首先第一个js文件开始下载，占用一部分时间，并阻塞其他js文件的下载。file1.js文件下载完成后，又消耗一部分时间用来完全执行此js代码。然后才是file2.js文件下载，执行，file3.js文件下载，执行。每个文件都需要等到前一个js文件下载完成并执行完毕才能开始自己的下载过程。这些文件下载时，用户屏幕会出现空白，有明显的延迟。且浏览器遇到body标签之前不会渲染页面任何部分。将外部js放在head会导致一个明显的延迟，打开页面首先会出现空白，用户既不能阅读也不能与之交互，体验非常不好。</p><p>随着浏览器的发展，浏览器允许并行下载js文件。当一个script标签正在下载资源时，不必阻塞别的script标签。<br>但是script标签的下载仍要阻塞其他资源的下载，如图片，样式表。即使脚本下载过程不互相阻塞，页面仍需等到所有js资源下载并执行完毕才能继续。所以，当浏览器通过允许并行下载提高性能之后，该问题并没有完全解决。脚本阻塞仍旧是一个问题。</p><p>脚本阻塞其他资源的下载过程，推荐将script标签放在body结束标签的前面。</p><h3 id="3-非阻塞脚本"><a href="#3-非阻塞脚本" class="headerlink" title="3.非阻塞脚本"></a>3.非阻塞脚本</h3><p>非阻塞脚本就是等页面加载完成之后，再加载js。</p><p>1.defer属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;file1.js&quot;</span> <span class="attr">defer</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>此script标签可以放在页面任何位置，解析到script标签时会立即下载此js文件，但会等到页面加载完成后再执行此js文件<br>只对外部js脚本有效，HTML5规范要求脚本按照它们出现的先后顺序执行。</p><p>2.async属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;file1.js&quot;</span> <span class="attr">async</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>不让页面等到脚本的下载和执行，从而异步加载页面其他内容。<br>下载完立即执行。不保证按照指定的先后顺序执行。只对外部js脚本有效</p><p>3.动态创建script标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">downloadJSAtOnload</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  element.src = <span class="string">&#x27;test.js&#x27;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.body.appendChild(element);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript"><span class="keyword">if</span>(<span class="built_in">window</span>.addEventListener)&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.addEventListener(<span class="string">&quot;load&quot;</span>,downloadJSAtOnload, <span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">window</span>.attachEvent)&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.attachEvent(<span class="string">&quot;onload&quot;</span>,downloadJSAtOnload);  </span></span><br><span class="line"><span class="javascript">&#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onload =downloadJSAtOnload; </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建script，插入到DOM中，加载完毕后callBack</p><h3 id="4-为什么需要顺序加载和执行？"><a href="#4-为什么需要顺序加载和执行？" class="headerlink" title="4.为什么需要顺序加载和执行？"></a>4.为什么需要顺序加载和执行？</h3><p>因为js有可能修改dom，如果不阻塞后续资源下载，dom的操作顺序不可控</p><h3 id="5-外部样式表会不会阻塞文档解析？"><a href="#5-外部样式表会不会阻塞文档解析？" class="headerlink" title="5.外部样式表会不会阻塞文档解析？"></a>5.外部样式表会不会阻塞文档解析？</h3><p>不会<br>style-sheets 不会修改 DOM 树，没有理由为了解析 style-sheets 而阻塞文档解析（即 style-sheets 不会阻塞文档解析）。但如果在解析文档过程中有脚本需要访问样式信息时，为了保证访问样式信息的正确性。Firefox 会阻塞所有脚本直到 style-sheets 下载解析完为止。而 WebKit 只在访问的样式属性没有被加载解析时，才会阻塞脚本。</p><p>即 style-sheet 不会直接阻塞文档解析，它只阻塞 script 的解析执行，才导致 style-sheet 间接阻塞文档解析</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端安全防范</title>
      <link href="/ZJY.github.io/2021/04/10/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E9%98%B2%E8%8C%83/"/>
      <url>/ZJY.github.io/2021/04/10/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E9%98%B2%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h2 id="1-XSS"><a href="#1-XSS" class="headerlink" title="1.XSS"></a>1.XSS</h2><h3 id="1-1-什么是XSS"><a href="#1-1-什么是XSS" class="headerlink" title="1.1 什么是XSS"></a>1.1 什么是XSS</h3><p>xss就是攻击者想尽一切办法将代码注入到网页中。</p><h3 id="1-2-类型？"><a href="#1-2-类型？" class="headerlink" title="1.2 类型？"></a>1.2 类型？</h3><p>XSS 可以分为多种类型，但是总体上我认为分为两类：持久型和非持久型。</p><p>持久型：<br>攻击的代码被服务器写入数据库中，这种攻击危害性很大，网站访问量很大的情况导致大量访问正常页面的用户都受到攻击。</p><p>比如在评论功能里输入：<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>,这段评论就会被存储到数据库中，这样每个打开该页面的用户都会被攻击到。</p><p>非持久型：<br>非持久型危害没有持久型危害大，一般通过修改url参数的方式加入攻击代码，诱导用户访问连接从而进行攻击。</p><p>比如如果页面需要从 URL 中获取某些参数作为内容的话，不经过过滤就会导致攻击代码被执行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- http://www.domain.com?name=&lt;script&gt;alert(1)&lt;/script&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>对于这种方式，使用chrome会自动帮助用户防御攻击。</p><h3 id="1-3防御对策"><a href="#1-3防御对策" class="headerlink" title="1.3防御对策"></a>1.3防御对策</h3><p>对于xss攻击，可通过转义字符和CSP2种方式进行防御</p><p>1.转义字符<br>转义输入输出的内容，对于引号、尖括号、斜杠进行转义<br>但是对于富文本，这样会把需要的格式也过滤掉。<br>对于这种情况，通常采用白名单过滤的办法，就是把这段代码解析成具体的html树, 对树进行分析哪些可以保留, 最后变成html字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xss = <span class="built_in">require</span>(<span class="string">&#x27;xss&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> html = xss(<span class="string">&#x27;&lt;h1 id=&quot;title&quot;&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert(&quot;XSS&quot;);&lt;/script&gt;&#x27;</span>);</span><br><span class="line"><span class="comment">// -&gt;&lt;h1&gt;XSS Demo&lt;/h1&gt;$lt;script&amp;gt;alert(&quot;XSS&quot;);&amp;lt;/script&amp;gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(html);</span><br></pre></td></tr></table></figure><p>2.CSP<br>CSP本质上就是建立白名单，开发者告诉浏览器哪些资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器实现的。</p><p>可通过2种方式开启CSP：<br>设置http种header中的:Content-Security-Policy<br>设置meta标签的方法<code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot; /&gt;</code></p><p>设置http header：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只允许加载本站资源：</span></span><br><span class="line">Content-Security-Policy: <span class="keyword">default</span>-src <span class="string">&#x27;self&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只允许加载https资源：</span></span><br><span class="line">Content-Security-Policy: img-src https:<span class="comment">//*</span></span><br></pre></td></tr></table></figure><h2 id="2-CSRF"><a href="#2-CSRF" class="headerlink" title="2.CSRF"></a>2.CSRF</h2><h3 id="2-1-什么是CSRF？"><a href="#2-1-什么是CSRF？" class="headerlink" title="2.1 什么是CSRF？"></a>2.1 什么是CSRF？</h3><p>CSRF跨站请求伪造，是一种挟制用户在已登录web应用程序上执行非本意操作的攻击方法。<br>Cookie 往往用来存储用户的身份信息，恶意网站可以设法伪造带有正确 Cookie 的 HTTP 请求，这就是 CSRF 攻击。<br>浏览器在访问服务器的时候会带上cookie，而第三方网站通过图片或表单提交方式也带上cookie，带上后利用用户身份进行攻击，而用户不知情。<br><code>&lt;img src=&quot;http://www.domain.com/xxx?comment=&#39;attack&#39;&quot;/&gt;</code></p><h3 id="2-2-如何防御？"><a href="#2-2-如何防御？" class="headerlink" title="2.2 如何防御？"></a>2.2 如何防御？</h3><p>1.get请求不修改数据<br>2.不让第三方网站访问到cookie，可以对 Cookie 设置 SameSite 属性。该属性表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容<br>3.请求时附带验证信息，比如验证码或者token<br>4.检查Referer字段，http请求头中referer字段表明请求来源于哪个地址，通常来说，Referer字段应和请求的地址位于同一域名下</p><h2 id="3-DDOS"><a href="#3-DDOS" class="headerlink" title="3. DDOS"></a>3. DDOS</h2><h3 id="3-1-什么是DDOS？"><a href="#3-1-什么是DDOS？" class="headerlink" title="3.1 什么是DDOS？"></a>3.1 什么是DDOS？</h3><p>短时间内发起大量请求，耗尽服务器资源，导致无法响应正常的访问，造成网站下线。</p><p>DDOS 里面的 DOS 是 denial of service（停止服务）的缩写，表示这种攻击的目的，就是使得服务中断。最前面的那个 D 是 distributed （分布式），表示攻击不是来自一个地方，而是来自四面八方，因此更难防</p><p>DDOS 不是一种攻击，而是一大类攻击的总称<br>比较常见的一种攻击是 cc 攻击。它就是简单粗暴地送来大量正常的请求，超出服务器的最大承受量，导致宕机</p><h2 id="4-SQL注入"><a href="#4-SQL注入" class="headerlink" title="4.SQL注入"></a>4.SQL注入</h2><p>SQL注入是一种代码注入的技术，攻击者可以将恶意SQL语句插入到输入字段中执行。</p><h2 id="5-加密传输"><a href="#5-加密传输" class="headerlink" title="5.加密传输"></a>5.加密传输</h2><p>加密主要有两种方式：对称加密和非对称加密。</p><ol><li>对称加密：在加密和解密时使用的是同一个秘钥。<br>对称加密的模式是：</li></ol><p>甲方选择某一种加密规则，对信息进行加密<br>乙方使用同一种规则，对信息进行解密</p><p>2.非对称加密：需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。<br>非对称加密的模式则是：</p><p>乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的<br>甲方获取乙方的公钥，然后用它对信息加密<br>乙方得到加密后的信息，用私钥解密。</p><p>最经典的非对称加密算法是RSA算法。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>window.sessionStorage的理解</title>
      <link href="/ZJY.github.io/2021/04/10/window-sessionStorage%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/ZJY.github.io/2021/04/10/window-sessionStorage%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>sessionStorage 属性允许你访问一个，对应当前源的 session Storage 对象。它与 localStorage 相似，不同之处在于 localStorage 里面存储的数据没有过期时间设置，而存储在 sessionStorage 里面的数据在页面会话结束时会被清除</p><ul><li>页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话。</li><li>在新标签或窗口打开一个页面时会复制顶级浏览会话的上下文作为新会话的上下文，这点和 session cookies 的运行方式不同。<br>使用target=”_blank”的A标签，window.open打开同源的新窗口时，会把旧窗口的sessionStorage数据带过去，但新旧窗口sessionStorage数据不同步</li><li>打开多个相同的URL的Tabs页面，会创建各自的sessionStorage。</li><li>关闭对应浏览器窗口（Window）/ tab，会清除对应的sessionStorage</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue虚拟dom和diff算法</title>
      <link href="/ZJY.github.io/2021/04/10/vue%E8%99%9A%E6%8B%9Fdom%E5%92%8Cdiff%E7%AE%97%E6%B3%95/"/>
      <url>/ZJY.github.io/2021/04/10/vue%E8%99%9A%E6%8B%9Fdom%E5%92%8Cdiff%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>1.虚拟dom<br>用js对象描述dom的层级结构。虚拟dom属性和真实dom的属性一一对应。<br>vue虚拟dom参考snabbdom库实现的</p><p>diff是发生在虚拟dom上的<br>新的虚拟dom和旧的虚拟dom进行diff，算出如何最小量更新，最后反映在真正的dom上。</p><p>数据更新-&gt;虚拟dom计算变更-&gt;操作真实的dom-&gt;视图更新</p><p>一个虚拟节点有哪些属性？</p><p>{<br>  tag:’div’,<br>  props:{<br>    id:’app’,<br>    className:’’<br>  },<br>  children:[]<br>}</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  children: <span class="literal">undefined</span> , <span class="comment">//子元素</span></span><br><span class="line">  data: &#123;&#125;, <span class="comment">//属性，样式等</span></span><br><span class="line">  elm: <span class="literal">undefined</span>, <span class="comment">//真实的dom节点</span></span><br><span class="line">  key: <span class="literal">undefined</span>, <span class="comment">//唯一标识</span></span><br><span class="line">  sel: <span class="string">&quot;div&quot;</span>, <span class="comment">//选择器</span></span><br><span class="line">  text: <span class="string">&#x27;文本&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    init,</span><br><span class="line">    classModule,</span><br><span class="line">    propsModule,</span><br><span class="line">    styleModule,</span><br><span class="line">    eventListenersModule,</span><br><span class="line">    h,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;snabbdom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建出patch函数</span></span><br><span class="line"><span class="keyword">const</span> patch = init([</span><br><span class="line">    <span class="comment">// Init patch function with chosen modules</span></span><br><span class="line">    classModule, <span class="comment">// makes it easy to toggle classes</span></span><br><span class="line">    propsModule, <span class="comment">// for setting properties on DOM elements</span></span><br><span class="line">    styleModule, <span class="comment">// handles styling on elements with support for animations</span></span><br><span class="line">    eventListenersModule, <span class="comment">// attaches event listeners</span></span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;container&quot;</span>);</span><br><span class="line"><span class="comment">// 创建虚拟节点 h函数</span></span><br><span class="line"><span class="keyword">const</span> vnode = h(<span class="string">&quot;div#container.two.classes&quot;</span>, &#123; <span class="attr">on</span>: &#123; <span class="attr">click</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; &#125; &#125;, [</span><br><span class="line">    h(<span class="string">&quot;span&quot;</span>, &#123; <span class="attr">style</span>: &#123; <span class="attr">fontWeight</span>: <span class="string">&quot;bold&quot;</span> &#125; &#125;, <span class="string">&quot;This is bold&quot;</span>),</span><br><span class="line">    <span class="string">&quot; and this is just normal text&quot;</span>,</span><br><span class="line">    h(<span class="string">&quot;a&quot;</span>, &#123; <span class="attr">props</span>: &#123; <span class="attr">href</span>: <span class="string">&quot;/foo&quot;</span> &#125; &#125;, <span class="string">&quot;I&#x27;ll take you places!&quot;</span>),</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// console.log(vnode)</span></span><br><span class="line"><span class="comment">// Patch into empty DOM element – this modifies the DOM as a side effect</span></span><br><span class="line"><span class="comment">// 让虚拟节点上树</span></span><br><span class="line">patch(container, vnode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newVnode = h(</span><br><span class="line">    <span class="string">&quot;div#container.two.classes&quot;</span>,</span><br><span class="line">    &#123; <span class="attr">on</span>: &#123; <span class="attr">click</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; &#125; &#125;,</span><br><span class="line">    [</span><br><span class="line">        h(</span><br><span class="line">            <span class="string">&quot;span&quot;</span>,</span><br><span class="line">            &#123; <span class="attr">style</span>: &#123; <span class="attr">fontWeight</span>: <span class="string">&quot;normal&quot;</span>, <span class="attr">fontStyle</span>: <span class="string">&quot;italic&quot;</span> &#125; &#125;,</span><br><span class="line">            <span class="string">&quot;This is now italic type&quot;</span></span><br><span class="line">        ),</span><br><span class="line">        <span class="string">&quot; and this is still just normal text&quot;</span>,</span><br><span class="line">        h(<span class="string">&quot;a&quot;</span>, &#123; <span class="attr">props</span>: &#123; <span class="attr">href</span>: <span class="string">&quot;/bar&quot;</span> &#125; &#125;, <span class="string">&quot;I&#x27;ll take you places!&quot;</span>),</span><br><span class="line">    ]</span><br><span class="line">);</span><br><span class="line"><span class="comment">// Second `patch` invocation</span></span><br><span class="line">patch(vnode, newVnode); <span class="comment">// Snabbdom efficiently updates the old view to the new state</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vnode3 = h(</span><br><span class="line">    <span class="string">&#x27;ul&#x27;</span>,[</span><br><span class="line">        h(<span class="string">&#x27;li&#x27;</span>,<span class="string">&#x27;one&#x27;</span>),</span><br><span class="line">        h(<span class="string">&#x27;li&#x27;</span>,<span class="string">&quot;two&quot;</span>)</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(vnode3);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   children:[</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//       sel:&#x27;li&#x27;,</span></span><br><span class="line"><span class="comment">//       data:&#123;&#125;,</span></span><br><span class="line"><span class="comment">//       text: &#x27;one&#x27;,</span></span><br><span class="line"><span class="comment">//       elm: li,</span></span><br><span class="line"><span class="comment">//       key: undefined,</span></span><br><span class="line"><span class="comment">//       children: undefined</span></span><br><span class="line"><span class="comment">//     &#125;,</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//       sel:&#x27;li&#x27;,</span></span><br><span class="line"><span class="comment">//       data:&#123;&#125;,</span></span><br><span class="line"><span class="comment">//       text: &#x27;two&#x27;,</span></span><br><span class="line"><span class="comment">//       elm: li,</span></span><br><span class="line"><span class="comment">//       key: undefined,</span></span><br><span class="line"><span class="comment">//       children: undefined</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//   ],</span></span><br><span class="line"><span class="comment">//   sel:&#x27;ul&#x27;,</span></span><br><span class="line"><span class="comment">//   elm: ul,</span></span><br><span class="line"><span class="comment">//   data:&#123;&#125;,</span></span><br><span class="line"><span class="comment">//   key: undefined,</span></span><br><span class="line"><span class="comment">//   text: undefined</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">patch(vnode,vnode3)</span><br></pre></td></tr></table></figure><ul><li>key是节点的唯一标识，告诉diff算法，在更改前后他们是同一个dom节点</li><li>只比较同一层级，不跨级作比较</li><li>只有是同一个虚拟节点才进行精细比较，否则就是暴力删除旧的，插入新的。</li></ul><p>diff算法：</p><ul><li>patch函数，首先判断oldvnode是不是虚拟节点，如果不是，转换为虚拟节点</li><li>接着判断是不是同一个虚拟节点（选择器相同且key相同），如果不是，则创建新的节点并插入删除旧的节点</li><li>如果是同一个虚拟节点则进行精细比较，调用patchVnode函数，首先判断新虚拟节点vnode和旧虚拟节点oldVnode是否指向同一个对象，如果是直接返回</li><li>如果他们都有文本节点并且不相等，那么将vnode的文本节点设置为真实dom的文本节点</li><li>如果oldVnode有子节点而vnode没有子节点，则删除对应真实dom的子节点</li><li>如果oldVnode没有子节点而vnode有子节点，将vnode的子节点真实化后添加到真实dom</li><li>如果oldVnode和vnode都有子节点则执行updateChildren函数比较子节点</li></ul><p>diff算法对比同级节点：<br>为了保证dom顺序和新节点保持一致使用while循环和首尾节点进行对比，对新旧虚拟节点数组的开始和结束节点设置索引，遍历的过程向中间移动索引，这样既能实现排序也减小了时间复杂度。两节点比较，有四种比对方式：</p><ul><li>旧开始节点  和  新结束节点  比较</li><li>旧结束节点  和  新开始节点  比较</li><li>旧开始节点  和  新开始节点  比较</li><li>旧结束节点  和  新结束节点  比较</li></ul><p>旧节点：oldStartIndex—-&gt;oldEndIndex<br>新节点：newStartIndex—-&gt;newEndIndex</p><p>比如：如果oldStartIndex和newEndIndex匹配上了，那么真实dom的第一个节点会移动到最右；如果newStartIndex和oldEndIndex匹配上了，那么真实dom的最后一个元素会移动到最左，匹配上的两个指针向中间移动，直到while循环结束</p><p>如果四种匹配都没有成功：</p><ul><li>那么遍历新节点，用新节点的key去老节点数组中查找相同节点</li><li>如果没有找到，说明当前节点是新节点，创建对应dom元素并插入到真实dom</li><li>如果找到了，比对新旧节点的sel是否相同<ul><li>如果相同，说明是同一个节点，移动到dom元素的最左边</li><li>如果不相同，说明修改了节点，创建对应的dom元素并插入到真实dom树中</li></ul></li></ul><p>循环结束：</p><ul><li>如果老节点的子节点先遍历完，那么说明新节点有新增节点，将新增节点批量加入</li><li>如果新节点的子节点先遍历完，那么说明老节点有剩余，将剩余节点批量删除</li></ul><p>例子：</p><p><img src="/ZJY.github.io/images/domdiff.jpeg" alt="image"></p><ul><li>先对首尾进行4种比较:b和a,b和e,a和e,e和e. 得出e节点匹配在真实DOM最右侧中得出第1步. 索引向中间移动,剩下old: b a d f 剩下new: a b</li><li>对剩余的同样进行收尾比较,匹配出b匹配在真实DOM的最左侧.剩下old: a d f 剩下new: a</li><li>同上,匹配出a匹配在真实DOM的最左侧.剩下old:d f 剩下new: 空</li><li>最后old长度大于new的长度,把真实dom中对应的删除</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>querySelector和getElement的区别</title>
      <link href="/ZJY.github.io/2021/04/09/querySelector%E5%92%8CgetElement%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/ZJY.github.io/2021/04/09/querySelector%E5%92%8CgetElement%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>querySelector()和querySelectorAll()是原生的选择符</p><ul><li>querySelector 属于 W3C 中的 Selectors API 规范 。而 getElementsBy 系列则属于 W3C 的 DOM 规范”</li><li>getElementBy系列方法获取的是动态集合，而querySelector获取的是静态集合。<br>简单来说就是，动态集合选出的元素会随文档改变而改变，但是静态的不会，静态集合在取出来以后元素与文档的改变无关。</li><li>getElementBy系列方法性能优于querySelector</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;query&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;query&#x27;</span>);</span><br><span class="line"><span class="comment">// query: 77.35107421875 ms</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;getElement&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;getElement&#x27;</span>);</span><br><span class="line"><span class="comment">// getElement: 0.22900390625 ms</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MVC/MVP/MVVM模式的概念和区别</title>
      <link href="/ZJY.github.io/2021/04/07/MVC-MVP-MVVM%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
      <url>/ZJY.github.io/2021/04/07/MVC-MVP-MVVM%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>1.MVC模式</p><p>一种使用MVC（模型-视图-控制器 model-view-controller）设计的web应用程序的模式：</p><p>Model：模型，表示应用程序核心（数据库）<br>View：视图，显示效果（html页面）<br>controller：控制器，处理用户输入（业务逻辑）</p><p>MVC 模式同时提供了对 HTML、CSS 和 JavaScript 的完全控制<br>最典型的MVC就是JSP + servlet + javabean的模式</p><p>视图是用户看到并与之交互的界面<br>模型表示企业数据和业务规则<br>控制器接受用户的输入并调用模型和视图去完成用户的需求</p><p>MVC是单向通信。也就是View跟Model，必须通过Controller来承上启下</p><p><img src="/ZJY.github.io/images/mvc.png" alt="image"></p><p>2.MVP模式</p><p>Model-View-Presenter ；MVP 是从经典的模式MVC演变而来，它们的基本思想有相通的地方Controller/Presenter负责逻辑的处理，Model提供数据，View负责显示。</p><p><img src="/ZJY.github.io/images/mvp.png" alt="image"></p><p>MVP与MVC有着一个重大的区别：在MVP中View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部，而在MVC中View会直接从Model中读取数据而不是通过 Controller</p><p>在MVC模型里，Model不依赖于View，但是View是依赖于Model的</p><p>3.MVVM模式</p><p>M - Model，Model 代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑</p><p>V - View，View 代表 UI 组件，它负责将数据模型转化为 UI 展现出来</p><p>VM - ViewModel，ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步 View 和 Model 的对象，连接 Model 和 View之间的桥梁，绑定数据到viewmodel层并自动更新渲染到页面上，视图变化通知到viewmodel层去更新数据</p><p><img src="/ZJY.github.io/images/mvvm.png" alt="image"></p><p>MVVM模式和MVC模式一样，主要目的是分离视图（View）和模型（Model）</p><p>mvvm模式将Presener改名为View Model，基本上与MVP模式完全一致，唯一的区别是，它采用双向绑定(data-binding): View的 变动，自动反映在View Model，反之亦然。这样开发者就不用处理接收事件和View更新的工作</p><p>这些模式是依次进化而形成MVC/MVP—&gt;MVVM。在以前传统的开发模式当中即MVC模式，前端人员只负责Model（数据库） View（视图） Controller /Presenter/ViewModel（控制器） 当中的View（视图）部分，写好页面交由后端创建渲染模板并提供数据，随着MVVM模式的出现前端已经可以自己写业务逻辑以及渲染模板，后端只负责提供数据即可。</p><p>4.观察者模式：<br>在观察者模式中，观察者直接订阅目标事件，在目标发出内容改变的事件后，直接接收事件并作出响应</p><p>5.发布订阅者模式<br>在发布订阅模式中，发布者和订阅者之间多了一个发布通道；一方面从发布者接收事件，另一方面向订阅者发布事件；订阅者需要从事件通道订阅事件</p><p>观察者模式： 观察者（Observer）直接订阅（Subscribe）主题（Subject），而当主题被激活的时候，会触发（Fire Event）观察者里的事件。</p><p>发布订阅模式： 订阅者（Subscriber）把自己想订阅的事件注册（Subscribe）到调度中心（Topic），当发布者（Publisher）发布该事件（Publish topic）到调度中心，也就是该事件触发时，由调度中心统一调度（Fire Event）订阅者注册到调度中心的处理代码。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css中伪类和伪元素</title>
      <link href="/ZJY.github.io/2021/03/28/css%E4%B8%AD%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0/"/>
      <url>/ZJY.github.io/2021/03/28/css%E4%B8%AD%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h2><p>css引入伪类和伪元素是为了格式化文档树以外的信息。也就是说伪类和伪元素是为了修饰不在文档树中的部分。比如一句话中第一个字母或者列表的第一个元素。</p><h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3><p>伪类用于当已有元素处于某个状态时，为其添加的样式，这个状态是根据用户行为而动态变化的。比如用户鼠标悬停:hover</p><h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><p>伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如添加::before伪元素在一个元素前增加一些文本。并为这些文本添加样式。虽然这些文本用户可以看到，但并不存在文档树中。</p><p>伪类的操作对象是文档树中已有的元素，而伪元素则创建了一个文档树之外的元素。<br>因此，伪类与伪元素的区别在于：有没有创建一个文档树之外的元素。</p><h3 id="伪元素是使用单冒号还是双冒号"><a href="#伪元素是使用单冒号还是双冒号" class="headerlink" title="伪元素是使用单冒号还是双冒号"></a>伪元素是使用单冒号还是双冒号</h3><p>虽然CSS3标准要求伪元素使用双冒号的写法，但也依然支持单冒号的写法。为了向后兼容，我们建议你在目前还是使用单冒号的写法。</p><h3 id="伪类和伪元素的具体用法"><a href="#伪类和伪元素的具体用法" class="headerlink" title="伪类和伪元素的具体用法"></a>伪类和伪元素的具体用法</h3><p>伪类：</p><ul><li>状态：:link :visited :hover :actived :focus</li><li>语言相关：:lang :dir</li><li>其他：:root  :fullscreen</li><li>表单相关：:checked :disabled :empty :enabled :valid :invalid :required :read-only :scope</li><li>结构化：:not :first-child :last-child :first-of-type :last-of-type :nth-child :nth-of-child :only-child :only-of-type :target</li></ul><p>伪元素：</p><ul><li>单双冒号：::before/:before   ::after/:after  ::first-letter/:first-letter  ::first-line/:first-line</li><li>双冒号：::selection  ::placeholder  ::backdrop</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP的请求头标签 If-Modified-Since与Last-Modified</title>
      <link href="/ZJY.github.io/2021/03/28/HTTP%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%B4%E6%A0%87%E7%AD%BE-If-Modified-Since%E4%B8%8ELast-Modified/"/>
      <url>/ZJY.github.io/2021/03/28/HTTP%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%B4%E6%A0%87%E7%AD%BE-If-Modified-Since%E4%B8%8ELast-Modified/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP的请求头标签-If-Modified-Since与Last-Modified"><a href="#HTTP的请求头标签-If-Modified-Since与Last-Modified" class="headerlink" title="HTTP的请求头标签 If-Modified-Since与Last-Modified"></a>HTTP的请求头标签 If-Modified-Since与Last-Modified</h2><h3 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1.基本定义"></a>1.基本定义</h3><p>If-Modified-since和last-modified都是http请求头中标签，用于记录页面的最后修改时间</p><h3 id="2-发送方向"><a href="#2-发送方向" class="headerlink" title="2.发送方向"></a>2.发送方向</h3><p>Last-Modified是服务器向客户端发送的http请求头标签<br>if-modified-since是由客户端向服务器发送的http请求他标签</p><h3 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3.应用场景"></a>3.应用场景</h3><p>（1）last-modified:当浏览器第一次请求某个url时，服务端返回状态200，内容是请求的资源，同时有一个last-modifined属性标记此文件在服务端最后被修改的时间，格式：<br>Last-Modified: Fri, 12 May 2006 18:53:33 GMT<br>（2）if-modified-since: 客户端第二次请求此url时，根据http协议的规定，浏览器会向服务器发送一个if-modified-since报头，询问此文件是否被修改过，格式：<br>If-Modified-Since: Fri, 12 May 2006 18:53:33 GMT<br>后面时间是本地浏览器存储文件修改的时间</p><p>如果服务端的资源没有发生变化，则时间一致，自动返回状态码304，客户端接收到后就将本地文件显示到浏览器，这样就节省来传输流量</p><p>如果服务器资源发生改变或者重启服务器，时间不一致，就返回http状态码200和新的文件内容，客户端接收到后就丢弃旧的文件，把新文件缓存起来，并显示到浏览器中。</p><p>以上操作可以保证不向客户端发送重复资源，服务端资源发生变化时，客户端能得到最新的资源</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack的插件plugin</title>
      <link href="/ZJY.github.io/2021/03/26/webpack%E7%9A%84%E6%8F%92%E4%BB%B6plugin/"/>
      <url>/ZJY.github.io/2021/03/26/webpack%E7%9A%84%E6%8F%92%E4%BB%B6plugin/</url>
      
        <content type="html"><![CDATA[<h3 id="插件-plugin"><a href="#插件-plugin" class="headerlink" title="插件(plugin)"></a>插件(plugin)</h3><p>loader用来转换文件，插件用来执行更广泛的任务。包括：打包优化、资源管理，注入环境变量。<br>使用一个插件，只需要require()它，添加到plugins数组中，多数插件可以通过option选项自定义。<br>你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建一个插件实例</p><p>webpack插件是一个具有apply方法的js对象，apply 方法会被 webpack compiler 调用，并且在__整个__编译生命周期都可以访问 compiler 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>); <span class="comment">// 通过 npm 安装</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins:[</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span> &#125;);</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HtmlWebpackPlugin插件为应用程序生成一个html文件，并自动注入所以生成的bundle</p><p>clean-webpack-plugin:打包之前删除 dist。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line">plugins:[</span><br><span class="line">  <span class="keyword">new</span> CleanWebpackPlugin();</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>CommonsChunkPlugin:提取chunks间共享的通用模块</p><p>MiniCssExtractPlugin：为每个引入css的js文件创建一个css文件</p><p>HotModuleReplacementPlugin：启用模块热更替</p><p>uglifyjs-webpack-plugin：压缩js文件的体积</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题</title>
      <link href="/ZJY.github.io/2021/03/25/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/ZJY.github.io/2021/03/25/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-网络中使用图片格式有哪些？"><a href="#1-网络中使用图片格式有哪些？" class="headerlink" title="1.网络中使用图片格式有哪些？"></a>1.网络中使用图片格式有哪些？</h3><p>jpeg：目前网络上最流行的图片格式，可以把文件压缩到最小的格式。在ps中以jpeg格式保存可以提供13级压缩级别。（有损压缩）<br>svg：可缩放矢量图形，基于xml。<br>png：支持高级别无损耗压缩，支持alpha 通道透明度，较旧的浏览器和程序可能不支持 PNG 文件。<br>gif：有损压缩，不支持Alpha透明通道。可做动画</p><h3 id="2-简述盒子模型"><a href="#2-简述盒子模型" class="headerlink" title="2.简述盒子模型"></a>2.简述盒子模型</h3><p>一个盒子由：margin + padding + border + content<br>默认情况下，盒子宽高只是content的宽和高<br>box-sizing:content-box; 元素宽高等于content宽高<br>box-sizing:border-box; 元素宽高等于content宽高+padding+border</p><h3 id="3-音视频标签的使用"><a href="#3-音视频标签的使用" class="headerlink" title="3.音视频标签的使用"></a>3.音视频标签的使用</h3><p>视频：video</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">width</span>=<span class="string">&quot;320&quot;</span> <span class="attr">height</span>=<span class="string">&quot;240&quot;</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;movie.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;movie.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/ogg&quot;</span>&gt;</span></span><br><span class="line">    您的浏览器不支持 video 标签。</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>video 元素支持三种视频格式：MP4、WebM、Ogg。<br>可选属性：</p><ul><li>autoplay:是否自动播放</li><li>src：要播放的视频的 URL。</li><li>controls：向用户显示控件，比如播放按钮</li><li>width/height：设置播放器的宽高</li><li>muted：是否静音</li><li>preload：如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。</li><li>poster：规定视频正在下载时显示的图像，直到用户点击播放按钮。</li><li>loop:是否循环播放</li></ul><p>音频：audio</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;horse.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/ogg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;horse.mp3&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/mpeg&quot;</span>&gt;</span></span><br><span class="line">  您的浏览器不支持 audio 元素。</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><p>支持的3种文件格式：MP3、Wav、Ogg</p><p>可选属性：</p><ul><li>autoplay:是否自动播放</li><li>src：要播放的音频的 URL。</li><li>controls：向用户显示控件，比如播放按钮</li><li>muted：是否静音</li><li>preload：规定当网页加载时，音频是否默认被加载以及如何被加载。</li><li>loop:是否循环播放</li></ul><h3 id="4-html5新增的内容有哪些？"><a href="#4-html5新增的内容有哪些？" class="headerlink" title="4.html5新增的内容有哪些？"></a>4.html5新增的内容有哪些？</h3><p>新增语义化标签<br>新增表单类型<br>表单元素/事件/属性<br>多媒体标签</p><h3 id="5-html5新增的语义化标签"><a href="#5-html5新增的语义化标签" class="headerlink" title="5.html5新增的语义化标签"></a>5.html5新增的语义化标签</h3><p>main,nav,section,article,header,footer,embed,video,audio,mark,figure,aside</p><h3 id="6-清除浮动的方式？"><a href="#6-清除浮动的方式？" class="headerlink" title="6.清除浮动的方式？"></a>6.清除浮动的方式？</h3><p>1.高度塌陷<br>所有子元素浮动，父元素没有设置高度时，这时父元素产生高度塌陷</p><p>解决1：给父元素单独设置高度<br>优点：快速简单，代码少； 缺点：无法进行响应式布局<br>解决2:给父元素设置overflow:hidden;zoom:1;(针对ie6的兼容)<br>优点：快速简单、代码少，兼容性高； 缺点：超出部分被隐藏，布局时要注意<br>解决3:给浮动元素后面添加空标签，设置clear:both;height:0;overflow:hidden;<br>优点：快速简单、代码少，兼容性高； 缺点：增加空标签，不利于页面优化；<br>解决4:给父元素设置overflow:auto;<br>优点：快速简单、代码少，兼容性高； 缺点：若父元素设置了高度，子元素超出父元素宽高会出现滚动条<br>解决5:给塌陷的元素设置伪元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.fater</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">overflow</span>:hidden;</span><br><span class="line">  <span class="attribute">visibility</span>:hidden;</span><br><span class="line">  <span class="attribute">clear</span>:both;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">display</span>:block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：写法固定兼容性高； 缺点：代码多</p><h3 id="7-给元素设置水平垂直居中"><a href="#7-给元素设置水平垂直居中" class="headerlink" title="7.给元素设置水平垂直居中"></a>7.给元素设置水平垂直居中</h3><p>一.水平居中<br>1.行内元素：只需要把行内元素包裹在一个属性 display 为 block 的父层元素中，并且把父层元素添加如下属性即可</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">  <span class="attribute">text-align</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.块状元素：给该元素设置：margin:0 auto;</p><p>3.多个块状元素，给元素设置display:inline-block,并把父元素的text-align:center</p><p>4.多个块状元素，给父元素设置display:flex;justify-content:center;</p><p>二、垂直居中<br>1.单行行内元素：设置height和line-height属性和父元素高度一样</p><p>2.多行行内元素：设置父元素属性：display:table-cell; vertical-align:middle;</p><p>3.已知高度的块状元素：给该元素设置属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">position</span><span class="selector-pseudo">:relative</span>;</span><br><span class="line"><span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span><br><span class="line"><span class="selector-tag">top</span><span class="selector-pseudo">:50</span>%;</span><br><span class="line"><span class="selector-tag">margin-top</span><span class="selector-pseudo">:-50px</span>;</span><br></pre></td></tr></table></figure><p>三、水平垂直居中<br>1.已知宽度和高度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">width</span><span class="selector-pseudo">:200px</span>;</span><br><span class="line"><span class="selector-tag">height</span><span class="selector-pseudo">:200px</span>;</span><br><span class="line"><span class="selector-tag">position</span><span class="selector-pseudo">:relative</span>;</span><br><span class="line"><span class="selector-tag">top</span><span class="selector-pseudo">:50</span>%;</span><br><span class="line"><span class="selector-tag">left</span><span class="selector-pseudo">:50</span>%;</span><br><span class="line"><span class="selector-tag">margin-top</span><span class="selector-pseudo">:-100px</span>;</span><br><span class="line"><span class="selector-tag">margin-left</span><span class="selector-pseudo">:-100px</span>;</span><br></pre></td></tr></table></figure><p>2.未知高度和宽度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">position</span><span class="selector-pseudo">:relative</span>;</span><br><span class="line"><span class="selector-tag">top</span><span class="selector-pseudo">:50</span>%;</span><br><span class="line"><span class="selector-tag">left</span><span class="selector-pseudo">:50</span>%;</span><br><span class="line"><span class="selector-tag">transform</span><span class="selector-pseudo">:translate(-50</span>%,<span class="selector-tag">-50</span>%);</span><br></pre></td></tr></table></figure><p>3.使用flex布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">display</span><span class="selector-pseudo">:flex</span>;</span><br><span class="line"><span class="selector-tag">align-items</span><span class="selector-pseudo">:center</span>;</span><br><span class="line"><span class="selector-tag">justify-content</span><span class="selector-pseudo">:center</span>;</span><br></pre></td></tr></table></figure><h3 id="8-display-inline-block元素间默认间距"><a href="#8-display-inline-block元素间默认间距" class="headerlink" title="8.display:inline-block元素间默认间距"></a>8.display:inline-block元素间默认间距</h3><p>1.给行内块元素设置浮动（需要清除浮动带来的影响）<br>2.给行内元素的父元素设置font-size:0;<br>3.给父元素添加词间距属性word-spacing,属性值为负数根据情况给出</p><h3 id="9-html5拖拽api"><a href="#9-html5拖拽api" class="headerlink" title="9.html5拖拽api"></a>9.html5拖拽api</h3><p>dragstart:事件主体是被拖拽元素，拖拽开始时触发<br>drag：事件主体是被拖拽元素，拖拽时触发<br>dragenter：事件主体是目标元素，被拖拽元素进入目标元素时触发<br>dragover：事件主体是目标元素，被拖拽元素在目标元素移动时触发<br>dragleave：事件主体是目标元素，被拖拽元素离开目标元素时触发<br>drog：事件主体是目标元素，在目标元素完全接受被拖拽元素时触发<br>dragend：事件主体是目标元素，在拖拽完成时触发</p><h3 id="10-双边距重叠问题"><a href="#10-双边距重叠问题" class="headerlink" title="10.双边距重叠问题"></a>10.双边距重叠问题</h3><p>多个相邻普通流中块元素垂直方向margin会发生重叠：</p><ul><li>两个相邻的外边距都是正数时，重叠结果是2者中较大值</li><li>两个相邻的外边距都是负数时，重叠结果是2者绝对值的较大值</li><li>两个相邻的外边距一正一负时，重叠结果是2者之和</li></ul><h3 id="11-什么是面向对象？"><a href="#11-什么是面向对象？" class="headerlink" title="11.什么是面向对象？"></a>11.什么是面向对象？</h3><p>面向对象是一种思想，是对面向过程而言的。面向对象就是把功能通过对象来实现，把功能封装到对象中，让对象去实现具体的细节。这种思想将数据放在第一位，是对数据的一种优化，使操作更加简单，方便简化了过程。</p><p>js本身没有class类型，但每个函数都有一个prototype属性，prototype指向一个对象，当函数作为构造函数使用时，prototype就起到类似于class的作用</p><p>面向对象的三个特点：封装、继承和多态。</p><h3 id="12-普通函数和构造函数的区别？"><a href="#12-普通函数和构造函数的区别？" class="headerlink" title="12.普通函数和构造函数的区别？"></a>12.普通函数和构造函数的区别？</h3><p>1.构造函数也是普通函数，创建方式和普通函数一样，但是构造函数名首字母大写<br>2.构造函数内部会创建一个对象，即实例，普通函数内部不会创建新对象<br>3.普通函数之间调用，构造函数通过new调用<br>4.构造函数内部this指向新创建的对象，而普通函数this指向函数的调用者<br>5.构造函数默认的返回值是创建的对象（实例），而普通函数返回值是return的值<br>6.构造函数的函数名和类名相同</p><h3 id="13-原型和原型链"><a href="#13-原型和原型链" class="headerlink" title="13.原型和原型链"></a>13.原型和原型链</h3><p>(1)原型<br>1.所有引用类型都有一个<strong>proto</strong>(隐式原型)属性，属性值是一个普通的对象<br>2.所有函数都有一个prototype（原型）属性，属性值是一个普通的对象<br>3.所有引用类型的__proto__都指向它构造函数的prototype</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.__proto__ === <span class="built_in">Array</span>.prototype; <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>(2)原型链<br>当访问对象的一个属性时，会先在这个对象的属性中查找，如果没有找到就去它的__proto__隐式原型中查找，即它的构造函数的prototype，如果还没有找到就去构造函数的prototype.__proto__中查找，这样一层一层的向上查找形成的链式结构叫原型链。</p><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Parent(<span class="string">&#x27;child&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child.name); <span class="comment">//&#x27;child&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(child.age); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>在child中查找某属性时：<br>1.在child中查找属性，本身有该属性时，返回值，没有去child.<strong>proto__，即Parent.prototype中查找<br>2.如果child.__proto__，即Parent.prototype有该属性，返回值，没有则去Parent.prototype.__proto__，即Object.prototype中查找<br>3.如果Parent.prototype.__proto__，即Object.prototype中有该属性，则返回值，没有则去Object.prototype.__proto</strong>,即null中查找<br>4.Object.prototype.<strong>proto</strong> === null,返回undefined</p><p>一直往上层查找，直到null还没有找到，返回undefined<br>Object.prototype.<strong>proto</strong> === null<br>所有从原型或更高级原型中的得到、执行的方法，其中的this在执行时，指向当前这个触发事件执行的对象</p><h3 id="14-clientHeight-offsetHeight-scrollHeight的区别？clientTop-offsetTop-scrollTop的区别？"><a href="#14-clientHeight-offsetHeight-scrollHeight的区别？clientTop-offsetTop-scrollTop的区别？" class="headerlink" title="14.clientHeight,offsetHeight,scrollHeight的区别？clientTop,offsetTop,scrollTop的区别？"></a>14.clientHeight,offsetHeight,scrollHeight的区别？clientTop,offsetTop,scrollTop的区别？</h3><p>clientHeight:表示可视区域的高度，不包含border和滚动条（包含padding）<br>offsetHeight:表示可视区域的高度，包含border和滚动条（包含padding）<br>scrollHeight:表示所有区域的高度，包含被隐藏的部分</p><p>clientTop:表示边框border的厚度，未指定情况一般为0<br>offsetTop:获取元素顶部距离相对于已定位的父元素或body顶部距离的高度<br>scrollTop：滚动后被隐藏的高度</p><h3 id="15-html5的拖拽"><a href="#15-html5的拖拽" class="headerlink" title="15.html5的拖拽"></a>15.html5的拖拽</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">allowDrop</span>(<span class="params">ev</span>)</span></span></span><br><span class="line">  &#123;</span><br><span class="line">    ev.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">drag</span>(<span class="params">ev</span>)</span></span></span><br><span class="line">  &#123;</span><br><span class="line"><span class="javascript">    ev.dataTransfer.setData(<span class="string">&quot;Text&quot;</span>,ev.target.id);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">drop</span>(<span class="params">ev</span>)</span></span></span><br><span class="line">  &#123;</span><br><span class="line">    ev.preventDefault();</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> data=ev.dataTransfer.getData(<span class="string">&quot;Text&quot;</span>);</span></span><br><span class="line"><span class="javascript">    ev.target.appendChild(<span class="built_in">document</span>.getElementById(data));</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span> <span class="attr">ondrop</span>=<span class="string">&quot;drop(event)&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">ondragover</span>=<span class="string">&quot;allowDrop(event)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;drag1&quot;</span> <span class="attr">src</span>=<span class="string">&quot;img_logo.gif&quot;</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">ondragstart</span>=<span class="string">&quot;drag(event)&quot;</span> <span class="attr">width</span>=<span class="string">&quot;336&quot;</span> <span class="attr">height</span>=<span class="string">&quot;69&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="16-js中垃圾回收机制"><a href="#16-js中垃圾回收机制" class="headerlink" title="16.js中垃圾回收机制"></a>16.js中垃圾回收机制</h3><p>为什么需要垃圾回收？</p><p>由于字符串、对象、数组没有固定的大小，所以当他们已知大小时才能进行动态的存储分配。js程序每次创建字符串、对象和数组时，解释器都必须分配内存来存储那个实体。只要像这样动态的分配了内存，最终都要释放内存以便他们能够被再用，否则，js的解释器会消耗完系统中所以可用的内存，造成系统崩溃。</p><p>js解释器可以检测到何时程序不再使用一个对象了，就可以把它占用的内存释放掉。</p><p>垃圾回收的方法：</p><p>1.标记清除：当变量就去环境时，就标记这个变量为“进入环境”，当离开环境时，就标记为离开环境。永远不能释放进入环境的变量所占用的内存。<br>垃圾回收器在运行时会给存储在内存中的变量都加上标记，然后去除环境变量中的变量，以及被环境变量中的变量所引用的变量，删除所有被标记的变量，然后垃圾回收器完成内存的清除工作，并回收他们占用的内存。</p><p>2.引用计数法：计算每个引用类型的变量的引用次数，当引用次数为0时就说明没有方法访问这个值了，垃圾回收器再次运行的时候就会释放引用次数为0的值。</p><h3 id="17-http"><a href="#17-http" class="headerlink" title="17.http"></a>17.http</h3><p>http1.1：<br>1.长连接<br>2.管道传输：在同一个TCP连接里，可发起多个请求，只要第一个请求发出去了，不必等其回来，就可发第二个请求出去，可以减少整体的响应时间。但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求<br>3.队头阻塞：因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，会导致后面的请求也被阻塞，客户端一直请求不到数据，这也就是对头阻塞。</p><p>http2:<br>http2基于https的，所以安全有保障<br>1.头部压缩：会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的分<br>2.HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了二进制格式，头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧和数据帧<br>3.多路复用：可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。<br>4.服务器推送：在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息</p><p>http2有哪些缺陷？<br>多个http请求在复用同一个tcp连接时，下层的tcp协议是不知道有多少个http请求的<br>所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。<br>这都是基于 TCP 传输层的问题，所以 HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP</p><h3 id="18-map和set的区别？"><a href="#18-map和set的区别？" class="headerlink" title="18.map和set的区别？"></a>18.map和set的区别？</h3><p>map：map对象保存健值对，并且能够记住原始插入顺序。<br>描述：map对象在迭代时会根据原始插入顺序来进行for…of遍历，返回一个[key,value]的数组</p><p>属性</p><p>Map.prototype.constructor<br>返回一个函数，它创建了实例的原型。默认是Map函数。</p><p>Map.prototype.size<br>返回Map对象的键/值对的数量。</p><p>方法</p><p>Map.prototype.clear()<br>移除Map对象的所有键/值对 。</p><p>Map.prototype.delete(key)<br>如果 Map 对象中存在该元素，则移除它并返回 true；否则如果该元素不存在则返回 false。随后调用 Map.<br>prototype.has(key) 将返回 false 。</p><p>Map.prototype.entries()<br>返回一个新的 Iterator 对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。</p><p>Map.prototype.forEach(callbackFn[, thisArg])<br>按插入顺序，为 Map对象里的每一键值对调用一次callbackFn函数。如果为forEach提供了thisArg，它将在每次回调中作为this值。</p><p>Map.prototype.get(key)<br>返回键对应的值，如果不存在，则返回undefined。</p><p>Map.prototype.has(key)<br>返回一个布尔值，表示Map实例是否包含键对应的值。</p><p>Map.prototype.keys()<br>返回一个新的 Iterator对象， 它按插入顺序包含了Map对象中每个元素的键 。</p><p>Map.prototype.set(key, value)<br>设置Map对象中键的值。返回该Map对象。</p><p>Map.prototype.values()<br>返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的值 。</p><p>set：允许存储任何类型的唯一值，无论是原始值或者是对象引用。<br>描述：Set对象是值的集合，你可以按照插入的顺序迭代它的元素。 Set中的元素只会出现一次，即 Set 中的元素是唯一的。</p><p>实例属性</p><p>Set.prototype.size<br>返回 Set 对象中的值的个数</p><p>实例方法</p><p>Set.prototype.add(value)<br>在Set对象尾部添加一个元素。返回该Set对象。</p><p>Set.prototype.clear()<br>移除Set对象内的所有元素。</p><p>Set.prototype.delete(value)<br>移除Set中与这个值相等的元素，返回Set.prototype.has(value)在这个操作前会返回的值（即如果该元素存在，返回true，否则返回false）。Set.prototype.has(value)在此后会返回false。</p><p>Set.prototype.entries()<br>返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值的[value, value]数组。为了使这个方法和Map对象保持相似， 每个值的键和值相等。</p><p>Set.prototype.forEach(callbackFn[, thisArg])<br>按照插入顺序，为Set对象中的每一个值调用一次callBackFn。如果提供了thisArg参数，回调中的this会是这个参数。</p><p>Set.prototype.has(value)<br>返回一个布尔值，表示该值在Set中存在与否。</p><p>Set.prototype.keys() (en-US)<br>与values()方法相同，返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。</p><p>Set.prototype.values()<br>返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端渲染方式</title>
      <link href="/ZJY.github.io/2021/03/24/%E5%89%8D%E7%AB%AF%E6%B8%B2%E6%9F%93%E6%96%B9%E5%BC%8F/"/>
      <url>/ZJY.github.io/2021/03/24/%E5%89%8D%E7%AB%AF%E6%B8%B2%E6%9F%93%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="单页面应用"><a href="#单页面应用" class="headerlink" title="单页面应用"></a>单页面应用</h3><p>只要一个web页面的应用，单页面跳转仅刷新局部资源，公共资源（css、js）仅需加载一次。<br>如图：</p><p><img src="/ZJY.github.io/images/sing.png" alt="image"></p><h3 id="多页面应用"><a href="#多页面应用" class="headerlink" title="多页面应用"></a>多页面应用</h3><p>多页面应用跳转需刷新所有资源，每个公共资源需选择性重新加载。</p><p><img src="/ZJY.github.io/images/mutli.png" alt="image"></p><p>具体分析对比：</p><table><thead><tr><th align="center"></th><th align="center">单页面应用</th><th align="center">多页面应用</th></tr></thead><tbody><tr><td align="center">组成</td><td align="center">一个外壳页面和多个页面片段组成</td><td align="center">多个完整页面组成</td></tr><tr><td align="center">资源共用（css、js）</td><td align="center">资源共用，只需在外壳页面加载</td><td align="center">不共用，每个页面都需要加载</td></tr><tr><td align="center">刷新方式</td><td align="center">页面局部刷新或更改</td><td align="center">整页刷新</td></tr><tr><td align="center">url模式</td><td align="center">a.com/#/pageone<br>a.com/#/pagetwo</td><td align="center">a.com/pageone.html <br> a.com/pagetwo.html</td></tr><tr><td align="center">用户体验</td><td align="center">页面切换速度快，用户体验好</td><td align="center">页面切换加载缓慢，流畅度不够，用户体验比较差</td></tr></tbody></table><p>单页面应用就是只有一个主页面的应用，浏览器需要一开始就加载所有必须的html，css，js。所有的页面内容都包含在这个主页面中，但在写的时候还是分开写页面片段，然后在交互的时候由路由动态载入，单页面的页面跳转，仅刷新局部资源。</p><p>多页面（MPA），就是指一个应用中有多个页面，页面跳转时是整页刷新</p><h3 id="客户端渲染"><a href="#客户端渲染" class="headerlink" title="客户端渲染"></a>客户端渲染</h3><p>用户访问url，请求html文件，前端根据路由动态渲染页面内容，关键链路较长，有一定的白屏时间</p><h3 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h3><p>用户访问url，服务端根据访问路径请求所需数据，拼接成html字符串，返回给前端，前端接收到html已有部分内容</p><h3 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h3><p>构建阶段生成匹配预渲染路径的html文件（每个需要预渲染的路由都有一个对应的 html），构建处理的html已有部分内容</p><p>服务端渲染：发送请求-服务器请求数据渲染html-包含首屏的html<br>预渲染：发送请求-包含首屏的html<br>客户端渲染：发送请求-html-js加载并动态渲染</p><p>prerender-spa-plugin ：一个 webpack 插件用于在单页应用中预渲染静态 html 内容</p><p>安装插件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install prerender-spa-plugin --save-dev</span><br></pre></td></tr></table></figure><p>配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> PrerenderSpaPlugin = <span class="built_in">require</span>(<span class="string">&#x27;prerender-spa-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">new</span> PrerenderSpaPlugin(</span><br><span class="line">      <span class="comment">// 输出目录的绝对路径</span></span><br><span class="line">      path.join(__dirname, <span class="string">&#x27;../dist&#x27;</span>),</span><br><span class="line">      <span class="comment">// 预渲染的路由</span></span><br><span class="line">      [ <span class="string">&#x27;/new&#x27;</span>, <span class="string">&#x27;/hot&#x27;</span> ]</span><br><span class="line">    )</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化 PrerenderSpaPlugin 需要至少两个参数，第一个参数是单页应用的输出目录，第二个参数指定预渲染的路由，这里执行了两个路由 /new 和 /hot</p><p>npm run build构建后：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dist</span><br><span class="line">│  index.html</span><br><span class="line">│  </span><br><span class="line">├─hot</span><br><span class="line">│      index.html</span><br><span class="line">│      </span><br><span class="line">├─<span class="keyword">new</span></span><br><span class="line">│      index.html</span><br><span class="line">│      </span><br><span class="line">└─<span class="keyword">static</span></span><br></pre></td></tr></table></figure><p>预渲染的目录多了两个文件 new/index.html, hot/index.html</p><p>prerender-spa-plugin 原理:</p><p>在 webpack 构建阶段的最后，在本地启动一个 phantomjs，访问配置了预渲染的路由，再将 phantomjs 中渲染的页面输出到 html 文件中，并建立路由对应的目录。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>animation和transition的区别</title>
      <link href="/ZJY.github.io/2021/03/23/animation%E5%92%8Ctransition%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/ZJY.github.io/2021/03/23/animation%E5%92%8Ctransition%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="animation和transition的区别"><a href="#animation和transition的区别" class="headerlink" title="animation和transition的区别"></a>animation和transition的区别</h2><h3 id="css3动画和js动画的区别"><a href="#css3动画和js动画的区别" class="headerlink" title="css3动画和js动画的区别"></a>css3动画和js动画的区别</h3><p>js实现的是帧动画，css3实现的是补间动画<br>帧动画：使用定时器，每隔一段时间就更改元素<br>js动画逐帧绘制内容，可操作性高，可以很好的控制动画开始，暂停，回放，取帧等；但复杂度高于css动画，资源占有比较大<br>补间动画：状态发生变化产生动画<br>只需要确定第一帧和最后一帧的位置，2个关键帧之间内容由composite线程自动生成，不需要人为处理。对动画控制比较弱。</p><h3 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h3><p>transition属性设置过度属性，四个简写属性为：</p><ul><li>transition-property:指定css属性的name，默认是all</li><li>transition-duration：transition效果需要指定多少秒或毫秒才能完成，默认为0</li><li>transition-timing-function:指定transition效果的转速曲线,默认值ease<ul><li>linear：规定以相同的速度开始至结束的过度效果</li><li>ease：规定慢速开始，然后变快，然后慢速结束的过渡效果</li><li>ease-in：规定以慢速开始的过渡效果</li><li>ease-in-out:规定以慢速开始和结束的过渡效果</li></ul></li><li>transition-delay:定义transition效果延迟多久开始</li></ul><p>transition需要事件触发（比如hover类），不能在加载网页时自动开始<br>一次性，不能重复触发<br>只有2个状态，开始和结束<br>一个transition属性只能定义一个属性</p><h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h3><p>animation属性用来创建动画</p><p>@keyframes规则用于创建动画</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> myFirst&#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@keyframes创建动画后，需要将它绑定到某个选择器，需要一下2个css属性，才能将动画绑定到选择器：<br>1.规定动画的名称<br>2.规定动画的时长</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">animation</span>: myFirst <span class="number">5s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可用0%到100%代替from和to</p><ul><li>@keyframes：创建动画</li><li>animation：动画的简写，默认值none 0 ease 0 1 normal</li><li>animation-name: 规定@keyframes动画的名称</li><li>animation-duration: 规定动画的一个周期所需时长，默认是0</li><li>animation-timing-function: 规定动画的曲线，默认是ease</li><li>animation-delay: 规定动画何时开始，默认是0</li><li>animation-iteration-count: 规定动画播放次数，默认是1，值可取n/infinate(无限播放)</li><li>animation-direction: 规定动画是否在下一周期逆向播放，默认是normal,取值normal/alternate</li><li>animation-play-state: 规定动画是正在运行还是暂停，默认值是running，取值running/paused</li><li>animation-fill-mode: 定对象动画时间之外的状态</li></ul><p>总结：</p><table><thead><tr><th align="center">区别</th><th align="center">transition</th><th align="center">animation</th></tr></thead><tbody><tr><td align="center">能否自动执行</td><td align="center">不能，需要事件触发，比如hover</td><td align="center">能</td></tr><tr><td align="center">能否重复发生</td><td align="center">不能，除非重复触发</td><td align="center">能</td></tr><tr><td align="center">是否有多个状态</td><td align="center">2个，开始和结束状态</td><td align="center">能，比如从0% 到100%，任意指定过渡状态</td></tr><tr><td align="center">能否暂停</td><td align="center">不能</td><td align="center">能</td></tr><tr><td align="center">能否定义速度曲线</td><td align="center">能</td><td align="center">能</td></tr><tr><td align="center">能否定义某个属性值过渡</td><td align="center">能</td><td align="center">能</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-1.vue.js的简介</title>
      <link href="/ZJY.github.io/2021/03/18/vue-1.vue.js%E7%9A%84%E7%AE%80%E4%BB%8B/"/>
      <url>/ZJY.github.io/2021/03/18/vue-1.vue.js%E7%9A%84%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-vue-js的简介"><a href="#1-vue-js的简介" class="headerlink" title="1.vue.js的简介"></a>1.vue.js的简介</h2><p>jquery：命令式操作dom<br>vue：声明式操作dom<br>通过描述状态和dom之间的映射关系，就可以将状态渲染成dom呈现在用户界面，也就是渲染到网页中。</p><p>渐进式框架，就是框架分层。<br>最核心的部分是视图渲染，然后往外是组件机制，在这个基础上加上路由机制，再加上状态管理，最外层是构建工具。<br>视图渲染-组件机制-路由机制-状态管理-构建工具<br>分层指既可以使用核心的视图渲染功能来快速开发一些需求，也可以使用全家桶来开发大型应用。vue.js有足够的灵活性可以适应不同的需求，你可以根据自己的需求来选择不同的层级</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES5的继承和ES6继承的区别</title>
      <link href="/ZJY.github.io/2021/03/08/ES5%E7%9A%84%E7%BB%A7%E6%89%BF%E5%92%8CES6%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/ZJY.github.io/2021/03/08/ES5%E7%9A%84%E7%BB%A7%E6%89%BF%E5%92%8CES6%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="ES5的继承和ES6继承的区别"><a href="#ES5的继承和ES6继承的区别" class="headerlink" title="ES5的继承和ES6继承的区别"></a>ES5的继承和ES6继承的区别</h2><h3 id="ES5继承："><a href="#ES5继承：" class="headerlink" title="ES5继承："></a>ES5继承：</h3><p>基本思想：利用原型链让一个引用类型的原型去继承另一个引用类型的属性和方法（通过prototype和构造函数实现）<br>本质：将父类添加到子类的原型上去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GrandParent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;GrandParent&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.a = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype = <span class="keyword">new</span> GrandParent();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;Parent&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;Child&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.c = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(child); <span class="comment">//&#123;name:&#x27;child&#x27;,c:1&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(child.a); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(child.b); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(child.c); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><h3 id="ES6继承："><a href="#ES6继承：" class="headerlink" title="ES6继承："></a>ES6继承：</h3><p>基本思想：通过extends实现继承，子类可以继承父类的所以方法和属性。子类必须在constructor()方法中调用super()方法，因为新建的子类没有this对象，而是继承了父类的this对象。<br>本质：通过extends实现继承，子类继承了父类的所有方法和属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.a = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Person constructor&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;eat&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">play</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Play&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.b = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">study</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;study&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> stu = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="built_in">console</span>.log(stu.a, stu.b);</span><br><span class="line">stu.eat();</span><br><span class="line">stu.study();</span><br><span class="line">Student.play();</span><br></pre></td></tr></table></figure><h3 id="ES5-的继承和-ES6-的继承有什么区别-？"><a href="#ES5-的继承和-ES6-的继承有什么区别-？" class="headerlink" title="ES5 的继承和 ES6 的继承有什么区别 ？"></a>ES5 的继承和 ES6 的继承有什么区别 ？</h3><p>ES5 的继承时通过 prototype 或构造函数机制来实现。</p><ul><li>ES5 的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到 this 上（Parent.apply(this)）。</li><li>ES6 的继承机制完全不同，实质上是先创建父类的实例对象 this（所以必须先调用父类的 super()方法），然后再用子类的构造函数修改 this。</li></ul><p>具体的：ES6 通过 class 关键字定义类，里面有构造方法，类之间通过 extends 关键字实现继承。子类必须在 constructor 方法中调用 super 方法，否则新建实例报错。因为子类没有自己的 this 对象，而是继承了父类的 this 对象，然后对其进行加工。如果不调用 super 方法，子类得不到 this 对象。</p><p>ps：super 关键字指代父类的实例，即父类的 this 对象。在子类构造函数中，调用 super 后，才可使用 this 关键字，否则报错。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>setTimeout中的this指向</title>
      <link href="/ZJY.github.io/2021/03/01/settimeout%E4%B8%AD%E7%9A%84this%E6%8C%87%E5%90%91/"/>
      <url>/ZJY.github.io/2021/03/01/settimeout%E4%B8%AD%E7%9A%84this%E6%8C%87%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h2 id="setTimeout中的this指向"><a href="#setTimeout中的this指向" class="headerlink" title="setTimeout中的this指向"></a>setTimeout中的this指向</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    x:<span class="number">2</span>,</span><br><span class="line">    fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(obj)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn(); </span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     x:2,</span></span><br><span class="line"><span class="comment">//     fn:f()</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     x:2,</span></span><br><span class="line"><span class="comment">//     fn:f()</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(obj.fn, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//window全局对象</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     x:2,</span></span><br><span class="line"><span class="comment">//     fn:f()</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//等同于：setTimeout是window下的方法</span></span><br><span class="line"><span class="built_in">window</span>.setTimeout(obj.fn, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// obj.fn相当于把fn函数给拿出来调用</span></span><br><span class="line"><span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);<span class="comment">//this是全局对象</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//全局</span></span><br><span class="line">        <span class="built_in">console</span>.log(obj);<span class="comment">//obj</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript的Object.create方法</title>
      <link href="/ZJY.github.io/2021/03/01/javascript%E7%9A%84Object-create%E6%96%B9%E6%B3%95/"/>
      <url>/ZJY.github.io/2021/03/01/javascript%E7%9A%84Object-create%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h2><p>Object.create()方法创建一个新的对象,使用现有的对象来提供新创建对象的<strong>proto</strong>.</p><p>语法:<br>Object.create(proto, [propertiesObject])<br>参数:<br>proto:新创建对象的原型对象,<br>propertiesObject:可选,需要传入一个对象.该对象的属性类型,参照Object.defineProperties()的,<br>第二个参数.如果该参数被指定且不为undefined,该传入对象的自有可枚举属性(即其自身定义的属性,而不<br>是其原型链上的枚举属性)将为新创建的对象添加指定的属性值和对应的属性描述符.<br>返回值:一个新对象,带着指定的原型对象和属性<br>例外:如果propertiesObject参数是null或非原始包装对象,则抛出一个typeerror异常</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  isHuman: <span class="literal">false</span>,</span><br><span class="line">  printIntroduction: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>. Am I human? <span class="subst">$&#123;<span class="built_in">this</span>.isHuman&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> me = <span class="built_in">Object</span>.create(person);</span><br><span class="line"><span class="built_in">console</span>.log(me);</span><br><span class="line"><span class="comment">// me&#123;</span></span><br><span class="line"><span class="comment">//     __proto__:&#123;</span></span><br><span class="line"><span class="comment">//         isHuman: false,</span></span><br><span class="line"><span class="comment">//         printIntroduction:function()</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">me.name = <span class="string">&#x27;zjy&#x27;</span>;</span><br><span class="line">me.isHuman = <span class="literal">true</span>;</span><br><span class="line">me.printIntroduction();</span><br><span class="line"><span class="built_in">console</span>.log(me);</span><br><span class="line"><span class="comment">// me&#123;</span></span><br><span class="line"><span class="comment">//     isHuman: true,</span></span><br><span class="line"><span class="comment">//     name:&#x27;zjy&#x27;,</span></span><br><span class="line"><span class="comment">//     __proto__:&#123;</span></span><br><span class="line"><span class="comment">//         isHuman: false,</span></span><br><span class="line"><span class="comment">//         printIntroduction:function()</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xxx = <span class="built_in">Object</span>.create(&#123;</span><br><span class="line">    a:<span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;,&#123;</span><br><span class="line">    <span class="string">&#x27;str&#x27;</span>:&#123;</span><br><span class="line">        value:<span class="string">&#x27;zjy&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>:&#123;</span><br><span class="line">        value:<span class="string">&#x27;ha&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(xxx);</span><br><span class="line"><span class="comment">// xxx&#123;</span></span><br><span class="line"><span class="comment">//     name:&#x27;ha&#x27;,</span></span><br><span class="line"><span class="comment">//     xxx:&#x27;zjy&#x27;,</span></span><br><span class="line"><span class="comment">//     __proto__:&#123;</span></span><br><span class="line"><span class="comment">//         a:&#x27;a&#x27;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aObj = &#123;</span><br><span class="line">    a:<span class="string">&#x27;zjy&#x27;</span>,</span><br><span class="line">    b:<span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">    c:<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;n:&#x27;</span>+n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> _aObj = <span class="built_in">Object</span>.create(aObj,&#123;</span><br><span class="line">    txt:&#123;</span><br><span class="line">        value:<span class="string">&#x27;Object.create()方法的继承&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(_aObj);</span><br><span class="line"><span class="comment">// _aObj&#123;</span></span><br><span class="line"><span class="comment">//     txt:&#x27;Object.create()方法的继承&#x27;,</span></span><br><span class="line"><span class="comment">//     __proto__:&#123;</span></span><br><span class="line"><span class="comment">//         a:&#x27;zjy&#x27;,</span></span><br><span class="line"><span class="comment">//         b:&#x27;name&#x27;,</span></span><br><span class="line"><span class="comment">//         c:funtion()</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">_aObj.c(<span class="string">&#x27;haha&#x27;</span>);<span class="comment">//n:haha</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript的Object.entries方法</title>
      <link href="/ZJY.github.io/2021/03/01/javascript%E7%9A%84Object-entries%E6%96%B9%E6%B3%95/"/>
      <url>/ZJY.github.io/2021/03/01/javascript%E7%9A%84Object-entries%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="Object-entries方法"><a href="#Object-entries方法" class="headerlink" title="Object.entries方法"></a>Object.entries方法</h2><p>Object.entries()方法会返回指定对象自身可枚举属性，并返回其健值对数组，其排列与使用与for…in遍历该对象时返回一致，只不过for…in还会枚举其原型链中属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;</span><br><span class="line">    a: <span class="string">&#x27;somestring&#x27;</span>,</span><br><span class="line">    b: <span class="number">42</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(object1));</span><br><span class="line"><span class="comment">// Array：[[&#x27;a&#x27;,&#x27;somestring&#x27;],[&quot;b&quot;,42]]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(object1)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a: somestring</span></span><br><span class="line"><span class="comment">// b: 42</span></span><br></pre></td></tr></table></figure><p>语法：Object.entries(obj)<br>参数：<br>obj: 可以返回枚举健值对的对象<br>返回值：返回指定对象可枚举属性的健值对数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">  baz: <span class="number">42</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(obj)); <span class="comment">// [ [&#x27;foo&#x27;, &#x27;bar&#x27;], [&#x27;baz&#x27;, 42] ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// array like object</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">&#x27;c&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(obj1)); <span class="comment">// [ [&#x27;0&#x27;, &#x27;a&#x27;], [&#x27;1&#x27;, &#x27;b&#x27;], [&#x27;2&#x27;, &#x27;c&#x27;] ]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// array like object with random key ordering</span></span><br><span class="line"><span class="keyword">const</span> anObj = &#123;</span><br><span class="line">    <span class="number">100</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="number">7</span>: <span class="string">&#x27;c&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(anObj)); <span class="comment">// [ [&#x27;2&#x27;, &#x27;b&#x27;], [&#x27;7&#x27;, &#x27;c&#x27;], [&#x27;100&#x27;, &#x27;a&#x27;] ]</span></span><br><span class="line"><span class="keyword">for</span> (k <span class="keyword">in</span> anObj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(k); <span class="comment">//2   7   10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// getFoo is property which isn&#x27;t enumerable</span></span><br><span class="line"><span class="comment">// create和defineProperty方法创建对象属性,enumerable默认值为false</span></span><br><span class="line"><span class="keyword">const</span> myObj = <span class="built_in">Object</span>.create(&#123;&#125;, &#123;</span><br><span class="line">  getFoo: &#123;</span><br><span class="line">      <span class="function"><span class="title">value</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">this</span>.foo;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(myObj); <span class="comment">//&#123; getFoo:()&#125;</span></span><br><span class="line">myObj.foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myObj); <span class="comment">//&#123;foo:&quot;bar&quot;,getFoo:()&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(myObj)); <span class="comment">// [ [&#x27;foo&#x27;, &#x27;bar&#x27;] ]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// non-object argument will be coerced to an object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// [ [&#x27;0&#x27;, &#x27;f&#x27;], [&#x27;1&#x27;, &#x27;o&#x27;], [&#x27;2&#x27;, &#x27;o&#x27;] ]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// iterate through key-value gracefully</span></span><br><span class="line"><span class="keyword">const</span> objs = &#123;</span><br><span class="line">    a: <span class="number">5</span>,</span><br><span class="line">    b: <span class="number">7</span>,</span><br><span class="line">    c: <span class="number">9</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(objs)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> <span class="subst">$&#123;value&#125;</span>`</span>); <span class="comment">// &quot;a 5&quot;, &quot;b 7&quot;, &quot;c 9&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Or, using array extras</span></span><br><span class="line"><span class="built_in">Object</span>.entries(objs).forEach(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> <span class="subst">$&#123;value&#125;</span>`</span>); <span class="comment">// &quot;a 5&quot;, &quot;b 7&quot;, &quot;c 9&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Object转换为Map:</span></span><br><span class="line"><span class="comment">// new Map() 构造函数接受一个可迭代的entries。借助Object.entries方法你可以</span></span><br><span class="line"><span class="comment">// 很容易的将Object转换为Map:</span></span><br><span class="line"><span class="keyword">var</span> obj3 = &#123; <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;; </span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(obj3));</span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// Map &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript的Object.assign方法</title>
      <link href="/ZJY.github.io/2021/03/01/javascript%E7%9A%84Object-assign%E6%96%B9%E6%B3%95/"/>
      <url>/ZJY.github.io/2021/03/01/javascript%E7%9A%84Object-assign%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Object.assign方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象，并返回目标对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> resourceObject = &#123;</span><br><span class="line">    b: <span class="number">4</span>,</span><br><span class="line">    c: <span class="number">5</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> resourceObject1 = &#123;</span><br><span class="line">    d: <span class="number">6</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> returnObject = <span class="built_in">Object</span>.assign(target, resourceObject, resourceObject1);</span><br><span class="line"><span class="built_in">console</span>.log(target);</span><br><span class="line"><span class="built_in">console</span>.log(returnObject);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   a:1,</span></span><br><span class="line"><span class="comment">//   b:4,</span></span><br><span class="line"><span class="comment">//   c:5,</span></span><br><span class="line"><span class="comment">//   d:6</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>语法：Object.assign(target,…resource);<br>参数：</p><ul><li>target：目标对象</li><li>resource：源对象<br>返回值：目标对象<br>描述：如果目标对象和源对象有相同属性，则目标对象属性值会被源对象覆盖，相应的后面的源对象的属性会覆盖前面源对象的属性</li></ul><p>Object.assign只会拷贝源对象自身的并且可枚举属性到目标对象上。该方法使用源对象的getter方法和目标对象的setter方法。因此他分配属性不仅仅是复制或定义新的属性。<br>如果合并源包含getter，可能不适合将新属性合并到原型上，为了将属性定义复制到原型，应使用Object.defineProperty和Object.getOwnPropertyDescriptor()</p><p>注意，Object.assign不会在源对象属性值为null或undefined时抛出错误</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">    test:<span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">    foo:<span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(a,b)</span><br><span class="line"><span class="comment">// &#123;test:null, foo:undefined&#125;</span></span><br></pre></td></tr></table></figure><p>String和Symbol类型的属性都会被拷贝.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">    c: <span class="built_in">Symbol</span>.for(<span class="number">1</span>),</span><br><span class="line">    d: <span class="built_in">String</span>(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(b, <span class="string">&#x27;b&#x27;</span>, &#123;</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="number">4</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> c = <span class="built_in">Object</span>.assign(a, b);</span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br><span class="line"><span class="comment">// object&#123;</span></span><br><span class="line"><span class="comment">//     a:1,</span></span><br><span class="line"><span class="comment">//     b:2,</span></span><br><span class="line"><span class="comment">//     c:Symbol(1),</span></span><br><span class="line"><span class="comment">//     d:&#x27;aaa&#x27;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getter获取a.b属性的值，对目标对象b.b属性进行覆盖，调用b的setter方法，但b.b不可修改，报错</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="built_in">Object</span>.assign(b,a);<span class="comment">//typeerror:cannot assign to read only property &#x27;b&#x27; </span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> aa = &#123;</span><br><span class="line">    a: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> bb = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(bb, <span class="string">&#x27;b&#x27;</span>, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;i am b&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> cc = <span class="built_in">Object</span>.assign(aa, bb);</span><br><span class="line"><span class="built_in">console</span>.log(cc);</span><br><span class="line"><span class="comment">// object&#123;</span></span><br><span class="line"><span class="comment">//     a:&#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#125;//不能将含有getter的属性合并到原型中</span></span><br></pre></td></tr></table></figure><h3 id="深拷贝问题"><a href="#深拷贝问题" class="headerlink" title="深拷贝问题:"></a>深拷贝问题:</h3><p>针对深拷贝，需要使用其他办法，因为 Object.assign()拷贝的是（可枚举）属性值。<br>假如源值是一个对象的引用，它仅仅会复制其引用值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> log = <span class="built_in">console</span>.log;</span><br><span class="line"><span class="keyword">const</span> stringify = <span class="built_in">JSON</span>.stringify</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    &#x27;use strict&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">        a: <span class="number">0</span>,</span><br><span class="line">        b: &#123;</span><br><span class="line">            c: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1);</span><br><span class="line">    log(stringify(obj2)); <span class="comment">//&#123;&quot;a&quot;:0,&quot;b&quot;:&#123;&quot;c&quot;:0&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    obj1.a = <span class="number">1</span>;</span><br><span class="line">    log(stringify(obj1)); <span class="comment">//&#123;&quot;a&quot;:1,&quot;b&quot;:&#123;&quot;c&quot;:0&#125;&#125;</span></span><br><span class="line">    log(stringify(obj2)); <span class="comment">//&#123;&quot;a&quot;:0,&quot;b&quot;:&#123;&quot;c&quot;:0&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    obj2.a = <span class="number">2</span>;</span><br><span class="line">    log(stringify(obj1)); <span class="comment">//&#123;&quot;a&quot;:1,&quot;b&quot;:&#123;&quot;c&quot;:0&#125;&#125;</span></span><br><span class="line">    log(stringify(obj2)); <span class="comment">//&#123;&quot;a&quot;:2,&quot;b&quot;:&#123;&quot;c&quot;:0&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    obj2.b.c = <span class="number">3</span>;</span><br><span class="line">    log(stringify(obj1)); <span class="comment">//&#123;&quot;a&quot;:1,&quot;b&quot;:&#123;&quot;c&quot;:3&#125;&#125;</span></span><br><span class="line">    log(stringify(obj2)); <span class="comment">//&#123;&quot;a&quot;:1,&quot;b&quot;:&#123;&quot;c&quot;:3&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//deep clone</span></span><br><span class="line">    obj1 = &#123;</span><br><span class="line">        a: <span class="number">0</span>,</span><br><span class="line">        b: &#123;</span><br><span class="line">            c: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> obj3 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj1));</span><br><span class="line">    obj1.a = <span class="number">4</span>;</span><br><span class="line">    obj1.b.c = <span class="number">4</span>;</span><br><span class="line">    log(stringify(obj3)); <span class="comment">//&#123;&quot;a&quot;:0,&quot;b&quot;:&#123;&quot;c&quot;:0&#125;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>合并对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 = &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> o2 = &#123;</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> o3 = &#123;</span><br><span class="line">    c: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj4 = <span class="built_in">Object</span>.assign(o1, o2, o3);</span><br><span class="line"><span class="built_in">console</span>.log(obj4); <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(o1); <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;, 注意目标对象自身也会改变</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>合并具有相同属性的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oo1 = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">1</span>,</span><br><span class="line">  c: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> oo2 = &#123;</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> oo3 = &#123;</span><br><span class="line">  c: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj5 = <span class="built_in">Object</span>.assign(&#123;&#125;, oo1, oo2, oo3);</span><br><span class="line"><span class="built_in">console</span>.log(obj5); <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;</span></span><br></pre></td></tr></table></figure><p>拷贝 symbol 类型的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> v1 = &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> v2 = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)]: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj6 = <span class="built_in">Object</span>.assign(&#123;&#125;, v1, v2);</span><br><span class="line"><span class="built_in">console</span>.log(obj6); <span class="comment">// &#123; a : 1, Symbol(&quot;foo&quot;): 2 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(obj6)); <span class="comment">// [Symbol(foo)]</span></span><br></pre></td></tr></table></figure><p>继承属性和不可枚举属性是不能拷贝的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj7 = <span class="built_in">Object</span>.create(&#123;</span><br><span class="line">    foo: <span class="number">1</span></span><br><span class="line">&#125;, &#123; <span class="comment">// foo 是个继承属性。</span></span><br><span class="line">    bar: &#123;</span><br><span class="line">        value: <span class="number">2</span> <span class="comment">// bar 是个不可枚举属性。</span></span><br><span class="line">    &#125;,</span><br><span class="line">    baz: &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        enumerable: <span class="literal">true</span> <span class="comment">// baz 是个自身可枚举属性。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> copy = <span class="built_in">Object</span>.assign(&#123;&#125;, obj7);</span><br><span class="line"><span class="built_in">console</span>.log(copy); <span class="comment">// &#123; baz: 3 &#125;</span></span><br></pre></td></tr></table></figure><p>原始类型会被包装为对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m1 = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> m2 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> m3 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> m4 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> res = <span class="built_in">Object</span>.assign(&#123;&#125;, m1, <span class="literal">null</span>, m2, <span class="literal">undefined</span>, m3, m4);</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//     0:&#x27;a&#x27;,</span></span><br><span class="line"><span class="comment">//     1:&#x27;b&#x27;,</span></span><br><span class="line"><span class="comment">//     2:&#x27;c&#x27;,</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> res) <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(res <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res1 = <span class="built_in">Object</span>.assign(<span class="literal">true</span>, <span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res1);</span><br><span class="line"><span class="comment">// Boolean&#123;</span></span><br><span class="line"><span class="comment">//     true,</span></span><br><span class="line"><span class="comment">//     0:&#x27;a&#x27;,</span></span><br><span class="line"><span class="comment">//     1:&#x27;b&#x27;,</span></span><br><span class="line"><span class="comment">//     2:&#x27;c&#x27;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> res1); <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(res1 <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res2 = <span class="built_in">Object</span>.assign(<span class="string">&#x27;abc&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res2);</span><br><span class="line"><span class="comment">// String&#123;</span></span><br><span class="line"><span class="comment">//     0:&#x27;a&#x27;,</span></span><br><span class="line"><span class="comment">//     1:&#x27;b&#x27;,</span></span><br><span class="line"><span class="comment">//     2:&#x27;c&#x27;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> res2); <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(res2 <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res3 = <span class="built_in">Object</span>.assign(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res3);</span><br><span class="line"><span class="comment">// Number&#123;10,0:&#x27;a&#x27;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> res3); <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(res3 <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>异常会打断后续拷贝任务</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetObj = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">&quot;foo&quot;</span>, &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  writable: <span class="literal">false</span></span><br><span class="line">&#125;); <span class="comment">// targetObj 的 foo 属性是个只读属性。</span></span><br><span class="line"><span class="built_in">Object</span>.assign(targetObj, &#123;<span class="attr">bar</span>: <span class="number">2</span>&#125;, &#123;<span class="attr">foo2</span>: <span class="number">3</span>, <span class="attr">foo</span>: <span class="number">3</span>, <span class="attr">foo3</span>: <span class="number">3</span>&#125;, &#123;<span class="attr">baz</span>: <span class="number">4</span>&#125;);<span class="comment">// TypeError: &quot;foo&quot; is read-only</span></span><br></pre></td></tr></table></figure><p>注意这个异常是在拷贝第二个源对象的第二个属性时发生的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// console.log(targetObj);//&#123;bar:2,foo2:3,foo:1&#125;</span></span><br><span class="line"><span class="comment">// console.log(targetObj.bar);  // 2，说明第一个源对象拷贝成功了。</span></span><br><span class="line"><span class="comment">// console.log(targetObj.foo2); // 3，说明第二个源对象的第一个属性也拷贝成功了。</span></span><br><span class="line"><span class="comment">// console.log(targetObj.foo);  // 1，只读属性不能被覆盖，所以第二个源对象的第二个属性拷贝失败了。</span></span><br><span class="line"><span class="comment">// console.log(targetObj.foo3); // undefined，异常之后 assign 方法就退出了，第三个属性是不会被拷贝到的。</span></span><br><span class="line"><span class="comment">// console.log(targetObj.baz);  // undefined，第三个源对象更是不会被拷贝到的。</span></span><br></pre></td></tr></table></figure><p>拷贝访问器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">bar</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)]: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> copy1 = <span class="built_in">Object</span>.assign(&#123;&#125;, o);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;assign&#x27;</span>,copy1); <span class="comment">//copy.bar的值来自obj.bar的getter函数的返回值 &#123;foo:1,bar:2&#125;</span></span><br><span class="line"><span class="comment">// assign&#123;</span></span><br><span class="line"><span class="comment">//     bar:2,</span></span><br><span class="line"><span class="comment">//     foo:1,</span></span><br><span class="line"><span class="comment">//     Symbol(foo):1</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript的reduce方法</title>
      <link href="/ZJY.github.io/2021/03/01/javascript%E7%9A%84reduce%E6%96%B9%E6%B3%95/"/>
      <url>/ZJY.github.io/2021/03/01/javascript%E7%9A%84reduce%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>reduce()方法接收一个函数作为累加器，数组中的每个值从左向右缩减，最终计算为一个值<br>reduce()作为空数组不会执行回调函数的。</p><p>语法:<br>reduce(function(total,currentValue,currentIndex,arr),initalValue);<br>参数：</p><ul><li>function(total,currentValue,currentIndex,arr)：必须，用于执行每个数组元素的函数<ul><li>total:必须，初始值或者用于计算后返回的函数值</li><li>currentValue:必须，当前值</li><li>currentIndex：可选，当前元素索引</li><li>arr: 可选，当前元素所属的数组对象</li></ul></li><li>initalValue:可选，传递给函数的初始值</li></ul><p>返回值：计算结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">total,num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> total + num</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//6</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript中this的指向</title>
      <link href="/ZJY.github.io/2021/03/01/javascript%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91/"/>
      <url>/ZJY.github.io/2021/03/01/javascript%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h2 id="javascript中this的指向"><a href="#javascript中this的指向" class="headerlink" title="javascript中this的指向"></a>javascript中this的指向</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xx</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">//window</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span> === <span class="built_in">window</span>); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line">xx();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> yy = &#123;</span><br><span class="line">  a:<span class="string">&#x27;zjy&#x27;</span>,</span><br><span class="line">  b:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//yy</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span> === yy);<span class="comment">//true</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">bb</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//window</span></span><br><span class="line">      &#125;</span><br><span class="line">      bb();<span class="comment">//bb只是在yy的属性b中执行，并不是b的属性，属于window</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">yy.b();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    s:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = o.s;</span><br><span class="line">f();<span class="comment">//this指向window,js中函数是按引用传递的</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xx3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.x = <span class="number">333</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">//xx3:&#123;x: 333&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.__proto__==xx3.prototype);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> xx3();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dom事件级别</title>
      <link href="/ZJY.github.io/2021/03/01/dom%E4%BA%8B%E4%BB%B6%E7%BA%A7%E5%88%AB/"/>
      <url>/ZJY.github.io/2021/03/01/dom%E4%BA%8B%E4%BB%B6%E7%BA%A7%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="DOM事件级别"><a href="#DOM事件级别" class="headerlink" title="DOM事件级别"></a>DOM事件级别</h2><p>DOM级别一共可以分为四个级别：DOM0级、DOM1级、DOM2级和DOM3级。而DOM事件分为3个级别：DOM 0级事件处理，DOM 2级事件处理和DOM 3级事件处理。由于DOM 1级中没有事件的相关内容，所以没有DOM 1级事件</p><h2 id="dom0级事件"><a href="#dom0级事件" class="headerlink" title="dom0级事件"></a>dom0级事件</h2><p>使用DOM0方式为事件程序赋值时，所赋函数被视为元素的方法。因此，事件处理程序会在元素的作用域运行，即this等于元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;btn1&quot;</span>  /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn1&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.id)l <span class="comment">//&quot;btn1&quot;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;click me: dom0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn1&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;click me: dom0-111&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击btn1时，输出’click me: dom0-111’，dom0只支持给一个事件添加一个处理程序.dom0级事件处理程序在元素的作用域运行。通过设置btn.onclick = null;可移除事件处理程序。</p><h2 id="dom2级事件"><a href="#dom2级事件" class="headerlink" title="dom2级事件"></a>dom2级事件</h2><p>el.addEventListener(event-name, callback, useCapture);<br>事件名，事件处理函数，布尔值（false默认值，冒泡阶段调用事件处理函数，true：捕获阶段调用事件处理函数）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn1&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;click me: addEventListener111&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn1&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;click me: addEventListener222&#x27;</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>点击btn1，依次输出：<br>click me: addEventListener111<br>click me: addEventListener222</p><p>用addEventListener函数添加的事件必须用removeEventListener()函数移除，且传参数一致。这意味着使用addEventListener添加的匿名函数无法移除，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn1&#x27;</span>);</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;click me: addEventListener111&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//没有效果</span></span><br><span class="line">btn.removeEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;click me: addEventListener111&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>传给removeEventListener()的事件处理函数必须与传给addEventListener()的是同一个，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn1&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);</span><br><span class="line">&#125;</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>,handler,<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//没有效果</span></span><br><span class="line">btn.removeEventListener(<span class="string">&#x27;click&#x27;</span>,handler,<span class="literal">false</span>);<span class="comment">//有效果</span></span><br></pre></td></tr></table></figure><p><b>IE事件处理程序</b><br>attachEvent()和detachEvent()接收同样的参数：事件处理程序的名字和事件处理函数。因为IE8及更早版本只支持冒泡，所以使用attachEvent添加的事件处理程序只会添加到冒泡阶段。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn1&#x27;</span>);</span><br><span class="line">btn.attachEvent(<span class="string">&quot;onclick&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;clicked&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">btn.attachEvent(<span class="string">&quot;onclick&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>attachEvent()的第一个参数是”onclick”而不是“click”</p><p>事件触发是反向触发，先打印“hello world“再打印”clicked”.</p><p>使用detachEvent()来移除事件处理程序，只要提供和attachEvent相同的参数。</p><p>作为事件处理程序添加的匿名函数也无法移除。</p><p>且attachEvent()添加事件处理程序是在全局作用域运行的。因此this === window</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.attachEvent(<span class="string">&quot;onclick&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span> === <span class="built_in">window</span>); <span class="comment">//true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="dom3级事件：在dom2级事件基础上添加了更多的事件类型。"><a href="#dom3级事件：在dom2级事件基础上添加了更多的事件类型。" class="headerlink" title="dom3级事件：在dom2级事件基础上添加了更多的事件类型。"></a>dom3级事件：在dom2级事件基础上添加了更多的事件类型。</h2><p>UI事件:当用户与页面上元素交互时触发,比如:load,scroll,<br>焦点事件:当元素获得或失去焦点时触发,比如:blur,focus,<br>鼠标事件:当用户通过鼠标在页面执行操作时触发如：dblclick、mouseup,<br>滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel<br>文本事件，当在文档中输入文本时触发，如：textInput<br>键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress<br>合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart<br>变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified<br>同时DOM3级事件也允许使用者自定义一些事件</p><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>event对象是传递给事件处理程序的唯一参数，不管以那种方式指定事件处理程序。</p><p>event.type:执行事件的类型<br>event.eventPhase:用于确定事件流当前所处的阶段。1:捕获阶段被调用  2:目标阶段被调用  3:冒泡阶段被调用。</p><p>在IE中，dom事件对象如果是使用dom0方式指定的，event对象只是window对象的一个属性:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn1&#x27;</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> event = <span class="built_in">window</span>.event;</span><br><span class="line">  <span class="built_in">console</span>.log(event.type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是attachEvent指定的事件处理程序，event对象仍然是window对新的属性，但是出于方便也将其作为参数传入。</p><h2 id="DOM事件模型和事件流"><a href="#DOM事件模型和事件流" class="headerlink" title="DOM事件模型和事件流"></a>DOM事件模型和事件流</h2><p>DOM事件模型分为捕获和冒泡。一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段</p><p>1.捕获阶段：事件从window对象自上而下向目标节点传播的阶段<br>2.目标阶段：真正的目标节点正在处理事件的阶段<br>3.冒泡阶段：事件从目标节点自下而上向window对象传播的阶段</p><h2 id="事件代理（事件委托）"><a href="#事件代理（事件委托）" class="headerlink" title="事件代理（事件委托）"></a>事件代理（事件委托）</h2><p>由于事件会在冒泡阶段传播到父元素上，由父元素监听函数同时处理多个子节点的事件，称为事件代理。<br>优点：减少内存的消耗提高性能</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;list&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 兼容性处理</span></span><br><span class="line">  <span class="keyword">var</span> event = e || <span class="built_in">window</span>.event;</span><br><span class="line">  <span class="keyword">var</span> target = event.target || event.srcElement;</span><br><span class="line">  <span class="comment">// 判断是否匹配目标元素</span></span><br><span class="line">  <span class="keyword">if</span> (target.nodeName.toLocaleLowerCase() === <span class="string">&#x27;li&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;the content is: &#x27;</span>, target.innerHTML);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Event对象常见的应用"><a href="#Event对象常见的应用" class="headerlink" title="Event对象常见的应用"></a>Event对象常见的应用</h2><p>event.preventDefault();阻止默认事件的发生，比如链接跳转，表单提交<br>event.stopPropagation();阻止事件流在dom结构中传播，取消后续的事件捕获或冒泡。<br>event.stopImmediatePropagation();用于取消后续事件捕获或事件冒泡，并阻止调用任何后续事件处理程序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#btn1&#x27;</span>);</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;btn click 1&#x27;</span>);</span><br><span class="line">  event.stopImmediatePropagation();</span><br><span class="line">&#125;);</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;btn click 2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;body click&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>点击btn，输出’btn click 1’</p><h2 id="event-amp-currentTarget"><a href="#event-amp-currentTarget" class="headerlink" title="event &amp; currentTarget"></a>event &amp; currentTarget</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;b&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;c&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;d&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;a&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;target: &#x27;</span>+ e.target.id+<span class="string">&#x27; &amp;curretTarget: &#x27;</span>+e.currentTarget.id)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;b&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;target: &#x27;</span>+ e.target.id+<span class="string">&#x27; &amp;curretTarget: &#x27;</span>+e.currentTarget.id)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;c&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;target: &#x27;</span>+ e.target.id+<span class="string">&#x27; &amp;curretTarget: &#x27;</span>+e.currentTarget.id)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;d&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;target: &#x27;</span>+ e.target.id+<span class="string">&#x27; &amp;curretTarget: &#x27;</span>+e.currentTarget.id)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>点击d元素，依次输出：<br>target: d &amp;curretTarget: d<br>target: d &amp;curretTarget: c<br>target: d &amp;curretTarget: b<br>target: d &amp;curretTarget: a</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript的双向绑定</title>
      <link href="/ZJY.github.io/2021/02/28/javascript%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
      <url>/ZJY.github.io/2021/02/28/javascript%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<p>实现双向绑定方式：</p><ul><li>1.javascript的get、set方法</li><li>2.Object.defineProperty</li><li>3.es6的proxy</li></ul><h2 id="JavaScript的get-set方法"><a href="#JavaScript的get-set方法" class="headerlink" title="JavaScript的get,set方法"></a>JavaScript的get,set方法</h2><p>在创建新对象初始化时定义一个getter<br>get语法将对象属性绑定到查询该属性时将调用的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  _t:<span class="string">&#x27;zjy&#x27;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">fn</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._t;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title">fn</span>(<span class="params">_x</span>)&#123;</span><br><span class="line">    <span class="built_in">this</span>._t = _x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.fn); <span class="comment">//zjy</span></span><br><span class="line"><span class="built_in">console</span>.log(obj._t); <span class="comment">//zjy</span></span><br><span class="line">obj.fn = <span class="string">&#x27;hahaha&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.fn); <span class="comment">//hahaha</span></span><br><span class="line"><span class="built_in">console</span>.log(obj._t); <span class="comment">//hahaha</span></span><br></pre></td></tr></table></figure><p>使用delete操作符删除getter</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> obj.fn; <span class="comment">//true</span></span><br><span class="line">obj.fn; <span class="comment">//undefined</span></span><br><span class="line">obj._t; <span class="comment">//hahaha</span></span><br></pre></td></tr></table></figure><h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h2><p>使用defineProperty在现有对象上定义getter<br>要随时在现有对象上添加getter，使用Object.defineProperty</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;b&#x27;</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.a + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj.a); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.b); <span class="comment">//2</span></span><br><span class="line">obj.a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.b); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">obj.b = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.b); <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>使用计算出的属性名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expr = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  get [expr]() &#123; <span class="keyword">return</span> <span class="string">&#x27;bar&#x27;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.foo); <span class="comment">//bar</span></span><br></pre></td></tr></table></figure><h3 id="get-vs-defineProperty"><a href="#get-vs-defineProperty" class="headerlink" title="get vs. defineProperty"></a>get vs. defineProperty</h3><p>1.当使用 get 关键字时，它和Object.defineProperty() 有类似的效果，在classes中使用时，二者有细微的差别。</p><p>2.当使用 get 关键字时，属性将被定义在实例的原型上，当使用Object.defineProperty()时，属性将被定义在实例自身上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">hello</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> exa = <span class="keyword">new</span> Example();</span><br><span class="line"><span class="built_in">console</span>.log(exa.hello);<span class="comment">//world</span></span><br></pre></td></tr></table></figure><p>Object.getOwnPropertyDescriptor(obj,property)方法返回指定对象上一个自有属性对应的属性描述符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(exa,<span class="string">&#x27;hello&#x27;</span>); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(getPropertyOf(exa),<span class="string">&#x27;hello&#x27;</span>); <span class="comment">//&#123; configurable: true, enumerable: false, get:funciton, set:undefined&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">&#x27;aaa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">//&#123; configurable: true, enumerable: true, value: &quot;aaa&quot;, writable: true&#125;</span></span><br></pre></td></tr></table></figure><p>语法：Object.getOwnPropertyDescriptor(obj,prop)<br>参数：</p><ul><li>1.obj:需要查找的对象</li><li>2.prop:目标对象内属性名称</li><li>3.返回值：如果指定的属性存在对象上，则返回其属性描述符对象。否则返回undefined</li><li>4.描述：该方法允许对一个属性的描述进行检索。属性描述符由以下组成：<ul><li>value：该属性的值（仅针对数据属性描述符有效）</li><li>writable：当且仅当该属性值可修改时为true（仅数据描述符有效）</li><li>get: 获取该属性的访问器函数，如果没有访问器，则该值为undefined（仅针对包含访问器或设置器的属性描述符有效）</li><li>set: 获取该属性的设置器函数，如果没有设置器，则该值为undefined（仅针对包含访问器或设置器的属性描述符有效）</li><li>configurable: 当且仅当对象属性描述可以被改变或者该属性可以被删除时，该值为true</li><li>enumerble: 当且仅当属性可枚举时，该值为true</li></ul></li></ul><p>访问器属性描述符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">foo</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">17</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj,<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line"><span class="comment">//&#123; enumerable: true, configurable: true, get:f foo(), set:undefined&#125;</span></span><br></pre></td></tr></table></figure><p>数据属性描述符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo:<span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj,<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line"><span class="comment">//&#123; writable: true, value:&#x27;bar&#x27;, configurable: true, enumerable:true&#125;</span></span><br></pre></td></tr></table></figure><p>使用Object.defineProperty(obj,prop)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;foo&#x27;</span>,&#123;</span><br><span class="line">    value: <span class="number">12</span>,</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    enumerable:<span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(o,<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line"><span class="comment">// &#123;value: 12, writable: false, enumerable: false, configurable: false&#125;</span></span><br></pre></td></tr></table></figure><p>Object.defineProperty()方法会直接在一个对象上定义一个新的属性，或者修改一个对象的现有属性，并返回此对象。<br>备注：应当直接在 Object 构造器对象上调用此方法，而不是在任意一个 Object 类型的实例上调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj1,<span class="string">&#x27;property1&#x27;</span>,&#123;</span><br><span class="line">    value:<span class="number">44</span>,</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line">obj1.property1 = <span class="number">77</span>;<span class="comment">//// throws an error in strict mode</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.property1); <span class="comment">//44</span></span><br></pre></td></tr></table></figure><p>语法：Object.defineProperty(obj,prop,desc)<br>参数：</p><ul><li>obj: 要定义属性的对象</li><li>prop: 要定义或要修改的属性名称或Symbol</li><li>desc：要定义或要修改的属性描述符</li></ul><p>返回值：被传递给函数的对象<br>描述：该方法允许精确的添加或修改对象的属性。通过赋值操作添加的普通属性都是可枚举的（例：var obj = {a:’a’}）.可通过for…in或Object.keys枚举到。可以修改这些属性的值，也可以删除属性。</p><p>默认情况下，通过Object.defineProperty方法添加的属性是不可修改的。<br>对象里目前存在2种类型的描述符：</p><ul><li>数据描述符：具有值的属性，该值可被修改也可以不能被修改</li><li>存取描述符：由getter或者setter函数所描述的属性</li></ul><p>一个描述符只能是2种描述符的一种，不能同时存在。他们共享以下可选健值（默认值是指在使用Object.defineProperty()定义属性时的默认值）：</p><ul><li>configurable: 当且仅当该值为true时，该属性的值可修改，属性也可以被删除</li><li>enumerable：当且仅当该值为true时，该属性可以被枚举</li></ul><p>数据描述符还具有以下可选健值：</p><ul><li>value：该属性对应的值，可以是任何任何js值，默认为undefined</li><li>writable: 当且仅当该值为true时，value的值才可被赋值运算修改，默认为false</li></ul><p>存取描述符还具有以下可选健值：</p><ul><li>get：属性的getter函数，如果没有，则为undefined，当访问该属性时，会调用该函数，执行时不传入任何参数，但是会默认传入this对象，由于继承关系，this不一定是该属性所属对象，该函数的返回值被用作属性的值默认为undefined</li><li>set：属性的setter函数，如果没有，则为undefined，当属性值被修改时，会调用该函数，该方法接受一个参数。默认把赋值时的this对象传入，默认值为undefined</li></ul><p>描述符汇总：<br>拥有布尔值的属性：writable,configurable,enumerable,默认值false<br>属性值和函数的键：value,get,set，默认值undefined</p><p>描述符可以拥有的健值：</p><table><thead><tr><th></th><th>enumerable</th><th>configurable</th><th>writable</th><th>value</th><th>get</th><th>set</th></tr></thead><tbody><tr><td>数据描述符</td><td>可以</td><td>可以</td><td>可以</td><td>可以</td><td>不可以</td><td>不可以</td></tr><tr><td>存取描述符</td><td>可以</td><td>可以</td><td>不可以</td><td>不可以</td><td>可以</td><td>可以</td></tr></tbody></table><p>如果一个描述符不具有value,writable，get，set中任意一个键,那么它将会被认为是一个数据描述符.</p><p>如果一个描述符同时拥有value或writable和get或set值,则会产生异常.</p><p>这些选项不一定是自身属性,也要考虑继承来的属性.</p><h3 id="创建属性："><a href="#创建属性：" class="headerlink" title="创建属性："></a>创建属性：</h3><p>如果对象中不存在指定的值,Object.defineProperty()会创建这个属性.当描述符中省略某些字段时,这些字段会使用默认值.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;<span class="comment">//创建一个新对象</span></span><br><span class="line"><span class="comment">//在对象中添加一个属性与属性描述符的示例</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&quot;a&quot;</span>,&#123;</span><br><span class="line">  value: <span class="number">37</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configuarable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o.a);</span><br><span class="line"><span class="comment">// 对象 o 拥有了属性 a，值为 37</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在对象中添加一个设置了存取描述符属性的示例</span></span><br><span class="line"><span class="keyword">var</span> bValue = <span class="number">38</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&quot;b&quot;</span>,&#123;</span><br><span class="line">  <span class="comment">//使用了方法名称缩写（ES2015特性）</span></span><br><span class="line">  <span class="comment">//下面两个缩写等价于：</span></span><br><span class="line">  <span class="comment">//get:function() &#123; return bValue&#125;,</span></span><br><span class="line">  <span class="comment">//set:function() &#123; return bValue;&#125;,</span></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;<span class="keyword">return</span> bValue;&#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123; bValue = newValue&#125;,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configuarable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line">o.b; <span class="comment">//38</span></span><br><span class="line"><span class="built_in">console</span>.log(o.b);</span><br><span class="line"><span class="comment">// 对象 o 拥有了属性 b，值为 38</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据描述符和存取描述符不能混合使用</span></span><br><span class="line"><span class="comment">// Object.defineProperty(o,&quot;conflict&quot;, &#123;</span></span><br><span class="line"><span class="comment">//   value: 0x9f91102,</span></span><br><span class="line"><span class="comment">//   get() &#123; return 0xdeadbeef&#125;</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br></pre></td></tr></table></figure><h3 id="修改属性："><a href="#修改属性：" class="headerlink" title="修改属性："></a>修改属性：</h3><p>如果属性已经存在，Object.defineProperty将尝试根据描述符中的值以及对象当前配置来修改这个属性。<br>如果旧属性将configurable值设置false，则该属性不可被配置，其他属性不可修改（除来单向将writable设置为false）<br>当试图改变不可配置属性的值时,除了value和writable属性之外,会抛出typeerror,除非当前值和新值相同.</p><h3 id="writable属性："><a href="#writable属性：" class="headerlink" title="writable属性："></a>writable属性：</h3><p>当writable属性设置为false时,该属性不可写,不能重新被赋值.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">    value: <span class="number">37</span>,</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">//37</span></span><br><span class="line">o.a = <span class="number">25</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">//37</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;b&#x27;</span>,&#123;</span><br><span class="line">      value: <span class="number">2</span>,</span><br><span class="line">      writable: <span class="literal">false</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// o.b = 3; //throws typeerror: &quot;b&quot; is read-only</span></span><br><span class="line">  <span class="keyword">return</span> o.b;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><h3 id="enumerable属性"><a href="#enumerable属性" class="headerlink" title="enumerable属性"></a>enumerable属性</h3><p>enumerable属性定义了对象的属性是否可以被for…in或Object.keys所枚举</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">&quot;a&quot;</span>, &#123; <span class="attr">value</span> : <span class="number">1</span>, <span class="attr">enumerable</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">&quot;b&quot;</span>, &#123; <span class="attr">value</span> : <span class="number">2</span>, <span class="attr">enumerable</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">&quot;c&quot;</span>, &#123; <span class="attr">value</span> : <span class="number">3</span> &#125;); <span class="comment">// enumerable 默认为 false</span></span><br><span class="line">o.d = <span class="number">4</span>; <span class="comment">// 如果使用直接赋值的方式创建对象的属性，则 enumerable 为 true</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="built_in">Symbol</span>.for(<span class="string">&#x27;e&#x27;</span>), &#123;</span><br><span class="line">  value: <span class="number">5</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="built_in">Symbol</span>.for(<span class="string">&#x27;f&#x27;</span>), &#123;</span><br><span class="line">  value: <span class="number">6</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> o)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);<span class="comment">// a,d</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Object</span>.keys(o)); <span class="comment">//[&quot;a&quot;,&quot;d&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(o.propertyIsEnumerable(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(o.propertyIsEnumerable(<span class="string">&#x27;b&#x27;</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(o.propertyIsEnumerable(<span class="string">&#x27;c&#x27;</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(o.propertyIsEnumerable(<span class="string">&#x27;d&#x27;</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(o.propertyIsEnumerable(<span class="built_in">Symbol</span>.for(<span class="string">&#x27;e&#x27;</span>)));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(o.propertyIsEnumerable(<span class="built_in">Symbol</span>.for(<span class="string">&#x27;f&#x27;</span>)));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(o);</span><br><span class="line"><span class="keyword">var</span> p = &#123; ...o&#125;</span><br><span class="line"><span class="built_in">console</span>.log(p.a);<span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(p.b);<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(p.c);<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(p.d);<span class="comment">//4</span></span><br><span class="line"><span class="built_in">console</span>.log(p[<span class="built_in">Symbol</span>.for(<span class="string">&#x27;e&#x27;</span>)]);<span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(p[<span class="built_in">Symbol</span>.for(<span class="string">&#x27;f&#x27;</span>)]);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><h3 id="configurable属性"><a href="#configurable属性" class="headerlink" title="configurable属性"></a>configurable属性</h3><p>configurable属性定义了该属性是否可被删除，以及除value和writable属性外属性是否可以被修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">   <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> <span class="number">1</span>;&#125;,</span><br><span class="line">   configuarable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">    configuarable: <span class="literal">true</span></span><br><span class="line">&#125;);<span class="comment">//typeerror:Cannot redefine property &#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">&#125;);<span class="comment">//typeerror:Cannot redefine property &#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;);<span class="comment">//typeerror:Cannot redefine property &#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">&#125;);<span class="comment">//typeerror:Cannot redefine property &#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">    value: <span class="number">12</span></span><br><span class="line">&#125;);<span class="comment">//typeerror:Cannot redefine property &#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">//1</span></span><br><span class="line"><span class="keyword">delete</span> o.a;<span class="comment">//false Nothing happens</span></span><br><span class="line"><span class="built_in">console</span>.log(o.a);<span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>如果 o.a 的 configurable 属性为 true，则不会抛出任何错误，并且，最后，该属性会被删除</p><p>添加多个属性和默认值：<br>考虑特性被赋予的默认特性值非常重要,通常,使用点运算符和Object.defineProperty()为对象的属性赋值时,<br>数据描述符中的属性默认值是不同的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">o.a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(o,<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line"><span class="comment">// a &#123;</span></span><br><span class="line"><span class="comment">//     configurable: true</span></span><br><span class="line"><span class="comment">//     enumerable: true</span></span><br><span class="line"><span class="comment">//     value: 1</span></span><br><span class="line"><span class="comment">//     writable: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 等同于:</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">   value:<span class="number">1</span>,</span><br><span class="line">   writable: <span class="literal">true</span>,</span><br><span class="line">   configurable: <span class="literal">true</span>,</span><br><span class="line">   enumerable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//另一方面：</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;b&#x27;</span>,&#123;<span class="attr">value</span>:<span class="number">1</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(o,<span class="string">&#x27;b&#x27;</span>));</span><br><span class="line"><span class="comment">// b&#123;</span></span><br><span class="line"><span class="comment">//     configurable: false</span></span><br><span class="line"><span class="comment">//     enumerable: false</span></span><br><span class="line"><span class="comment">//     value: 1</span></span><br><span class="line"><span class="comment">//     writable: false</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 等同于:</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;b&#x27;</span>, &#123;</span><br><span class="line">   value:<span class="number">1</span>,</span><br><span class="line">   configurable:<span class="literal">false</span>,</span><br><span class="line">   enumerable: <span class="literal">false</span>,</span><br><span class="line">   writable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="自定义setters和getters："><a href="#自定义setters和getters：" class="headerlink" title="自定义setters和getters："></a>自定义setters和getters：</h3><p>下面的例子展示了如何实现一个自存档对象。当设置temperature 属性时，archive 数组会收到日志条目</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Archiver</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> temperature = <span class="literal">null</span>;</span><br><span class="line"> <span class="keyword">var</span> archive = [];</span><br><span class="line"></span><br><span class="line"> <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>, <span class="string">&#x27;temperature&#x27;</span>, &#123;</span><br><span class="line">   get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;get!&#x27;</span>);</span><br><span class="line">     <span class="keyword">return</span> temperature;</span><br><span class="line">   &#125;,</span><br><span class="line">   set: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">     temperature = value;</span><br><span class="line">     archive.push(&#123; <span class="attr">val</span>: temperature &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">this</span>.getArchive = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> archive; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arc = <span class="keyword">new</span> Archiver();</span><br><span class="line">arc.temperature; <span class="comment">// &#x27;get!&#x27;</span></span><br><span class="line">arc.temperature = <span class="number">11</span>;</span><br><span class="line">arc.temperature = <span class="number">13</span>;</span><br><span class="line">arc.getArchive(); <span class="comment">// [&#123; val: 11 &#125;, &#123; val: 13 &#125;]</span></span><br></pre></td></tr></table></figure><p>下面这个例子中，getter 总是会返回一个相同的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = &#123;</span><br><span class="line"> get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&#x27;I alway return this string,whatever you have assigned&#x27;</span>;</span><br><span class="line"> &#125;,</span><br><span class="line"> set: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">this</span>.myname = <span class="string">&#x27;this is my name string&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TestDefineSetAndGet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>, <span class="string">&#x27;myproperty&#x27;</span>, pattern);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> TestDefineSetAndGet();</span><br><span class="line">instance.myproperty = <span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#x27;I alway return this string,whatever you have assigned&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.myproperty);</span><br><span class="line"><span class="comment">// &#x27;this is my name string&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.myname);</span><br></pre></td></tr></table></figure><h3 id="继承属性"><a href="#继承属性" class="headerlink" title="继承属性"></a>继承属性</h3><p>如果访问者的属性是被继承的，它的 get 和 set 方法会在子对象的属性被访问或者修改时被调用。<br>如果这些方法用一个变量存值，该值会被所有对象共享。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myclass</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> value ;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myclass.prototype,<span class="string">&quot;x&quot;</span>,&#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">x</span>)</span> &#123;</span><br><span class="line">        value = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> myclass();</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> myclass();</span><br><span class="line">a.x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b.x);<span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>这可以通过将值存储在另一个属性中解决。在 get 和 set 方法中，this 指向某个被访问和修改属性的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myclass</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myclass.prototype,<span class="string">&quot;x&quot;</span>,&#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.stored_x;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">x</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stored_x = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> myclass();</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> myclass();</span><br><span class="line">a.x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.x);<span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(b.x);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>不像访问者属性，值属性始终在对象自身上设置，而不是一个原型。然而，如果一个不可写的属性被继承，它仍然可以防止修改对象的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myclass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myclass.prototype.x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myclass.prototype, <span class="string">&quot;y&quot;</span>, &#123;</span><br><span class="line"> writable: <span class="literal">false</span>,</span><br><span class="line"> value: <span class="number">1</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> myclass();</span><br><span class="line">a.x = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.x); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(myclass.prototype.x); <span class="comment">// 1</span></span><br><span class="line">a.y = <span class="number">2</span>; <span class="comment">// Ignored, throws in strict mode </span></span><br><span class="line"><span class="built_in">console</span>.log(a.y); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(myclass.prototype.y); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS3新特性</title>
      <link href="/ZJY.github.io/2021/02/22/CSS3%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/ZJY.github.io/2021/02/22/CSS3%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="边框属性"><a href="#边框属性" class="headerlink" title="边框属性"></a>边框属性</h2><h2 id="border-image边框图片属性"><a href="#border-image边框图片属性" class="headerlink" title="border-image边框图片属性"></a>border-image边框图片属性</h2><p>border-image:none 100% 1 0 stretch; 默认值<br>border-image是一个简写，用于设置以下属性：</p><ul><li>border-image-source: 边框图片路径</li><li>border-image-slice: 图片边框向内偏移</li><li>border-image-width: 图片边框的宽度</li><li>border-image-outset: 边框图像区域超出边框的量</li><li>border-image-repeat: 图片边框是否平铺（repeated）,铺满（rounded）或拉伸（stretched）</li></ul><h2 id="border-radius边框圆角属性"><a href="#border-radius边框圆角属性" class="headerlink" title="border-radius边框圆角属性"></a>border-radius边框圆角属性</h2><p>border-radius: 0; 默认值<br>border-radius是一个简写，用于设置以下属性：</p><ul><li>border-top-left-radius: 左上角圆角属性</li><li>border-top-right-radius: 右上角圆角属性，若省略则取top-left的值</li><li>border-bottom-left-radius: 左下角圆角属性，若省略则取top-right的值</li><li>border-bottom-right-radius: 右下角圆角属性，若省略则取top-left的值</li></ul><p>以上属性值可取2种值：</p><ul><li>length: 具体的值,比如2px,2em等</li><li>%: 百分比</li></ul><h2 id="box-shadow边框阴影属性"><a href="#box-shadow边框阴影属性" class="headerlink" title="box-shadow边框阴影属性"></a>box-shadow边框阴影属性</h2><p>box-shadow属性向边框添加一个或多个阴影，是由逗号分隔的阴影列表，每个阴影由2-4个长度值、可选的颜色以及可选的inset关键词来规定。省略长度的值是0.</p><p>box-shadow属性值：</p><ul><li>h-shadow: 必需，水平阴影的位置，允许负值</li><li>v-shadow：必需，垂直阴影的位置，允许负值</li><li>blur： 可选，模糊距离</li><li>spread：可选，阴影的尺寸</li><li>color：可选，阴影的颜色</li><li>inset：可选，将外部阴影设置为内部阴影</li></ul><h2 id="背景属性"><a href="#背景属性" class="headerlink" title="背景属性"></a>背景属性</h2><h2 id="background-image多背景图片属性"><a href="#background-image多背景图片属性" class="headerlink" title="background-image多背景图片属性"></a>background-image多背景图片属性</h2><p>background-image:url(bg_flower.gif),url(bg_flower_2.gif);</p><h2 id="background-clip背景的绘制区域"><a href="#background-clip背景的绘制区域" class="headerlink" title="background-clip背景的绘制区域"></a>background-clip背景的绘制区域</h2><p>background-clip 属性规定背景的绘制区域</p><p>background-clip属性可选值：</p><ul><li>border-box：默认值，图片被剪裁到边框盒</li><li>padding-box: 图片被剪裁到内边距框</li><li>content-box: 图片被剪裁到内容框</li></ul><h2 id="background-origin规定背景图片的定位区域"><a href="#background-origin规定背景图片的定位区域" class="headerlink" title="background-origin规定背景图片的定位区域"></a>background-origin规定背景图片的定位区域</h2><p>background-origin属性规定background-position属性相对于什么位置来定位。<br>如果background-attachment属性设置为“fixed”，该属性无效。</p><p>background-origin属性值：</p><ul><li>padding-box: 默认值，背景图片相对于内边距框来定位</li><li>border-box: 背景图片相对于边框盒来定位</li><li>content-box: 背景图片相对于内容框来定位</li></ul><h2 id="background-size规定背景图片的尺寸"><a href="#background-size规定背景图片的尺寸" class="headerlink" title="background-size规定背景图片的尺寸"></a>background-size规定背景图片的尺寸</h2><p>background-size 属性规定背景图像的尺寸</p><p>background-size: auto;默认值</p><p>background-size取值四种方式：</p><ul><li>length：设置宽度和高度，第一个设置宽度，第二个值设置高度，如果只设置一个值，第二个值会被设置为”auto”.</li><li>%:百分比设置宽度和高度，相对于父元素的宽高设置，第一个设置宽度，第二个值设置高度，如果只设置一个值，第二个值会被设置为”auto”.</li><li>cover：把背景图片扩展至足够大，以使背景图像完全覆盖背景区域</li><li>contain：把背景图片扩展至最大尺寸，以使其宽高完全适应内容区域</li></ul><h2 id="文本效果"><a href="#文本效果" class="headerlink" title="文本效果"></a>文本效果</h2><h2 id="text-shadow文本阴影"><a href="#text-shadow文本阴影" class="headerlink" title="text-shadow文本阴影"></a>text-shadow文本阴影</h2><p>text-shadow 属性向文本设置阴影。<br>text-shadow: none;默认值</p><p>text-shadow属性包含下列值：</p><ul><li>h-shadow: 必需，水平阴影的位置，允许负值</li><li>v-shadow: 必需，垂直阴影的位置，允许负值</li><li>blur: 可选，模糊的距离</li><li>color: 可选，阴影的颜色</li></ul><h2 id="word-wrap属性"><a href="#word-wrap属性" class="headerlink" title="word-wrap属性"></a>word-wrap属性</h2><p>word-wrap属性允许长单词或 URL 地址换行到下一行。</p><p>word-wrap:normal;默认值</p><ul><li>break-word：允许长单词或url地址换到下一行</li><li>normal: 只在允许的断字点换行（浏览器保持默认处理）</li></ul><h2 id="word-break属性规定自动换行的处理方法"><a href="#word-break属性规定自动换行的处理方法" class="headerlink" title="word-break属性规定自动换行的处理方法"></a>word-break属性规定自动换行的处理方法</h2><p>word-break: noraml默认值</p><ul><li>noraml:浏览器默认换行规则</li><li>break-all: 允许在单词内换行</li><li>keep-all： 只允许在半角空格或连字符处换行</li></ul><h2 id="transform属性"><a href="#transform属性" class="headerlink" title="transform属性"></a>transform属性</h2><p>transform属性向元素应用2D或3D属性。该属性允许元素进行旋转、缩放、倾斜、移动</p><p>transform:none/transform-function,none为默认值</p><p>transform值可以是以下方法：</p><ul><li>none：不进行任何转换</li><li>matrix(n,n,n,n,n,n):定义2D转换，使用六个值的矩阵</li><li>matrix3d(n,…n):定义3D转换，使用16个值的矩阵</li><li>translate(x,y):定义2D转换</li><li>translate3d(x,y,z): 定义3D转换</li><li>translateX(x): 定义转换，只是用 X 轴的值。</li><li>translateY(y): 定义转换，只是用 Y 轴的值。</li><li>translateZ(z): 定义转换，只是用 Z 轴的值。</li><li>scale(x,y): 定义2D缩放转换</li><li>scale3d(x,y,z): 定义3D缩放转换</li><li>scaleX(x): 通过设置 X 轴的值来定义缩放转换。</li><li>scaleY(y): 通过设置 Y 轴的值来定义缩放转换。</li><li>scaleZ(z): 通过设置 Z 轴的值来定义缩放转换。</li><li>rotate(angle): 定义 2D 旋转，在参数中规定角度</li><li>rotate(x,y,angle): 定义3D旋转</li><li>rotateX(angle): 定义沿着 X 轴的 3D 旋转</li><li>rotatezY(angle): 定义沿着 Y 轴的 3D 旋转</li><li>rotateZ(angle): 定义沿着 Z 轴的 3D 旋转</li><li>skew(x-angle,y-angle): 定义沿着x轴和y轴倾斜转换</li><li>skewX(angle): 定义沿着X轴的2D倾斜转换</li><li>skewY(angle):定义沿着y轴的2D倾斜转换</li></ul><h2 id="transition过渡属性"><a href="#transition过渡属性" class="headerlink" title="transition过渡属性"></a>transition过渡属性</h2><p>transition过渡是元素从一种样式逐渐改变为另一种效果，需要规定2项内容：</p><ul><li>规定希望效果作用到元素哪个属性上</li><li>规定效果的时长</li></ul><p>transition是简写属性，包含以下转换属性：</p><ul><li>transition-property:规定应用过渡的css属性名称，取值：none/property/all</li><li>transition-duration:规定应用过渡时长，默认值0，以秒或毫秒计</li><li>transition-timing-function: 规定过渡效果的曲线，默认值是ease</li><li>transition-delay: 规定效果从何时开始，默认值是0</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">transition</span>: width <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">-moz-transition</span>: width <span class="number">2s</span>;<span class="comment">/* Firefox 4 */</span></span><br><span class="line">  <span class="attribute">-webkit-transition</span>: width <span class="number">2s</span>;<span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line">  <span class="attribute">-o-transition</span>: width <span class="number">2s</span>;<span class="comment">/* Opera */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="animation动画"><a href="#animation动画" class="headerlink" title="animation动画"></a>animation动画</h2><p>@keyframes规则用于创建动画</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> myFirst&#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在@keyframes创建动画后，需要将它绑定到某个选择器，需要以下2项css3动画属性，即可将动画绑定到选择器：</p><ul><li>规定动画的名称</li><li>规定动画的时长</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">animation</span>: myFirst <span class="number">5s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可用0%和100%代替from和to。</p><ul><li>@keyframes：创建动画</li><li>animation：动画属性简写</li><li>animation-name: 规定@keyframes动画的名称</li><li>animation-duration: 规定动画的一个周期所需时长，默认是0</li><li>animation-timing-function: 规定动画的曲线，默认是ease</li><li>animation-delay: 规定动画何时开始，默认是0</li><li>animation-iteration-count: 规定动画播放次数，默认是1，值可取n/infinate(无限播放)</li><li>animation-direction: 规定动画是否在下一周期逆向播放，默认是normal,取值normal/alternate</li><li>animation-play-state: 规定动画是正在运行还是暂停，默认值是running，取值running/paused</li><li>animation-fill-mode: 定对象动画时间之外的状态</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端开发常见面试问题及答案整理</title>
      <link href="/ZJY.github.io/2021/02/21/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%95%B4%E7%90%86/"/>
      <url>/ZJY.github.io/2021/02/21/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前端开发常见面试问题及答案整理"><a href="#前端开发常见面试问题及答案整理" class="headerlink" title="前端开发常见面试问题及答案整理"></a>前端开发常见面试问题及答案整理</h2><h2 id="闭包的理解"><a href="#闭包的理解" class="headerlink" title="闭包的理解"></a>闭包的理解</h2><p>闭包是为了设计私有方法和变量。<br>优点：避免全局变量的污染<br>缺点：闭包常驻内存，加大内存使用，使用不当容易造成内存泄漏</p><p>闭包的三大特性：</p><ul><li>函数嵌套函数</li><li>函数内部可以引用外部的参数和变量</li><li>参数和变量不会被垃圾回收机制回收</li></ul><h2 id="cookie的弊端"><a href="#cookie的弊端" class="headerlink" title="cookie的弊端"></a>cookie的弊端</h2><p>1.每个特定的域名下最多生成20个cookie，每个cookie长度不能超过4KB，否则会被截掉。<br>2.安全性问题。如果cookie被拦截，那就可以取到所有session信息，即使加密也于事无补，，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。</p><h2 id="浏览器本地存储"><a href="#浏览器本地存储" class="headerlink" title="浏览器本地存储"></a>浏览器本地存储</h2><p>html5中web storage包括了2种存储方式：sessionStorage和localStorage</p><ul><li>sessionStorage:用于存储本地的一个会话的数据，这些数据只能在同一个会话中的页面才能访问并且当会话结束后会随之销毁。所以sessionStorage不是一个持久化的的本地存储，仅仅是会话级别的存储。</li><li>localStorage：是持久化的本地存储，除非主动删除数据，否则永远不用过期。</li></ul><h3 id="web-storage和cookie的区别"><a href="#web-storage和cookie的区别" class="headerlink" title="web storage和cookie的区别"></a>web storage和cookie的区别</h3><p>web storage和cookie类似，区别是web storage是为了更大容量设计的。<br>cookie大小受限制；且每次打开新的页面，cookie都会被发送过去，无形中浪费带宽；且cookie不能跨域</p><p>web storage拥有setItem,getItem,removeItem,clear等方法，而cookie需要自己封装setCookie,getCookie</p><p>但cookie是不可或缺的：cookie的作用是与服务器进行交互，作为http的规范而存在，web storage仅仅是为了本地存储</p><p>localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem</p><h3 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h3><ul><li>cookie存放在客户端浏览器，session存放在服务器</li><li>cookie最大4kb，且每个站点最多20个cookie</li><li>cookie不是很安全，别人可以获取cookie进行cookie欺骗</li><li>session会在一定时间内存储在服务器，当访问量增大时，占用服务器的性能</li></ul><h2 id="css相关问题"><a href="#css相关问题" class="headerlink" title="css相关问题"></a>css相关问题</h2><h3 id="display-none-和-visibility-hidden"><a href="#display-none-和-visibility-hidden" class="headerlink" title="display:none 和 visibility:hidden"></a>display:none 和 visibility:hidden</h3><ul><li>display:none隐藏对应的元素,文档布局中不再分配空间，周边元素会当他不存在</li><li>visibility:hidden 隐藏元素，保留布局，占用空间。</li></ul><h3 id="css中link和-import的区别"><a href="#css中link和-import的区别" class="headerlink" title="css中link和@import的区别"></a>css中link和@import的区别</h3><ul><li>link是html标签，@import是css提供的</li><li>link是html标签无兼容问题，@import需ie5以上才兼容</li><li>页面加载时，link会被一起加载，而@import需要页面加载完后再加载</li><li>link引入样式权重高于@import权重</li></ul><h3 id="position-absolute和float的异同"><a href="#position-absolute和float的异同" class="headerlink" title="position:absolute和float的异同"></a>position:absolute和float的异同</h3><ul><li>相同点：对内联元素设置position:absolute和float都会使其脱离文档流，并可设置宽和高</li><li>不同点：设置position:absolute的元素会覆盖文档流中的其他元素，而float仍然占据位置。</li></ul><h3 id="box-sizing属性"><a href="#box-sizing属性" class="headerlink" title="box-sizing属性"></a>box-sizing属性</h3><p>box-sizing属性用来控制元素的盒模型解析模式，默认是content-box</p><ul><li>content-box: w3c标准盒模型，元素的宽高由padding+border+content决定，设置元素的width/height属性是指content的宽/高</li><li>border-box: IE怪异盒模型，设置元素的width/height属性是指content+padding+border</li></ul><p>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。</p><h3 id="CSS-选择符有哪些？"><a href="#CSS-选择符有哪些？" class="headerlink" title="CSS 选择符有哪些？"></a>CSS 选择符有哪些？</h3><ul><li>id选择器(#con)</li><li>class选择器(.con)</li><li>标签选择器(div/p)</li><li>相邻选择器(div + p)</li><li>子选择器(div &gt; p)</li><li>后代选择器(div p)</li><li>通配符选择器(*)</li><li>属性选择器（a[rel = “external”]）</li><li>伪类选择器(a:hover)</li></ul><h3 id="css哪些属性可以继承？"><a href="#css哪些属性可以继承？" class="headerlink" title="css哪些属性可以继承？"></a>css哪些属性可以继承？</h3><ul><li>可以继承属性：font-size, font-family,color,text-indent</li><li>不可以继承属性：width,height,border,padding,margin</li></ul><p>所有元素可继承：visibility/cursor<br>块元素可继承:text-align/text-indent<br>列表元素可继承：list-style,list-style-image,list-style-type<br>行内元素可继承：font,font-size,font-family,color,line-height,letter-spacing,word-spacing</p><h3 id="css优先级算法？"><a href="#css优先级算法？" class="headerlink" title="css优先级算法？"></a>css优先级算法？</h3><ul><li>优先级就近原则，同权重情况下样式定义最近者为准</li><li>载入样式以最后载入为准</li><li>!important &gt;  id &gt; class &gt; tag，important 比 内联优先级高,但内联比 id 要高</li></ul><h3 id="css3新增伪类有哪些？"><a href="#css3新增伪类有哪些？" class="headerlink" title="css3新增伪类有哪些？"></a>css3新增伪类有哪些？</h3><ul><li>p:first-of-type 选择属于其父元素的首个 <code>&lt;p&gt; </code>元素的每个<code> &lt;p&gt;</code> 元素。</li><li>p:last-of-type 选择属于其父元素的最后 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。</li><li>p:only-of-type 选择属于其父元素唯一的 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。</li><li>p:nth-child(2) 选择属于其父元素的第二个子元素的每个 <code>&lt;p&gt;</code> 元素。</li><li>p:only-child 选择属于其父元素的唯一子元素的每个 <code>&lt;p&gt;</code> 元素。</li><li>:enabled :disabled 控制表单控件的禁用状态。</li><li>:checked 单选框或复选框被选中。</li></ul><h3 id="position的值，分别相对于谁定位？"><a href="#position的值，分别相对于谁定位？" class="headerlink" title="position的值，分别相对于谁定位？"></a>position的值，分别相对于谁定位？</h3><ul><li>static： 默认值，没有定位，元素出现在正常文档流中。</li><li>relative：相对定位，相对于其在正常文档流中位置定位。</li><li>absolute： 绝对定位，相对于最近一级的定位不是staic的元素定位。</li><li>fixed： 绝对定位，相对于浏览器视窗定位。</li></ul><h3 id="css3有哪些新特性？"><a href="#css3有哪些新特性？" class="headerlink" title="css3有哪些新特性？"></a>css3有哪些新特性？</h3><ul><li>border-radius:圆角</li><li>border-image: 边框图片</li><li>box-shadow: 边框阴影</li><li>background-image: 多背景</li><li>background-clip: 背景图片绘制区域</li><li>background-origin: 背景图片的定位区域</li><li>text-shadow: 文本阴影</li><li>word-wrap:允许长单词或url换行到下一行</li><li>word-break: 设置自动换行的处理方法</li><li>transform: 旋转、缩放、移动、倾斜，2D或3D转换</li><li>animation: 使用@keyframes创建动画</li><li>transition: 设置元素过渡效果</li><li>column-count/gap/rule: 多列设置</li><li>::selection: 新增伪元素，设置选中高亮</li></ul><h3 id="XML和JSON的区别？"><a href="#XML和JSON的区别？" class="headerlink" title="XML和JSON的区别？"></a>XML和JSON的区别？</h3><ul><li>数据体积方面：JSON相对XML来说，数据体积小，传输速度更快</li><li>数据交互方面：JSON于js的交互更方便，更容易解析处理</li><li>数据描述方面：XML对数据的描述比JSON好</li><li>传输速度方面：JSON的传输速度要快于XML</li></ul><h3 id="对BFC的理解？"><a href="#对BFC的理解？" class="headerlink" title="对BFC的理解？"></a>对BFC的理解？</h3><p>BFC块级格式化上下文，是一个独立的渲染区域，内部元素不会影响外部元素定位，使内外元素相隔离</p><p>BFC布局规则：</p><ul><li>BFC是一个独立的区域，内外元素不互相影响</li><li>内部的box会在垂直方向，一个一个排列</li><li>box垂直方向的距离由margin决定，相邻的2个box间的margin会发生重叠</li><li>每个元素的margin box的左边与border box的左边相接触，即使浮动也如此</li><li>BFC区域不和浮动盒子相重叠</li><li>计算BFC高度时，float box也参与计算</li></ul><p>什么情况会形成BFC？</p><ul><li>根元素</li><li>position为absolute或fixed</li><li>浮动元素</li><li>display值为flex、inline-flex、inline-block、table-cell</li><li>overflow不为visible的元素</li></ul><h3 id="css-sprites-如何在网站使用？"><a href="#css-sprites-如何在网站使用？" class="headerlink" title="css sprites,如何在网站使用？"></a>css sprites,如何在网站使用？</h3><p>css sprites就是把网页中一些背景图片整合到一张图片中，利用”background-image”,”background-repeat”,”background-position”属性组合进行背景定位。”background-position”可以精准定位背景图片的位置。有效减少图片请求开销。</p><h2 id="html部分"><a href="#html部分" class="headerlink" title="html部分"></a>html部分</h2><h3 id="对语义化的理解？"><a href="#对语义化的理解？" class="headerlink" title="对语义化的理解？"></a>对语义化的理解？</h3><ul><li>样式丢失也能呈现出清晰的结构</li><li>有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓去更多信息</li><li>方便其他设备解析（屏幕阅读器、盲人阅读器）</li><li>便于团队开发和维护，语义化更具有可读性</li></ul><h3 id="Doctype的作用？严格模式和混杂模式区别？有何意义？"><a href="#Doctype的作用？严格模式和混杂模式区别？有何意义？" class="headerlink" title="Doctype的作用？严格模式和混杂模式区别？有何意义？"></a>Doctype的作用？严格模式和混杂模式区别？有何意义？</h3><ul><li><!DOCTYPE>声明位于文档最前面，告知浏览器以何种模式渲染文档</li><li>严格模式的排版和js运作模式是以浏览器支持的最高标准运行。</li><li>在混杂模式中以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。</li><li>DOCTYPE不存在或不正确会使浏览器以混杂模式呈现。</li></ul><h3 id="浮动工作原理？清除浮动的技巧？"><a href="#浮动工作原理？清除浮动的技巧？" class="headerlink" title="浮动工作原理？清除浮动的技巧？"></a>浮动工作原理？清除浮动的技巧？</h3><p>浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或浮动元素的边框停留。</p><p>清除浮动方式：</p><ul><li>使用空标签清除浮动：浮动标签后面添加一个空标签，定义css clear:both.弊端就是增加了无意义的标签</li><li>使用overflow：给包含浮动元素的父元素添加overflow:auto;zoom:1;zoom:1;兼容ie6</li><li>使用after伪对象清除浮动：只适用于非IE浏览器，该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素</li></ul><h3 id="浮动元素引起的问题和解决方案？"><a href="#浮动元素引起的问题和解决方案？" class="headerlink" title="浮动元素引起的问题和解决方案？"></a>浮动元素引起的问题和解决方案？</h3><ul><li>1.父元素的高度无法被撑开，影响与父元素同级的元素</li><li>2.与浮动元素同级的非浮动元素（内联元素）会跟随其后</li><li>3.若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面结构</li></ul><p>解决方法：<br>对于第二个第三个问题可用clear:both清除元素的浮动，对于第一个问题，给父元素添加clearfix样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">clear</span>:both;</span><br><span class="line">  <span class="attribute">visibility</span>:hidden;</span><br><span class="line">  <span class="attribute">display</span>:block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:inline-block; <span class="comment">/* for IE/Mac */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清除浮动的几种方式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1，额外标签法，&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;（缺点：不过这个办法会增加额外的标签使HTML结构看起来不够简洁。）</span><br><span class="line">2，使用<span class="selector-tag">after</span>伪类</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#parent</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">&quot;.&quot;</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">visibility</span>:hidden;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">clear</span>:both;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">3,浮动外部元素</span><br><span class="line">4,设置`<span class="selector-tag">overflow</span>`为`<span class="selector-tag">hidden</span>`或者<span class="selector-tag">auto</span></span><br></pre></td></tr></table></figure><h3 id="DOM操作——怎样添加、移除、移动、复制、创建和查找节点"><a href="#DOM操作——怎样添加、移除、移动、复制、创建和查找节点" class="headerlink" title="DOM操作——怎样添加、移除、移动、复制、创建和查找节点"></a>DOM操作——怎样添加、移除、移动、复制、创建和查找节点</h3><ul><li><p>创建</p><ul><li>createDocumentFragment() 创建一个Dom片段</li><li>createElement() 创建一个元素</li><li>createTextNode() 创建文本节点</li></ul></li><li><p>添加、移除、移动、复制</p><ul><li>appendChild() </li><li>removeChild()</li><li>replaceChild()</li><li>insertBefore()</li></ul></li><li><p>查找</p><ul><li>getElementsByTagName()</li><li>getElementById()</li><li>getElementsByClassName()</li></ul></li></ul><h3 id="html5有哪些新特性？"><a href="#html5有哪些新特性？" class="headerlink" title="html5有哪些新特性？"></a>html5有哪些新特性？</h3><ul><li>拖拽API</li><li>语义化更好的标签（header,section,article,footer,nav,aside）</li><li>音视频（audio/video）</li><li>canvas画布/svg</li><li>地理位置Geolocation</li><li>本地缓存：localStorage持久化缓存，sessionStorage会话级缓存</li><li>新的表单控件：calendar,date,time,url,search,email</li></ul><h3 id="常见浏览器兼容问题"><a href="#常见浏览器兼容问题" class="headerlink" title="常见浏览器兼容问题"></a>常见浏览器兼容问题</h3><ul><li>浏览器默认margin,padding值不同，需要添加全局*{margin:0;padding:0}</li><li>chrome浏览器设置字体小于12px，会默认为12px，解决方法：-webkit-text-size-adjust:none;</li><li>a标签超链接访问过后hover样式就不出现了，被访问过的链接不再具有hover和active，解决方法改变css属性的顺序：<br>L-V-H-A: a:link{} a:visited: a:hover a:active</li><li>怪异模式问题：漏写DTD声明时，火狐仍然按照标准模式来解析网页，但在IE中会触发怪异模式。</li></ul><h3 id="如何实现浏览器多个标签页之间通信？"><a href="#如何实现浏览器多个标签页之间通信？" class="headerlink" title="如何实现浏览器多个标签页之间通信？"></a>如何实现浏览器多个标签页之间通信？</h3><p>使用localStorage,cookies等本地存储方式</p><h3 id="进程和线程之间关系和区别？"><a href="#进程和线程之间关系和区别？" class="headerlink" title="进程和线程之间关系和区别？"></a>进程和线程之间关系和区别？</h3><ul><li><p>1.定义</p><ul><li>进程：是系统进行资源分配和调度的独立单位。</li><li>线程：线程是进程的一个实体，是cpu调度和分派的基本单位，是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，但是和进程内的其他线程共享进程拥有的全部资源。</li></ul></li><li><p>2.关系</p><ul><li>一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。</li><li>相对进程而言，线程更接近于执行体的概念，它可以与进程内的其他线程共享资源，但拥有自己的栈空间，拥有独立的执行序列</li></ul></li><li><p>3.区别<br>进程和线程的主要差别是他们是不同的操作系统资源的管理方式。进程拥有独立的地址空间，一个进程崩溃后，基于系统的保护程序，并不会影响其他进程，而线程只是进程中的不同执行路径。<br>线程拥有自己的堆栈和局部变量，但线程间没有单独的地址空间，一个线程死掉就相当于整个进程死掉，所以多进程的程序比多线程的程序更健壮，但在进程切换时，耗费资源较大，效率低一些。</p><ul><li>一个程序至少有一个进程，一个进程中至少有一个线程</li><li>线程的划分尺度低于进程，使得多线程的程序并发性高</li><li>进程在执行过程拥有独立的内存单元，而多个线程共享内存，从而极大的提高程序的运行效率</li><li>线程在执行过程中和进程还是有区别的。每个线程都有程序运行入口，顺序执行序列和程序的出口，但线程不能独立执行，必须依存于应用程序，由应用程序提供多个线程执行控制</li><li>从逻辑角度来看，多线程的意义在于应用程序中，有多个执行部分可以同时执行，但是操作系统并没有将多个线程看出多个独立的应用，来实现线程的调度和管理以及资源分配。这就是进程和线程的重要区别</li></ul></li><li><p>4.优缺点</p><ul><li>线程执行开销小，但不利于资源的管理和保护；而进程相反</li><li>线程适合于在SMP机器上运行，而进程则可以跨机器迁移。</li></ul></li></ul><h3 id="什么是FOUC？怎么解决？"><a href="#什么是FOUC？怎么解决？" class="headerlink" title="什么是FOUC？怎么解决？"></a>什么是FOUC？怎么解决？</h3><p>Flash Of Unstyled Content 文档式闪烁</p><ul><li>什么是FOUC(文档样式短暂失效)?<ul><li>如果使用import方法对CSS进行导入,会导致某些页面在Windows 下的Internet Explorer出现一些奇怪的现象:以无样式显示页面内容的瞬间闪烁,这种现象称之为文档样式短暂失效(Flash of Unstyled Content),简称为FOUC。</li></ul></li><li>造成原因：<ul><li>使用import引入css</li><li>将样式表放在页面底部</li><li>多个样式表放在html结构的不同位置<br>当样式表晚于页面html加载，当加载到此样式表时，页面将停止之前的渲染，等待文件的下载解析后将重新渲染页面，也就出现短暂页面闪烁</li></ul></li><li>解决方法：<ul><li>使用link标签将样式表放置与head中</li></ul></li></ul><h3 id="null和undefined的区别？"><a href="#null和undefined的区别？" class="headerlink" title="null和undefined的区别？"></a>null和undefined的区别？</h3><p>null是表示“无”的对象，转为数值为0，undefined是表示“无”的原始值，转为数值为NaN。</p><p>当声明的变量未初始化时，值为undefined。<br>null用来表示尚未存在的对象，常用来表示函数企图返回不存在的对象。</p><p>undefined:<br>1.变量被声明了，但没有赋值，该变量值为undefined<br>2.调用函数时，应该提供的参数没有提供，该参数值为undefined<br>3.未给对象的属性赋值时，该属性的值为undefined<br>4.函数没有返回值时，默认返回undefined</p><p>null：<br>1.作为函数的参数，表明该函数的参数不是对象<br>2.作为对象原型链的终点</p><h3 id="new-操作符具体做了什么？"><a href="#new-操作符具体做了什么？" class="headerlink" title="new 操作符具体做了什么？"></a>new 操作符具体做了什么？</h3><ul><li>1.创建新的空对象，并且this变量引用该对象，同时还继承了该函数的原型</li><li>2.属性和方法被加入到this引用的对象上</li><li>3.新创建的对象由this所引用，并隐式返回this</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.__proto__ = Base.prototype;</span><br><span class="line">Base.call(obj);</span><br></pre></td></tr></table></figure><h3 id="js延迟加载的几种方式？"><a href="#js延迟加载的几种方式？" class="headerlink" title="js延迟加载的几种方式？"></a>js延迟加载的几种方式？</h3><p>js延迟加载就是等页面加载完成后再加载js文件<br>js延迟加载有助于提高页面加载速度。<br>一般有以下几种方式：</p><ul><li><p>1.defer属性<br>html4为script标签添加了defer属性，表明脚本在执行时不会影响页面构造，也就是说脚本会延迟到整个页面都加载解析完毕再执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;script src=<span class="string">&quot;test.js&quot;</span> defer=<span class="string">&quot;defer&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><p>defer属性告诉浏览器立即下载，但延迟执行。虽然<code>&lt;script&gt;</code> 元素放在了<code>&lt;head&gt;</code>元素中，但包含的脚本会延迟到浏览器遇到<code>&lt;/html&gt;</code>标签后再执行。</p></li></ul><p>HTML5规范要求脚本按照它们出现的先后顺序执行</p><p>defer属性只适用于外部脚本文件</p><ul><li><p>2.async属性<br>html5为script标签定义了async属性，与defer属性类似。只适用于外部脚本。<br>目的：不让页面等待脚本下载和执行，从而异步加载页面其他内容<br>异步脚本一定会在onload事件前执行<br>不能保证脚本按照顺序执行</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;test1.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>async和defer一样，不会阻塞其他资源下载，不会影响页面加载<br>缺点：不能控制脚本加载顺序</p></li><li><p>3.动态创建DOM方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这些代码应被放置在&lt;/body&gt;标签前(接近HTML文件底部)</span></span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">downloadJSAtOnload</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">      varelement = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);  </span><br><span class="line">      element.src = <span class="string">&quot;defer.js&quot;</span>;  </span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(element);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener)  </span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">&quot;load&quot;</span>,downloadJSAtOnload, <span class="literal">false</span>);  </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.attachEvent)  </span><br><span class="line">      <span class="built_in">window</span>.attachEvent(<span class="string">&quot;onload&quot;</span>,downloadJSAtOnload);  </span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">      <span class="built_in">window</span>.onload =downloadJSAtOnload;  </span><br><span class="line">&lt;/script&gt;  </span><br></pre></td></tr></table></figure><p>创建script，插入到DOM中，加载完毕后callBack</p></li><li><p>4.使用setTimeout延迟</p></li><li><p>5.按需异步加载</p></li></ul><h3 id="document-write和innerHTML的区别"><a href="#document-write和innerHTML的区别" class="headerlink" title="document.write和innerHTML的区别"></a>document.write和innerHTML的区别</h3><p>document.write重绘整个页面<br>innerHTML重绘页面一部分</p><h3 id="哪些操作会造成内存泄漏？"><a href="#哪些操作会造成内存泄漏？" class="headerlink" title="哪些操作会造成内存泄漏？"></a>哪些操作会造成内存泄漏？</h3><p>内存泄漏是指任何对象在您不再拥有或需要时仍然存在<br>垃圾回收器会定时扫描对象，并计算应用了每个对象的其他对象的数量，当引用该对象数量为0，或对该对象的惟一引用是循环的，那么该对象的内存就会被回收。</p><p>setTimeout函数的第一个参数如果是字符串，闭包、控制台日志，循环（两个对象彼此存在且彼此引用时，会行程一个循环）会引发内存泄漏。</p><h3 id="如何判断当前脚本运行在浏览器还是node环境中？"><a href="#如何判断当前脚本运行在浏览器还是node环境中？" class="headerlink" title="如何判断当前脚本运行在浏览器还是node环境中？"></a>如何判断当前脚本运行在浏览器还是node环境中？</h3><p>通过判断Global对象是否等于window，如果不是则在node中</p><p>this == window</p><h3 id="ajax过程"><a href="#ajax过程" class="headerlink" title="ajax过程"></a>ajax过程</h3><ul><li>1.创建一个XMLHttpRequest对象，也就是异步调用对象</li><li>2.创建一个新的http请求，设置请求的方式、URL以及验证信息</li><li>3.设置响应http请求状态变化的函数</li><li>4.发送http请求</li><li>5.获取异步调用返回的结果</li><li>6.使用js和dom实现局部刷新</li></ul><h3 id="ie各版本和chrome可以并行下载多少个资源"><a href="#ie各版本和chrome可以并行下载多少个资源" class="headerlink" title="ie各版本和chrome可以并行下载多少个资源"></a>ie各版本和chrome可以并行下载多少个资源</h3><p>IE6 两个并发，iE7升级之后的6个并发，之后版本也是6个</p><p>Firefox，chrome也是6个</p><h3 id="javascript的同源策略"><a href="#javascript的同源策略" class="headerlink" title="javascript的同源策略"></a>javascript的同源策略</h3><p>同源：协议、域名、端口相同，同源策略是一种协议，指脚本只能读取来自同一源的窗口和文档属性。</p><h3 id="哪些地方会出现css阻塞，哪些地方会出现js阻塞？"><a href="#哪些地方会出现css阻塞，哪些地方会出现js阻塞？" class="headerlink" title="哪些地方会出现css阻塞，哪些地方会出现js阻塞？"></a>哪些地方会出现css阻塞，哪些地方会出现js阻塞？</h3><p>所有浏览器在下载js的时候，都会阻塞其他资源的下载，页面的呈现等。直到js下载、解析、执行完毕后才能继续并行下载其他资源并呈现内容。新一代浏览器都支持并行下载js，但仍然会阻塞其他资源（css，图片）的下载。<br>由于浏览器为了防止出现js修改dom树，造成重新构造dom树的情况，需要阻塞其他资源的下载和呈现<br>嵌入js会阻塞所有内容的呈现，外部js只会阻塞其后内容的显示，2种方式都会阻塞资源的下载。</p><p>css本来是可以并行下载的，在什么情况下会阻塞加载？<br>css后面跟着嵌入js的时候，会阻塞后面资源的下载，而把嵌入js放置在css前面就不会阻塞资源加载了。</p><p>原因：<br>因为浏览器会维持html中css和js的顺序，样式表必须在嵌入js前先加载、解析完。而嵌入js又会阻塞后面的资源加载，所以就会出现css阻塞下载的情况</p><p>嵌入js应该放在什么位置？<br>1.放置在底部，虽然放在底部会阻塞所有呈现，但不会阻塞资源下载<br>2.放在head，放在css前面<br>3.使用defer<br>4.嵌入js中不要调用运行时间较长的函数，如果要调用，可以使用setTimeout来调用</p><h3 id="js无阻塞加载方式？"><a href="#js无阻塞加载方式？" class="headerlink" title="js无阻塞加载方式？"></a>js无阻塞加载方式？</h3><ul><li>将脚本放在底部：script标签放在<code>&lt;/body&gt;</code>前</li><li>非阻塞脚本：等页面加载完后，再加载js。也就是在onload事件下载js<ul><li>1.defer属性/async属性</li><li>2.动态创建dom方式（创建script，插入文档，onload事件回调触发）</li></ul></li></ul><h3 id="eval是做什么的？"><a href="#eval是做什么的？" class="headerlink" title="eval是做什么的？"></a>eval是做什么的？</h3><p>功能是将对应的字符串解析成js代码并执行。</p><p>应该避免使用eval，不安全，耗性能（2次，一次解析成js代码，一次执行）</p><h3 id="事件冒泡和事件捕获？"><a href="#事件冒泡和事件捕获？" class="headerlink" title="事件冒泡和事件捕获？"></a>事件冒泡和事件捕获？</h3><p>事件流描述的是从页面接收事件的顺序。<br>IE是冒泡事件流<br>Firefox是捕获事件流</p><ul><li>事件冒泡：即事件从具体的元素到不具体的元素，从内向外传递事件</li><li>事件捕获：即事件从不具体的元素到具体的元素</li></ul><p>事件冒泡和事件捕获是两个相反的过程</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>event<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;obj1&quot;</span>&gt;</span></span><br><span class="line">        welcome</span><br><span class="line">        <span class="tag">&lt;<span class="name">h5</span> <span class="attr">id</span>=<span class="string">&quot;obj2&quot;</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h5</span> <span class="attr">id</span>=<span class="string">&quot;obj3&quot;</span>&gt;</span>world<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> obj1=<span class="built_in">document</span>.getElementById(<span class="string">&#x27;obj1&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> obj2=<span class="built_in">document</span>.getElementById(<span class="string">&#x27;obj2&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        obj1.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&#x27;hello&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;,<span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">        obj2.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&#x27;world&#x27;</span>);</span></span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>文档结构：document &gt; html &gt; body &gt; div &gt; h5<br>addEventListener的第三个参数为false,所以页面是在冒泡阶段处理绑定事件</p><p>1.点击文字welcome，触发obj1的点击事件，弹出hello<br>2.点击文字hello，触发obj2的点击事件，弹出world &gt; hello<br>3.点击world时，触发obj1的点击事件，弹出hello</p><ul><li>事件代理机制：</li></ul><p>我们想要在点击每个h5标签时，弹出对应的innerHTML 。常规做法是遍历每个h5,然后在每个h5上绑定一个点击事件，这种做法在h5较少的时候可以使用，但如果有一万个h5，那就会导致性能降低。这时就需要事件代理出场了。 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj1.addEventListener(&#x27;click&#x27;,function(e)&#123;</span><br><span class="line">    var e=e||window.event;</span><br><span class="line">    if(e.target.nodeName.toLowerCase()==&#x27;h5&#x27;)&#123;</span><br><span class="line">        alert(e.target.innerHTML);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;,false);</span><br></pre></td></tr></table></figure><p>由于事件冒泡机制，点击了h5后会冒泡到div,此时就会触发绑定在div上的点击事件，再利用target找到事件实际发生的元素，就可以达到预期的效果</p><p>采用事件代理，为页面所有a标签绑定click事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEvenetListenser(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(e.target.nodeName == <span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>问题：若a标签里面仍有span、img等其他元素，上述代码中，单击span、img等其他元素不能触发click事件。</p><p>原因：单击span、img等其他元素时，e.target指向的是触发click事件的元素（span、img等其他元素），而不是a标签</p><p>解决方法：从触发click事件的元素开始，逐级向上查找，直到找到a标签为止。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> node = e.target;</span><br><span class="line">  <span class="keyword">while</span>(node.parentNode.nodeName != <span class="string">&#x27;BODY&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node.nodeName == <span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node = node.parentNode</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>阻止事件冒泡：e.stopPropagation(),ie旧方法e.cancelBubble = true</p><h3 id="如何获取UA"><a href="#如何获取UA" class="headerlink" title="如何获取UA"></a>如何获取UA</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">whatBrowser</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        <span class="built_in">document</span>.Browser.Name.value=navigator.appName;  </span><br><span class="line">        <span class="built_in">document</span>.Browser.Version.value=navigator.appVersion;  </span><br><span class="line">        <span class="built_in">document</span>.Browser.Code.value=navigator.appCodeName;  </span><br><span class="line">        <span class="built_in">document</span>.Browser.Agent.value=navigator.userAgent;  </span><br><span class="line">    &#125;  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="js操作和设置cookie"><a href="#js操作和设置cookie" class="headerlink" title="js操作和设置cookie"></a>js操作和设置cookie</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建cookie</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, expires, path, domain, secure</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cookieText = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">&#x27;=&#x27;</span> + <span class="built_in">encodeURIComponent</span>(value);</span><br><span class="line">    <span class="keyword">if</span> (expires <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">        cookieText += <span class="string">&#x27;; expires=&#x27;</span> + expires;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (path) &#123;</span><br><span class="line">        cookieText += <span class="string">&#x27;; expires=&#x27;</span> + expires;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (domain) &#123;</span><br><span class="line">        cookieText += <span class="string">&#x27;; domain=&#x27;</span> + domain;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (secure) &#123;</span><br><span class="line">        cookieText += <span class="string">&#x27;; secure&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.cookie = cookieText;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取cookie</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cookieName = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> cookieStart = <span class="built_in">document</span>.cookie.indexOf(cookieName);</span><br><span class="line">    <span class="keyword">var</span> cookieValue = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (cookieStart &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> cookieEnd = <span class="built_in">document</span>.cookie.indexOf(<span class="string">&#x27;;&#x27;</span>, cookieStart);</span><br><span class="line">        <span class="keyword">if</span> (cookieEnd == -<span class="number">1</span>) &#123;</span><br><span class="line">            cookieEnd = <span class="built_in">document</span>.cookie.length;</span><br><span class="line">        &#125;</span><br><span class="line">        cookieValue = <span class="built_in">decodeURIComponent</span>(<span class="built_in">document</span>.cookie.substring(cookieStart + cookieName.length, cookieEnd));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cookieValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除cookie</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unsetCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.cookie = name + <span class="string">&quot;= ; expires=&quot;</span> + <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tcp三次握手"><a href="#tcp三次握手" class="headerlink" title="tcp三次握手"></a>tcp三次握手</h3><p>为了准确无误将数据送达目标处，TCP协议采取了三次握手协议。<br>用tcp协议将数据包送出去后，tcp不会对发送后的情况置之不理，它一定向对方确认是否收到。</p><ul><li>1.发送端首先发送带SYN标志的数据给对方。</li><li>2.接收方收到后回传一个SYN/ACK标志的数据包以示传达确认信息。</li><li>3.最后，发送端再回传一个带ACK标志的字段，代表握手结束</li></ul><p>若在握手过程中某个阶段被打断，TCP会再次以相同的顺序发送数据包。</p><h3 id="对promise的理解"><a href="#对promise的理解" class="headerlink" title="对promise的理解"></a>对promise的理解</h3><p>promise有四种状态：</p><ul><li>1.pending:初始状态，非fullfilled或rejected</li><li>2.fullfilled: 成功的状态</li><li>3.rejected: 失败的状态</li><li>4:settled：promise已被fullfilled或rejected，且不是pending</li></ul><p>另外，fullfilled和rejected合称settled</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (...) &#123;  <span class="comment">// succeed</span></span><br><span class="line">        resolve(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;   <span class="comment">// fails</span></span><br><span class="line">        reject(<span class="built_in">Error</span>(errMessage));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Promise 实例拥有 then 方法（具有 then 方法的对象，通常被称为 thenable）。它的使用方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure><p>接收两个函数作为参数，一个在 fulfilled 的时候被调用，一个在 rejected 的时候被调用，接收参数就是 future，onFulfilled 对应 resolve, onRejected 对应 reject</p><h3 id="谈谈性能优化问题"><a href="#谈谈性能优化问题" class="headerlink" title="谈谈性能优化问题"></a>谈谈性能优化问题</h3><p>代码层面：避免使用css表达式，避免使用高级选择器，通配选择器。<br>缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等<br>请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载。<br>请求带宽：压缩文件，开启GZIP</p><h3 id="什么是Etag？"><a href="#什么是Etag？" class="headerlink" title="什么是Etag？"></a>什么是Etag？</h3><p>浏览器下载组件的时候，会将它们存储到浏览器缓存中。如果需要再次获取相同的组件，浏览器将检查组件的缓存时间，假如已经过期，那么浏览器将发送一个条件GET请求到服务器，服务器判断缓存还有效，则发送一个304响应<br>告诉浏览器可以重用缓存组件</p><p>那么服务器是根据什么判断缓存是否还有效呢?答案有两种方式，一种是前面提到的ETag，另一种是根据Last-Modified</p><h3 id="栈和队列的区别"><a href="#栈和队列的区别" class="headerlink" title="栈和队列的区别?"></a>栈和队列的区别?</h3><p>栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。<br>队列先进先出，栈先进后出。</p><p>栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除 </p><h3 id="栈和堆的区别？"><a href="#栈和堆的区别？" class="headerlink" title="栈和堆的区别？"></a>栈和堆的区别？</h3><p>栈区（stack）—   由编译器自动分配释放   ，存放函数的参数值，局部变量的值等。<br>堆区（heap）   —   一般由程序员分配释放，   若程序员不释放，程序结束时可能由OS回收。<br>堆（数据结构）：堆可以被看成是一棵树，如：堆排序；<br>栈（数据结构）：一种先进后出的数据结构。 </p><h3 id="关于Http-2-0-你知道多少？"><a href="#关于Http-2-0-你知道多少？" class="headerlink" title="关于Http 2.0 你知道多少？"></a>关于Http 2.0 你知道多少？</h3><p>HTTP/2引入了“服务端推（serverpush）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。<br>HTTP/2提供更多的加密支持<br>HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。<br>它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript</title>
      <link href="/ZJY.github.io/2021/02/21/typescript/"/>
      <url>/ZJY.github.io/2021/02/21/typescript/</url>
      
        <content type="html"><![CDATA[<h2 id="TS（typescript）是什么？"><a href="#TS（typescript）是什么？" class="headerlink" title="TS（typescript）是什么？"></a>TS（typescript）是什么？</h2><p>TS是以JavaScript为基础构建的语言，是JavaScript的一个超集<br>TS扩展了JavaScript，并添加了类型。可以在任何支持JavaScript的平台执行。<br>TS不能被js解释器直接执行，需要将ts编译成js</p><h2 id="TS增加了什么？"><a href="#TS增加了什么？" class="headerlink" title="TS增加了什么？"></a>TS增加了什么？</h2><p>类型<br>支持ES的新特性<br>添加ES不具有的新特性<br>丰富的配置选项（编译为ES3，ES6等）<br>强大的开发工具</p><h2 id="TS安装"><a href="#TS安装" class="headerlink" title="TS安装"></a>TS安装</h2><p>1.安装node<br>2.安装npm<br>3.npm install -g typescript<br>4.tsc -v  查看tsc安装版本</p><h2 id="TS编译"><a href="#TS编译" class="headerlink" title="TS编译"></a>TS编译</h2><p>tsc ts.ts<br>编译成功生成同名js文件</p><h2 id="类型声明："><a href="#类型声明：" class="headerlink" title="类型声明："></a>类型声明：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a:number = <span class="number">10</span>;或者<span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a:number, b:number</span>):<span class="title">number</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>联合类型（Union Types）可以通过管道(|)将变量设置多种类型，赋值时可以根据设置的类型来赋值。</p><p>注意：只能赋值指定的类型，如果赋值其它类型就会报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> d: <span class="string">&#x27;male&#x27;</span> | <span class="string">&#x27;female&#x27;</span>;</span><br><span class="line">d = <span class="string">&#x27;male&#x27;</span>;</span><br><span class="line">d = <span class="string">&#x27;female&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> e: boolean | string;</span><br><span class="line">e = <span class="literal">false</span>;</span><br><span class="line">e = <span class="string">&#x27;123&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="TypeScript基础类型"><a href="#TypeScript基础类型" class="headerlink" title="TypeScript基础类型"></a>TypeScript基础类型</h2><table><thead><tr><th>数据类型</th><th>关键字</th><th>描述</th></tr></thead><tbody><tr><td>任意类型</td><td>any</td><td>声明为 any 的变量可以赋予任意类型的值</td></tr><tr><td>数字类型</td><td>number</td><td>双精度 64 位浮点值。它可以用来表示整数和分数。<br>let binaryLiteral: number = 0b1010; // 二进制 <br>let octalLiteral: number = 0o744;    // 八进制 <br>let decLiteral: number = 6;    // 十进制 <br>let hexLiteral: number = 0xf00d;    // 十六进制</td></tr><tr><td>字符串类型</td><td>string</td><td>一个字符系列，使用单引号（’）或双引号（”）来表示字符串类型。反引号（``）来定义多行文本和内嵌表达式。<br>let name: string = “Runoob”;<br>let years: number = 5;<br>let words: string = <code>您好，今年是 $&#123; name &#125; 发布 $&#123; years + 1&#125; 周年</code>;</td></tr><tr><td>布尔类型</td><td>boolean</td><td>表示逻辑值：true 和 false。<br>let flag: boolean = true;</td></tr><tr><td>数组类型</td><td>无</td><td>声明变量为数组。<br>// 在元素类型后面加上[]<br>let arr: number[] = [1, 2];<br>// 或者使用数组泛型<br>let arr: Array<number> = [1, 2];</td></tr><tr><td>元组</td><td>无</td><td>元组类型用来表示已知元素数量和类型的数组，各元素的类型不必相同，对应位置的类型需要相同。<br>let x: [string, number];<br>x = [‘Runoob’, 1];    // 运行正常<br>x = [1, ‘Runoob’];    // 报错<br>console.log(x[0]);    // 输出 Runoob</td></tr><tr><td>枚举</td><td>enum</td><td>用于定义数值集合 <br>enum Color {Red, Green, Blue};<br>let c: Color = Color.Blue;<br>console.log(c);    // 输出 2</td></tr><tr><td>void</td><td>void</td><td>用于标识方法返回值的类型，表示该方法没有返回值<br>function hello(): void {<br>alert(“Hello Runoob”);<br>或者return; /return null; /return undefined}</td></tr><tr><td>null</td><td>null</td><td>表示对象值缺失</td></tr><tr><td>undefined</td><td>undefined</td><td>用于初始化变量为一个未定义的值</td></tr><tr><td>never</td><td>never</td><td>never 是其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值</td></tr></tbody></table><h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line">a = <span class="number">123</span>;</span><br><span class="line">a = <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line">a = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s:string;</span><br><span class="line">s = a; <span class="comment">//正常</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c: unknown; <span class="comment">//未知类型的值</span></span><br><span class="line">c = <span class="number">123</span>;</span><br><span class="line">c = <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line">c = <span class="literal">true</span>;</span><br><span class="line">c = <span class="string">&#x27;str&#x27;</span>;</span><br><span class="line"></span><br><span class="line">s = c; <span class="comment">//错误：Type &#x27;unknown&#x27; is not assignable to type &#x27;string&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// unknown实际上是一个类型安全的any</span></span><br><span class="line"><span class="comment">// unknown类型的变量不可以直接赋值给其他变量，需要类型检测，any类型的可以直接赋值。</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> c === <span class="string">&#x27;string&#x27;</span>)&#123;</span><br><span class="line">    s = c; <span class="comment">//正常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者：</span></span><br><span class="line">s = h <span class="keyword">as</span> string; <span class="comment">//类型断言</span></span><br><span class="line">s = &lt;string&gt;e; <span class="comment">//类型断言</span></span><br></pre></td></tr></table></figure><h2 id="类型断言-Type-Assertion"><a href="#类型断言-Type-Assertion" class="headerlink" title="类型断言(Type Assertion)"></a>类型断言(Type Assertion)</h2><p>类型断言可以用来手动指定一个值的类型，即允许变量从一种值的类型转换为另一种类型。<br>语法：</p><ul><li>&lt;类型&gt;值</li><li>值 as 类型</li></ul><h2 id="never-不可能出现的值"><a href="#never-不可能出现的值" class="headerlink" title="never 不可能出现的值"></a>never 不可能出现的值</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示不会有返回值的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>): <span class="title">never</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值为 never 的函数可以是无法被执行到的终止点的情况</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n:never;</span><br><span class="line"><span class="keyword">let</span> m: string;</span><br><span class="line"><span class="comment">// n = 1; // 运行错误，数字类型不能转为 never 类型</span></span><br><span class="line"><span class="comment">// &lt;!-- 运行正确，never 类型可以赋值给 never类型 --&gt;</span></span><br><span class="line">n = (<span class="function">()=&gt;</span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>)&#125;)();</span><br><span class="line"></span><br><span class="line">m = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="comment">// &lt;!-- 运行正确，never 类型可以赋值给 字符串类型 --&gt;</span></span><br><span class="line">m = (<span class="function">()=&gt;</span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>)&#125;)();</span><br></pre></td></tr></table></figure><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>{}可以指定对象中有哪些属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj: &#123;<span class="attr">name</span>: string,age?:number&#125;;</span><br><span class="line">obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;zjy&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p>age?:number,?表示可选</p><p>多个属性可选：[propName: string]:any</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj: &#123;<span class="attr">name</span>: string,[propName:string]:any&#125;;</span><br><span class="line">obj = &#123;<span class="attr">name</span>:<span class="string">&#x27;zjy&#x27;</span>,<span class="attr">age</span>:<span class="number">13</span>,<span class="attr">sex</span>:<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><p>函数结构的类型声明：<br>语法：(属性：类型,…)=&gt;返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fun :<span class="function">(<span class="params">a:number,b:number</span>)=&gt;</span>number;</span><br><span class="line">fun = <span class="function"><span class="keyword">function</span>(<span class="params">n1:number,n2:number</span>):<span class="title">number</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n1 + n2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="amp-表示同时满足2个条件"><a href="#amp-表示同时满足2个条件" class="headerlink" title="&amp;:表示同时满足2个条件"></a>&amp;:表示同时满足2个条件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj2: &#123;<span class="attr">name</span>:string&#125; &amp; &#123;<span class="attr">age</span>:number&#125;;</span><br><span class="line">    obj2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;zjy&#x27;</span>, <span class="attr">age</span>:<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="类型的别名"><a href="#类型的别名" class="headerlink" title="类型的别名"></a>类型的别名</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型的别名</span></span><br><span class="line">type typename = <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> k: typename;</span><br><span class="line">k = <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="自动编译选项：tsc-xxx-ts-w"><a href="#自动编译选项：tsc-xxx-ts-w" class="headerlink" title="自动编译选项：tsc xxx.ts -w"></a>自动编译选项：tsc xxx.ts -w</h2><h2 id="添加tsconfig-json文件可编译目录下所有文件"><a href="#添加tsconfig-json文件可编译目录下所有文件" class="headerlink" title="添加tsconfig.json文件可编译目录下所有文件"></a>添加tsconfig.json文件可编译目录下所有文件</h2><p>tsc -init 生成tsconfig.json文件</p><h2 id="tsconfig-json编译选项"><a href="#tsconfig-json编译选项" class="headerlink" title="tsconfig.json编译选项"></a>tsconfig.json编译选项</h2><ul><li><p>include: [] 用于指定哪些文件需要被编译</p><ul><li>**: 任意目录</li><li>*: 任意文件</li></ul></li><li><p>exclude :[] 不需要被编译文件的目录</p><ul><li>“exclude”默认情况下会排除node_modules，bower_components，jspm_packages和<code>&lt;outDir&gt;</code>目录</li></ul></li><li><p>extends： 可以利用extends属性从另一个配置文件里继承配置</p></li><li><p>files: [] 指定一个包含相对或绝对文件路径的列表</p><ul><li>使用”include”引入的文件可以使用”exclude”属性过滤。 然而，通过 “files”属性明确指定的文件却总是会被包含在内，不管”exclude”如何设置</li></ul></li><li><p>compilerOptions:编译器选项配置</p><ul><li>target：指定ECMAScript目标版本，默认ES3，”ES5”， “ES6”/ “ES2015”， “ES2016”， “ES2017”或 “ESNext”。</li><li>module: 指定生成哪个模块系统代码： “None”， “CommonJS”， “AMD”， “System”， “UMD”， “ES6”或 “ES2015”。</li><li>lib:[]  编译过程中需要引入的库文件的列表,例如ES5，ES6 ，DOM等</li><li>outDir: 用来指定编译后文件所在目录</li><li>outFile: 将输出文件合并为一个文件,只有 “AMD”和 “System”能和 –outFile一起使用。</li><li>allowJs: 默认是false，允许编译javascript文件。</li><li>checkJs: 默认是false，是否检测js语法，与allowJs配合使用</li><li>removeComments: 默认是false，删除所有注释，除了以 /!*开头的版权信息。</li><li>noEmit: 默认是false,不输出编译文件</li><li>noEmitOnError: 默认是false 报错时不生成输出文件</li><li>alwaysStrict: 默认是false 以严格模式解析并为每个源文件生成 “use strict”语句,当文件使用模块化时自动采用严格模式，不会生成文件头部’use strict’</li><li>noImplicitAny: 默认是false 在表达式和声明上有隐含的 any类型时报错。<ul><li>例如：function add(a,b){<br>return a + b;<br>}</li></ul></li><li>noImplicitThis: 默认是false 当 this表达式的值为 any类型的时候，生成一个错误</li><li>strictNullChecks: 默认是false 严格检查空值</li><li>strict: 默认是false 启用所有严格类型检查选项。启用 –strict相当于启用 –noImplicitAny, –noImplicitThis, –alwaysStrict， –strictNullChecks和 –strictFunctionTypes和–strictPropertyInitialization</li></ul></li></ul><p>tsconfig.json文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">/* Visit https://aka.ms/tsconfig.json to read more about this file */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Basic Options */</span></span><br><span class="line">    <span class="comment">// &quot;incremental&quot;: true,                   /* Enable incremental compilation */</span></span><br><span class="line">    <span class="string">&quot;target&quot;</span>: <span class="string">&quot;es6&quot;</span>,                          <span class="comment">/* Specify ECMAScript target version: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, &#x27;ES2018&#x27;, &#x27;ES2019&#x27;, &#x27;ES2020&#x27;, or &#x27;ESNEXT&#x27;. */</span></span><br><span class="line">    <span class="string">&quot;module&quot;</span>: <span class="string">&quot;es6&quot;</span>,                     <span class="comment">/* Specify module code generation: &#x27;none&#x27;, &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27;, &#x27;es2015&#x27;, &#x27;es2020&#x27;, or &#x27;ESNext&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;lib&quot;: [],                             /* Specify library files to be included in the compilation. */</span></span><br><span class="line">    <span class="string">&quot;allowJs&quot;</span>: <span class="literal">true</span>,                       <span class="comment">/* Allow javascript files to be compiled. */</span></span><br><span class="line">    <span class="string">&quot;checkJs&quot;</span>: <span class="literal">true</span>,                       <span class="comment">/* Report errors in .js files. */</span></span><br><span class="line">    <span class="comment">// &quot;jsx&quot;: &quot;preserve&quot;,                     /* Specify JSX code generation: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;declaration&quot;: true,                   /* Generates corresponding &#x27;.d.ts&#x27; file. */</span></span><br><span class="line">    <span class="comment">// &quot;declarationMap&quot;: true,                /* Generates a sourcemap for each corresponding &#x27;.d.ts&#x27; file. */</span></span><br><span class="line">    <span class="comment">// &quot;sourceMap&quot;: true,                     /* Generates corresponding &#x27;.map&#x27; file. */</span></span><br><span class="line">    <span class="comment">// &quot;outFile&quot;: &quot;dist/app.js&quot;,                       /* Concatenate and emit output to single file. */</span></span><br><span class="line">    <span class="string">&quot;outDir&quot;</span>: <span class="string">&quot;dist/&quot;</span>,                        <span class="comment">/* Redirect output structure to the directory. */</span></span><br><span class="line">    <span class="comment">// &quot;rootDir&quot;: &quot;./&quot;,                       /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */</span></span><br><span class="line">    <span class="comment">// &quot;composite&quot;: true,                     /* Enable project compilation */</span></span><br><span class="line">    <span class="comment">// &quot;tsBuildInfoFile&quot;: &quot;./&quot;,               /* Specify file to store incremental compilation information */</span></span><br><span class="line">    <span class="string">&quot;removeComments&quot;</span>: <span class="literal">true</span>,                <span class="comment">/* Do not emit comments to output. */</span></span><br><span class="line">    <span class="string">&quot;noEmit&quot;</span>: <span class="literal">false</span>,                        <span class="comment">/* Do not emit outputs. */</span></span><br><span class="line">    <span class="string">&quot;noEmitOnError&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// &quot;importHelpers&quot;: true,                 /* Import emit helpers from &#x27;tslib&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;downlevelIteration&quot;: true,            /* Provide full support for iterables in &#x27;for-of&#x27;, spread, and destructuring when targeting &#x27;ES5&#x27; or &#x27;ES3&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;isolatedModules&quot;: true,               /* Transpile each file as a separate module (similar to &#x27;ts.transpileModule&#x27;). */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Strict Type-Checking Options */</span></span><br><span class="line">    <span class="string">&quot;strict&quot;</span>: <span class="literal">true</span>,                           <span class="comment">/* Enable all strict type-checking options. */</span></span><br><span class="line">    <span class="string">&quot;noImplicitAny&quot;</span>: <span class="literal">true</span>,                 <span class="comment">/* Raise error on expressions and declarations with an implied &#x27;any&#x27; type. */</span></span><br><span class="line">    <span class="comment">// &quot;strictNullChecks&quot;: true,              /* Enable strict null checks. */</span></span><br><span class="line">    <span class="comment">// &quot;strictFunctionTypes&quot;: true,           /* Enable strict checking of function types. */</span></span><br><span class="line">    <span class="comment">// &quot;strictBindCallApply&quot;: true,           /* Enable strict &#x27;bind&#x27;, &#x27;call&#x27;, and &#x27;apply&#x27; methods on functions. */</span></span><br><span class="line">    <span class="comment">// &quot;strictPropertyInitialization&quot;: true,  /* Enable strict checking of property initialization in classes. */</span></span><br><span class="line">    <span class="comment">// &quot;noImplicitThis&quot;: true,                /* Raise error on &#x27;this&#x27; expressions with an implied &#x27;any&#x27; type. */</span></span><br><span class="line">    <span class="comment">// &quot;alwaysStrict&quot;: true,                  /* Parse in strict mode and emit &quot;use strict&quot; for each source file. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Additional Checks */</span></span><br><span class="line">    <span class="comment">// &quot;noUnusedLocals&quot;: true,                /* Report errors on unused locals. */</span></span><br><span class="line">    <span class="comment">// &quot;noUnusedParameters&quot;: true,            /* Report errors on unused parameters. */</span></span><br><span class="line">    <span class="comment">// &quot;noImplicitReturns&quot;: true,             /* Report error when not all code paths in function return a value. */</span></span><br><span class="line">    <span class="comment">// &quot;noFallthroughCasesInSwitch&quot;: true,    /* Report errors for fallthrough cases in switch statement. */</span></span><br><span class="line">    <span class="comment">// &quot;noUncheckedIndexedAccess&quot;: true,      /* Include &#x27;undefined&#x27; in index signature results */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Module Resolution Options */</span></span><br><span class="line">    <span class="comment">// &quot;moduleResolution&quot;: &quot;node&quot;,            /* Specify module resolution strategy: &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6). */</span></span><br><span class="line">    <span class="comment">// &quot;baseUrl&quot;: &quot;./&quot;,                       /* Base directory to resolve non-absolute module names. */</span></span><br><span class="line">    <span class="comment">// &quot;paths&quot;: &#123;&#125;,                           /* A series of entries which re-map imports to lookup locations relative to the &#x27;baseUrl&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;rootDirs&quot;: [],                        /* List of root folders whose combined content represents the structure of the project at runtime. */</span></span><br><span class="line">    <span class="comment">// &quot;typeRoots&quot;: [],                       /* List of folders to include type definitions from. */</span></span><br><span class="line">    <span class="comment">// &quot;types&quot;: [],                           /* Type declaration files to be included in compilation. */</span></span><br><span class="line">    <span class="comment">// &quot;allowSyntheticDefaultImports&quot;: true,  /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */</span></span><br><span class="line">    <span class="string">&quot;esModuleInterop&quot;</span>: <span class="literal">true</span>,                  <span class="comment">/* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies &#x27;allowSyntheticDefaultImports&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;preserveSymlinks&quot;: true,              /* Do not resolve the real path of symlinks. */</span></span><br><span class="line">    <span class="comment">// &quot;allowUmdGlobalAccess&quot;: true,          /* Allow accessing UMD globals from modules. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Source Map Options */</span></span><br><span class="line">    <span class="comment">// &quot;sourceRoot&quot;: &quot;&quot;,                      /* Specify the location where debugger should locate TypeScript files instead of source locations. */</span></span><br><span class="line">    <span class="comment">// &quot;mapRoot&quot;: &quot;&quot;,                         /* Specify the location where debugger should locate map files instead of generated locations. */</span></span><br><span class="line">    <span class="comment">// &quot;inlineSourceMap&quot;: true,               /* Emit a single file with source maps instead of having a separate file. */</span></span><br><span class="line">    <span class="comment">// &quot;inlineSources&quot;: true,                 /* Emit the source alongside the sourcemaps within a single file; requires &#x27;--inlineSourceMap&#x27; or &#x27;--sourceMap&#x27; to be set. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Experimental Options */</span></span><br><span class="line">    <span class="comment">// &quot;experimentalDecorators&quot;: true,        /* Enables experimental support for ES7 decorators. */</span></span><br><span class="line">    <span class="comment">// &quot;emitDecoratorMetadata&quot;: true,         /* Enables experimental support for emitting type metadata for decorators. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Advanced Options */</span></span><br><span class="line">    <span class="string">&quot;skipLibCheck&quot;</span>: <span class="literal">true</span>,                     <span class="comment">/* Skip type checking of declaration files. */</span></span><br><span class="line">    <span class="string">&quot;forceConsistentCasingInFileNames&quot;</span>: <span class="literal">true</span>  <span class="comment">/* Disallow inconsistently-cased references to the same file. */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;include&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;src/**/*&quot;</span></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue框架基础</title>
      <link href="/ZJY.github.io/2021/02/20/vue%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80/"/>
      <url>/ZJY.github.io/2021/02/20/vue%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue-js优点"><a href="#Vue-js优点" class="headerlink" title="Vue.js优点"></a>Vue.js优点</h2><p>1.体积小</p><p>压缩后33k</p><p>2.更高的运行效率</p><p>基于虚拟dom，一种可以预先通过JavaScript进行各种计算，把最终的dom操作计算出来并优化的技术，由于这个dom操作属于预处理操作，并没有真实的操作dom，所以叫虚拟dom。</p><p>3.双向数据绑定</p><p>让开发者不再去操作dom对象，更多的精力投入到业务逻辑上</p><p>4.生态丰富、学习成本低</p><p>市场上拥有大量成熟、稳定的基于vue.js的ui框架、常用组件，实现快速开发。对初学者友好、入门容易、学习资料多。</p><h2 id="vue的安装与部署"><a href="#vue的安装与部署" class="headerlink" title="vue的安装与部署"></a>vue的安装与部署</h2><p>安装：</p><ul><li>1.通过script直接引入</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line">&lt;script src=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="comment">// &lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;</span></span><br><span class="line">&lt;script src=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>2.NPM</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue</span><br></pre></td></tr></table></figure><ul><li>3.命令行工具（CLI）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br><span class="line"><span class="comment">// OR</span></span><br><span class="line">yarn <span class="built_in">global</span> add @vue/cli</span><br></pre></td></tr></table></figure><h2 id="数据与方法"><a href="#数据与方法" class="headerlink" title="数据与方法"></a>数据与方法</h2><p>当一个 Vue 实例被创建时，它将 data 对象中的所有的 property 加入到 Vue 的响应式系统中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们的数据对象</span></span><br><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该对象被加入到一个 Vue 实例中</span></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得这个实例上的 property</span></span><br><span class="line"><span class="comment">// 返回源数据中对应的字段</span></span><br><span class="line">vm.a == data.a <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 property 也会影响到原始数据</span></span><br><span class="line">vm.a = <span class="number">2</span></span><br><span class="line">data.a <span class="comment">// =&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ……反之亦然</span></span><br><span class="line">data.a = <span class="number">3</span></span><br><span class="line">vm.a <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure><p>当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时就已经存在于 data 中的 property 才是响应式的。也就是说如果你添加一个新的 property，比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.b = <span class="string">&#x27;hi&#x27;</span></span><br></pre></td></tr></table></figure><p>那么对 b 的改动将不会触发任何视图的更新。如果你知道你会在晚些时候需要一个 property，但是一开始它为空或不存在，那么你仅需要设置一些初始值。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  newTodoText: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  visitCount: <span class="number">0</span>,</span><br><span class="line">  hideCompletedTodos: <span class="literal">false</span>,</span><br><span class="line">  todos: [],</span><br><span class="line">  error: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里唯一的例外是使用 Object.freeze()，这会阻止修改现有的 property，也意味着响应系统无法再追踪变化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.freeze(obj)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: obj</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; foo &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 这里的 `foo` 不会更新！ --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;foo = &#x27;baz&#x27;&quot;</span>&gt;</span>Change it<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>除了数据 property，Vue 实例还暴露了一些有用的实例 property 与方法。它们都有前缀 $，以便与用户定义的 property 区分开来。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.$data === data <span class="comment">// =&gt; true</span></span><br><span class="line">vm.$el === <span class="built_in">document</span>.getElementById(<span class="string">&#x27;example&#x27;</span>) <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $watch 是一个实例方法</span></span><br><span class="line">vm.$watch(<span class="string">&#x27;a&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">newValue, oldValue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个回调将在 `vm.a` 改变后调用</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</span></span><br><span class="line">beforeCreate:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;beforeCreate&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">/* 在实例创建完成后被立即调用。</span></span><br><span class="line"><span class="comment">在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。</span></span><br><span class="line"><span class="comment">然而，挂载阶段还没开始，$el 属性目前不可见。 */</span></span><br><span class="line">created:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;created&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//在挂载开始之前被调用：相关的渲染函数首次被调用</span></span><br><span class="line">beforeMount : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;beforeMount&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//el 被新创建的 vm.$el 替换, 挂载成功</span></span><br><span class="line"><span class="comment">// 注意 mounted 不会保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 mounted 内部使用 vm.$nextTick</span></span><br><span class="line">mounted : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;mounted&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//数据更新时调用</span></span><br><span class="line">beforeUpdate : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;beforeUpdate&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//组件 DOM 已经更新, 组件更新完毕 </span></span><br><span class="line">updated : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;updated&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例销毁之前调用。在这一步，实例仍然完全可用</span></span><br><span class="line">beforeDestory: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;beforeDestory&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。</span></span><br><span class="line">destroyed: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;destroyed&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 被 keep-alive 缓存的组件激活时调用。</span></span><br><span class="line">activated: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;activated&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 被 keep-alive 缓存的组件停用时调用</span></span><br><span class="line">deactivated: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;deactivated&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模版语法"><a href="#模版语法" class="headerlink" title="模版语法"></a>模版语法</h2><p>Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML，所以能被遵循规范的浏览器和 HTML 解析器解析。</p><p>在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。</p><p>1.文本<br>数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-once</span>&gt;</span>这个将不会改变: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.原始HTML<br>双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 v-html 指令：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using mustaches: &#123;&#123; rawHtml &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using v-html directive: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&quot;rawHtml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.Attribute<br>Mustache 语法不能作用在 HTML attribute 上，遇到这种情况应该使用 v-bind 指令：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;dynamicId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4.使用javascript表达式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; number + 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;&#x27;list-&#x27; + id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>指令 (Directives) 是带有 v- 前缀的特殊 attribute。指令 attribute 的值预期是单个 JavaScript 表达式 (v-for 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</p><p>1.参数<br>一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，v-bind 指令可以用于响应式地更新 HTML attribute：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另一个例子是 v-on 指令，它用于监听 DOM 事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.动态参数<br>从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[<span class="attr">attributeName</span>]=<span class="string">&quot;url&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同样地，你可以使用动态参数为一个动态的事件名绑定处理函数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:</span>[<span class="attr">eventName</span>]=<span class="string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对动态参数的值的约束:<br>  动态参数预期会求出一个字符串，异常情况下值为 null。这个特殊的 null 值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。<br>对动态参数表达式的约束:<br>  动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML attribute 名里是无效的。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这会触发一个编译警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[&#x27;<span class="attr">foo</span>&#x27; + <span class="attr">bar</span>]=<span class="string">&quot;value&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>变通的办法是使用没有空格或引号的表达式，或用计算属性替代这种复杂表达式。</p><p>在 DOM 中使用模板时 (直接在一个 HTML 文件里撰写模板)，还需要避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">在 DOM 中使用模板时这段代码会被转换为 `v-bind:[someattr]`。</span></span><br><span class="line"><span class="comment">除非在实例中有一个名为“someattr”的 property，否则代码不会工作。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[<span class="attr">someAttr</span>]=<span class="string">&quot;value&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.修饰符</p><p>修饰符 (modifier) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4.缩写</p><p>v-bind缩写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:</span>[<span class="attr">key</span>]=<span class="string">&quot;url&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>v-on缩写</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @[<span class="attr">event</span>]=<span class="string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="class和style绑定"><a href="#class和style绑定" class="headerlink" title="class和style绑定"></a>class和style绑定</h2><ul><li>绑定html class</li></ul><p>1.对象语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;&#123; active: isActive &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;div</span><br><span class="line">  class=&quot;static&quot;</span><br><span class="line">  v-bind:class=&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们也可以在这里绑定一个返回对象的计算属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;classObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  error: <span class="literal">null</span></span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  classObject: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      active: <span class="built_in">this</span>.isActive &amp;&amp; !<span class="built_in">this</span>.error,</span><br><span class="line">      <span class="string">&#x27;text-danger&#x27;</span>: <span class="built_in">this</span>.error &amp;&amp; <span class="built_in">this</span>.error.type === <span class="string">&#x27;fatal&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.数组语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;[activeClass, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;[&#123; active: isActive &#125;, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.用在组件上</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;&#123; active: isActive &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>绑定内联样式</li></ul><p>1.对象语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;styleObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  styleObject: &#123;</span><br><span class="line">    color: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">    fontSize: <span class="string">&#x27;13px&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.数组语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;[baseStyles, overridingStyles]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><ul><li><p>v-if<br>v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。</p></li><li><p>v-else<br>你可以使用 v-else 指令来表示 v-if 的“else 块”：</p></li><li><p>v-else-if<br>v-else-if，顾名思义，充当 v-if 的“else-if 块”，可以连续使用：</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;type === &#x27;A&#x27;&quot;</span>&gt;</span></span><br><span class="line">  A</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;B&#x27;&quot;</span>&gt;</span></span><br><span class="line">  B</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;C&#x27;&quot;</span>&gt;</span></span><br><span class="line">  C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  Not A/B/C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>用 key 管理可复用的元素<br>Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染.如果两个元素是完全独立的，不要复用它们，只需添加一个具有唯一值的key属性即可</p></li><li><p>v-show<br>另一个用于根据条件展示元素的选项是 v-show 指令。用法大致一样：</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">&quot;ok&quot;</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS property display。v-show 不支持 <code>&lt;template&gt; </code>元素，也不支持 v-else</p><ul><li>v-if vs v-show</li></ul><p>v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p><p>v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p>相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p><p>一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好</p><ul><li>v-if与v-for一起使用</li></ul><p>当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级</p><h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><ul><li>用 v-for 把一个数组对应为一组元素</li></ul><p>我们可以用 v-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组，而 item 则是被迭代的数组元素的别名。</p><p>你也可以用 of 替代 in 作为分隔符，因为它更接近 JavaScript 迭代器的语法：</p><ul><li>在 v-for 里使用对象</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;v-for-object&quot;</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;value in object&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; value &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#v-for-object&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    object: &#123;</span><br><span class="line">      title: <span class="string">&#x27;How to do lists in Vue&#x27;</span>,</span><br><span class="line">      author: <span class="string">&#x27;Jane Doe&#x27;</span>,</span><br><span class="line">      publishedAt: <span class="string">&#x27;2016-04-10&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以提供第二个的参数为 property 名称 (也就是键名)：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, name) in object&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还可以用第三个参数作为索引：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, name, index) in object&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在遍历对象时，会按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下都一致</p><ul><li>维护状态</li></ul><p>当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染</p><p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key attribute</p><p>建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</p><p>不要使用对象或数组之类的非基本类型值作为 v-for 的 key。请用字符串或数值类型的值。</p><ul><li>数组更新检查</li></ul><p>变更方法：Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：<br>push()<br>pop()<br>shift()<br>unshift()<br>splice()<br>sort()<br>reverse()</p><p>替换数组：变更方法，顾名思义，会变更调用了这些方法的原始数组。相比之下，也有非变更方法，例如 filter()、concat() 和 slice()。它们不会变更原始数组，而总是返回一个新数组。当使用非变更方法时，可以用新数组替换旧数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">example1.items = example1.items.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item.message.match(<span class="regexp">/Foo/</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>你可能认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表。幸运的是，事实并非如此。Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的启发式方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作</p><p>由于 JavaScript 的限制，Vue 不能检测数组和对象的变化</p><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>可以用 v-on 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example-1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;counter += 1&quot;</span>&gt;</span>Add 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>The button above has been clicked &#123;&#123; counter &#125;&#125; times.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然而许多事件处理逻辑会更为复杂，所以直接把 JavaScript 代码写在 v-on 指令中是不可行的。因此 v-on 还可以接收一个需要调用的方法名称。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example-2&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- `greet` 是在下面定义的方法名 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;greet&quot;</span>&gt;</span>Greet<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example-3&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;say(&#x27;hi&#x27;)&quot;</span>&gt;</span>Say hi<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;say(&#x27;what&#x27;)&quot;</span>&gt;</span>Say what<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;warn(&#x27;Form cannot be submitted yet.&#x27;, $event)&quot;</span>&gt;</span></span><br><span class="line">  Submit</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p>.stop<br>.prevent<br>.capture<br>.self<br>.once<br>.passive</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.once</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 而不会等待 `onScroll` 完成  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">&quot;onScroll&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击</p><h3 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 你可以直接将 KeyboardEvent.key 暴露的任意有效按键名转换为 kebab-case 来作为修饰符。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.page-down</span>=<span class="string">&quot;onPageDown&quot;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h2><p>你可以用 v-model 指令在表单<code> &lt;input&gt;</code>、<code>&lt;textarea&gt; </code>及 <code>&lt;select&gt;</code> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理</p><p>v-model 会忽略所有表单元素的 value、checked、selected attribute 的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值</p><p>v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：<br>text 和 textarea 元素使用 value property 和 input 事件；<br>checkbox 和 radio 使用 checked property 和 change 事件；<br>select 字段将 value 作为 prop 并将 change 作为事件</p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul><li>.lazy</li></ul><p>在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 lazy 修饰符，从而转为在 change 事件_之后_进行同步：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在“change”时而非“input”时更新 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.lazy</span>=<span class="string">&quot;msg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>.number</li></ul><p>如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.number</span>=<span class="string">&quot;age&quot;</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这通常很有用，因为即使在 type=”number” 时，HTML 输入元素的值也总会返回字符串。如果这个值无法被 parseFloat() 解析，则会返回原始的值</p><ul><li>.trim</li></ul><p>如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.trim</span>=<span class="string">&quot;msg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个名为 button-counter 的新组件</span><br><span class="line">Vue.component(&#x27;button-counter&#x27;, &#123;</span><br><span class="line">  data: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: &#x27;<span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;count++&quot;</span>&gt;</span>You clicked me &#123;&#123; count &#125;&#125; times.<span class="tag">&lt;/<span class="name">button</span>&gt;</span>&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>因为组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项。</p><h3 id="组件的复用"><a href="#组件的复用" class="headerlink" title="组件的复用"></a>组件的复用</h3><p>你可以将组件进行任意次数的复用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;components-demo&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意当点击按钮时，每个组件都会各自独立维护它的 count。因为你每用一次组件，就会有一个它的新实例被创建。</p><p><b>data 必须是一个函数</b><br>当我们定义这个 <code>&lt;button-counter&gt;</code> 组件时，你可能会发现它的 data 并不是像这样直接提供一个对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  count: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取而代之的是，一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 Vue 没有这条规则，点击一个按钮就可能会影响到其它所有实例</p><h3 id="通过prop向自组件传递数据"><a href="#通过prop向自组件传递数据" class="headerlink" title="通过prop向自组件传递数据"></a>通过prop向自组件传递数据</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;blog-post&#x27;</span>, &#123;</span><br><span class="line">  props: [<span class="string">&#x27;title&#x27;</span>],</span><br><span class="line">  template: <span class="string">&#x27;&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="监听子组件事件"><a href="#监听子组件事件" class="headerlink" title="监听子组件事件"></a>监听子组件事件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;blog-post</span><br><span class="line">  ...</span><br><span class="line">  v-on:enlarge-text=&quot;postFontSize += 0.1&quot;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 同时子组件可以通过调用内建的 $emit 方法并传入事件名称来触发一个事件：</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;$emit(&#x27;enlarge-text&#x27;)&quot;</span>&gt;</span></span><br><span class="line">  Enlarge text</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用事件抛出一个值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;$emit(&#x27;enlarge-text&#x27;, 0.1)&quot;</span>&gt;</span></span><br><span class="line">  Enlarge text</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在组件上使用v-model"><a href="#在组件上使用v-model" class="headerlink" title="在组件上使用v-model"></a>在组件上使用v-model</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;searchText&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等价于 --&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;input</span><br><span class="line">  v-bind:value=&quot;searchText&quot;</span><br><span class="line">  v-on:input=&quot;searchText = $event.target.value&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>当用在组件上时，v-model 则会这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;custom-input</span><br><span class="line">  v-bind:value=&quot;searchText&quot;</span><br><span class="line">  v-on:input=&quot;searchText = $event&quot;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了让它正常工作，这个组件内的 <input> 必须：<br>将其 value attribute 绑定到一个名叫 value 的 prop 上<br>在其 input 事件被触发时，将新的值通过自定义的 input 事件抛出</p><p>写成代码之后是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;custom-input&#x27;</span>, &#123;</span><br><span class="line">  props: [<span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      v-bind:value=&quot;value&quot;</span></span><br><span class="line"><span class="string">      v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在 v-model 就应该可以在这个组件上完美地工作起来了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">custom-input</span> <span class="attr">v-model</span>=<span class="string">&quot;searchText&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="通过插槽分发内容"><a href="#通过插槽分发内容" class="headerlink" title="通过插槽分发内容"></a>通过插槽分发内容</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;alert-box&#x27;, &#123;</span><br><span class="line">  template: `</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo-alert-box&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">strong</span>&gt;</span>Error!<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><p>有的时候，在不同组件之间进行动态切换是非常有用的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">&quot;currentTabComponent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h2><p>定义组件名的方式：</p><ul><li>使用kebab-case:以短横线分隔命名，你也必须在引用这个自定义元素时使用 kebab-case，例如 <code>&lt;my-component-name&gt;</code>。</li><li>使用 PascalCase:首字母大写命名定义组件，你在引用这个自定义元素时两种命名法都可以使用。也就是说 <code>&lt;my-component-name&gt;</code> 和 <code>&lt;MyComponentName&gt; </code>都是可接受的</li></ul><h3 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;my-component-name&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// ... 选项 ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">&#x27;component-a&#x27;</span>: ComponentA,</span><br><span class="line">    <span class="string">&#x27;component-b&#x27;</span>: ComponentB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Css单位px,rem,em,vw,vh的区别</title>
      <link href="/ZJY.github.io/2021/02/19/Css%E5%8D%95%E4%BD%8Dpx-rem-em-vw-vh%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/ZJY.github.io/2021/02/19/Css%E5%8D%95%E4%BD%8Dpx-rem-em-vw-vh%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="px"><a href="#px" class="headerlink" title="px"></a>px</h2><p>px就是pixel像素的缩写，相对长度单位，网页设计常用的基本单位。像素px是相对于显示器屏幕分辨率而言的</p><h2 id="em"><a href="#em" class="headerlink" title="em"></a>em</h2><p>em是相对长度单位。相对于当前对象内文本的字体尺寸（参考物是父元素的font-size）</p><p>如当前父元素的字体尺寸未设置，则相对于浏览器的默认字体尺寸</p><h2 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h2><p>rem是CSS3新增的一个相对单位，rem是相对于HTML根元素的字体大小（font-size）来计算的长度单位</p><p>如果你没有设置html的字体大小，就会以浏览器默认字体大小，一般是16px<br>html{font-size: 62.5%}  /* 10 ÷ 16 × 100% = 62.5% */</p><p>em与rem的区别：</p><p>　　rem是相对于根元素（html）的字体大小，而em是相对于其父元素的字体大小</p><p>两者使用规则：</p><p>  如果这个属性根据它的font-size进行测量，则使用em<br>  其他的一切事物属性均使用rem</p><h2 id="vw、vh"><a href="#vw、vh" class="headerlink" title="vw、vh"></a>vw、vh</h2><p>vw、vh、vmax、vmin这四个单位都是基于视口<br>vw是相对视口（viewport）的宽度而定的，长度等于视口宽度的1/100</p><p>假如浏览器的宽度为200px，那么1vw就等于2px（200px/100）</p><p>vh是相对视口（viewport）的高度而定的，长度等于视口高度的1/100</p><p>假如浏览器的高度为500px，那么1vh就等于5px（500px/100）</p><p>vmin和vmax是相对于视口的高度和宽度两者之间的最小值或最大值</p><p>如果浏览器的高为300px、宽为500px，那么1vmin就是3px，1vmax就是5px；如果浏览器的高为800px，宽为1080px，那么1vmin也是8px，1vmax也是10.8px</p><h2 id="（百分比）"><a href="#（百分比）" class="headerlink" title="%（百分比）"></a>%（百分比）</h2><p>一般来说就是相对于父元素</p><p>1、对于普通定位元素就是我们理解的父元素</p><p>2、对于position: absolute;的元素是相对于已定位的父元素</p><p>3、对于position: fixed;的元素是相对于ViewPort（可视窗口）</p><h2 id="vm"><a href="#vm" class="headerlink" title="vm"></a>vm</h2><p>css3新单位，相对于视口的宽度或高度中较小的那个</p><p>其中最小的那个被均分为100单位的vm</p><p>比如：浏览器高度900px，宽度1200px，取最小的浏览器高度，1 vm = 900px/100 = 9 px</p><p>缺点：兼容性差</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5基础</title>
      <link href="/ZJY.github.io/2021/02/19/HTML5/"/>
      <url>/ZJY.github.io/2021/02/19/HTML5/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><h3 id="开始学习HTML5"><a href="#开始学习HTML5" class="headerlink" title="开始学习HTML5"></a>开始学习HTML5</h3><h4 id="HTML5-简介"><a href="#HTML5-简介" class="headerlink" title="HTML5 简介"></a>HTML5 简介</h4><ul><li>HTML5是HTML最新的修订版本，2014年10月由万维网联盟（W3C）完成标准制定。</li><li>HTML5的设计目的是为了在移动设备上支持多媒体。</li></ul><h4 id="什么是-HTML5"><a href="#什么是-HTML5" class="headerlink" title="什么是 HTML5?"></a>什么是 HTML5?</h4><ul><li>HTML5 是下一代 HTML 标准。</li><li>HTML , HTML 4.01的上一个版本诞生于 1999 年。自从那以后，Web 世界已经经历了巨变。</li><li>HTML5 仍处于完善之中。然而，大部分现代浏览器已经具备了某些 HTML5 支持。</li><li>HTML5 受包括Firefox（火狐浏览器），IE9及其更高版本，Chrome（谷歌浏览器），Safari，Opera等国外主流浏览器的支持；国内的傲游浏览器（Maxthon）， 360浏览器、搜狗浏览器、QQ浏览器、猎豹浏览器等同样具备支持HTML5的能力。</li></ul><h4 id="HTML5-lt-DOCTYPE-gt"><a href="#HTML5-lt-DOCTYPE-gt" class="headerlink" title="HTML5 &lt;!DOCTYPE&gt;"></a>HTML5 &lt;!DOCTYPE&gt;</h4><!doctype><p> 声明必须位于 HTML5 文档中的第一行,使用非常简单:<code>&lt;!doctype html&gt;</code></p><h4 id="最小的HTML5文档"><a href="#最小的HTML5文档" class="headerlink" title="最小的HTML5文档"></a>最小的HTML5文档</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="HTML5的改进"><a href="#HTML5的改进" class="headerlink" title="HTML5的改进"></a>HTML5的改进</h4><ul><li>新元素</li><li>新属性</li><li>完全支持 CSS3</li><li>Video 和 Audio</li><li>2D/3D 制图</li><li>本地存储</li><li>本地 SQL 数据</li><li>Web 应用</li></ul><h4 id="HTML5多媒体"><a href="#HTML5多媒体" class="headerlink" title="HTML5多媒体"></a>HTML5多媒体</h4><p>使用 HTML5 你可以简单的在网页中播放 视频(video)与音频 (audio) 。</p><ul><li>html5 <code>&lt;video/&gt;</code></li><li>html5 <code>&lt;audio/&gt;</code></li></ul><h4 id="HTML5-图形"><a href="#HTML5-图形" class="headerlink" title="HTML5 图形"></a>HTML5 图形</h4><p>使用 HTML5 你可以简单的绘制图形:</p><ul><li>使用 <code>&lt;canvas&gt;</code> 元素</li><li>使用内联 SVG</li><li>使用 CSS3 2D/CSS 3D</li></ul><h4 id="HTML5-使用-CSS3"><a href="#HTML5-使用-CSS3" class="headerlink" title="HTML5 使用 CSS3"></a>HTML5 使用 CSS3</h4><ul><li>新选择器</li><li>新属性</li><li>动画</li><li>2D/3D 转换</li><li>圆角</li><li>阴影效果</li><li>可下载的字体</li></ul><h4 id="语义要素"><a href="#语义要素" class="headerlink" title="语义要素"></a>语义要素</h4><p>HTML5 添加了很多语义元素如下所示：</p><ul><li>article: 定义页面独立的内容区域。</li><li>aside:定义页面的侧边栏内容</li><li>bdi:允许您设置一段文本，使其脱离其父元素的文本方向设置。</li><li>command:定义命令按钮，比如单选按钮、复选框或按钮</li><li>details:用于描述文档或文档某个部分的细节</li><li>dialog:定义对话框，比如提示框</li><li>summary: 标签包含 details 元素的标题</li><li>figure:规定独立的流内容（图像、图表、照片、代码等等）</li><li>figcaption:定义 <code>&lt;figure&gt; </code>元素的标题</li><li>footer:定义 section 或 document 的页脚。</li><li>header:定义了文档的头部区域</li><li>mark:定义带有记号的文本。</li><li>meter:定义度量衡。仅用于已知最大和最小值的度量</li><li>nav:定义导航链接的部分。</li><li>progress:定义任何类型的任务的进度</li><li>ruby:定义 ruby 注释（中文注音或字符）</li><li>rt:定义字符（中文注音或字符）的解释或发音。</li><li>rp:在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容</li><li>section:定义文档中的节（section、区段）</li><li>time:定义日期或时间。</li><li>wbr:规定在文本中的何处适合添加换行符</li></ul><h4 id="HTML5-新特性"><a href="#HTML5-新特性" class="headerlink" title="HTML5 - 新特性"></a>HTML5 - 新特性</h4><ul><li>用于绘画的 canvas 元素</li><li>用于媒介回放的 video 和 audio 元素</li><li>对本地离线存储的更好的支持</li><li>新的特殊内容元素，比如 article、footer、header、nav、section</li><li>新的表单控件，比如 calendar、date、time、email、url、search</li></ul><h3 id="HTML5-浏览器支持"><a href="#HTML5-浏览器支持" class="headerlink" title="HTML5 浏览器支持"></a>HTML5 浏览器支持</h3><ul><li>HTML5 浏览器支持<br>  现代的浏览器都支持 HTML5。<br>  此外，所有浏览器，包括旧的和最新的，对无法识别的元素会作为内联元素自动处理。<br>  正因为如此，你可以 “教会” 浏览器处理 “未知” 的 HTML 元素。</li><li>将 HTML5 元素定义为块元素<br>  HTML5 定了 8 个新的 HTML 语义（semantic）  元素。所有这些元素都是块级 元素。<br>  为了能让旧版本的浏览器正确显示这些元素，你可以设置 CSS 的 display 属性值为 block:<br>  header, section, footer, aside, nav, main, article, figure {display: block;}</li><li>为 HTML 添加新元素</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> newEle = <span class="built_in">document</span>.createElement(<span class="string">&#x27;myHero&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> content = <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;myHero&#x27;</span>);</span></span><br><span class="line">        newEle.appendChild(content)</span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.body.appendChild(newEle);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    myHero&#123;</span><br><span class="line"><span class="css">        <span class="selector-tag">background-color</span><span class="selector-pseudo">:red</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">padding</span><span class="selector-pseudo">:30px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Internet Explorer 浏览器问题<ul><li>你可以使用以上的方法来为 IE 浏览器添加 HTML5 元素，但是Internet Explorer 8 及更早 IE 版本的浏览器不支持以上的方式.针对IE浏览器html5shiv 是比较好的解决方案。html5shiv主要解决HTML5提出的新的元素不被IE6-8识别，这些新元素不能作为父节点包裹子元素，并且不能应用CSS样式。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- [<span class="keyword">if</span> It IE <span class="number">9</span>] --&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;/html5shiv.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- [endif] --&gt;</span><br></pre></td></tr></table></figure><ul><li>完美的 Shiv 解决方案<ul><li>html5shiv.js 引用代码必须放在  <code>&lt;head&gt;</code> 元素中，因为 IE 浏览器在解析 HTML5 新元素时需要先加载该文件。</li></ul></li></ul><h3 id="HTML5-新元素"><a href="#HTML5-新元素" class="headerlink" title="HTML5 新元素"></a>HTML5 新元素</h3><h4 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h4><p>什么是canvas？<br>  标签定义图形，比如图表和其他图像。该标签基于javascript的绘图API。<br>创建画布<br>  画布在网页中是一个矩形框，通过<code>&lt;canvas&gt;</code>元素来绘制</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;myCanvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>使用 JavaScript 来绘制图像<br>  canvas本身没有绘图能力，所以绘图工作必须在js内完成：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = c.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">ctx.fillStyle=<span class="string">&quot;#ffffff&quot;</span>;</span><br><span class="line">ctx.fillRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">150</span>,<span class="number">75</span>);</span><br></pre></td></tr></table></figure><p>canvas-坐标<br>  canvas是一个二维网络，左上角坐标为（0，0）<br>  ctx.fillRect(0,0,150,75);在画布上绘制150*75的矩形，从左上角开始</p><p>canvas-路径<br>  moveTo(x,y) 定义线条开始坐标<br>  lineTo(x,y) 定义线条结束坐标</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx.moveTo(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">ctx.lineTo(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line">ctx.stroke();<span class="comment">//绘制线条</span></span><br></pre></td></tr></table></figure><p>  绘制圆形：arc(x,y,r,start,stop)</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx.begainPath();</span><br><span class="line">ctx.arc(<span class="number">0</span>,<span class="number">0</span>,<span class="number">40</span>,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p>canvas-文本<br>  fillText(text,x,y,[maxWidth]);</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx.font = <span class="string">&#x27;30px arial&#x27;</span>;</span><br><span class="line">ctx.fillText(<span class="string">&#x27;hello,world&quot;,10,50)</span></span><br></pre></td></tr></table></figure><p>canvas-渐变</p><p>  渐变可以填充在矩形，圆形，线条，文本等，可以定义不同的颜色<br>  createLinearGradient(x,y,x1,y1);//线条渐变<br>  createRadialGradient(x,y,r,x1,y1,r1);//径向/圆渐变<br>  当我们使用渐变对象，必须使用两种或两种以上的停止颜色<br>  addColorStop()方法指定颜色停止，参数使用坐标来描述，可以是0至1.<br>  设置fillStyle或strokeStyle的值为渐变，然后绘制形状，如矩形，文本，或一条线。<br>  使用createLinearGradient：创建一个线性渐变，使用渐变填充矩形</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//create gradient</span></span><br><span class="line"><span class="keyword">var</span> grd = ctx.createLinearGradient(<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">0</span>);</span><br><span class="line">grd.addColorStop(<span class="number">0</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line">grd.addColorStop(<span class="number">1</span>,<span class="string">&#x27;white&#x27;</span>);</span><br><span class="line"><span class="comment">//fill width gradient</span></span><br><span class="line">ctx.fillStyle = grd;</span><br><span class="line">ctx.fillRect(<span class="number">10</span>,<span class="number">10</span>,<span class="number">150</span>,<span class="number">80</span>);</span><br></pre></td></tr></table></figure><p>  使用createRadialGradient：创建一个径向/圆渐变，使用渐变填充矩形</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> grd = ctx.createRadialGradient(<span class="number">75</span>,<span class="number">50</span>,<span class="number">5</span>,<span class="number">90</span>,<span class="number">60</span>,<span class="number">100</span>);</span><br><span class="line">grd.addColorStop(<span class="number">0</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line">grd.addColorStop(<span class="number">1</span>,<span class="string">&#x27;white&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.fillStyle= grd;</span><br><span class="line">ctx.fillRect(<span class="number">10</span>,<span class="number">10</span>,<span class="number">150</span>,<span class="number">80</span>);</span><br></pre></td></tr></table></figure><p>  createRadialGradient(x , y , r , x1 , y1 , r1) 括号内的参数有如下的含义:<br>  x：表示渐变的开始圆的 x 坐标<br>  y：表示渐变的开始圆的 y 坐标<br>  r：表示开始圆的半径<br>  x1：表示渐变的结束圆的 x 坐标<br>  y1：表示渐变的结束圆的 y 坐标<br>  r1：表示结束圆的半径</p><p>canvas-图像<br>  drawImage(image,x,y)</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.getElementById(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">ctx.drawImage(img,<span class="number">10</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h4 id="新多媒体元素"><a href="#新多媒体元素" class="headerlink" title="新多媒体元素"></a>新多媒体元素</h4><ul><li>audio音频</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;audio.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;aduio/ogg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;audio.mp3&quot;</span> <span class="attr">type</span>=<span class="string">&quot;aduio/mpeg&quot;</span>&gt;</span></span><br><span class="line">  您的浏览器不支持audio元素</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><p>control 属性供添加播放、暂停和音量控件<br>在<code>&lt;audio&gt;</code> 与 <code>&lt;/audio&gt;</code> 之间你需要插入浏览器不支持的<code>&lt;audio&gt;</code>元素的提示文本 。<br><code>&lt;audio&gt;</code> 元素允许使用多个 <code>&lt;source&gt;</code> 元素. <code>&lt;source&gt;</code> 元素可以链接不同的音频文件，浏览器将使用第一个支持的音频文件</p><ul><li>video视频</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> <span class="attr">width</span>=<span class="string">&quot;320&quot;</span> <span class="attr">height</span>=<span class="string">&quot;240&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;movie.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/ogg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;movie.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line">  您的浏览器不支持video元素</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;video&gt;</code>元素提供了播放、暂停和音量控件来控制视频。<br>同时<code>&lt;video&gt;</code>元素也提供了 width 和 height 属性控制视频的尺寸.如果设置的高度和宽度，所需的视频空间会在页面加载时保留。。如果没有设置这些属性，浏览器不知道大小的视频，浏览器就不能再加载时保留特定的空间，页面就会根据原始视频的大小而改变。<br>元素支持多个source元素. 元素可以链接不同的视频文件。浏览器将使用第一个可识别的格式<br>元素支持三种视频格式： MP4, WebM, 和 Ogg:</p><ul><li><p>source<br><code>&lt;source&gt;</code> 标签可以为<code>&lt;picture&gt;</code>、<code>&lt;audio&gt;</code>或<code>&lt;video&gt;</code>元素指定一个或者多个的媒体资源</p></li><li><p>embed<br>定义嵌入的内容，比如插件，定义了一个容器，用来嵌入外部应用或者互动程序（插件）<br>属性：<br>height：规定嵌入内容的高度<br>src: 规定嵌入内容的url<br>type: 规定嵌入内容的MIME类型<br>width: 规定嵌入内容的宽带</p></li><li><p>track<br>为诸如 <code>&lt;video&gt;</code> 和 <code>&lt;audio&gt;</code> 元素之类的媒介规定外部文本轨道<br><code>&lt;track&gt;</code> 标签用作 <code>&lt;audio&gt;</code> 元素和 <code>&lt;video&gt; </code>元素的子级，它允许您指定定时文本轨道（或基于时间的数据），采用 WebVTT 格式（.vtt 文件）</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> <span class="attr">width</span>=<span class="string">&quot;320&quot;</span> <span class="attr">height</span>=<span class="string">&quot;240&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;movie.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/ogg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;movie.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">track</span> <span class="attr">src</span>=<span class="string">&quot;subtitle_en.vtt&quot;</span> <span class="attr">kind</span>=<span class="string">&quot;subtitles&quot;</span> <span class="attr">srclang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">label</span>=<span class="string">&quot;English&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">track</span> <span class="attr">src</span>=<span class="string">&quot;subtitle_zh.vtt&quot;</span> <span class="attr">kind</span>=<span class="string">&quot;subtitles&quot;</span> <span class="attr">srclang</span>=<span class="string">&quot;zh&quot;</span> <span class="attr">label</span>=<span class="string">&quot;Zh&quot;</span>&gt;</span></span><br><span class="line">  您的浏览器不支持video元素</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个元素用于规定字幕文件或其他包含文本的文件，当媒体播放时，这些文件是可见的。</p><h4 id="新表单元素"><a href="#新表单元素" class="headerlink" title="新表单元素"></a>新表单元素</h4><ul><li>datalist<br>定义选项列表。请与 input 元素配合使用该元素，来定义 input 可能的值<ul><li><code>&lt;datalist&gt;</code> 标签规定了 <code>&lt;input&gt;</code> 元素可能的选项列表。</li><li><code>&lt;datalist&gt;</code> 标签被用来在为 <code>&lt;input&gt;</code> 元素提供”自动完成”的特性。用户能看到一个下拉列表，里边的选项是预先定义好的，将作为用户的输入数据。</li><li>请使用 <code>&lt;input&gt;</code> 元素的 list 属性来绑定 <code>&lt;datalist&gt;</code> 元素。</li><li>提示：不能控制 datalist 的位置，并且不能将其与服务器的数据进行绑定。</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">list</span>=<span class="string">&quot;browser&quot;</span> <span class="attr">name</span>=<span class="string">&quot;browser&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">&quot;browser&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;IE&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Firefox&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;chrome&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Opera&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;safari&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>keygen</p><ul><li>规定用于表单的密钥对生成器字段</li><li>当提交表单时，私钥存储在本地，公钥发送到服务器。</li></ul></li><li><p>output</p><ul><li>定义不同类型的输出，比如脚本的输出</li></ul></li></ul><h4 id="新的语义和结构元素"><a href="#新的语义和结构元素" class="headerlink" title="新的语义和结构元素"></a>新的语义和结构元素</h4><ul><li><p>article：定义页面独立的内容区域，主要是布局文章、内容方面的内容</p></li><li><p>aside：定义页面的侧边栏内容。<code>&lt;aside&gt;</code> 标签定义 <code>&lt;article&gt;</code> 标签外的内容</p></li><li><p>bdi:标签允许您设置一段文本，使其脱离其父元素的文本方向设置</p></li><li><p>figure: 标签规定独立的流内容（图像、图表、照片、代码等等）,figure 元素的内容应该与主内容相关，但如果被删除，则不应对文档流产生影响</p></li><li><p>footer:标签定义文档document或节section的页脚。页脚通常包含文档的作者、版权信息、使用条款链接、联系信息等等。您可以在一个文档中使用多个 <code>&lt;footer&gt; </code>元素。</p></li><li><p>header:定义了文档的头部区域,表示介绍性的内容，可以让您了解页面涉及的内容，具有导航性.在一个文档中，您可以定义多个 <code>&lt;header&gt;</code> 元素。注释：<code>&lt;header&gt;</code> 标签不能被放在 <code>&lt;footer&gt;</code>、<code>&lt;address&gt;</code> 或者另一个 <code>&lt;header&gt;</code> 元素内部。</p></li><li><p>mark:带有记号的文本，请在需要突出显示文本时使用 <code>&lt;mark&gt; </code>标签。</p></li><li><p>meter：定义度量衡。仅用于已知最大和最小值的度量<code>&lt;meter min=&quot;0&quot; max=&quot;10&quot; value=&quot;5&quot;&gt;5 out of 10&lt;/meter&gt;</code></p></li><li><p>nav:标签定义导航链接的部分,如果文档中有“前后”按钮，则应该把它放到 <code>&lt;nav&gt; </code>元素中。</p></li><li><p>progress:标签标示任务的进度</p></li><li><p>ruby:标签定义 ruby 注释（中文注音或字符）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ruby</span>&gt;</span></span><br><span class="line">    王 <span class="tag">&lt;<span class="name">rp</span>&gt;</span>(<span class="tag">&lt;/<span class="name">rp</span>&gt;</span><span class="tag">&lt;<span class="name">rt</span>&gt;</span> wang <span class="tag">&lt;/<span class="name">rt</span>&gt;</span><span class="tag">&lt;<span class="name">rp</span>&gt;</span>)<span class="tag">&lt;/<span class="name">rp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ruby</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将 <code>&lt;ruby&gt;</code> 标签与 <code>&lt;rt&gt;</code> 和 <code>&lt;rp&gt; </code>标签一起使用<br>rt:定义字符（中文注音或字符）的解释或发音<br>rp:在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容</p></li><li><p>section:定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。</p></li><li><p>time:用来表示HTML网页中出现的日期和时间，目的是让搜索引擎等其它程序更容易的提取这些信息。<code>&lt;time&gt;</code> 标签不会在任何浏览器中呈现任何特殊效果，只是用来给机器识别的。</p></li><li><p>wbr:可以用来定义HTML文档中需要进行换行的位置，与<code>&lt;br&gt;</code>标签不同，如果浏览器窗口的宽度足够，则不换行；反之，则在添加了 <code>&lt;wbr&gt;</code> 标签的位置进行换行</p></li></ul><h3 id="HTML5-内联-SVG"><a href="#HTML5-内联-SVG" class="headerlink" title="HTML5 内联 SVG"></a>HTML5 内联 SVG</h3><p>SVG表示可缩放矢量图形，是基于可扩展标记语言（标准通用标记语言的子集），用于描述二维矢量图形的一种图形格式，它在2003年1月14日成为W3C推荐标准。<br>什么是SVG?</p><ul><li>SVG 指可伸缩矢量图形 (Scalable Vector Graphics)</li><li>SVG 用于定义用于网络的基于矢量的图形</li><li>SVG 使用 XML 格式定义图形</li><li>SVG 图像在放大或改变尺寸的情况下其图形质量不会有损失</li><li>SVG 是万维网联盟的标准</li><li>SVG 与 DOM 和 XSL 之类的 W3C 标准是一个整体</li></ul><p>与其他图像格式相比（比如 JPEG 和 GIF），使用 SVG 的优势在于：</p><ul><li>SVG 图像可通过文本编辑器来创建和修改</li><li>SVG 图像可被搜索、索引、脚本化或压缩</li><li>SVG 是可伸缩的</li><li>SVG 图像可在任何的分辨率下被高质量地打印</li><li>SVG 可在图像质量不下降的情况下被放大</li></ul><p>SVG 与 Canvas两者间的区别:</p><ul><li>SVG 是一种使用 XML 描述 2D 图形的语言。</li><li>Canvas 通过 JavaScript 来绘制 2D 图形</li><li>SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器</li><li>在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形</li><li>Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。</li></ul><p>Canvas与SVG的比较<br>canvas：</p><ul><li>依赖分辨率</li><li>不支持事件处理器</li><li>弱的文本渲染能力</li><li>能够以png或jpg格式保存结果图像</li><li>最适合图像密集型游戏，其中的许多对象会被频繁重绘</li></ul><p>svg：</p><ul><li>不依赖分辨率</li><li>支持事件处理器</li><li>最适合带有大型渲染区域的应用程序（比如地图）</li><li>复杂度稿会减慢渲染速度（任何过度使用DOM的应用都不快）</li><li>不适合游戏应用</li></ul><h3 id="HTML5-拖放"><a href="#HTML5-拖放" class="headerlink" title="HTML5 拖放"></a>HTML5 拖放</h3><ul><li>HTML5 拖放（Drag 和 Drop）<ul><li>拖放的目的是可以让你将某个对象放置到你想要放置的位置。</li><li>拖放（Drag 和 drop）是 HTML5 标准的组成部分。</li><li>拖放是一种常见的特性，即抓取对象以后拖到另一个位置。</li><li>在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">allowDrop</span>(<span class="params">ev</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ev.preventDefault();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drag</span>(<span class="params">ev</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ev.dataTransfer.setData(<span class="string">&quot;Text&quot;</span>,ev.target.id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drop</span>(<span class="params">ev</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ev.preventDefault();</span><br><span class="line"><span class="keyword">var</span> data=ev.dataTransfer.getData(<span class="string">&quot;Text&quot;</span>);</span><br><span class="line">ev.target.appendChild(<span class="built_in">document</span>.getElementById(data));</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;p&gt;请把 W3School 的图片拖放到矩形中：&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">&quot;div1&quot;</span> ondrop=<span class="string">&quot;drop(event)&quot;</span> ondragover=<span class="string">&quot;allowDrop(event)&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">&lt;img id=<span class="string">&quot;drag1&quot;</span> src=<span class="string">&quot;/i/eg_dragdrop_w3school.gif&quot;</span> draggable=<span class="string">&quot;true&quot;</span> ondragstart=<span class="string">&quot;drag(event)&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p>设置元素为可拖放:<code>&lt;img draggable=&quot;true&quot;&gt;</code><br>拖动什么 - ondragstart 和 setData()<br>放到何处 - ondragover,ondragover 事件规定在何处放置被拖动的数据。<br>默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。<br>这要通过调用 ondragover 事件的 event.preventDefault() 方法<br>进行放置 - ondrop</p><h3 id="HTML5-地理定位"><a href="#HTML5-地理定位" class="headerlink" title="HTML5 地理定位"></a>HTML5 地理定位</h3><p>HTML5 Geolocation（地理定位）用于定位用户的位置<br>Geolocation 通过请求一个位置信息，用户同意后，浏览器会返回一个包含经度和维度的位置信息</p><p>定位用户的位置:<br>  HTML5 Geolocation API 用于获得用户的地理位置<br>  鉴于该特性可能侵犯用户的隐私，除非用户同意，否则用户位置信息是不可用的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;p id=<span class="string">&quot;demo&quot;</span>&gt;点击按钮获取您当前坐标：&lt;/p&gt;</span><br><span class="line">&lt;button onclick=<span class="string">&quot;getLocation()&quot;</span>&gt;click me&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;demo&#x27;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getLocation</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(navigator.geolocation)&#123;</span><br><span class="line">            navigator.geolocation.getCurrentPosition(showPosition);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            x.innerHTML =<span class="string">&#x27;该浏览器不支持获取地理位置&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">showPosition</span>(<span class="params">position</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(position)</span><br><span class="line">        x.innerHTML = <span class="string">&#x27;纬度：&#x27;</span>+ position.coords.latitude+<span class="string">&#x27;&lt;br&gt;经度：&#x27;</span>+position.coords.longitude</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> HTML5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http常见面试题</title>
      <link href="/ZJY.github.io/2021/02/05/http%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/ZJY.github.io/2021/02/05/http%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="1-HTTP基本概念"><a href="#1-HTTP基本概念" class="headerlink" title="1.HTTP基本概念"></a>1.HTTP基本概念</h2><h3 id="1-1-http是什么？"><a href="#1-1-http是什么？" class="headerlink" title="1.1 http是什么？"></a>1.1 http是什么？</h3><p>http是超文本传输协议，也就是HyperText Transfer Protocaol。</p><ul><li>协议<ul><li>http是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式</li></ul></li><li>传输<ul><li>http协议是一个双向协议</li><li>http是一个在计算机世界里专门用来在两点之间传输数据的约定和规范<br>  我们在上网冲浪时，浏览器是请求方 A ，百度网站就是应答方 B。双方约定用 HTTP 协议来通信，于是浏览器把请求数据发送给网站，网站再把一些数据返回给浏览器，最后由浏览器渲染在屏幕，就可以看到图片、视频了。<br>  数据虽然是在 A 和 B 之间传输，但允许中间有中转或接力。<br>  就好像第一排的同学想穿递纸条给最后一排的同学，那么传递的过程中就需要经过好多个同学（中间人），这样的传输方式就从「A &lt; — &gt; B」，变成了「A &lt;-&gt; N &lt;-&gt; M &lt;-&gt; B」。<br>  而在 HTTP 里，需要中间人遵从 HTTP 协议，只要不打扰基本的数据传输，就可以添加任意额外的东西。</li></ul></li><li>超文本<ul><li>http传输的内容是超文本</li><li>我们先来理解「文本」，在互联网早期的时候只是简单的字符文字，但现在「文本」的涵义已经可以扩展为图片、视频、压缩包等，在 HTTP 眼里这些都算做「文本」</li><li>再来理解「超文本」，它就是超越了普通文本的文本，它是文字、图片、视频等的混合体最关键有超链接，能从一个超文本跳转到另外一个超文本</li><li>HTML 就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，在经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了</li></ul></li></ul><p><b>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</b></p><h3 id="1-2-「HTTP-是用于从互联网服务器传输超文本到本地浏览器的协议HTTP」-这种说法正确吗？"><a href="#1-2-「HTTP-是用于从互联网服务器传输超文本到本地浏览器的协议HTTP」-这种说法正确吗？" class="headerlink" title="1.2 「HTTP 是用于从互联网服务器传输超文本到本地浏览器的协议HTTP」,这种说法正确吗？"></a>1.2 「HTTP 是用于从互联网服务器传输超文本到本地浏览器的协议HTTP」,这种说法正确吗？</h3><p>这种说法是不正确的。因为也可以是「服务器&lt; – &gt;服务器」，所以采用两点之间的描述会更准确</p><h3 id="1-3-http常见的状态吗有哪些？"><a href="#1-3-http常见的状态吗有哪些？" class="headerlink" title="1.3 http常见的状态吗有哪些？"></a>1.3 http常见的状态吗有哪些？</h3><ul><li>1xx<ul><li>1xx类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少</li></ul></li><li>2xx<ul><li>2xx类状态码表示服务器成功处理了客户端的请求。</li><li>200 ok是最常见的成功状态码，表示一切正常。如果是非HEAD请求，服务器返回的相应头都会有body数据。</li><li>204 no content也是常见的成功状态码，与200基本相同，但响应头没有body数据。</li><li>206 partial content是应用于http分块下载或断电续传。表示响应返回的body数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li></ul></li><li>3xx<ul><li>3xx类状态码表示客户端请求的资源发生了变动，需要客户端用新的URL重新发送请求获取资源，也就是重定向。</li><li>301 Moved Permanently 表示永久重定向，说明请求的资源已经不在了，需要用另一个url再次访问</li><li>302 临时重定向，说明请求的资源还在，但暂时需要用另一个url来访问</li><li>301和302都会在响应头里使用字段location，指明后续要跳转的url，浏览器会自动重定向新的url。</li><li>304 not modified不具有跳转的含义，表示资源未被修改，重定向已存在的缓冲文件，也称为缓存重定向，用于缓存控制。</li></ul></li><li>4xx<ul><li>4xx类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。</li><li>400 bad request表示客户端请求的报文有误，但只是个笼统的错误</li><li>401 用户没有访问权限,需要进行身份认证</li><li>403 forbidden表示服务器禁止访问资源，并不是客户端的请求出错</li><li>404 not found表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul></li><li>5xx<ul><li>5xx类状态码表示客户端请求报文正确，但服务器处理时内部发生了错误，属于服务端的错误码。</li><li>500 internal server error，与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li><li>501 not implemented 表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li><li>502 bad gateway，通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误</li><li>503 service unavailable表示服务器当前很忙，暂时无法响应服务器。</li></ul></li></ul><h3 id="1-4-http常见字段有哪些？"><a href="#1-4-http常见字段有哪些？" class="headerlink" title="1.4 http常见字段有哪些？"></a>1.4 http常见字段有哪些？</h3><ul><li>Host<ul><li>客户端发送请求时，用来指定服务器的域名</li><li>host:http:<a href="http://www.a.com/">www.a.com</a></li><li>有了host字段，就可以将请求发往同一台服务器的不同网站</li></ul></li><li>Content-Length<ul><li>服务器在返回数据时，会有content-length字段，表明本次回应的数据长度</li></ul></li><li>Connection字段<ul><li>Connection字段最常用于客户端要求服务器使用TCP持久连接，以便其他请求复用。Connection: keep-alive</li></ul></li><li>Content-Type字段<ul><li>Content-Type字段用于服务器返回时，告诉客户端本次数据返回什么格式。</li><li>Content-Type: text/html; charset=utf-8</li><li>上面的类型表明，发送的是网页，而且编码是UTF-8</li><li>客户端请求的时候，可以使用 Accept 字段声明自己可以接受哪些数据格式</li><li>Accept: <em>/</em></li><li>上面代码中，客户端声明自己可以接受任何格式的数据。</li></ul></li><li>Content-Encoding字段<ul><li>Content-Encoding 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</li><li>Content-Encoding: gzip</li><li>上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。</li><li>客户端在请求时，用 Accept-Encoding 字段说明自己可以接受哪些压缩方法</li><li>Accept-Encoding: gzip, deflate</li></ul></li></ul><h2 id="2-GET和POST"><a href="#2-GET和POST" class="headerlink" title="2.GET和POST"></a>2.GET和POST</h2><h3 id="2-1get和post的区别？"><a href="#2-1get和post的区别？" class="headerlink" title="2.1get和post的区别？"></a>2.1get和post的区别？</h3><ul><li>get方法含义是请求从服务器获取资源，这个资源可以是静态的文本、页面、图片视频等。比如打开一篇文章，浏览器会发送get请求给服务器，服务器就会返回文章所有资源。</li><li>post方法向url指定的资源提交数据，数据就放在报文的body里。比如在一篇文章底部，提交留言板，浏览器就会执行一次post请求，把你的留言文字放进报文body里然后拼接好post请求，通过tcp协议发送给服务器。</li></ul><h3 id="2-2-get和post-方法都是安全和幂等的吗？"><a href="#2-2-get和post-方法都是安全和幂等的吗？" class="headerlink" title="2.2 get和post 方法都是安全和幂等的吗？"></a>2.2 get和post 方法都是安全和幂等的吗？</h3><ul><li>安全：在http协议里，所谓的安全是指请求方法不会破坏服务器上的资源。</li><li>幂等：多次执行相同的操作，结果都是相同的。</li><li>get方法就是安全且幂等的，因为它是只读操作，无论操作多少次，服务器上的数据是安全的，且每次的结果都是相同的。</li><li>post是新增或提交数据的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。</li></ul><h2 id="3-http的特性"><a href="#3-http的特性" class="headerlink" title="3.http的特性"></a>3.http的特性</h2><h3 id="3-1-你知道的-HTTP（1-1）-的优点有哪些，怎么体现的？"><a href="#3-1-你知道的-HTTP（1-1）-的优点有哪些，怎么体现的？" class="headerlink" title="3.1 你知道的 HTTP（1.1） 的优点有哪些，怎么体现的？"></a>3.1 你知道的 HTTP（1.1） 的优点有哪些，怎么体现的？</h3><p>http最凸出的优点是简单、灵活和易于扩展、应用广泛和跨平台。</p><ul><li>简单：http最基本的报文格式是header+body，头部信息也是key-value简单文本的形式。易于理解降低学习和使用门槛。</li><li>灵活和易于扩展：<ul><li>http协议里的各类请求方法、URL/URI、状态码、头字段等每个组成要求都没被固定死，都允许开发人员自定义和扩展。</li><li>http工作在应用层，则它下层可以随意变化</li><li>HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP3 甚至把 TCPP 层换成了基于 UDP 的 QUIC。</li></ul></li><li>应用广泛和跨平台</li></ul><h3 id="3-2-http的缺点？"><a href="#3-2-http的缺点？" class="headerlink" title="3.2 http的缺点？"></a>3.2 http的缺点？</h3><p>http协议里有优缺点一体的双刃剑，分别是无状态、明文传输，同时还有一大缺点不安全。</p><ul><li>无状态双刃剑<ul><li>无状态的好处，因为服务器不会去记忆http的状态，所以不需要额外的资源来记录状态信息，这可以减轻服务器的压力，能够把更多的cpu和内存用于对外提供服务</li><li>无状态的坏处，既然服务器没有记忆能力，在完成关联性的操作时会非常麻烦。例如登录-&gt;添加购物车-&gt;下单-&gt;结算-&gt;支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息</li></ul></li><li>明文传输双刃剑<ul><li>明文传输是在传输信息过程中，是可方便阅读的，在浏览器控制台和抓包可以直接肉眼查看，为开发者调试工作带来了便利。</li><li>但是就是因为这样，信息都暴露出来，容易泄漏，很容易被窃取。</li></ul></li><li>不安全<ul><li>通信使用明文，不加密，信息很容易被窃取。</li><li>不验证通信方的身份，很可能遭遇伪装，比如访问假的淘宝，京东</li><li>无法证明报文的完整性，所以有可能已遭篡改，比如网页植入广告</li><li>HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL/TLS 层，使得在安全上达到了极致。</li></ul></li></ul><h3 id="3-3-http1-1的性能？"><a href="#3-3-http1-1的性能？" class="headerlink" title="3.3 http1.1的性能？"></a>3.3 http1.1的性能？</h3><p>http协议是基于TCP/IPP，并且使用了请求-应答的通信模式，所以性能的关键就在这2点里。</p><ul><li>长连接<ul><li>早期http1.0性能上很大一个问题就是每发起一个请求，都要重新建立一次TCP连接（三次握手），而且是串行请求，做了无谓的TCP连接建立和断开，增加了通信的开销</li><li>为了解决上述的TCP连接问题，http1.1提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器的负载。</li><li>持久连接的特点是，只要任意一端没有明确说明断开连接则保持TCP连接状态。</li></ul></li><li>管道网络传输<ul><li>HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。</li><li>即在同一个TCP连接里，可发起多个请求，只要第一个请求发出去了，不必等其回来，就可发第二个请求出去，可以减少整体的响应时间。</li><li>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求</li><li>但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。要是 前面的回应特别慢，后面就会有许多请求排队等着。这称为「队头堵塞」。</li></ul></li><li>队头堵塞<ul><li>请求 - 应答的模式，加剧了http的性能问题。</li><li>因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，会导致后面的请求也被阻塞，客户端一直请求不到数据，这也就是对头阻塞。</li><li>总之 HTTP/1.1 的性能一般般，后续的 HTTP/2 和 HTTP/3 就是在优化 HTTP 的性能</li></ul></li></ul><h2 id="4-http和https"><a href="#4-http和https" class="headerlink" title="4.http和https"></a>4.http和https</h2><h3 id="4-1-HTTP-与-HTTPS-有哪些区别？"><a href="#4-1-HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="4.1 HTTP 与 HTTPS 有哪些区别？"></a>4.1 HTTP 与 HTTPS 有哪些区别？</h3><ul><li>http是超文本传输协议，信息是明文传输，存在安全隐患。https则解决了http不安全的问题，在TCP和HTTP网络层之间加入了SSL/TLS安全协议，使得报文能够加密传输。</li><li>http连接建立相对简单，TCP三次握手后就可进行http报文传输。而https在TCP三次握手之后，还需要进行SSL/TLS的握手过程，才可进入报文加密传输。</li><li>http的端口是80，https的端口是443</li><li>https需要向CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li></ul><h3 id="4-2-HTTPS解决了http的哪些问题？"><a href="#4-2-HTTPS解决了http的哪些问题？" class="headerlink" title="4.2 HTTPS解决了http的哪些问题？"></a>4.2 HTTPS解决了http的哪些问题？</h3><ul><li>HTTP 由于是明文传输，所以安全上存在以下三个风险：<ul><li>窃听风险，比如通信链路上可以获取通信内容，用户号容易没。</li><li>篡改风险，比如强制入垃圾广告，视觉污染，用户眼容易瞎。</li><li>冒充风险，比如冒充淘宝网站，用户钱容易没。</li></ul></li><li>HTTPS 在 HTTP 与 TCP 层之间加入了 SSL/TLS 协议。<ul><li>HTTP TCP IP MAC</li><li>HTTP SSL/TLS TCP IP MAC</li></ul></li><li>HTTP 与 HTTPS可以很好的解决了上述的风险：<ul><li>信息加密：交互信息无法被窃取</li><li>校验机制：无法篡改通信内容，篡改了就不能正常显示</li><li>身份证书：证明淘宝是真的淘宝网</li></ul></li><li>HTTPS 是如何解决上面的三个风险的？<ul><li>混合加密的方式实现信息的机密性，解决了窃听的风险</li><li>摘要算法的方式来实现完整性，它能够为数据生成独一无二的指纹，用于校验数据的完整性，解决来篡改的风险</li><li>将服务器公钥放进数字证书里，解决里冒充的风险。</li></ul></li></ul><h2 id="5-HTTP-1-1、HTTP-2、HTTP-3-演变"><a href="#5-HTTP-1-1、HTTP-2、HTTP-3-演变" class="headerlink" title="5.HTTP/1.1、HTTP/2、HTTP/3 演变"></a>5.HTTP/1.1、HTTP/2、HTTP/3 演变</h2><h3 id="5-1-HTTP-1-1-相比-HTTP-1-0-提高了什么性能？"><a href="#5-1-HTTP-1-1-相比-HTTP-1-0-提高了什么性能？" class="headerlink" title="5.1 HTTP/1.1 相比 HTTP/1.0 提高了什么性能？"></a>5.1 HTTP/1.1 相比 HTTP/1.0 提高了什么性能？</h3><ul><li>HTTP/1.1 相比 HTTP/1.0 性能上的改进：<ul><li>使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。</li><li>支持 管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间</li></ul></li><li>但 HTTP/1.1 还是有性能瓶颈：<ul><li>请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分</li><li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多</li><li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</li><li>没有请求优先级控制；</li><li>请求只能从客户端开始，服务器只能被动响应</li></ul></li></ul><h3 id="5-2-基于上面的-HTTP-1-1-的性能瓶颈，HTTP-2-做了什么优化？"><a href="#5-2-基于上面的-HTTP-1-1-的性能瓶颈，HTTP-2-做了什么优化？" class="headerlink" title="5.2 基于上面的 HTTP/1.1 的性能瓶颈，HTTP/2 做了什么优化？"></a>5.2 基于上面的 HTTP/1.1 的性能瓶颈，HTTP/2 做了什么优化？</h3><ul><li>HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。</li><li>那 HTTP/2 相比 HTTP/1.1 性能上的改进：<ul><li>头部压缩<ul><li>HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的分。</li><li>这就是所谓的 HPACK 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</li></ul></li><li>二进制格式<ul><li>HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了二进制格式。</li><li>头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧和数据帧</li><li>这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这增加了数据传输的效率。</li></ul></li><li>数据流<ul><li>HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</li><li>每个请求或回应的所有数据包，称为一个数据流（Stream）。</li><li>每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数</li><li>客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求</li></ul></li><li>多路复用<ul><li>HTTP/2 是可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。</li><li>移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，大幅度提高了连接的利用率。</li><li>举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。</li></ul></li><li>服务器推送<ul><li>HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。</li><li>举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）。</li></ul></li></ul></li></ul><h3 id="5-3-HTTP-2-有哪些缺陷？HTTP-3-做了哪些优化？"><a href="#5-3-HTTP-2-有哪些缺陷？HTTP-3-做了哪些优化？" class="headerlink" title="5.3 HTTP/2 有哪些缺陷？HTTP/3 做了哪些优化？"></a>5.3 HTTP/2 有哪些缺陷？HTTP/3 做了哪些优化？</h3><ul><li>HTTP/2 主要的问题在于：多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。</li><li>所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。<ul><li>HTTP/1.1 中的管道（ pipeline）传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了</li><li>HTTP/2 多请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。</li></ul></li><li>这都是基于 TCP 传输层的问题，所以 HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！<br><img src="/ZJY.github.io/images/http.jpg" alt="image"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookie、Session、Token、JWT的区别</title>
      <link href="/ZJY.github.io/2021/02/04/Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/ZJY.github.io/2021/02/04/Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="Cookie、Session、Token、JWT"><a href="#Cookie、Session、Token、JWT" class="headerlink" title="Cookie、Session、Token、JWT"></a>Cookie、Session、Token、JWT</h2><h3 id="什么是认证（Authentication）"><a href="#什么是认证（Authentication）" class="headerlink" title="什么是认证（Authentication）?"></a>什么是认证（Authentication）?</h3><p>认证就是验证当前用户的身份，证明你是你自己。<br>认证方式：</p><ul><li>用户名密码登录</li><li>手机号发送验证码</li><li>邮箱发送链接，点击验证登录</li></ul><h3 id="什么是授权（Authorization）"><a href="#什么是授权（Authorization）" class="headerlink" title="什么是授权（Authorization）?"></a>什么是授权（Authorization）?</h3><p>用户授予第三方应用访问用户某些资源的权限</p><ul><li>安装app时，app询问是否允许授予权限（位置，存储等）</li><li>访问微信小程序，授权登录，询问是否允许授予权限（昵称，头像，地区等信息）</li></ul><p>实现授权的方式：cookie、session、token、OAuth</p><h3 id="什么是凭证（Credentials）"><a href="#什么是凭证（Credentials）" class="headerlink" title="什么是凭证（Credentials）?"></a>什么是凭证（Credentials）?</h3><ul><li>实现认证和授权的前提</li><li>需要一种媒介（证书）来标记访问者的身份</li><li>比如居民身份证</li><li>比如bilibili，有游客模式和登录模式，游客模式可以正常浏览观看，但是若要点赞，收藏，则需要用户登录。用户登录后服务器会给该用户使用的浏览器一个令牌token，这个令牌来表明你的身份，每次浏览器发送请求时都会带上这个令牌。</li></ul><h3 id="什么是Cookie？"><a href="#什么是Cookie？" class="headerlink" title="什么是Cookie？"></a>什么是Cookie？</h3><ul><li><p>HTTP是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。</p></li><li><p>cookie存储在客户端：cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器发送请求时被携带并发送到服务器上。</p></li><li><p>cookie是不可跨域的：每个cookie都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠domain）</p></li><li><p>cookie重要的属性：</p><ul><li><p>name=value健值对，设置cookie的名称及相应的值，都必须是字符串类型。<br>  如果值为unicode字符，需要转为字符编码<br>  如果值为二进制，需要转为base64编码</p></li><li><p>domain指定cookie所属域名，默认是当前域名，path指定cookie在哪个路径下生效，默认是’/‘。如果设置为/abc，则只有/abc下的路由可以访问到该cookie，如/abc/read。</p></li><li><p>maxAgeCookie：失效的时间，单位秒，如果为整数，则该cookie在maxAge秒后失效。如果为负数，则该cookie为临时cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该cookie。如果为0，表示删除该cookie。默认为-1。比expires好用。一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除。</p></li><li><p>expires：过期时间，在设置的某个时间点后该cookie就会失效。</p></li><li><p>secure：该cookie是否仅被使用安全协议传输。安全协议有HTTPS，SSL等。在网络上传输数据先将数据进行加密。默认是false，当secure为true时，cookie在http中是无效的，在https才有效。</p></li><li><p>httpOnly：如果给某个cookie设置来httpOnly属性，则无法通过js脚本读取到该cookie的信息，但是还是能够通过Application中手动修改cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全</p></li></ul></li></ul><h3 id="什么是Session？"><a href="#什么是Session？" class="headerlink" title="什么是Session？"></a>什么是Session？</h3><ul><li><p>session是另一种记录服务器和客户端会话状态的机制</p></li><li><p>session是基于cookie实现的，session存储在服务端，sessionId会被存储在客户端的cookie中</p></li><li><p>session认证流程：</p><ul><li><p>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的session</p></li><li><p>请求返回将此session的唯一标识sessionId返回给浏览器</p></li><li><p>浏览器接收到服务器返回的sessionId后会将该信息存储到cookie中，同时cookie将记录此sessionId属于哪个域名</p></li><li><p>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在cookie信息，如果存在自动将cookie信息也发送给服务器，服务端会从cookie中获取sessionId，再根据sessionId查找对于session信息，如果没有找到说明用户没有登录或者登录失效，如果找到session证明用户已经登录可执行后续操作。</p></li></ul></li><li><p>sessionId是连接cookie和session的一道桥梁，大部分系统也是根据此原理来验证用户登录状态</p></li></ul><h3 id="cookie和session的区别？"><a href="#cookie和session的区别？" class="headerlink" title="cookie和session的区别？"></a>cookie和session的区别？</h3><ul><li>安全性：session比cookie安全，session是存储在服务端的，cookie是存储在客户端的</li><li>存取值的类型不同： cookie只支持字符串数据，想要设置其他类型的数据，需要将其转换为字符串，session可以存任意数据类型。</li><li>有效期不同：cookie可设置为长时间保持，比如我们经常使用的默认登录功能。session一般失效时间较短，客户端关闭或者session超时都会失效。</li><li>存储大小不同：单个cookie存储数据不能超过4k，session可存储数据远高于cookie，但是当访问量过多，会占用过多的服务器资源。</li></ul><h3 id="什么是token（令牌）？"><a href="#什么是token（令牌）？" class="headerlink" title="什么是token（令牌）？"></a>什么是token（令牌）？</h3><ul><li><p>Access Token</p><ul><li><p>访问资源接口（API）时所需要的资源凭证</p></li><li><p>简单token的组成： uid(用户唯一身份标识)、time(当前时间戳)、sign（签名，token的前几位以哈希算法压缩为一定长度的十六进制字符串）</p></li><li><p>特点： 服务端无状态化、可扩展行好、支持移动端设备、安全、支持跨程序调用</p></li><li><p>token的身份验证流程：</p><ul><li>浏览器发送用户名密码等信息给服务器，服务器将登录凭证做成数字签名，加密之后得到字符串作为token</li><li>服务器将token返回给浏览器，拿到token后，将token保存到本地</li><li>请求时携带token给服务端</li><li>服务器拿到token串，做解密和签名认证，判断其有效性，将数据返回给浏览器</li></ul></li><li><p>每一次请求都需要携带token，需要把token放到http的header里</p></li><li><p>基于token的用户认证是一种服务端无状态的方式，服务端不用存放token数据。用解析token的计算时间来换取session的存储空间，从而减轻服务器的压力。</p></li><li><p>token完全由应用管理，所以它可以避开同源策略</p></li></ul></li><li><p>Refresh Token</p><ul><li>refresh token是一种专用于刷新access token的token。如果没有refresh token也可以刷新access token，但每次刷新都需要用户输入登录名和密码，会很麻烦。有了refresh token可以减少这个麻烦。客户端直接用 refresh token 去更新 access token，无需用户进行额外的操作。</li><li>Access Token 的有效期比较短，当 Acesss Token 由于过期而失效时，使用 Refresh Token 就可以获取到新的 Token，如果 Refresh Token 也失效了，用户就只能重新登录了。</li><li>Refresh Token 及过期时间是存储在服务器的数据库中，只有在申请新的 Acesss Token 时才会验证，不会对业务接口响应时间造成影响，也不需要向 Session 一样一直保持在内存中以应对大量的请求。</li></ul></li></ul><h3 id="token和session的区别？"><a href="#token和session的区别？" class="headerlink" title="token和session的区别？"></a>token和session的区别？</h3><ul><li><p>session是一种记录客户端和服务器会话状态的机制，使服务端有状态化，可以记录会话信息。而token是令牌，访问资源接口（API）时所需要的资源凭证。token使服务端无状态化，不会存储会话信息。</p></li><li><p>session和token并不矛盾，作为身份认证token安全性比session好，因为每一个请求都有签名还能防止监听以及重放攻击，而session就必须依赖链路层来保障通讯安全了。如果你需要实现现有状态的会话，仍然可以增加session来在服务端保存一些状态。</p></li><li><p>所谓session认证只是简单的把user信息存储到session里，因为sessionId的不可预测性，暂且认为是安全的。而token，如果指的是OAuth token或类似机制的话，提供的是认证和授权。认证是真的用户，授权是针对app。</p></li></ul><h3 id="什么是JWT？"><a href="#什么是JWT？" class="headerlink" title="什么是JWT？"></a>什么是JWT？</h3><ul><li><p>JSON Web Token（简称JWT）是目前最流行的跨域认证解决方案。</p></li><li><p>是一种认证授权机制</p></li><li><p>JWT是为了在网络应用环境间传递声明而执行的一种基于JSON的开发标准。jwt的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。</p></li><li><p>可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。</p></li></ul><h3 id="JWT的原理"><a href="#JWT的原理" class="headerlink" title="JWT的原理"></a>JWT的原理</h3><ul><li>JWT认证流程：<ul><li>用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个JWT</li><li>客户端将token保存到本地（通常使用localStorage，也可以使用cookie）</li><li>当用户希望访问一个受保护的路由或者资源的时候，需要请求头的Authorization字段中使用bearer模式添加JWT，<br>  Authorization: bearer <token></li><li>服务端的保护路由将会检查请求头Authorization中的JWT信息，如果合法，则允许用户的行为。</li><li>因为JWT是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要。</li><li>因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</li><li>因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制</li></ul></li></ul><h3 id="JWT的使用方式"><a href="#JWT的使用方式" class="headerlink" title="JWT的使用方式"></a>JWT的使用方式</h3><p>客户端收到服务端返回的jwt，可以存储到cookie里面，也可以储存到localStorage里面。</p><ul><li>方式一<ul><li>当用户希望访问一个受保护的路由或者资源的时候，可以把它放在cookie里面自动发送，但是这样不能跨域，所以更好的做法是放在http请求头信息的Authorization字段里，使用bearer模式添加jwt。<br>  get: /user/page<br>  host: <a href="http://api.example.com/">http://api.example.com</a><br>  Authorization: Bearer<token></li><li>用户的状态不会保存在服务端，这是一种无状态的认证机制。</li><li>服务端的保护路由会检查请求头Authorization中的JWT信息，如果合法，则允许用户的行为</li><li>由于JWT是自包含的，因此减少了需要查询数据库的需要</li><li>JWT 的这些特性使得我们可以完全依赖其无状态的特性提供数据 API 服务，甚至是创建一个下载流服务</li><li>因为JWT并不使用cookie，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</li></ul></li><li>方式二<ul><li>跨域的时候，可以把 JWT 放在 POST 请求的数据体里。</li></ul></li><li>方式三<ul><li>通过 URL 传输：<a href="http://www.example.com/user?token=xxx">http://www.example.com/user?token=xxx</a></li></ul></li></ul><h3 id="token和JWT的区别？"><a href="#token和JWT的区别？" class="headerlink" title="token和JWT的区别？"></a>token和JWT的区别？</h3><ul><li>相同：<ul><li>都是访问资源的令牌</li><li>都可以记录用户的信息</li><li>都是使服务端无状态化</li><li>都是只有验证成功后，客户端才能访问服务端上受保护的资源</li></ul></li><li>区别：<ul><li>token：服务端验证客户端发送过来的token时，还需要查询数据库获取用户信息，然后验证token是否有效</li><li>JWT：将token和payload加密后存储于客户端，服务端只需要使用密钥进行校验（校验也是JWT自己实现的）即可，不需要查询或者减少查询数据库，因为JWT自包含了用户信息和加密的数据。</li></ul></li></ul><h3 id="常见的前后的鉴权方式"><a href="#常见的前后的鉴权方式" class="headerlink" title="常见的前后的鉴权方式"></a>常见的前后的鉴权方式</h3><ul><li>session/cookie</li><li>token验证（包括JWT，SSO）</li><li>OAuth2.0（开发授权）</li></ul><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li><p>使用cookie时需要考虑的问题</p><ul><li>存储在客户端容易被客户端篡改，使用前需要验证合法性</li><li>不能存户敏感数据</li><li>使用httpOnly在一定程度上可以提高安全性</li><li>尽量减少cookie的体积，能存储的数据不能超过4k</li><li>设置正确的domain和path，减少数据传输</li><li>cookie无法跨域</li><li>一个浏览器针对一个网站最多存20个cookie，浏览器一般只允许存放300个cookie</li><li>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token</li></ul></li><li><p>使用session时需要考虑的问题</p><ul><li>将 session 存储在服务器里面，当用户同时在线量比较多时，这些 session 会占据较多的内存，需要在服务端定期的去清理过期的 session</li><li>当网站采用集群部署的时候，会遇到多台 web 服务器之间如何做 session 共享的问题。因为 session 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 session 的服务器，那么该服务器就无法拿到之前已经放入到 session 中的登录凭证之类的信息了</li><li>当多个应用要共享 session 时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好 cookie 跨域的处理。</li><li>sessionId 是存储在 cookie 中的，假如浏览器禁止 cookie 或不支持 cookie 怎么办？ 一般会把 sessionId 跟在 url 参数后面即重写 url，所以 session 不一定非得需要靠 cookie 实现</li></ul></li><li><p>使用 token 时需要考虑的问题</p><ul><li>如果你认为用数据库来存储 token 会导致查询时间太长，可以选择放在内存当中。比如 redis 很适合你对 token 查询的需求</li><li>token 完全由应用管理，所以它可以避开同源策略</li><li>token 可以避免 CSRF 攻击(因为不需要 cookie 了)</li></ul></li><li><p>使用 JWT 时需要考虑的问题</p><ul><li>因为 JWT 并不依赖 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</li><li>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</li><li>JWT 不加密的情况下，不能将秘密数据写入 JWT。</li><li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</li><li>JWT 最大的优势是服务器不再需要存储 Session，使得服务器认证鉴权业务可以方便扩展。但这也是 JWT 最大的缺点：由于服务器不需要存储 Session 状态，因此使用过程中无法废弃某个 Token 或者更改 Token 的权限。也就是说一旦 JWT 签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。</li><li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证</li><li>JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态</li><li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输</li></ul></li></ul><h3 id="只要关闭浏览器-，session-真的就消失了？"><a href="#只要关闭浏览器-，session-真的就消失了？" class="headerlink" title="只要关闭浏览器 ，session 真的就消失了？"></a>只要关闭浏览器 ，session 真的就消失了？</h3><p>不对。对 session 来说，除非程序通知服务器删除一个 session，否则服务器会一直保留，程序一般都是在用户做 log off 的时候发个指令去删除 session。然而浏览器从来不会主动在关闭之前通知服务器它将要关闭，因此服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分 session 机制都使用会话 cookie 来保存 session id，而关闭浏览器后这个 session id 就消失了，再次连接服务器时也就无法找到原来的 session。如果服务器设置的 cookie 被保存在硬盘上，或者使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 session id 发送给服务器，则再次打开浏览器仍然能够打开原来的 session。恰恰是由于关闭浏览器不会导致 session 被删除，迫使服务器为 session 设置了一个失效时间，当距离客户端上一次使用 session 的时间超过这个失效时间时，服务器就认为客户端已经停止了活动，才会把 session 删除以节省存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器是如何运作的</title>
      <link href="/ZJY.github.io/2021/01/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84/"/>
      <url>/ZJY.github.io/2021/01/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器是如何运作的"><a href="#浏览器是如何运作的" class="headerlink" title="浏览器是如何运作的"></a>浏览器是如何运作的</h2><h3 id="1-浏览器发展史："><a href="#1-浏览器发展史：" class="headerlink" title="1.浏览器发展史："></a>1.浏览器发展史：</h3><ul><li>1991年Berners Lee建立了第一代网络浏览器WorldWideWeb,只支持显示文本图片 </li><li>1993年Mosaic问世，同时支持显示文本和图像</li><li>1994年网景浏览器发布 ，只能显示简单的静态html，没有js，css。同年出现Opera。</li><li>1995年微软发布IE1.0，IE2.0，自此第一次浏览器大战正式打响</li><li>1996年微软发布的IE3.0和window系统集成一起，网景份额此时占86%</li><li>1998年网景开源了firefox火狐来迎击IE</li><li>1999年IE市场份额占据99%</li><li>2003年苹果发布safari浏览器，被包含在所有苹果操作系统中 </li><li>2004年网景发布来firefox1.0版本，拉开第二次浏览器大战</li><li>2005年苹果开源了safari浏览器内核webkit </li><li>2008年谷歌以苹果开源项目webkit 创建了新的项目chromium， 在该项目的基础上谷歌发布了自己的浏览器产品Chrome，</li><li>2015年微软放弃了IE，推出了以webkit内核的Edge浏览器</li><li>2020年chrome已占据60%多的市场份额</li></ul><h3 id="2-浏览器结构图："><a href="#2-浏览器结构图：" class="headerlink" title="2.浏览器结构图："></a>2.浏览器结构图：</h3><ul><li>用户界面-用户界面用来展示除标签页窗口以外的其他用户界面内容</li><li>浏览器引擎- </li><li>渲染引擎-渲染引擎负责渲染用户请求的页面内容</li></ul><p>浏览器是运行在操作系统上的一个应用程序 ，每个应用程序必须至少启动一个进程来执行其功能，每个程序往往需要运行很多任务，进程就会创建很多线程去帮助它执行一些小的任务。</p><p>当我们启动一个应用程序时，就会创建一个进程来执行任务代码，同时为该进程分配内存空间。该应用程序的状态都保存在内存空间里，当应用关闭时，该内存就会被回收。<br>进程可以启动更多的进程来执行任务，由于每个进程分配的内存空间是独立的，如果两个进程间需要传递数据，则需要通过进程间通信管道IPC来传递。很多引用程序都是多进程的结构，避免某一个进程卡死，由于进程间相互独立，这样不会影响整个应用程序。<br>进程可以将任务分为更多个细小的任务，然后通过创建多个线程并行执行不同的任务，同一进程下的线程之间是可以通信共享数据的。</p><h3 id="3-浏览器是一个多进程的结构："><a href="#3-浏览器是一个多进程的结构：" class="headerlink" title="3.浏览器是一个多进程的结构："></a>3.浏览器是一个多进程的结构：</h3><ul><li>浏览器进程<br>  浏览器进程负责控制除标签页外的用户界面，包括地址栏，书签，前进，后退按钮以及负责与浏览器其他进程协调工作</li><li>缓存进程</li><li>网络进程<br>  负责发起接受网络请求</li><li>GPU进程<br>  负责整个浏览器界面的渲染</li><li>插件进程<br>  负责网站使用的所有插件，例如flash,插件并不是指插件安装的扩展</li><li>渲染器进程<br>  用来控制显示tab标签内的所有内容<br>  浏览器默认情况下会为每个标签页都创建一个进程（和启动浏览器选择的进程模型有关）</li></ul><h3 id="4-当你在浏览器输入地址时，浏览器内部会发生什么？"><a href="#4-当你在浏览器输入地址时，浏览器内部会发生什么？" class="headerlink" title="4.当你在浏览器输入地址时，浏览器内部会发生什么？"></a>4.当你在浏览器输入地址时，浏览器内部会发生什么？</h3><p>当你在浏览器输入内容时，浏览器进程的UI进程会捕捉你的输入内容，如果访问的是网址，则UI进程会启动一个网络线程来请求DNS进行域名解析，接着开始连接服务器来获取数据。如果输入的不是网址，而是关键词，浏览器就会使用默认配置的搜索引擎来查询。</p><p>当网络线程获取到数据后会通过SafeBrowsing来检查站点是否是恶意站点，如果是，会提示个警告页面阻止你继续访问，也可以强行继续访问。SafeBrowsing是谷歌内部的一套站点安全系统，通过检测该站点的数据判断是否安全。</p><p>当返回数据并安全校验通过时，网络线程就会通知UI线程（浏览器进程）准备好了，然后UI线程就会创建一个渲染器进程来渲染页面，浏览器进程就会通过进程通信管道IPC来把数据传递给渲染器进程，正式进入渲染流程。渲染器接受到的数据也就是html，渲染器的核心任务就是把html,js,css,image等资源渲染成用户可以交互的web页面。</p><p>渲染器进程的主线程将html进行解析，构造DOM数据结构。<br>html首先经过tokeniser标记化，通过词法分析将输入的html内容解析成多个标记，根据识别后的标记进行DOM树构造,在DOM树构造偶成中会创建document对象，然后以document为根节点的DOM树不断进行修改向其中添加各种元素。</p><pre><code>html-&gt;tokeniser-&gt;tree construction-&gt;DOMdocument-&gt;body-&gt;p-&gt;text</code></pre><p>html的代码中往往会引入一些额外的资源，比如图片、css、js脚本等，图片和css资源需要经过网络下载或者从缓存中加载，这些资源不回阻塞html的解析，因为它们不会影响dom的生成。但是html解析遇到script标签，就会停止html的解析流程，转而去加载解析并且执行js，可以使用async或defer来异步加载执行js。在html解析完成后会获得一个DOM 树，但是还不知道dom树上每个节点长什么样子。 </p><p>主线程需要解析css来确定每个dom节点的计算样式。</p><p>在知道DOM节点和每个节点的样式后，接下来需要直到每个节点放置的位置，也就是节点的坐标以及该节点需要占据的区域，这个阶段称为layout布局。</p><p>主线程通过遍历dom和计算好的样式来生成layout tree，layout tree上的每个节点都记录来x,y坐标以及边框尺寸。layout tree是和最后显示的节点一一对应的。</p><p>现在知道节点的形状大小，还需要知道以什么样的顺序来绘制，z-index属性会影响节点绘制的层级关系。按照dom层级顺序绘制节点是不对的，为了在屏幕上展示正确的层级，主线程遍历Layout tree 创建了一个绘制记录表（paint record）,该表记录了绘制的顺序，这个阶段被称为绘制（paint）。</p><p>现在知道了节点绘制的顺序，到了把这些信息转化称像素点显示在屏幕上的时候了。这种行为被称为栅格化。<br>chrome早期栅格化只栅格用户可视区域界面，随着滚动再继续栅格，会带来延迟。现在使用另一种更复杂的栅格化，叫做合成（Composting）,合成是一种将页面的各个部分分为多个图层，分别对其栅格化，并在合成器线程中单独进行合成页面的技术。<br>简单来说就是页面所有元素按照某种规则进行分图层，然后把图层都栅格化好了，然后只需把可视区域的内容组合成一帧展示给用户即可。</p><p>主线程遍历layout tree生成layer tree(图层),当layer tree生成完毕和绘制顺序确定后，主线程将这些信息传递给合成器线程，<br>合成器线程将每个图层栅格化，由于一层可能像页面的整个长度一样大，因此合成器线程将他们切分为许多图块，然后将每个图块发送给栅格化线程（Raster thread）。</p><p>栅格化线程栅格每个图块，并将它们存储在GPU内存中，当栅格化完成后，合成器线程将收集称为“draw quads”的图块信息，这些信息记录了图块在内存中的位置和在页面的哪个位置绘制图块的信息。根据这些信息合成器线程合成生成了一个合成器帧（Compositor Frame）,然后这个合成器帧通过进程间通信管道IPC传递给浏览器进程，接着浏览器进程将合成器帧传送到GPU，然后GPU渲染展示到屏幕上。</p><p>页面上终于可以看到内容，当页面发生变化，比如滚动页面，则会生成一个新的合成器帧，新的帧再传送到GPU，再渲染到屏幕上。</p><h3 id="5-总结："><a href="#5-总结：" class="headerlink" title="5.总结："></a>5.总结：</h3><ul><li>浏览器进程中的网络线程请求获取到html数据后，通过IPC将数据传给渲染器进程的主线程</li><li>主线程将html解析构造DOM树</li><li>然后进行样式计算</li><li>根据DOM树和生成好的样式成功layout tree</li><li>通过遍历layout tree生成绘制顺序表paint</li><li>接着遍历layout tree生成layer tree(图层)</li><li>然后主线程将layer tree和绘制顺序信息一起传递给合成器线程</li><li>合成器线程按照规则进行分图层，并把更小的tiles（图块）传递给栅格化线程进程栅格化</li><li>栅格化完成后，合成器线程将收到栅格化线程传递过来的“draw quads”的图块信息</li><li>根据这些信息合成器线程合成生成了一个合成器帧（Compositor Frame）</li><li>然后这个合成器帧通过进程间通信管道IPC传递给浏览器进程</li><li>浏览器进程再传送到GPU渲染，然后就展示到屏幕上了。</li></ul><p>主线程-&gt;DOM-&gt;style-&gt;layout tree-&gt;paint-&gt;layer（这些在主线程执行）<br>-&gt;合成器线程-&gt;tiles（图块）<br>-&gt;栅格化线程-&gt;“draw quads”的图块信息-&gt;传递给合成器线程-&gt;合成器帧-&gt;浏览器进程-&gt;GPU-&gt;渲染屏幕</p><p>当我们改变元素的尺寸位置时，会重新计算样式,layout,paint以及后面所有流程，这种行为称为重排reflow</p><p>当我们改变元素颜色属性时，不会出发layout layer 布局，但会触发样式计算，这种行为称为重绘repaint</p><p>重排和重绘都会占用主线程，js也在主线程运行，如果他们都在主线程运行，就会出现抢占执行时间的问题，如果写了一个不断导致重排重绘的动画，浏览器则需要在每一帧都运行样式计算布局和绘制的操作，页面以每秒60帧频率刷新时才不会让用户感觉到页面卡顿，绘制动画时，如果js运行时间过长，没有及时归还主线程，就会导致页面绘制卡顿。</p><p>可以通过requestAnimationFrame()和transform解决这个问题。<br>合成器线程和栅格化线程不运行在主线程，不会受到主线程中js执行的影响，css中transform动画不需要样式计算布局绘制，不运行在主线程。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>互联网是如何运行的</title>
      <link href="/ZJY.github.io/2021/01/26/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84/"/>
      <url>/ZJY.github.io/2021/01/26/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h2 id="互联网是如何运行的"><a href="#互联网是如何运行的" class="headerlink" title="互联网是如何运行的"></a>互联网是如何运行的</h2><p>当你的电脑联入互联网之后，会得到一个编号地址，这个地址称为Internet Protocal Address,也就是IP地址。<br>bilibili的服务器也接入互联网，它也将分配一个IP地址，常说的访问某某网站，就是访问这个网站的服务器。<br>如果你的电脑想通过访问index.html来获取b站首页内容， 此时称电脑为客户端，bilibili为服务端，这种形式就是客户端服务端模型。</p><p>客户端更贴近用户 ，是面向用户的应用程序，例如web浏览器，电子邮件客户端，手机app。<br>服务端是在远程计算机上运行的引用程序，客户端可以在需要时，通过互联网与服务端进行通信。</p><p>你的电脑发送给bilibili服务器消息，要获取index.html的内容，消息将会被转化为电子信号，通过电缆发送给bilibili服务器，在服务器端又将电子信号转换为计算机可以使用的文本数据。<br>以上通过Tcp/Ip协议族来实现。</p><p>协议：协议是一组规则，用于指定计算机应如何通过网络来互相通信。</p><h3 id="1-Tcp-Ip协议族共分为4层："><a href="#1-Tcp-Ip协议族共分为4层：" class="headerlink" title="1.Tcp/Ip协议族共分为4层："></a>1.Tcp/Ip协议族共分为4层：</h3><ul><li>应用层：提供特定于应用程序的协议（HTTP，FTP，IMAP）</li><li>Tcp传输控制层：发送数据包到计算机上使用特定端口号的应用程序</li><li>IP网络层：使用IP地址将数据包发送到特定的计算机</li><li>链路层：将二进制数据包与网络信号相互转换</li></ul><p>网络协议通过分层来明确每一层的职责，通过定义明确的接口来协同工作</p><p>1.在当前的例子中，使用应用层的HTTP协议请求获取html文本，这时需要发送一个请求消息，消息在发送前会被分解为许多片段，称为数据包。</p><p>2.通过应用层进入传输控制层后，每个数据包都会被分配一个端口号，端口号用来确定计算机的哪一个应用程序要接受并使用该数据包。<br>进入IP网络层后，每个数据包将会赋予目标计算机的IP地址。</p><p>3.有了IP地址和端口号之后，链路层会将数据包的文本数据转换为电子信号。然后通过电缆传输，在电缆中的另一端的路由器检查每个数据包中的地址，并确定发送到何处，最终数据包到达服务器。数据包到达服务器后，从Tcp/Ip协议族的底部数据链路层开始向上运行， 当数据包向上通过协议族时，客户端添加的所有路由数据，例如Ip地址和端口号都将从数据包剥离出来。当数据到达栈顶时，数据包已恢复成最初始的形式。</p><p>4.通过端口号可以将数据传递给当前服务器监听该端口的应用程序。应用程序根据当前请求数据作出反应。<br>比如现在想获取index.html，服务器会将路径index.html的数据通过刚才方式返回给你的电脑。也就是客户端，这样就可以看到b站首页内容。 这里完成了客户端与服务器在互联网的一次数据交互。</p><ul><li>应用层： 数据包</li><li>传输控制层： 数据  源端口  目标端口</li><li>网络层： 数据  源端口  目标端口  源IP 目标IP</li><li>数据链路层： 数据  源端口  目标端口  源IP 目标IP</li></ul><h3 id="Tcp是一种面向连接的可靠字节流服务。"><a href="#Tcp是一种面向连接的可靠字节流服务。" class="headerlink" title="Tcp是一种面向连接的可靠字节流服务。"></a>Tcp是一种面向连接的可靠字节流服务。</h3><p>Tcp必须经过3次握手建立连接后才可以交换数据，每个收到的数据包都会向发送方发送ack确认，以保证发送成功</p><h3 id="IP是-不可靠的无连接协议"><a href="#IP是-不可靠的无连接协议" class="headerlink" title="IP是 不可靠的无连接协议"></a>IP是 不可靠的无连接协议</h3><p>它并不关心数据包是否到达目的地，也不关心连接和端口号，它的工作是发送数据包并将其路由到目标计算机，其中每个数据包都是独立的不相互依赖的，所以有可能乱序到达目的地。</p><p>如何保证数据包到达和顺序正确？交给TCP。<br>当数据包过大时，在IP网络层会进行分包，由于每个数据包在物理链路层走的物理链路不同，传输速度不同，导致数据包没有按顺序到达目的地。但是TCP会根据数据包携带的序列号来进行排序重组，并且发送方在特定时间内没有接收到接收方发来的ack确认时，则发送方会重新发送该数据包。</p><p>IP是一种网络协议，IP地址是一串数字。</p><h3 id="IP有两种协议："><a href="#IP有两种协议：" class="headerlink" title="IP有两种协议："></a>IP有两种协议：</h3><ul><li>IPv4 Internet Protocol version4<br>  采用32位地址，即4字节，因此地址空间只有2<sup>32</sup>个，约40亿个，专用网络1800万个，多播地址2.7亿个， </li><li>IPv6 Internat Protocol version6<br>  采用128位地址，2<sup>128</sup>个</li></ul><h3 id="调制解调器（也叫猫）和路由器的区别："><a href="#调制解调器（也叫猫）和路由器的区别：" class="headerlink" title="调制解调器（也叫猫）和路由器的区别："></a>调制解调器（也叫猫）和路由器的区别：</h3><ul><li>猫用于网络间不同介质网络信号转接，比如把ADSL，光纤，有线通等的网络信号转成标准的电脑网络信号。</li><li>路由器用于网络信号的再分配，简单地说就是让一根网线可以连接更多的电脑。</li><li>家里有宽带就必须有猫，有多台电脑上网就必须有路由器，假如电脑很多，超过路由器的接口就需要交换机扩展接口。</li></ul><p>1.电脑通过调制解调器modem，也就是常说的“猫”，将计算机的数字信号翻译成可沿普通电话线传输的模拟信号后，在公共电话网络进行传输，公共电话网络通过连接Internet Service Provider，互联网服务提供商ISP，来接入互联网。生活中常见的电信，移动，联通都是ISP。</p><p>2.数据包经过电话网络和ISP后，它们将路由到ISP的主干网络。互联网骨干网由许多相互连接的大型网络组成，这些大型网络被称为网络服务提供商，简称NSP。NSP是为ISP提供网络主干服务的公司。ISP可以从NSP那里批量购入带宽，为客户提供网络接入服务。<br>NSP网络通过网络访问点NAP相连，来交换数据包流量，每个NSP都必须连接到至少三个网络访问点NAP。</p><p>3.计算机有个特殊的计算器-路由器，路由器中有个路由表，记录来其子网络的所有IP地址。当数据包到达路由器，路由器检查路由表上是否有目的地的IP地址，如果有则直接发送给那个网络。否则就向上层发送数据，在更高的层级去寻找拥有该iP的路由器。如果依然没有找到，继续向上路由，直到到达NSP主干网为止，连接到NSP主干网的路由器拥有最大的路由表，通过这张表可以将数据包路由到正确的骨干网。然后开始向下传播，直到找到目的地为止。你的电脑就是这样访问bilibili服务器的。</p><p>4.通过IP地址来访问bilibili服务器，ip地址可能会改变，通过域名来访问可以解决Ip地址改变问题。<br>浏览器通过DNS来知道哪个域名访问哪个IP地址。</p><p>Domian names service,简称DNS，是一个分布式数据库，记录来域名和其IP地址的对应关系。<br>在浏览器输入网址时，浏览器首先连接DNS服务器，获取到该域名的IP地址后，浏览器在连接访问该IP的服务器。<br>有了DNS后，之后IP有了变化，重新绑定下域名和新IP地址就可以了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试基础</title>
      <link href="/ZJY.github.io/2021/01/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
      <url>/ZJY.github.io/2021/01/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="一-HTML"><a href="#一-HTML" class="headerlink" title="一.HTML"></a>一.HTML</h2><h3 id="1-html语义化"><a href="#1-html语义化" class="headerlink" title="1.html语义化"></a>1.html语义化</h3><ul><li><p>使页面内容结构化，即使丢失样式也能使页面呈现清晰的结构</p></li><li><p>有利于SEO，搜索引擎根据标签确定上下文和关键字的权重有利于开发和维护</p></li><li><p>语义化更具有可读性，代码更好维护</p></li><li><p>方便其他设备解析，如配合盲人阅读器渲染页面易于用户阅读，<br>如：</p><p>  header  定义头部内容<br>  nav 定义导航区域<br>  main 定义主要文档内 容<br>  article 表示文章、博客等内容<br>  aside   侧边内容<br>  footer  尾部</p></li></ul><p>div、article、section</p><p>div、article、section是语义从无到有，逐渐增强的。<br>div无任何语义，仅仅用作样式化或脚本的标签。<br>对于一段主题性的内容，则适用于section元素。<br>对于可脱离上下文，作为一段完整独立内容的，适用于article。</p><ul><li><p>article元素代表文档、页面或应用程序中独立的、完整的、可以独自被外部引用的内容。它可以是一篇博客或报刊中的文章、一篇论坛帖子、一段用户评论或独立的插件，或其他任何独立的内容。除了内容部分，一个article元素通常有它自己的标题（一般放在一个header元素里面），有时还有自己的脚注</p></li><li><p>section元素的作用是对页面上的内容进行分块，或者说对文章进行分段；一个section元素通常由内容及其标题组成，通常不推荐为那些没有标题的内容使用section元素</p></li></ul><h3 id="2-HTML5新标签"><a href="#2-HTML5新标签" class="headerlink" title="2.HTML5新标签"></a>2.HTML5新标签</h3><pre><code>&lt;header&gt; &lt;footer&gt; &lt;nav&gt; &lt;aside&gt; &lt;aduio&gt; &lt;video&gt; &lt;canvas&gt;</code></pre><h3 id="3-html5语义化"><a href="#3-html5语义化" class="headerlink" title="3.html5语义化"></a>3.html5语义化</h3><p>表示选择合适的标签（语义化标签）便于开发者阅读和写出更优雅的代码</p><h3 id="4-html5新特性"><a href="#4-html5新特性" class="headerlink" title="4.html5新特性"></a>4.html5新特性</h3><p>HTML5新特性有哪些？</p><pre><code>语义化标签音视频处理canvas / webGLhistory APIrequestAnimationFrame地理位置webSocket</code></pre><h3 id="5-对WEB标准和W3C的理解认识"><a href="#5-对WEB标准和W3C的理解认识" class="headerlink" title="5.对WEB标准和W3C的理解认识"></a>5.对WEB标准和W3C的理解认识</h3><p>个人理解：</p><pre><code>html - 表示人的光身体 ---结构css - 表示给人穿的衣服 ---表现js - 表示人的行为，走路等 ---行为</code></pre><p>web简单来说可以分为结构、表现和行为。</p><ul><li>其中结构主要是由HTML标签组成。</li><li>表现是指css样式表，可用通过css使页面标签更具美感。</li><li>行为是指用户和页面有一定的交互，同时结构和表现也会发生变化，主要由js组成</li></ul><p>web标准一般是将该三部分独立分开，使其更具有模块化。但一般产生行为时，就会有结构或者表现的变化，也使这三者的界限并不那么清晰。</p><p>W3C对web标准提出了规范化的要求，也就是在实际编程中的<br>一些代码规范：</p><pre><code>1.对于结构要求（标签规范可以提高搜索引擎对页面的抓取率，对seo很有帮助）：    标签要小写    标签要闭合    标签不能随意嵌套2.对于css和js来说：    使用外链css和js，使结构、表现、行为三者分离。    提高页面渲染速度，提高用户体验    尽量少使用行内样式，使结构和表现分离，标签的id和class要见文知意，标签越少，加载越快，用户体验越高    不需要变动页面内容，便可提供打印版本而不需要复制内容，提高网站易用性。</code></pre><h3 id="6-什么是DOCTYPE及作用"><a href="#6-什么是DOCTYPE及作用" class="headerlink" title="6.什么是DOCTYPE及作用"></a>6.什么是DOCTYPE及作用</h3><p>DTD（document type definition，文档类型定义）是一系列的语法规则，用来定义XML或（X）HTML的文件类型。浏览器会使用它来判断文档类型，决定使用何种协议来解析以及切换浏览器模式。（DTD告诉浏览器我是什么文档类型，浏览器会根据这个来判断用什么引擎来解析和渲染他们）</p><p>DOCTYPE是用来声明文档类型和DTD规范的，一个主要的用途便是文件的合法性验证。如果文件代码不合法，那么浏览器解析时会出一些错误。（DOCTYPE告诉浏览器当前是哪个文档类型）</p><!DOCTYPE html><p>作用：<br>告诉浏览器用哪种HTML版本的规范来解析HTML文档</p><h2 id="二-CSS"><a href="#二-CSS" class="headerlink" title="二.CSS"></a>二.CSS</h2><h3 id="1-盒模型"><a href="#1-盒模型" class="headerlink" title="1.盒模型"></a>1.盒模型</h3><ul><li>组成：border+padding+content+margin</li><li>标准盒模型：width: content  box-sizing: content-box</li><li>怪异盒模型/IE：width: content+padding+border  box-sizing:border-box</li></ul><h3 id="2-rem和em的区别"><a href="#2-rem和em的区别" class="headerlink" title="2.rem和em的区别"></a>2.rem和em的区别</h3><p>rem是根据根元素的font-size变化，em是根据父元素的font-size变化</p><ul><li>rem：相对于根元素html的font-size，假如html为font-size：12px，那么，在其当中的div设置为font-size：2rem,就是当中的div为24px</li><li>em：相对于父元素计算，假如某个p元素为font-size:12px,在它内部有个span标签，设置font-size：2em,那么，这时候的span字体大小为：12*2=24px</li></ul><h3 id="3-常见单位"><a href="#3-常见单位" class="headerlink" title="3.常见单位"></a>3.常见单位</h3><ol><li>px：绝对单位，页面按精确像素展示</li><li>em：相对单位，基准点为父节点字体的大小，如果自身定义了font-size按自身来计算（浏览器默认字体是16px），整个页面内1em不是一个固定的值</li><li>rem：相对单位，可理解为”root em”, 相对根节点html的字体大小来计算，CSS3新加属性，chrome/firefox/IE9+支持</li><li>vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%</li><li>vh：viewpoint height，视窗高度，1vh等于视窗高度的1%</li><li>vmin：vw和vh中较小的那个</li><li>vmax：vw和vh中较大的那个</li><li>%:百分比</li></ol><h3 id="4-移动端视口配置"><a href="#4-移动端视口配置" class="headerlink" title="4.移动端视口配置"></a>4.移动端视口配置</h3><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;&gt;initial-scale：初始的缩放比例minimum-scale：允许用户缩放到的最小比例maximum-scale：允许用户缩放到的最大比例user-scalable：用户是否可以手动缩放</code></pre><h3 id="5-渐进增强与优雅降级的理解及区别"><a href="#5-渐进增强与优雅降级的理解及区别" class="headerlink" title="5.渐进增强与优雅降级的理解及区别"></a>5.渐进增强与优雅降级的理解及区别</h3><ul><li><p>渐进增强（Progressive Enhancement）：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。</p></li><li><p>优雅降级（Graceful Degradation）：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行hack 使其可以在低版本浏览器上正常浏览。</p></li></ul><p>两者区别？</p><p>1、广义：<br>其实要定义一个基准线，在此之上的增强叫做渐进增强，在此之下的兼容叫优雅降级<br>2、狭义：<br>渐进增强一般说的是使用CSS3技术，在不影响老浏览器的正常显示与使用情形下来增强体验，而优雅降级则是体现html标签的语义，以便在js/css的加载失败/被禁用时，也不影响用户的相应功能</p><h3 id="6-cookie、sessionStorage、localStorage区别"><a href="#6-cookie、sessionStorage、localStorage区别" class="headerlink" title="6.cookie、sessionStorage、localStorage区别"></a>6.cookie、sessionStorage、localStorage区别</h3><p>相同点：</p><ul><li>都是保存在浏览器端、且同源的 </li></ul><p>不同点：</p><ul><li><p>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下 </p></li><li><p>存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M+</p></li></ul><ul><li><p>cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除</p></li><li><p>cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地</p></li><li><p>作用域不同，sessionStorage在不同的浏览器窗口中不共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的 </p></li></ul><h3 id="7-css选择器"><a href="#7-css选择器" class="headerlink" title="7.css选择器"></a>7.css选择器</h3><ul><li><p>常用css选择器</p><p>  id选择器   #header<br>  类选择器   .header<br>  元素选择器  div<br>  通配符     *<br>  后代选择器  div p, p a<br>  儿子选择器  div &gt; span<br>  兄弟选择器  div + p, h2 ~ h3<br>  伪类选择器  a:hover<br>  属性选择器  input[type=”text”]<br>  伪元素选择器  p::before  p::first-line</p></li><li><p>css选择器权重</p><p>  !important &gt; id &gt; class &gt; 元素和伪元素 &gt; * &gt; 继承 &gt;默认</p></li></ul><h3 id="8-css3新特性"><a href="#8-css3新特性" class="headerlink" title="8.css3新特性"></a>8.css3新特性</h3><ul><li>transition 过渡</li><li>transform   旋转 倾斜 移动 缩放</li><li>animation   动画</li><li>shadow  阴影</li><li>grdient 渐变</li><li>border-radius   圆角</li></ul><h3 id="9-行内元素和块级元素"><a href="#9-行内元素和块级元素" class="headerlink" title="9.行内元素和块级元素"></a>9.行内元素和块级元素</h3><ul><li><p>行内元素（display: inline）:</p><ul><li>设置宽高无效，宽度和高度由内容决定</li><li>设置margin左右有效，上下无效，padding都有效</li><li>不会自动换行</li><li>有span,img,input,a,b,sub,sup,i</li></ul></li><li><p>块级元素(display:block):</p><ul><li>可以设置宽高</li><li>margin和padding都有效</li><li>自动换行</li><li>多个块元素写一起，排列从上到下</li><li>由div,p,nav,h,footer,main,header等</li></ul></li><li><p>行内块元素（display:inline-block）</p><ul><li>能够设置宽高</li><li>margin/padding都有效</li><li>不会自动换行</li><li>默认排列方式从左到右 </li></ul></li></ul><h3 id="10-css的position的定位"><a href="#10-css的position的定位" class="headerlink" title="10.css的position的定位"></a>10.css的position的定位</h3><p>relative  absolute  fixed  static</p><ul><li>绝对定位： absolute和fiexed统称为绝对定位</li><li>相对定位： relative</li><li>默认值：static<br>相对定位和绝对定位的区别：</li><li>relative：<br>相对于自身位置定位，仍处于文档流中，元素的宽高不变，设置偏移量也不会影响其他元素的位置，如果最外层设置relative，在没有设置宽度情况，元素宽度是整个浏览器的宽度</li><li>absolute：<br>相对于离自己最近的设置了相对或绝对定位的父元素定位，如果没有父元素设置相对和绝对定位，则相对于跟元素html定位，设置了绝对定位的元素脱离了文档流，如果没有设置宽高由元素内容决定，脱离后元素位置是空的下面的元素会占据</li><li>fixed：<br>相对于浏览器窗口定位,如果没有设置宽高由元素内容决定。</li></ul><h3 id="11-Flex布局"><a href="#11-Flex布局" class="headerlink" title="11.Flex布局"></a>11.Flex布局</h3><p>Flexbox为Flexible box缩写，“弹性布局”，任何一个元素都能设置弹性布局包含两部分，一个为容器，一个为项目<br>水平的主轴（main axis）和垂直的交叉轴（cross axis）<br>主轴的排列方式：从左到右；交叉轴的排列方式：从上到下;</p><p>容器的属性：</p><ul><li>flex-direction:主轴的方向-row/row-reverse/column/column-reverse</li><li>flex-wrap:项目排列方式是否换行–nowrap/wrap/wrap-reverse</li><li>flex-flow:direction和wrap的缩写</li><li>justify-content:项目在主轴排列方式–flex-start/flex-end/center/space-between/space-around</li><li>align-items:项目在交叉轴的如何对齐-flex-start/flex-end/center/baseline/stretch</li></ul><p>项目属性：</p><ul><li>order：number （数值越小越靠前，默认为0）项目排列顺序</li><li>flex-grow ：number（默认0，如果有剩余空间也不放大，值为1放大，2是1的双倍大小，此类推）定义项目放大比例</li><li>flex-shrink ：number （默认为1，如果空间不足则会缩小，值为0不能缩小）项目缩小比例</li><li>flex-basis ：number/auto （默认auto，可设置固定的值50px/50%）定义项目自身的大小</li><li>flex：属性是flex-grow，flex-shrink ,flex-basis的简写，默认值为0、1、auto</li><li>align-self ：auto | flex-start | flex-end | center | baseline | stretch项目自身对齐</li></ul><h3 id="12-display有哪些值？说明他们的作用"><a href="#12-display有哪些值？说明他们的作用" class="headerlink" title="12.display有哪些值？说明他们的作用?"></a>12.display有哪些值？说明他们的作用?</h3><ul><li>inline（默认）–内联</li><li>none–隐藏</li><li>block–块显示</li><li>table–表格显示</li><li>list-item–项目列表</li><li>inline-block-内联块</li></ul><h3 id="13-BFC"><a href="#13-BFC" class="headerlink" title="13.BFC"></a>13.BFC</h3><p>BFC块格式化上下文，是Web页面的可视CSS渲染的一部分.是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p><p>下列方式会创建块格式化上下文</p><pre><code>    根元素html    浮动元素（元素的float不是none）    绝对定位元素（元素的display为absolute或fixed）    行内块元素（display：inline-block）    表格单元格（display：table-cell）    表格标题（display：table-caption）    匿名表格单元格元素（display：table/table-row/table-row-group/table-header-group/table-footer-group或inline-table）    overflow计算值不为visible的块元素    display值为flow-root的元素    contain值为layout/content/paint的元素    弹性元素（display为flex或inline-flex 元素的直接子元素）    网格元素（display为grid或inline-grid 元素的直接子元素）    多列容器（元素的column-count或column-width部位auto）    column-span为all的元素始终会创建一个新的BFC，即使该元素没有包裹一个多列容器中。</code></pre><p>BFC布局规则：</p><pre><code>    内部的box会在垂直方向，一个一个排列    Box垂直方向的距离由margin决定，同一个BFC内相邻的两个box的margin值会重叠    每个元素的margin box的左边与border box的左边相接触，即使浮动也如此    BFC区域不和float box区域重叠    BFC是页面上一个独立的容器，内部子元素不回对外部元素产生影响    计算BFC高度时，浮动元素也参与计算</code></pre><p>BFC的使用场景？</p><pre><code>去除边距重叠现象清除浮动（让父元素的高度包含子浮动元素）避免某元素被浮动元素覆盖避免多列布局由于宽度计算四舍五入而自动换行</code></pre><h3 id="14-水平垂直居中"><a href="#14-水平垂直居中" class="headerlink" title="14.水平垂直居中"></a>14.水平垂直居中</h3><pre><code>水平居中： margin:0 auto;text-align:center;flex:justify-content垂直居中：line-height;flex:align-items水平垂直居中：flex;absolute+margin负；absolute+translate负</code></pre><h3 id="15-Sass、Less、Stylus区别"><a href="#15-Sass、Less、Stylus区别" class="headerlink" title="15.Sass、Less、Stylus区别"></a>15.Sass、Less、Stylus区别</h3><p>什么是CSS预处理器?<br>CSS预处理器是一种语言用来为CSS增加一些编程的特性，无需考虑浏览器兼容问题，例如你可以在CSS中使用变量，简单的程序逻辑、函数等在编程语言中的一些基本技巧，可以让CSS更加简洁，适应性更强，代码更直观等诸多好处</p><ul><li>基本语法区别<br>  Sass是以.sass为扩展名，Less是以.less为扩展名，Stylus是以.styl为扩展名</li></ul><ul><li>变量的区别<br>  Sass 变量必须是以$开头的，然后变量和值之间使用冒号（：）隔开，和css属性是一样的。<br>  Less 变量是以@开头的，其余sass都是一样的。<br>  Stylus 对变量是没有任何设定的，可以是以$开头或者任意字符，而且变量之间可以冒号，空格隔开，但是在stylus中不能用@开头</li></ul><p>三种预处理器都有：嵌套、运算符、颜色函数、导入、继承、混入。Stylus还有一些高级特性。例如循环、判断等</p><h3 id="16-display-none与visibility-hidden的区别"><a href="#16-display-none与visibility-hidden的区别" class="headerlink" title="16.display: none与visibility: hidden的区别"></a>16.display: none与visibility: hidden的区别</h3><pre><code>display：none 不显示对应的元素，在文档布局中不再分配空间（回流+重绘）visibility：hidden 隐藏对应元素，在文档布局中仍保留原来的空间（重绘）</code></pre><h3 id="17-重绘-amp-回流"><a href="#17-重绘-amp-回流" class="headerlink" title="17.重绘 &amp; 回流"></a>17.重绘 &amp; 回流</h3><p>浏览器渲染过程如下：</p><ul><li>解析HTML，生成DOM树，解析CSS，生成CSSOM树</li><li>将DOM树和CSSOM树结合，生成渲染树(Render Tree)</li><li>Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）</li><li>Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</li><li>Display:将像素发送给GPU，展示在页面上</li></ul><p>通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流</p><p>我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。</p><p>何时发生回流重绘</p><ul><li>添加或删除可见的DOM元素</li><li>元素的位置发生变化</li><li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li><li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。</li><li>页面一开始渲染的时候（这肯定避免不了）</li><li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</li></ul><p>注意：回流一定会触发重绘，而重绘不一定会回流根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。</p><p>当你获取布局信息的操作的时候，会强制队列刷新</p><p>最小化重绘和重排：</p><pre><code>    批量修改DOM：    使元素脱离文档流    对其进行多次修改    将元素带回到文档中。</code></pre><p>有三种方式可以让DOM脱离文档流：</p><pre><code>    隐藏元素，应用修改，重新显示    使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。    将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。</code></pre><h3 id="18-防抖（debounce）"><a href="#18-防抖（debounce）" class="headerlink" title="18.防抖（debounce）"></a>18.防抖（debounce）</h3><p>防抖就是在触发事件n秒内函数只执行一次，如果在n秒内又触发了事件，就重新计时<br>如下，鼠标移动时，计数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;content&quot;</span> style=<span class="string">&quot;height:150px;line-height:150px;text-align:center; color: #fff;background-color:#ccc;font-size:80px;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> content = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;content&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        content.innerHTML = num++;</span><br><span class="line">    &#125;;</span><br><span class="line">    content.onmousemove = count;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>防抖函数分为非立即执行版和立即执行版</p><p>非立即执行版：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func,wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(timeout)&#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        &#125;</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            func.apply(context,args)</span><br><span class="line">        &#125;,wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在触发事件后函数 1 秒后才执行，而如果我在触发事件后的 1秒内又触发了事件，则会重新计算函数执行时间<br>content.onmousemove = debounce(count,1000);</p><p>let context = this;<br>let args = arguments;<br>防抖函数的代码使用这两行代码来获取 this 和参数，是为了让 debounce 函数最终返回的函数 this指向不变以及依旧能接受到 e 参数</p><p>立即执行版：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func,wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(timeout)&#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> callNow = !timeout;</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            timeout = <span class="literal">null</span></span><br><span class="line">        &#125;,wait)</span><br><span class="line">        <span class="keyword">if</span> (callNow) func.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。</p><h3 id="19-节流（throttle）"><a href="#19-节流（throttle）" class="headerlink" title="19.节流（throttle）"></a>19.节流（throttle）</h3><p>连续触发函数在n秒内只执行一次，稀释了函数的执行频率<br>时间戳版：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func,wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span>(now-previous &gt; wait)&#123;</span><br><span class="line">            func.apply(context,args);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line">content.onmousemove = throttle(count,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>在持续触发事件的过程中，函数会立即执行，并且每 1s 执行一次</p><p>定时器版：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func,wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = argments;</span><br><span class="line">        <span class="keyword">if</span>(!timeout)&#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在持续触发事件的过程中，函数不会立即执行，并且每1s 执行一次，在停止触发事件后，函数还会再执行一次。</p><p>时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候。</p><h3 id="20-获取盒子宽高的几种方式及区别"><a href="#20-获取盒子宽高的几种方式及区别" class="headerlink" title="20.获取盒子宽高的几种方式及区别"></a>20.获取盒子宽高的几种方式及区别</h3><ul><li><p>dom.style.width/height<br>这种方式只能取到dom元素内联样式所设置的宽高，也就是说如果该节点的样式是在style标签中或外联的CSS文件中设置的话，通过这种方法是获取不到dom的宽高的</p></li><li><p>dom.currentStyle.width/height<br>获取渲染后的宽高。但是仅IE支持</p></li><li><p>window.getComputedStyle(dom).width/height<br>与2原理相似，但是兼容性，通用性更好一些</p></li><li><p>dom.getBoundingClientRect().width/height<br>计算元素绝对位置，获取到四个元素left,top,width,height</p></li></ul><p>扩展：获取浏览器高度和宽度的兼容性写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  w = <span class="built_in">window</span>.innerWidth || <span class="built_in">document</span>.documentElement.clientWidth || <span class="built_in">document</span>.body.clientWidth</span><br><span class="line"><span class="keyword">var</span>  h = <span class="built_in">window</span>.innerHeight || <span class="built_in">document</span>.documentElement.clientHeight || <span class="built_in">document</span>.body.clientHeight</span><br></pre></td></tr></table></figure><h3 id="21-link和import区别："><a href="#21-link和import区别：" class="headerlink" title="21.link和import区别："></a>21.link和import区别：</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line"><span class="keyword">@import</span> url(CSS文件路径地址);</span><br><span class="line">&lt;/<span class="selector-tag">style</span>&gt;</span><br><span class="line">&lt;link href=&quot;CSSurl路径&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;</span><br></pre></td></tr></table></figure><ul><li>import是css提供的语法规则，只有导入样式表的作用，link是html的标签，不仅可以加载样式还可以设置rel type等属性</li><li>import是css2才引入等，只支持ie5+，而link没有兼容问题</li><li>import在页面加载完毕才引入，link在加载页面时引入</li><li>link可用dom操作引入link加载样式</li></ul><h3 id="22-多行元素省略号："><a href="#22-多行元素省略号：" class="headerlink" title="22.多行元素省略号："></a>22.多行元素省略号：</h3><pre><code>overflow : hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 3;-webkit-box-orient: vertical</code></pre><h2 id="三-JS"><a href="#三-JS" class="headerlink" title="三.JS"></a>三.JS</h2><h3 id="1-JS的基本数据类型："><a href="#1-JS的基本数据类型：" class="headerlink" title="1.JS的基本数据类型："></a>1.JS的基本数据类型：</h3><p><code>Number</code>  <code>String</code>  <code>Boolean</code>  <code>Null</code>  <code>undefined</code> 新增<code>Symbol</code></p><h3 id="2-几种判断数据类型的优缺点"><a href="#2-几种判断数据类型的优缺点" class="headerlink" title="2.几种判断数据类型的优缺点"></a>2.几种判断数据类型的优缺点</h3><p>一、typeof</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">1</span>);               <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);            <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">&#x27;mc&#x27;</span>);           <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);    <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []);              <span class="comment">// object </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;);              <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);            <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>);       <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>优点：能够快速区分基本数据类型 缺点：不能将Object、Array和Null区分，都返回object</p><p>二、instanceof</p><p>instanceof用来检测构造函数的prototype属性是否存在某实例对象的原型链上</p><p>语法：object instanceof constructor<br>参数：<br>object:某个实例对象<br>constructor:某个构造函数<br>描述：二、instanceof用来检测constructor.prototype属性是否存在在object的原型链上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>);                    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);                <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>);                <span class="comment">// false  </span></span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>);                    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Function</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>);                   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>优点：能够区分Array、Object和Function，适合用于判断自定义的类实例对象 缺点：Number，Boolean，String基本数据类型不能判断</p><p>三、Object.prototype.toString.call()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="number">1</span>));                      <span class="comment">//[object Number]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="literal">true</span>));                   <span class="comment">//[object Boolean]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="string">&#x27;mc&#x27;</span>));                  <span class="comment">//[object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call([]));                     <span class="comment">//[object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(&#123;&#125;));                     <span class="comment">//[object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;));           <span class="comment">//[object Function]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="literal">undefined</span>));              <span class="comment">//[object Undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="literal">null</span>));                   <span class="comment">//[object Null]</span></span><br></pre></td></tr></table></figure><p>优点：精准判断数据类型 缺点：写法繁琐不容易记，推荐进行封装后使用</p><h3 id="3-null和undefined的区别"><a href="#3-null和undefined的区别" class="headerlink" title="3.null和undefined的区别"></a>3.null和undefined的区别</h3><pre><code>undefined是访问一个未初始化的变量时返回的值，而null是访问一个尚未存在的对象时所返回的值。undefined看作是空的变量，而null看作是空的对象</code></pre><h3 id="4-对象深浅拷贝"><a href="#4-对象深浅拷贝" class="headerlink" title="4.对象深浅拷贝"></a>4.对象深浅拷贝</h3><p>一、深拷贝</p><ul><li>1.1 最简单的方法就是JSON.parse(JSON.stringify())<br>但是这种拷贝方法不可以拷贝一些特殊的属性（例如正则表达式，undefine，function）</li><li>1.2 用递归去复制所有层级属性</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopyTwo</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> objClone = <span class="built_in">Array</span>.isArray(obj) ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (obj &amp;&amp; <span class="keyword">typeof</span> obj == <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">            <span class="comment">//判断obj子元素是否为对象，如果是，递归复制</span></span><br><span class="line">            <span class="keyword">if</span> (obj[key] &amp;&amp; <span class="keyword">typeof</span> obj[key] === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">                objClone[key] = deepCopyTwo(obj[key]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果不是，简单复制</span></span><br><span class="line">                objClone[key] = obj[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objClone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、浅拷贝</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(target, ...sources)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        result[i] = obj[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-数组基本方法："><a href="#5-数组基本方法：" class="headerlink" title="5.数组基本方法："></a>5.数组基本方法：</h3><ul><li><p>push()：将参数逐个添加到数组尾部，返回修改后的数组长度</p></li><li><p>unshift()：将参数逐个添加到数组前端，返回修改后的数组长度</p></li><li><p>pop()：移除数组中的最后一项，返回移除的项</p></li><li><p>shift()：移除数组中的第一项，返回移除的项</p></li></ul><p>push pop shift unshift 都会直接改变原数组</p><ul><li><p>map: 遍历数组，返回回调返回值组成的新数组</p></li><li><p>forEach: 无法break，可以用try/catch中throw new Error来停止</p></li><li><p>filter: 过滤</p></li><li><p>some: 有一项返回true，则整体为true</p></li><li><p>every: 有一项返回false，则整体为false</p></li><li><p>join: 通过指定连接符生成字符串</p></li><li><p>concat: 连接数组，不影响原数组， 浅拷贝</p></li><li><p>slice(start, end): 返回截断后的新数组，不改变原数组</p></li><li><p>splice(start, number, value…):返回删除元素组成的数组，value 为插入项，改变原数组</p></li><li><p>indexOf / lastIndexOf(value, fromIndex): 查找数组项，返回对应的下标</p></li><li><p>reduce / reduceRight(fn(prev, cur)， defaultPrev): 两两执行，prev 为上次化简函数的return值,cur 为当前值(从第二项开始)</p></li></ul><p>map和forEach的区别：</p><p>1.都用来遍历数组，map速度比forEach快<br>2.map返回回调返回值组成的新数组，不会对原数组产生影响，forEach没有返回值，不能return或者break<br>3.map返回数组，所以可以链式调用</p><h3 id="6-js有那些内置对象："><a href="#6-js有那些内置对象：" class="headerlink" title="6.js有那些内置对象："></a>6.js有那些内置对象：</h3><p>Object是JavaScript中所有对象的父对象</p><p>数据封装对象：Object、Array、Boolean、Number和String<br>其他对象：Function、Arguments、Math、Date、RegExp、Error</p><h3 id="7-get请求传参长度的误区："><a href="#7-get请求传参长度的误区：" class="headerlink" title="7.get请求传参长度的误区："></a>7.get请求传参长度的误区：</h3><ul><li>HTTP 协议 未规定 GET 和POST的长度限制</li><li>GET的最大长度显示是因为 浏览器和 web服务器限制了 URI的长度</li><li>不同的浏览器和WEB服务器，限制的最大长度不一样</li><li>要支持IE，则最大长度为2083byte，若只支持Chrome，则最大长度 8182byte</li></ul><p>补充get和post请求在缓存方面的区别</p><ul><li>get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存</li><li>post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。</li></ul><h3 id="8-同步任务和异步任务"><a href="#8-同步任务和异步任务" class="headerlink" title="8.同步任务和异步任务"></a>8.同步任务和异步任务</h3><ul><li><p>同步任务：在主线程上执行的任务，只有前一个任务执行完，才能执行下一个任务</p></li><li><p>异步任务：不进入主线程而进入“任务队列”的任务，只有任务队列通知主线程，某个任务可以执行了，该任务才会进入主线程执行。</p><p>  异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）：<br>  1）所以同步任务都在主线程执行，形成一个执行栈<br>  2）主线程之外，还有一个任务队列，只要异步任务有了执行结果，就在任务队列放置一个事件<br>  3）一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列，看看有哪些事件，对应的事件就结束等待状态，进入执行栈进行执行<br>  4）主线程不断重复第三步</p><p>  主线程从“任务队列”中读取事件，这个事件是循环不断的，又称为事件循环（Event loop）</p></li></ul><h3 id="9-事件和回调函数"><a href="#9-事件和回调函数" class="headerlink" title="9.事件和回调函数"></a>9.事件和回调函数</h3><p>“任务队列”就是一个事件的队列，当IO设备完成一项任务，就在“任务队列”中添加一个事件，表示相关的异步任务可以进入执行栈了，主线程读取“任务队列”，就是读取有哪些事件</p><p>“回调函数”（callback）就是被主线程挂起来的代码。异步任务必须指定回调函数，主线程执行异步任务就是执行对应的回调函数。</p><h3 id="10-定时器"><a href="#10-定时器" class="headerlink" title="10.定时器"></a>10.定时器</h3><p>定时器功能主要由setTimeout()和setInterval()这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者则为反复执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">2</span>);&#125;,<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>上面代码的执行结果是1，3，2，因为setTimeout()将第二行推迟到1000毫秒之后执行。</p><p>如果将setTimeout()的第二个参数设为0，就表示当前代码执行完（执行栈清空）以后，立即执行（0毫秒间隔）指定的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>);&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>上面代码的执行结果总是2，1，因为只有在执行完第二行以后，系统才会去执行”任务队列”中的回调函数。</p><p>setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行</p><p>HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加.需要注意的是，setTimeout()只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行</p><p>除了setTimeout和setInterval这两个方法，Node.js还提供了另外两个与”任务队列”有关的方法：process.nextTick和setImmediate。</p><ul><li><p>process.nextTick方法可以在当前”执行栈”的尾部—-下一次Event Loop（主线程读取”任务队列”）之前—-触发回调函数。也就是说，它指定的任务总是发生在所有异步任务之前。setImmediate方法则是在当前”任务队列”的尾部添加事件，也就是说，它指定的任务总是在下一次EventLoop时执行，这与setTimeout(fn, 0)很像</p></li><li><p>process.nextTick和setImmediate的一个重要区别：多个process.nextTick语句总是在当前”执行栈”一次执行完，多个setImmediate可能则需要多次loop才能执行完</p></li></ul><p>另外，由于process.nextTick指定的回调函数是在本次”事件循环”触发，而setImmediate指定的是在下次”事件循环”触发，所以很显然，前者总是比后者发生得早，而且执行效率也高（因为不用检查”任务队列”）。</p><h3 id="11-进程和线程"><a href="#11-进程和线程" class="headerlink" title="11.进程和线程"></a>11.进程和线程</h3><p>进程和线程是操作系统的基本概念</p><p>单个cpu一次只能运行一个任务，任一时刻，CPU总是运行一个进程，其他进程处于非运行状态</p><ul><li>一个进程可用包含多个线程</li><li>一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。</li><li>一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。”互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。</li></ul><p>某些内存区域，只能供给固定数目的线程使用。”信号量”（Semaphore），用来保证多个线程不会互相冲突</p><p>操作系统的设计，因此可以归结为三点：</p><pre><code>（1）以多进程形式，允许多个任务同时运行；（2）以多线程形式，允许单个任务分成不同的部分运行；（3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源</code></pre><h3 id="12-axios在vue-js中应用和特点"><a href="#12-axios在vue-js中应用和特点" class="headerlink" title="12.axios在vue.js中应用和特点"></a>12.axios在vue.js中应用和特点</h3><p>axios是基于promise的http请求客户端，可用在浏览器和node。js中使用</p><p>使用场景：结合vue.js发送请求，拦截请求</p><p>特点：<br>    1.基于promise<br>    2.拦截请求和响应<br>    3.转换请求和响应的数据<br>    4.可在node.js中使用</p><p>安装：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save axios</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> ‘axios’</span><br></pre></td></tr></table></figure><p>结合Vue.js的请求响应拦截器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求拦截</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (config.url.indexOf(<span class="string">&#x27;/oauth/token?grant_type=password&#x27;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">    config.headers[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="string">&#x27;Basic Y2xpOnNlYw==&#x27;</span></span><br><span class="line">    <span class="comment">// config.headers[&#x27;Content-Type&#x27;] = &#x27;application/json;charset-UTF-8&#x27;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getToken()) &#123;</span><br><span class="line">    config.headers[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="string">&#x27;Bearer &#x27;</span> + getToken() + <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Do something with request error</span></span><br><span class="line">  <span class="built_in">console</span>.log(error) <span class="comment">// for debug</span></span><br><span class="line">  <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截</span></span><br><span class="line">axios.interceptors.response.use(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.data.code !== <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (res.data.code) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;401&#x27;</span>:</span><br><span class="line">        <span class="built_in">window</span>.location.href = <span class="string">&#x27;/login&#x27;</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;403&#x27;</span>:</span><br><span class="line">        Notification.error(&#123;</span><br><span class="line">          title: <span class="string">&#x27;错误：403&#x27;</span>,</span><br><span class="line">          message: <span class="string">&#x27;访问拒绝&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;404&#x27;</span>:</span><br><span class="line">        Notification.error(&#123;</span><br><span class="line">          title: <span class="string">&#x27;错误：404&#x27;</span>,</span><br><span class="line">          message: <span class="string">&#x27;找不到网络资源&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;500&#x27;</span>:</span><br><span class="line">        Notification.error(&#123;</span><br><span class="line">          title: <span class="string">&#x27;错误：500&#x27;</span>,</span><br><span class="line">          message: res.data.error.errorMsg</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.data</span><br><span class="line">&#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err.response) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (err.response.status) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;401&#x27;</span>:</span><br><span class="line">        <span class="built_in">window</span>.location.href = <span class="string">&#x27;/login&#x27;</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;403&#x27;</span>:</span><br><span class="line">        Notification.error(&#123;</span><br><span class="line">          title: <span class="string">&#x27;错误：403&#x27;</span>,</span><br><span class="line">          message: <span class="string">&#x27;访问拒绝&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;404&#x27;</span>:</span><br><span class="line">        Notification.error(&#123;</span><br><span class="line">          title: <span class="string">&#x27;错误：404&#x27;</span>,</span><br><span class="line">          message: <span class="string">&#x27;找不到网络资源&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;500&#x27;</span>:</span><br><span class="line">        Notification.error(&#123;</span><br><span class="line">          title: <span class="string">&#x27;错误：500&#x27;</span>,</span><br><span class="line">          message: <span class="string">&#x27;服务器出错&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求封装</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">_axios</span> (<span class="params">method, url, params</span>) </span>&#123;</span><br><span class="line">  method = method.toUpperCase()</span><br><span class="line">  <span class="keyword">var</span> options = &#123;</span><br><span class="line">    method: method,</span><br><span class="line">    url: url,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json;charset=UTF-8&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (method === <span class="string">&#x27;POST&#x27;</span> || method === <span class="string">&#x27;PATCH&#x27;</span> || method === <span class="string">&#x27;PUT&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (params) &#123;</span><br><span class="line">      options.data = params</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> axios(options)</span><br><span class="line">      .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">      &#125;, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> error</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (method === <span class="string">&#x27;GET&#x27;</span> || method === <span class="string">&#x27;DELETE&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (params) &#123;</span><br><span class="line">      options.params = params</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> axios(options)</span><br><span class="line">      .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">      &#125;, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> error</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-HTTP中定义请求方式"><a href="#13-HTTP中定义请求方式" class="headerlink" title="13.HTTP中定义请求方式"></a>13.HTTP中定义请求方式</h3><ul><li><p>get</p></li><li><p>post</p></li><li><p>put</p></li><li><p>delete</p></li><li><p>trace</p></li><li><p>options</p></li><li><p>head</p></li></ul><p>1.get</p><p>get请求只是查询数据，不对数据库进行删改操作；请求会把参数放在url后面；http协议对url长度没有限制，有限制的是浏览器和服务器</p><p>2.post</p><p>post请求一般是对服务器的数据做改变，比如数据的提交，新增操作，请求参数放在请求体中</p><p>3.put</p><p>put和post一样都是对服务器数据对修改，但是put侧重于对数据的修改，而post是对数据的新增</p><p>4.delete</p><p>用来请求删除服务器的资源，但有可能删除不成功（取消delete请求）</p><p>5.options</p><p>options请求属于浏览器的预检请求，查看服务器是否接受请求，预检通过后，浏览器才会去发get，post，put，delete等，响应报文包含一个 Allow 首部字段，该字段的值表明了服务器支持的所有 HTTP 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Allow: OPTIONS, GET, HEAD, POST</span><br><span class="line">Cache-Control: max-age=<span class="number">604800</span></span><br><span class="line"><span class="built_in">Date</span>: Thu, <span class="number">13</span> Oct <span class="number">2016</span> <span class="number">11</span>:<span class="number">45</span>:<span class="number">00</span> GMT</span><br><span class="line">Expires: Thu, <span class="number">20</span> Oct <span class="number">2016</span> <span class="number">11</span>:<span class="number">45</span>:<span class="number">00</span> GMT</span><br><span class="line">Server: EOS (lax004/<span class="number">2813</span>)</span><br><span class="line">x-ec-custom-error: <span class="number">1</span></span><br><span class="line">Content-Length: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>在 CORS 中，可以使用 OPTIONS 方法发起一个预检请求，以检测实际请求是否可以被服务器所接受。预检请求报文中的 Access-Control-Request-Method首部字段告知服务器实际请求所使用的 HTTP方法；Access-Control-Request-Headers首部字段告知服务器实际请求所携带的自定义首部字段。服务器基于从预检请求获得的信息来判断，是否接受接下来的实际请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS /resources/post-here/ HTTP/<span class="number">1.1</span> </span><br><span class="line">Host: bar.other </span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;</span><br><span class="line">Accept-Language: en-us,en;q=<span class="number">0.5</span> </span><br><span class="line">Accept-Encoding: gzip,deflate </span><br><span class="line">Accept-Charset: ISO-<span class="number">8859</span>-<span class="number">1</span>,utf-<span class="number">8</span>;</span><br><span class="line">Connection: keep-alive </span><br><span class="line">Origin: http:<span class="comment">//foo.example </span></span><br><span class="line">Access-Control-Request-Method: POST </span><br><span class="line">Access-Control-Request-Headers: X-PINGOTHER, Content-Type</span><br></pre></td></tr></table></figure><p>服务器所返回的 Access-Control-Allow-Methods 首部字段将所有允许的请求方法告知客户端。该首部字段与 Allow 类似，但只能用于涉及到 CORS 的场景中。</p><pre><code>    Access-Control-Allow-Methods: POST, GET, OPTIONS     Access-Control-Allow-Headers: X-PINGOTHER, Content-Type </code></pre><p>6.head</p><p>与GET方法的行为很类似，但服务器在响应中只返回实体的主体部分</p><p>7.trace</p><p>会在目的服务器端发起一个“回环”诊断。这样客户端就可以查看HTTP请求报文在发送的途中，是否被修改过了</p><h3 id="14-get和post区别"><a href="#14-get和post区别" class="headerlink" title="14.get和post区别"></a>14.get和post区别</h3><ul><li><p>GET参数通过URL传递，POST放在Request body中。</p></li><li><p>GET请求会被浏览器主动cache，而POST不会，除非手动设置</p></li><li><p>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留</p></li><li><p>Get 请求中有非 ASCII 字符，会在请求之前进行转码，POST不用，因为POST在Request body中，通过 MIME，也就可以传输非 ASCII 字符</p></li><li><p>一般我们在浏览器输入一个网址访问网站都是GET请求,HTTP的底层是TCP/IP。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。但是请求的数据量太大对浏览器和服务器都是很大负担。所以业界有了不成文规定，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。</p></li><li><p>GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）</p></li><li><p>在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。但并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次</p></li></ul><h3 id="15-http中content-type"><a href="#15-http中content-type" class="headerlink" title="15.http中content-type"></a>15.http中content-type</h3><p>MediaType，即是Internet Media Type，互联网媒体类型；也叫做MIME类型，在Http协议消息头中，使用Content-Type来表示具体请求中的媒体类型信息</p><p>常见的媒体格式类型如下：</p><ul><li>text/html ： HTML格式</li><li>text/plain ：纯文本格式      </li><li>text/xml ：  XML格式</li><li>image/gif ：gif图片格式    </li><li>image/jpeg ：jpg图片格式 </li><li>image/png：png图片格式</li></ul><p>以application开头的媒体格式类型：</p><ul><li>application/xhtml+xml ：XHTML格式</li><li>application/xml     ： XML数据格式</li><li>application/atom+xml  ：Atom XML聚合格式</li><li>application/json    ： JSON数据格式</li><li>application/pdf       ：pdf格式  </li><li>application/msword  ： Word文档格式</li><li>application/octet-stream ： 二进制流数据（如常见的文件下载）</li><li>application/x-www-form-urlencoded ： <form encType=””>中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）</li></ul><p>另外一种常见的媒体格式是上传文件之时使用的：</p><ul><li>multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式</li></ul><h3 id="16-import和require区别"><a href="#16-import和require区别" class="headerlink" title="16.import和require区别"></a>16.import和require区别</h3><ul><li><p>加载方式<br>require：运行时加载，所以require理论上可以运用在代码的任何地方<br>import：编译时加载，import是编译时调用，所以必须放在文件开头</p></li><li><p>遵循规范<br>require 是 AMD规范引入方式<br>import是es6的一个语法标准，如果要兼容浏览器的话必须转化成es5的语法</p></li><li><p>本质<br>require是赋值过程，其实require的结果就是对象、数字、字符串、函数等，再把require的结果赋值给某个变量import是解构过程，但是目前所有的引擎都还没有实现import，我们在node中使用babel支持ES6，也仅仅是将ES6转码为ES5再执行，import语法会被转码为require</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="built_in">exports</span>.fs = fs</span><br><span class="line"><span class="built_in">module</span>.exports = fs</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> fs&#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;readFile&#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;readFile <span class="keyword">as</span> read&#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> fs, &#123;readFile&#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> fs</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fs</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">readFile</span></span></span><br><span class="line"><span class="function"><span class="title">export</span> </span>&#123;readFile, read&#125;</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="17-ajax"><a href="#17-ajax" class="headerlink" title="17.ajax"></a>17.ajax</h3><p>ajax是异步javascript和xml；<br>Ajax是一种用于创建快速动态网页的技术。</p><p>ajax的使用及实现步骤：<br>1.创建XMLHttpRequest对象,也就是创建一个异步调用对象.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlHttp;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;  <span class="comment">//针对除IE6以外的浏览器</span></span><br><span class="line">    xmlHttp=<span class="keyword">new</span> XMLHttpRequest(); <span class="comment">//实例化一个XMLHttpRequest</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   xmlHttp=<span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);   <span class="comment">//针对IE5,IE6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(method,url,<span class="keyword">async</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure><p>3.设置响应HTTP请求状态变化的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xmlHttp.onreadystatechange()=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(xmlHttp.readyState === <span class="number">4</span> &amp;&amp; xmlHttp.status === <span class="number">200</span>)&#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>).innerHTML=xmlhttp.responseText;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//服务器响应<br>responseText:获得字符串形式的响应数据。<br>responseXML:获得 XML 形式的响应数据。<br>readyState:存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。</p><pre><code>0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪</code></pre><p>status:</p><pre><code>200: &quot;OK&quot;404: 未找到页面</code></pre><p>当 readyState 等于 4 且状态为 200 时，表示响应已就绪：<br>ajax步骤：</p><pre><code>创建XMLHttpRequest对象。设置请求方式。调用回调函数。发送请求。</code></pre><h3 id="18-闭包："><a href="#18-闭包：" class="headerlink" title="18.闭包："></a>18.闭包：</h3><p>函数A 里面包含了 函数B，而 函数B 里面使用了 函数A 的变量，那么 函数B 被称为闭包。</p><p>又或者：闭包就是能够读取其他函数内部变量的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特征：</p><ul><li>函数内再嵌套函数</li><li>内部函数可以引用外层的参数和变量</li><li>参数和变量不会被垃圾回收制回收  </li></ul><p>闭包的理解：使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。</p><p>在js中，函数即闭包，只有函数才会产生作用域的概念</p><p>闭包 的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中</p><ul><li>好处：能够实现封装和缓存等</li><li>坏处：消耗内存，使用不当造成内存泄漏；在退出函数之前，将不使用的局部变量全部删除</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：3个3<br>解析：首先，for 循环是同步代码，先执行三遍 for，i变成了 3；然后，再执行异步代码 setTimeout，这时候输出的 i，只能是 3 个 3 了<br>解决方法：<br>1.使用let i=0;每个 let 和代码块结合起来形成块级作用域，当 setTimeout() 打印时，会寻找最近的块级作用域中的 i，所以依次打印出 0 1 2<br>2.立即执行函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19-js作用域和作用域链"><a href="#19-js作用域和作用域链" class="headerlink" title="19.js作用域和作用域链"></a>19.js作用域和作用域链</h3><p>1.作用域</p><p>在JavaScript中，作用域分为 全局作用域 和 函数作用域</p><ul><li>全局作用域：<br>代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域</li><li>函数作用域：<br>在固定的代码片段才能被访问</li></ul><p>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</p><p>变量取值：到创建 这个变量 的函数的作用域中取值</p><p>2.作用域链</p><p>一般情况下，变量取值到 创建 这个变量 的函数的作用域中取值。</p><p>但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链</p><p>3.原型和原型链</p><p>概念：<br>每个对象在其内部都会初始化一个属性，这个属性就是prototype（原型），指向对象的原型对象，当访问一个对象的某个属性时，就会去对象中查找，如果对象中不存在这个属性就去prototype中查找，而prototype又有自己的prototype，</p><p>任何对象都有一个<code>__proto__</code>[[prototype]]）,它是一个指针，指向构造函数的原型对象。</p><p>原型和原型链的关系：</p><pre><code>instance.constructor.prototype =instance.__proto__构造函数的原型===实例化对象的原型链</code></pre><p>原型和原型链的特点:</p><pre><code>JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变</code></pre><p>当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性，如果没有的就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象</p><h3 id="20-组件化和模块化"><a href="#20-组件化和模块化" class="headerlink" title="20.组件化和模块化"></a>20.组件化和模块化</h3><p>1.组件化</p><ul><li>为什么要组件化?</li></ul><p>有时候页面代码量太大，逻辑太多或者同一个功能组件在许多页面均有使用，维护起来相当复杂，这个时候，就需要组件化开发来进行功能拆分、组件封装，已达到组件通用性，增强代码可读性，维护成本也能大大降低</p><ul><li>组件化开发的优点</li></ul><p>很大程度上降低系统各个功能的耦合性，并且提高了功能内部的聚合性，降低了开发成本</p><ul><li><p>组件化开发的准则：</p><p>  专一<br>  可配置性<br>  标准<br>  复用性<br>  可维护性</p></li></ul><p>2.模块化</p><ul><li>为什么要模块化?</li></ul><p>早期的javascript版本没有块级作用域、没有类、没有包、也没有模块，这样会带来一些问题，如复用、依赖、冲突、代码组织混乱等，随着前端的膨胀，模块化显得非常迫切</p><ul><li><p>模块化的好处</p><p>  提高代码可复用性<br>  避免变量污染，命名冲突<br>  提高可维护性<br>  方便依赖关系管理</p></li><li><p>模块化的几种方法：</p></li></ul><p>1)函数封装：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myModule = &#123;</span><br><span class="line">    var1: <span class="number">1</span>,</span><br><span class="line">    </span><br><span class="line">    var2: <span class="number">2</span>,</span><br><span class="line">    </span><br><span class="line">    fn1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    fn2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：这样避免了变量污染，只要保证模块名唯一即可，同时同一模块内的成员也有了关系</p><p>缺陷：外部可以睡意修改内部成员，这样就会产生意外的安全问题</p><p>2)立即执行函数表达式(IIFE)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myModule = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> var1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> var2 = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        fn1: fn1,</span><br><span class="line">        fn2: fn2</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>总结：这样在模块外部无法修改我们没有暴露出来的变量、函数</p><p>缺点：功能相对较弱，封装过程增加了工作量，仍会导致命名空间污染可能、闭包是有成本的</p><h3 id="21-图片的预加载和懒加载"><a href="#21-图片的预加载和懒加载" class="headerlink" title="21.图片的预加载和懒加载"></a>21.图片的预加载和懒加载</h3><ul><li>预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染</li><li>懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数<br>两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。预加载则会增加服务器前端压力，懒加载对服务器有一定的缓解压力作用。</li></ul><h3 id="22-mouseover和mouseenter的区别"><a href="#22-mouseover和mouseenter的区别" class="headerlink" title="22.mouseover和mouseenter的区别"></a>22.mouseover和mouseenter的区别</h3><ul><li>mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是mouseout</li><li>mouseenter：当鼠标移入元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是mouseleave</li></ul><p>解决异步回调地狱：promise、generator、async/await</p><h3 id="23-对This对象的理解"><a href="#23-对This对象的理解" class="headerlink" title="23.对This对象的理解"></a>23.对This对象的理解</h3><p>this总是指向函数的直接调用者（而非间接调用者）</p><p>如果有new关键字，this指向new出来的那个对象</p><p>在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window</p><p>this表示当前对象，this的指向是根据调用的上下文来决定的，默认指向window对象，指向window对象时可以省略不写</p><p>全局环境： this始终指向的是window对象<br>局部环境： 在全局作用域下直接调用函数，this指向window 对象函数调用，哪个对象调用就指向哪个对象 使用new实例化对象，在构造函数中的this指向实例化对象 使用call或apply改变this的指向<br>总结：this始终指向最后一个调用它的函数的对象</p><h3 id="24-ES6其他常用功能"><a href="#24-ES6其他常用功能" class="headerlink" title="24.ES6其他常用功能"></a>24.ES6其他常用功能</h3><ol><li>let/const</li><li>多行字符串/模板变量</li><li>解构赋值</li><li>块级作用域</li><li>函数默认参数</li><li>箭头函数</li></ol><h3 id="25-bind、call、apply用法及区别"><a href="#25-bind、call、apply用法及区别" class="headerlink" title="25.bind、call、apply用法及区别"></a>25.bind、call、apply用法及区别</h3><p>相同点： 三个函数的作用就是改变this的指向，将函数绑定到上下文中； 不同点： 三个函数的语法不同</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun.call(thisArg[, arg1[, arg2[, ...]]])</span><br><span class="line">fun.apply(thisArg, [argsArray])</span><br><span class="line"><span class="keyword">var</span> bindFn = fun.bind(thisArg[, arg1[, arg2[, ...]]])</span><br><span class="line">bindFn()</span><br></pre></td></tr></table></figure><h3 id="26-目前JS解决异步的方案有哪些"><a href="#26-目前JS解决异步的方案有哪些" class="headerlink" title="26.目前JS解决异步的方案有哪些"></a>26.目前JS解决异步的方案有哪些</h3><p>回调函数<br>事件监听<br>发布-订阅<br>Promise<br>Generator<br>Async/Await</p><h3 id="27-创建对象有几种方法"><a href="#27-创建对象有几种方法" class="headerlink" title="27.创建对象有几种方法"></a>27.创建对象有几种方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种：字面量</span></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;<span class="attr">name</span>: <span class="string">&quot;o1&quot;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;<span class="attr">name</span>: <span class="string">&quot;o2&quot;</span>&#125;)</span><br><span class="line"><span class="comment">// 第二种：通过构造函数</span></span><br><span class="line"><span class="keyword">var</span> M = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;<span class="built_in">this</span>.name = name&#125;</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="keyword">new</span> M(<span class="string">&quot;o3&quot;</span>)</span><br><span class="line"><span class="comment">// 第三种：Object.create()</span></span><br><span class="line"><span class="keyword">var</span> p = &#123;<span class="attr">name</span>: <span class="string">&quot;p&quot;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> o4 = <span class="built_in">Object</span>.create(p)</span><br></pre></td></tr></table></figure><h2 id="四-Vue"><a href="#四-Vue" class="headerlink" title="四.Vue"></a>四.Vue</h2><p>vue的生命周期：就是vue实例从创建到销毁的过程，也就是从开始创建，初始化数据，编译模版，挂载Dom，渲染更新，卸载等过程</p><h3 id="1-Vue生命周期的作用是什么？"><a href="#1-Vue生命周期的作用是什么？" class="headerlink" title="1.Vue生命周期的作用是什么？"></a>1.Vue生命周期的作用是什么？</h3><p>它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑</p><h3 id="2-Vue生命周期总共有几个阶段？"><a href="#2-Vue生命周期总共有几个阶段？" class="headerlink" title="2.Vue生命周期总共有几个阶段？"></a>2.Vue生命周期总共有几个阶段？</h3><p>它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后</p><h3 id="3-DOM渲染在哪个周期中就已经完成？"><a href="#3-DOM渲染在哪个周期中就已经完成？" class="headerlink" title="3.DOM渲染在哪个周期中就已经完成？"></a>3.DOM渲染在哪个周期中就已经完成？</h3><p>DOM 渲染在 mounted 中就已经完成了</p><h3 id="4-每个生命周期适合哪些场景？"><a href="#4-每个生命周期适合哪些场景？" class="headerlink" title="4.每个生命周期适合哪些场景？"></a>4.每个生命周期适合哪些场景？</h3><p>生命周期钩子的一些使用方法：<br>    beforecreate : 可以在这加个loading事件，在加载实例时触发<br>    created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用<br>    mounted : 挂载元素，获取到DOM节点<br>    updated : 如果对数据统一处理，在这里写上相应函数<br>    beforeDestroy : 销毁实例前做收尾清除工作<br>    nextTick : 更新数据后立即操作dom</p><h3 id="5-关于vue的keep-alive需要条件性缓存的解决"><a href="#5-关于vue的keep-alive需要条件性缓存的解决" class="headerlink" title="5.关于vue的keep-alive需要条件性缓存的解决"></a>5.关于vue的keep-alive需要条件性缓存的解决</h3><p>A&gt;B不缓存，C&gt;B需要缓存<br>在路由里面加上了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">&#x27;/b&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;B&#x27;</span>,</span><br><span class="line">    component: B,</span><br><span class="line">    meta:&#123;</span><br><span class="line">    keepAlive:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在app.vue写了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">    &lt;router-view v-<span class="keyword">if</span>=<span class="string">&quot;$route.meta.keepAlive&quot;</span>&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line">&lt;router-view v-<span class="keyword">if</span>=<span class="string">&quot;!$route.meta.keepAlive&quot;</span>&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure><p>A页面写了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">beforeRouteLeave</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span><br><span class="line">    to.meta.keepAlive = <span class="literal">false</span>;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C页面写了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">beforeRouteLeave</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span><br><span class="line">    to.meta.keepAlive = <span class="literal">true</span>;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>meta.keepAlive=true这种方法，解决不了条件缓存问题<br>原因：在keep-alive源码中，include和exclude是被watch的 ，当发生变化时，keep-alive会去校验cache里是否匹配，匹配不上的会被删除。也就是说，官方是为这种情况做了处理的。而meta这种方法，因为没有存在某种类似于watch的方法，导致这种方法天然是和实际cache里面的内容有出入的，所以可定会存在各种奇怪的bug</p><p>利用include,动态添加”B”<br>1、在app.vue下增加keep-alive</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">&quot;catchList&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><p>catchList，是vuex维护的需要缓存的组件名的一个数组</p><p>2、在路由中加入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to,next,<span class="keyword">from</span></span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (to.name === <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">        store.commit(<span class="string">&#x27;keepAlive&#x27;</span>, <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3、在b.vue中加入(A&gt;B不缓存，C&gt;B缓存)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteLeave(<span class="function">(<span class="params">to,next,<span class="keyword">from</span></span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (to.name !== <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">        store.commit(<span class="string">&#x27;noKeepAlive&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在vuex中mutation是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">keepAlive</span>(<span class="params">state, component</span>)</span> &#123;</span><br><span class="line">    !state.catchList.includes(component) &amp;&amp;</span><br><span class="line">      state.catchList.push(component)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">noKeepAlive</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">    state.catchList = []</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>只要是B的组件，都缓存。只有当从A&gt;B的时候，才让B不缓存。</p><h3 id="6-Vue-路由懒加载"><a href="#6-Vue-路由懒加载" class="headerlink" title="6.Vue 路由懒加载"></a>6.Vue 路由懒加载</h3><p>Vue项目中实现路由按需加载（路由懒加载）的3中方式：<br>一、Vue异步组件技术：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">path: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">name: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">component: <span class="function"><span class="params">resolve</span> =&gt;</span> reqire([<span class="string">&#x27;path路径&#x27;</span>], resolve)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、es6提案的import()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Home = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;path路径&#x27;</span>)</span><br></pre></td></tr></table></figure><p>三、webpack提供的require.ensure()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">path: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">name: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">component: <span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">require</span>.ensure([],<span class="function">() =&gt;</span>  r(<span class="built_in">require</span>(<span class="string">&#x27;path路径&#x27;</span>)), <span class="string">&#x27;demo&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-Proxy与Object-defineProperty-的对比"><a href="#7-Proxy与Object-defineProperty-的对比" class="headerlink" title="7.Proxy与Object.defineProperty()的对比"></a>7.Proxy与Object.defineProperty()的对比</h3><p>Proxy的优点：<br>         1. 可以直接监听对象而非属性,并返回一个新对象<br>        2. 可以直接监听数值的变化<br>        3. 可以劫持整个对象，并返回一个新对象</p><p>Proxy的缺点：<br>    Proxy是es6提供的新特性，兼容性不好，所以导致Vue3一致没有正式发布让让广大开发者使用，IE不兼容</p><p>Object.defineProperty的优点：<br>    IE9以下的版本不兼容</p><p>Object.defineProperty的缺点：<br>    只能劫持对象的属性，我们需要对每个对象的每个属性进行遍历，无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应</p><p>Proxy代理整个对象，Object.defineProperty只代理对象上的某个属性。<br>如果对象内部要全部递归代理，则Proxy可以只在调用时递归，而Object.defineProperty需要在一开始就全部递归，Proxy性能优于Object.defineProperty。<br>对象上定义新属性时，Proxy可以监听到，Object.defineProperty监听不到。<br>数组新增删除修改时，Proxy可以监听到，Object.defineProperty监听不到。<br>Proxy不兼容IE，Object.defineProperty不兼容IE8及以下。</p><h3 id="8-v-show与v-if区别"><a href="#8-v-show与v-if区别" class="headerlink" title="8.v-show与v-if区别"></a>8.v-show与v-if区别</h3><p>v-show是css切换，v-if是完整的销毁和重新创建</p><p>使用 频繁切换时用v-show，运行时较少改变时用v-if</p><p>v-if=’false’ v-if是条件渲染，当false的时候不会渲染</p><h3 id="9-vue有哪些指令"><a href="#9-vue有哪些指令" class="headerlink" title="9.vue有哪些指令"></a>9.vue有哪些指令</h3><ul><li><p>v-model //在表单控件或者组件上创建双向绑定</p></li><li><p>v-if  //根据表达式的值的 truthiness 来有条件地渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建</p></li><li><p>v-else-if </p></li><li><p>v-else</p></li><li><p>v-text //更新元素的 textContent</p></li><li><p>v-show //根据表达式之真假值，切换元素的 display CSS property。</p></li><li><p>v-html://更新元素的 innerHTML。注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译。如果试图使用 v-html 组合模板，可以重新考虑是否通过使用组件来替代。</p></li><li><p>v-on:绑定事件监听器</p></li><li><p>v-bind //动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。</p></li><li><p>v-for //基于源数据多次渲染元素或模板块</p></li><li><p>v-cloak //这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕</p></li><li><p>v-once //只渲染元素和组件一次</p></li><li><p>v-pre //跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。</p></li><li><p>v-slot //提供具名插槽或需要接收 prop 的插槽</p></li></ul><p>绑定class的数组用法</p><pre><code>对象方法: v-bind:class=&quot;&#123;&#39;orange&#39;: isRipe, &#39;green&#39;: isNotRipe&#125;&quot;数组方法:  v-bind:class=&quot;[class1, class2]&quot;行内: v-bind:style=&quot;&#123;color: color, fontSize: fontSize+&#39;px&#39; &#125;&quot;</code></pre><h3 id="10-组件之间的传值通信"><a href="#10-组件之间的传值通信" class="headerlink" title="10.组件之间的传值通信"></a>10.组件之间的传值通信</h3><ul><li><p>父组件给子组件传值:props</p></li><li><p>子组件向父组件通信:父组件向子组件传递事件方法，子组件通过$emit触发事件，回调给父组件</p></li><li><p>非父子，兄弟组件之间通信:<br>可以通过实例一个vue实例Bus作为媒介，要相互通信的兄弟组件之中，都引入Bus，然后通过分别调用Bus事件触发和监听来实现通信和参数传递</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;button @click=<span class="string">&quot;toBus&quot;</span>&gt;子组件传给兄弟组件&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> Bus <span class="keyword">from</span> <span class="string">&#x27;../common/js/bus.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        toBus () &#123;</span><br><span class="line">            Bus.$emit(<span class="string">&#x27;on&#x27;</span>, <span class="string">&#x27;来自兄弟组件&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>另一个组件也import Bus.js 在钩子函数中监听on事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Bus <span class="keyword">from</span> <span class="string">&#x27;../common/js/bus.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">        message: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        Bus.$on(<span class="string">&#x27;on&#x27;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.message = msg</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-子组件调用父组件的方法函数"><a href="#11-子组件调用父组件的方法函数" class="headerlink" title="11.子组件调用父组件的方法函数"></a>11.子组件调用父组件的方法函数</h3><ul><li>直接在子组件中通过this.$parent.event来调用父组件的方法</li><li>在子组件里用$emit向父组件触发一个事件，父组件监听这个事件就行了</li><li>父组件把方法传入子组件中，在子组件里直接调用这个方法</li></ul><h3 id="12-路由跳转方式"><a href="#12-路由跳转方式" class="headerlink" title="12.路由跳转方式"></a>12.路由跳转方式</h3><p><router-link to='home'> router-link标签会渲染为<a>标签</p><p>另一种是编程是导航 也就是通过js跳转 比如 router.push(‘/home’)</p><h3 id="13-mvvm"><a href="#13-mvvm" class="headerlink" title="13.mvvm"></a>13.mvvm</h3><ul><li><p>M - Model，Model 代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑</p></li><li><p>V - View，View 代表 UI 组件，它负责将数据模型转化为 UI 展现出来</p></li><li><p>VM - ViewModel，ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步 View 和 Model 的对象，连接 Model 和 View之间的桥梁，绑定数据到viewmodel层并自动更新渲染到页面上，视图变化通知到viewmodel层去更新数据</p></li></ul><h3 id="14-computed和watch有什么区别"><a href="#14-computed和watch有什么区别" class="headerlink" title="14.computed和watch有什么区别?"></a>14.computed和watch有什么区别?</h3><ul><li><p>computed:</p><ol><li>computed是计算属性,也就是计算值,它更多用于计算值的场景</li><li>computed具有缓存性,computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时才会重新调用对应的getter来计算</li><li>computed适用于计算比较消耗性能的计算场景</li></ol></li><li><p>watch：</p><ol><li>更多的是「观察」的作用,类似于某些数据的监听回调,用于观察props $emit或者本组件的值,当数据变化时来执行回调进行后续操作</li><li>无缓存性，页面重新渲染时值不变化也会执行</li></ol></li><li><p>小结：</p><ol><li>当我们要进行数值计算,而且依赖于其他数据，那么把这个数据设计为computed</li><li>如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化</li></ol></li></ul><h3 id="15-key"><a href="#15-key" class="headerlink" title="15.key"></a>15.key</h3><p>key是为Vue中的vnode标记的唯一id，通过这个key，我们的diff操作可以 更准确、更快速</p><ul><li><p>准确:<br>  如果不加key,那么vue会选择复用节点(Vue的就地更新策略),<br>  导致之前节点的状态被保留下来，会产生一系列的bug</p></li><li><p>快速:<br>  key的唯一性可以被Map数据结构充分利用</p></li></ul><p>预期：number | string</p><p>key 的特殊属性主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key的变化重新排列元素顺序，并且会移除 key 不存在的元素。</p><p>有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误。</p><p>最常见的用例是结合 v-for：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用：</p><ul><li>完整地触发组件的生命周期钩子</li><li>触发过渡</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">:key</span>=<span class="string">&quot;text&quot;</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当 text 发生改变时，<span> 总是会被替换而不是被修改，因此会触发过渡</p><h3 id="16-组件中的data为什么是函数？"><a href="#16-组件中的data为什么是函数？" class="headerlink" title="16.组件中的data为什么是函数？"></a>16.组件中的data为什么是函数？</h3><p>组件可以被多次复用，创建多个实例，这些实例本质是同一个构造函数，如果data是对象，对象是引用类型，修改对象会影响所有实例，因此data是一个函数</p><h3 id="17-Class-与-Style-如何动态绑定？"><a href="#17-Class-与-Style-如何动态绑定？" class="headerlink" title="17.Class 与 Style 如何动态绑定？"></a>17.Class 与 Style 如何动态绑定？</h3><p>1)class<br>对象语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;&#123; &#x27;active&#x27;: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  hasError: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  activeClass: <span class="string">&#x27;active&#x27;</span>,</span><br><span class="line">  errorClass: <span class="string">&#x27;text-danger&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2)style：</p><p>对象语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=<span class="string">&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  activeColor: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">  fontSize: <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=<span class="string">&quot;[styleColor, styleSize]&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  styleColor: &#123;</span><br><span class="line">     color: <span class="string">&#x27;red&#x27;</span></span><br><span class="line">   &#125;,</span><br><span class="line">  styleSize:&#123;</span><br><span class="line">     fontSize:<span class="string">&#x27;23px&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18-vue的单向数据流"><a href="#18-vue的单向数据流" class="headerlink" title="18.vue的单向数据流"></a>18.vue的单向数据流</h3><p>所有的 prop都使得其父子prop之间形成了一个单向下行绑定：<br>父级 prop的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解</p><p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。<br>这意味着你不应该在一个子组件内部改变prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。<br>子组件想修改时，只能通过 $emit派发一个自定义事件，父组件接收到后，由父组件修改</p><p>有两种常见的试图改变一个 prop 的情形 :</p><p>1)这个 prop 用来传递一个初始值:<br>这个子组件接下来希望将其作为一个本地的 prop 数据来使用，在这种情况下，最好定义一个本地的 data属性并将这个 prop 用作其初始值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">&#x27;initialCounter&#x27;</span>],</span><br><span class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter: <span class="built_in">this</span>.initialCounter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2)prop 以一种原始的值传入且需要进行转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">&#x27;size&#x27;</span>],</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedSize: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19-keep-alive"><a href="#19-keep-alive" class="headerlink" title="19.keep-alive"></a>19.keep-alive</h3><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p><ul><li><p>一般结合路由和动态组件一起使用，用于缓存组件；</p></li><li><p>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include表示只有名称匹配的组件会被缓存，exclude表示任何名称匹配的组件都不会被缓存 ，其中 exclude的优先级比 include 高；</p></li><li><p>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</p></li></ul><h3 id="20-v-model-的原理"><a href="#20-v-model-的原理" class="headerlink" title="20.v-model 的原理"></a>20.v-model 的原理</h3><p>vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p><ul><li>text 和 textarea 元素使用 value 属性和 input 事件；</li><li>checkbox 和 radio 使用 checked 属性和 change 事件；</li><li>select 字段将 value 作为 prop 并将 change 作为事件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&#x27;something&#x27;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 相当于 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;something&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;something = $event.target.value&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件</p><h3 id="21-nextTick"><a href="#21-nextTick" class="headerlink" title="21.nextTick()"></a>21.nextTick()</h3><p>在下次DOM更新循环结束之后执行延迟回调。在修改数据之后，立即使用的这个回调函数，获取更新后的DOM</p><h3 id="22-vue插槽"><a href="#22-vue插槽" class="headerlink" title="22.vue插槽"></a>22.vue插槽</h3><ul><li><p>单个插槽：<br>  当子组件模板只有一个没有属性的插槽时，<br>  父组件传入的整个内容片段将插入到插槽所在的 DOM 位置，<br>  并替换掉插槽标签本身</p></li><li><p>命名插槽：<br>  solt元素可以用一个特殊的特性name来进一步配置如何分发内容。<br>  多个插槽可以有不同的名字。 这样可以将父组件模板中 slot 位置，<br>  和子组件 slot 元素产生关联，便于插槽内容对应传递</p></li><li><p>作用域插槽：<br>  可以访问组件内部数据的可复用插槽(reusable slot)<br>  在父级中，具有特殊特性 slot-scope 的<code>&lt;template&gt;</code> 元素必须存在，<br>  表示它是作用域插槽的模板。slot-scope 的值将被用作一个临时变量名，<br>  此变量接收从子组件传递过来的 prop 对象</p></li></ul><h3 id="23-导航守卫"><a href="#23-导航守卫" class="headerlink" title="23.导航守卫"></a>23.导航守卫</h3><p>vue-router提供的导航守卫主要通过跳转或取消的方式守卫导航<br>参数或查询的改变不会触发进入/离开的导航守卫<br>你可以通过观察 $route 对象来应对这些变化，或使用beforeRouteUpdate 的组件内守卫</p><ul><li>全局前置守卫：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 等待中</p><p>to: Route: 即将要进入的目标 路由对象</p><p>from: Route: 当前导航正要离开的路由</p><p>next: Function: 一定要调用该方法来 resolve这个钩子。执行效果依赖 next 方法的调用参数。<br>确保要调用 next 方法，否则钩子就不会被 resolved</p><ul><li>路由独享的守卫</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;/foo&#x27;</span>,</span><br><span class="line">      component: Foo,</span><br><span class="line">      beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>组件内的守卫</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  template: <span class="string">`...`</span>,</span><br><span class="line">  beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在渲染该组件的对应路由被 confirm 前调用</span></span><br><span class="line">    <span class="comment">// 不！能！获取组件实例 `this`</span></span><br><span class="line">    <span class="comment">// 因为当守卫执行前，组件实例还没被创建</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span><br><span class="line">    <span class="comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span><br><span class="line">    <span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 导航离开该组件的对应路由时调用</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vue-router有哪几种导航钩子</p><pre><code>第一种：是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截第二种：组件内的钩子：beforeRouteEnter/beforeRouteUpdate/beforeRouteLeave第三种：单独路由独享组件：beforeEnter</code></pre><h3 id="24-vuex是什么？"><a href="#24-vuex是什么？" class="headerlink" title="24.vuex是什么？"></a>24.vuex是什么？</h3><p>vuex是专门为vuejs应用程序开发的状态管理插件，集中存储管理组件状态，通过显式提交mutation改变组件状态<br>vuex 就是一个仓库，仓库里放了很多对象。其中 state就是数据源存放地，对应于一般 vue 对象里面的 data</p><p>state 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新</p><p>它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性</p><p>Vuex有5种属性: 分别是 state、getter、mutation、action、module;</p><ul><li><p>state<br>  Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据</p></li><li><p>mutations<br>  mutations定义的方法动态修改Vuex 的 store 中的状态或数据</p></li><li><p>getters<br>  类似vue的计算属性，主要用来过滤一些数据</p></li><li><p>actions<br>  actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action</p></li><li><p>modules<br>  由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得复杂时，store对象就变得臃肿。为了解决以上问题，vuex允许将store分隔成模块。每个模块有自己的state/getter/mutation/action,甚至是嵌套子模块。<br>总结<br>vuex 一般用于中大型 web 单页应用中对应用的状态进行管理，对于一些组件间关系较为简单的小型应用，使用 vuex 的必要性不是很大，因为完全可以用组件 prop属性或者事件来完成父子组件之间的通信，vuex 更多地用于解决跨组件通信以及作为数据中心集中式存储数据</p></li></ul><p>vuex解决了什么？<br>    多个组件依赖同一个状态，多层组件间传值<br>    来自不同的组件的行为需要变更同一个状态</p><h3 id="25-优化SPA首屏加载速度"><a href="#25-优化SPA首屏加载速度" class="headerlink" title="25.优化SPA首屏加载速度"></a>25.优化SPA首屏加载速度</h3><ul><li><p>缩小webpack或者其他打包工具生成的包的大小</p><p>  用webpack-bundle-analyzer的分析工具哪个模块占空间大</p></li><li><p>第三方UI组件按需引入</p></li><li><p>使用服务端渲染方式（基于vue的nuxt.js开发）</p></li><li><p>使用预渲染的方式</p><p>  在打包时会预先运行一次js代码，将一部分静态页面直接渲染成html写在生成的index.html中，在加载完index.html后页面就能展示，无需等待加载js缺点是在需要预渲染的页面较多时，build打包的时间会十分漫长</p></li><li><p>使用gzip减小网络传输的流量大小</p><p>  HTTP协议上的gzip编码是一种用来改进web应用程序性能的技术，web服务器和客户端（浏览器）必须共同支持gzip，使用gzip可以将原静态文件压缩到30%，效果很明显，对于优化首屏加载时间非常适合在nginx中配置<br>  http{<br>  gzip on;<br>  }</p></li><li><p>组件懒加载</p></li></ul><h3 id="26-你有对-Vue-项目进行哪些优化？"><a href="#26-你有对-Vue-项目进行哪些优化？" class="headerlink" title="26.你有对 Vue 项目进行哪些优化？"></a>26.你有对 Vue 项目进行哪些优化？</h3><p>1)代码层面的优化</p><ul><li>v-if 和 v-show 区分使用场景</li><li>computed 和 watch  区分使用场景</li><li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li><li>长列表性能优化</li><li>事件的销毁</li><li>图片资源懒加载</li><li>路由懒加载</li><li>第三方插件的按需引入</li><li>优化无限列表性能</li><li>服务端渲染 SSR or 预渲染</li><li>减少data中数据</li><li>SPA采用keep-alive缓存组件</li></ul><p>2)Webpack 层面的优化</p><ul><li>Webpack 对图片进行压缩</li><li>减少 ES6 转为 ES5 的冗余代码</li><li>提取公共代码</li><li>模板预编译</li><li>提取组件的 CSS</li><li>优化 SourceMap</li><li>构建结果输出分析</li><li>Vue 项目的编译优化</li><li>压缩代码</li><li>tree shaking</li><li>cdn加载第三方模块</li><li>sourcemap优化</li></ul><p>3)基础的 Web 技术的优化</p><ul><li>开启 gzip 压缩</li><li>浏览器缓存</li><li>CDN 的使用</li><li>使用 Chrome Performance 查找性能瓶颈</li></ul><h2 id="五-ES6"><a href="#五-ES6" class="headerlink" title="五.ES6"></a>五.ES6</h2><h3 id="1-var-let-const区别"><a href="#1-var-let-const区别" class="headerlink" title="1.var let const区别"></a>1.var let const区别</h3><p>let、const声明的变量仅在块级作用域内有效，var声明变<br>量是全局的，没有块级作用域功能<br>let 、const 不存在变量提升 , var 存在变量提升<br>let 、const不能在同一块级作用域内重复申请</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">test();<span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">test();<span class="comment">//ReferenceError: Cannot access &#x27;name&#x27; before initialization</span></span><br></pre></td></tr></table></figure><p>通过 var 声明的变量有初始值 undefined，而通过 let声明的变量直到定义的代码被执行时才会初始化。在变量初始化前访问变量会导致 ReferenceError</p><h3 id="2-解构赋值"><a href="#2-解构赋值" class="headerlink" title="2.解构赋值"></a>2.解构赋值</h3><p>1)数组解构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]   <span class="comment">//a=1, b=2, c=3</span></span><br><span class="line"><span class="keyword">let</span> [d, [e], f] = [<span class="number">1</span>, [<span class="number">2</span>], <span class="number">3</span>]    <span class="comment">//嵌套数组解构 d=1, e=2, f=3</span></span><br><span class="line"><span class="keyword">let</span> [g, ...h] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]   <span class="comment">//数组拆分 g=1, h=[2, 3]</span></span><br><span class="line"><span class="keyword">let</span> [i,,j] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]   <span class="comment">//不连续解构 i=1, j=3</span></span><br><span class="line"><span class="keyword">let</span> [k,l] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]   <span class="comment">//不完全解构 k=1, l=2</span></span><br></pre></td></tr></table></figure><p>2)对象解构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a, b&#125; = &#123;<span class="attr">a</span>: <span class="string">&#x27;aaaa&#x27;</span>, <span class="attr">b</span>: <span class="string">&#x27;bbbb&#x27;</span>&#125;      <span class="comment">//a=&#x27;aaaa&#x27; b=&#x27;bbbb&#x27;</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">d</span>: <span class="string">&#x27;aaaa&#x27;</span>, <span class="attr">e</span>: &#123;<span class="attr">f</span>: <span class="string">&#x27;bbbb&#x27;</span>&#125;&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;d, <span class="attr">e</span>:&#123;f&#125;&#125; = obj    <span class="comment">//嵌套解构 d=&#x27;aaaa&#x27; f=&#x27;bbbb&#x27;</span></span><br><span class="line"><span class="keyword">let</span> g;</span><br><span class="line">(g = &#123;<span class="attr">g</span>: <span class="string">&#x27;aaaa&#x27;</span>&#125;)   <span class="comment">//以声明变量解构 g=&#x27;aaaa&#x27;</span></span><br><span class="line"><span class="keyword">let</span> [h, i, j, k] = <span class="string">&#x27;nice&#x27;</span>    <span class="comment">//字符串解构 h=&#x27;n&#x27; i=&#x27;i&#x27; j=&#x27;c&#x27; k=&#x27;e&#x27;</span></span><br></pre></td></tr></table></figure><p>函数参数的定义  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">personInfo</span>(<span class="params">name, age, address, gender</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name, age, address, gender)</span><br><span class="line">&#125;</span><br><span class="line">personInfo(<span class="string">&#x27;william&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;changsha&#x27;</span>, <span class="string">&#x27;man&#x27;</span>)</span><br></pre></td></tr></table></figure><p>上面这个例子在对用户信息的时候需要传递四个参数，且需要一一对应，这样就会极易出现参数顺序传错的情况，从而导致bug，接下来来看es6解构赋值是怎么解决这个问题的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">personInfo</span>(<span class="params">&#123;name, age, address, gender&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name, age, address, gender)</span><br><span class="line">&#125;</span><br><span class="line">personInfo(&#123;<span class="attr">gender</span>: <span class="string">&#x27;man&#x27;</span>, <span class="attr">address</span>: <span class="string">&#x27;changsha&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;william&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;)</span><br></pre></td></tr></table></figure><p>交换变量的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="number">1</span>, b=<span class="number">2</span>;</span><br><span class="line">[b, a] = [a, b]</span><br><span class="line"><span class="built_in">console</span>.log(a, b)</span><br></pre></td></tr></table></figure><p>函数默认参数</p><p>es5：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveInfo</span>(<span class="params">name, age, address, gender</span>) </span>&#123;</span><br><span class="line">  name = name || <span class="string">&#x27;william&#x27;</span></span><br><span class="line">  age = age || <span class="number">18</span></span><br><span class="line">  address = address || <span class="string">&#x27;changsha&#x27;</span></span><br><span class="line">  gender = gender || <span class="string">&#x27;man&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(name, age, address, gender)</span><br><span class="line">&#125;</span><br><span class="line">saveInfo()</span><br></pre></td></tr></table></figure><p>es6:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveInfo</span>(<span class="params">&#123;name= <span class="string">&#x27;william&#x27;</span>, age= <span class="number">18</span>, address= <span class="string">&#x27;changsha&#x27;</span>, gender= <span class="string">&#x27;man&#x27;</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name, age, address, gender)</span><br><span class="line">&#125;</span><br><span class="line">saveInfo()</span><br></pre></td></tr></table></figure><h3 id="3-forEach、for-in、for-of三者区别"><a href="#3-forEach、for-in、for-of三者区别" class="headerlink" title="3.forEach、for in、for of三者区别"></a>3.forEach、for in、for of三者区别</h3><ul><li><p>forEach更多的用来遍历数组，无法return或break</p></li><li><p>for in 一般常用来遍历对象或json，循环遍历的值都是数据结构的键值，也遍历数组</p></li><li><p>for of数组对象都可以遍历，遍历对象需要通过和Object.keys()一起使用<br>它是ES6中新增加的语法，用来循环获取一对键值对中的值<br>一个数据结构只有部署了 Symbol.iterator 属性, 才具有 iterator接口可以使用 for of循环<br>以下数据结构部署了 Symbol.iteratoer属性：</p><ul><li>数组</li><li>Map</li><li>Set</li><li>String</li><li>Nodelist</li><li>arguments对象<br>如果想让对象可以使用 for of循环怎么办?使用 Object.keys() 获取对象的 key值集合后,再使用 for of<br>或者使用内置的Object.values()方法获取对象的value值集合再使用for of</li></ul></li><li><p>for in循环出的是key，for of循环出的是value</p></li></ul><h3 id="4-使用箭头函数应注意什么？"><a href="#4-使用箭头函数应注意什么？" class="headerlink" title="4.使用箭头函数应注意什么？"></a>4.使用箭头函数应注意什么？</h3><ul><li>1、用了箭头函数，this就不是指向window，而是父级（指向是可变的）</li><li>2、不能够使用arguments对象</li><li>3、不能用作构造函数，这就是说不能够使用new命令，否则会抛出一个错误</li><li>4、不可以使用yield命令，因此箭头函数不能用作 Generator 函数</li></ul><h3 id="5-Set、Map的区别"><a href="#5-Set、Map的区别" class="headerlink" title="5.Set、Map的区别"></a>5.Set、Map的区别</h3><p>应用场景Set用于数据重组，Map用于数据储存</p><ul><li>Set：<br>  1，成员不能重复<br>  2，只有键值没有键名，类似数组<br>  3，可以遍历，方法有add, delete,has</li><li>Map:<br>  1，本质上是健值对的集合，类似集合<br>  2，可以遍历，可以跟各种数据格式转换</li></ul><h3 id="6-Ajax："><a href="#6-Ajax：" class="headerlink" title="6.Ajax："></a>6.Ajax：</h3><p>1.创建一个XmlHttpRequest对象，也就是创建一个异步调用对象<br>2.创建一个发送请求到方法，设置http请求方法，url和验证信息<br>3.设置请求状态变化到方法<br>4.发送请求<br>5.获取异步调用返回的数据<br>6.使用js和dom实现局部刷新</p><h3 id="7-同步和异步的区别"><a href="#7-同步和异步的区别" class="headerlink" title="7.同步和异步的区别"></a>7.同步和异步的区别</h3><ul><li>同步：<br>按照一定的顺序去执行，执行完一个才能执行下一个浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作</li><li>异步：<br>浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容执行顺序是不确定的，由触发条件决定，什么时间执行也是不确定的，即使是定时器（下面做解释），异步处理可以同时执行多个。</li></ul><h3 id="8-ajax的优点和缺点"><a href="#8-ajax的优点和缺点" class="headerlink" title="8.ajax的优点和缺点"></a>8.ajax的优点和缺点</h3><ul><li><p>ajax的优点<br>  1、无刷新更新数据（在不刷新整个页面的情况下维持与服务器通信）<br>  2、异步与服务器通信（使用异步的方式与服务器通信，不打断用户的操作）<br>  3、前端和后端负载均衡（将一些后端的工作交给前端，减少服务器与宽度的负担）<br>  4、界面和应用相分离（ajax将界面和应用分离也就是数据与呈现相分离）</p></li><li><p>ajax的缺点<br>  1、ajax不支持浏览器back按钮<br>  2、安全问题 Aajax暴露了与服务器交互的细节<br>  3、对搜索引擎的支持比较弱<br>  4、破坏了Back与History后退按钮的正常行为等浏览器机制</p></li></ul><h3 id="9-get和post的区别"><a href="#9-get和post的区别" class="headerlink" title="9.get和post的区别"></a>9.get和post的区别</h3><p>1、get和post在HTTP中都代表着请求数据，其中get请求相对来说更简单、快速，效率高些<br>2、get相对post安全性低<br>3、get有缓存，post没有<br>4、get体积小，post可以无限大<br>5、get的url参数可见，post不可见<br>6、get只接受ASCII字符的参数数据类型，post没有限制<br>7、get请求参数会保留历史记录，post中参数不会保留<br>8、get会被浏览器主动catch，post不会，需要手动设置<br>9、get在浏览器回退时无害，post会再次提交请求</p><h3 id="10-什么时候使用post？"><a href="#10-什么时候使用post？" class="headerlink" title="10.什么时候使用post？"></a>10.什么时候使用post？</h3><p>post一般用于修改服务器上的资源，对所发送的信息没有限制。比如<br>    1、无法使用缓存文件（更新服务器上的文件或数据库）<br>    2、向服务器发送大量数据（POST 没有数据量限制）<br>    3、发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</p><h3 id="11-同源策略"><a href="#11-同源策略" class="headerlink" title="11.同源策略"></a>11.同源策略</h3><p>同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能相互读取对方资源</p><p>同源策略限制了一个源的文档和脚本和另一个源的资源进行交互，是一个隔离潜在恶意文件攻击的安全机制</p><p>不受同源策略限制的：</p><p>1.页面中的连接，重定向和表单提交<br>2.第三方js的引入不受限制，但不能js读写加载的内容，script，link，img，iframe</p><h3 id="12-如何解决跨域问题"><a href="#12-如何解决跨域问题" class="headerlink" title="12.如何解决跨域问题?"></a>12.如何解决跨域问题?</h3><p>跨域的概念：协议、域名、端口都相同才同域，否则都是跨域</p><p>解决跨域问题：</p><p>1、 通过jsonp跨域<br>2、 document.domain + iframe跨域<br>3、 location.hash + iframe<br>4、 window.name + iframe跨域<br>5、 postMessage跨域<br>6、 跨域资源共享（CORS）<br>7、 nginx代理跨域<br>8、 nodejs中间件代理跨域<br>9、 WebSocket协议跨域</p><h2 id="六-浏览器"><a href="#六-浏览器" class="headerlink" title="六.浏览器"></a>六.浏览器</h2><h3 id="1-主流浏览器"><a href="#1-主流浏览器" class="headerlink" title="1.主流浏览器"></a>1.主流浏览器</h3><p>IE Google Chrome Firefox Opera Safari</p><h3 id="2-浏览器内核"><a href="#2-浏览器内核" class="headerlink" title="2.浏览器内核"></a>2.浏览器内核</h3><p>渲染引擎和js引擎<br>渲染引擎：用来解释网页语法并渲染到网页上</p><p>浏览器内核决定了如何显示网页内容和格式化的信息<br>Trident：IE、360<br>Gecko：火狐<br>Presto：Opera<br>Blink：Opera，Googlechrome<br>webkit：Safari</p><h3 id="3-浏览器兼容"><a href="#3-浏览器兼容" class="headerlink" title="3.浏览器兼容"></a>3.浏览器兼容</h3><p>1.不同浏览器默认内外边距不同：*{margin:0;padding:0}<br>2.图片默认有间距:img设置float<br>3. IE6双边距bug：块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大。hack：display:inline;将其转化为行内属性。<br>4. 设置较小高度标签（一般小于10px），在IE6，IE7中高度超出自己设置高度。hack：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。<br>5. Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。<br>6. 超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有hover和active了。解决方法是改变CSS属性的排列顺序:L-V-H-A ( love hate ): a:link {} a:visited {} a:hover {} a:active {}</p><h2 id="七-其他"><a href="#七-其他" class="headerlink" title="七.其他"></a>七.其他</h2><h3 id="1-前端组件化和模块化"><a href="#1-前端组件化和模块化" class="headerlink" title="1.前端组件化和模块化"></a>1.前端组件化和模块化</h3><p>组件化：组件化是具体的，按照一些功能的通用性和复用性来抽象组件侧重于UI部分，比如弹窗按钮</p><p>模块化：模块化是抽象的，按照项目业务划分的大块侧重于数据数据的封装</p><p>对于组件来说，其主要是提高代码的复用性，功能单一独立模块是将同一类型的代码整合在一起，例如用户信息，设置等，所以模块等功能相当复杂，但都同属于同一业务（提高内聚降低耦合）</p><h3 id="2-什么是Ajax和JSON，它们的优点和缺点"><a href="#2-什么是Ajax和JSON，它们的优点和缺点" class="headerlink" title="2.什么是Ajax和JSON，它们的优点和缺点"></a>2.什么是Ajax和JSON，它们的优点和缺点</h3><ul><li><p>Ajax：</p><p>  Ajax是异步JavaScript和XML，用于在Web页面中实现异步数据交互<br>  Ajax优点：<br>  异步请求响应快，用户体验好；页面无刷新、数据局部更新；按需取数据，减少了冗余请求和服务器的负担；<br>  Ajax缺点：<br>  异步回调问题、this指向问题、路由跳转back问题；对搜索引擎的支持比较弱，对于一些手机还不是很好的支持</p></li><li><p>JSON：</p><p>  是一种轻量级的数据交换格式，看着像对象，本质是字符串<br>  JSON优点：<br>  轻量级、易于人的阅读和编写，便于js解析，支持复合数据类型<br>  JSON缺点：<br>  没有XML格式这么推广的深入人心和使用广泛, 没有XML那么通用性。</p></li></ul><h3 id="3-Github"><a href="#3-Github" class="headerlink" title="3.Github"></a>3.Github</h3><p>git常用的命令<br>从远程库克隆到本地：git clone 网站上的仓库地址<br>新增文件的命令：git add .<br>提交文件的命令：git commit –m或者git commit –a<br>查看工作区状况：git status –s<br>拉取合并远程分支的操作：git fetch/git merge或者git pull<br>查看提交记录命令：git reflog</p><h3 id="4-webpack"><a href="#4-webpack" class="headerlink" title="4.webpack"></a>4.webpack</h3><p>webpack打包原理：<br>webpack只是一个打包模块的机制，只是把依赖的模块转化成可以代表这些包的静态文件。webpack就是识别你的入口文件。识别你的模块依赖，来打包你的代码。至于你的代码使用的是commonjs还是amd或者es6的import。webpack都会对其进行分析。来获取代码的依赖。webpack做的就是分析代码，转换代码，编译代码，输出代码。webpack本身是一个node的模块，所以webpack.config.js是以commonjs形式书写的(node中的模块化是commonjs规范的)</p><p>webpack 核心概念<br>1.entry<br>入口起点(entry point)指示 webpack 应该使用哪个模块,来作为构建其内部依赖图的开始. 进入入口起点后,webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。 每个依赖项随即被处理,最后输出到称之为 bundles 的文件中。</p><p>2.output<br>output 属性告诉 webpack 在哪里输出它所创建的bundles,以及如何命名这些文件,默认值为 ./dist。 基本上整个应用程序结构,都会被编译到你指定的输出路径的文件夹中。</p><p>3.Module 模块<br>在 Webpack 里一切皆模块,一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块</p><p>4.chunk 代码块<br>一个 Chunk 由多个模块组合而成,用于代码合并与分割。</p><p>5.loader<br>loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。 loader 可以将所有类型的文件转换为 webpack能够处理的有效模块,然后你就可以利用 webpack 的打包能力,对它们进行处理。 本质上,webpack loader将所有类型的文件,转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。</p><p>6.Plugin<br>loader 被用于转换某些类型的模块,而插件则可以用于执行范围更广的任务。 插件的范围包括,从打包优化和压缩,一直到重新定义环境中的变量。插件接口功能极其强大,可以用来处理各种各样的任务。</p><p>模块热更新<br>模块热更新是webpack的一个功能，他可以使代码修改过后不用刷新就可以更新，是高级版的自动刷新浏览器</p><p>devServer中通过hot属性可以控制模块的热替换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> env = process.env.NODE_ENV == <span class="string">&quot;development&quot;</span> ? <span class="string">&quot;development&quot;</span> : <span class="string">&quot;production&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  mode: env,</span><br><span class="line"> devServer: &#123;</span><br><span class="line">     hot:<span class="literal">true</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">  plugins: [</span><br><span class="line">     <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(), <span class="comment">//热加载插件</span></span><br><span class="line">  ],</span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure><p>webpack的优点</p><pre><code>专注于处理模块化的项目，能做到开箱即用，一步到位可通过plugin扩展，完整好用又不失灵活使用场景不局限于web开发社区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展良好的开发体验</code></pre><p>webpack的缺点</p><pre><code>webpack的缺点是只能用于采用模块化开发的项目</code></pre><h3 id="5-微信小程序"><a href="#5-微信小程序" class="headerlink" title="5.微信小程序"></a>5.微信小程序</h3><ul><li>onLoad()：页面加载时触发。</li><li>onReady()：页面初次渲染完成时触发。</li><li>onShow()：页面显示/切入前台时触发。</li><li>onHide()：页面隐藏/切入后台时触发。</li><li>onUnload()：页面卸载时触发。</li></ul><p>小程序运行环境分为渲染层和逻辑层，其中wxml和wxss工作在渲染层，js工作在逻辑层</p><p>小程序的渲染层和逻辑层分别由两个线程来管理：渲染层的界面使用webview来管理，逻辑层使用jscore来运行js脚本，一个小程序存在多个界面，所以渲染层有多个webview，两个线程通过微信客户端做中转，逻辑层请求网络经由客户端转发</p><h3 id="6-微信小程序支付流程："><a href="#6-微信小程序支付流程：" class="headerlink" title="6.微信小程序支付流程："></a>6.微信小程序支付流程：</h3><ul><li>1.wx.login用code换取openid</li><li>2.生成商户订单</li><li>3.调用支付统一下单api，返回预付单信息prepay_id</li><li>4.将组合数据再次签名，返回5个参数和sign</li><li>5.小程序获取参数后，鉴权调起支付</li><li>6.返回支付结果给小程序，推送支付结果给商户，修改订单状态</li></ul><p><img src="/ZJY.github.io/timages/weappPay.png" alt="image"></p><h3 id="7-微信网页授权流程"><a href="#7-微信网页授权流程" class="headerlink" title="7.微信网页授权流程"></a>7.微信网页授权流程</h3><p>前置条件：<br>        公众平台设置授权回调域名，在域名内页面可进行OAuth2.0鉴权</p><p>关于网页授权的两种scope的区别说明<br>1.以snsapi_base为scope发起的网页授权，是用来获取进入页面的用户的openid的，并且是静默授权跳转到回调页面的<br>2.snsapi_userinfo为scope发起的网页授权，是用来获取用户基本信息的，但是需要用户手动同意，由于用户同意过所以无需关注就可获取用户基本信息<br>3、用户管理类接口中的“获取用户基本信息接口”，是在用户和公众号产生消息交互或关注后事件推送后，才能根据用户OpenID来获取用户基本信息。这个接口，包括其他微信接口，都是需要该用户（即openid）关注了公众号后，才能调用成功的。</p><p>网页授权流程分为四步：<br>        1.引导用户进入授权页面，同意授权，获取code<br>        2.通过code换取网页授权access_token<br>        3.如果需要，刷新access_token<br>        4.通过access_token和opened获取用户基本信息</p><h3 id="8-小程序登录流程"><a href="#8-小程序登录流程" class="headerlink" title="8.小程序登录流程"></a>8.小程序登录流程</h3><p>1.wx.login()获取code，传给开发者服务器<br>2.开发者服务器用appid,appsecret,code调用登录凭证校验<br>（ auth.code2Session ）向微信服务器获取openid和sessionkey<br>3.发者服务器可以根据用户标识来生成自定义登录态，用于后<br>续业务逻辑中前后端交互时识别用户身份。</p><h3 id="9-小程序授权"><a href="#9-小程序授权" class="headerlink" title="9.小程序授权"></a>9.小程序授权</h3><p>如果用户未接受或拒绝过此权限，会弹窗询问用户，用户点击同意后方可调用接口；</p><p>如果用户已授权，可以直接调用接口；</p><p>如果用户已拒绝授权，则不会出现弹窗，而是直接进入接口fail 回调。请开发者兼容用户拒绝授权的场景。（wx.openSetting引导用户进行授权）</p><p>开发者可以使用 wx.getSetting 获取用户当前的授权状态。</p><p>微信小程序分为两个部分：webview 和 appService。其中 webview 主要用来展示 UI，appService 用来处理业务逻辑、数据及接口调用。它们在两个进程中进行，通过系统层 JSBridge 实现通信，实现 UI 的渲染、事件的处理</p><h3 id="10-网络协议"><a href="#10-网络协议" class="headerlink" title="10.网络协议"></a>10.网络协议</h3><p>网络分层<br>目前网络分层可分为两种：OSI 模型和 TCP/IP 模型<br>OSI模型</p><pre><code>应用层（Application）表示层（Presentation）会话层（Session）传输层（Transport）网络层（Network）数据链路层（Data Link）物理层（Physical）</code></pre><p>TCP/IP模型</p><pre><code>应用层（Application）传输层（Host-to-Host Transport）互联网层（Internet）网络接口层（Network Interface）</code></pre><h3 id="11-HTTP-HTTPS"><a href="#11-HTTP-HTTPS" class="headerlink" title="11.HTTP/HTTPS"></a>11.HTTP/HTTPS</h3><p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用<br>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议<br>3、http和https使用的是完全不同的连接方式，用的端口也不一样，默认前者是80，后者是443<br>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><h3 id="12-从输入URL到页面加载到过程？"><a href="#12-从输入URL到页面加载到过程？" class="headerlink" title="12.从输入URL到页面加载到过程？"></a>12.从输入URL到页面加载到过程？</h3><p>1.浏览器地址栏输入URL并回车<br>2.通过DNS将域名解析成IP地址。在解析过程中，按照浏览器缓存、系统缓存、路由器缓存、ISP(运营商)DNS缓存、根域名服务器、顶级域名服务器、主域名服务器的顺序，逐步读取缓存，直到拿到IP地址。（应用层）<br>3.根据获取IP进行tcp连接（三次握手）（传输层）<br>4.发送http请求<br>5.服务器处理请求，浏览器接收http的响应<br>6.渲染页面，构造dom树<br>7.关闭tcp连接（四次挥手）</p><h3 id="13-HTTP状态码"><a href="#13-HTTP状态码" class="headerlink" title="13.HTTP状态码"></a>13.HTTP状态码</h3><p>区分状态码<br>    1××开头  - 临时响应<br>    2××开头  - 请求成功<br>    3××开头  - 请求被重定向<br>    4××开头  - 请求错误<br>    5××开头  - 服务器错误<br>常见状态码<br>    200 - 请求成功，Ajax 接受到信息了<br>    400 - 服务器不理解请求<br>    403 - 服务器拒绝请求<br>    404 - 请求页面错误<br>    500 - 服务器内部错误，无法完成请求</p><h3 id="14-性能优化"><a href="#14-性能优化" class="headerlink" title="14.性能优化"></a>14.性能优化</h3><ul><li><p>HTML优化<br>  1、避免 HTML 中书写 CSS 代码，因为这样难以维护。<br>  2、使用 Viewport 加速页面的渲染。<br>  3、使用语义化标签，减少 CSS 代码，增加可读性和 SEO。<br>  4、减少标签的使用，DOM 解析是一个大量遍历的过程，减少不必要的标签，能降低遍历的次数。<br>  5、避免 src、href 等的值为空，因为即时它们为空，浏览器也会发起 HTTP 请求。</p></li><li><p>CSS优化<br>  1、优化选择器路径：使用 .c {} 而不是 .a .b .c {}。<br>  2、选择器合并：共同的属性内容提起出来，压缩空间和资源开销。<br>  3、精准样式：使用 padding-left: 10px 而不是 padding: 0 0 0 10px。<br>  4、雪碧图：将小的图标合并到一张图中，这样所有的图片只需要请求一次。<br>  5、避免通配符：.a .b * {} 这样的选择器，根据从右到左的解析顺序在解析过程中遇到通配符 * {} 会遍历整个 DOM，性能大大损耗。<br>  6、少用 float：float 在渲染时计算量比较大，可以使用 flex 布局。<br>  7、为 0 值去单位：增加兼容性。<br>  8、压缩文件大小，减少资源下载负担。</p></li><li><p>JavaScript优化<br>  1、尽可能把 <code>&lt;script&gt;</code> 标签放在 body 之后，避免 JS 的执行卡住 DOM 的渲染，最大程度保证页面尽快地展示出来<br>  2、尽可能合并 JS 代码：提取公共方法，进行面向对象设计等……<br>  3、CSS 能做的事情，尽量不用 JS 来做，毕竟 JS 的解析执行比较粗暴，而 CSS 效率更高。<br>  4、尽可能逐条操作 DOM，并预定好 CSs 样式，从而减少 reflow 或者 repaint 的次数。<br>  5、尽可能少地创建 DOM，而是在 HTML 和 CSS 中使用 display: none 来隐藏，按需显示。<br>  6、压缩文件大小，减少资源下载负担。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试</title>
      <link href="/ZJY.github.io/2021/01/20/%E9%9D%A2%E8%AF%95/"/>
      <url>/ZJY.github.io/2021/01/20/%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="1-webpack优化："><a href="#1-webpack优化：" class="headerlink" title="1.webpack优化："></a>1.webpack优化：</h3><ul><li><p>优化开发体验（提升开发效率）</p><ul><li>优化构建速度 （配置时相关路径尽量写绝对路径，以减少查找，代码中写导入语句时，确定文件时带上文件后缀，以避免查找）</li><li>使用DllPlugin (动态链接库,原因在于包含大量复用模块的动态链接库只需要编译一次，在之后的构建过程中被动态链接库包含的模块将不会在重新编译，而是直接使用动态链接库中的代码)</li><li>使用HappyPack （在整个 Webpack 构建流程中，最耗时的流程可能就是 Loader 对文件的转换操作了，因为要转换的文件数据巨多，而且这些转换操作都只能一个个挨着处理。HappyPack的核心原理就是把这部分任务分解到多个进程去并行处理，从而减少了总的构建时间。）</li><li>使用ParallelUglifyPlugin (ParallelUglifyPlugin 会开启多个子进程，把对多个文件的压缩工作分配给多个子进程去完成，每个子进程其实还是通过 UglifyJS去压缩代码，但是变成了并行执行)</li></ul></li><li><p>优化使用体验</p><ul><li>使用自动刷新（使用 webpack 模块负责监听文件，webpack-dev-server 模块则负责刷新浏览器。）</li><li>使用模块热替换 （hot）</li></ul></li><li><p>优化输出质量</p><ul><li>减少用户能感知到的加载时间，也就是首屏加载<ul><li>区分环境 （开发和线上环境 代码压缩和提示日志）</li><li>压缩代码 （UglifyJsPlugin：通过封装 UglifyJS 实现压缩。ParallelUglifyPlugin：多进程并行处理压缩）</li><li>CDN加速 （CDN 又叫内容分发网络，通过把资源部署到世界各地，用户在访问时按照就近原则从离用户最近的服务器获取资源，从而加速资源的获取速度。要给网站接入 CDN，需要把网页的静态资源上传到 CDN 服务上去，在服务这些静态资源的时候需要通过 CDN 服务提供的 URL 地址去访问）</li><li>使用Tree Shaking (Tree Shaking 可以用来剔除 JavaScript 中用不上的死代码)</li><li>提取公共代码</li><li>按需加载</li></ul></li></ul></li></ul><h3 id="2-webpack如何区分环境？"><a href="#2-webpack如何区分环境？" class="headerlink" title="2.webpack如何区分环境？"></a>2.webpack如何区分环境？</h3><p>具体区分方法很简单，在源码中通过如下方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;你正在线上环境&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;你正在使用开发环境&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其大概原理是借助于环境变量的值去判断执行哪个分支</p><h3 id="3-小程序的生命周期和路由以及setData原理"><a href="#3-小程序的生命周期和路由以及setData原理" class="headerlink" title="3.小程序的生命周期和路由以及setData原理"></a>3.小程序的生命周期和路由以及setData原理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">onLaunch</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onLaunch监听小程序初始化&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">onShow</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onShow监听小程序显示&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">onHide</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onHide监听小程序隐藏&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小程序的生命周期函数的调用顺序为：onLaunch&gt;onShow&gt;onHide</p><p>页面生命周期：<br>页面生命周期函数就是当你每进入/切换到一个新的页面的时候，就会调用的生命周期函数。Page(Object) 函数用来注册一个页面。接受一个Object类型参数，其指定页面的初始数据、生命周期回调、事件处理函数等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">onLoad</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onLoad监听页面加载:首次进入页面加载时触发，可以在 onLoad 的参数中获取打开当前页面路径中的参数。&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">onReady</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onReady监听页面初次渲染完成&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">onShow</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onShow监听页面显示:加载完成后、后台切到前台或重新进入页面时触发&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">onHide</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onHide监听页面隐藏&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">onUnload</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onUnload监听页面卸载&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生命周期函数的调用顺序为：onLoad&gt;onShow&gt;onReady。</p><p>首次进入小程序会先触发应用生命周期中onLaunch方法和onShow方法，其次触发页面生命周期中onLoad、onShow和onReady方法。</p><p>前台切换到后台时，先触发页面生命周期中onHide方法，再触发应用生命周期的onHide方法。</p><p>后台切换到前台时，先触发应用生命周期中onShow方法，再触发页面生命周期的onShow方法。</p><p>setData:setData 函数用于将数据从逻辑层发送到视图层（异步），同时改变对应的 this.data 的值（同步）</p><p>setData工作原理<br>小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。当前，视图层和逻辑层的数据传输，实际上通过两边提供的 evaluateJavascript 所实现。即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。</p><p>而 evaluateJavascript 的执行会受很多方面的影响，数据到达视图层并不是实时的。</p><h3 id="4-哪些css属性可以继承？"><a href="#4-哪些css属性可以继承？" class="headerlink" title="4.哪些css属性可以继承？"></a>4.哪些css属性可以继承？</h3><p>可继承的有： font-size font-family color、<br>不可继承的有：border、padding、margin、width、height<br>与字体相关的样式通常可以继承，与尺寸相关的样式通常不能继承</p><h3 id="5-call-apply-bind都是用来重新定义this对象的"><a href="#5-call-apply-bind都是用来重新定义this对象的" class="headerlink" title="5.call/apply/bind都是用来重新定义this对象的"></a>5.call/apply/bind都是用来重新定义this对象的</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;wang&#x27;</span>,age = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;zhang&#x27;</span>,</span><br><span class="line">    objAag: <span class="built_in">this</span>.age,</span><br><span class="line">    myFun:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;年龄&#x27;</span> + <span class="built_in">this</span>.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.objAag; <span class="comment">//17</span></span><br><span class="line">obj.myFun(); <span class="comment">//zhang年龄undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用call/apply/bind</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db = &#123;</span><br><span class="line">    name:<span class="string">&#x27;dema&#x27;</span>,</span><br><span class="line">    age: <span class="number">99</span></span><br><span class="line">&#125;</span><br><span class="line">obj.myFun.call(db); <span class="comment">// dema年龄99</span></span><br><span class="line">obj.myFun.apply(db); <span class="comment">// dema年龄99</span></span><br><span class="line">obj.myFun.bind(db)(); <span class="comment">// dema年龄99</span></span><br></pre></td></tr></table></figure><p>以上除了bind多了个（）外，结果都一致，由此可知，bind返回的是一个新函数，必须调用它能执行</p><p>call/apply/bind 传参数区别</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;wang&#x27;</span>,age = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;zhang&#x27;</span>,</span><br><span class="line">    objAag: <span class="built_in">this</span>.age,</span><br><span class="line">    myFun:<span class="function"><span class="keyword">function</span>(<span class="params">fm,t</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;年龄&#x27;</span> + <span class="built_in">this</span>.age,<span class="string">&#x27;来自 &#x27;</span>+ fm+<span class="string">&#x27; 去往&#x27;</span>+t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> db = &#123;</span><br><span class="line">    name:<span class="string">&#x27;dema&#x27;</span>,</span><br><span class="line">    age: <span class="number">99</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.myFun.call(db,<span class="string">&#x27;成都&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>); <span class="comment">//dema年龄99 来自 成都 去往上海</span></span><br><span class="line">obj.myFun.apply(db,[<span class="string">&#x27;成都&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>]); <span class="comment">//dema年龄99 来自 成都 去往上海</span></span><br><span class="line">obj.myFun.bind(db,[<span class="string">&#x27;成都&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>])(); <span class="comment">//dema年龄99 来自 成都,上海 去往undefined</span></span><br><span class="line">obj.myFun.bind(db,<span class="string">&#x27;成都&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>)(); <span class="comment">//dema年龄99 来自 成都 去往上海</span></span><br><span class="line">obj.myFun.bind(db)(<span class="string">&#x27;成都&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>); <span class="comment">// dema年龄99 来自 成都 去往上海</span></span><br></pre></td></tr></table></figure><p>call 、bind 、 apply 这三个函数的第一个参数都是 this 的指向对象,第二个参数：<br>call的参数直接放进去，多个参数用逗号分隔<br>apply的第二个参数是数组<br>bind 除了返回是函数以外，它 的参数和 call 一样</p><h3 id="6-z-index属性"><a href="#6-z-index属性" class="headerlink" title="6.z-index属性"></a>6.z-index属性</h3><p>z-index 属性指定一个元素的堆叠顺序。</p><p>拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。</p><p>注释：元素可拥有负的 z-index 属性值。</p><p>注释：Z-index 仅能在定位元素上奏效（例如 position:absolute, position:relative, or position:fixed)</p><p>可能的值：</p><ul><li>auto ：默认。堆叠顺序与父元素相等。</li><li>number ：设置元素的堆叠顺序。</li><li>inherit： 规定应该从父元素继承 z-index 属性的值。</li></ul><p>默认的 z-index 是 0</p><h3 id="7-vue生命周期"><a href="#7-vue生命周期" class="headerlink" title="7.vue生命周期"></a>7.vue生命周期</h3><ul><li>beforeCreate：在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用</li><li>created：在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，property 和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el property 目前尚不可用。一般creadted钩子函数主要是用来初始化数据。</li><li>beforeMount：在挂载开始之前被调用：相关的 render 函数首次被调用。</li><li>mounted： 实例被挂载后调用，这时 el 被新创建的 vm.$el 替换了。如果根实例挂载到了一个文档内的元素上，当 mounted 被调用时 vm.$el 也在文档内。注意 mounted 不会保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 mounted 内部使用 vm.$nextTick。该钩子函数是在挂在完成以后也就是模板渲染完成以后才会被调用</li><li>beforeUpdate： 数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</li><li>updated:由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。</li><li>activated：被 keep-alive 缓存的组件激活时调用。</li><li>deactivated：被 keep-alive 缓存的组件停用时调用</li><li>beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用</li><li>destroyed： 实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁</li><li>errorCaptured：当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。</li></ul><h3 id="8-JavaScript的let和const"><a href="#8-JavaScript的let和const" class="headerlink" title="8.JavaScript的let和const"></a>8.JavaScript的let和const</h3><p>ES2015(ES6) 新增加了两个重要的 JavaScript 关键字: let 和 const。</p><p>let 声明的变量只能let命令所在代码块内有效<br>const声明一个只读的常量，一旦声明了值，该值就不能改变。</p><p>在 ES6 之前，JavaScript 只有两种作用域： 全局变量 与 函数内的局部变量。</p><p>全局变量：</p><p>在函数外声明的变量是全局的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> carName = <span class="string">&quot;Volvo&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这里可以使用 carName 变量</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里也可以使用 carName 变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局变量在js程序的任何地方都可用</p><p>局部变量：<br>在函数内部声明的变量的作用域是局部的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里不能使用 carName 变量</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> carName = <span class="string">&quot;Volvo&quot;</span>;</span><br><span class="line">    <span class="comment">// 这里可以使用 carName 变量</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这里不能使用 carName 变量</span></span><br></pre></td></tr></table></figure><p>函数内使用var声明的变量只能在函数内部可用，没有用var声明的变量全局可用</p><p>javascript的块级作用域：<br>使用var声明的变量不具有块级作用域的特性，在{}外仍然能使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">2</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里可以使用 x 变量</span></span><br></pre></td></tr></table></figure><p>在es6之前没有块级作用域的概念<br>es6可以使用let关键字来实现块级作用域<br>let 声明的变量只在 let 命令所在的代码块 {} 内有效，在 {} 之外不能访问。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里不能使用 x 变量</span></span><br></pre></td></tr></table></figure><p>重新定义变量：</p><p>使用var关键字重新声明变量会带来问题<br>在块中重新声明变量也会重新声明块外的变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 这里输出 x 为 10</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 这里输出 x 为 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里输出 x 为 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>let 关键字就可以解决这个问题，因为它只在 let 命令所在的代码块 {} 内有效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 这里输出 x 为 10</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 这里输出 x 为 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里输出 x 为 10</span></span><br></pre></td></tr></table></figure><p>循环作用域：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一些代码...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里输出 i 为 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一些代码...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里输出 i 为 5</span></span><br></pre></td></tr></table></figure><p>在第一个实例中，使用了 var 关键字，它声明的变量是全局的，包括循环体内与循环体外。</p><p>在第二个实例中，使用 let 关键字， 它声明的变量作用域只在循环体内，循环体外的变量不受影响。</p><p>局部变量：</p><p>在函数体内使用 var 和 let 关键字声明的变量有点类似。</p><p>它们的作用域都是 局部的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 var</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> carName = <span class="string">&quot;Volvo&quot;</span>;   <span class="comment">// 局部作用域</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 let</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> carName = <span class="string">&quot;Volvo&quot;</span>;   <span class="comment">//  局部作用域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局变量<br>在函数体外或代码块外使用 var 和 let 关键字声明的变量也有点类似。</p><p>它们的作用域都是 全局的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 var</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;       <span class="comment">// 全局作用域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 let</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">2</span>;       <span class="comment">// 全局作用域</span></span><br></pre></td></tr></table></figure><p>HTML 代码中使用全局变量:<br>在JavaScript中，全局作用域是针对JavaScript环境<br>在html中，全局作用域是指window对象</p><p>使用var关键字声明的全局作用域变量是属于 window 对象:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> carName = <span class="string">&quot;Volvo&quot;</span>;</span><br><span class="line"><span class="comment">// 可以使用 window.carName 访问变量</span></span><br></pre></td></tr></table></figure><p>使用let声明的全局作用域变量不属于window对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> carName = <span class="string">&quot;Volvo&quot;</span>;</span><br><span class="line"><span class="comment">// 不能使用 window.carName 访问变量</span></span><br></pre></td></tr></table></figure><p>重置变量：</p><p>使用var关键字声明的变量任何地方都可以修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// x 为 2</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 现在 x 为 3</span></span><br></pre></td></tr></table></figure><p>在相同的作用域下，不能使用let来重置var声明的变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;       <span class="comment">// 合法</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">3</span>;       <span class="comment">// 不合法</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">4</span>;   <span class="comment">// 合法</span></span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>   <span class="comment">// 不合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在相同的作用域下，不能使用let重置let声明的变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">2</span>;       <span class="comment">// 合法</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">3</span>;       <span class="comment">// 不合法</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">4</span>;   <span class="comment">// 合法</span></span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;   <span class="comment">// 不合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在相同作用域下，不能使用var关键字来重置let声明的变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">2</span>;       <span class="comment">// 合法</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;       <span class="comment">// 不合法</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">4</span>;   <span class="comment">// 合法</span></span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">5</span>;   <span class="comment">// 不合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>let 关键字在不同作用域，或不同块级作用域中是可以重新声明赋值的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">2</span>;       <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">3</span>;   <span class="comment">// 合法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">4</span>;   <span class="comment">// 合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量提升：</p><p>js中，var声明的变量可以先使用后声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在这里可以使用 carName 变量</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> carName;</span><br></pre></td></tr></table></figure><p>let声明的变量不可以先使用再声明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在这里不可以使用 carName 变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> carName;</span><br></pre></td></tr></table></figure><p>const关键字<br>const用来声明一个或多个常量值，声明时必须进行初始化，且初始化后不可以再修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.141592653589793</span>;</span><br><span class="line">PI = <span class="number">3.14</span>;      <span class="comment">// 报错</span></span><br><span class="line">PI = PI + <span class="number">10</span>;   <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>const和let定义变量的类似：</p><ul><li>二者都是块级作用域</li><li>都不能和所在作用域内其他变量或函数同名</li></ul><p>两者区别：</p><ul><li>const声明变量必须初始化，let可以不用初始化</li><li>const初始化后不可以修改，let初始化后可以修改</li></ul><p>const并非是一个真正的常量<br>const 的本质: const 定义的变量并非常量，并非不可变，它定义了一个常量引用一个值。使用 const 定义的对象或者数组，其实是可变的。下面的代码并不会报错：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建常量对象</span></span><br><span class="line"><span class="keyword">const</span> car = &#123;<span class="attr">type</span>:<span class="string">&quot;Fiat&quot;</span>, <span class="attr">model</span>:<span class="string">&quot;500&quot;</span>, <span class="attr">color</span>:<span class="string">&quot;white&quot;</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 修改属性:</span></span><br><span class="line">car.color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 添加属性</span></span><br><span class="line">car.owner = <span class="string">&quot;Johnson&quot;</span>;</span><br></pre></td></tr></table></figure><p>但不能对常量对象重新赋值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> car = &#123;<span class="attr">type</span>:<span class="string">&quot;Fiat&quot;</span>, <span class="attr">model</span>:<span class="string">&quot;500&quot;</span>, <span class="attr">color</span>:<span class="string">&quot;white&quot;</span>&#125;;</span><br><span class="line">car = &#123;<span class="attr">type</span>:<span class="string">&quot;Volvo&quot;</span>, <span class="attr">model</span>:<span class="string">&quot;EX60&quot;</span>, <span class="attr">color</span>:<span class="string">&quot;red&quot;</span>&#125;;    <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>在相同的作用域或块级作用域中，不能使用 const 关键字来重置 var 和 let关键字声明的变量:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;         <span class="comment">// 合法</span></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">2</span>;       <span class="comment">// 不合法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span>;     <span class="comment">// 合法</span></span><br><span class="line">    <span class="keyword">const</span> x = <span class="number">2</span>;   <span class="comment">// 不合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在相同的作用域或块级作用域中，不能使用 const 关键字来重置 const 关键字声明的变量:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">2</span>;       <span class="comment">// 合法</span></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">3</span>;       <span class="comment">// 不合法</span></span><br><span class="line">x = <span class="number">3</span>;             <span class="comment">// 不合法</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;         <span class="comment">// 不合法</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">3</span>;         <span class="comment">// 不合法</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> x = <span class="number">2</span>;   <span class="comment">// 合法</span></span><br><span class="line">    <span class="keyword">const</span> x = <span class="number">3</span>;   <span class="comment">// 不合法</span></span><br><span class="line">    x = <span class="number">3</span>;         <span class="comment">// 不合法</span></span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">3</span>;     <span class="comment">// 不合法</span></span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">3</span>;     <span class="comment">// 不合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>const 关键字在不同作用域，或不同块级作用域中是可以重新声明赋值的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">2</span>;       <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> x = <span class="number">3</span>;   <span class="comment">// 合法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> x = <span class="number">4</span>;   <span class="comment">// 合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>const 关键字定义的变量则不可以在使用后声明，也就是变量需要先声明再使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">carName = <span class="string">&quot;Volvo&quot;</span>;    <span class="comment">// 在这里不可以使用 carName 变量</span></span><br><span class="line"><span class="keyword">const</span> carName = <span class="string">&quot;Volvo&quot;</span></span><br></pre></td></tr></table></figure><h3 id="9-箭头函数"><a href="#9-箭头函数" class="headerlink" title="9.箭头函数"></a>9.箭头函数</h3><p>ES6 之前，JavaScript 的 this 对象一直很令人头大，回调函数，经常看到 var self = this 这样的代码，为了将外部 this 传递到回调函数中，那么有了箭头函数，就不需要这样做了，直接使用 this 就行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">&#x27;sayHello&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line">Person.sayHello();  <span class="comment">// 20</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> Person1 = &#123;</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">&#x27;sayHello&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line">Person1.sayHello();  <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>当我们需要维护this上下文的时候，使用箭头函数</p><p>箭头函数：<br>箭头函数提供了一种更加简洁的函数书写方式。基本语法是：<br>参数 =&gt; 函数体</p><p>基本用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>);  <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>当箭头函数没有参数或者有多个参数，要用 () 括起来:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">a,b</span>) =&gt;</span> a+b;</span><br><span class="line">f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">//8</span></span><br></pre></td></tr></table></figure><p>当箭头函数函数体有多行语句，用 {} 包裹起来，表示代码块，当只有一行语句，并且需要返回结果时，可以省略 {} , 结果会自动返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">a,b</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">let</span> result = a+b;</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p>当箭头函数要返回对象的时候，为了区分于代码块，要用 () 将对象包裹起来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">id,name</span>) =&gt;</span> &#123;<span class="attr">id</span>: id, <span class="attr">name</span>: name&#125;;</span><br><span class="line">f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">// SyntaxError: Unexpected token :</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">id,name</span>) =&gt;</span> (&#123;<span class="attr">id</span>: id, <span class="attr">name</span>: name&#125;);</span><br><span class="line">f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">// &#123;id: 6, name: 2&#125;</span></span><br></pre></td></tr></table></figure><p>注意点：没有 this、super、arguments 和 new.target 绑定。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 箭头函数里面没有 this 对象，</span></span><br><span class="line">  <span class="comment">// 此时的 this 是外层的 this 对象，即 Window </span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">func(<span class="number">55</span>)  <span class="comment">// Window </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> func = <span class="function">() =&gt;</span> &#123;    </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">func(<span class="number">55</span>);  <span class="comment">// ReferenceError: arguments is not defined</span></span><br></pre></td></tr></table></figure><p>箭头函数体中的 this 对象，是定义函数时的对象，而不是使用函数时的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 定义时，this 绑定的是 fn 中的 this 对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// fn 的 this 对象为 &#123;a: 19&#125;</span></span><br><span class="line">fn.call(&#123;<span class="attr">a</span>: <span class="number">18</span>&#125;);  <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>不可以作为构造函数，也就是不能使用 new 命令，否则会报错</p><h3 id="10-vuex页面刷新数据保持不变"><a href="#10-vuex页面刷新数据保持不变" class="headerlink" title="10.vuex页面刷新数据保持不变"></a>10.vuex页面刷新数据保持不变</h3><p>用vuex做全局状态管理的时候，页面刷新，数据会丢失，是因为store中的数据是保存在运行内存中的，页面刷新时就会重新加载vue实例，store会被重新赋值。<br>解决方法：</p><p>方案一：<br>由于state中的数据是响应式的，而数据又是通过mutation来修改的，所以在mutation修改state数据时调用localStorage.setItem()方法来进行数据的存储：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        orderList:[],</span><br><span class="line">        menuList:[]</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        <span class="function"><span class="title">orderList</span>(<span class="params">state,data</span>)</span>&#123;</span><br><span class="line">            state.orderList = data;</span><br><span class="line">            <span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;orderList&#x27;</span>, <span class="built_in">JSON</span>.stringify(data))</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">menuList</span>(<span class="params">state,data</span>)</span>&#123;</span><br><span class="line">            state.menuList = data;</span><br><span class="line">            <span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;menuList&#x27;</span>, <span class="built_in">JSON</span>.stringify(data))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在页面加载的时候再通过localStorage.getItem()方法将值取出放回vuex，可在app.vue的created方法中写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.localStorage.getItem(<span class="string">&#x27;orderList&#x27;</span>))&#123;</span><br><span class="line">        <span class="built_in">this</span>.$store.replaceState(<span class="built_in">Object</span>.assign(&#123;&#125;, <span class="built_in">this</span>.$store.state, <span class="built_in">JSON</span>.parse(<span class="built_in">window</span>.localStorage.getItem(<span class="string">&#x27;orderList&#x27;</span>))))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案二：<br>方案一能够顺利解决问题，但不断触发localStorage.setItem()方法对性能不是特别友好，而且一直将数据同步到localStorage中似乎就没必要再用vuex做状态管理，直接用localStorage即可，于是对以上解决方法进行了改进，通过监听beforeunload事件来进行数据的localStorage存储，beforeunload事件在页面刷新时进行触发，具体做法是在App.vue的created()周期函数中下如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.localStorage.getItem(<span class="string">&#x27;orderList&#x27;</span>))&#123;</span><br><span class="line">        <span class="built_in">this</span>.$store.replaceState(<span class="built_in">Object</span>.assign(&#123;&#125;, <span class="built_in">this</span>.$store.state, <span class="built_in">JSON</span>.parse(<span class="built_in">window</span>.localStorage.getItem(<span class="string">&#x27;orderList&#x27;</span>))))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;beforeunload&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.localStorage.setItem(<span class="string">&quot;orderList&quot;</span>,<span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>.$store.state.orderList))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-公众号openid和unionid的区别"><a href="#11-公众号openid和unionid的区别" class="headerlink" title="11.公众号openid和unionid的区别"></a>11.公众号openid和unionid的区别</h3><ul><li>微信openid和unionid长度是不一样的：openid=28，unionid=29</li><li>openid同一用户同一应用唯一，unionid同一用户不同应用唯一<ul><li>这里的不同应用是指在同一微信开发平台下的不同应用</li><li>为了识别用户，每个用户针对每个公众号会产生一个安全的openid</li><li>一个用户虽然对多个公众号和应用有多个不同的openid，但他对所有这些同一开放平台账号下的公众号和应用，只有一个unionid</li></ul></li></ul><h3 id="12-axios统一封装"><a href="#12-axios统一封装" class="headerlink" title="12.axios统一封装"></a>12.axios统一封装</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> _axios = axios.create();</span><br><span class="line"></span><br><span class="line">_axios.default.baseURL = <span class="string">&#x27;requesturl&#x27;</span>;</span><br><span class="line">_axios.interceptors.request.use(<span class="function"><span class="keyword">function</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 在发送请求前做些什么</span></span><br><span class="line">    config =&gt; &#123;</span><br><span class="line">        config.withCredentials = <span class="literal">true</span>; <span class="comment">// 允许携带token ,这个是解决跨域产生的相关问题</span></span><br><span class="line">        config.timeout = <span class="number">12000</span>;</span><br><span class="line">        config.headers = &#123;</span><br><span class="line">            <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    config.headers[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="string">`<span class="subst">$&#123;<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;token&#x27;</span>)&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加相应拦截器</span></span><br><span class="line">_axios.interceptors.response.use(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(response.data.code == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> response.data</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(response.data.message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 对相应错误做些什么</span></span><br><span class="line">    <span class="function"><span class="title">swtich</span>(<span class="params">error.response.status</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">401</span>:</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">403</span>:</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">500</span>:</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> _axios;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用axios</span></span><br><span class="line"><span class="keyword">import</span> _axios <span class="keyword">from</span> <span class="string">&#x27;./axios&#x27;</span>;</span><br><span class="line"><span class="comment">// 接口定义</span></span><br><span class="line"><span class="function"><span class="title">getList</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _axios(&#123;</span><br><span class="line">        method: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">        url:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        params:&#123;data&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">postList</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _axios(&#123;</span><br><span class="line">        method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">        url:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        data:&#123;data&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 页面接口调用</span></span><br><span class="line">getList(data).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>12.webpack</p><p>loader和plugin的使用</p><ul><li>loader：下载、使用</li><li>plugin: 下载、引入、使用</li></ul><p>配置文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;resolve&#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">&#x27;./src/index.js&#x27;</span>, <span class="comment">//打包的入口文件</span></span><br><span class="line">    output:&#123;</span><br><span class="line">        <span class="comment">// 输出的文件名，以及文件路径</span></span><br><span class="line">        filename: <span class="string">&#x27;build.js&#x27;</span>, <span class="comment">//输出的文件名</span></span><br><span class="line">        path: resolve(__dirname,<span class="string">&#x27;build&#x27;</span>) <span class="comment">//// 当前路径(__dirname)的build文件夹</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        <span class="comment">// 在此配置loader</span></span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>, <span class="comment">//表示匹配以css结尾的文件</span></span><br><span class="line">                use:[</span><br><span class="line">                    <span class="comment">// 使用以下loader进行编译从下往上</span></span><br><span class="line">                    <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test:<span class="regexp">/\.(png|svg|jpg|gif)&amp;/</span>,</span><br><span class="line">                use:[</span><br><span class="line">                    <span class="string">&#x27;file-loader&#x27;</span> <span class="comment">//在Css中有背景和图标等图片，需要安装file-loader来处理</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="comment">// 在此配置插件，插件的作用比loader要强，如压缩编译转换等</span></span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin(), <span class="comment">//清理 /dist 文件夹</span></span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">           title: <span class="string">&#x27;Output Management&#x27;</span></span><br><span class="line">        &#125;), <span class="comment">//生成html文件</span></span><br><span class="line">    ],</span><br><span class="line">      mode: <span class="string">&quot;development&quot;</span>  <span class="comment">//配置当前打包环境 development-开发环境、production-生产环境 （生产环境会压缩代码）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用loader(按顺序引入)</p><p>处理 css</p><ul><li>style-loader</li><li>css-loader</li></ul><p>处理 less</p><ul><li>style-loader</li><li>css-loader</li><li>less-loader(less-loader依赖less，要一起安装)</li></ul><p>处理css图片资源</p><ul><li>url-loader(依赖file-loader,可一并安装)</li></ul><p>处理html图片资源</p><ul><li>html-loader</li></ul><p>处理其他资源(如：字体文件等)</p><ul><li>file-loader</li></ul><p>常用plugins</p><ul><li>html-webpack-plugin</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hwp = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>)</span><br><span class="line"><span class="keyword">new</span> hwp(&#123;</span><br><span class="line">  template:<span class="string">&quot;./src/index.html&quot;</span>，  <span class="comment">//以该文件为模板进行复制打包</span></span><br><span class="line">  minify:&#123;</span><br><span class="line">    collapseWhitespace:<span class="literal">true</span>, <span class="comment">//压缩空格</span></span><br><span class="line">    removeComments:<span class="literal">true</span> <span class="comment">// 去除注释</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>clean-webpack-plugin</li></ul><h3 id="13-数组的toString方法"><a href="#13-数组的toString方法" class="headerlink" title="13.数组的toString方法"></a>13.数组的toString方法</h3><p>数组的toString方法会将数组的每个元素转换为字符串，有逗号拼接并且没有其他界定符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].toString()</span><br><span class="line"><span class="string">&quot;1,2,3&quot;</span></span><br><span class="line">[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>].toString()</span><br><span class="line"><span class="string">&quot;a,b,c&quot;</span></span><br><span class="line">[<span class="number">1</span>,[<span class="number">2</span>,<span class="string">&quot;c&quot;</span>]].toString()</span><br><span class="line"><span class="string">&quot;1,2,c&quot;</span></span><br></pre></td></tr></table></figure><h3 id="14-对象的toString方法"><a href="#14-对象的toString方法" class="headerlink" title="14.对象的toString方法"></a>14.对象的toString方法</h3><p>对象的toString方法没有任何参数，返回一个字符串，该方法返回的是调用它的对象的类型或值。<br>当使用“+”运算符把一个字符串和一个对象连接一起或把一个对象传递给alert()或document.write()时，会调用toString方法。</p><p>默认的toString方法返回的字符串形式总是[object class],class是对象的内部类型，通常对应的是该对象的构造函数名。例如，Array对象的class值是Array，Function对象的class值是“Function”，Date对象的class值是“Date”，内部Math对象的class值是“Math”，所有Error对象的的class值是“Error”，用户定义的对象（例如Complex）的class值是“Object”。</p><h3 id="15-怎样判断一个对象是不是数组？"><a href="#15-怎样判断一个对象是不是数组？" class="headerlink" title="15.怎样判断一个对象是不是数组？"></a>15.怎样判断一个对象是不是数组？</h3><ul><li>从原型入手，Array.prototype.isPrototypeOf(obj);<br>利用isPrototypeOf()方法判断Array是否在obj的原型链上</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.isPrototypeOf([]); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.isPrototypeOf(&#123;&#125;); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><ul><li>用instanceof, obj instanceof Array<br>instanceof检测构造函数的prototype属性是否存在实例对象的原型链上</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure><ul><li>Object.prototype.toString.call(obj)<br>根据对象的class属性，跨原型链调用toString方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]); <span class="comment">//&quot;[object Array]&quot;</span></span><br></pre></td></tr></table></figure><ul><li>Array.isArray()</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray([]); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="16-js解决苹果移动端300ms延迟的问题"><a href="#16-js解决苹果移动端300ms延迟的问题" class="headerlink" title="16.js解决苹果移动端300ms延迟的问题"></a>16.js解决苹果移动端300ms延迟的问题</h3><p>做移动端页面开发的可能会了解到，ios系统click事件会有卡顿的现象，这个问题的根源是苹果本身自带的safari有双击放大页面的功能，再次双击会返回到原始尺寸，所以在第一次点击的系统会延迟300ms来判断是不是双击操作，为了解决这个问题，网上也给了解决的办法，把click事件绑定到ontouchstart事件上，这样就解决了300ms延迟的问题，这个文件是fastclick.js</p><h3 id="17-tcp三次握手"><a href="#17-tcp三次握手" class="headerlink" title="17.tcp三次握手"></a>17.tcp三次握手</h3><p>为了准确无误将数据送达目标处，TCP协议采取了三次握手协议。<br>用tcp协议将数据包送出去后，tcp不会对发送后的情况置之不理，它一定向对方确认是否收到。</p><ul><li>1.发送端首先发送带SYN标志的数据给对方。</li><li>2.接收方收到后回传一个SYN/ACK标志的数据包以示传达确认信息。</li><li>3.最后，发送端再回传一个带ACK标志的字段，代表握手结束</li></ul><p>若在握手过程中某个阶段被打断，TCP会再次以相同的顺序发送数据包。</p><h3 id="18-四次挥手"><a href="#18-四次挥手" class="headerlink" title="18.四次挥手"></a>18.四次挥手</h3><p>第一次：客户端请求断开FIN,seq=u<br>第二次：服务器确认客户端的断开请求ACK,ack=u+1,seq=v<br>第三次：服务器请求断开FIN,seq=w,ACK,ack=u+1<br>第四次：客户端确认服务器的断开ACK,ack=w+1,seq=u+1</p><h3 id="19-osi模型"><a href="#19-osi模型" class="headerlink" title="19.osi模型"></a>19.osi模型</h3><ul><li>应用层：提供应用程序间通道</li><li>表示层：处理数据格式、数据加密等</li><li>会话层：建立、维护和管理会话</li><li>传输层：建立主机端到端的连接</li><li>网络层：寻址和路由选择</li><li>数据链路层：提供介质访问，链路管理等</li><li>物理层：比特流传输</li></ul><h3 id="20-vue-minxins"><a href="#20-vue-minxins" class="headerlink" title="20.vue minxins"></a>20.vue minxins</h3><p>mixins定义：mixins选项接受一个混入对象的数组，类型：Array<Object></p><p>mixins原理：真正的实现是靠mergeOptions函数实现的。</p><p>这个函数传进去的两个参数分别是this.options 和 mixin，而mergeOptions函数则实现了递归遍历this.options，然后执行mergeField，返回最终合并的this.options<br>mergeField函数：一般我们执行mergeField 里的key基本上就是上面strats的属性了，用的最多的可能就是data、methods、props了，所以如果我们在mixins中用到了data，其本质上就是合并当前vue实例对象里的data和我们传进去的mixin里的data，其他属性也是一样的</p><p>合并策略：<br>1.data<br>mixins中的data会合并到实例中的data中，有冲突的话，实例中data的数据会覆盖mixins中的数据</p><p><img src="/ZJY.github.io/images/minxins1.png" alt="image"></p><p>2.钩子函数<br>mixins中和实例中的钩子函数，都会执行，先执行mixins中的钩子函数</p><p><img src="/ZJY.github.io/images/minxins2.png" alt="image"></p><p>3.methods、components、directives<br>methods、components、directives会执行，当有冲突的时候，实例中的会覆盖mixins中的</p><p><img src="/ZJY.github.io/images/minxins3.png" alt="image"></p><h3 id="21-git常用命令"><a href="#21-git常用命令" class="headerlink" title="21.git常用命令"></a>21.git常用命令</h3><p>创建仓库：<br>git init</p><p>提交代码相关：</p><ul><li>把当工作区文件加到暂存区<ul><li>单个文件加入：git add x.js</li><li>全部文件加入: git add .</li></ul></li><li>把暂存区的内容提交到本地仓库: git commit -m “xxx”</li><li>克隆一下远程仓库到本地:<br>git clone <a href="mailto:&#103;&#105;&#116;&#x40;&#x67;&#x69;&#x74;&#104;&#x75;&#98;&#x2e;&#99;&#x6f;&#x6d;">&#103;&#105;&#116;&#x40;&#x67;&#x69;&#x74;&#104;&#x75;&#98;&#x2e;&#99;&#x6f;&#x6d;</a>:michaelliao/gitskills.git<br>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。</li><li>添加一个远程仓库:git remote add origin <a href="mailto:&#x67;&#x69;&#x74;&#64;&#x67;&#105;&#x74;&#x68;&#117;&#x62;&#46;&#99;&#x6f;&#109;">&#x67;&#x69;&#x74;&#64;&#x67;&#105;&#x74;&#x68;&#117;&#x62;&#46;&#99;&#x6f;&#109;</a>:michaelliao/learngit.git</li><li>本地库的所有内容推送到远程库上:git push -u origin master</li><li>提交日志查看（详细）:git log</li><li>提交查看（简洁版）:git log –pretty=oneline</li><li>指定本地dev分支与远程origin/dev分支的链接:git branch –set-upstream-to=origin/dev dev</li></ul><p>版本回退:</p><ul><li>回到上一个版本:git reset –hard HEAD^</li><li>回到上倒数第3个版本:git reset –hard HEAD^^^</li><li>回到指定版本:git reset –hard 1094a</li></ul><p>撤销更改:<br>丢弃修改，这个文件回到最近一次git commit或git add时的状态。类似svn revert命令。<br>git checkout – readme.txt</p><p>删除本地分支 :git branch -d 本地分支名<br>删除远程分支:<br>git push origin –delete 分支名<br>git branch -r -d origin/branchName<br>git push origin :branchName</p><h3 id="22-vue中的虚拟dom"><a href="#22-vue中的虚拟dom" class="headerlink" title="22.vue中的虚拟dom"></a>22.vue中的虚拟dom</h3><p>1.什么是虚拟DOM<br>虚拟DOM 表现为一个 Object对象。并且最少包含标签名 (tag)、属性 (attrs) 和子元素对象 (children) 三个属性<br>创建虚拟DOM就是为了更好将虚拟的节点渲染到页面视图中，所以虚拟DOM对象的节点与真实DOM的属性一一照应</p><p>2.为什么需要虚拟DOM<br>DOM是很慢的，其元素非常庞大，页面的性能问题，大部分都是由DOM操作引起的</p><p>真实的DOM节点，哪怕一个最简单的div也包含着很多属性<br>操作DOM的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户的体验</p><p>3.Diff原理<br>diff算法就是进行虚拟节点对比，并返回一个patch对象，用来存储两个节点不同的地方，最后用patch记录的消息去局部更新Dom。通俗的讲就是：diff的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的DOM打补丁<br>通过diff算法比较 新 旧 两个VDOM，将不同的地方进行修改，相同的地方就地复用，最后再通过render函数渲染页面</p><h3 id="23-vue双向绑定原理"><a href="#23-vue双向绑定原理" class="headerlink" title="23.vue双向绑定原理"></a>23.vue双向绑定原理</h3><p>vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p><h3 id="24-on-once-emit-off"><a href="#24-on-once-emit-off" class="headerlink" title="24.$on,$once,$emit,$off"></a>24.$on,$once,$emit,$off</h3><p>vm.$on( event, callback ):<br>监听当前实例上的自定义事件。事件可以由 vm.$emit 触发。回调函数会接收所有传入事件触发函数的额外参数</p><p>vm.$once( event, callback ):<br>监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除</p><p>vm.$off( [event, callback] ):<br>移除自定义事件监听器。</p><p>如果没有提供参数，则移除所有的事件监听器；</p><p>如果只提供了事件，则移除该事件所有的监听器；</p><p>如果同时提供了事件与回调，则只移除这个回调的监听器</p><p>vm.$emit( eventName, […args] ):<br>触发当前实例上的事件。附加参数都会传给监听器回调。</p><h3 id="25-vue的响应式原理，数组的变异检测"><a href="#25-vue的响应式原理，数组的变异检测" class="headerlink" title="25.vue的响应式原理，数组的变异检测"></a>25.vue的响应式原理，数组的变异检测</h3><p>当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。</p><p>这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更</p><p>每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。</p><p>检测变化的注意事项<br>由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。尽管如此我们还是有一些办法来回避这些限制并保证它们的响应性。</p><p>对于对象：<br>Vue 无法检测 property 的添加或移除。由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 data 对象上存在才能让 Vue 将它转换为响应式的</p><p>对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式 property</p><p>对于数组：<br>Vue 不能检测以下数组的变动：<br>当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue<br>当你修改数组的长度时，例如：vm.items.length = newLength</p><p>为了解决第一类问题，以下两种方式都可以实现和 vm.items[indexOfItem] = newValue 相同的效果，同时也将在响应式系统内触发状态更新：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line">Vue.set(vm.items, indexOfItem, newValue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.prototype.splice</span></span><br><span class="line">vm.items.splice(indexOfItem, <span class="number">1</span>, newValue)</span><br></pre></td></tr></table></figure><p>为了解决第二类问题，你可以使用 splice:vm.items.splice(indexOfItem, 1, newValue)</p><p>异步更新队列:</p><p>可能你还没有注意到，Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替</p><h3 id="26-vue-loader"><a href="#26-vue-loader" class="headerlink" title="26.vue-loader"></a>26.vue-loader</h3><p>vue-loader作用：<br>解析和转换.vue文件，提取出其中的逻辑代码script，样式代码style，以及html模版template，再分别把他们交给对应的loader去处理</p><p>用途：js可以写es6,style样式可以写scss或less</p><p>css-loader：加载由 vue-loader 提取出的 CSS 代码。<br>vue-template-compiler：把vue-loader提取出的HTML模板编译成可执行的jacascript代码</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-symbol原始数据类型</title>
      <link href="/ZJY.github.io/2021/01/20/javascript-symbol%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/ZJY.github.io/2021/01/20/javascript-symbol%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：</p><p>undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p><p>Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> s</span><br><span class="line"><span class="comment">// &quot;symbol&quot;</span></span><br></pre></td></tr></table></figure><p>注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p><p>Symbol函数可以接受一个字符串作为参数，表示对 Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p><p>注意，Symbol函数的参数只是表示对当前 Symbol值的描述，因此相同参数的Symbol函数的返回值是不相等的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript this 关键字</title>
      <link href="/ZJY.github.io/2021/01/20/javasctipt%E7%9A%84this%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/ZJY.github.io/2021/01/20/javasctipt%E7%9A%84this%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript-this-关键字"><a href="#JavaScript-this-关键字" class="headerlink" title="JavaScript this 关键字"></a>JavaScript this 关键字</h2><p>面向对象语言中this表示对对象的一个引用。</p><p>但在javascript中，this不是固定不变的，它随执行环境的改变而改变。</p><ul><li>在方法中，this表示该方法所属的对象。</li><li>如果单独使用，this代表全局对象</li><li>在函数中，this代表全局对象</li><li>在函数中，严格模式下，this是未定义的undefined</li><li>在事件中，this表示接收事件的元素</li><li>类似call(),apply(),bind()可以将this引用到任何对象</li></ul><p>实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  lastName : <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">  id       : <span class="number">5566</span>,</span><br><span class="line">  fullName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法中的this"><a href="#方法中的this" class="headerlink" title="方法中的this"></a>方法中的this</h3><p>在对象方法中，this指向调用它所在方法的对象。</p><p>上面实例中，this指person对象。<br>fullName 方法所属的对象就是 person。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.fullName(); <span class="comment">// John Doe</span></span><br></pre></td></tr></table></figure><h3 id="单独使用this"><a href="#单独使用this" class="headerlink" title="单独使用this"></a>单独使用this</h3><p>单独使用this，this指全局对象</p><p>在浏览器中，全局对象指window</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(this &#x3D;&#x3D;&#x3D; window); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><p>严格模式下，单独使用this，也是指全局对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#39;use strict&#39;</span><br><span class="line">console.log(this &#x3D;&#x3D;&#x3D; window); &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><h3 id="函数中使用this"><a href="#函数中使用this" class="headerlink" title="函数中使用this"></a>函数中使用this</h3><p>在函数中，函数的所属者默认绑定到this<br>在浏览器中，this指全局对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">myFunction(); <span class="comment">//window</span></span><br></pre></td></tr></table></figure><h3 id="严格模式下函数中使用this"><a href="#严格模式下函数中使用this" class="headerlink" title="严格模式下函数中使用this"></a>严格模式下函数中使用this</h3><p>严格模式下，函数是没有绑定到this的，this是undefined</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">myFunction(); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><h3 id="事件中的this"><a href="#事件中的this" class="headerlink" title="事件中的this"></a>事件中的this</h3><p>在html事件柄中，this指向了接收事件的html元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;this.style.display=&#x27;none&#x27;&quot;</span>&gt;</span></span><br><span class="line">点我后我就消失了</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="对象方法中绑定"><a href="#对象方法中绑定" class="headerlink" title="对象方法中绑定"></a>对象方法中绑定</h3><p>下面实例中，this 是 person 对象，person 对象是函数的所有者：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstName  : <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  lastName   : <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">  id         : <span class="number">5566</span>,</span><br><span class="line">  myFunction : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.myFunction(); <span class="comment">//&#123;firstName: &quot;John&quot;, lastName: &quot;Doe&quot;, id: 5566, myFunction: ƒ&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  lastName : <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">  id       : <span class="number">5566</span>,</span><br><span class="line">  fullName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.fullName(); <span class="comment">//John Doe</span></span><br></pre></td></tr></table></figure><p> this.firstName 表示 this (person) 对象的 firstName 属性。</p><h3 id="显式函数绑定"><a href="#显式函数绑定" class="headerlink" title="显式函数绑定"></a>显式函数绑定</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  fullName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">  firstName:<span class="string">&quot;John&quot;</span>,</span><br><span class="line">  lastName: <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">person1.fullName.call(person2);  <span class="comment">// 返回 &quot;John Doe&quot;</span></span><br></pre></td></tr></table></figure><p>在 JavaScript 中函数也是对象，对象则有方法，apply 和 call 就是函数对象的方法。这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 this 绑定的对象。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>promise理解</title>
      <link href="/ZJY.github.io/2021/01/20/promise%E7%90%86%E8%A7%A3/"/>
      <url>/ZJY.github.io/2021/01/20/promise%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p>Promise 是异步编程的一种解决方案<br>Promise 是一个对象，从它可以获取异步操作的消息</p><h3 id="Promise特点"><a href="#Promise特点" class="headerlink" title="Promise特点"></a>Promise特点</h3><p>Promise对象有以下两个特点。</p><ul><li><p>对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功<br>）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p></li><li><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p></li></ul><h3 id="Promise的缺点："><a href="#Promise的缺点：" class="headerlink" title="Promise的缺点："></a>Promise的缺点：</h3><ul><li>1.无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li><li>2.如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li><li>3.当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li></ul><p>promise是一个构造函数，用来生成promise实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        resolve(value)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>promise构造函数接收一个函数作为参数，该函数的两个参数为resovle和reject，由js引擎提供，不用自己部署</p><p>resovle函数的作用是，将promise对象的状态从“未完成”变为“成功”（pending变为fullfilled），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。</p><p>reject函数的作用是，将promise对象的状态从“未完成”变为“失败”（pending变为rejected），在异步操作失败时调用，并将异步操作返回的结果作为参数传递出去</p><h3 id="Promise-then方法"><a href="#Promise-then方法" class="headerlink" title="Promise.then方法"></a>Promise.then方法</h3><p>promise生成以后，可用then方法分别指定为resolve和reject状态的回调函数：</p><p>promise.then(function(value){},function(error){})</p><p>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</p><p>promise.then(onFulfilled, onRejected)</p><p>promise简化了对error的处理，上面的代码我们也可以这样写：</p><p>promise.then(onFulfilled).catch(onRejected)</p><h3 id="Promise-all方法"><a href="#Promise-all方法" class="headerlink" title="Promise.all方法"></a>Promise.all方法</h3><p>Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。<br>var p = Promise.all([p1,p2,p3]);</p><p>上面代码中，Promise.all 方法接受一个数组作为参数，p1、p2、p3 都是 Promise 对象的实例。（Promise.all 方法的参数不一定是数组，但是必须具有 iterator 接口，且返回的每个成员都是 Promise 实例。）</p><p>p 的状态由 p1、p2、p3 决定，分成两种情况。</p><p>（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。<br>（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</p><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wake = <span class="function">(<span class="params">time</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;time / <span class="number">1000</span>&#125;</span>秒后醒来`</span>)</span><br><span class="line">      resolve(<span class="string">`<span class="subst">$&#123;time / <span class="number">1000</span>&#125;</span>秒后醒来`</span>)</span><br><span class="line">    &#125;, time)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = wake(<span class="number">3000</span>)</span><br><span class="line"><span class="keyword">let</span> p2 = wake(<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2]).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result)       <span class="comment">//&#x27;2秒后醒来&#x27;,&#x27;3秒后醒来&#x27;  [ &#x27;3秒后醒来&#x27;, &#x27;2秒后醒来&#x27; ]</span></span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>需要特别注意的是，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，即p1的结果在前，即便p1的结果获取的比p2要晚。这带来了一个绝大的好处：在前端开发请求数据的过程中，偶尔会遇到发送多个请求并根据请求顺序获取和使用数据的场景，使用Promise.all毫无疑问可以解决这个问题。</p><h3 id="Promise-race方法"><a href="#Promise-race方法" class="headerlink" title="Promise.race方法"></a>Promise.race方法</h3><p>Promise.race 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例</p><p>var p = Promise.race([p1,p2,p3]);</p><p>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的返回值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">&#x27;failed&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">500</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error)  <span class="comment">// 打开的是 &#x27;failed&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果Promise.all方法和Promise.race方法的参数，不是Promise实例，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。</p><h3 id="Promise-resolve-方法"><a href="#Promise-resolve-方法" class="headerlink" title="Promise.resolve 方法"></a>Promise.resolve 方法</h3><p>有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果 Promise.resolve 方法的参数，不是具有 then 方法的对象（又称 thenable 对象），则返回一个新的 Promise 对象，且它的状态为fulfilled。</p><p>上面代码生成一个新的Promise对象的实例p，它的状态为fulfilled，所以回调函数会立即执行，Promise.resolve方法的参数就是回调函数的参数。</p><p>如果Promise.resolve方法的参数是一个Promise对象的实例，则会被原封不动地返回。</p><h3 id="Promise-reject方法"><a href="#Promise-reject方法" class="headerlink" title="Promise.reject方法"></a>Promise.reject方法</h3><p>Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected。Promise.reject方法的参数reason，会被传递给实例的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">p.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>上面代码生成一个Promise对象的实例，状态为rejected，回调函数会立即执行。</p><p>promise实现ajax：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">URL</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest(); </span><br><span class="line">        req.open(<span class="string">&#x27;GET&#x27;</span>, URL, <span class="literal">true</span>);</span><br><span class="line">        req.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (req.status === <span class="number">200</span>) &#123; </span><br><span class="line">                resolve(req.responseText);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;;</span><br><span class="line">        req.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">        &#125;;</span><br><span class="line">        req.send(); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> URL = <span class="string">&quot;/try/ajax/testpromise.php&quot;</span>; </span><br><span class="line">ajax(URL).then(<span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">&#x27;内容是：&#x27;</span> + value); </span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">&#x27;错误：&#x27;</span> + error); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>async/await的使用</title>
      <link href="/ZJY.github.io/2021/01/20/async-await%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/ZJY.github.io/2021/01/20/async-await%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><p>async 是 ES7 才有的与异步操作有关的关键字，和 Promise ， Generator 有很大关联的</p><p>语法：async function name([param[, param[, … param]]]) { statements }</p><ul><li>name: 函数名称。</li><li>param: 要传递给函数的参数的名称。</li><li>statements: 函数体语句。</li></ul><p>返回值：async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">helloAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;helloAsync&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">console</span>.log(helloAsync())  <span class="comment">// Promise &#123;&lt;resolved&gt;: &quot;helloAsync&quot;&#125;</span></span><br><span class="line"> </span><br><span class="line">helloAsync().then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(v);         <span class="comment">// helloAsync</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>async 函数中可能会有 await 表达式，async 函数执行时，如果遇到 await 就会先暂停执行 ，等到触发的异步操作完成后，恢复 async 函数的执行并返回解析值。</p><p>await 关键字仅在 async function 中有效。如果在 async function 函数体外使用 await ，你只会得到一个语法错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testAwait</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&quot;testAwait&quot;</span>);</span><br><span class="line">          resolve();</span><br><span class="line">       &#125;, <span class="number">1000</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">helloAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">await</span> testAwait();</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;helloAsync&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">helloAsync();</span><br><span class="line"><span class="comment">// testAwait</span></span><br><span class="line"><span class="comment">// helloAsync</span></span><br></pre></td></tr></table></figure><h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>await 操作符用于等待一个 Promise 对象, 它只能在异步函数 async function 内部使用。</p><p>语法:[return_value] = await expression;<br>expression: 一个 Promise 对象或者任何要等待的值</p><p>返回值:</p><p>返回 Promise 对象的处理结果。如果等待的不是 Promise 对象，则返回该值本身。</p><p>如果一个 Promise 被传递给一个 await 操作符，await 将等待 Promise 正常处理完成并返回其处理结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testAwait</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(x);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">helloAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="keyword">await</span> testAwait (<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(x); </span><br><span class="line">&#125;</span><br><span class="line">helloAsync ();</span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>正常情况下，await 命令后面是一个 Promise 对象，它也可以跟其他值，如字符串，布尔值，数值以及普通函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testAwait</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;testAwait&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">helloAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">await</span> testAwait();</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;helloAsync&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">helloAsync();</span><br><span class="line"><span class="comment">// testAwait</span></span><br><span class="line"><span class="comment">// helloAsync</span></span><br></pre></td></tr></table></figure><p>await针对所跟不同表达式的处理方式：</p><ul><li>Promise 对象：await 会暂停执行，等待 Promise 对象 resolve，然后恢复 async 函数的执行并返回解析值。</li><li>非 Promise 对象：直接返回对应的值</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序性能优化</title>
      <link href="/ZJY.github.io/2021/01/20/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/"/>
      <url>/ZJY.github.io/2021/01/20/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/</url>
      
        <content type="html"><![CDATA[<p>小程序优化性能从两点出发：</p><p>1.提高加载性能<br>2.提高渲染性能</p><h3 id="1-提高加载性能"><a href="#1-提高加载性能" class="headerlink" title="1.提高加载性能"></a>1.提高加载性能</h3><p>用户点击小程序：<br><img src="/ZJY.github.io/images/webapp.png" alt="image"></p><p>它们分别对应小程序的下面三个状态：</p><ul><li>有三个点的白屏（左侧）： 下载代码包的阶段</li><li>没有三个点的白屏（中间）： 业务代码注入和渲染的阶段</li><li>加载中（右边）： 业务代码中异步请求数据</li></ul><p>1.控制包的大小<br>提升体验最直接的方法是控制小程序包的大小，基本上可以说，1M的代码包，下载耗时1秒左右。</p><ul><li>压缩代码，清理无用的代码</li><li>图片放在cdn</li><li>采用分包策略<ul><li>分包预加载</li><li>独立分包（版本要求有点高）</li></ul></li></ul><p>2.对异步请求的优化</p><ul><li>onLoad 阶段就可以发起请求，不用等ready</li><li>请求结果放在缓存中, 下次接着用</li><li>请求中可以先展示骨架图</li><li>先反馈，再请求。比如说，点赞的按钮，可以先改变按钮的样式，再发起异步请求</li></ul><h3 id="2-提升渲染性能"><a href="#2-提升渲染性能" class="headerlink" title="2.提升渲染性能"></a>2.提升渲染性能</h3><p>setData：每调用一次setData, 都是逻辑层向渲染层的一次通讯，这个通信还不是直接传给webView, 而是通过走了native层，通讯的开销很大。</p><p>渲染层收到通讯后，还需要重新渲染出来，所以，一次setData带来两次开销：通信的开销 + webview更新的开销。</p><ul><li>1.减少setData的数据量<ul><li>如果一个数据不会影响渲染层，则不用放在setData里面</li></ul></li><li>2.合并setData的请求，减少通讯的次数</li><li>3.列表的局部更新</li><li>4.清理定时器等</li><li>5.只在必要时候监听pageScroll，避免在pageScroll中频繁setData，避免在pagescroll中写复杂逻辑</li></ul><h3 id="3-html和小程序页面加载的不同"><a href="#3-html和小程序页面加载的不同" class="headerlink" title="3.html和小程序页面加载的不同"></a>3.html和小程序页面加载的不同</h3><p>传统HTML5在加载的时候受限于网络环境，需要顺序加载HTML、CSS、JS，然后返回数据，最后渲染页面显示在浏览器中。用户经常需要等待很长时间，体验会受到影响。</p><p>相比之下，小程序的两个线程：Appservice Thread和ViewThread会同时进行、并行加载，甚至AppserviceThread会更早执行，当视图线程加载完，通知Appservice，Appservice 会把准备好的数据用setData的方法返回给视图线程。</p><p>小程序的这种优化策略，可以减少用户的等待时间、加快小程序的响应速度。</p><h3 id="4-小程序性能优化"><a href="#4-小程序性能优化" class="headerlink" title="4.小程序性能优化"></a>4.小程序性能优化</h3><ul><li><p>控制包体积的大小，减少包文件个数</p></li><li><p>分包加载</p></li><li><p>图片优化:除icon外图片可以放在cdn，不建议把所有图片放在包内，加大包的体积，影响包的下载速度和解压速度;选择合适的图片格式;适当降低图片质量压缩图片;</p></li><li><p>其他资源文件的优化，压缩json文件</p></li><li><p>请求数据的优化:关键的早请求，不关键的晚请求，可使页面所需数据尽早可能的处于ready状态，不必等到ready状态后才去请求数据</p></li><li><p>setdata的优化:不要过于频繁的调用setdata，应考虑多次合并请求;不在视图层使用的数据不要使用setdata;通过setdata<br>的key值优化</p></li><li><p>清理页面定时器</p></li><li><p>合理使用自定义组件(不需要逻辑功能时可使用模板)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http状态码</title>
      <link href="/ZJY.github.io/2021/01/20/http%E7%8A%B6%E6%80%81%E7%A0%81/"/>
      <url>/ZJY.github.io/2021/01/20/http%E7%8A%B6%E6%80%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h3 id="1xx-（临时响应）"><a href="#1xx-（临时响应）" class="headerlink" title="1xx （临时响应）"></a>1xx （临时响应）</h3><p>表示临时响应并需要请求者继续执行操作的状态代码。</p><ul><li>100 （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。</li><li>101 （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。</li><li>102 由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</li></ul><h3 id="2xx-（成功）"><a href="#2xx-（成功）" class="headerlink" title="2xx （成功）"></a>2xx （成功）</h3><p>表示成功处理了请求的状态代码。</p><ul><li>200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</li><li>201 （已创建） 请求成功并且服务器创建了新的资源。</li><li>202 （已接受） 服务器已接受请求，但尚未处理。</li><li>203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。</li><li>204 （无内容） 服务器成功处理了请求，但没有返回任何内容。</li><li>205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。</li><li>206 （部分内容） 服务器成功处理了部分 GET 请求。</li><li>207 由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</li></ul><h3 id="3xx-（重定向）"><a href="#3xx-（重定向）" class="headerlink" title="3xx （重定向）"></a>3xx （重定向）</h3><p>表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向。</p><ul><li>300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (useragent)选择一项操作，或提供操作列表供请求者选择。</li><li>301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或HEAD请求的响应）时，会自动将请求者转到新位置。</li><li>302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li><li>303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</li><li>304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</li><li>305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</li><li>307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li></ul><h3 id="4xx-（请求错误）"><a href="#4xx-（请求错误）" class="headerlink" title="4xx （请求错误）"></a>4xx （请求错误）</h3><p>这些状态代码表示请求可能出错，妨碍了服务器的处理。</p><ul><li>400 （错误请求） 服务器不理解请求的语法。</li><li>401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</li><li>402 该状态码是为了将来可能的需求而预留的。</li><li>403 （禁止） 服务器拒绝请求。</li><li>404 （未找到） 服务器找不到请求的网页。</li><li>405 （方法禁用） 禁用请求中指定的方法。</li><li>406 （不接受） 无法使用请求的内容特性响应请求的网页。</li><li>407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</li><li>408 （请求超时）服务器等候请求时发生超时。</li><li>409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。</li><li>410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。</li><li>411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。</li><li>412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。</li><li>413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</li><li>414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。这比较少见，通常的情况包括：本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。</li><li>415 （不支持的媒体类型） 请求的格式不受请求页面的支持。</li><li>416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。</li><li>417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。</li></ul><h3 id="5xx-（服务器错误）"><a href="#5xx-（服务器错误）" class="headerlink" title="5xx （服务器错误）"></a>5xx （服务器错误）</h3><p>这些状态代码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。</p><ul><li>500 （服务器内部错误） 服务器遇到错误，无法完成请求。</li><li>501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</li><li>502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。</li><li>503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。</li><li>504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。</li><li>505 （HTTP 版本不受支持）服务器不支持请求中所用的 HTTP 协议版本。</li></ul><h3 id="600"><a href="#600" class="headerlink" title="600"></a>600</h3><p>源站没有返回响应头部，只返回实体内容</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript基础题</title>
      <link href="/ZJY.github.io/2021/01/20/javascript%E5%9F%BA%E7%A1%80%E9%A2%98/"/>
      <url>/ZJY.github.io/2021/01/20/javascript%E5%9F%BA%E7%A1%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-js基础"><a href="#1-js基础" class="headerlink" title="1.js基础"></a>1.js基础</h3><ul><li>基本类型：<ul><li>number</li><li>string</li><li>boolean</li><li>null</li><li>undefined</li><li>symbol  </li></ul></li></ul><p>基本类型的比较就是值的比较，访问的是值的本身，没有属性和方法，保存在栈内存中</p><ul><li>引用类型<ul><li>Array</li><li>Function</li><li>Date</li><li>Object</li></ul></li></ul><p>引用类型有属性和方法，同时保存在栈内存和堆内存中；引用类型的比较是内存地址的比较。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> address = &#123;<span class="attr">details</span>:<span class="string">&#x27;a&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">let</span> one = address</span><br><span class="line"><span class="keyword">let</span> tow = address</span><br><span class="line">one === tow <span class="comment">//true</span></span><br><span class="line"><span class="comment">// 虽然one、tow是两枚不同的指针，但它们都同时指向了堆内存里的address的内容，所以它们是相等的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数参数是引用类型（对象）的时候会发生什么</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  person.age = <span class="number">26</span></span><br><span class="line">  person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;aaa&#x27;</span>,</span><br><span class="line">    age: <span class="number">30</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> person</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;bbb&#x27;</span>,</span><br><span class="line">  age: <span class="number">25</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p2 = test(p1)</span><br><span class="line">p1 <span class="comment">// &#123;age:26,name:&#x27;bbb&#x27;&#125;</span></span><br><span class="line">p2 <span class="comment">// &#123;age:30,name:&#x27;aaa&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>函数传递参数时，实际上是传递指针的副本。<br>test(p1)实际上传递的就是p1的副本，这时指针仍然指向{name: ‘bbb’,age: 25}<br>person.age = 26 这时修改的还是原来内存位置的内容，所以这时p1的age变成了26<br>当person = {} .. 相当于重新开辟了一块堆内存，赋值{name:’aaa’,age:30},最后返回这个对象，而这个对象的指针就是p2</p><h3 id="2-字符串翻转："><a href="#2-字符串翻转：" class="headerlink" title="2.字符串翻转："></a>2.字符串翻转：</h3><p>console.log(str1.split(‘’).reverse().join(‘’))</p><p>判断字符串出现次数最多元素，并统计次数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str2 = <span class="string">&#x27;asdfasdfasdfasdfjkjkljlkjssss&#x27;</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> num2 = str2.length</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num2; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj[str2.charAt(i)]) &#123;</span><br><span class="line">    obj[str2.charAt(i)] = <span class="built_in">parseInt</span>(obj[str2.charAt(i)]) + <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    obj[str2.charAt(i)] = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"><span class="keyword">let</span> maxNum = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> maxDocument = <span class="literal">null</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j <span class="keyword">in</span> obj) &#123;<span class="comment">//循环对象</span></span><br><span class="line">  <span class="keyword">if</span> (obj[j] &gt; maxNum) &#123;</span><br><span class="line">    maxNum = obj[j]</span><br><span class="line">    maxDocument = j</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-数组去重"><a href="#3-数组去重" class="headerlink" title="3.数组去重"></a>3.数组去重</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;e&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(arr2.indexOf(arr[i])== -<span class="number">1</span>)&#123;</span><br><span class="line">    arr2.push(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr2)</span><br></pre></td></tr></table></figure><h3 id="4-replace字符串替换"><a href="#4-replace字符串替换" class="headerlink" title="4.replace字符串替换"></a>4.replace字符串替换</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;hello china&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> str2 = str.replace(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;hi&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str2,str);<span class="comment">//hi china,hello china</span></span><br></pre></td></tr></table></figure><h3 id="5-toUpperCase-大写-toLocaleUpperCase"><a href="#5-toUpperCase-大写-toLocaleUpperCase" class="headerlink" title="5.toUpperCase()大写/toLocaleUpperCase"></a>5.toUpperCase()大写/toLocaleUpperCase</h3><h3 id="6-toLowerCase-小写-toLocalLowerCase"><a href="#6-toLowerCase-小写-toLocalLowerCase" class="headerlink" title="6.toLowerCase()小写/toLocalLowerCase"></a>6.toLowerCase()小写/toLocalLowerCase</h3><h3 id="7-repeat-count-number-字符串重复次数"><a href="#7-repeat-count-number-字符串重复次数" class="headerlink" title="7.repeat(count:number)字符串重复次数"></a>7.repeat(count:number)字符串重复次数</h3><h3 id="8-Math-ceil-向上舍入-4-1结果5"><a href="#8-Math-ceil-向上舍入-4-1结果5" class="headerlink" title="8.Math.ceil()向上舍入 4.1结果5"></a>8.Math.ceil()向上舍入 4.1结果5</h3><h3 id="9-Math-floor-向下舍入-4-9结果4"><a href="#9-Math-floor-向下舍入-4-9结果4" class="headerlink" title="9.Math.floor()向下舍入  4.9结果4"></a>9.Math.floor()向下舍入  4.9结果4</h3><h3 id="10-Math-round-把数四舍五入为最接近的整数。"><a href="#10-Math-round-把数四舍五入为最接近的整数。" class="headerlink" title="10.Math.round()把数四舍五入为最接近的整数。"></a>10.Math.round()把数四舍五入为最接近的整数。</h3><h3 id="11-数组-和length-0的区别："><a href="#11-数组-和length-0的区别：" class="headerlink" title="11.数组[]和length=0的区别："></a>11.数组[]和length=0的区别：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> bar = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> foo2 = foo;</span><br><span class="line"><span class="keyword">var</span> bar2 = bar;</span><br><span class="line">foo=[];</span><br><span class="line">bar.length = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo,foo2,bar,bar2);<span class="comment">//[]  [1,2,3]  []  []</span></span><br></pre></td></tr></table></figure><p>[]是创建了一个新数组，重新分配了内存空间，任何其他引<br>用不受影响，仍指向其原始数据<br>length=0 修改数组本身。如果通过不同的变量访问它，那<br>么仍然可以获得修改后的数组</p><h3 id="12-typeof"><a href="#12-typeof" class="headerlink" title="12.typeof"></a>12.typeof</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">//&quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span> <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">Infinity</span> <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;  <span class="comment">//&quot;function&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;aaa&quot;</span>) <span class="comment">//&quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">String</span>(<span class="string">&#x27;aaa&#x27;</span>) <span class="comment">//&quot;string&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> object <span class="comment">//false</span></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> 任何类型 <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span>可以用来检查一个没有声明的变量，而不报错:</span><br><span class="line"><span class="keyword">typeof</span> v <span class="comment">//&quot;undefined&quot;</span></span><br></pre></td></tr></table></figure><p>typeof可以判断基本数据类型：String，Boolean,Number,但不能判断Array,Object,Null类型</p><h3 id="13-变量提升"><a href="#13-变量提升" class="headerlink" title="13.变量提升"></a>13.变量提升</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;World!&#x27;</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> name = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Goodbye &#x27;</span> + name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Hello &#x27;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 结果：Goodbye Jack</span></span><br><span class="line"><span class="comment">// 注意js的var hoisting变量声明提升，虽然声明提升，但是初始化并不提升</span></span><br><span class="line"><span class="comment">// 这段代码相当于：</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;World!&#x27;</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">        name = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Goodbye &#x27;</span> + name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Hello &#x27;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="14-splice"><a href="#14-splice" class="headerlink" title="14.splice"></a>14.splice</h3><p>splice(index,number,value)向数组中添加或删除数目，返回被删除的数目<br>    index：必须，要添加或删除的起始位置，为负时，从数组尾部开始<br>    number：必须，要删除的数量，为0时则不删除<br>    value：可选，要添加的数目</p><p>删除：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line"><span class="built_in">console</span>.log(a.splice(<span class="number">0</span>,a.length)); <span class="comment">//[1,2,3]</span></span><br><span class="line"><span class="built_in">console</span>.log(a,b); <span class="comment">//[] []</span></span><br></pre></td></tr></table></figure><p>添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr1 = arr;</span><br><span class="line"><span class="built_in">console</span>.log(arr.splice(<span class="number">1</span>,<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>)); <span class="comment">//[]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr,arr1);<span class="comment">// [1,&#x27;a&#x27;,&#x27;b&#x27;,2,3]   [1,&#x27;a&#x27;,&#x27;b&#x27;,2,3]</span></span><br></pre></td></tr></table></figure><h3 id="15-slice"><a href="#15-slice" class="headerlink" title="15.slice"></a>15.slice</h3><p>slice(start,end)向数组中选出指定数组，返回被截选的子数组<br>（start到end，不包含end），并不改变原数组</p><ul><li>start：必须，规定从何处开始，为负时，从数组尾部算起,-1为尾部第一个元素</li><li>end：可选，规定截取到何处，没有此参数则到数组结尾所有元素，<br>  为负时，从尾部开始算起元素</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> d = c;</span><br><span class="line"><span class="built_in">console</span>.log(c.slice(<span class="number">0</span>,<span class="number">2</span>));<span class="comment">//[1,2]</span></span><br><span class="line"><span class="built_in">console</span>.log(c,d);<span class="comment">//[1,2,3]  [1,2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以截取字符串：不包含end元素</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="string">&#x27;hello,world&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(test.slice(<span class="number">1</span>,<span class="number">5</span>),test);<span class="comment">// ello   hello,world</span></span><br><span class="line"><span class="built_in">console</span>.log(test.slice(-<span class="number">3</span>),test);<span class="comment">// rld  hello,world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// substring:不包含end元素</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="string">&#x27;hello,world&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(test.substring(<span class="number">1</span>,<span class="number">5</span>),test);<span class="comment">// ello   hello,world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// substr:包含end元素</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="string">&#x27;hello,world&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(test.substr(<span class="number">1</span>,<span class="number">5</span>),test);<span class="comment">// ello,   hello,world</span></span><br></pre></td></tr></table></figure><h3 id="16-js判断数据类型"><a href="#16-js判断数据类型" class="headerlink" title="16.js判断数据类型"></a>16.js判断数据类型</h3><p>1.typeof:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;ls&#x27;</span> <span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">123</span> <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// bollean</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// function</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(<span class="number">1</span>) <span class="comment">// symbol</span></span><br></pre></td></tr></table></figure><p>typeof可以判断基本数据类型：String，Boolean,Number,但不能判断Array,Object,Null类型</p><p>2.instanceof</p><p>判断构造函数的prototype属性是否存在某实例对象的原型链上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。其意思就是判断对象是否是某一数据类型（如Array）的实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> A);<span class="comment">//true,因为 Object.getPrototypeOf(a) === A.prototype;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;srr&#x27;</span> intanceof <span class="built_in">String</span>) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>) <span class="comment">// false</span></span><br><span class="line">在这里字面量值，<span class="number">2</span>， <span class="literal">true</span> ，<span class="string">&#x27;str&#x27;</span>不是实例，所以判断值为<span class="literal">false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">2</span>) <span class="keyword">instanceof</span> <span class="built_in">Number</span>)<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;2&#x27;</span>) <span class="keyword">instanceof</span> <span class="built_in">String</span>)<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>) <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>)<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Function</span>)<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null和undefined</span></span><br><span class="line">conosle.log(<span class="literal">null</span> <span class="keyword">instanceof</span> Null) <span class="comment">// Null is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> <span class="keyword">instanceof</span> Undefined) <span class="comment">//Undefined is not undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="literal">null</span> <span class="keyword">instanceof</span> Null) <span class="comment">// null is not a constructor</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="literal">undefined</span> <span class="keyword">instanceof</span> Undefined) <span class="comment">//undefined is not a constructor</span></span><br><span class="line"><span class="comment">// 浏览器认为null，undefined不是构造器</span></span><br></pre></td></tr></table></figure><p>能判断Array,Object,Null类型，但不能区分基本数据类型</p><p>3.constructor</p><p>constructor属性返回创建该对象时构造函数的引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">2</span>).constructor === <span class="built_in">Number</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">true</span>).constructor === <span class="built_in">Boolean</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="string">&#x27;str&#x27;</span>).constructor === <span class="built_in">String</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(([]).constructor === <span class="built_in">Array</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log((&#123;&#125;).constructor === <span class="built_in">Object</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;).constructor === <span class="built_in">Function</span>);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用costructor来判断类型看起来是完美的，然而，如果</span></span><br><span class="line"><span class="comment">// 我创建一个对象，更改它的原型，这种方式也变得不可</span></span><br><span class="line"><span class="comment">// 靠了</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Fn.prototype = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Fn();</span><br><span class="line"><span class="built_in">console</span>.log(f.constructor === Fn);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(f.constructor=== <span class="built_in">Array</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>4.Object.prototype.toString.call</p><p>toString方法返回调用它的对象的类型或值。<br>返回值默认是[object class],class是对象的内部类型，通常对应对象的构造函数名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常用于判断浏览器内置对象,对于所有基本的数据类型都能进行判断，即使是 null 和 undefined</span></span><br><span class="line"><span class="keyword">var</span>  test = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"><span class="built_in">console</span>.log(test.call(<span class="number">1</span>)); <span class="comment">//[object Number]</span></span><br><span class="line"><span class="built_in">console</span>.log(test.call(<span class="literal">true</span>)); <span class="comment">//[object Boolean]</span></span><br><span class="line"><span class="built_in">console</span>.log(test.call(<span class="string">&#x27;123&#x27;</span>)); <span class="comment">//[object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(test.call([])); <span class="comment">//[object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(test.call(&#123;&#125;)); <span class="comment">//[object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(test.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)); <span class="comment">//[object Function]</span></span><br><span class="line"><span class="built_in">console</span>.log(test.call(<span class="literal">null</span>)); <span class="comment">//[object Null]</span></span><br><span class="line"><span class="built_in">console</span>.log(test.call(<span class="literal">undefined</span>)); <span class="comment">//[object Undefined]       </span></span><br></pre></td></tr></table></figure><p>5.Array.isArray</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray([]))<span class="comment">// true</span></span><br><span class="line">     </span><br><span class="line"> <span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;123&#x27;</span>);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> str); <span class="comment">//object</span></span><br><span class="line"> <span class="built_in">console</span>.log(str <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">//true</span></span><br><span class="line"> <span class="built_in">console</span>.log(str.constructor===<span class="built_in">String</span>); <span class="comment">//true</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(str));[object <span class="built_in">String</span>]</span><br></pre></td></tr></table></figure><h3 id="17-闭包的概念"><a href="#17-闭包的概念" class="headerlink" title="17.闭包的概念"></a>17.闭包的概念</h3><p>闭包就是能访问其他函数内部的变量的函数</p><ul><li>优点：<br>  避免全局变量的污染<br>  变量长期存储在内存中（缓存变量）</li><li>缺点：<br>  常驻内存，加大内存使用<br>  内存泄漏<br>闭包实现了私有变量和参数</li></ul><h3 id="18-深拷贝和浅拷贝"><a href="#18-深拷贝和浅拷贝" class="headerlink" title="18.深拷贝和浅拷贝"></a>18.深拷贝和浅拷贝</h3><ul><li>基础数据类型（number string boolean null undefined）存储在栈内存中</li><li>引用数据类型（Function Array Object）变量名与内存地址存储在栈内存中，值作为对象保存在堆内存中</li><li>基础数据类型的比较是值比较</li><li>引用数据类型的比较是内存地址比较</li></ul><p>浅拷贝：只复制指向某个对象的指针，而不复制对象本身，新旧对象共享同一块内存<br>深拷贝：复制并创建一个一摸一样的对象，不共享内存，修改新对象，旧对象保持不变</p><ul><li>浅拷贝：<pre><code>  Object.assign()  扩展运算符...  Array.prototype.slice()//数组浅拷贝</code></pre></li><li>深拷贝：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify())</span><br><span class="line"><span class="comment">// 递归克隆</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现深拷贝：浅拷贝+递归</span></span><br><span class="line"><span class="comment">// 浅拷贝：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneShallow</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">            target[key] = source[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name: <span class="string">&quot;muyiy&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;You Don&#x27;t Know JS&quot;</span>,</span><br><span class="line">        price: <span class="string">&quot;45&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    a1: <span class="literal">undefined</span>,</span><br><span class="line">    a2: <span class="literal">null</span>,</span><br><span class="line">    a3: <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = cloneShallow(a);</span><br><span class="line"></span><br><span class="line">a.name = <span class="string">&quot;高级前端进阶&quot;</span>;</span><br><span class="line">a.book.price = <span class="string">&quot;55&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123; </span></span><br><span class="line"><span class="comment">//   name: &#x27;muyiy&#x27;, </span></span><br><span class="line"><span class="comment">//   book: &#123; title: &#x27;You Don\&#x27;t Know JS&#x27;, price: &#x27;55&#x27; &#125;,</span></span><br><span class="line"><span class="comment">//   a1: undefined,</span></span><br><span class="line"><span class="comment">//   a2: null,</span></span><br><span class="line"><span class="comment">//   a3: 123</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 以上只能拷贝一层，只要稍微改动下，加上是否是对象</span></span><br><span class="line"><span class="comment">// 的判断并在相应的位置使用递归就可以实现简单深拷贝。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep1</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> source[key] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">                target[key] = cloneDeep1(source[key]); <span class="comment">// 注意这里</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                target[key] = source[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用上面测试用例测试一下</span></span><br><span class="line"><span class="keyword">var</span> b = cloneDeep1(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123; </span></span><br><span class="line"><span class="comment">//   name: &#x27;muyiy&#x27;, </span></span><br><span class="line"><span class="comment">//   book: &#123; title: &#x27;You Don\&#x27;t Know JS&#x27;, price: &#x27;45&#x27; &#125;, </span></span><br><span class="line"><span class="comment">//   a1: undefined,</span></span><br><span class="line"><span class="comment">//   a2: &#123;&#125;,</span></span><br><span class="line"><span class="comment">//   a3: 123</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>一个简单的深拷贝就完成了，但是这个实现还存在很多问题。</p><p>1、没有对传入参数进行校验，传入 null 时应该返回 null 而不是 {}</p><p>2、对于对象的判断逻辑不严谨，因为 typeof null === ‘object’</p><p>3、没有考虑数组的兼容</p><p>判断是否是object</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span> &amp;&amp; obj != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 所以兼容数组的写法如下：</span></span><br><span class="line">functoin <span class="function"><span class="title">cloneDeep2</span>(<span class="params">source</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!isObject(source)) <span class="keyword">return</span> source;<span class="comment">//非对象返回自身</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> target = <span class="built_in">Array</span>.isArray(source) ? []: &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> source)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source,key))&#123;</span><br><span class="line">            <span class="keyword">if</span>(isObject(source[key]))&#123;</span><br><span class="line">                target[key] = cloneDeep2(source[key])</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                target[key] = source[key]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>赋值、浅拷贝、深拷贝区别：</p><ul><li>赋值：赋值就是将某一数值或某一对象赋给某个变量的过程，分为如下两个部分：<pre><code>  基本数据类型：赋值，赋值之后两个变量互不影响  引用数据类型：赋址，两个变量具有相同的引用，指向同一个对象，互相有影响</code></pre></li></ul><p>对基本类型进行赋值操作，两个变量互不影响：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&quot;muyiy&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// muyiy</span></span><br><span class="line"></span><br><span class="line">a = <span class="string">&quot;change&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// change</span></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// muyiy</span></span><br></pre></td></tr></table></figure><p>对引用类型进行赋址操作，两个变量指向同一个对象，改变变量 a 之后会影响变量 b，哪怕改变的只是对象 a中的基本类型数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    name: <span class="string">&quot;muyiy&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;You Don&#x27;t Know JS&quot;</span>,</span><br><span class="line">        price: <span class="string">&quot;45&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;muyiy&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line">a.name = <span class="string">&quot;change&quot;</span>;</span><br><span class="line">a.book.price = <span class="string">&quot;55&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;change&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;change&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br></pre></td></tr></table></figure><ul><li><p>浅拷贝（Shallow Copy）：<br>创建一个对象，这个对象有原始对象属性值的一份精确拷贝。如果属性值是基本数据类型，拷贝的就是基本数据类型的值，如果属性值是引用类型，拷贝的就是内存的地址，所以两个对象会相互影响。浅拷贝只解决了第一层的问题，拷贝第一层的基本类型值，以及第一层的引用类型地址</p><p>  浅拷贝使用场景：</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">Object</span>.assign()方法将所有可枚举属性的值从一个或多个源对象复制到目标对象</span><br><span class="line"><span class="comment">// 木易杨</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    name: <span class="string">&quot;muyiy&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;You Don&#x27;t Know JS&quot;</span>,</span><br><span class="line">        price: <span class="string">&quot;45&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;, a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;muyiy&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line">a.name = <span class="string">&quot;change&quot;</span>;</span><br><span class="line">a.book.price = <span class="string">&quot;55&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;change&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;muyiy&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br></pre></td></tr></table></figure><p>上面代码改变对象 a 之后，对象 b 的基本属性保持不变。但是当改变对象 a 中的对象 book 时，对象 b 相应的位置也发生了变化</p><p>2.展开语法 Spread</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    name: <span class="string">&quot;muyiy&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;You Don&#x27;t Know JS&quot;</span>,</span><br><span class="line">        price: <span class="string">&quot;45&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;...a&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;muyiy&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line">a.name = <span class="string">&quot;change&quot;</span>;</span><br><span class="line">a.book.price = <span class="string">&quot;55&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;change&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;muyiy&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br></pre></td></tr></table></figure><p>通过代码可以看出实际效果和 Object.assign() 是一样的。</p><p>3.Array.prototype.slice()</p><p>slice() 方法返回一个新的数组对象，这一对象是一个由 begin和 end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">0</span>, <span class="string">&quot;1&quot;</span>, [<span class="number">2</span>, <span class="number">3</span>]];</span><br><span class="line"><span class="keyword">let</span> b = a.slice(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// [&quot;1&quot;, [2, 3]]</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">1</span>] = <span class="string">&quot;99&quot;</span>;</span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// [0, &quot;99&quot;, [4, 3]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">//  [&quot;1&quot;, [4, 3]]</span></span><br></pre></td></tr></table></figure><p>深拷贝（Deep Copy）</p><p>复制并创建一个一摸一样的对象，不共享内存，修改新对象，旧对象保持不变;</p><p>深拷贝使用场景：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>。<span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(object))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    name: <span class="string">&quot;muyiy&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;You Don&#x27;t Know JS&quot;</span>,</span><br><span class="line">        price: <span class="string">&quot;45&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a));</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;muyiy&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line">a.name = <span class="string">&quot;change&quot;</span>;</span><br><span class="line">a.book.price = <span class="string">&quot;55&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;change&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;muyiy&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br></pre></td></tr></table></figure><p>对数组深拷贝效果如何：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">0</span>, <span class="string">&quot;1&quot;</span>, [<span class="number">2</span>, <span class="number">3</span>]];</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify( a.slice(<span class="number">1</span>) ));</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// [&quot;1&quot;, [2, 3]]</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">1</span>] = <span class="string">&quot;99&quot;</span>;</span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// [0, &quot;99&quot;, [4, 3]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">//  [&quot;1&quot;, [2, 3]]</span></span><br></pre></td></tr></table></figure><p>对数组深拷贝之后，改变原数组不会影响到拷贝之后的数组但是该方法有以下几个问题：<br>会忽略 undefined/symbol，不能处理正则/new Date<br>undefined、symbol 和函数这三种情况，会直接忽略</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;muyiy&#x27;</span>,</span><br><span class="line">    a: <span class="literal">undefined</span>,</span><br><span class="line">    b: <span class="built_in">Symbol</span>(<span class="string">&#x27;muyiy&#x27;</span>),</span><br><span class="line">    c: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;muyiy&quot;, </span></span><br><span class="line"><span class="comment">// a: undefined, </span></span><br><span class="line"><span class="comment">//  b: Symbol(muyiy), </span></span><br><span class="line"><span class="comment">//  c: ƒ ()</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;name: &quot;muyiy&quot;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="19-数组去重："><a href="#19-数组去重：" class="headerlink" title="19.数组去重："></a>19.数组去重：</h3><p>1.for循环嵌套for循环，使用splice去重更改原数组 正向遍历循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">distinct</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.length ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] === arr[j]) &#123;</span><br><span class="line">                    arr.splice(j, <span class="number">1</span>)</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    distinct(arr)</span><br><span class="line">    <span class="built_in">console</span>.log(arr) <span class="comment">// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：该方法可以顾虑到重复的 String、Boolean、 Number、undefined、null，返回的是去重后的原数组。<br>缺点：不能过滤掉 NaN、Object</p><p>2.for循环嵌套for循环，使用splice去重更改原数组 逆向遍历循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">distinct</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = arr.length; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j = i - <span class="number">1</span>; j &gt; -<span class="number">1</span> ; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] === arr[j]) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(arr[j])</span><br><span class="line">                    arr.splice(j, <span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    distinct(arr)</span><br><span class="line">    <span class="built_in">console</span>.log(arr) <span class="comment">// [1, &quot;true&quot;, true, 15, false, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点同方法一</p><p>3.includes去重 返回新数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">distinct</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> newArr = []</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!newArr.includes(arr[i])) &#123;</span><br><span class="line">                newArr.push(arr[i])</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newArr</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(distinct(arr)) <span class="comment">// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点是可以过滤重复的NaN了，但是返回的是个新数组，对比方法一二，该方法多消耗了一些存储空间。</p><p>优点：该方法可以顾虑到重复的 String、Boolean、Number、undefined、null、NaN，返回的是去重后的新数组。<br>缺点：不能过滤掉 Object</p><p>4.indexOf去重 返回新数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">distinct</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> newArr = []</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(newArr.indexOf(arr[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                newArr.push(arr[i])</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newArr</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(distinct(arr)) <span class="comment">//  [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：该方法可以顾虑到重复的 String、Boolean、 Number、undefined、null，返回的是去重后的新数组。<br>缺点：不能过滤掉 NaN、Object</p><p>5.利用对象的属性key唯一的特性去重</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">distinct</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">        <span class="keyword">let</span> newArr = []</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!obj[arr[i]])&#123;</span><br><span class="line">                obj[arr[i]] = <span class="number">1</span></span><br><span class="line">                newArr.push(arr[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newArr</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(distinct(arr)) <span class="comment">// [1, &quot;true&quot;, 15, false, undefined, null, NaN, 0, &quot;a&quot;, &#123;…&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法不仅可以过滤掉重复的NaN,还是可以过滤掉Object。</p><p>优点：该方法可以顾虑到重复的 String、Boolean、 Number、undefined、null、NaN、Object，返回的是去重后的新数组。<br>缺点：针对 NaN和’NaN’, 对象的key会视为一个key，区分不了NaN和’NaN’</p><p>6.利用ES6的Set数据结构的特性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">distinct</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(distinct(arr)) <span class="comment">// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：该方法可以顾虑到重复的 String、Boolean、 Number、undefined、null、NaN，返回的是去重后的新数组。<br>缺点：不能过滤重复的Object</p><p>7.利用ES6的Map数据结构的特性去重</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">distinct</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">        <span class="keyword">let</span> newArr = []</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!map.has(arr[i])) &#123;</span><br><span class="line">                map.set(arr[i])</span><br><span class="line">                newArr.push(arr[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newArr</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(distinct(arr)) <span class="comment">// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：该方法可以顾虑到重复的 String、Boolean、 Number、undefined、null、NaN，返回的是去重后的新数组。<br>缺点：不能过滤重复的Object</p><p>总结：</p><ul><li><p>splice、indexof（不能过滤NaN、object）：</p><pre><code>  双重for循环，判断arr[i] 和 arr[j](j=i+1)是否相等利  用splice去重数组，正向遍历数组，不能过滤掉 NaN、Object  双重for循环，判断arr[i]和arr[j](j=i-1)是否相等利  用splice去重数组，逆向遍历数组，不能过滤掉 NaN、Object  定义新数组，for循环判断新数组是否包含indexOf当前循环值，  利用indexOf去重，不能过滤掉 NaN、Object</code></pre></li><li><p>includes、set、map（不能过滤object）：</p><pre><code>  定义新数组，for循环判断新数组是否includes当  前循环值，利用includes去重，不能过滤掉 Object  利用ES6的Set数据结构的特性：return Array.from  (new Set(arr))，不能过滤掉 Object  利用ES6的Map数据结构的特性去重：      let map = new Map()      for循环中判断：map.has(arr[i])  不能过滤掉 Object</code></pre></li><li><p>利用对象的属性key唯一的特性去重:</p><pre><code>  let obj = &#123;&#125;  for循环判断：obj[arr[i]]不存在将当前循环元素push新数组  可以过滤掉 NaN、Object，不可以区分&#39;NaN&#39;和NaN</code></pre></li></ul><h3 id="20-DOM-事件有哪些阶段？谈谈对事件代理的理解"><a href="#20-DOM-事件有哪些阶段？谈谈对事件代理的理解" class="headerlink" title="20.DOM 事件有哪些阶段？谈谈对事件代理的理解"></a>20.DOM 事件有哪些阶段？谈谈对事件代理的理解</h3><p>捕获阶段-目标阶段-冒泡阶段</p><p>事件代理简单说就是：事件不直接绑定到某元素上，而是绑定到该元素的父元素上，进行触发事件操作时(例如’click’)，再通过条件判断，执行事件触发后的语句(例如’alert(e.target.innerHTML)’)</p><p>好处：(1)使代码更简洁；(2)节省内存开销</p><h3 id="21-async-await"><a href="#21-async-await" class="headerlink" title="21.async/await"></a>21.async/await</h3><p>async用于声明一个函数是异步的，await用来等待一个异步<br>方法执行完成，await只能出现在async函数中</p><p>async函数会返回一个promise对象，如果async函数直接<br>return一个直接量，async函数会把这个直接量用promise.resolve()<br>封装成promise对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello async&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = testAsync();</span><br><span class="line"><span class="built_in">console</span>.log(result);<span class="comment">//Promise &#123;resolved： &#x27;hello async&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p>所以如果不能用await取其返回值情况下可用：<br>then()链来处理这个promise对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">testAsync().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res); <span class="comment">//hello async</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果async没有返回值，它会返回Promise.resolve(undefined)</p><p>await等待的是一个表达式，这个表达式的结果是promise对<br>象或其他值（直接量或者普通函数）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;something&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">&quot;hello async&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> v1 = <span class="keyword">await</span> getSomething();</span><br><span class="line">    <span class="keyword">const</span> v2 = <span class="keyword">await</span> testAsync();</span><br><span class="line">    <span class="built_in">console</span>.log(v1, v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();<span class="comment">//something hello async</span></span><br></pre></td></tr></table></figure><p>如果await等待的不是promise对象，那await表达式的结果就是它等到的东西<br>如果await等待的是promise对象，那它就阻塞后面的代码，等着<br>promise对象resolve，resolve的值就是await表达式的运算结果</p><p>async会将其后的函数的返回值封装成一个promise对象，而await会等待这个promise完成，并将resolve结果返回</p><p>await函数结果可能是rejected，所以最好把await命令放<br>在try…catch块中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">await</span> getSomething();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">await</span> getSomething().catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err)</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="22-协程"><a href="#22-协程" class="headerlink" title="22.协程"></a>22.协程</h3><p>意思是多个线程互相协作，完成异步任务。<br>协程有点像函数，又有点像线程。它的运行流程大致如下：<br>第一步，协程A开始执行。</p><p>第二步，协程A执行到一半，进入暂停，执行权转移到协程B。</p><p>第三步，（一段时间后）协程B交还执行权。</p><p>第四步，协程A恢复执行。</p><h3 id="23-Generator"><a href="#23-Generator" class="headerlink" title="23.Generator"></a>23.Generator</h3><p>Generator函数就是协程再es6的实现，最大的特点就是可用交出函数的执行权（暂停执行）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码就是一个 Generator 函数。它不同于普通函数，是可以暂停执行的，所以函数名之前要加星号，以示区别。整个generator函数就是一个异步任务，需要操作暂停地方就用yeild语句注明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>generator函数返回一个内部指针g，执行generator函数不会返回结果，而是返回一个指针对象，调用g的next方法会移动内部指针移动到yeild语句</p><p>next 方法的作用是分阶段执行 Generator 函数，每次调用next方法会返回一个对象，表示当前阶段信息（value和done）value是yeild语句后表达式的值，done 属性是一个布尔值，表示Generator 函数是否执行完毕，即是否还有下一个阶段。</p><p>Generator函数可以暂停执行和恢复执行，这是可用异步任务的原因，除此外还有两个特效：函数体内数据交换和错误处理机制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.next(<span class="number">2</span>) <span class="comment">// &#123; value: 2, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>第二个 next 方法带有参数2，这个参数可以传入 Generator函数，作为上个阶段异步任务的返回结果，被函数体内的变量 y 接收。因此，这一步的 value 属性，返回的就是2</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js事件执行机制-事件循环</title>
      <link href="/ZJY.github.io/2021/01/20/js%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
      <url>/ZJY.github.io/2021/01/20/js%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="1-javascript是单线程语言"><a href="#1-javascript是单线程语言" class="headerlink" title="1.javascript是单线程语言"></a>1.javascript是单线程语言</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;定时器开始啦&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;马上开始执行for循环&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        i==<span class="number">99</span> &amp;&amp; resolve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;执行then函数&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;代码执行结束&#x27;</span>);</span><br></pre></td></tr></table></figure><p>结果：<br>马上开始执行for循环<br>代码执行结束<br>执行then函数<br>定时器开始啦</p><h3 id="2-Js事件循环："><a href="#2-Js事件循环：" class="headerlink" title="2.Js事件循环："></a>2.Js事件循环：</h3><ul><li>同步任务</li><li>异步任务</li></ul><p>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。<br>当指定的事情完成时，Event Table会将这个函数移入Event Queue。<br>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。<br>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [];</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url:www.javascript.com,</span><br><span class="line">    data:data,</span><br><span class="line">    success:<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;发送成功!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;代码执行结束&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>ajax进入Event Table，注册回调函数success。</li><li>执行console.log(‘代码执行结束’)。</li><li>ajax事件完成，回调函数success进入Event Queue。</li><li>主线程从Event Queue读取回调函数success并执行</li></ul><p>除了广义的同步任务和异步任务，我们对任务有更精细的定义：</p><ul><li>macro-task(宏任务)：包括整体代码script，setTimeout，setInterval</li><li>micro-task(微任务)：Promise，process.nextTick</li></ul><p>事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;   <span class="comment">//宏任务timeout1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//微任务process2</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//微任务then2</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//微任务process1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;7&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//微任务then1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//宏任务timeout2</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; 微任务process3</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;10&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;11&#x27;</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//微任务then3</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;12&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>宏任务：timeout1—timeout2<br>微任务：process1—then1—process2—then2—process3—then3<br>输出顺序：1—7—整个script宏任务执行完毕，执行所有微任务process1，then1，—6—8—执行宏任务timeout1—2—4—执行所有微任务process2，then2—3—5—执行宏任务timout2—9—11—执行所有微任务process3，then3—10—12</p><p>1、7、6、8、2、4、3、5、9、11、10、12</p><p>事件循环Event loop是js实现异步的一种方法，也是js的执行机制</p><p>Javascript是一门单线程语言，事件循环是javascript的执行机制</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>js是单线程非阻塞的脚本语言，意味着代码在js执行的任何时候只有一个主线程来处理所有任务。而非阻塞是指当代码需要异步处理的时候，主线程会挂起这个任务，当异步任务处理完毕后，主线程再根据一定规则去执行相应的回调。</p><p>当任务处理完毕，js会将这个事件加入一个队列，这个队列叫做事件队列。</p><p>异步任务分为：宏任务和微任务，不同类型的任务会被分配到不同的任务队列中。</p><p>当执行栈中所有任务都执行完毕后，会去检查微任务队列是否有事件存在，如果存在，会依次执行任务队列对应的回调，直到为空。然后去宏任务队列中取出一个事件，把对应的回调加入到当前执行战，当执行栈中所有任务都执行完毕后，检查为任务队列是否有事件存在。无限重复此过程，就形成了循环，这个循环就叫做事件循环。</p><p>微任务包括但不限于以下几种：</p><ul><li>Promise.then</li><li>MutationObserver</li><li>Object.observe</li><li>process.nextTick</li></ul><p>宏任务包括但不限于以下几种：</p><ul><li>setTimeout</li><li>setInterval</li><li>setImmediate</li><li>MessageChannel</li><li>requestAnimationFrame</li><li>I/O</li><li>UI交互事件</li></ul><h3 id="什么是执行栈？"><a href="#什么是执行栈？" class="headerlink" title="什么是执行栈？"></a>什么是执行栈？</h3><p>当我们执行一个方法时，js会生成一个与该方法对于的执行环境（context）,又叫执行上下文。这个执行环境有这个方法的私有作用域，上层作用域的指向，方法的参数，私有作用域中定义的变量和this指向。这个执行环境会被添加到一个执行栈中，这个栈就是执行栈。</p><p>如果这个方法的代码又执行到了一行函数的调用语句，那么js会生成这个函数的执行环境并将其添加到执行栈中，然后进入这个执行环境继续执行其中代码，执行完毕并返回结果后，js会退出执行环境并把这个执行环境从栈中销毁，回到上一个方法的执行栈。</p><p>$nextTick，下次dom更新渲染后执行延迟回调，其实是下次微任务执行时更新dom，而$nextTick只是将回调添加到微任务中。</p><p>vue中更新dom的回调也是使用$nextTick注册的回调，都是向微任务队列中添加任务。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-面试点</title>
      <link href="/ZJY.github.io/2021/01/20/vue-%E9%9D%A2%E8%AF%95%E7%82%B9/"/>
      <url>/ZJY.github.io/2021/01/20/vue-%E9%9D%A2%E8%AF%95%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="1-mvvm"><a href="#1-mvvm" class="headerlink" title="1.mvvm"></a>1.mvvm</h3><p>m,指数据模型（data）,v,指视图，UI组件，vm视图模型，把传统的mvc中controller演变成viewModel.<br>viewModel是view和model的桥梁，数据会绑定到viewModel并自动将数据渲染到页面，视图变化时会<br>通知viewModel层更新数据。</p><h3 id="2-vue2中响应式原理"><a href="#2-vue2中响应式原理" class="headerlink" title="2.vue2中响应式原理"></a>2.vue2中响应式原理</h3><p>在初始化数据时，会使用Object.defineProperty()方法重新定义data中到所有属性，在使用对于属性时，<br>首先进行依赖收集（收集当前组件到watcher），如果属性发生变化时会通知相关依赖进行更新操作（订阅/发布）</p><h3 id="3-vue3响应式原理"><a href="#3-vue3响应式原理" class="headerlink" title="3.vue3响应式原理"></a>3.vue3响应式原理</h3><p>vue3使用proxy替代了object.defineproperty，proxy可直接检测到数组和对象到变化。并且有13中拦截方法。</p><h3 id="4-vue3只会监测数组到第一层，vue3怎么解决？"><a href="#4-vue3只会监测数组到第一层，vue3怎么解决？" class="headerlink" title="4.vue3只会监测数组到第一层，vue3怎么解决？"></a>4.vue3只会监测数组到第一层，vue3怎么解决？</h3><p>判断Reflect.get到返回值类型是否为object，如果式用Reactive方法继续进行代理，实现数组到深度监测</p><h3 id="5-监测数组可能多次触发get-set方法，如何防止？"><a href="#5-监测数组可能多次触发get-set方法，如何防止？" class="headerlink" title="5.监测数组可能多次触发get/set方法，如何防止？"></a>5.监测数组可能多次触发get/set方法，如何防止？</h3><p>判断key是否为当前被代理对象target自身属性，或者新值和旧值是否相等，两者满足其一可触发trigger</p><h3 id="6-vue2如何监测数组变化？"><a href="#6-vue2如何监测数组变化？" class="headerlink" title="6.vue2如何监测数组变化？"></a>6.vue2如何监测数组变化？</h3><p>使用了函数劫持，并重新了数组方法。vue对data中数组进行了原型链重写，并指向了自己定义的数组原型方法，<br>当调用数组api时，进行依赖更新，当数组中存在引用类型时，会对引用类型再次递归遍历进行监控属性监测数组。</p><h3 id="7-nextTick"><a href="#7-nextTick" class="headerlink" title="7.nextTick"></a>7.nextTick</h3><p>在下次Dom更新循环之后执行延迟回调。主要使用了宏任务和微任务，根据执行环境分别尝试采用：<br>promise/mutationobserve/setimmediate/settimeout定义了一个异步方法，多次调用nextTick会将方法存入队列中，<br>通过这个异步方法清空队列。</p><h3 id="8-vue生命周期"><a href="#8-vue生命周期" class="headerlink" title="8.vue生命周期"></a>8.vue生命周期</h3><ul><li>beforeCreate:new Vue()后第一个钩子函数，在此阶段data/methods/computed/watch中方法和数据都不能被访问；</li><li>created:实例被创建之后，此时已完成数据观测，可以访问，更改数据，此时更改数据不回触发update函数，此时<br>可初始化数据，不可访问Dom，或者vm.$nextTick中进行访问</li><li>beforeMount:实例被挂载之前，template模版已导入渲染函数编译，此时虚拟dom已创建完成，即将开始渲染，可更新数据</li><li>mounted:实例被挂载之后，dom已挂载，数据完成双向绑定，可更新数据，通过ref访问真是dom</li><li>beforeUpdate:数据更新之前，响应式数据更新之前，虚拟dom重新渲染之前触发，可更新数据不触发update</li><li>updated:完成更新之后，dom已完成更新，避免此阶段更新数据，造成重复渲染</li><li>beforeDestory：实例销毁之前，实例扔可用，可做收尾清除工作</li><li>destoryed:实例被销毁后，实例不可用</li></ul><h3 id="9-接口请求放在哪个生命周期？"><a href="#9-接口请求放在哪个生命周期？" class="headerlink" title="9.接口请求放在哪个生命周期？"></a>9.接口请求放在哪个生命周期？</h3><p>mounted和created中都可，根据是否需要访问dom决定，但是服务器渲染不支持mounted,需要放在created中</p><h3 id="10-computed和watch区别？"><a href="#10-computed和watch区别？" class="headerlink" title="10.computed和watch区别？"></a>10.computed和watch区别？</h3><p>computed本质上是一个具有缓存的watcher,依赖的属性发生变化就会更新视图，使用于消耗性能的场景<br>watch没有缓存，起到观察的作用，可以监听数据执行回调，深度监听，deep：true</p><h3 id="11-v-if和v-show的区别？"><a href="#11-v-if和v-show的区别？" class="headerlink" title="11.v-if和v-show的区别？"></a>11.v-if和v-show的区别？</h3><p>v-if条件不成立时，不会渲染dom，v-show是display属性样式切换当前dom的显示和隐藏，<br>v-if有更高的切换消耗；v-show有更高的初始渲染消耗</p><h3 id="12-组件中的data为什么是一个函数？"><a href="#12-组件中的data为什么是一个函数？" class="headerlink" title="12.组件中的data为什么是一个函数？"></a>12.组件中的data为什么是一个函数？</h3><p>组件可以被多次复用，创建多个实例，这些实例本质是同一个构造函数，如果data是对象，对象是引用类型，<br>修改对象会影响所有实例，因此data是一个函数</p><h3 id="13-v-model的原理"><a href="#13-v-model的原理" class="headerlink" title="13.v-model的原理"></a>13.v-model的原理</h3><p>v-model是一个语法糖，是value+input的语法糖，根据model属性的prop和event属性来进行定义。原生的v-model会根据<br>标签的不同生成不同的事件和属性</p><h3 id="14-vue事件绑定原理"><a href="#14-vue事件绑定原理" class="headerlink" title="14.vue事件绑定原理"></a>14.vue事件绑定原理</h3><p>原生绑定事件通过addEventlistener绑定给真实原素的，组件事件绑定通过vue自定义的$on实现的</p><h3 id="15-vue模版编译的原理？"><a href="#15-vue模版编译的原理？" class="headerlink" title="15.vue模版编译的原理？"></a>15.vue模版编译的原理？</h3><p>vue的编译过程就是将template转化为render函数的过程，经历以下阶段：</p><ul><li>将模版解析为AST（抽象语法树）</li><li>遍历AST标记静态节点</li><li>使用AST生成渲染函数</li></ul><p>这三部分内容分别抽象出三个模块来实现各自的功能，分别是：</p><ul><li>解析器</li><li>优化器</li><li>代码生成器</li></ul><p>首先解析模版，生成AST树，使用正则对模版进行解析，对不同标签文本用不同钩子进行处理<br>vue数据是响应式对，但不是所有数据都是响应式的，有一些数据渲染后就不会发生变化，其Dom也不会<br>发生变化，深度遍历AST树，标记这些静态节点就可以跳过比对<br>将优化过后的AST树转化为可执行的代码</p><p>解析器的作用是通过模版得到AST<br>生成AST需要借助html解析器，当html解析器触发不同的钩子函数时，我们可以构建出不同的节点。<br>html解析器的内部原理是一小段一小段的截取模版字符串，每截取一小段字符串就会根据截取处理的字符串类型触发不同的钩子函数，直到模版字符串截空停止运行。</p><p>优化器的作用是在AST找出静态子树并打上标记，这样作有2个好处：</p><ul><li>每次重新渲染时，不需要为静态子树创建新节点。</li><li>在虚拟dom打补丁的过程可以跳过。</li></ul><h3 id="16-keep-alive"><a href="#16-keep-alive" class="headerlink" title="16.keep-alive"></a>16.keep-alive</h3><p>keep-alive可以实现组件缓存，当组件切换时不会对当前组件进行卸载<br>通过include/exclued实现组件有条件对进行缓存<br>两个生命周期activated/deactivated，用来判断当前组件是否处于活跃状态</p><h3 id="17-vue组件生命周期调用顺序？"><a href="#17-vue组件生命周期调用顺序？" class="headerlink" title="17.vue组件生命周期调用顺序？"></a>17.vue组件生命周期调用顺序？</h3><ul><li>组件调用顺序是先父后子，渲染完成顺序是先子后父</li><li>组件销毁顺序是先父后子，销毁完成顺序是先子后父</li></ul><p>加载渲染过程：<br>父beforeCreate-&gt;父created-&gt;父beforeMount-子beforecreate-子created-》子beforeMounted-》子mounted-》父mounted</p><p>子组件更新过程：<br>父beforeUpdated-》子beforeUpdated-》子updated-》父updated</p><p>父组件更新过程：<br>父beforeUpdated-》父updated</p><p>销毁过程：<br>父beforeDestory-》子beforeDestory-》子destoryed-》父destoryed</p><h3 id="18-vue2组件通信"><a href="#18-vue2组件通信" class="headerlink" title="18.vue2组件通信"></a>18.vue2组件通信</h3><ul><li>父子间通信： 父-》子： props       子-》父：$on  $emit<br>获取父子组件实例 ：$parent  $children<br>Ref获取实例的方式调用组件的属性或方法</li><li>兄弟组件通信： Event Bus</li><li>跨级组件通信：vuex      $attrs  $listeners    Provide  inject</li></ul><h3 id="19-SSR"><a href="#19-SSR" class="headerlink" title="19.SSR"></a>19.SSR</h3><p>SSR服务端渲染，就是在客户端把标签渲染成html的工作放在服务端完成，然后将html返回给客户端<br>SSR有更好的SEO，首屏加载速度快，缺点是服务端渲染只支持beforeCreate和created两个钩子，需要nodejs环境，<br>对服务器有更大对负载需求</p><h3 id="20-vue性能优化"><a href="#20-vue性能优化" class="headerlink" title="20.vue性能优化"></a>20.vue性能优化</h3><ul><li><p>编码阶段：</p><ul><li>减少data中数据</li><li>v-if和v-show不能连用</li><li>SPA采用keep-alive缓存组件</li><li>使用路由懒加载，异步组件</li><li>第三模块按需引入</li><li>图片懒加载</li><li>防抖、节流</li></ul></li><li><p>SEO优化：</p><ul><li>预渲染</li><li>服务端渲染</li></ul></li><li><p>打包优化：</p><ul><li>压缩代码</li><li>tree shaking</li><li>cdn加载第三方模块</li><li>sourcemap优化</li></ul></li></ul><h3 id="21-hash路由和history路由的实现原理"><a href="#21-hash路由和history路由的实现原理" class="headerlink" title="21.hash路由和history路由的实现原理"></a>21.hash路由和history路由的实现原理</h3><p>location.hash的值实际上就是url中#后面的值<br>history采用懒H5中提供的API来实现，主要有history.pushState() history.replaceState()</p><h3 id="22-vuex"><a href="#22-vuex" class="headerlink" title="22.vuex"></a>22.vuex</h3><p>vuex和全局对象的区别：<br>vuex的状态存储是响应式的，组件从store中读取状态，当store中的状态变化时，会更新组件<br>不能直接改变store中状态，必须显式提交mutation</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        count:<span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutation:&#123;</span><br><span class="line">        <span class="function"><span class="title">increment</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">            state.count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">store.commit(<span class="string">&#x27;increment&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(store.state.count); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>由于 store 中的状态是响应式的，在组件中调用 store 中的状态简单到仅需要在计算属性中返回即可。触发变化也仅仅是在组件的 methods 中提交 mutation</p><h3 id="23-什么是vuex"><a href="#23-什么是vuex" class="headerlink" title="23.什么是vuex"></a>23.什么是vuex</h3><p>vuex是专门为vuejs应用程序开发的状态管理插件，集中存储管理组件状态，通过显式提交mutation改变组件状态</p><h3 id="24-vuex解决了什么？"><a href="#24-vuex解决了什么？" class="headerlink" title="24.vuex解决了什么？"></a>24.vuex解决了什么？</h3><p>多个组件依赖同一个状态，多层组件间传值<br>来自不同的组件的行为需要变更同一个状态</p><p>怎么引用vuex？<br>1.安装依赖 npm install vuex –save<br>2.在项目目录创建store文件夹<br>3.在store文件夹下新建index。js文件，创建vuex实例<br>4.在main文件中引入vuex和store</p><p>vuex的5个核心属性？<br>state    mutation        getter        actions        modules</p><p>vuex的状态管理存储在state中，通过提交mutation改变状态</p><p>vuex中状态是对象时，使用时，要深度克隆赋值对象再修改，防止影响原始数据</p><p>vuex中action和mutation有什么区别？<br>action提交的是mutation，而不是直接变更状态，mutation可以直接变更状态<br>action是this.$store.dispatch()来提交，而mutation是this.$store.commit来提交<br>接收参数不同，mutation第一个参数是state，action是context</p><h3 id="25-重定向页面："><a href="#25-重定向页面：" class="headerlink" title="25.重定向页面："></a>25.重定向页面：</h3><p>routes:[{path:’/a’, redirect: ‘/b’ }]<br>配置404页面：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">&quot;/404&quot;</span>,</span><br><span class="line">    name: <span class="string">&quot;notFound&quot;</span>,</span><br><span class="line">    component: notFound</span><br><span class="line">&#125;, </span><br><span class="line">&#123;</span><br><span class="line">    path: <span class="string">&quot;*&quot;</span>, <span class="comment">// 此处需特别注意置于最底部</span></span><br><span class="line">    redirect: <span class="string">&quot;/404&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="26-路由几种模式，区别是什么？"><a href="#26-路由几种模式，区别是什么？" class="headerlink" title="26.路由几种模式，区别是什么？"></a>26.路由几种模式，区别是什么？</h3><ul><li>hash：兼容所有浏览器，但不支持H5 history api hash值为#后面的内容，通过监听hashChange事件<br>来完成操作实现前端路由，hash值变化不会请求服务器</li><li>history：依赖H5 history API实现前端路由，和正常url一样，但是初次请求或刷新会请求服务器，没有<br>请求到对于资源会返回404</li><li>abstract：支持所有js运行环境，如果发现没有浏览器到api路由会强制进入此模式</li></ul><h3 id="27-发布-订阅者模式："><a href="#27-发布-订阅者模式：" class="headerlink" title="27.发布/订阅者模式："></a>27.发布/订阅者模式：</h3><p>vue内部实现了双向绑定机制，可以不再操作dom，此机制是通过数据劫持结合发布/订阅者模式实现的：通过object.defineProperty()来劫持各个属性的getter,setter属性，在数据变动时发布消息给订阅者，触发相应的监听回调。<br>订阅模式和观察者模式不一致，订阅模式有一个调度中心，对订阅事件统一进行管理。而观察者模式可以随意注册事件，调用事件。</p><h3 id="28-数据双向绑定基础：Object-defineProperty"><a href="#28-数据双向绑定基础：Object-defineProperty" class="headerlink" title="28.数据双向绑定基础：Object.defineProperty()"></a>28.数据双向绑定基础：Object.defineProperty()</h3><ul><li>数据属性：</li></ul><p>configurable—能否用delete删除属性从而重新定义属性<br>enumerable—能否通过for-in遍历，即是否可枚举<br>writable—能否修改属性的值，默认为true<br>value—属性的数据值，默认为undefined<br>若要修改上述4个数据属性，需要Object.defineProperty(属性所在对象，属性名，描述符对象)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name:’’</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person,”name”,&#123;</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    name:”test”</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>访问器属性：</li></ul><p>访问器属性不包含数据值value，包含一对getter,setter函数（非必须）。value和writable和get/set不能共存。<br>configurable—能否用delete删除属性从而重新定义属性<br>enumerable—能否通过for-in遍历，即是否可枚举<br>get—读取属性调用的函数，默认为undefined<br>value—读取属性调用的函数，默认为undefined</p><p>Object.create(null): this.set = Object.create(null)这样赋值，这样写不需要考虑原型链上的属性，可以真正创建一个纯净的对象。</p><h3 id="29-es6"><a href="#29-es6" class="headerlink" title="29.es6"></a>29.es6</h3><p>export default和export的区别：<br>1.在一个文件或模块中，可以有多个export，而export default只能有一个<br>2.通过export方式导出，在导入时要加{},而export default则不需要</p><p>箭头函数：<br>1.箭头函数中的this的指向时固定不变的，即是定义函数时的指向<br>2.普通函数中的this的指向是变化的，即是使用函数时的指向<br>class继承：<br>可通过extends关键字实现继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.company=‘A’;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">testA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.company;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.exployee=<span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>super关键字，表示父类的构造函数，用来新建父类的this对象。super虽然代表类父类A的构造函数，但是返回的是子类B的实例，即super内部的this指向的是B，因此 super()在这里相当于A.prototype.constructor.call(this)</p><ul><li>es5和es6实现继承的不同：</li></ul><p>es5的继承，实质上是先创建子类的实例对象this,然后将父类的方法添加到this上，Parent.apply(this)<br>es6的继承，实质上是先创建父类的实例对象this，然后再用子类的构造函数修改this。</p><ul><li>proxy:</li></ul><p>vue3将会用proxy代替object.defineProperty()完成数据劫持工作，会使初始化速度加倍，内存占用减半。<br>var proxy = new Proxy(target,handler);target表示要拦截的对象，handler用来定制拦截的行为。</p><h3 id="30-闭包"><a href="#30-闭包" class="headerlink" title="30.闭包"></a>30.闭包</h3><p>闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常用方式，就是一个函数中创建另一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一段：</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">con</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="built_in">this</span>.num )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> funOne = fun();</span><br><span class="line"></span><br><span class="line">funOne();  <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二段</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">con</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( num )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> funOne = fun();</span><br><span class="line"></span><br><span class="line">funOne(); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h3 id="31-函数柯里化"><a href="#31-函数柯里化" class="headerlink" title="31.函数柯里化"></a>31.函数柯里化</h3><p>就是把多个参数的函数，转化为单参数函数。<br>add(2)(3)(4)(5)输出14:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum=<span class="number">0</span>;</span><br><span class="line">    sum= sum+num;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">tempFun</span>(<span class="params">numB</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">arguments</span>.length===<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sum= sum+ numB;</span><br><span class="line">            <span class="keyword">return</span> tempFun;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-大文件上传</title>
      <link href="/ZJY.github.io/2021/01/19/javascript-%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/ZJY.github.io/2021/01/19/javascript-%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<p>整体思路：</p><ul><li>前端：<br>前端大文件上传网上的大部分文章已经给出了解决方案，核心是利用 Blob.prototype.slice 方法，和数组的 slice 方法相似，调用的 slice 方法可以返回原文件的某个切片<br>这样我们就可以根据预先设置好的切片最大数量将文件切分为一个个切片，然后借助 http 的可并发性，同时上传多个切片，这样从原本传一个大文件，变成了同时传多个小的文件切片，可以大大减少上传时间<br>另外由于是并发，传输到服务端的顺序可能会发生变化，所以我们还需要给每个切片记录顺序</li><li>服务端：<br>服务端需要负责接受这些切片，并在接收到所有切片后合并切片</li></ul><p>上传控件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> @<span class="attr">change</span>=<span class="string">&quot;handleFileChange&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">&quot;handleUpload&quot;</span>&gt;</span>上传<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    data: <span class="function">() =&gt;</span> (&#123;</span></span><br><span class="line">        container: &#123;</span><br><span class="line"><span class="javascript">        file: <span class="literal">null</span></span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;),</span><br><span class="line">methods: &#123;</span><br><span class="line"><span class="javascript">    <span class="keyword">async</span> <span class="function"><span class="title">handleFileChange</span>(<span class="params">e</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> [file] = e.target.files;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (!file) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">Object</span>.assign(<span class="built_in">this</span>.$data, <span class="built_in">this</span>.$options.data());</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.container.file = file;</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        <span class="keyword">async</span> <span class="function"><span class="title">handleUpload</span>(<span class="params"></span>)</span> &#123;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>请求逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">request(&#123;</span><br><span class="line">    url,</span><br><span class="line">    method = <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    data,</span><br><span class="line">    headers=&#123;&#125;,</span><br><span class="line">    requestList</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        xhr.open(method,url);</span><br><span class="line">        <span class="built_in">Object</span>.keys(headers).forEach(<span class="function"><span class="params">key</span>=&gt;</span>&#123;</span><br><span class="line">            xhr.setRequestHeader(key, headers[key])</span><br><span class="line">        &#125;);</span><br><span class="line">        xhr.send(data),</span><br><span class="line">        xhr.onload = <span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">            resolve(&#123;</span><br><span class="line">                data: e.target.response</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上传切片：</p><p>上传需要做两件事：<br>1.对文件进行切片<br>2.将切片传给服务器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"> <span class="keyword">const</span> LENGTH = <span class="number">10</span>; <span class="comment">// 切片数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">data: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    container: &#123;</span><br><span class="line">        file: <span class="literal">null</span>,</span><br><span class="line">         data: []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;),</span><br><span class="line">methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">request</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">handleFileChange</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">    <span class="comment">// 生成文件切片</span></span><br><span class="line">    <span class="function"><span class="title">createFileChunk</span>(<span class="params">file, length= LENGTH</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> fileChunkList = [];</span><br><span class="line">        <span class="keyword">const</span> chunkSize = <span class="built_in">Math</span>.ceil(file.size / length);<span class="comment">//切片大小</span></span><br><span class="line">        <span class="keyword">let</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="title">whilte</span>(<span class="params">cur &lt; file.size</span>)</span> &#123;</span><br><span class="line">            fileChunkList.push(&#123;<span class="attr">file</span>:file.slice(cur,curchunkSize)&#125;);</span><br><span class="line">            cur=chunkSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fileChunkList;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 上传切片</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">uploadChunks</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> requestList = <span class="built_in">this</span>.data.map(<span class="function">(<span class="params">&#123;chunk&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> formData = <span class="keyword">new</span> formData();</span><br><span class="line">            formData.append(<span class="string">&quot;chunk&quot;</span>,chunk);</span><br><span class="line">            formData.append(<span class="string">&quot;hash&quot;</span>,hash);</span><br><span class="line">            formData.append(<span class="string">&quot;filename&quot;</span>,<span class="built_in">this</span>.container.file.name);</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                formData;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).map(<span class="keyword">async</span> (&#123;formData&#125;)=&gt;&#123;</span><br><span class="line">            <span class="built_in">this</span>.request(&#123;</span><br><span class="line">                url:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                data: formData</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">await</span> <span class="built_in">Promise</span>.all(requestList);<span class="comment">//并发切片</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">handleUpload</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!<span class="built_in">this</span>.container.file) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">const</span> fileChunkList = <span class="built_in">this</span>.createFileChunk(<span class="built_in">this</span>.container.file);</span><br><span class="line">        <span class="built_in">this</span>.data = fileChunkList.map(<span class="function">(<span class="params">&#123;file&#125;,index</span>)=&gt;</span>&#123;</span><br><span class="line">            chunk: file,</span><br><span class="line">            hash: <span class="built_in">this</span>.container.file.name  <span class="string">&#x27;-&#x27;</span> index, <span class="comment">//文件名数组下标</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">await</span> <span class="built_in">this</span>.uploadChunks();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>当点击上传按钮时，调用 createFileChunk 将文件切片，切片数量通过一个常量 Length 控制，这里设置为 10，即将文件分成 10 个切片上传<br>createFileChunk 内使用 while 循环和 slice 方法将切片放入 fileChunkList 数组中返回<br>在生成文件切片时，需要给每个切片一个标识作为 hash，这里暂时使用文件名  下标，这样后端可以知道当前切片是第几个切片，用于之后的合并切片<br>随后调用 uploadChunks 上传所有的文件切片，将文件切片，切片 hash，以及文件名放入 FormData 中，再调用上一步的 request 函数返回一个 proimise，最后调用 Promise.all 并发上传所有的切片</p><p>发送合并请求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">await</span> <span class="built_in">Promise</span>.all(requestList);</span><br><span class="line"> <span class="comment">// 合并切片</span></span><br><span class="line"><span class="keyword">await</span> <span class="built_in">this</span>.mergeRequest();</span><br><span class="line"> <span class="keyword">async</span> <span class="function"><span class="title">mergeRequest</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="keyword">await</span> <span class="built_in">this</span>.request(&#123;</span><br><span class="line">         url: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">         headers: &#123;</span><br><span class="line">             <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">         &#125;,</span><br><span class="line">         data: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">             filename: <span class="built_in">this</span>.container.file.name</span><br><span class="line">         &#125;)</span><br><span class="line">     &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>服务端部分：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&quot;request&quot;</span>, <span class="keyword">async</span>(req, res)=&gt;&#123;</span><br><span class="line">    res.retHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>,<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    res.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>,<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(res.method == <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">        res.status = <span class="number">200</span>;</span><br><span class="line">        res.end();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function">()=&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;listening on port:3000&quot;</span>));</span><br></pre></td></tr></table></figure><p>接受切片：</p><p>使用multiparty包处理前端传来的formdata,在 multiparty.parse 的回调中，files 参数保存了 FormData 中文件，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">fields 参数保存了 FormData 中非文件的字段.</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fse = <span class="built_in">require</span>(<span class="string">&quot;fs-extra&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> multiparty = <span class="built_in">require</span>(<span class="string">&quot;multiparty&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"> <span class="keyword">const</span> UPLOAD_DIR = path.resolve(__dirname, <span class="string">&quot;..&quot;</span>, <span class="string">&quot;target&quot;</span>); <span class="comment">// 大文件存储目录</span></span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&quot;request&quot;</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">res.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">res.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (req.method === <span class="string">&quot;OPTIONS&quot;</span>) &#123;</span><br><span class="line">    res.status = <span class="number">200</span>;</span><br><span class="line">    res.end();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> multipart = <span class="keyword">new</span> multiparty.Form();</span><br><span class="line"></span><br><span class="line">  multipart.parse(req, <span class="keyword">async</span> (err, fields, files) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> [chunk] = files.chunk;</span><br><span class="line">    <span class="keyword">const</span> [hash] = fields.hash;</span><br><span class="line">    <span class="keyword">const</span> [filename] = fields.filename;</span><br><span class="line">    <span class="keyword">const</span> chunkDir = <span class="string">`<span class="subst">$&#123;UPLOAD_DIR&#125;</span>/<span class="subst">$&#123;filename&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 切片目录不存在，创建切片目录</span></span><br><span class="line">    <span class="keyword">if</span> (!fse.existsSync(chunkDir)) &#123;</span><br><span class="line">      <span class="keyword">await</span> fse.mkdirs(chunkDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重命名文件</span></span><br><span class="line">    <span class="keyword">await</span> fse.rename(chunk.path, <span class="string">`<span class="subst">$&#123;chunkDir&#125;</span>/<span class="subst">$&#123;hash&#125;</span>`</span>);</span><br><span class="line">    res.end(<span class="string">&quot;received file chunk&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;正在监听 3000 端口&quot;</span>));</span><br></pre></td></tr></table></figure><p>合并切片：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fse = <span class="built_in">require</span>(<span class="string">&quot;fs-extra&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"><span class="keyword">const</span> UPLOAD_DIR = path.resolve(__dirname, <span class="string">&quot;..&quot;</span>, <span class="string">&quot;target&quot;</span>); <span class="comment">// 大文件存储目录</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> resolvePost = <span class="function"><span class="params">req</span> =&gt;</span></span><br><span class="line">   <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">let</span> chunk = <span class="string">&quot;&quot;</span>;</span><br><span class="line">     req.on(<span class="string">&quot;data&quot;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">       chunk = data;</span><br><span class="line">     &#125;);</span><br><span class="line">     req.on(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">       resolve(<span class="built_in">JSON</span>.parse(chunk));</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 合并切片</span></span><br><span class="line"> <span class="keyword">const</span> mergeFileChunk = <span class="keyword">async</span> (filePath, filename) =&gt; &#123;</span><br><span class="line">   <span class="keyword">const</span> chunkDir = <span class="string">`<span class="subst">$&#123;UPLOAD_DIR&#125;</span>/<span class="subst">$&#123;filename&#125;</span>`</span>;</span><br><span class="line">   <span class="keyword">const</span> chunkPaths = <span class="keyword">await</span> fse.readdir(chunkDir);</span><br><span class="line">   <span class="keyword">await</span> fse.writeFile(filePath, <span class="string">&quot;&quot;</span>);</span><br><span class="line">   chunkPaths.forEach(<span class="function"><span class="params">chunkPath</span> =&gt;</span> &#123;</span><br><span class="line">     fse.appendFileSync(filePath, fse.readFileSync(<span class="string">`<span class="subst">$&#123;chunkDir&#125;</span>/<span class="subst">$&#123;chunkPath&#125;</span>`</span>));</span><br><span class="line">     fse.unlinkSync(<span class="string">`<span class="subst">$&#123;chunkDir&#125;</span>/<span class="subst">$&#123;chunkPath&#125;</span>`</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">   fse.rmdirSync(chunkDir); <span class="comment">// 合并后删除保存切片的目录</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&quot;request&quot;</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">res.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">res.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (req.method === <span class="string">&quot;OPTIONS&quot;</span>) &#123;</span><br><span class="line">    res.status = <span class="number">200</span>;</span><br><span class="line">    res.end();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (req.url === <span class="string">&quot;/merge&quot;</span>) &#123;</span><br><span class="line">     <span class="keyword">const</span> data = <span class="keyword">await</span> resolvePost(req);</span><br><span class="line">     <span class="keyword">const</span> &#123; filename &#125; = data;</span><br><span class="line">     <span class="keyword">const</span> filePath = <span class="string">`<span class="subst">$&#123;UPLOAD_DIR&#125;</span>/<span class="subst">$&#123;filename&#125;</span>`</span>;</span><br><span class="line">     <span class="keyword">await</span> mergeFileChunk(filePath, filename);</span><br><span class="line">     res.end(</span><br><span class="line">       <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">         code: <span class="number">0</span>,</span><br><span class="line">         message: <span class="string">&quot;file merged success&quot;</span></span><br><span class="line">       &#125;)</span><br><span class="line">     );</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;正在监听 3000 端口&quot;</span>));</span><br></pre></td></tr></table></figure><p>总结：<br>前端上传大文件时使用blob.prototype.slice将文件切片，并发上传多个切片，最后发送一个合并的请求通知服务端合并切片。<br>服务端接收切片并存储，收到合并请求后使用fs.appendFileSync对多个切片进行合并<br>原生XMLHttpRequest的upload.onpropgress对切片上传进度的监听<br>使用vue计算属性根据每个切片的进度算出整个文件的上传进度</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-前端路由</title>
      <link href="/ZJY.github.io/2021/01/19/javascript-%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/"/>
      <url>/ZJY.github.io/2021/01/19/javascript-%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由?"></a>什么是路由?</h3><p>简单的说 路由就是根据不同的url地址来展示不同的内容或页面.</p><h3 id="前端路由的来源"><a href="#前端路由的来源" class="headerlink" title="前端路由的来源"></a>前端路由的来源</h3><p>在很久很久以前~ 用户的每次更新操作都需要重新刷新页面,非常的影响交互体验,后来,为了解决这个问题,便有了Ajax(异步加载方案),Ajax给体验带来了极大的提升。<br>虽然Ajax解决了用户交互时体验的痛点,但是多页面之间的跳转一样会有不好的体验,所以便有了spa(single-page application)使用的诞生。而spa应用便是基于前端路由实现的,所以便有了前端路由<br>如今比较火的vue-router/react-router 也是基于前端路由的原理实现的~</p><h3 id="前端路由的两种实现原理"><a href="#前端路由的两种实现原理" class="headerlink" title="前端路由的两种实现原理"></a>前端路由的两种实现原理</h3><p>1.Hash模式</p><pre><code>window对象提供了onhashchange事件来监听hash值的改变,一旦url中的hash值发生改变,便会触发该事件。window.onhashchange = function()&#123;&#125;</code></pre><p>2.history模式</p><pre><code>HTML5的History API 为浏览器的全局history对象增加的扩展方法。简单来说,history其实就是浏览器历史栈的一个接口window对象提供了onpopstate事件来监听历史栈的改变,一旦历史栈信息发生改变,便会触发该事件。需要特别注意的是,调用history.pushState()或history.replaceState()不会触发popstate事件。只有在做出浏览器动作时，才会触发该事件。window.onpopstate = function()&#123;// 历史栈 信息改变// do you want&#125;history提供了两个操作历史栈的API:history.pushState 和 history.replaceState：history.pushState(data[,title][,url]);//向历史记录中追加一条记录history.replaceState(data[,title][,url]);//替换当前页在历史记录中的信息。// data: 一个JavaScript对象，与用pushState()方法创建的新历史记录条目关联。无论何时用户导航到新创建的状态，popstate事件都会被触发，并且事件对象的state属性都包含历史记录条目的状态对象的拷贝。//title: FireFox浏览器目前会忽略该参数，虽然以后可能会用上。考虑到未来可能会对该方法进行修改，传一个空字符串会比较安全。或者，你也可以传入一个简短的标题，标明将要进入的状态。//url: 新的历史记录条目的地址。浏览器不会在调用pushState()方法后加载该地址，但之后，可能会试图加载，例如用户重启浏览器。新的URL不一定是绝对路径；如果是相对路径，它将以当前URL为基准；传入的URL与当前URL应该是同源的，否则，pushState()会抛出异常。该参数是可选的；不指定的话则为文档当前URL。pushState操作：    history.pushState(&#123;&quot;foo&quot;:bar&#125;,&quot;page 2&quot;,&quot;apply&quot;)    history.state;   //输出 &#123;foo:&quot;bar&quot;&#125;    window.onpopstate = function()&#123;        console.log(&#39;router&#39;);    &#125;    history.pushState(&#123;&quot;foo&quot;:&quot;bar1&quot;&#125;,&quot;page2&quot;,&quot;apply&quot;);// 此时执行不触发onpopstate方法    history.state； //输出 &#123;foo:&#39;bar1&#39;&#125;    history.back(); //做出后退操作，触发onpopstate事件，此时输出 &#39;router&#39;    history.state; //输出 &#123;foo:&quot;bar&quot;&#125;    history.forward(); //做前进操作，触发onpopstate事件，此时输出 &#39;router&#39;    history.state; //输出 &#123;foo:&quot;bar1&quot;&#125;replaceState操作：    history.back();    history.state; //输出 &#123;foo:bar&#125; 当前是bar    history.replaceState(&#123;&quot;foo&quot;:&quot;barreplace&quot;&#125;,&quot;page2&quot;,&quot;test&quot;);//不触发onpopstate事件， 此时浏览器地址改为test,并不重新加载    history.state; //输出：&#123;foo:&quot;barreplace&quot;&#125;    history.forward(); //触发onpopstate事件，输出&#39;router&#39;    history.state;  //输出： &#123;foo:&quot;bar1&quot;&#125;    history.back();//触发onpopstate事件，输出&#39;router&#39;,重新加载test    history.state; //输出：&#123;foo:&quot;barreplace&quot;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-小程序云开发</title>
      <link href="/ZJY.github.io/2021/01/19/javascript-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91/"/>
      <url>/ZJY.github.io/2021/01/19/javascript-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>1.云开发：</p><p>云开发是原生Serverless云服务。<br>云开发与传统模式相比少了后端开发这一块。</p><p>2.云开发能力：</p><p>存储<br>云函数<br>云数据库<br>音视频服务<br>智能图像服务<br>一天多交付，快速迭代产品</p><p>3.初始化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wx.cloud.init(&#123;</span><br><span class="line">    <span class="comment">// env 参数说明：</span></span><br><span class="line">    <span class="comment">//   env 参数决定接下来小程序发起的云开发调用（wx.cloud.xxx）会默认请求到哪个云环境的资源</span></span><br><span class="line">    <span class="comment">//   此处请填入环境 ID, 环境 ID 可打开云控制台查看</span></span><br><span class="line">    <span class="comment">//   如不填则使用默认环境（第一个创建的环境）</span></span><br><span class="line">    env: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    traceUser: <span class="literal">true</span>, <span class="comment">//是否在云开发控制台可见用户信息</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>4.数据库</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> db = wx.cloud.database();</span><br><span class="line"><span class="keyword">const</span> _ = db.command</span><br><span class="line">db.collection(<span class="string">&#x27;集合名&#x27;</span>).get().then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p>1.get()查询<br>2.where条件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">counter不等于<span class="number">1</span>  <span class="number">3</span>  <span class="number">4</span>的记录</span><br><span class="line">where(&#123;</span><br><span class="line">    counter: _.nin([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">&#125;)</span><br><span class="line">counter等于<span class="number">1</span>  <span class="number">3</span>  <span class="number">4</span>的记录</span><br><span class="line">where(&#123;</span><br><span class="line">    counter: _.in([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3.字段类型查询</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.collection(<span class="string">&quot;data&quot;</span>)</span><br><span class="line">.field(&#123;</span><br><span class="line">    desc: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">.get().then(<span class="built_in">console</span>.log)</span><br><span class="line">查询所有数据但只显示有desc字段的内容，例如：</span><br><span class="line"><span class="number">0</span>: &#123;<span class="attr">_id</span>: <span class="string">&quot;dbbb40a0-a4e0-479d-8432-926d05b002a8&quot;</span>&#125;</span><br><span class="line"><span class="number">1</span>: &#123;<span class="attr">_id</span>: <span class="string">&quot;37aa3ea0-db49-4c12-849f-34e5342966da&quot;</span>, <span class="attr">desc</span>: <span class="string">&quot;name2&quot;</span>&#125;</span><br><span class="line"><span class="number">2</span>: &#123;<span class="attr">_id</span>: <span class="string">&quot;1d6ff516-5714-4970-9a28-a0f8b3f7a3e6&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>4.正则查询<br>可以使用原生的正则对象：<br>    /miniprogram/i<br>db.RegExp对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.RegExp(&#123;</span><br><span class="line">    regexp: <span class="string">&#x27;miniprogram&#x27;</span>,</span><br><span class="line">    options: <span class="string">&#x27;i&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>查询name值以name-0开头的数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    db.collection(<span class="string">&quot;data&quot;</span>)</span><br><span class="line">    .where(&#123;</span><br><span class="line">        name: <span class="keyword">new</span> db.RegExp(&#123;</span><br><span class="line">            regexp: <span class="string">&#x27;name-0[1-9]&#x27;</span>,</span><br><span class="line">            options: <span class="string">&#x27;i&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .get().then(<span class="built_in">console</span>.log)</span><br><span class="line"><span class="number">0</span>: &#123;<span class="attr">_id</span>: <span class="string">&quot;dbbb40a0-a4e0-479d-8432-926d05b002a8&quot;</span>, <span class="attr">counter</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;name-01&quot;</span>&#125;</span><br><span class="line"><span class="number">1</span>: &#123;<span class="attr">_id</span>: <span class="string">&quot;37aa3ea0-db49-4c12-849f-34e5342966da&quot;</span>, <span class="attr">counter</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&quot;name-02&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>5.地理位置查询</p><p>添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.collection(<span class="string">&#x27;location&#x27;</span>).add(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        location: db.Geo.Point(<span class="number">100.2333</span>,<span class="number">10.9978</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>查询：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.collection(<span class="string">&#x27;location&#x27;</span>).get().then( <span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res.data[<span class="number">0</span>].location)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>6.云开发数据库权限：</p><p>1.仅创建者可写，所有人可读<br>2.仅创建者可读写<br>3.仅管理端可写，所有人可读<br>4.仅管理端可读写</p><p>存储：</p><p>可使用fileid引用存储的资源</p><p>生成文件的临时链接：</p><p>为什么生成临时链接： fileid无法在小程序以外的平台使用<br>如何生成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wx.cloud.getTempFileURL(&#123;</span><br><span class="line">    fileList: [<span class="string">&#x27;cloud://zjy20200115-8v2oc.7a6a-zjy20200115-8v2oc-1258009129/oL40f5Rxp9wplmcEtUO3Av-4Yr9M/0.5019968125178349_1579073268192.jpg&#x27;</span>],<span class="comment">//fileid</span></span><br><span class="line">    success:<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res.fileList[<span class="number">0</span>].tempFileURL)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用云函数定时器：</p><p>1.在云函数目录下创建config.json文件，并设置触发器<br>2.上传触发器<br>步骤：<br>    1.创建云函数trigger<br>    2.上传云函数<br>    3.云函数目录下trigger创建config.json文件：添加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;triggers&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;trigger&quot;</span>, <span class="comment">//触发器名字</span></span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;timer&quot;</span>, <span class="comment">//类型：定时器</span></span><br><span class="line">            <span class="string">&quot;config&quot;</span>: <span class="string">&quot;* * * * * * *&quot;</span> <span class="comment">//触发事件配置，七位从右到左代表：年 星期 月 日 时 分 秒 ；七个*代表每秒钟执行一次</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.上传触发器<br>5.在云开发控制台-云函数-日志可查看</p><p>获取集合中指定记录的引用</p><p>db.collection(‘todos’).doc(‘my-todo-id’)<br>方法接受一个 id 参数，指定需引用的记录的 _id</p><p>limit(number):指定查询结果集数量上限:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.collection(<span class="string">&#x27;todos&#x27;</span>).limit(<span class="number">10</span>)</span><br><span class="line">.get()</span><br><span class="line">.then(<span class="built_in">console</span>.log)</span><br><span class="line">.catch(<span class="built_in">console</span>.error)</span><br></pre></td></tr></table></figure><p>skip(offset:number): 指定查询返回结果时从指定序列后的结果开始返回，常用于分页</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.collection(<span class="string">&#x27;todos&#x27;</span>).skip(<span class="number">10</span>)</span><br><span class="line">.get()</span><br><span class="line">.then(<span class="built_in">console</span>.log)</span><br><span class="line">.catch(<span class="built_in">console</span>.error)</span><br></pre></td></tr></table></figure><p>云上传：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wx.chooseImage(&#123;</span><br><span class="line">    success: <span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        wx.cloud.uploadFile(&#123;</span><br><span class="line">            cloudPath: <span class="string">&#x27;images/xx.png&#x27;</span>,</span><br><span class="line">            filePath: res.tempFilePaths[<span class="number">0</span>],</span><br><span class="line">        &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res.fileID)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>定位：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wx.chooseLocation(&#123;</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">        that.setData(&#123;</span><br><span class="line">            location:&#123;</span><br><span class="line">                name: res.name,</span><br><span class="line">                latitude: res.latitude,</span><br><span class="line">                longitude: res.longitude,</span><br><span class="line">                address: res.address</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>查看定位：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wx.openLocation(&#123;</span><br><span class="line">    latitude: <span class="built_in">this</span>.data.todoInfo.location.latitude,</span><br><span class="line">    longitude: <span class="built_in">this</span>.data.todoInfo.location.longitude,</span><br><span class="line">    name: <span class="built_in">this</span>.data.todoInfo.location.name,</span><br><span class="line">    address: <span class="built_in">this</span>.data.todoInfo.location.address   </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>report-submit： true,给表单此属性设置为true,会返回formId,用于发送模板消息</p><p>云函数查询数据：</p><p>新建云函数：query：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cloud = <span class="built_in">require</span>(<span class="string">&#x27;wx-server-sdk&#x27;</span>)</span><br><span class="line">cloud.init()</span><br><span class="line"><span class="keyword">const</span> db = cloud.database()</span><br><span class="line"><span class="comment">// 云函数入口函数</span></span><br><span class="line"><span class="built_in">exports</span>.main = <span class="keyword">async</span> (event, context) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> db.collection(<span class="string">&#x27;todos&#x27;</span>).get();</span><br><span class="line">&#125;</span><br><span class="line">页面查询触发：</span><br><span class="line">wx.cloud.callFunction(&#123;</span><br><span class="line">    name: <span class="string">&#x27;query&#x27;</span>,</span><br><span class="line">&#125;).then(<span class="built_in">console</span>.log)</span><br><span class="line"></span><br><span class="line">添加： add(&#123;<span class="attr">data</span>:&#123;&#125;&#125;)</span><br><span class="line">删除： remove()</span><br><span class="line">编辑： update(&#123;</span><br><span class="line">    data:&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在云函数中使用存储资源：</p><p>1.上传文件： uploadFile</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.main = <span class="keyword">async</span> (event, context) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> fileStream = fs.createReadStream(path.join(__dirname, <span class="string">&#x27;demo.jpg&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> cloud.uploadFile(&#123;</span><br><span class="line">        cloudPath: <span class="string">&#x27;demo.jpg&#x27;</span>,</span><br><span class="line">        fileContent: fileStream,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.下载文件： downloadFile<br>3.获取临时文件链接： getTempFileURL<br>4.删除文件： deleteFile</p><p>云函数访问第三方服务器:</p><p>1.安装got （版本9.6.0，10以上版本调用失败）<br>2.开启npm 模块<br>3.云函数修改后需重新上传</p><p>云函数访问数据库：</p><p>1.安装mysql2: npm i mysql2<br>2.引入： const mysql2 = require(‘mysql2’);<br>3.连接：<br>    const connection = await mysql.createConnection({<br>        host: ‘192.168.3.66’,<br>        port: ‘3306’,<br>        user: ‘root’,<br>        database: ‘sample’,<br>        password: ‘123456’<br>    })<br>    await connection.execute(“SELECT version();”)</p><p>云函数中生成小程序二维码：</p><p>1.引用安装wx-js-utils：npm install wx-js-utils<br>2.获取token和小程序id等信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    WXMINIUser,</span><br><span class="line">    WXMINIQR</span><br><span class="line">&#125; = <span class="built_in">require</span>(<span class="string">&#x27;wx-js-utils&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> appId = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 小程序 appId</span></span><br><span class="line"><span class="keyword">const</span> secret = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 小程序 secret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取小程序码，A接口</span></span><br><span class="line"><span class="keyword">let</span> wXMINIUser = <span class="keyword">new</span> WXMINIUser(&#123;</span><br><span class="line">    appId,</span><br><span class="line">    secret</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般需要先获取 access_token</span></span><br><span class="line"><span class="keyword">let</span> access_token = <span class="keyword">await</span> wXMINIUser.getAccessToken();</span><br><span class="line"><span class="keyword">let</span> wXMINIQR = <span class="keyword">new</span> WXMINIQR();</span><br></pre></td></tr></table></figure><p>3.获取二维码api: getQR</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">options: &#123;</span><br><span class="line">    access_token,</span><br><span class="line">    path,<span class="comment">//</span></span><br><span class="line">    width</span><br><span class="line">&#125;</span><br><span class="line">示例：</span><br><span class="line"><span class="keyword">let</span> qrResult = <span class="keyword">await</span> wXMINIQR.getQR(&#123;</span><br><span class="line">    access_token,</span><br><span class="line">    path: <span class="string">&#x27;pages/index/index&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line">上传：</span><br><span class="line">wx.cloud.uploadFile(&#123;bn </span><br><span class="line">    cloudPath: <span class="string">&#x27;qr/qr.png&#x27;</span>,</span><br><span class="line">    fileConent: qrResult</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>腾讯云短信sdk: qcloudsms_js</p><p>npm i qcloudsms_js</p><p>微信支付： node tenpay</p><p>npm i tenpay</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack-webpack基础使用</title>
      <link href="/ZJY.github.io/2021/01/19/webpack-webpack%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
      <url>/ZJY.github.io/2021/01/19/webpack-webpack%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h5 id="使用lodash-是一个一致性、模块化、高性能的-JavaScript-实用工具库。"><a href="#使用lodash-是一个一致性、模块化、高性能的-JavaScript-实用工具库。" class="headerlink" title="使用lodash:是一个一致性、模块化、高性能的 JavaScript 实用工具库。"></a>使用lodash:是一个一致性、模块化、高性能的 JavaScript 实用工具库。</h5><p>要使用lodash 需要本地安装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--npm install --save lodash</span><br></pre></td></tr></table></figure><h5 id="在安装一个要打包到生产环境的安装包时，你应该使用-npm-install-–save，如果你在安装一个用于开发环境的安装包（例如，linter-测试库等），你应该使用-npm-install-–save-dev。请在-npm-文档-中查找更多信息。"><a href="#在安装一个要打包到生产环境的安装包时，你应该使用-npm-install-–save，如果你在安装一个用于开发环境的安装包（例如，linter-测试库等），你应该使用-npm-install-–save-dev。请在-npm-文档-中查找更多信息。" class="headerlink" title="在安装一个要打包到生产环境的安装包时，你应该使用 npm install –save，如果你在安装一个用于开发环境的安装包（例如，linter, 测试库等），你应该使用 npm install –save-dev。请在 npm 文档 中查找更多信息。"></a>在安装一个要打包到生产环境的安装包时，你应该使用 npm install –save，如果你在安装一个用于开发环境的安装包（例如，linter, 测试库等），你应该使用 npm install –save-dev。请在 npm 文档 中查找更多信息。</h5><h5 id="加载css"><a href="#加载css" class="headerlink" title="加载css"></a>加载css</h5><p>为了从 JavaScript 模块中 import 一个 CSS 文件，你需要在 module 配置中 安装并添加 style-loader 和 css-loader：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--npm install --save-dev style-loader css-loader</span><br></pre></td></tr></table></figure><p>在webpack.config.js中配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">                use:[</span><br><span class="line">                    <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="加载图片：-在Css中有背景和图标等图片，需要安装file-loader来处理："><a href="#加载图片：-在Css中有背景和图标等图片，需要安装file-loader来处理：" class="headerlink" title="加载图片：  在Css中有背景和图标等图片，需要安装file-loader来处理："></a>加载图片：  在Css中有背景和图标等图片，需要安装file-loader来处理：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev file-loader</span><br></pre></td></tr></table></figure><p>在配置文件中配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test:<span class="regexp">/\.(png|svg|jpg|gif)&amp;/</span>,</span><br><span class="line">        use:[</span><br><span class="line">            <span class="string">&#x27;file-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="加载字体：-file-loader-和-url-loader-可以接收并加载任何文件，然后将其输出到构建目录"><a href="#加载字体：-file-loader-和-url-loader-可以接收并加载任何文件，然后将其输出到构建目录" class="headerlink" title="加载字体： file-loader 和 url-loader 可以接收并加载任何文件，然后将其输出到构建目录"></a>加载字体： file-loader 和 url-loader 可以接收并加载任何文件，然后将其输出到构建目录</h3><p>在配置文件中配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test:<span class="regexp">/\.(woff|woff2|eot|ttf|otf)$/</span>,</span><br><span class="line">        use:[</span><br><span class="line">            <span class="string">&#x27;file-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此外，可以加载的有用资源还有数据，如 JSON 文件，CSV、TSV 和 XML。类似于 NodeJS，JSON 支持实际上是内置的，也就是说 import Data from ‘./data.json’ 默认将正常运行。要导入 CSV、TSV 和 XML，你可以使用 csv-loader 和 xml-loader：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev csv-loader xml-loader</span><br></pre></td></tr></table></figure><p>在配置文件中配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test:<span class="regexp">/\.(csv|tsv)$/</span>,</span><br><span class="line">        use:[</span><br><span class="line">            <span class="string">&#x27;csv-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        test:<span class="regexp">/\.xml$/</span>,</span><br><span class="line">        use:[</span><br><span class="line">            <span class="string">&#x27;xml-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><p>如果我们更改了我们的一个入口起点的名称，甚至添加了一个新的名称，会发生什么？生成的包将被重命名在一个构建中，但是我们的index.html文件仍然会引用旧的名字。我们用 HtmlWebpackPlugin 来解决这个问题。首先安装插件，并且调整 webpack.config.js 文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev html-webpack-plugin</span><br><span class="line">webpack.config.js:</span><br><span class="line">    <span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line">    plugins: [</span><br><span class="line">       <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">       title: <span class="string">&#x27;Output Management&#x27;</span></span><br><span class="line">     &#125;)</span><br><span class="line">   ],</span><br></pre></td></tr></table></figure><h3 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h3><p>清理 /dist 文件夹:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install clean-webpack-plugin --save-dev</span><br><span class="line">webpack.config.js:</span><br><span class="line">    <span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> CleanWebpackPlugin(), /+</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><p>通过 manifest，webpack 能够对「你的模块映射到输出 bundle 的过程」保持追踪</p><h3 id="source-map"><a href="#source-map" class="headerlink" title="source map"></a>source map</h3><p>使用 source map: 为了更容易地追踪错误和警告，JavaScript 提供了 source map 功能，将编译后的代码映射回原始源代码。如果一个错误来自于 b.js，source map 就会明确的告诉你。ource map 有很多不同的选项可用,对于本指南，我们使用 inline-source-map 选项</p><p>devtool: ‘inline-source-map’</p><h3 id="webpack编译模式"><a href="#webpack编译模式" class="headerlink" title="webpack编译模式"></a>webpack编译模式</h3><p>每次要编译代码时，手动运行 npm run build 就会变得很麻烦,webpack 中有几个不同的选项，可以帮助你在代码发生变化后自动编译代码：</p><ul><li><p>1.webpack’s Watch Mode 使用观察模式 依赖图中的所有文件以进行更改。如果其中一个文件被更新，代码将被重新编译，所以你不必手动运行整个构建。<br>  scripts中添加”watch”: “webpack –watch”,唯一的缺点是，为了看到修改后的实际效果，你需要刷新浏览器。如果能够自动刷新浏览器就更好了，<br>  可以尝试使用 webpack-dev-server，恰好可以实现我们想要的功能</p></li><li><p>2.webpack-dev-server: 为你提供了一个简单的 web 服务器，并且能够实时重新加载(live reloading)让我们设置以下：npm install –save-dev webpack-dev-server<br>  修改配置文件，告诉开发服务器(dev server)，在哪里查找文件,webpack.config.js:<br>  devServer: {<br>   contentBase: ‘./dist’<br>  },<br>  以上配置告知 webpack-dev-server，在 localhost:8080 下建立服务，将 dist 目录   下的文件，作为可访问文件。在package.json中添加一个script脚本可直接运行开发服务器。</p></li><li><p>3.webpack-dev-middleware 是一个容器(wrapper)，它可以把 webpack 处理后的文件传递给一个服务器(server)。 webpack-dev-server 在内部使用了它，同时，它也可以作为一个单独的包来使用，以便进行更多自定义设置来实现更多的需求。接下来是一个 webpack-dev-middleware 配合 express server 的示例:<br>  首先，安装 express 和 webpack-dev-middleware:<br>  npm install –save-dev express webpack-dev-middleware<br>  webpack.config.js: output:{publicPath:’/‘}<br>  新建server.js,再添加一个npm script :”server”: “node server.js”,运行npm run server</p></li></ul><h3 id="tree-shaking是一个术语，通常用于描述移除-JavaScript-上下文中的未引用代码-dead-code"><a href="#tree-shaking是一个术语，通常用于描述移除-JavaScript-上下文中的未引用代码-dead-code" class="headerlink" title="tree shaking是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)"></a>tree shaking是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)</h3><h3 id="glifyJsPlugin-用来对js文件进行压缩，从而减小js文件的大小，加速load速度。"><a href="#glifyJsPlugin-用来对js文件进行压缩，从而减小js文件的大小，加速load速度。" class="headerlink" title="glifyJsPlugin 用来对js文件进行压缩，从而减小js文件的大小，加速load速度。"></a>glifyJsPlugin 用来对js文件进行压缩，从而减小js文件的大小，加速load速度。</h3><p>uglifyJsPlugin会拖慢webpack的编译速度，所有建议在开发简单将其关闭，部署的时候再将其打开。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--npm install uglifyjs-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure><p>通过webpack-merge配置不同环境的构建配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--npm install --save-dev webpack-merge</span><br></pre></td></tr></table></figure><p>多数情况下，你也可以进行 CSS 分离，以便在生产环境中节省加载时间:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--npm install --save-dev extract-text-webpack-plugin</span><br></pre></td></tr></table></figure><p>它会将所有的入口 chunk(entry chunks)中引用的 *.css，移动到独立分离的 CSS 文件。因此，你的样式将不再内嵌到 JS bundle 中，而是会放到一个单独的 CSS 文件（即 styles.css）当中。 如果你的样式文件大小较大，这会做更快提前加载，因为 CSS bundle 会跟 JS bundle 并行加载。</p><p>代码分离是 webpack 中最引人注目的特性之一。此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。有三种常用的代码分离方法：</p><ul><li><p>1.入口起点：使用 entry 配置手动地分离代码。</p></li><li><p>2.防止重复(prevent duplication): 通过使用 CommonsChunkPlugin 来移除重复的模块</p></li><li><p>3.动态导入(dynamic imports):</p><p>  涉及到动态代码拆分时，webpack 提供了两个类似的技术。对于动态导入，第一种，也是优先选择的方式是，使用符合 ECMAScript 提案 的 import() 语法。第二种，则是使用 webpack 特定的 require.ensure<br>  import() 调用会在内部用到 promises:使用： import().then(),由于import（）会返回一个promise函数，因此可以和async函数一起使用，但是需要使用像babel这样的预处理器和Syntax Dynamic Import Babel Plugin：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--npm install --save-dev @babel/plugin-syntax-dynamic-<span class="keyword">import</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-vue基础知识点</title>
      <link href="/ZJY.github.io/2021/01/19/vue-vue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/ZJY.github.io/2021/01/19/vue-vue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="vue渐进式JavaScript框架"><a href="#vue渐进式JavaScript框架" class="headerlink" title="vue渐进式JavaScript框架"></a>vue渐进式JavaScript框架</h3><p>核心库和插件，核心库很小，需要其他插件时添加进来</p><p>核心库只关注视图层，动态构建用户界面</p><p>框架顺序：angluar(数据绑定和模板)、react（组件化和虚拟Dom技术）、vue</p><p>1、vue的特点<br>遵循MVVM模式<br>编码简洁、体积小、运行效率高<br>本身只关注UI，可以轻松引入插件（依赖vue)或第三方库(不依赖vue)开发项目</p><p>2、vue借鉴  </p><p>angluar(数据绑定和模板)<br>react（组件化和虚拟Dom技术）</p><p>3、vue扩展插件</p><p>vue-cli:vue脚手架<br>vue-resources(axios):ajax请求<br>vue-router:路由<br>vue-scroll:页面滑动<br>vue-lazyload：图片懒加载<br>vuex:状态管理模式<br>mint-ui：基于vue的UI组件库（移动端）<br>element-UI：基于vue的UI组件库（pc端）</p><p>4、vue的使用</p><p>1.引入vue.js<br>2.创建vue实例,el指定选择器范围，data初始化数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> vue(&#123;</span><br><span class="line">    el:<span class="string">&#x27;app&#x27;</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        message:<span class="string">&#x27;hello&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>5.MVVM<br>model:模型、数据对象（data）<br>view:视图、模板页面（指令、<code>&#123;&#123;&#125;&#125;`显示数据）viewmodel:视图模型（vue的实例）<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">                    viewmodel</span><br><span class="line">view-------------dom listener--------------&gt;model</span><br><span class="line">view&lt;------------data bindings--------------model</span><br><span class="line">(DOM)              (vue实例)              (js objects)</span><br></pre></td></tr></table></figure>6、数据绑定：Mustache语法（双大括号）`&#123;&#123;msg&#125;&#125;</code></p><p>7、v-once一次性的插值，当数据改变时，内容不会更新</p><p>8、v-html输入真正的HTML</p><p>9、v-bind：href将mustache语法作用于HTML特性上可简写：href</p><p>10、使用JavaScript表达式<code>&#123;&#123;msg.toUpperCase()&#125;&#125;</code></p><p>11、指令：带有v-前缀的特殊特性  v-if  v-for</p><p>12、v-on:click简写为：@click</p><p>13、计算属性computed和侦听属性watch<br>computed的set监听方法，值改变时调用set回调方法，需要显示值时，调用get回调方法<br>计算属性存在缓存，多次读取只执行一次getter计算</p><p>14、class和style绑定</p><ul><li>:class=”classA”(字符串）</li><li>:class=”{classA:isA,classB:isB}”(对象)</li><li>:class=”[‘classA;,’classB’]”(数组）</li><li>:style=”{color:activeColor,fontSize:fontSize+’px’}”(样式JS写法）</li></ul><p>15、条件渲染</p><p>v-if v-else-if v-else v-show<br>v-if是惰性的如果初始条件为假则什么都不做，直到条件第一次变为真时，v-show不管初始条件真假，元素总被渲染，并且知识简单地基于css切换<br>v-if有更高的切换开销，v-show有更高的初始渲染开销，因此，需频繁切换则使用v-show较好，如果运行时条件很少改变，则使用v-if</p><p>16、不建议v-if和v-show同时使用，v-for具有比v-if更高的优先级</p><p>17、列表渲染</p><p>v-for=”item in items”/v-for=”(item,index) in items”<br>可用of代替in<br>遍历对象按Object.keys()结果遍历</p><p>18、数组更新检测-变异方法</p><p>vue包含一组观察数组的变异方法，也会触发视图更新：<br>push()向数组末尾添加一个或多个元素，返回新的长度<br>pop()删除并返回数组的最后一个元素<br>shift()删除数组第一个元素并返回第一个元素的值<br>unshift()向数组开头添加一个或更多元素，并返回新的长度<br>splice()增、删、改数组项目，返回被删除的项目，改变原数组<br>sort()数组排序<br>reverse()颠倒数组的元素顺序，会改变原数组</p><p>19、filter数组过滤 sort排序</p><p>20、绑定事件@click=’test($event)’,$event代表当前绑定事件标签</p><p>test(event){ var text = event.target.innerHTML}</p><p>21、事件冒泡：从子到父依次执行，阻止事件冒泡，事件修饰符@click.stop=”test”原生写法:event.stopPropagation()</p><p>22、阻止事件的默认行为(比如跳转），@click.prevent=”test”原生写法：event.preventDefault</p><p>23、按键修饰符@click.enter .tab .deleter .esc .space .up .down .left .right</p><p>24、使用v-model对表单数据自动收集 双向绑定</p><p>26、vue实例的生命周期</p><p>new vue 创建vue实例<br>初始化显示（执行一次）：</p><pre><code>beforeCreate    初始化设置：observe data  init eventscreatedbeforeMountmounted</code></pre><p>更新状态（执行n次）：</p><pre><code>beforeUpdateupdated</code></pre><p>销毁vue实例（执行n次）：</p><pre><code>beforeDestorydestroyed</code></pre><p>常用生命周期：<br>mounted：请求ajax请求，设置定时器等<br>beforeDestroyed:销毁vue实例前，清除定时器等</p><p>27、transition过渡动画</p><p>在目标元素外包裹<code>&lt;transition name=&quot;xxx&quot;&gt;&lt;/transition&gt;</code><br>定义class样式：<br>    xxx-enter-active   xxx-leave-active<br>    xxx-enter          xxx-leave-to</p><p>28、自定义过滤器</p><p>1.在组件的选项中定义本地过滤器<br>2.在创建vue实例前定义全局过滤器<br>页面使用：<br><code>&#123;&#123;date | filterDate('YYYY-MM-DD')&#125;&#125;</code><br>js:<br>引入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> format <span class="keyword">from</span> <span class="string">&#x27;date-fns/format&#x27;</span></span><br><span class="line">filters:&#123;</span><br><span class="line">    filterDate:<span class="function"><span class="keyword">function</span>(<span class="params">value,fmt</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> format(value,fmt || <span class="string">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>29、指令</p><p>v-text:更新元素的textContext<br>v-html:更新元素的innerHTML<br>v-show:条件为true，切换元素的display属性<br>v-if<br>v-else-if<br>v-else<br>v-for:列表渲染<br>v-on/@:绑定事件监听器<br>v-bind:简写：，绑定Dom属性<br>v-model:在表单控件上双向绑定<br>v-pre:跳过这个元素和它的子元素的编译过程<br>v-cloak:<code>&lt;div v-cloak&gt;``&#123;&#123; message &#125;&#125;</code></div>这个指令保持在元素上直到关联实例结束编译 防止闪现, 与 css 配合:[v-cloak]{display:none}<br>v-once:只渲染元素和组件一次<br>$ref:指定唯一标识,vue 对象通过$refs 属性访问这个元素对象</p><p>30.自定义指令</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-upper-text</span>=<span class="string">&quot;msg&quot;</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-lower-text</span>=<span class="string">&quot;msg&quot;</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注册全局指令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">&#x27;upper-text&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">el,binding</span>)</span>&#123;</span><br><span class="line">    el.innerHTML= binding.value.toUpperCase()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册局部指令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">directives:&#123;</span><br><span class="line">    <span class="string">&#x27;lower-text&#x27;</span>:<span class="function"><span class="keyword">function</span>(<span class="params">el,binding</span>)</span>&#123;</span><br><span class="line">        el.innerHTML= binding.value.toLowerCase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>31.创建vue项目</p><p>npm install -g vue-cli<br>vue init webpack vueProjectname<br>cd vueProjectname<br>npm install<br>npm run dev<br>访问：<a href="http://localhost:8080/">http://localhost:8080/</a></p><p>32.模板项目结构</p><p>|–build:webpack 相关的配置文件夹(基本不需要修改)<br>|–dev-server.js: 通过 express 启动后台服务器<br>|–config:webpack 相关的配置文件夹(基本不需要修改)<br>|–index.js: 指定的后台服务的端口号和静态资源文件夹<br>|–node_modules<br>|–src: 源码文件夹<br>|–components:vue 组件及其相关资源文件夹<br>|–App.vue: 应用根主组件<br>|–main.js: 应用入口 js<br>|–static: 静态资源文件夹<br>|–.babelrc:babel 的配置文件<br>|–.eslintignore:eslint 检查忽略的配置 |–.eslintrc.js:eslint 检查的配置<br>|–.gitignore:git 版本管制忽略的配置<br>|–index.html: 主页面文件<br>|–package.json: 应用包配置文件<br>|–README.md: 应用描述说明的 readme 文件</p><p>33、项目打包和发布</p><p>1.打包：npm run build<br>2.发布：npm install -g serve<br>3.访问：<a href="http://localhost:5000/">http://localhost:5000</a></p><p>34.组件使用</p><p>1.引入组件  import List from ‘’<br>2.映射成标签：components:{}<br>3.使用<code>&lt;List&gt;&lt;/List&gt;</code></p><p>35、数据代理</p><p>数据代理是通过一个对象代理（A)对另一个对象（B,B在A中）中属性的操作</p><p>36、vue数据代理</p><p>通过MVVM对象代理data对象中所有属性的操作<br>基本流程：<br>    通过Object.defineProperty()给VM添加与data对象的属性相对应的属性描述符<br>    所有添加的属性都包含getter/setter<br>    getter/setter内部去操作data中对象属性数据</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>taro-taro的基本使用</title>
      <link href="/ZJY.github.io/2021/01/19/taro-taro%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/ZJY.github.io/2021/01/19/taro-taro%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行:"></a>项目运行:</h3><pre><code>微信小程序：npm run dev:weappH5:npm run dev:h5</code></pre><h3 id="项目打包"><a href="#项目打包" class="headerlink" title="项目打包"></a>项目打包</h3><pre><code>微信小程序：npm run build:weappH5:npm run build:h5</code></pre><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>在 Taro 中尺寸单位建议使用 px、 百分比 %，Taro 默认会对所有单位进行转换。在 Taro 中书写尺寸按照 1:1 的关系来进行书写</p><p>如果你希望部分 px 单位不被转换成 rpx 或者 rem ，最简单的做法就是在 px 单位中增加一个大写字母，例如 Px 或者 PX 这样，则会被转换插件忽略</p><p>Taro 默认以 750px 作为换算尺寸标准</p><p>Taro 提供了 API Taro.pxTransform 来做运行时的尺寸转换:Taro.pxTransform(10) // 小程序：rpx，H5：rem</p><p>对于头部包含注释 /<em>postcss-pxtransform disable</em>/ 的文件，插件不予处理。</p><p>externalClasses 需要使用 短横线命名法 (kebab-case)，而不是 React 惯用的 驼峰命名法 (camelCase)。否则无效。</p><p> Taro 中，所有组件都应当首字母大写并且使用大驼峰式命名法（Camel-Case）</p><p> Taro只能使用map,forEach,reduce等无效</p><p> setState() 函数是唯一能够更新 this.state 的地方。taro的状态更新一定是异步的，可以在回调中取得更新后的值，react的setState不总是异步的</p><p> 在 Taro 中不能使用 catchEvent 的方式阻止事件冒泡。你必须明确的使用 stopPropagation</p><p> 在 Taro 的页面和组件类中，this 指向的是 Taro 页面或组件的实例,要获取对应的小程序原生页面和组件的实例，通过this.$scope</p><h3 id="react组件的生命周期："><a href="#react组件的生命周期：" class="headerlink" title="react组件的生命周期："></a>react组件的生命周期：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructor，顾名思义，组件的构造函数。一般会在这里进行 state 的初始化，事件的绑定等等</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是当组件在进行挂载操作前，执行的函数，一般紧跟着 constructor 函数后执行</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentWillMount</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是当组件挂载在 dom 节点后执行。一般会在这里执行一些异步数据的拉取等动作</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当组件在进行更新之前，会执行的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentWillUpdate</span>(<span class="params">nextProps, nextState</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当组件收到新的 props 时会执行的函数，传入的参数就是 nextProps ，你可以在这里根据新的 props 来执行一些相关的操作，例如某些功能初始化等</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentWillReceiveProps</span>(<span class="params">nextProps</span>)</span> &#123;&#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当组件完成更新时，会执行的函数，传入两个参数是 prevProps 、prevState</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentDidUpdate</span>(<span class="params">prevProps, prevState</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 false 时，组件将不会进行更新，可用于渲染优化</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当组件准备销毁时执行。在这里一般可以执行一些回收的工作，例如 clearInterval(this.timer) 这种对定时器的回收操作</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line"></span><br><span class="line">        &lt;div&gt;</span><br><span class="line"></span><br><span class="line">            &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">            &lt;h2&gt;It is &#123;<span class="built_in">this</span>.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>props：父组件传给子组件的数据，会挂载在子组件的 this.props 上</p><p>state：与 props 不同，是属于组件自己内部的数据状态，一般在 constructor 构造函数里初始化定义 state</p><p>react组件的三个声明周期状态：</p><pre><code>*Mount: 插入真实Dom*Update: 被重新渲染*Unmount：被移除真实Dom</code></pre><h3 id="生命周期流程"><a href="#生命周期流程" class="headerlink" title="生命周期流程"></a>生命周期流程</h3><pre><code>第一次初始化渲染显示：ReactDom.render()    *constructor: 创建对象初始化state    *componentWillMount(): 将要插入回调    * render() : 用于插入虚拟 DOM 回调    * componentDidMount() : 已经插入回调每次更新 state: this.setSate()     * componentWillUpdate() : 将要更新回调    * render() : 更新(重新渲染    * componentDidUpdate() : 已经更新回调</code></pre><h3 id="taro-ui使用方式："><a href="#taro-ui使用方式：" class="headerlink" title="taro-ui使用方式："></a>taro-ui使用方式：</h3><pre><code>在页面test.tsx中：    import &#123; AtButton &#125; from &#39;taro-ui&#39;    按需引入：@import &quot;~taro-ui/dist/style/components/button.scss&quot;;全局引入使用：    在app.scss中：@import &quot;~taro-ui/dist/style/index.scss&quot;;    在页面：import &#123; AtButton &#125; from &#39;taro-ui&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> taro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css-scss的基本使用</title>
      <link href="/ZJY.github.io/2021/01/19/css-scss%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/ZJY.github.io/2021/01/19/css-scss%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="scss基础使用"><a href="#scss基础使用" class="headerlink" title="scss基础使用"></a>scss基础使用</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量:"></a>变量:</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$primary-color: #341234;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: $primary-color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">nav</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span> &#123;</span><br><span class="line">        left:<span class="number">0</span>;</span><br><span class="line">        <span class="attribute">right</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="混合属性"><a href="#混合属性" class="headerlink" title="混合属性:"></a>混合属性:</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span>  alert &#123;</span><br><span class="line">    <span class="selector-tag">color</span>: <span class="selector-id">#723899</span>;</span><br><span class="line">    background-color: $primary-color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@mixin</span>  alert-a &#123;</span><br><span class="line">    <span class="selector-tag">color</span>: <span class="selector-id">#723899</span>;</span><br><span class="line">    background-color: $primary-color;</span><br><span class="line">    <span class="selector-tag">a</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>:$primary-color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@mixin</span> alert-b($text-color,$background) &#123;</span><br><span class="line">    color: $text-color;</span><br><span class="line">    background-color: $background;</span><br><span class="line">    <span class="selector-tag">span</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>: <span class="built_in">darken</span>($text-color,<span class="number">10%</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span>&#123;</span><br><span class="line">    @include alert</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span>&#123;</span><br><span class="line">    @include alert-a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line">    @include alert-b(#786789,#000 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承"><a href="#继承" class="headerlink" title="继承:"></a>继承:</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.alert</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.alert-info</span> &#123;</span><br><span class="line">    @extend .alert;</span><br><span class="line">    <span class="selector-tag">background</span>: <span class="selector-id">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色:"></a>颜色:</h4><p>rgb(255,255,255)<br>rgba(255,255,255,1)<br>红绿蓝透明度</p><p>hsl(50,100%,50%)<br>hsla(50,100%,50%,0.5)<br>色相 饱和度 明度 透明度</p><p>adjust-hue调整颜色 background: adjust-hue(#fff, 123deg)</p><p>lighten darken函数 $lighten-color: lighten(#fff,30%) $darken-color: darken(#fff,20%)</p><p>saturate增加颜色的纯度 desaturate减少颜色的纯度<br>$saturate-color: saturate(#000,40%)<br>$desaturate-color: desaturate(#000,40%)</p><p>opacify添加透明度(让颜色更不透明)  transparentize减少透明度(让颜色更透明)</p><h4 id="interpolation插入值"><a href="#interpolation插入值" class="headerlink" title="interpolation插入值 :"></a>interpolation插入值 :</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$text: &#x27;info&#x27;;</span><br><span class="line">.alert-#&#123;$text&#125; &#123;</span><br><span class="line">    background:$primary-color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">results</span>:</span><br><span class="line"><span class="selector-class">.alert-info</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="if条件判断"><a href="#if条件判断" class="headerlink" title="if条件判断:"></a>if条件判断:</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@if</span> condition&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$conditon: 2 &gt; 1;</span><br><span class="line"><span class="selector-class">.rounded</span> &#123;</span><br><span class="line">    @if $conditon &#123;</span><br><span class="line">        <span class="selector-tag">-webkit-animation-name</span>: <span class="selector-tag">taro</span>;</span><br><span class="line">        <span class="selector-tag">-moz-animation-name</span>: <span class="selector-tag">taro</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">border-radius</span>: 5<span class="selector-tag">px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$color : &quot;dark&quot;;</span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    @if $color == dark &#123;</span><br><span class="line">        <span class="selector-tag">background-color</span>: <span class="selector-tag">darkblue</span>;</span><br><span class="line">    &#125; <span class="keyword">@else</span> if $color == lighten &#123;</span><br><span class="line">        <span class="selector-tag">background-color</span>: <span class="selector-tag">lightblue</span>;</span><br><span class="line">    &#125; <span class="keyword">@else</span> &#123;</span><br><span class="line">        <span class="selector-tag">background</span>: <span class="selector-tag">gray</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环:"></a>for循环:</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@for</span> $var from &lt;begain&gt; through &lt;end&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$columns: 4;</span><br><span class="line"><span class="keyword">@for</span> $i from <span class="number">1</span> through $columns &#123;</span><br><span class="line">    .col-#&#123;$i&#125; &#123;</span><br><span class="line">        width: 100% / $columns * $i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">results</span>:</span><br><span class="line"><span class="selector-class">.col-1</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">25%</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-2</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-3</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">75%</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-4</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@for</span> $i from <span class="number">1</span> to $columns &#123;</span><br><span class="line">    .col-#&#123;$i&#125; &#123;</span><br><span class="line">        width: 100% / $columns * $i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">results</span>:</span><br><span class="line"><span class="selector-class">.col-1</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">25%</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-2</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-3</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">75%</span>; &#125;</span><br></pre></td></tr></table></figure><h4 id="each语句"><a href="#each语句" class="headerlink" title="each语句"></a>each语句</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@each</span> $var in $lists &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$icons: success error warning;</span><br><span class="line"><span class="keyword">@each</span> $icon in $icons &#123;</span><br><span class="line">    .icon-#&#123;$icon&#125;&#123;</span><br><span class="line">        background-image: url(../image/icons/#&#123;$icon&#125;.png);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">results</span>:</span><br><span class="line"><span class="selector-class">.icon-success</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(../image/icons/success.png); &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.icon-error</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(../image/icons/error.png); &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.icon-warning</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(../image/icons/warning.png); &#125;</span><br></pre></td></tr></table></figure><h4 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@while</span> condition &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$i : 6;</span><br><span class="line"><span class="keyword">@while</span> $i &gt; <span class="number">0</span> &#123;</span><br><span class="line">    .item-#&#123;$i&#125; &#123;</span><br><span class="line">        width: 5px * $i;</span><br><span class="line">    &#125;</span><br><span class="line">    $i : $i - 2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">results</span>:</span><br><span class="line"><span class="selector-class">.item-6</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">30</span>rpx; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item-4</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20</span>rpx; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item-2</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">10</span>rpx; &#125;</span><br></pre></td></tr></table></figure><h4 id="用户自定义函数"><a href="#用户自定义函数" class="headerlink" title="用户自定义函数:"></a>用户自定义函数:</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$colors: (light: #fff, dark: #000);</span><br><span class="line"><span class="keyword">@function</span> color($key)&#123;</span><br><span class="line">    // <span class="keyword">@if</span> <span class="keyword">not</span> map-has-key($colors, $key)&#123;</span><br><span class="line">    //     <span class="keyword">@warn</span> <span class="string">&quot;在colors中没有这个属性&quot;</span></span><br><span class="line">    // &#125;</span><br><span class="line">    @return map-get($colors,$key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.test</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">color</span>(gray);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">results</span>:</span><br><span class="line">    <span class="selector-class">.test</span> &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="warn-警告信息-error错误信息"><a href="#warn-警告信息-error错误信息" class="headerlink" title="@warn 警告信息  @error错误信息"></a>@warn 警告信息  @error错误信息</h4><h4 id="sass编译输入四种格式"><a href="#sass编译输入四种格式" class="headerlink" title="sass编译输入四种格式:"></a>sass编译输入四种格式:</h4><p>1.nested,嵌套<br>2.compact,紧凑<br>3.expander,扩展<br>4.compressed,压缩</p><p>.sass缩进式写法  .scss嵌套写法</p><h4 id="partials与-import"><a href="#partials与-import" class="headerlink" title="partials与@import:"></a>partials与@import:</h4><p>文件名以_下划线开头的是partials,不会编译 _base.scss<br>可以通过@import “base”;将文件引入</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongodb-MongoDB的安装使用</title>
      <link href="/ZJY.github.io/2021/01/19/mongodb-MongoDB%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
      <url>/ZJY.github.io/2021/01/19/mongodb-MongoDB%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>MongoDB非关系数据库、键值对数据、文档型数据库、快速开发<br>存储的是各种各样的json</p><p>1.安装MongoDB（官网下载，版本号偶数稳定版，奇数开发版）</p><p>2.配置环境变量</p><p>path中添加安装路径的bin文件夹 例E:\MongoDB\bin</p><p>3.在c盘根目录</p><p>存储数据的目录：创建data目录-》创建db目录</p><p>4.打开cmd命令窗口</p><ul><li>输入mongod 启动mongdb服务器 等待连接</li><li>32位电脑第一次启动时：mongod –storageEngine==mmapv1</li><li>可以通过mongod –dbpath url(启动指定数据库路径)</li><li>默认端口27017</li><li>指定端口号mongod –dbpath url(启动指定数据库路径c:\data\db) –port 1234</li></ul><p>5.再打开cmd窗口</p><p>输入mongo  连接</p><p>6.数据库</p><ul><li>数据库的服务器（保存数据） mongod 启动服务器</li><li>数据库的客户端（操作数据） mongo  启动客户端</li></ul><p>7.将MongoDB设置为系统服务，自动后台启动</p><p>c盘根目录data下创建log日志文件<br>在安装路径bin上一级目录创建配置文件mongod.cfg</p><pre><code>systemLog:    destination:file    path: c:\data\log\mongod.logstorage:    dbPath: c:\data\db</code></pre><p>以管理员身份打开命令窗口<br>执行如下命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc.exe create MongoDB binPath=<span class="string">&quot;\&quot;E:\MongoDB\bin\mongod.exe\&quot; --service --config=\&quot;E:\MongoDB\mongod.cfg\&quot;&quot;</span> DisplayName=<span class="string">&quot;MongoDB&quot;</span> start=<span class="string">&quot;auto&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>target和currentTarget区别</title>
      <link href="/ZJY.github.io/2021/01/19/javascript-target%E5%92%8CcurrentTarget%E5%8C%BA%E5%88%AB/"/>
      <url>/ZJY.github.io/2021/01/19/javascript-target%E5%92%8CcurrentTarget%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="target和currentTarget区别"><a href="#target和currentTarget区别" class="headerlink" title="target和currentTarget区别"></a>target和currentTarget区别</h2><p>target:触发事件的元素<br>currentTarget:事件绑定的元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;ulT&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item3&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item4&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item5&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时target和currentTarget是一样的 都是点击的li标签</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lis = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>;i&lt;lis.length;i++)&#123;</span><br><span class="line">    lis[i].onclick= <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e.target);  <span class="comment">//&lt;li class=&quot;item1&quot;&gt;1&lt;/li&gt;</span></span><br><span class="line">        <span class="built_in">console</span>.log(e.currentTarget); <span class="comment">//&lt;li class=&quot;item1&quot;&gt;1&lt;/li&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时是不一样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line">ul.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.target);  <span class="comment">//当前的li</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.currentTarget); <span class="comment">//元素的ul</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECMAScript和JavaScript的区别以及小程序区别</title>
      <link href="/ZJY.github.io/2021/01/19/javascript-ECMAScript%E5%92%8CJavaScript%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8C%BA%E5%88%AB/"/>
      <url>/ZJY.github.io/2021/01/19/javascript-ECMAScript%E5%92%8CJavaScript%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h3><p>ECMAScript是一种由Ecma国际通过ECMA-262标准化的脚本程序设计语言， JavaScript 是 ECMAScript 的一种实现.</p><p>小程序中的 JavaScript同浏览器中的 JavaScript 以及 NodeJS 中的 JavaScript 是不相同的</p><h3 id="ECMA-262-规定了-ECMAScript-语言的几个重要组成部分："><a href="#ECMA-262-规定了-ECMAScript-语言的几个重要组成部分：" class="headerlink" title="ECMA-262 规定了 ECMAScript 语言的几个重要组成部分："></a>ECMA-262 规定了 ECMAScript 语言的几个重要组成部分：</h3><ul><li>语法</li><li>类型</li><li>语句</li><li>关键字</li><li>操作符</li><li>对象</li></ul><h3 id="浏览器中JavaScript-构成如下-ECMAScript-DOM（文档对象模型）-BOM（浏览器对象模型）"><a href="#浏览器中JavaScript-构成如下-ECMAScript-DOM（文档对象模型）-BOM（浏览器对象模型）" class="headerlink" title="浏览器中JavaScript 构成如下: ECMAScript + DOM（文档对象模型） + BOM（浏览器对象模型）"></a>浏览器中JavaScript 构成如下: ECMAScript + DOM（文档对象模型） + BOM（浏览器对象模型）</h3><h3 id="NodeJS中JavaScript-构成如下-ECMAScript-NPM-包管理系统-Native"><a href="#NodeJS中JavaScript-构成如下-ECMAScript-NPM-包管理系统-Native" class="headerlink" title="NodeJS中JavaScript 构成如下: ECMAScript + NPM (包管理系统) + Native"></a>NodeJS中JavaScript 构成如下: ECMAScript + NPM (包管理系统) + Native</h3><h3 id="小程序中-JavaScript-构成如下-ECMAScript-小程序框架-小程序-API"><a href="#小程序中-JavaScript-构成如下-ECMAScript-小程序框架-小程序-API" class="headerlink" title="小程序中 JavaScript 构成如下: ECMAScript + 小程序框架 + 小程序 API"></a>小程序中 JavaScript 构成如下: ECMAScript + 小程序框架 + 小程序 API</h3><p>同浏览器中的JavaScript 相比没有 BOM 以及 DOM 对象，所以类似 JQuery、Zepto这种浏览器类库是无法在小程序中运行起来的，同样的缺少 Native 模块和NPM包管理的机制，小程序中无法加载原生库，也无法直接使用大部分的 NPM 包。</p><h3 id="小程序的执行环境"><a href="#小程序的执行环境" class="headerlink" title="小程序的执行环境"></a>小程序的执行环境</h3><ul><li>小程序目前可以运行在三大平台：</li><li>iOS平台，包括iOS9、iOS10、iOS11</li><li>Android平台</li><li>小程序IDE</li></ul><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>浏览器中，所有 JavaScript 是在运行在同一个作用域下的，定义的参数或者方法可以被后续加载的脚本访问或者改写。同浏览器不同，小程序中可以将任何一个JavaScript 文件作为一个模块，通过module.exports 或者 exports 对外暴露接口。</p><h3 id="脚本的执行顺序"><a href="#脚本的执行顺序" class="headerlink" title="脚本的执行顺序"></a>脚本的执行顺序</h3><p>浏览器中，脚本严格按照加载的顺序执行;而在小程序中的脚本执行顺序有所不同。小程序的执行的入口文件是 app.js 。并且会根据其中 require 的模块顺序决定文件的运行顺序.当 app.js 执行结束后，小程序会按照开发者在 app.json 中定义的 pages 的顺序，逐一执行</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>同浏览器中运行的脚本文件有所不同，小程序的脚本的作用域同 NodeJS 更为相似。在文件中声明的变量和函数只在该文件中有效，不同的文件中可以声明相同名字的变量和函数，不会互相影响</p><h3 id="小程序通信模型"><a href="#小程序通信模型" class="headerlink" title="小程序通信模型"></a>小程序通信模型</h3><p>小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了WebView 进行渲染；逻辑层采用JsCore线程运行JS脚本。一个小程序存在多个界面，所以渲染层存在多个WebView线程，这两个线程的通信会经由微信客户端（下文中也会采用Native来代指微信客户端）做中转，逻辑层发送网络请求也经由Native转发</p><h3 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h3><p>WXML可以先转成JS对象，然后再渲染出真正的Dom树</p><h3 id="双线程下的界面渲染"><a href="#双线程下的界面渲染" class="headerlink" title="双线程下的界面渲染"></a>双线程下的界面渲染</h3><p>小程序的逻辑层和渲染层是分开的两个线程。在渲染层，宿主环境会把WXML转化成对应的JS对象，在逻辑层发生数据变更的时候，我们需要通过宿主环境提供的setData方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的Dom树上，渲染出正确的UI界面</p><h3 id="所有页面的脚本逻辑都跑在同一个JsCore线程，页面使用setTimeout或者setInterval的定时器，然后跳转到其他页面时，这些定时器并没有被清除，需要开发者自己在页面离开的时候进行清理"><a href="#所有页面的脚本逻辑都跑在同一个JsCore线程，页面使用setTimeout或者setInterval的定时器，然后跳转到其他页面时，这些定时器并没有被清除，需要开发者自己在页面离开的时候进行清理" class="headerlink" title="所有页面的脚本逻辑都跑在同一个JsCore线程，页面使用setTimeout或者setInterval的定时器，然后跳转到其他页面时，这些定时器并没有被清除，需要开发者自己在页面离开的时候进行清理"></a>所有页面的脚本逻辑都跑在同一个JsCore线程，页面使用setTimeout或者setInterval的定时器，然后跳转到其他页面时，这些定时器并没有被清除，需要开发者自己在页面离开的时候进行清理</h3><h3 id="Page构造器的参数"><a href="#Page构造器的参数" class="headerlink" title="Page构造器的参数"></a>Page构造器的参数</h3><ul><li>data:   Object   页面的初始数据</li><li>onLoad: Function 生命周期函数–监听页面加载，触发时机早于onShow和onReady 在页面没被销毁前只会触发1次</li><li>onShow: Function 生命周期函数–监听页面显示，触发事件早于onReady 一般从别的页面返回到当前页面时，当前页的+ onShow方法都会被调用</li><li>onReady:Function 生命周期函数–监听页面初次渲染完成  在页面没被销毁前只会触发1次</li><li>onHide: Function 生命周期函数–监听页面隐藏</li><li>onUnload:Function 生命周期函数–监听页面卸载</li><li>onPullDownRefresh:Function 页面相关事件处理函数–监听用户下拉动作</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gulp-gulp基础使用</title>
      <link href="/ZJY.github.io/2021/01/19/gulp-gulp%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
      <url>/ZJY.github.io/2021/01/19/gulp-gulp%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>1.前置条件：测试node /npm /npx是否安装<br>2.安装gulp命令行工具</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --<span class="built_in">global</span> gulp-cli</span><br></pre></td></tr></table></figure><p>3.创建项目目录</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npx mkdirp my-project</span><br><span class="line">cd my-project</span><br></pre></td></tr></table></figure><p>4.在项目目录下创建package.json文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><p>5.安装gulp,作为开发时依赖项</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev gulp</span><br></pre></td></tr></table></figure><p>6.检查gulp版本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp --version</span><br></pre></td></tr></table></figure><p>7.创建gulpfile文件</p><p>8.测试</p><p>在项目根目录下执行 gulp 命令：gulp</p><p>9.创建任务（task）:</p><p>每个 gulp 任务（task）都是一个异步的 JavaScript 函数，此函数是一个可以接收 callback 作为参数的函数，或者是一个返回 stream、promise、event emitter、child process 或 observable (后面会详细讲解) 类型值的函数</p><p>10.导出任务：</p><p>任务可以是公开或私有的：<br>公开任务： 从gulpfile中被导出，可以通过gulp命令直接调用<br>私有任务：被设计在内部使用，通常作为series（）或parallel()组合的组成部分。<br>一个私有（private）类型的任务（task）在外观和行为上和其他任务（task）是一样的，但是不能够被用户直接调用。如需将一个任务（task）注册为公开（public）类型的，只需从 gulpfile 中导出（export）即可</p><p>11.组合任务</p><p>两个组合方法： series()和parallel(),允许多个独立的任务组合为一个更大的操作。这两个方法都可以接受任意数目的任务函数和已组合的操作。<br>series()和parallel()可以互相嵌套至任意深度。<br>如果需要让任务按顺序执行，请使用series()方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; series &#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transpile</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bundle</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exports</span>.build = series(transpile, bundle);</span><br></pre></td></tr></table></figure><p>对于希望以最大并发来允许的任务，可以使用parallel()方法将他们组合：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cosnt &#123; parallel &#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">javascript</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line">functin <span class="function"><span class="title">css</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exports</span>.build = parallel(javascript, css);</span><br></pre></td></tr></table></figure><p>当series()和parallel()被调用时，任务会被立即组合在一起，这就允许在组合中进行改变，而不需要在单个任务中进行条件判断：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; series &#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minify</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">overload</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transpile</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(process.env.NODE_ENV == <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">exports</span>.build = series(minify, overload);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">exports</span>.build = series(transpile,overload);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>series()和parallel()可以被嵌套任意深度：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; series, parallel &#125; = requier(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exports</span>.build = series(</span><br><span class="line">    a,</span><br><span class="line">    parallel(b</span><br><span class="line">    ,</span><br><span class="line">    series(c,d)</span><br><span class="line">    ),</span><br><span class="line">    e</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果在两个不同任务间调用同一个任务将被执行两次，并产生不可预期结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; series, parallel&#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> clean = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> javascript = series(clean,<span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> css = series(clean, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">exports</span>.build = parallel(javascript,css)</span><br></pre></td></tr></table></figure><p>重构为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; series, parallel &#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clean</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">css</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">javascript</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exports</span>.build = series(clean, parallel(css, javascript));</span><br></pre></td></tr></table></figure><p>12.异步执行：</p><p>异步执行方式：<br>1.返回stream</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; src, dest&#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">streanTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&quot;*.js&quot;</span>)</span><br><span class="line">    .pipe(dest(<span class="string">&#x27;output&#x27;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.返回promise:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseTask</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.返回event emitter</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; EventEmitter &#125; = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eventEmitterTask</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> emitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123; emitter.emit(<span class="string">&#x27;finish&#x27;</span>)&#125;,<span class="number">250</span>);</span><br><span class="line">    <span class="keyword">return</span> emitter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.返回 child process</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; exec &#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">childProcessTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exec(<span class="string">&#x27;date&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.返回observable</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Observale&#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observaleTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.使用callback<br>如果任务不返回任何内容，则必须用callback来指示任务已完成</p><p>7.使用async/await</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncAwaitTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; version &#125; = fs.readFileSync(<span class="string">&#x27;package.json&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(version);</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;some result&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>13.处理文件</p><p>gulp暴露了src()和dest()方法用于处理计算机上存放的文件<br>src()接受glob参数，并从文件系统中读取文件然后生成一个node流<br>dest()接收一个输入目录作为参数，并且会产生一个node流作为终止流，当他接受到管道pipe传输的文件时，他会将文件内容及属性写到目录中</p><p>14.glob</p><p> glob 是由普通字符和/或通配字符组成的字符串，用于匹配文件路径。可以利用一个或多个 glob 在文件系统中定位文件</p><p> src() 方法接受一个 glob 字符串或由多个 glob 字符串组成的数组作为参数，用于确定哪些文件需要被操作。glob 或 glob 数组必须至少匹配到一个匹配项，否则 src() 将报错</p><ul><li>分隔符： /</li><li>特殊符号： *<br>在一个字符串片段中匹配任意数量的字符，包括零个匹配。对于匹配单级目录下的文件很有用： ‘*.js’</li><li>特殊字符： ** (两个星号)<br>在多个字符串片段中匹配任意数量的字符，包括零个匹配。 对于匹配嵌套目录下的文件很有用 ‘scripts/*<em>/</em>.js’</li><li>特殊字符： ! (取反)<br>由于 glob 匹配时是按照每个 glob 在数组中的位置依次进行匹配操作的，所以 glob 数组中的取反（negative）glob 必须跟在一个非取反（non-negative）的 glob 后面<pre><code>  [&#39;script/**/*.js&#39;, &#39;!scripts/vendor/&#39;]</code></pre></li><li>匹配重叠：<br>两个或多个 glob 故意或无意匹配了相同的文件就被认为是匹配重叠（overlapping）了。如果在同一个 src() 中使用了会产生匹配重叠的 glob，gulp 将尽力去除重叠部分，但是在多个 src() 调用时产生的匹配重叠是不会被去重的</li></ul><p>15.使用插件</p><p>Gulp 插件实质上是 Node 转换流（Transform Streams），它封装了通过管道（pipeline）转换文件的常见功能，通常是使用 .pipe() 方法并放在 src() 和 dest() 之间。他们可以更改经过流（stream）的每个文件的文件名、元数据或文件内容</p><p>16.文件监控</p><p>ulp api 中的 watch() 方法利用文件系统的监控程序（file system watcher）将 globs 与 任务（task） 进行关联。它对匹配 glob 的文件进行监控，如果有文件被修改了就执行关联的任务（task）。如果被执行的任务（task）没有触发 异步完成 信号，它将永远不会再次运行了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">css</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line">watch(<span class="string">&#x27;src/*.css&#x27;</span>,css);</span><br></pre></td></tr></table></figure><p>与文件监控程序关联的任务不能时同步任务<br>默认情况下，只要创建、更改或删除文件，文件监控程序就会执行关联的任务（task）。 如果你需要使用不同的事件，你可以在调用 watch() 方法时通过 events 参数进行指定。可用的事件有 ‘add’、’addDir’、’change’、’unlink’、’unlinkDir’、’ready’、’error’。此外，还有一个 ‘all’ 事件，它表示除 ‘ready’ 和 ‘error’ 之外的所有事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; watch &#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有事件都将被监控</span></span><br><span class="line">watch(<span class="string">&#x27;src/*.js&#x27;</span>, &#123; <span class="attr">events</span>: <span class="string">&#x27;all&#x27;</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>初次执行：<br>调用watch之后，关联的任务是不会被立即执行，要等到第一次文件修改之后才执行<br>如果需要在第一次文件修改之前执行，也就是调用watch之后立即执行，设置参数： ignoreInitial: false</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch(<span class="string">&#x27;src/*.js&#x27;</span>, &#123; <span class="attr">ignoreInitial</span>: <span class="literal">false</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>队列： queue: false//禁止队列<br>延迟： delay: Nubmer //文件更改之后延迟多久被执行</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> gulp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6-模块化</title>
      <link href="/ZJY.github.io/2021/01/19/es6-%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>/ZJY.github.io/2021/01/19/es6-%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="es5中，用module-exports-和-exports导出模块，用require引入模块"><a href="#es5中，用module-exports-和-exports导出模块，用require引入模块" class="headerlink" title="es5中，用module.exports 和 exports导出模块，用require引入模块"></a>es5中，用module.exports 和 exports导出模块，用require引入模块</h3><h3 id="es6中，新增export-和-export-default-导出模块，import引入模块"><a href="#es6中，新增export-和-export-default-导出模块，import引入模块" class="headerlink" title="es6中，新增export 和 export default 导出模块，import引入模块"></a>es6中，新增export 和 export default 导出模块，import引入模块</h3><ol><li>module.exports 和 exports 的区别：</li></ol><p>module.exports 和 exports 导出的对象，可以在另一个文件中通过require引用</p><p>module 和 exports 是node.js给每个js文件内置的两个对象，初始值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">exports</span>):  &#123;&#125;  空对象</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>): &#123;..., <span class="attr">exports</span>: &#123;&#125; &#125;  ...代表其他属性如：id,filename...</span><br></pre></td></tr></table></figure><p>一开始这两个对象都是空对象{}，实际上这两个对象指向同一块内存<br>exports.age = 18 和 module.exports.age = 18 两者是等价的</p><p>但是require引入的本质是module.exports，所有当module.exports 和exports<br>指向的不是同一块内存时，exports的内容就会失效：例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a.js:</span><br><span class="line"><span class="built_in">exports</span> = &#123;<span class="attr">name</span>:<span class="string">&#x27;lily&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;<span class="attr">name</span>:<span class="string">&#x27;lucy&#x27;</span> &#125;</span><br><span class="line">b.js:</span><br><span class="line"><span class="keyword">let</span> test = <span class="built_in">require</span>(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">consle.log(test)  <span class="comment">// &#123;name:&#x27;lucy&#x27;&#125;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>export default 和 export 的区别：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> People = &#123; <span class="attr">name</span>: <span class="string">&#x27;lucy&#x27;</span> ,<span class="attr">age</span>: <span class="number">18</span> &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> = People</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>):</span><br><span class="line">&#123;<span class="attr">exports</span>:&#123;<span class="attr">default</span>:&#123;<span class="attr">name</span>:<span class="string">&#x27;lucy&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;&#125;&#125;</span><br><span class="line"><span class="keyword">import</span> Peole <span class="keyword">from</span> <span class="string">&#x27;.a&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">name</span>:<span class="string">&#x27;aaa&#x27;</span>,age,<span class="number">12</span>&#125;</span><br><span class="line"><span class="keyword">const</span> b = &#123; <span class="attr">name</span>:<span class="string">&#x27;bbb&#x27;</span>, <span class="attr">age</span>:<span class="number">23</span>&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; a, b&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>):</span><br><span class="line">&#123;<span class="attr">exports</span>: &#123;<span class="attr">a</span>:&#123;<span class="attr">name</span>:<span class="string">&#x27;aaa&#x27;</span>,<span class="attr">age</span>:<span class="number">12</span>&#125;,<span class="attr">b</span>:&#123;<span class="attr">name</span>:<span class="string">&#x27;bbb&#x27;</span>,<span class="attr">age</span>:<span class="number">23</span>&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>导入： import {a,b} from ‘./a’</p><p>导出时， export 相当于将对象添加到module 的 exports中，<br>export default 相当于将对象添加到module 的 exports ，对象key 为default</p><p>导入时：<br>不带{}的导入，本质上就是导入exports的default属性，若default属性不存在，<br>则导入exports对象<br>带{}的导入，按key值导入exports中对应的属性值</p><p>一般来说，module.exports和exports与require对应。也就是用module.exports和exports<br>导出的模块，则用require导入。（不是绝对，如果代码支持es6，也可以用import引入）。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dart-dart基础</title>
      <link href="/ZJY.github.io/2021/01/19/dart-dart%E5%9F%BA%E7%A1%80/"/>
      <url>/ZJY.github.io/2021/01/19/dart-dart%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="1-安装dart-sdk"><a href="#1-安装dart-sdk" class="headerlink" title="1.安装dart sdk"></a>1.安装dart sdk</h3><p><a href="https://dart.dev/get-dart">https://dart.dev/get-dart</a><br>终端输入dart –version 测试是否安装成功</p><h3 id="2-配置vscode支持dart语法提示："><a href="#2-配置vscode支持dart语法提示：" class="headerlink" title="2.配置vscode支持dart语法提示："></a>2.配置vscode支持dart语法提示：</h3><p>1.安装插件dart<br>2.安装插件code runner  可以运行文件</p><h3 id="3-vscode运行dart文件中文乱码："><a href="#3-vscode运行dart文件中文乱码：" class="headerlink" title="3.vscode运行dart文件中文乱码："></a>3.vscode运行dart文件中文乱码：</h3><p>1.在settings.json添加：”code-runner.runInTerminal”: true,<br>2.重启vscode</p><h3 id="4-入口方法"><a href="#4-入口方法" class="headerlink" title="4.入口方法"></a>4.入口方法</h3><p>main(){};<br>void main(){};//没有返回值</p><h3 id="5-注释"><a href="#5-注释" class="headerlink" title="5.注释"></a>5.注释</h3><p>//注释<br>///注释<br>/<em>注释</em>/</p><h3 id="6-声明变量："><a href="#6-声明变量：" class="headerlink" title="6.声明变量："></a>6.声明变量：</h3><p>1.通过var声明： var str = “aaa”; //dart强类型校验，可以不预先声明变量类型，自行判断类型<br>2.通过类型声明  String str = “aaa”</p><p>变量命名规则：<br>        1.必须由数字/字母/下划线和$组成<br>        2.不能以数字开头<br>        3.不能是保留字和关键字<br>        4.区分大小写</p><h3 id="7-常量：-const-和-final"><a href="#7-常量：-const-和-final" class="headerlink" title="7.常量： const 和 final"></a>7.常量： const 和 final</h3><p>1.const 和finnal 赋值都不可以修改<br>2.区别： final可以开始不赋值，只能赋值一次，final不仅有const的编译时常量的特性，最重要的是它是编译时赋值<br>        例如：<br>        final date = new DateTime.now(); //正常 编译时赋值，只能赋值一次<br>        const date = new DateTime.now(); //报错 定义时赋值</p><h3 id="8-dart-数据类型："><a href="#8-dart-数据类型：" class="headerlink" title="8.dart 数据类型："></a>8.dart 数据类型：</h3><p>常用数据类型：</p><pre><code>    Numbers(数值)：int double    Strings(字符串)： String    Booleans(布尔值): bool    List(数组): 列表对象    Maps(字典)： Map是一个键值对相关的对象</code></pre><p>1.字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> str = <span class="string">&quot;falds&quot;</span></span><br><span class="line"><span class="built_in">String</span> str = <span class="string">&quot;&quot;</span><span class="string">&quot;flasjd</span></span><br><span class="line"><span class="string">flad</span></span><br><span class="line"><span class="string">d;fja&quot;</span><span class="string">&quot;&quot;</span> <span class="comment">//三个单引号或者三个双引号字符串可换行</span></span><br><span class="line"><span class="comment">// &lt;!-- 字符串拼接： --&gt;</span></span><br><span class="line">    print(<span class="string">&quot;$str $str&quot;</span>);</span><br><span class="line">    print(str +<span class="string">&quot; &quot;</span>+ str);</span><br></pre></td></tr></table></figure><p>2.数值类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = <span class="number">12</span>; <span class="comment">//只可以是整型</span></span><br><span class="line">double = <span class="number">12.23</span>  <span class="comment">//既可以是整型也可以是浮点型</span></span><br></pre></td></tr></table></figure><p>3.布尔类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool flag = <span class="literal">true</span>/<span class="literal">false</span> ; <span class="comment">//布尔类型的值只能是true/false</span></span><br><span class="line">条件判断不会对变量进行类型转换： <span class="number">123</span> != <span class="string">&#x27;123&#x27;</span></span><br></pre></td></tr></table></figure><p>4.数组类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> List();</span><br><span class="line">arr2.add(<span class="string">&quot;a&quot;</span>)</span><br></pre></td></tr></table></figure><p>3.指定数组元素类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr3 = <span class="keyword">new</span> List&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">arr3.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">arr3.add(<span class="number">1</span>); <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><p>5.Maps</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:<span class="string">&quot;test&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问： person[“name”]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">p[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;test&quot;</span></span><br></pre></td></tr></table></figure><p>6.is关键词判断数据类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;ad&#x27;</span>;</span><br><span class="line">print(str is <span class="built_in">String</span>)</span><br></pre></td></tr></table></figure><h3 id="9-运算符"><a href="#9-运算符" class="headerlink" title="9.运算符"></a>9.运算符</h3><ul><li><p>算术运算符</p><ol><li>+</li><li>-</li><li>*</li><li>/</li><li>% 取余</li><li>~/ 取整</li></ol></li><li><p>关系运算符：</p><ol><li>==</li><li>!=</li><li>&lt;</li><li><code>&gt;</code></li><li>&lt;=</li><li><code> &gt;=</code></li></ol></li><li><p>逻辑运算符：<br>  !<br>  &amp;&amp;<br>  ||</p></li><li><p>赋值运算符：<br>  <code>=</code><br>  <code>??=</code>  // int b; b??=23 如果b等于空的话，把23赋值给b</p></li><li><p>复合赋值运算符：<br>  +=<br>  -=<br>  *-<br>  /=<br>  ~/=</p></li><li><p>条件表达式：<br>  if… else<br>  if… else if<br>  swtich… case</p><p>  三目运算符 ? :<br>  ??运算符 b= a ?? 10 //a不为空时b等于a，a为空时b等于10</p><p>  b=a++ 赋值运算中： ++写在后面 先赋值后运算 ++a 写在前面先运算后赋值</p></li></ul><h3 id="10-类型转换："><a href="#10-类型转换：" class="headerlink" title="10.类型转换："></a>10.类型转换：</h3><ul><li>int.parse</li><li>double.parge</li><li>toString</li><li>str.isEmpty</li><li>num.isNaN</li></ul><h3 id="11-List属性："><a href="#11-List属性：" class="headerlink" title="11.List属性："></a>11.List属性：</h3><ul><li>length</li><li>isEmpty</li><li>isNotEmpty</li><li>reversed 翻转列表 [1,2,3].reversed //(3,2,1) [1,2,3].reversed.toList() //[3,2,1]</li></ul><h3 id="12-List方法："><a href="#12-List方法：" class="headerlink" title="12.List方法："></a>12.List方法：</h3><ul><li>add 数组添加 add(1)</li><li>addAll([1,2]) //拼接数组</li><li>indexOf 返回索引值</li><li>remove 移除值，参数为值</li><li>removeAt 参数为索引值</li><li>fillRange int start,int end,修改后的值</li><li>insert(int index,value)指定位置插入值</li><li>insertAll(index,interable)  insertAll(1,[1,2]) </li><li>join(分割符) 以分隔符拼接转换成字符串</li><li>split(分隔符) 将string以分隔符切割成数组</li><li>toList() 将其他类型对象转换为数组</li></ul><h3 id="13-Set主要功能是数组去重"><a href="#13-Set主要功能是数组去重" class="headerlink" title="13.Set主要功能是数组去重"></a>13.Set主要功能是数组去重</h3><p>set是不能重复且没有顺序的对象</p><h3 id="14-Maps-映射"><a href="#14-Maps-映射" class="headerlink" title="14.Maps 映射"></a>14.Maps 映射</h3><ul><li>key   var person={“a”:1,”b”:2} person.keys.toList()</li><li>value</li><li>isEmpty</li><li>isNotEmpty</li><li>addAll() 添加多个</li><li>remove(key)</li><li>containsValue(value) 是否存在某个值</li></ul><h3 id="15-循环："><a href="#15-循环：" class="headerlink" title="15.循环："></a>15.循环：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">forEach</span><br><span class="line">map  用于修改数据 <span class="keyword">var</span> newList = list.map((value)&#123; <span class="keyword">return</span> value*<span class="number">2</span>&#125;)</span><br><span class="line">where  <span class="keyword">var</span> newList = list.where((value)&#123; <span class="keyword">return</span> value &gt; <span class="number">5</span>&#125;) 返回符合条件的数组</span><br><span class="line">any  <span class="keyword">var</span> newList = list.any((value)&#123; <span class="keyword">return</span> value &gt; <span class="number">5</span>&#125;) 有一个满足条件返回<span class="literal">true</span></span><br><span class="line">some ar newList = list.some((value)&#123; <span class="keyword">return</span> value &gt; <span class="number">5</span>&#125;) 满足所有条件返回<span class="literal">true</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> dart </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css-grid布局</title>
      <link href="/ZJY.github.io/2021/01/19/css-grid%E5%B8%83%E5%B1%80/"/>
      <url>/ZJY.github.io/2021/01/19/css-grid%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<p>Flex是轴线布局，只能指定“项目” 针对轴线的位置，可以看作是一维布局。</p><p>Grid布局则是将容器分成行和列，产生单元格，然后指定项目所在单元格，可以看作是二维布局</p><h3 id="1-容器和项目："><a href="#1-容器和项目：" class="headerlink" title="1.容器和项目："></a>1.容器和项目：</h3><p>采用网格布局的区域，称为“容器” container， 容器内采用网格定位的子元素，称为“项目” item</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最外层的div元素就是容器， 内层的三个div 是项目<br>注意： 项目只能是容器的顶层子元素，不包含项目的子元素，grid布局只对项目生效</p><h3 id="2-行和列"><a href="#2-行和列" class="headerlink" title="2.行和列"></a>2.行和列</h3><p>容器里水平区域称为”行”row,垂直区域称为“列”column</p><h3 id="3-单元格"><a href="#3-单元格" class="headerlink" title="3.单元格"></a>3.单元格</h3><p>行和列的交叉区域，称为“单元格”cell<br>正常情况下，N行M列，会产生N*M个单元格</p><h3 id="4-网格线"><a href="#4-网格线" class="headerlink" title="4.网格线"></a>4.网格线</h3><p>划分网格的线，称为”网格线”（grid line）。水平网格线划分出行，垂直网格线划分出列<br>正常情况下，n行有n + 1根水平网格线，m列有m + 1根垂直网格线</p><p>Grid 布局的属性分成两类。一类定义在容器上面，称为容器属性；另一类定义在项目上面，称为项目属性。这部分先介绍容器属性</p><h3 id="5-容器属性"><a href="#5-容器属性" class="headerlink" title="5.容器属性"></a>5.容器属性</h3><h4 id="5-1-display属性"><a href="#5-1-display属性" class="headerlink" title="5.1 display属性"></a>5.1 display属性</h4><p>display: grid指定一个容器采用网格布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，容器元素都是块级元素，但也可以设成行内元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。</p><h4 id="5-2-grid-template-rows属性和grid-template-columns属性"><a href="#5-2-grid-template-rows属性和grid-template-columns属性" class="headerlink" title="5.2 grid-template-rows属性和grid-template-columns属性"></a>5.2 grid-template-rows属性和grid-template-columns属性</h4><p>容器指定了网格布局以后，接着就要划分行和列。grid-template-columns属性定义每一列的列宽，grid-template-rows属性定义每一行的行高。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了使用绝对单位,还可使用百分比：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: 33.33% 33.33% 33.33%;</span><br><span class="line"><span class="selector-tag">grid-template-rows</span>: 33.33% 33.33% 33.33%;</span><br></pre></td></tr></table></figure><p>1.repeat() 接受两个参数，第一个参数是重复的次数,第二个参数是所要重复的值:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: <span class="selector-tag">repeat</span>(3, 33.33%)</span><br></pre></td></tr></table></figure><p>重复某种模式：定义了6列，第一列和第四列的宽度为100px，第二列和第五列为20px，第三列和第六列为80px</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: <span class="selector-tag">repeat</span>(2, 100<span class="selector-tag">px</span> 20<span class="selector-tag">px</span> 80<span class="selector-tag">px</span>)</span><br></pre></td></tr></table></figure><p>2.auto-fill关键字<br>    有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用auto-fill关键字表示自动填充</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: <span class="selector-tag">repeat</span>(<span class="selector-tag">auto-fill</span>, 100<span class="selector-tag">px</span>)</span><br></pre></td></tr></table></figure><p>表示每列宽度100px，然后自动填充，直到容器不能放置更多的列</p><p>3.fr关键字</p><p>为了方便表示比例关系，网格布局提供了fr关键字（fraction 的缩写，意为”片段”）。如果两列的宽度分别为1fr和2fr，就表示后者是前者的两倍</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: 1<span class="selector-tag">fr</span> 1<span class="selector-tag">fr</span></span><br></pre></td></tr></table></figure><p>表示两个相同宽度的列。<br>fr可以与绝对长度的单位结合使用，这时会非常方便</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: 150<span class="selector-tag">px</span> 1<span class="selector-tag">fr</span> 2<span class="selector-tag">fr</span></span><br></pre></td></tr></table></figure><p>表示第一列宽度未150像素，第二列宽度是第三列的一半</p><p>4.minmax()函数产生一个长度范围，表示长度就在这个范围内，接收两个参数，分别为最小值和最大值</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: 1<span class="selector-tag">fr</span> 1<span class="selector-tag">fr</span> <span class="selector-tag">minmax</span>(100<span class="selector-tag">px</span>, 1<span class="selector-tag">fr</span>);</span><br></pre></td></tr></table></figure><p>5.auto关键字表示由浏览器自己决定长度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: 100<span class="selector-tag">px</span> <span class="selector-tag">auto</span> 100<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure><p>第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了min-width，且这个值大于最大宽度</p><p>6.网格线的名称</p><p>grid-template-columns属性和grid-template-rows属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: <span class="selector-attr">[c1]</span> 100<span class="selector-tag">px</span> <span class="selector-attr">[c2]</span> 100<span class="selector-tag">px</span> <span class="selector-attr">[c3]</span> <span class="selector-tag">auto</span> <span class="selector-attr">[c4]</span>;</span><br><span class="line"><span class="selector-tag">grid-template-rows</span>: <span class="selector-attr">[r1]</span> 100<span class="selector-tag">px</span> <span class="selector-attr">[r2]</span> 100<span class="selector-tag">px</span> <span class="selector-attr">[r3]</span> <span class="selector-tag">auto</span> <span class="selector-attr">[r4]</span></span><br></pre></td></tr></table></figure><p>7.布局实例</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: 70% 30%;</span><br></pre></td></tr></table></figure><p>上面代码将左边栏设为70%，右边栏设为30%。<br>传统的十二网格布局，写起来也很容易。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: <span class="selector-tag">repeat</span>(12, 1<span class="selector-tag">fr</span>);</span><br></pre></td></tr></table></figure><h4 id="5-3-grid-row-gap属性-grid-column-gap属性-grid-gap属性"><a href="#5-3-grid-row-gap属性-grid-column-gap属性-grid-gap属性" class="headerlink" title="5.3 grid-row-gap属性 grid-column-gap属性 grid-gap属性"></a>5.3 grid-row-gap属性 grid-column-gap属性 grid-gap属性</h4><p>grid-row-gap属性设置行与行的间隔（行间距），grid-column-gap属性设置列与列的间隔（列间距）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-row-gap</span>: 20<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">grid-column-gap</span>: 20<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">grid-gap</span>: &lt;<span class="selector-tag">grid-row-gap</span>&gt; &lt;<span class="selector-tag">grid-column-gap</span>&gt;</span><br><span class="line"><span class="selector-tag">grid-gap</span><span class="selector-pseudo">:20px</span>; <span class="comment">/* 如果省略了第二个值，则默认第二个值等于第一个值 */</span></span><br></pre></td></tr></table></figure><p>注： 根据最新标准，上面三个属性名的grid-前缀已经删除，grid-column-gap和grid-row-gap写成column-gap和row-gap，grid-gap写成gap。</p><h3 id="5-4-grid-template-areas属性"><a href="#5-4-grid-template-areas属性" class="headerlink" title="5.4 grid-template-areas属性"></a>5.4 grid-template-areas属性</h3><p>网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。grid-template-areas属性用于定义区域。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grid-template-areas: &#x27;a b c&#x27;</span><br><span class="line">                   &#x27;d e f&#x27;</span><br><span class="line">                   &#x27;g h i&#x27;;</span><br></pre></td></tr></table></figure><p>上面代码先划分出9个单元格，然后将其定名为a到i的九个区域，分别对应这九个单元格。<br>多个单元格合并成一个区域的写法如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grid-template-areas: &#x27;a a a&#x27;</span><br><span class="line">                 &#x27;b b b&#x27;</span><br><span class="line">                 &#x27;c c c&#x27;;</span><br></pre></td></tr></table></figure><p>上面代码将9个单元格分成a、b、c三个区域。<br>如果某些区域不需要利用，则使用”点”（.）表示</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grid-template-areas: &#x27;a . c&#x27;</span><br><span class="line">                 &#x27;d . f&#x27;</span><br><span class="line">                 &#x27;g . i&#x27;;</span><br></pre></td></tr></table></figure><p>注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end。</p><h3 id="5-5-grid-auto-flow属性"><a href="#5-5-grid-auto-flow属性" class="headerlink" title="5.5 grid-auto-flow属性"></a>5.5 grid-auto-flow属性</h3><p>划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行，即下图数字的顺序。<br>这个顺序由grid-auto-flow属性决定，默认值是row，即”先行后列”。也可以将它设成column，变成”先列后行”。<br>grid-auto-flow: row/row dense/column/column dense</p><h3 id="5-6-justify-items属性-align-items属性-place-items属性"><a href="#5-6-justify-items属性-align-items属性-place-items属性" class="headerlink" title="5.6 justify-items属性 align-items属性 place-items属性"></a>5.6 justify-items属性 align-items属性 place-items属性</h3><p>justify-items属性设置单元格内容的水平位置（左中右），align-items属性设置单元格内容的垂直位置（上中下）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">justify-items: start | end | center | stretch;</span><br><span class="line">align-items: start | end | center | stretch;</span><br><span class="line">    <span class="selector-tag">start</span>：对齐单元格的起始边缘。</span><br><span class="line">    <span class="selector-tag">end</span>：对齐单元格的结束边缘。</span><br><span class="line">    <span class="selector-tag">center</span>：单元格内部居中。</span><br><span class="line">    <span class="selector-tag">stretch</span>：拉伸，占满单元格的整个宽度（默认值）。</span><br><span class="line"><span class="selector-tag">place-items</span>属性是<span class="selector-tag">align-items</span>属性和<span class="selector-tag">justify-items</span>属性的合并简写形式。</span><br></pre></td></tr></table></figure><h4 id="5-7-justify-content属性-align-content-属性-place-content-属性"><a href="#5-7-justify-content属性-align-content-属性-place-content-属性" class="headerlink" title="5.7 justify-content属性 align-content 属性 place-content 属性"></a>5.7 justify-content属性 align-content 属性 place-content 属性</h4><p>justify-content属性是整个内容区域在容器里面的水平位置（左中右），align-content属性是整个内容区域的垂直位置（上中下）。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">justify-content: start | end | center | stretch | space-around | space-between | space-evenly;</span><br><span class="line">align-content: start | end | center | stretch | space-around | space-between | space-evenly; </span><br></pre></td></tr></table></figure><h3 id="5-8-grid-auto-rows-属性和-grid-auto-columns属性"><a href="#5-8-grid-auto-rows-属性和-grid-auto-columns属性" class="headerlink" title="5.8 grid-auto-rows 属性和 grid-auto-columns属性"></a>5.8 grid-auto-rows 属性和 grid-auto-columns属性</h3><p>有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目<br>grid-auto-columns属性和grid-auto-rows属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与grid-template-columns和grid-template-rows<br>完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-auto-rows</span>: 50<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-class">.item8</span>&#123;</span><br><span class="line">    <span class="attribute">grid-row-start</span>: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定第8个项目位于第四行行高50像素</p><h3 id="6-项目属性"><a href="#6-项目属性" class="headerlink" title="6.项目属性"></a>6.项目属性</h3><h4 id="6-1-grid-column-start-grid-column-end-grid-row-start-grid-row-end"><a href="#6-1-grid-column-start-grid-column-end-grid-row-start-grid-row-end" class="headerlink" title="6.1 grid-column-start grid-column-end grid-row-start grid-row-end"></a>6.1 grid-column-start grid-column-end grid-row-start grid-row-end</h4><p>项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。</p><pre><code>grid-column-start属性：左边框所在的垂直网格线grid-column-end属性：右边框所在的垂直网格线grid-row-start属性：上边框所在的水平网格线grid-row-end属性：下边框所在的水平网格线</code></pre><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">    <span class="attribute">grid-column-start</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">grid-column-end</span>: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线。<br>这四个属性的值，除了指定为第几个网格线，还可以指定为网格线的名字。<br>这四个属性的值还可以使用span关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-column-start</span>: <span class="selector-tag">span</span> 2;</span><br></pre></td></tr></table></figure><h4 id="6-2-grid-column-属性-grid-row-属性"><a href="#6-2-grid-column-属性-grid-row-属性" class="headerlink" title="6.2 grid-column 属性 grid-row 属性"></a>6.2 grid-column 属性 grid-row 属性</h4><p>grid-column属性是grid-column-start和grid-column-end的合并简写形式，grid-row属性是grid-row-start属性和grid-row-end的合并简写形式。</p><pre><code>grid-column: 1/3grid-column 1/span 2占据两列</code></pre><h4 id="6-3-grid-area"><a href="#6-3-grid-area" class="headerlink" title="6.3 grid-area"></a>6.3 grid-area</h4><p>grid-area属性指定项目放在哪一个区域</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">grid-template-areas</span>: <span class="string">&#x27;a b c&#x27;</span></span><br><span class="line">                            <span class="string">&#x27;d e f&#x27;</span></span><br><span class="line">                            <span class="string">&#x27;g h i&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item1</span>&#123;</span><br><span class="line">    <span class="attribute">grid-area </span>:e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-4-justify-self-属性，align-self-属性，place-self-属性"><a href="#6-4-justify-self-属性，align-self-属性，place-self-属性" class="headerlink" title="6.4 justify-self 属性，align-self 属性，place-self 属性"></a>6.4 justify-self 属性，align-self 属性，place-self 属性</h4><p>justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。<br>align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css-flex布局</title>
      <link href="/ZJY.github.io/2021/01/19/css-flex%E5%B8%83%E5%B1%80/"/>
      <url>/ZJY.github.io/2021/01/19/css-flex%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="flexbox-布局"><a href="#flexbox-布局" class="headerlink" title="flexbox 布局"></a>flexbox 布局</h3><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p><p>任何一个容器都可以指定为 Flex 布局</p><p>flex:包含两部分：flex-container容器 和 flex-item</p><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。</p><p>主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p><h3 id="container属性"><a href="#container属性" class="headerlink" title="container属性:"></a>container属性:</h3><pre><code>flex-directionflex-wrapflex-flowjustify-contentalign-itemsalign-content</code></pre><p>1.display属性：</p><pre><code>flexinline-flex 行内容器-webkit-flex Webkit 内核的浏览器，必须加上-webkit前缀。</code></pre><p>注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效</p><p>2.flex-direction:</p><pre><code>row 水平方向从左向右column 垂直方向 从上往下row-reverse 水平方向从右向左column-reverse 垂直方向 从下向上</code></pre><p>3.flex-wrap: 默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行</p><pre><code>nowrap 不换行 默认值wrap 换行,第一行在上方。wrap-reverse 换行，第一行在下方。</code></pre><p>4.flex-flow: flex-direction 和 flex-wrap 结合</p><pre><code>row nowrap 两个参数对应</code></pre><p>5.justify-content： 定义了项目在主轴上的对齐方式</p><pre><code>centerspace-betweenspace-aroundspace-evenlyflex-startflex-end</code></pre><!-- ![avatar](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png) --><p>6.align-item：属性定义项目在交叉轴上如何对齐</p><pre><code>stretch 拉伸 如果项目未设置高度或设为auto，将占满整个容器的高度。flex-start 交叉轴的起点对齐。flex-end 交叉轴的终点对齐。center 交叉轴的中点对齐baseline 项目的第一行文字的基线对齐</code></pre><p>7.align-content: 多行显示设置垂直对齐方式 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用</p><pre><code>stretchflex-startflex-endcenterspace-between 行与行之间添加间隔space-around 行周围间隔</code></pre><h3 id="item属性："><a href="#item属性：" class="headerlink" title="item属性："></a>item属性：</h3><p>1.order: 控制item在容器里的位置 给item设置</p><pre><code>默认为0值越大排越后</code></pre><p>2.flex-grow： 控制item的宽度 值越大，宽度越宽,定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p><pre><code>flex-grow: 1; </code></pre><p>3.flex-basies: 设置item的宽度,定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p><pre><code>flex-basies: 100pxauto 默认值</code></pre><p>4.flex-shrink: 设置item缩小的比例,默认为1，即如果空间不足，该项目将缩小</p><pre><code>flex-shrink: 0; 设置不缩小设置比1大的数可设置缩小比例更大些如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小</code></pre><p>5.flex: 0 1 auto;分别对应 flex-grow flex-shrink flex-basies</p><p>6.align-self: 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p><pre><code>align-self: auto/flex-start/flex-end/center/stretch/baseline </code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css-css3选择器</title>
      <link href="/ZJY.github.io/2021/01/19/css-css3%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>/ZJY.github.io/2021/01/19/css-css3%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="类型选择器：-标签名进行选择"><a href="#类型选择器：-标签名进行选择" class="headerlink" title="类型选择器： 标签名进行选择"></a>类型选择器： 标签名进行选择</h3><ul><li>h1{}</li><li>h1,h2{} 选择器群组</li></ul><h3 id="通用选择器："><a href="#通用选择器：" class="headerlink" title="通用选择器： *"></a>通用选择器： *</h3><h3 id="类选择器："><a href="#类选择器：" class="headerlink" title="类选择器："></a>类选择器：</h3><ul><li>.content{}</li></ul><h3 id="ID选择器"><a href="#ID选择器" class="headerlink" title="ID选择器"></a>ID选择器</h3><ul><li>#title{}</li></ul><h3 id="属性选择器："><a href="#属性选择器：" class="headerlink" title="属性选择器："></a>属性选择器：</h3><ul><li>[attribute]</li><li>[attribute1][attribute2]</li><li>[attribute = value]</li><li>[attribute ~= value] 选择器用于选取属性值中包含指定词汇的元素 [title ~= ‘flower’]</li><li>[attribute |= value] 选择器用于选取带有以指定值开头的属性值的元素 [leng | en]</li><li>[attribute ^= value] 以value开头的值 [class ^=”test”]</li><li>[attribute $= value] 以value结尾的值</li><li>[attribute *= value] 选择器匹配属性值包含指定值的每个元素</li></ul><h3 id="伪类："><a href="#伪类：" class="headerlink" title="伪类："></a>伪类：</h3><ul><li><p>a:link a:visited a:hover a:active :focus </p></li><li><p>:target 选择器可用于选取当前活动的目标元素</p></li><li><p>:disabled 用于添加禁用样式</p></li><li><p>:nth-child(n) 选择器匹配属于其父元素的第 N 个子元素，不论元素的类</p></li><li><p>:nth-last-child() 同上，从最后一个子元素开始计数</p></li><li><p>:first-child  p:first-child 选择属于父元素的第一个子元素的每个<code>&lt;p&gt;</code>元素</p></li><li><p>:last-child  p:last-child    选择属于其父元素最后一个子元素每个<code>&lt;p&gt;</code>元素。</p></li><li><p>:nth-of-type() p:nth-of-type(2) 选择属于其父元素第二个<code>&lt;p&gt;</code>元素的每个<code>&lt;p&gt;</code>元素</p></li><li><p>:nth-last-of-type() 同上，但是从最后一个子元素开始计数</p></li><li><p>:first-of-type  p:first-of-type    选择属于其父元素的首个<code>&lt;p&gt;</code>元素的每个<code>&lt;p&gt;</code>元素</p></li><li><p>:last-of-type  p:last-of-type    选择属于其父元素的最后<code>&lt;p&gt;</code>元素的每个<code>&lt;p&gt;</code>元素</p></li><li></li><li><p>:only-child  p:only-child    选择属于其父元素的唯一子元素的每个<code>&lt;p&gt;</code>元素。</p></li><li><p>:only-of-type  p:only-of-type    选择属于其父元素唯一的<code>&lt;p&gt;</code>元素的每个<code>&lt;p&gt;</code>元素</p></li><li><p>:empty p:empty    选择没有子元素的每个<code>&lt;p&gt;</code>元素（包括文本节点）</p></li><li><p>:not :not(p)    选择非<code>&lt;p&gt;</code>元素的每个元素。</p></li></ul><h3 id="伪元素选择器："><a href="#伪元素选择器：" class="headerlink" title="伪元素选择器："></a>伪元素选择器：</h3><ul><li><p>::first-line p::first-line    选择每个<code>&lt;p&gt;</code>元素的首行。</p></li><li><p>::first-letter    p::first-letter    选择每个<code>&lt;p&gt;</code>元素的首字母。</p></li><li><p>::before    p::before    在每个<code>&lt;p&gt;</code>元素的内容之前插入内容。</p></li><li><p>::after    p::after    在每个<code>&lt;p&gt;</code>元素的内容之后插入内容。</p></li></ul><h3 id="组合选择器："><a href="#组合选择器：" class="headerlink" title="组合选择器："></a>组合选择器：</h3><ul><li>div img  以空格隔开 后裔选择器</li></ul><h3 id="儿子选择器："><a href="#儿子选择器：" class="headerlink" title="儿子选择器："></a>儿子选择器：</h3><ul><li>div &gt; img</li></ul><h3 id="兄弟选择器："><a href="#兄弟选择器：" class="headerlink" title="兄弟选择器："></a>兄弟选择器：</h3><ul><li>div + img</li><li>h2 ~ h3 h2 后面的h3 元素</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css-BFC块级格式化上下文</title>
      <link href="/ZJY.github.io/2021/01/14/css-BFC/"/>
      <url>/ZJY.github.io/2021/01/14/css-BFC/</url>
      
        <content type="html"><![CDATA[<h3 id="BOX：-css布局的基本单位-amp-盒模型"><a href="#BOX：-css布局的基本单位-amp-盒模型" class="headerlink" title="BOX： css布局的基本单位&amp;盒模型"></a>BOX： css布局的基本单位&amp;盒模型</h3><ul><li><p>盒模型–块级盒/行内盒<br>一个盒包含：内容（content）/边（border）/内边距（padding）/外边距（margin）<br>盒的尺寸（width和height–计算得到offsetWidth和offsetHeight）定义受到box-sizing属性的影响<br>w3c标准盒模型-块级盒-border-box：width = content + padding + margin<br>IE盒子模型-块级盒-content-box：width = content</p></li><li><p>行内盒：</p><ul><li>width/height 不起作用，盒子高度由内容决定（font-size/line-height）</li><li>margin-top/margin-bottom padding-top/padding-bottom不起作用</li></ul></li></ul><p>tips：</p><ul><li>两类块级盒子可用过设置box-sizing转换</li><li>行内盒与块级盒转换可通过设置display属性来修改</li><li>行内盒参与IFC布局，块级盒参与BFC布局，如果块级盒包含行内盒，但是由于BFC内只有块级盒参与，因此行内盒会被匿名块级盒包含</li></ul><h3 id="BOX"><a href="#BOX" class="headerlink" title="BOX"></a>BOX</h3><p>Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。<br>不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染</p><ul><li>block-level：box的display 属性为block, list-item, table 的元素，会生成 block-level box。并且参与（BFC）block fomatting context；</li><li>inline-level：box的display 属性为inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context；</li></ul><h3 id="格式化上下文："><a href="#格式化上下文：" class="headerlink" title="格式化上下文："></a>格式化上下文：</h3><ul><li>块级格式化上下文( Block formatting contexts )( BFC )</li><li>行内格式化上下文( Inline formatting contexts ) ( IFC )</li><li>自适应格式化上下文( Flex Formatting Contexts )( FFC )</li><li>网格布局格式化上下文( GridLayout Formatting Contexts )( GFC )</li></ul><p>有一类盒被称为块容器，它们能够包含块级盒。块容器要么创建BFC，这样它内部仅仅包含块级盒，要么创建一个IFC，这样它内部仅仅包含行内级元素。</p><p>（也就是说，块容器中不可能既包含块级盒，又包含行内级盒，一旦他的子盒中有块级盒，所有行内级盒都会被自动创建匿名盒包裹）。</p><p>在非块级格式化上下文中的块容器总是会创建新的BFC：如display为inline-blocks, table-cells, 和table-captions所生成的盒。</p><p>而自身也在块级格式化上下文中的块容器，则只有overflow不为visible的情形下才会创建新的BFC</p><ul><li>绝对定位和浮动的块容器则总是会创建新的块级格式化上下文。</li><li>display值为table或者inline-table的元素将会生成表格（table），表格内部会使用特殊的格式化方式来排布其内部元素。</li><li>display值为grid或者inline-grid的元素将会生成格元素（grid element），与table情形类似，它内部也是使用特殊的格式化方式来排布其内部元素，</li><li>display值为flex或者inline-flex的元素将会生成自适应容器（flex container），自适应容器在其内部产生自适应格式化上下文（flex formatting context）</li></ul><p>FC的全称是：Formatting Contexts，是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p><p>BFC:BFC(Block Formatting Contexts)直译为”块级格式化上下文”。<br>Block Formatting Contexts就是页面上的一个隔离的渲染区域，容器里面的子元素不会在布局上影响到外面的元素，反之也是如此。<br>浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。</p><p>BFC布局规则：</p><ul><li>内部的Box会在垂直方向，一个接一个地放置。</li><li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li><li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li><li>BFC的区域不会与float box重叠。</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li><li>计算BFC的高度时，浮动元素也参与计算</li></ul><p>那些元素生成BFC</p><ul><li>根元素</li><li>float属性不为none</li><li>position为absolute或fixed</li><li>display为inline-block, table-cell, table-caption, flex, inline-flex</li><li>overflow不为visible</li></ul><p>元素与盒</p><ul><li>在HTML中常常使用的概念是元素，而在CSS中，布局的基本单位是盒，盒总是矩形的。</li><li>元素与盒并非一一对应的关系，一个元素可能生成多个盒，CSS规则中的伪元素也可能生成盒，display属性为none的元素则不生成盒。</li><li>除了元素之外，HTML中的文本节点也可能会生成盒。</li></ul><p>正常流</p><ul><li>正常流是页面，大部分盒排布于正常流中。正常流中的盒必定位于某一格式化上下文中，正常流中有两种格式化上下文：块级格式化上下文（block formatting context，简称BFC）和行内格式化上下文（inline formatting context,IFC）。</li><li>在块级格式化上下文中，盒呈纵向排布，在行内格式化上下文中，盒则呈横向排布。</li><li>正常流根容器中是块级格式化上下文，不同的盒可能会在内部产生行内格式化上下文或者块级格式化上下文。</li></ul><p>块级与行内级</p><ul><li><p>正常流中的盒分为块级与行内级两种，任何一个行内级盒都不能够直接被放入块级格式化上下文中。如果有一个HTML元素生成了一个行内盒，而其所在的上下文是块级的话，那么应当为它生成一个匿名块级盒，匿名块级盒会在内部生成行内格式化上下文。</p></li><li><p>元素的display属性会决定盒是行内级还是块级：<br>block, table, flex, grid, list-item 为块级<br>inline, inline-block, inline-table, inline-flex, inline-grid 为行内级</p></li></ul><p>产生垂直外边距合并的必备条件,两个margin是邻接的必须满足以下条件:</p><ul><li>必须是处于常规文档流（非float和绝对定位）的块级盒子,并且处于同一个BFC当中<br>没有线盒，没有空隙（clearance，下面会讲到），没有padding和border将他们分隔开,都属于垂直方向上相邻的外边距，可以是下面任意一种情况:<ul><li>元素的margin-top与其第一个常规文档流的子元素的margin-top</li><li>元素的margin-bottom与其下一个常规文档流的兄弟元素的margin-top</li><li>height为auto的元素的margin-bottom与其最后一个常规文档流的子元素的margin-bottom</li><li>高度为0并且最小高度也为0，不包含常规文档流的子元素，并且自身没有建立新的BFC的元素的margin-top和margin-bottom</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css-BEM块元素修饰符</title>
      <link href="/ZJY.github.io/2021/01/14/css-BEM/"/>
      <url>/ZJY.github.io/2021/01/14/css-BEM/</url>
      
        <content type="html"><![CDATA[<h2 id="BlockElementModifier其实是块（block）、元素（element）、修饰符（modifier）。"><a href="#BlockElementModifier其实是块（block）、元素（element）、修饰符（modifier）。" class="headerlink" title="BlockElementModifier其实是块（block）、元素（element）、修饰符（modifier）。"></a>BlockElementModifier其实是块（block）、元素（element）、修饰符（modifier）。</h2><p>这三个部分使用__ 与<code>--</code>连接:<br>.块__元素–修饰符{}</p><p>block 代表了更高级别的抽象或组件<br>block__element 代表 block 的后代，用于形成一个完整的 block 的整体<br>block<code>--</code>modifier代表 block 的不同状态或不同版本</p><p>css引擎查找样式表，对每条规则都按从右到做的顺序去匹配<br>在scss中使用：使用@at-root内联选择器模式，编译出来的CSS无任何嵌套（这是关键）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.person</span> &#123;</span><br><span class="line">  @at-root #&#123;&amp;&#125;__hand &#123;</span><br><span class="line">    <span class="selector-tag">color</span>: <span class="selector-tag">red</span>;</span><br><span class="line">    <span class="keyword">@at-root</span> #&#123;&amp;&#125;<span class="selector-tag">--left</span> &#123;</span><br><span class="line">     <span class="attribute">color</span>: yellow;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">@at-root</span> #&#123;&amp;&#125;<span class="selector-tag">--female</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">    @at-root #&#123;&amp;&#125;__hand &#123;</span><br><span class="line">      <span class="selector-tag">color</span>: <span class="selector-tag">green</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*生成的css*/</span></span><br><span class="line"><span class="selector-class">.person__hand</span> &#123;</span><br><span class="line">   <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.person__hand--left</span> &#123;</span><br><span class="line">   <span class="attribute">color</span>: yellow; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.person--female</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.person--female__hand</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css-background属性使用</title>
      <link href="/ZJY.github.io/2021/01/14/css-background/"/>
      <url>/ZJY.github.io/2021/01/14/css-background/</url>
      
        <content type="html"><![CDATA[<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>Background 是一种 CSS 简写属性，一次性定义了所有的背景属性，包括 color, image, origin 还有 size, repeat 方式等等。</p><p>语法：</p><ul><li><p>background: background-color，background-image，background-repeat，background-attachment，background-position;(不强制要求书写顺序)</p><ul><li><p>background-color 指定要使用的背景颜色 transparent </p></li><li><p>background-position 指定背景图像的位置 0%, 0% </p></li><li><p>background-image 指定要使用的一个或多个背景图像 none </p></li><li><p>background-repeat 指定如何重复背景图像 repeat</p></li><li><p>background-attachment 设置背景图像是否固定或者随着页面的其余部分滚动。 croll</p></li><li><p>background-size 指定背景图片的大小 auto CSS3</p></li><li><p>background-origin 指定背景图像的定位区域 padding-box CSS3</p></li><li><p>background-clip 指定背景图像的绘画区域 border-box CSS3</p></li></ul></li></ul><p>多背景图片 background-image：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">background-image: url(<span class="string">&#x27;img1&#x27;</span>), url(<span class="string">&#x27;img2&#x27;</span>);</span><br><span class="line">background-size: <span class="number">50</span>%, <span class="number">100</span>%;</span><br><span class="line">background-repeat: repeat-x, no-repeat;</span><br></pre></td></tr></table></figure><p>多背景图片总结：</p><ul><li>背景图片所生效的样式，是属性值中与图片位置对应的值；</li><li>如果属性值比背景图片的个数要少，那么没有对应的值的图片样式以第一个值为准；</li><li>背景图片的层级按着从左往右，依次减小。当然，层级最低的还是 background-color；</li></ul><p>背景渐变 background-image: linear-gradient：路径渐变（可手动设置方向，默认自下向上）</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">background: linear-gradient(to left, #333, #333 50%, #eee 75%, #333 75%);</span><br><span class="line">background-image: linear-gradient(#71c9ce, #e3fdfd);</span><br></pre></td></tr></table></figure><p>background-image: radial-gradient 径向渐变：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-image: radial-gradient( #71c9ce, #e3fdfd);</span><br></pre></td></tr></table></figure><p>background-image: repeating-linear-gradient 重复路径渐变：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-image: repeating-linear-gradient(45deg, #71c9ce 20px, #a6e3e9 30px, #e3fdfd 40px);</span><br></pre></td></tr></table></figure><p>background-image: repeating-radial-gradient 重复径向渐变：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-image: repeating-radial-gradient(circle, #90ade4 ,#3350ba 20%);</span><br></pre></td></tr></table></figure><p>背景定位 background-position：</p><p>三个盒子：</p><ul><li>border-box  即所设置元素的 border 所占的区域，位于 padding 和 content 的外层</li><li>padding-box  即所设置元素的 padding 所占的区域，位于 border的内层、content 的外层</li><li>content-box 元素的 padding 所占区域包围着的即为 content</li></ul><p>background-position 默认的定位为 padding-box 盒子的左上角。其属性值可设置为：百分比 / 像素 /位置</p><p>背景重复 background-repeat：</p><p>除了常见的几个 repeat、repeat-x，repeat-y 以及 no-repeat 以外，还在CSS3 中新加了两个值： space 和 round：</p><ul><li>1.背景图片小于容器时<ul><li>background-repeat:space 在保证不缩放的前提下尽可能多的重复图片，并等分图片中间的空隙</li><li>background-repeat:round 在尽可能多的重复图片的前提下，拉伸图片以铺满容器</li></ul></li><li>2.背景图片大于容器时<ul><li>background-repeat:space 在不缩放的前提下裁剪图片，只保留在容器内的部分</li><li>background-repeat:round 缩小图片以铺满容器，长宽与容器尺寸一致（未按比例缩放，图片极有可能变形）</li></ul></li></ul><p>背景相对位置 background-origin：</p><ul><li>background-origin 属性规定 background-position 属性相对于什么位置来定位。属性值有 content-box 、padding-box 、border-box 三个，默认为 padding-box</li></ul><p>背景绘制区域 background-clip：</p><ul><li>background-clip 属性规定背景的绘制区域。默认值为 border-box，其属性值同 background-origin 一样，不过表现大不相同</li></ul><p>背景大小 background-size：</p><ul><li>background-size 除了常见的设置大小和百分比之外，还有两个特殊的属性：contain 和 cover</li><li>background-size: contain 图片长宽不相同时，把图片按比例缩小至较长的一方完全适应内容区域为止，多用于背景图片比元素大的情况</li><li>background-size: cover 图片长宽不相同时，把图片按比例放大至较短的一方完全适应内容区域为止，以使背景图像完全覆盖背景区域，多用于背景图片比元素小的情况。</li></ul><p>背景固定 background-attachment：fixed 背景固定/scroll 背景随页面滚动而滚动（默认）</p><p>扩展属性 background: element</p><ul><li>一个特殊的扩展属性，可以将某个元素设置为另一元素的背景。惊不惊喜，意不意外！不过这个属性只有 FireFox 4+ 的浏览器可以使用，并且需要加上浏览器前缀。<br>  background: element(#id)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-第十一章-javascript更多主题</title>
      <link href="/ZJY.github.io/2021/01/14/javascript-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-javascript%E6%9B%B4%E5%A4%9A%E4%B8%BB%E9%A2%98/"/>
      <url>/ZJY.github.io/2021/01/14/javascript-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-javascript%E6%9B%B4%E5%A4%9A%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript的更多主题"><a href="#JavaScript的更多主题" class="headerlink" title="JavaScript的更多主题"></a>JavaScript的更多主题</h2><h3 id="1-数据类型转换"><a href="#1-数据类型转换" class="headerlink" title="1. 数据类型转换"></a>1. 数据类型转换</h3><p>JavaScript是一种无类型语言，如果某个类型的值需要用于其他类型的值的环境中，JavaScript就会自动将    这个值转换成所需要的类型。例如，如果一个数字用于布尔值环境中，它就会被转换成布尔值。如果一个对象用于字符串类型中，那么它就会被转换为字符串。<br>自动数据类型转换：</p><table style="text-align:center">   <tr >      <td rowspan="2">值</td>      <td colspan="4">使用值的环境</td>   </tr>   <tr>      <td>字符串</td>      <td>数字</td>      <td>布尔值</td>      <td>对象</td>   </tr>   <tr>      <td>未定义的值</td>      <td>“undefined”</td>      <td>NaN</td>      <td>false</td>      <td>Error</td>   </tr>   <tr>      <td>null</td>      <td>“null”</td>      <td>0</td>      <td>false</td>      <td>Error</td>   </tr>   <tr>      <td>非空字符串</td>      <td>原内容</td>      <td>非空字符串对应数字或ASCLL码</td>      <td>true</td>      <td>String对象</td>   </tr>   <tr>      <td>空字符串</td>      <td>原内容</td>      <td>0</td>      <td>false</td>      <td>String对象</td>   </tr>   <tr>      <td>0</td>      <td>“0”</td>      <td>原值</td>      <td>false</td>      <td>Number对象</td>   </tr>   <tr>      <td>NaN</td>      <td>“NaN”</td>      <td>NaN</td>      <td>false</td>      <td>Number对象</td>   </tr>   <tr>      <td>无穷大</td>      <td>“Infinity”</td>      <td>原值</td>      <td>true</td>      <td>Number对象</td>   </tr>   <tr>      <td>负无穷大</td>      <td>“-Infinity”</td>      <td>原值</td>      <td>true</td>      <td>Number对象</td>   </tr>   <tr>      <td>其他所有数字</td>      <td>数字对应字符串</td>      <td>原值</td>      <td>true</td>      <td>Number对象</td>   </tr>   <tr>      <td>true</td>      <td>“true”</td>      <td>1</td>      <td>true</td>      <td>Boolean对象</td>   </tr>   <tr>      <td>false</td>      <td>“false”</td>      <td>0</td>      <td>false</td>      <td>Boolean对象</td>   </tr>   <tr>      <td>对象</td>      <td>toString()</td>      <td>valueOf()或toString()或NaN</td>      <td>true</td>      <td>原值</td>   </tr></table><h4 id="1-1-对象到基本数据类型的转换"><a href="#1-1-对象到基本数据类型的转换" class="headerlink" title="1.1 对象到基本数据类型的转换"></a>1.1 对象到基本数据类型的转换</h4><p>只要把非空对象用在布尔值环境中，它就会被转换为true。这适用于所有对象，即使是被转换成false的表示原始值的包装对象也不例外。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>))</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">0</span>))</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="keyword">new</span> <span class="built_in">Array</span>())</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>把对象转为数字是通过首先调用该对象的valueOf()方法来完成的。大多数对象继承了Object对象的默认valueOf()方法。它只是返回对象本身。由于默认的valueOf()方法不返回原始值，所有接下来javascript会通过调用对象的toString()方法，再将字符串转为数字来把对象转为数字。</p><p>对于数组，数组的toString()方法把数组元素逐一的转换成字符串，用逗号分隔符分隔连接起来，返回连接后的字符串。因此，没有元素的空数组，被转换为空字符串，空字符串被转换为数字0。如果数组只有一个为n的数字元素，则被转换为n本身，如果数组含有多个元素，则被转换为NaN。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>([])</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="literal">NaN</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"><span class="literal">NaN</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="number">1</span>])</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="string">&#x27;1&#x27;</span>])</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>运算符“+”和比较运算符(&lt;、&lt;=、&gt;和&gt;=)既能作用于数字，又能作用于字符串。所以当这两个运算符作用于对象时，就不太清楚应将该对象转换为数字还是字符串。在大多数情况下，JavaScript会先尝试调用对象的valueOf ()方法对它进行转换。如果该方法返回了原始值(通常是一个数字)，就使用那个值。但是valueOf ()方法通常返回的都是未被转换的对象，在这种情况下，JavaScript 将调用对象的tostring()方法对它进行转换。<br>对于这种转换规则，只有“+”运算符是例外的当“+”作用于Date对象时，首先调用toString()方法进行转换。存在这一例外的原因是Date对象既有toString又有valueOf方法。当“+”作用于一个Date对象时，你想执行的几乎都是连接操作，但是当用于比较运算符时想执行的几乎都是数字比较，以判断时间大小。</p><p>大多数对象没有valueOf()方法，或者没有能够返回有用的结果的valueOf()方法。当将“+”运算符作用于一个对象时，通常进行的是字符串的连接而不是加法运算。当将比较运算符作用于一个对象时，通常进行的则是字符串的比较，而不是数字比较。</p><h4 id="1-2-显示类型转换"><a href="#1-2-显示类型转换" class="headerlink" title="1.2 显示类型转换"></a>1.2 显示类型转换</h4><p>Number(),String(),Boolean(),Object()可以把它们参数转换为合适的类型。<br>还有别的技巧可以显式类型转换。<br>要把一个值转换为字符串，可以把它连接到一个空串上：<br>var str = x + “”;<br>要把一个值强制转换为数字，就用它减去0:<br>var number = x - 0;<br>要把一个值转换为布尔值，需要连用两次”!”：<br>var bool = !!x;</p><h4 id="1-3-从数字到字符串的转换"><a href="#1-3-从数字到字符串的转换" class="headerlink" title="1.3 从数字到字符串的转换"></a>1.3 从数字到字符串的转换</h4><p>将数字转换为字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="built_in">String</span>(number);</span><br><span class="line"><span class="keyword">var</span> str = number + ‘’;</span><br></pre></td></tr></table></figure><p>另一种方法是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = number.toString();</span><br><span class="line"><span class="comment">// Number的toString()方法又一个可选的参数，说明了转换的基数，如果省略默认是10，也可以是2-36之间的整数</span></span><br></pre></td></tr></table></figure><h4 id="1-4-从字符串到数字的转换"><a href="#1-4-从字符串到数字的转换" class="headerlink" title="1.4 从字符串到数字的转换"></a>1.4 从字符串到数字的转换</h4><p>从字符串到数字的转换，可以显式的使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="built_in">Number</span>(str);</span><br><span class="line"><span class="keyword">var</span> num = str - <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这种转换只适用于基数10，且允许字符串数字前面有空格，不允许字符串数字后面出现任何非空字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">‘ <span class="number">123</span>’ - <span class="number">0</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line">‘<span class="number">123</span> ’ - <span class="number">0</span></span><br><span class="line">‘a123’ - <span class="number">0</span></span><br><span class="line"><span class="literal">NaN</span></span><br><span class="line">‘<span class="number">123</span> a’ - <span class="number">0</span></span><br><span class="line"><span class="literal">NaN</span></span><br></pre></td></tr></table></figure><p>可以适用parseInt()/parseFloat()函数，这两个函数转换并返回字符串开头的所有数字，并忽略其后的所有非数字后缀。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;aq123&#x27;</span>)</span><br><span class="line"><span class="literal">NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;123a&#x27;</span>)</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="comment">// parseInt()只能解析整数，parseFloat()既能解析整数又能解析浮点数，如果一个字符串以’ox’或’0X’开头，那么parseInt()就将它解释为16进制。</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;3.14 meters&#x27;</span>)</span><br><span class="line"><span class="number">3.14</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;3.14 meters&#x27;</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;0xff&#x27;</span>)</span><br><span class="line"><span class="number">255</span></span><br></pre></td></tr></table></figure><p>parseInt()第二个参数指定要被解析的基数，是2-36之间的整数。<br>如果不能将字符串转换为数字，就返回NaN。</p><h3 id="2-使用值和使用引用"><a href="#2-使用值和使用引用" class="headerlink" title="2. 使用值和使用引用"></a>2. 使用值和使用引用</h3><p>在JavaScript中可以使用三种方式来操作数值：<br>1.可以复制它，把它赋值个一个新的变量<br>2.把它作为参数传递给一个函数或方法<br>3.可以把它和其他值比较来看是否相等<br>操作数值时，有2种根本不同的方式，一种“使用值”一种是“使用引用”。<br>当使用值来操作数据时，重要的是那个值。在一个赋值语句中，会生成一个实际值的副本，这个副本存储在变量中，对象的属性或数组元素中。副本和原始数据是两个分别存放的，独立的值。当使用值将一个数据传递给函数时，传递的是这个数据的副本。如果函数修改了这个值，改变的只是这个数据的副本，并不会修改原始的数据。</p><p>另一种操作数值的方式是使用引用。采用这个方式时，数据的实际副本只有一份，操作的是那个数值的引用。如果操作数据时使用的是引用，那么变量保存的并不是那个值，而是数值的引用，复制的，传递的以及比较的都是值的引用。因此在使用引用的赋值语句中，赋予的是数值的引用而不是值的副本更不是值本身。进行了赋值后，新的变量保存的也是对值的引用，这两个引用具有同等效力，如果其中一个修改了数值，那么原始引用也会改变。当使用引用将值传递给函数时，传递的也是值的引用。使用引用将一个数值和另一个数值比较时，比较的是两个引用，看它们是否引用的是同一个数值的唯一副本。<br>使用值和使用引用</p><table style="text-align:center">   <tr>      <td>操作</td>      <td>使用值</td>      <td>使用引用</td>   </tr>   <tr>      <td>复制</td>      <td>实际复制的是值，是2个不同的独立的副本</td>      <td>复制的只是对数值的引用，如果通过新的引用修改了值，也会改变原始引用</td>   </tr>   <tr>      <td>传递</td>      <td>传递的是一个独立的副本，对他的改变在函数外部没有影响</td>      <td>传递的是值的引用，如果通过函数传递的引用修改了值，这个改变在函数外部可见</td>   </tr>   <tr>      <td>比较</td>      <td>比较的两个独立的值，以判断是否相等</td>      <td>比较的是2个引用，以判断它们引用的是否是同一个数值，对两个不同的数值的引用不相等，即使这两个数值的是由相同的字节构成的。</td>   </tr></table><h4 id="2-1-基本类型和引用类型"><a href="#2-1-基本类型和引用类型" class="headerlink" title="2.1 基本类型和引用类型"></a>2.1 基本类型和引用类型</h4><p>基本类型使用值操作，引用类型使用引用来操作。<br>在JavaScript中，数字和布尔值是基本类型，说它们基本，是因为它们只是由小的、固定数量的字节构成的，这些字节是在JavaScript解释器的低层(基本层)进行操作的。另一方面，对象就是引用类型。作为特殊对象类型的数组和函数因此也是引用类型。由于这些数据类型可以包含任意多个属性或元素，所以它们不像固定大小的基本数值那样易于操作。因为对象和数组的值可能变得非常大，所以使用值来操作这些数据很不合理，这样做可能会产生大量低效率的内存复制和比较。<br>那么字符串又是什么类型的呢?由于字符串的长度是任意的，所以看起来它好像应该属于引用类型。但事实上在JavaScrip中它们通常被当作基本类型，因为它们并不是对象。<br>例：使用值进行复制，传递，比较</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> m = n;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add_to_total</span>(<span class="params">total, x</span>)</span>&#123;</span><br><span class="line">    total = total + x;</span><br><span class="line">&#125;</span><br><span class="line">add_to_total(n,m);</span><br><span class="line"><span class="built_in">console</span>.log(n,m); <span class="comment">//1 1</span></span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>) m = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(n,m);<span class="comment">//1  2</span></span><br></pre></td></tr></table></figure><p>例：使用引用进行复制，传递，比较</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmas = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2001</span>,<span class="number">11</span>,<span class="number">25</span>);</span><br><span class="line"><span class="keyword">var</span> solstice = xmas; <span class="comment">//赋值的是值的引用</span></span><br><span class="line">solstice.setDate(<span class="number">21</span>);</span><br><span class="line">xmas.getDate(); <span class="comment">//返回21，而不是原始值25</span></span><br><span class="line">(xmas == solstice) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xmas1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2001</span>,<span class="number">11</span>,<span class="number">25</span>);</span><br><span class="line"><span class="keyword">var</span> solstice1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2001</span>,<span class="number">11</span>,<span class="number">25</span>); </span><br><span class="line">(xmas1 == solstice1) <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h4 id="2-2-使用值和使用引用：总结"><a href="#2-2-使用值和使用引用：总结" class="headerlink" title="2.2 使用值和使用引用：总结"></a>2.2 使用值和使用引用：总结</h4><p>操作不同类型时所采取的方式。</p><table style="text-align:center">   <tr>      <td>类型</td>      <td>复制所使用的</td>      <td>传递所引用的</td>      <td>比较所引用的</td>   </tr>   <tr>      <td>数字</td>      <td>值</td>      <td>值</td>      <td>值</td>   </tr>   <tr>      <td>布尔值</td>      <td>值</td>      <td>值</td>      <td>值</td>   </tr>   <tr>      <td>字符串</td>      <td>不可变的值</td>      <td>不可变的</td>      <td>值</td>   </tr>   <tr>      <td>对象</td>      <td>引用</td>      <td>引用</td>      <td>引用</td>   </tr></table><h3 id="3-无用存储单元收集"><a href="#3-无用存储单元收集" class="headerlink" title="3. 无用存储单元收集"></a>3. 无用存储单元收集</h3><p>JavaScript·使用无用存储单元来回收那些由字符串、对象、数组和函数占用的而且不再使用的内存。</p><h4 id="3-1-标记和清除的无用存储单元"><a href="#3-1-标记和清除的无用存储单元" class="headerlink" title="3.1 标记和清除的无用存储单元"></a>3.1 标记和清除的无用存储单元</h4><p>一个标记 和清除的无用存储单元回收器会周期性地遍历javascript环境中的所有变量的列表，并且给这些变量所引用的值做标记。如果被引用的值是对象或数组，那么对象的属性或者数组的元素就会被递归地做上标记。通过递归地遍历所有值的树或者图，无用存储单元收集器就能够找到(并标记)仍旧使用的每个值。那些没有标记的值就是无用的存储单元。当采用标记和清除算法的无用单元收集器给所有正在使用的变量做完了标记之后，它就会开始进行清除。在这个阶段中，它将遍历环境中所有值的列表，同时释放那些没有标记的值。经典的标记和清除无用存储单元收集器每次都进行一次完整的标记和一次完整的清除工作，这在使用无用存储单元收集过程的系统中会大大降低系统的速度。该算法较为复杂的变形使效率相对提高，它们在后台执行收集，并不影响系统的性能。</p><h4 id="3-2-采用引用计数的无用存储单元收集"><a href="#3-2-采用引用计数的无用存储单元收集" class="headerlink" title="3.2 采用引用计数的无用存储单元收集"></a>3.2 采用引用计数的无用存储单元收集</h4><p>当一个对象被创建，而且它的一个引用被存储在变量中，引用计数就为1。当这个对象的引用被复制，并且存储在另一个变量中时，引用计数就增加到2。当保存这些引用的其中一个变量被某个新值覆盖了时，该象的引用计数就减为1。如果引用计数达到了0，那么就没有对这个对象的引用了。由于没有了对副本的引用，所以在程序中也就不会再有对这个对象的引用。因此， Javascript知道此时销毀对象并且收集与之关联的内存是安全的。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-第十章-正则表达式</title>
      <link href="/ZJY.github.io/2021/01/13/javascript-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/ZJY.github.io/2021/01/13/javascript-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="第十章-正则表达式"><a href="#第十章-正则表达式" class="headerlink" title="第十章-正则表达式"></a>第十章-正则表达式</h2><p>正则表达式（regular expression）是一个描述字符模式的对象。javascript的RegExp类表示正则表达式。而String和RegExp都定义了使用正则表达式进行强大的模式匹配和文本检索与替换的函数。</p><h3 id="1-正则表达式的定义"><a href="#1-正则表达式的定义" class="headerlink" title="1. 正则表达式的定义"></a>1. 正则表达式的定义</h3><p>在javascript中，正则表达式由RegExp对象表示，当然可以使用RegExp()构造函数创建RegExp对象，不过通常用直接量语法来创建RegExp对象。被定义在一堆斜杠之间的字符，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/s$/</span>; <span class="comment">//匹配所有以字母‘s’结尾的字符串</span></span><br></pre></td></tr></table></figure><p>也可用构造函数表示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(‘s$’);</span><br></pre></td></tr></table></figure><h4 id="1-1-直接量字符"><a href="#1-1-直接量字符" class="headerlink" title="1.1 直接量字符"></a>1.1 直接量字符</h4><p>正则表达式的直接量字符</p><table><thead><tr><th align="center">字符</th><th align="center">匹配</th></tr></thead><tbody><tr><td align="center">字母数字字符</td><td align="center">匹配自己本身</td></tr><tr><td align="center">\o</td><td align="center">NUL字符(\u0000)</td></tr><tr><td align="center">\t</td><td align="center">制表符</td></tr><tr><td align="center">\n</td><td align="center">换行符</td></tr><tr><td align="center">\v</td><td align="center">垂直制表符</td></tr><tr><td align="center">\v</td><td align="center">换页符</td></tr><tr><td align="center">\r</td><td align="center">回车</td></tr><tr><td align="center">\xnn</td><td align="center">由十六进制数nn指定的拉丁字符</td></tr><tr><td align="center">\uxxxx</td><td align="center">由十六进制xxxx指定的unicode字符</td></tr><tr><td align="center">\cX</td><td align="center">控制字符^X</td></tr></tbody></table><p>在正则中，许多标点符号具有特殊的含义：<br> ^ $ . * + ? = ! : | \ / () [] {}</p><h4 id="1-2-字符类"><a href="#1-2-字符类" class="headerlink" title="1.2 字符类"></a>1.2 字符类</h4><p>正则表达式的字符类</p><table><thead><tr><th align="center">字符</th><th align="center">匹配</th></tr></thead><tbody><tr><td align="center">[…]</td><td align="center">位于括号之内的任意字符</td></tr><tr><td align="center">[^…]</td><td align="center">不在括号之中的任意字符</td></tr><tr><td align="center">.</td><td align="center">除换行符和其他unicode行终止符之外的任意字符</td></tr><tr><td align="center">\w</td><td align="center">任何ASCLL单字字符，等价于[a-zA-Z0-9]</td></tr><tr><td align="center">\W</td><td align="center">任何ASCLL非单字字符，等价于[^a-zA-Z0-9]</td></tr><tr><td align="center">\s</td><td align="center">任何unicode空白符</td></tr><tr><td align="center">\S</td><td align="center">任何非unicode空白符</td></tr><tr><td align="center">\d</td><td align="center">任何ASCLL数字，等价于[0-9]</td></tr><tr><td align="center">\D</td><td align="center">任何ASCLL数字之外的任何字符，等价于[^0-9]</td></tr><tr><td align="center">[\b]</td><td align="center">退格直接量</td></tr></tbody></table><h4 id="1-3-重复"><a href="#1-3-重复" class="headerlink" title="1.3 重复"></a>1.3 重复</h4><p>正则表达式的重复字符</p><table><thead><tr><th align="center">字符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">{n,m}</td><td align="center">匹配前一项至少n次，但是不能超过m次</td></tr><tr><td align="center">{n,}</td><td align="center">匹配前一项n次或更多次</td></tr><tr><td align="center">{n}</td><td align="center">匹配前一项正好n次</td></tr><tr><td align="center">?</td><td align="center">匹配前一项0次或1次，等价于{0,1}</td></tr><tr><td align="center">+</td><td align="center">匹配前一项一次或多次，等价于{1,}</td></tr><tr><td align="center">*</td><td align="center">匹配前一项0次或多次，等价于{0,}</td></tr></tbody></table><h4 id="1-4-选择-分组和引用"><a href="#1-4-选择-分组和引用" class="headerlink" title="1.4 选择/分组和引用"></a>1.4 选择/分组和引用</h4><p>字符“｜”用于分隔供选择的字符，例如，/ab|cd|ef/既匹配字符串”ab”,又匹配”cd”,又或者是”ef”. 选择项从左到右考虑，直到发现了匹配项，如果左边选项匹配，就忽略右边的匹配项。</p><h4 id="1-5指定匹配的位置"><a href="#1-5指定匹配的位置" class="headerlink" title="1.5指定匹配的位置"></a>1.5指定匹配的位置</h4><table><thead><tr><th align="center">字符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">^</td><td align="center">匹配字符串的开头</td></tr><tr><td align="center">$</td><td align="center">匹配字符串的结尾</td></tr><tr><td align="center">\b</td><td align="center">匹配一个词语的边界</td></tr><tr><td align="center">\B</td><td align="center">匹配非词语边界的字符</td></tr></tbody></table><h4 id="1-6标志"><a href="#1-6标志" class="headerlink" title="1.6标志"></a>1.6标志</h4><table><thead><tr><th align="center">字符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">i</td><td align="center">执行大小写不敏感的匹配</td></tr><tr><td align="center">g</td><td align="center">执行全局匹配</td></tr><tr><td align="center">m</td><td align="center">多行模式</td></tr></tbody></table><h3 id="2-用于匹配模式的String方法"><a href="#2-用于匹配模式的String方法" class="headerlink" title="2. 用于匹配模式的String方法"></a>2. 用于匹配模式的String方法</h3><p>类String支持四种利用正则表达式的方法</p><ul><li>search(),该方法以正则表达式为参数，返回第一个与之匹配的子串的开始字符的位置，没有没有匹配子串，返回-1，例如：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“JavaScript”.search(<span class="regexp">/script/i</span>); <span class="comment">//4</span></span><br></pre></td></tr></table></figure><p>如果参数不是正则表达式，会传递给RegExp构造函数转换成正则表达式。search不支持全局检索。</p><ul><li><p>方法replace()执行检索和替换操作，第一个参数是正则表达式，第二个参数是要进行替换的字符串。如果正则表达式中设置类标记g，将用替换字符串替换被检索的字符串中所有与模式匹配的子串，否则只替换第一个与模式匹配的子串。如果第一个参数是字符串，则直接检索该字符串。例如：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text.replace(<span class="regexp">/javascript/gi</span>,”JavaScript”);</span><br></pre></td></tr></table></figure><p>  第二个参数可以是函数，能够动态地计算替换字符串。</p></li><li><p>方法match()，唯一的参数就是正则表达式（或者参数传递给构造函数RegExp以转换成正则表达式），返回包含匹配结果的数组，例如：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“<span class="number">1</span> plus <span class="number">2</span> equals <span class="number">3</span>”.match(<span class="regexp">/\d+/g</span>); <span class="comment">//[“1”,”2”,”3”]</span></span><br></pre></td></tr></table></figure><p>  如果不设置标志g，只检索第一个匹配，返回的也是数组</p></li><li><p>split()方法可以把调用它的字符串分解为一个子串数组，使用分隔符作为参数，例如：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“<span class="number">123</span>,<span class="number">456</span>,<span class="number">789</span>”.split(‘,’); <span class="comment">//[“123”,”456”,”789”]</span></span><br></pre></td></tr></table></figure><p>  也可以用正则表达式为参数，指定分隔符，允许两个有任意多个空白符：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“<span class="number">1</span>,<span class="number">2</span>, <span class="number">3</span> , <span class="number">4</span> ,<span class="number">5</span>”.split(<span class="regexp">/\s*,\s*/</span>); <span class="comment">//[“1”,”2”,”3”,”4”,”5”]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-RegExp对象"><a href="#3-RegExp对象" class="headerlink" title="3. RegExp对象"></a>3. RegExp对象</h3><p>构造函数RegExp()有一个或2个字符串参数，第一个是包含正则表达式主体的字符串，即正则表达式斜杠之间的文本，用<code>\\</code>代表转义的\字符，第二个参数可选，是表达式的标志，“g”,”i”,”m”或它们的组合，例如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> zipcode = <span class="keyword">new</span> <span class="built_in">RegExp</span>(“\\d&#123;<span class="number">5</span>&#125;”,”g”);<span class="comment">//找到字符串中5个数字</span></span><br></pre></td></tr></table></figure><h4 id="3-1-用于模式匹配的RegExp方法"><a href="#3-1-用于模式匹配的RegExp方法" class="headerlink" title="3.1 用于模式匹配的RegExp方法"></a>3.1 用于模式匹配的RegExp方法</h4><p>RegExp对象定义类2个用于执行模式匹配操作的方法。</p><ul><li><p>exec()对一个指定的字符串执行正则表达式，就是在一个字符串中检索匹配，如果没有找到就返回null，如果找到一个匹配就返回一个数组。这个数组的元素0包含的是正则表达式相匹配的字符串，余下的所有元素包含的是与括号扩起来的子表达式相匹配的子串。而且，属性index包含类匹配发生的字符的位置，属性input引用的是被检索的字符串。</p></li><li><p>test()参数是一个字符串，如果这个字符串包含正则表达式的一个匹配就返回true</p></li></ul><h4 id="3-2-RegExp的实例属性"><a href="#3-2-RegExp的实例属性" class="headerlink" title="3.2 RegExp的实例属性"></a>3.2 RegExp的实例属性</h4><p>每个RegExp对象都有5个属性.</p><ul><li>属性source是一个只读字符串，存放的是正则表达式的文本。</li><li>属性global是一个只读的布尔值，说明该表达式是否有标志g。</li><li>属性ignoreCase是一个只读的布尔值，说明该表达式是否有标志i。</li><li>属性multiline是一个只读的布尔值，说明该表达式是否有标志m。</li><li>最后一个属性是lastIndex，可读写的整数。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-第九章-数组</title>
      <link href="/ZJY.github.io/2021/01/13/javascript-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%95%B0%E7%BB%84/"/>
      <url>/ZJY.github.io/2021/01/13/javascript-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="第九章-数组"><a href="#第九章-数组" class="headerlink" title="第九章-数组"></a>第九章-数组</h2><p>对象类型是一种包含已命名的的值的复合数据类型，数组即一种包含已编码的值的复合数据类型</p><h3 id="1-数组和数组元素"><a href="#1-数组和数组元素" class="headerlink" title="1. 数组和数组元素"></a>1. 数组和数组元素</h3><p>数组（array）是一种数据类型，它包含或者存储了编码的值。每个编码的值称作该数组的一个元素（element），每个元素的编码成为数组的下标（index）。</p><h4 id="1-1-数组的创建"><a href="#1-1-数组的创建" class="headerlink" title="1.1 数组的创建"></a>1.1 数组的创建</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">a</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line">a.length; <span class="comment">//3, 每个元素都是undefined</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>();<span class="comment">//[] 创建了一个空数组</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><h4 id="1-2-数组元素的读和写"><a href="#1-2-数组元素的读和写" class="headerlink" title="1.2 数组元素的读和写"></a>1.2 数组元素的读和写</h4><p>可以用[]来存取数组元素。方括号左边是对数组的引用，方括号中是具有非负整数的任意表达式。数组的下标必须是大于等于0并小于2<sup>23-1</sup>的整数，如果你使用的数字过大或者使用了小数负数，浮点数，会转化为字符串作为对象属性的名字，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">a[-<span class="number">12</span>] = <span class="number">12</span></span><br><span class="line">a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, &#123;-<span class="number">12</span>:<span class="number">12</span>&#125;]</span><br></pre></td></tr></table></figure><h4 id="1-3-数组的长度"><a href="#1-3-数组的长度" class="headerlink" title="1.3 数组的长度"></a>1.3 数组的长度</h4><p>所有的数组都有length属性，用来说明这个数组包含的元素个数。数组的length是自动更新的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">a.length</span><br><span class="line"><span class="number">0</span></span><br><span class="line">a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>);</span><br><span class="line">a.length</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>数组的length属性既可以读又可以写，当length设置了一个比他小的值，之后的值会被截断，值就会丢失。如果length设置的值比当前值大，那么未定义的元素就会被添加到数组末尾以使数组增加到指定长度。<br>通过设置数组length是唯一缩短数组长度的方法。如果使用delete来删除元素，虽然元素变成未定义的，但是数组的length属性不会变。</p><h3 id="2-数组的方法"><a href="#2-数组的方法" class="headerlink" title="2. 数组的方法"></a>2. 数组的方法</h3><h4 id="2-1-join方法"><a href="#2-1-join方法" class="headerlink" title="2.1 join方法"></a>2.1 join方法</h4><p>方法Array.join()方法可以将一个数组元素都转换成字符串，然后拼接起来。你可以指定一个可选的字符串来隔离结果字符串中的元素，如果没有指定，用逗号分割。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">a.join(<span class="string">&quot;*&quot;</span>)</span><br><span class="line"><span class="string">&quot;1*2&quot;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-reverse方法"><a href="#2-2-reverse方法" class="headerlink" title="2.2.reverse方法"></a>2.2.reverse方法</h4><p>方法Array.reverse()方法将颠倒数组顺序并返回颠倒后的结果。他在原数组上操作，并不是新建一个数组进行操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a.reverse();</span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">a</span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h4 id="2-3-sort方法"><a href="#2-3-sort方法" class="headerlink" title="2.3 sort方法"></a>2.3 sort方法</h4><p>Array.sort()方法是在原数组上对数组元素进行排序，返回排序后的结果，如果调用时不传参数，将按照字母顺序进行排序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;banan&#x27;</span>,<span class="string">&#x27;apple&#x27;</span>,<span class="string">&#x27;orange&#x27;</span>];</span><br><span class="line">a.sort();</span><br><span class="line">a.join();</span><br><span class="line"><span class="string">&quot;apple,banan,orange&quot;</span></span><br><span class="line">a</span><br><span class="line">[<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banan&quot;</span>, <span class="string">&quot;orange&quot;</span>]</span><br></pre></td></tr></table></figure><p>如果含有未定义的元素，这些元素将被放在数组的末尾<br>如果要按照别的顺序排序，需要传递给sort方法一个比较函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>];</span><br><span class="line">a.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;)</span><br><span class="line"> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>];</span><br><span class="line">a.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b-a;</span><br><span class="line">&#125;)</span><br><span class="line"> [<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h4 id="2-4-concat"><a href="#2-4-concat" class="headerlink" title="2.4 concat"></a>2.4 concat</h4><p>方法Array.concat()能创建并返回一个数组,这个数组包含了调用concat()的原始数组的元素，其后跟随的是concat()的参数。如果其中有些参数是数组,那么它将被展开,其元素将被添加到返回的数组中。但是要注意concat()并不能递归地展开一个元素为数组的数组。下面是一些例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.concat(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment">//[1,2,3.4,5]</span></span><br><span class="line">a.concat([<span class="number">4</span>,<span class="number">5</span>]);</span><br><span class="line"><span class="comment">//返回[1,2,3,4,5]</span></span><br><span class="line">a.concat([<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>])</span><br><span class="line"><span class="comment">//[1,2,3,4,5,6,7]</span></span><br><span class="line">a.concat(<span class="number">4</span>,[<span class="number">5</span>,[<span class="number">6</span>,<span class="number">7</span>]])<span class="comment">//返回[1,2,3,4,5,[6,7]]</span></span><br></pre></td></tr></table></figure><h4 id="2-5-slice-方法"><a href="#2-5-slice-方法" class="headerlink" title="2.5 slice()方法"></a>2.5 slice()方法</h4><p>方法Array.slice()方法返回的是指定的一个数组片段，它的两个参数指定要返回数组的起止点，返回的值是包含第一个参数指定的元素和第二个参数指定元素的上一个元素为止的元素，但是并不包含第二个参数包含的元素。如果只传递一个参数，那么返回从第一个元素到末尾之间的元素，如果参数含有负数，那么从数组末尾开始算，例如，-1指的是数组最后一个元素。例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">a.slice(<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line"> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">a.slice(<span class="number">1</span>,-<span class="number">1</span>)</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">a.slice(-<span class="number">3</span>,-<span class="number">2</span>)</span><br><span class="line">[<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h4 id="2-6-splice方法"><a href="#2-6-splice方法" class="headerlink" title="2.6 splice方法"></a>2.6 splice方法</h4><p>方法Array.splice()在原数组上插入或删除数组元素，修改原数组。<br>第一个参数指定了要插入或删除的的元素在数组中的位置。第二个参数指定了要删除的元素个数。如果第二个参数省略，将删除从开始元素到末尾之间的元素，splice返回的是删除了的数组元素数组，如果没有删除，返回空数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">a.splice(<span class="number">4</span>)</span><br><span class="line">[<span class="number">5</span>]</span><br><span class="line">a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">a.splice(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">a</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">a.splice(<span class="number">1</span>,<span class="number">0</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">[]</span><br><span class="line">a</span><br><span class="line">[<span class="number">1</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">a.splice(<span class="number">1</span>,<span class="number">0</span>,[<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">[]</span><br><span class="line">a</span><br><span class="line">[<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>]</span><br><span class="line"><span class="comment">// splice并不将插入的元素展开</span></span><br></pre></td></tr></table></figure><h4 id="2-7-push方法和pop方法"><a href="#2-7-push方法和pop方法" class="headerlink" title="2.7 push方法和pop方法"></a>2.7 push方法和pop方法</h4><p>push和pop可以像栈那样使用数组，push可以向数组末尾添加一个或多个数组元素，并返回数组的新长度，pop可以删除数组最后一个元素，返回删除的值，这两个方法都修改原数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stack = [];</span><br><span class="line">stack.push(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line">stack.pop()</span><br><span class="line"><span class="number">2</span></span><br><span class="line">stack.push(<span class="number">3</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line">stack.pop()</span><br><span class="line"><span class="number">3</span></span><br><span class="line">stack.push([<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="number">2</span></span><br><span class="line">stack.pop()</span><br><span class="line"> [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">stack.pop()</span><br><span class="line"><span class="number">1</span></span><br><span class="line">stack</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><h4 id="2-8-unshift和shift方法"><a href="#2-8-unshift和shift方法" class="headerlink" title="2.8 unshift和shift方法"></a>2.8 unshift和shift方法</h4><p>和push和pop类似，只不过是在数组头部插入和删除元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = []</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">a.unshift(<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">a.unshift(<span class="number">22</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line">a.shift()</span><br><span class="line"><span class="number">22</span></span><br><span class="line">a</span><br><span class="line">[<span class="number">1</span>]<span class="number">0</span>: 1length: 1__proto__: <span class="built_in">Array</span>(<span class="number">0</span>)</span><br><span class="line">a.unshift([<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="number">2</span></span><br><span class="line">a</span><br><span class="line"> [[<span class="number">4</span>, <span class="number">5</span>], <span class="number">1</span>]</span><br><span class="line">a.shift()</span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">a.shift()</span><br><span class="line"><span class="number">1</span></span><br><span class="line">a</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><h4 id="2-9-toString方法"><a href="#2-9-toString方法" class="headerlink" title="2.9 toString方法"></a>2.9 toString方法</h4><p>数组的toString将数组每个元素转换为字符串，用逗号拼接，并且没有其他的界定符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].toString()</span><br><span class="line"><span class="string">&quot;1,2,3&quot;</span></span><br><span class="line">[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>].toString()</span><br><span class="line"><span class="string">&quot;a,b,c&quot;</span></span><br><span class="line">[<span class="number">1</span>,[<span class="number">2</span>,<span class="string">&quot;c&quot;</span>]].toString()</span><br><span class="line"><span class="string">&quot;1,2,c&quot;</span></span><br></pre></td></tr></table></figure><p>注意toString的返回值和无参数的join方法返回值相等：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,[<span class="number">2</span>,<span class="string">&quot;c&quot;</span>]].join()</span><br><span class="line"><span class="string">&quot;1,2,c&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-第八章-对象</title>
      <link href="/ZJY.github.io/2021/01/13/javascript-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1/"/>
      <url>/ZJY.github.io/2021/01/13/javascript-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="第八章-对象"><a href="#第八章-对象" class="headerlink" title="第八章-对象"></a>第八章-对象</h2><h3 id="1-对象和属性"><a href="#1-对象和属性" class="headerlink" title="1. 对象和属性"></a>1. 对象和属性</h3><p>对象是一种复合数据类型，将多个数据值存储在一个单元中，并使用名字来存取这些值。<br>解释对象的另一种方式就是，对象是一个无序的属性集合，每个属性都有自己的名字和值，存储在对象中已命名的值既可以是数字字符串也可以是对象。</p><h4 id="1-1-对象的创建"><a href="#1-1-对象的创建" class="headerlink" title="1.1 对象的创建"></a>1.1 对象的创建</h4><p>对象是由运算符new创建的，在这个运算符之后必须有用于初始化对象的构造函数名，可以用如下代码创建空对象（没有属性的对象）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure><p>javascript还支持内部构造函数，例如： var now  = new Date();<br>对象直接量定义了另一种初始化对象的方式。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    x:<span class="number">0</span>,</span><br><span class="line">    y:<span class="number">0</span>,</span><br><span class="line">    radius:<span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-属性的设置和查询"><a href="#1-2-属性的设置和查询" class="headerlink" title="1.2 属性的设置和查询"></a>1.2 属性的设置和查询</h4><p>通常使用“.”运算符来存取对象的属性。位于“.”运算符左边的是对象的引用，右边的是对象的属性，是一个标识符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">book.title = <span class="string">&#x27;javascript高级程序设计&#x27;</span>;<span class="comment">//设置属性</span></span><br><span class="line">book.title ; <span class="comment">//属性查询</span></span><br></pre></td></tr></table></figure><h4 id="1-3-属性的枚举"><a href="#1-3-属性的枚举" class="headerlink" title="1.3 属性的枚举"></a>1.3 属性的枚举</h4><p>可以通过for/in来遍历对象的属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getObjNames</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> names = “”;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> name <span class="keyword">in</span> obj) names+= name ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for/in循环属性并没有特定的顺序，虽然能枚举出用户定义的属性，但不能枚举出某些预定义的属性和方法</p><h4 id="1-4-未定义的属性"><a href="#1-4-未定义的属性" class="headerlink" title="1.4 未定义的属性"></a>1.4 未定义的属性</h4><p>如果要读取一个未定义的属性，那么读取的值是undefined.<br>可以用运算符delete来删除对象的属性：<br>delete book.title;<br>删除一个属性不仅仅是将属性值设置为undefined,而是真正从该对象中移除该属性。用for/in循环可以证明两者区别，它只能枚举出来被设定为undefined的属性，不能枚举已删除的属性。</p><h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2. 构造函数"></a>2. 构造函数</h3><p>在javascript中，使用new运算符和预定义的构造函数（Date(),Object(),Function()等）可以创建并初始化一个对象。</p><p>要创建已经定义了属性的对象，需要编写一个构造函数在新的对象中创建并初始化这些属性。构造函数是具有2个特性的javascript函数：</p><ul><li>由new运算符调用</li><li>传递给它的是对一个新创建的空对象的引用，将该引用作为关键字this的值，而且还要对新创建的对象进行初始化</li></ul><p>如下例子说明如何定义并调用Rectangle对象的构造函数<br>Rectangle对象的构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/定义构造函数</span><br><span class="line"><span class="comment">//注意如何初始化this引用的对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">w,h</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.width = w;</span><br><span class="line">    <span class="built_in">this</span>.height = h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用构造函数创建2个Rectangle对象</span></span><br><span class="line"><span class="comment">//注意把宽和高传递给构造函数，这样就能初始化对象</span></span><br><span class="line"><span class="keyword">var</span> rect1 = <span class="keyword">new</span> Rectangle(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">var</span> rect2 = <span class="keyword">new</span> Rectangle(<span class="number">8</span>,<span class="number">9</span>);</span><br></pre></td></tr></table></figure><p>构造函数只是初始化了对象，并不返回这个对象。构造函数通常没有返回值，只是初始化由this值传递进来的对象。<br>但是，构造函数可以返回一个对象值，如果这样做，被返回的对象就成了new表达式的值，this所引用的对象就被丢弃了。</p><h3 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h3><p>所谓方法（method）就是通过对象调用的javascript函数。函数就是数值，可以将函数赋值给任何变量，设置对象的属性。如果一个函数f和一个对象o，可以定义一个名为m的方法：o.m = f;<br>定义m方法之后可以通过o.m()调用它。</p><p>方法有一个重要的属性，即函数主体内部，关键字this变成了调用该方法的对象。例如，在o.m()中，主体可以使用关键字this来引用对象o.</p><p>任何一个用作方法的函数都会得到一个额外的实际参数，即调用该方法的对象。</p><p>由于方法通常是对对象执行某种操作，要表达函数作用于对象，最好采用方法的调用的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rect.setSize(width,height);</span><br><span class="line">setRectSize(rect, width, height);</span><br></pre></td></tr></table></figure><p>虽然这两行代码都是对对象做同样的操作，但第一行采用方法的调用语法。表达rect是操作的焦点。</p><p>虽然有区别地对特函数和方法比较有用，但实际上它们之间的差别井没有最初时那么大了。<br>回忆一下，函数是储存在变量中的值，而那个变量也不过是全局对象的一个属性。因此，当你调用一个函数时，实际上调用的是全局对象的一个方法。<br>在这样的函数中，关键字this引用的是全局对象。所以在函数和方法之间井设有件么技术上的差别。<br>真正的差别存在于设计和目的上，方法是用来对上this对象进行操作的，而函数通常是独立的，并不需要使用this对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例8-2方法的定义和调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compute_area</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.width * <span class="built_in">this</span>.height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> page = <span class="keyword">new</span> Rectangle(<span class="number">9</span>,<span class="number">88</span>);</span><br><span class="line">page.area = compute_area; <span class="comment">//通过把函数赋予对象的属性，来定义一个方法。</span></span><br><span class="line"><span class="keyword">var</span> a = page.area();</span><br></pre></td></tr></table></figure><p>在例8-2中有一个明显的缺点，那就是在调用rect对象的方法area()之前，必须先将该方法赋给rect对象的一个属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">8</span>-<span class="number">3</span> 用构造函数定义方法</span><br><span class="line"><span class="comment">//首页定义一些函数，它们将被用作方法。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle_area</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>.width * <span class="built_in">this</span>.height; &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle_perimeter</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">2</span>*<span class="built_in">this</span>.width + <span class="number">2</span>*<span class="built_in">this</span>.height; &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle_set_size</span>(<span class="params">w,h</span>) </span>&#123; <span class="built_in">this</span>.width = w; <span class="built_in">this</span>.height = h; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为Rectangle对象定义一个构造函数，不仅要初始化属性还要给方法赋值。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">w,h</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//初始化对象的属性</span></span><br><span class="line">    <span class="built_in">this</span>.width = w;</span><br><span class="line">    <span class="built_in">this</span>.height = h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义对象的方法</span></span><br><span class="line">    <span class="built_in">this</span>.area = Rectangle;</span><br><span class="line">    <span class="built_in">this</span>.perimeter = Rectangle_perimeter;</span><br><span class="line">    <span class="built_in">this</span>.set_size = Rectangle_set_size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一旦创建Rectangle对象，就可以直接调用它的方法</span></span><br><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> Rectangle(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> a = r.area();</span><br><span class="line"><span class="keyword">var</span> p = r.perimeter();</span><br></pre></td></tr></table></figure><p>例8-3说明的方法还是有缺点，构造函数Rectangle()要对它所有属性都进行设置。由于每个属性都占用一定内存空间，所以给每个Rectangle类添加方法，内存占用就会增加。</p><h3 id="4-原型对象和继承"><a href="#4-原型对象和继承" class="headerlink" title="4.原型对象和继承"></a>4.原型对象和继承</h3><p>我们已经知道，用构造函数把方法赋予它要初始化的对象效率低下。<br>javascript对象都继承原型对象的属性。每个对象都有原型对象，原型对象的所有属性都是以它为原型的对象的属性。也就是说，每个对象都继承原型对象的所有属性。</p><p>一个对象的原型是由创建并初始化该对象的构造函数定义的。<br>javascript中所有函数都有prototype属性，它引用了一个对象。虽然原型对象初始化是空的，但你在其中定义的任何属性都会被该构造函数创建的所有对象继承。<br>因为原型对象的属性被一个类的所有对象共享，所有通常只用它们来定义类中所有相同的属性。这使得原型对象适用于方法定义，另外原型属性还适合于那些具有常量值的属性定义。</p><h4 id="4-1-原型和内部类"><a href="#4-1-原型和内部类" class="headerlink" title="4.1 原型和内部类"></a>4.1 原型和内部类</h4><p>不只是用户定义的类具有原型对象，像String和Date这样的内部类同样具有原型对象，也可以给它们赋值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.endsWith = <span class="function"><span class="keyword">function</span>(<span class="params">c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (c == <span class="built_in">this</span>.charAt(<span class="built_in">this</span>.length - <span class="number">1</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> message = “hello world”;</span><br><span class="line">message.endsWith(‘h’); <span class="comment">//false</span></span><br><span class="line">message.endsWith(‘d’); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="5-面向对象的javascript"><a href="#5-面向对象的javascript" class="headerlink" title="5. 面向对象的javascript"></a>5. 面向对象的javascript</h3><p>javascript采取以原型对象为基础的继承机制，而不是采取类为基础的继承机制。</p><h4 id="5-1-实例的属性"><a href="#5-1-实例的属性" class="headerlink" title="5.1 实例的属性"></a>5.1 实例的属性</h4><p>每个对象都有它自己单独的属性副本。如果有10个给定的类的对象，那么每个实例属性就有10个副本。<br>在默认情况下，javascript对象的属性都是实例属性，但是为了更真实的模拟面向对象的设计语言，我们说javascript的实例属性都是在对象中用构造函数创建的或初始化的属性。</p><h4 id="5-2-实例方法"><a href="#5-2-实例方法" class="headerlink" title="5.2 实例方法"></a>5.2 实例方法</h4><p>实例方法和实例属性十分相似，只不过是方法而不是数值。实例方法由特定方法和实例对象调用的。<br>实例方法使用了this来引用它们要操作的对象或实例。虽然类的任何实例都可以调用实例方法，但是并不意味着每个对象都像实例属性那样含有自己专有的方法副本。相反，每个实例方法都是由类的所有实例所共享的。<br>在javascript中，给类定义一个实例方法，是通过把构造函数的原型对象的一个属性设置为函数值来实现的。</p><h4 id="5-3-类属性"><a href="#5-3-类属性" class="headerlink" title="5.3 类属性"></a>5.3 类属性</h4><p>在Java中，类属性是和类相关联的的变量。而不是和类的每个实例相关联的变量。无论类创建多少个实例，每个类属性就只有一个副本。就像实例属性是通过实例存取一样，类属性是通过类存取的。在javascript中，Number.MAX_VALUE就是类属性的一个例子，因为MAX_VALUE就是通过类Number存取的.</p><h4 id="5-4-类方法"><a href="#5-4-类方法" class="headerlink" title="5.4 类方法"></a>5.4 类方法</h4><p>类方法是一个与类关联的一起的方法，而不是和类的实例关联在一起的方法。要调用类方法就必须使用类本身，而不能使用类的实例。方法Date.parse()就是一个类方法。和类属性一样，类方法是全局性的。<br>因为类方法不是对特定对象进行操作的所以类方法更容易被认为是由类调用的函数。在javascript中，要定义一个类方法，只需要用合适的函数作为构造函数的属性即可。</p><h4 id="5-5-例子，类Circle"><a href="#5-5-例子，类Circle" class="headerlink" title="5.5 例子，类Circle()"></a>5.5 例子，类Circle()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义构造函数本身</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.r = radius;</span><br><span class="line">    <span class="comment">//r是构造函数定义并初始化的一个实例属性</span></span><br><span class="line">&#125;</span><br><span class="line">Circle.PI = <span class="number">3.14159</span>;<span class="comment">//定义类属性，是构造函数的一个属性</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cricle_area</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Circle.PI * <span class="built_in">this</span>.r * <span class="built_in">this</span>.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Circle.prototype.area = Cricle_area();<span class="comment">//通过把函数赋给构造函数的原型对象来定义一个实例方法。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle_max</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.r &gt; b.r) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line">Circle.max = Circle_max;<span class="comment">//将函数赋给构造函数的属性，使之成为类方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Circle(<span class="number">1.0</span>);<span class="comment">//创建Circle类的一个实例</span></span><br><span class="line">c.r = <span class="number">2.2</span>; <span class="comment">//修改类实例属性值</span></span><br><span class="line"><span class="keyword">var</span> a = c.crea(); <span class="comment">//调用实例方法</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> Circle(<span class="number">1.2</span>);</span><br><span class="line"><span class="keyword">var</span> bigger = Circle.max(c,d); <span class="comment">//调用类方法</span></span><br></pre></td></tr></table></figure><h4 id="5-6-例子，类Complex复数"><a href="#5-6-例子，类Complex复数" class="headerlink" title="5.6 例子，类Complex复数"></a>5.6 例子，类Complex复数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">复数就是一个实数和一个虚数的和</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 定义类的第一步就是定义该类的构造函数</span></span><br><span class="line"><span class="comment">* 这个构造函数要初始化对象的所有实例属性</span></span><br><span class="line"><span class="comment">* 这些属性是核心的状态变量，是它们使每个类实例不同</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Complex</span>(<span class="params">real, imaginary</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.x = real;<span class="comment">//复数的实数部分</span></span><br><span class="line">    <span class="built_in">this</span>.y = imaginary; <span class="comment">//复数的虚数部分</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 定义类的第二部是在构造函数的原型对象定义他的实例方法（或属性）</span></span><br><span class="line"><span class="comment">* 该对象定义的任何属性都被类的实例所继承</span></span><br><span class="line"><span class="comment">* 返回复数的大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Complex.prototype.maginary = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(<span class="built_in">this</span>.x * <span class="built_in">this</span>.x,<span class="built_in">this</span>.y * <span class="built_in">this</span>.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回复数的相反数</span></span><br><span class="line">Complex.prototype.negative = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Complex(-<span class="built_in">this</span>.x, -<span class="built_in">this</span>.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将Complex对象转化成一个字符串</span></span><br><span class="line">Complex.prototyoe.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&quot;</span>+ <span class="built_in">this</span>.x+<span class="string">&#x27;,&#x27;</span>+<span class="built_in">this</span>.y+<span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个复数的实数部分</span></span><br><span class="line">Complex.prototyoe.valueOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 定义类的第二部是定义类方法</span></span><br><span class="line"><span class="comment">* 常量和其他必要属性作为构造函数的属性而不是构造函数原型对象的属性</span></span><br><span class="line"><span class="comment">* 注意，类方法没有使用this关键字，因为它们只对实际参数进行操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Complex.add = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Complex(a.x+b.x,a.y+b.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex.subtract = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Complex(a.x-b.x,a.y-b.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 下面是预定义复数</span></span><br><span class="line"><span class="comment">* 被定义为类属性，可以被用作常量，实际上并不是只读的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Complex.zero = <span class="keyword">new</span> Complex(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">Complex.one = <span class="keyword">new</span> Complex(<span class="number">1</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="5-7-超类和子类"><a href="#5-7-超类和子类" class="headerlink" title="5.7 超类和子类"></a>5.7 超类和子类</h4><p>在javascript中，类Object是最通用的类，其他所有类都是专用化了的类，或者说是Object的子类。<br>另一种解释就是Object是所有内部类的超类。所有类都继承类Object的基本方法。<br>对象从他的构造函数的原型对象中继承属性，原型对象本身就是一个对象，由构造函数Object()创建。这就意味着原型对象继承了Object.prototype属性，因此类Complex就继承了Complex.prototype的属性，而后者又继承了Object.prototype属性。因此，Complex继承了两个对象的属性，在Complex中查询某个属性时，首先查询这个对象本身，如果没有查询到，就查询Complex.prototype的对象，如果还未查询到，就查询Object.prototype对象。</p><h3 id="6-对象的属性和方法"><a href="#6-对象的属性和方法" class="headerlink" title="6. 对象的属性和方法"></a>6. 对象的属性和方法</h3><p>在javascript中，所有对象都是Object类创建而来，虽然一些专用的类比如String和用户自定义的类Complex都定义了自己的属性和方法，但是都支持Object类定义的属性和方法。</p><h4 id="6-1-constructor属性"><a href="#6-1-constructor属性" class="headerlink" title="6.1 constructor属性"></a>6.1 constructor属性</h4><p>每个对象都有constructor属性，它引用的是初始化该对象的构造函数，例如用构造函数Complex创建类一个对象o，那么o.constructor引用的就是Complex，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> Complex(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">o.constructor == Complex;</span><br></pre></td></tr></table></figure><h4 id="6-2-toString方法"><a href="#6-2-toString方法" class="headerlink" title="6.2 toString方法"></a>6.2 toString方法</h4><p>方法toString没有任何实际参数，它返回的是一个字符串，该方法返回的是调用它的对象的类型或值。当使用“+”运算符把一个字符串和一个对象连接一起或把一个对象传递给alert()或document.write()时，会调用toString方法。</p><p>由类Object定义的默认的toString方法揭示了有关内置对象的内部类型信息。<br>默认的toString方法返回的字符串形式总是[object class]，class是对象的内部类型，通常对应于该对象的构造函数名。例如，Array对像的class值是Array，Function对象的class值是“Function”，Date对象的class值是“Date”，内部Math对象的class值是“Math”，所有Error对象的的class值是“Error”，用户定义的对象（例如Complex）的class值是“Object”。</p><h4 id="6-3-toLocaelString方法"><a href="#6-3-toLocaelString方法" class="headerlink" title="6.3 toLocaelString方法"></a>6.3 toLocaelString方法</h4><p>除了toString外，Object类还定义了toLocaleString方法，该方法返回该对象局部化的字符串表示。Object类默认定义的toLocaelString方法，本身并不做任何局部化，返回值和toString一样。但是Object的子类可以定义自己的toLocaleString方法，Array，Number,Date都定义了自己的toLocaelString方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let now &#x3D; new Date();</span><br><span class="line">now.toString()</span><br><span class="line">&quot;Fri Jan 08 2021 14:05:09 GMT+0800 (中国标准时间)&quot;</span><br><span class="line">now.toLocaleString()</span><br><span class="line">&quot;2021&#x2F;1&#x2F;8 下午2:05:09&quot;</span><br><span class="line"></span><br><span class="line">let num &#x3D; new Number(1);</span><br><span class="line">num.toString()</span><br><span class="line">&quot;1&quot;</span><br><span class="line">num.toLocaleString()</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure><h4 id="6-4-valueOf方法"><a href="#6-4-valueOf方法" class="headerlink" title="6.4 valueOf方法"></a>6.4 valueOf方法</h4><p>valueOf方法和toString方法非常相似，当需要把对象转化为非字符串之外的原始类型（通常是数字）时，就需要调用它。这个函数返回的是能代表this关键字所引用的对象的值的类型。</p><p>由于对象没有定义为原始类型的值，所以大多数对象都没有等价的原始值，因此由Object定义的valueOf方法不执行任何转换，只是返回调用它的对象。像Number和Boolean这样的类具有明显的原始等价值。</p><p>有时你可以定义一个合理的原始等价类型的类，需要为类定义一个valueOf方法，例如Complex，就定义了一个valueOf方法，返回实数部分。定义valueOf方法时，当某些环境中，当执行对象转字符串时，方法valueOf的优先级比toString高，这样当你定义了一个valueOf方法时，如果想转为字符串需要明确的调用toString方法，以Complex为例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Complex(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">alert(“c”+c);<span class="comment">//调用valueOf方法显示“c=3”</span></span><br><span class="line">alert(“c”+c.toString);<span class="comment">//显示“c=&#123;3,3&#125;”</span></span><br></pre></td></tr></table></figure><h4 id="6-5-hasOwnProperty"><a href="#6-5-hasOwnProperty" class="headerlink" title="6.5 hasOwnProperty"></a>6.5 hasOwnProperty</h4><p>如果对象局部定义了一个非继承的属性，属性名是由字符串实际参数指定的，那么该值返回true，否则返回false，例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.hasOwnProperty(“unde”);<span class="comment">//false</span></span><br><span class="line">o.hasOwnProperty(“toString”);<span class="comment">//false,toString 是一个继承属性</span></span><br><span class="line"><span class="built_in">Math</span>.hasOwnProperty(“cos”);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="6-6-propertyIsEnumerable-方法"><a href="#6-6-propertyIsEnumerable-方法" class="headerlink" title="6.6 propertyIsEnumerable()方法"></a>6.6 propertyIsEnumerable()方法</h4><p>如果对象定义了一个属性，由字符串实际参数指定的，而且该属性可以用for/in遍历出来，那么该方法返回true，否则返回false，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</span><br><span class="line">o.propertyIsEnumerable(“x”); <span class="comment">//true</span></span><br><span class="line">o.propertyIsEnumerable(“y”); <span class="comment">//false</span></span><br><span class="line">o.propertyIsEnumerable(“valueOf”); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>ECMAScript标准规定该方法只考虑对象直接定义的属性，不考虑对象的继承属性。</p><h4 id="6-7-isPrototypeOf方法"><a href="#6-7-isPrototypeOf方法" class="headerlink" title="6.7 isPrototypeOf方法"></a>6.7 isPrototypeOf方法</h4><p>如果调用对象是实际参数指定对象的原型对象，那么返回true，否则返回false，该方法用途和constructor属性相似：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(o);<span class="comment">//true  o.constructor == Object</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.isPrototypeOf(<span class="built_in">Object</span>); <span class="comment">//true  Object.constructor == Function</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-第七章-函数</title>
      <link href="/ZJY.github.io/2021/01/13/javascript-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%87%BD%E6%95%B0/"/>
      <url>/ZJY.github.io/2021/01/13/javascript-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="第七章-函数"><a href="#第七章-函数" class="headerlink" title="第七章-函数"></a>第七章-函数</h2><h3 id="1-函数定义和调用"><a href="#1-函数定义和调用" class="headerlink" title="1. 函数定义和调用"></a>1. 函数定义和调用</h3><p>定义函数最常用方法是function语句，该语句由function关键字构成，后面跟：</p><ul><li>函数名</li><li>一个括号括起来的参数列表，参数可选，多个参数用逗号分隔</li><li>构成函数主体的javascript语句，大括号括起来</li></ul><p>定义函数时可以使用个数可变的参数，而且函数既可以有return语句，也可以没有return语句，return语句使函数停止运行，并把结果返回给函数调用者。如果没有return语句，返回给调用者undefined.</p><h3 id="1-1-嵌套的函数"><a href="#1-1-嵌套的函数" class="headerlink" title="1.1 嵌套的函数"></a>1.1 嵌套的函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    funtion <span class="function"><span class="title">add</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> add(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-Function构造函数"><a href="#1-2-Function构造函数" class="headerlink" title="1.2 Function构造函数"></a>1.2 Function构造函数</h3><p>function语句并不是创建函数的唯一方式，在ECMAScript v1和javascript 1.1中还可以使用Function()构造函数和new运算符。<br>var f = new Function(“x”,”y”,”return x*y;”)<br>Function构造函数可以接收任意数量参数，最后一个参数是函数主体，没有参数可只传函数主体字符串参数。</p><h3 id="1-3-函数直接量"><a href="#1-3-函数直接量" class="headerlink" title="1.3 函数直接量"></a>1.3 函数直接量</h3><p>函数直接量是一个表达式，可以定义一个匿名函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">funtion <span class="function"><span class="title">f</span>(<span class="params">x,y</span>)</span>&#123;<span class="keyword">return</span> x*y；&#125; <span class="comment">//function语句</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Function</span>(“x”,”y”,”<span class="keyword">return</span> x*y;”)   <span class="comment">//Function构造函数</span></span><br><span class="line"><span class="keyword">var</span>  f = <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>) </span>&#123; <span class="keyword">return</span> x*y; &#125; <span class="comment">//函数直接量</span></span><br></pre></td></tr></table></figure><p>虽然函数直接量定义的是未命名函数，但也可以指定名称，在递归函数非常有用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = funtion <span class="function"><span class="title">fact</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x*fact(x-<span class="number">1</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码虽然定义了一个未命名函数，并把对他引用存储在变量f中，但并没有真正创建一个fact函数，只允许用这个名称引用自身</p><p>和Function构造函数一样，函数直接量创建的是匿名函数，而且不会自动地将这个函数存储在属性中。但是比起构造函数来，函数直接量又一个明显的优点。由Function构造函数创建的函数的主体，必须用一个字符串说明，用这种方式表达一个长而复杂的函数是非常笨拙的。<br>但是函数直接量的主体确是使用了javascript的语法。而且函数直接量只被解析和编译一次，而作为字符串传递给Function()函数的javascript代码则在每次调用该构造函数时只需被解析和编译一次。</p><h3 id="2-作为数据的函数"><a href="#2-作为数据的函数" class="headerlink" title="2. 作为数据的函数"></a>2. 作为数据的函数</h3><p>除了作为变量的值，还可以作为对象的属性，称为方法</p><h3 id="3-函数的作用域：调用对象"><a href="#3-函数的作用域：调用对象" class="headerlink" title="3. 函数的作用域：调用对象"></a>3. 函数的作用域：调用对象</h3><p>javascript函数的主体是在局部作用域中执行的，这个作用域通过把调用对象添加到作用域的头部创建的。<br>因为调用对象是作用域链的一部分，所以在函数体内可以把这个对象属性作为变量来访问。<br>var语句声明的变量作为调用对象的属性，函数形参也可用于对象的属性。</p><p>除了局部变量和形式参数外，调用对象还定义了一个属性：arguments，这个属性引用了另外一个Arguments对象。arguments应作为保留字。</p><h3 id="4-函数的实际参数：Arguments对象"><a href="#4-函数的实际参数：Arguments对象" class="headerlink" title="4. 函数的实际参数：Arguments对象"></a>4. 函数的实际参数：Arguments对象</h3><p>在一个函数体内，标识符arguments具有特殊含义。他是调用对象的一个属性，用来引用Arguments对象。Arguments对象就像一个数组，可以通过数字获取传递给函数的参数值。<br>但它并非真正但Array对象。用参数名改变参数值也会改变通过arguments[]取的值。</p><h4 id="4-1-属性callee"><a href="#4-1-属性callee" class="headerlink" title="4.1 属性callee"></a>4.1 属性callee</h4><p>除了数组元素，arguments对象还定义了callee属性。用来引用当前正在执行的函数。对未命名的函数非常有用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="built_in">arguments</span>.callee(x-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-函数的属性和方法"><a href="#5-函数的属性和方法" class="headerlink" title="5. 函数的属性和方法"></a>5. 函数的属性和方法</h3><p>在javascript程序中，函数可以用作数值，也可以通过Function()构造函数创建函数，所以函数是对象，Function对象，拥有属性和方法。</p><h4 id="5-1-属性length"><a href="#5-1-属性length" class="headerlink" title="5.1 属性length"></a>5.1 属性length</h4><p>在函数主体中，arguments数组的length属性指定了函数实际参数数目。<br>但是函数自身的length属性并非如此，它是只读特性，返回的是函数形式参数列表中声明的形式参数的数目。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = args.length; <span class="comment">//实际的参数个数</span></span><br><span class="line">    <span class="keyword">var</span> actualLen = args.callee.length <span class="comment">//声明的参数个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-属性prototype"><a href="#5-2-属性prototype" class="headerlink" title="5.2 属性prototype"></a>5.2 属性prototype</h4><p>每个函数都有一个prototype属性，引用的是预定义的原型对象。原型对象在使用new运算符把函数作为构造函数时起作用。它在定义新的对象类型时起着非常重要的作用。</p><h4 id="5-3-定义你自己的函数属性"><a href="#5-3-定义你自己的函数属性" class="headerlink" title="5.3 定义你自己的函数属性"></a>5.3 定义你自己的函数属性</h4><p>当函数需要在调用过程中始终不变的一个值时，使用Function对象的属性比定义一个全局变量更加方便。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test.counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> test.counter++;</span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">//0</span></span><br><span class="line">test(); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><h4 id="5-4-方法apply-和call"><a href="#5-4-方法apply-和call" class="headerlink" title="5.4 方法apply()和call()"></a>5.4 方法apply()和call()</h4><p>所有函数都定义了apply()和call()方法。<br>第一个参数都是要调用的函数对象，在函数体内这个关键词是this的值。<br>call()的剩余参数是传递给调用函数的值，例如要把两个数字传递给函数f，并把它作为对象o的方法调用，可以使用如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.call(o, <span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>apply()要传递的参数是一个数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.apply(o, [<span class="number">1</span>, <span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p>比如要找到数字数组中最大值，可以用apply方法把数组传递给Math.max:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> biggest = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, array_number);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-第六章-语句</title>
      <link href="/ZJY.github.io/2021/01/13/javascript-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%AF%AD%E5%8F%A5/"/>
      <url>/ZJY.github.io/2021/01/13/javascript-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="第六章-语句"><a href="#第六章-语句" class="headerlink" title="第六章-语句"></a>第六章-语句</h2><h3 id="1-表达式语句"><a href="#1-表达式语句" class="headerlink" title="1. 表达式语句"></a>1. 表达式语句</h3><p>递增（++）和递减（–）运算符，delete运算符，函数调用，被作为语句使用，因为都改变了值，而不仅仅是表达式的一部分。</p><h3 id="2-复合语句"><a href="#2-复合语句" class="headerlink" title="2. 复合语句"></a>2. 复合语句</h3><p>复合语句就是用花括号括起来，将几个语句联合起来形成语句块。js语句可以包含别的语句，这样的语句叫复合语句。<br>正式的javascript语法规定每个复合语句可以包含一个子语块。那么使用语句块可以将任意数量语句放在子语块中。<br>javascript解释器执行复合语句时，按照编写顺序执行语句。通常javascript语句会执行完所有语句，但复合语句中若含有break语句、continue语句、return或throw语句，或它引发了错误等会被终止。</p><h3 id="3-if语句"><a href="#3-if语句" class="headerlink" title="3. if语句"></a>3. if语句</h3><p>条件控制语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(express) <span class="comment">//null、undefined、0、“”、NaN值为false</span></span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><h3 id="4-else-if语句"><a href="#4-else-if语句" class="headerlink" title="4. else if语句"></a>4. else if语句</h3><p>用来执行多个条件语句，实际上是if/else嵌套</p><h3 id="5-switch语句"><a href="#5-switch语句" class="headerlink" title="5. switch语句"></a>5. switch语句</h3><p>用于重复检测同一个变量的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(express)&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span>(n)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        statement</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        statement</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数调用中可以用return替换break语句.<br>case使用===等同运算符匹配的，如果没有匹配值就执行default:，如果没有default：就跳过主体，default:语句可以放置任何位置。</p><h3 id="6-while语句"><a href="#6-while语句" class="headerlink" title="6. while语句"></a>6. while语句</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(express)</span><br><span class="line">    statement</span><br><span class="line">    <span class="comment">//express表达式值为true，执行statement循环体</span></span><br></pre></td></tr></table></figure><h3 id="7-do-while语句"><a href="#7-do-while语句" class="headerlink" title="7. do/while语句"></a>7. do/while语句</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">while</span>(express);</span><br></pre></td></tr></table></figure><p>循环体至少会被执行一次。用分号结尾.</p><h3 id="8-for语句"><a href="#8-for语句" class="headerlink" title="8. for语句"></a>8. for语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(initalize; test ; increment) &#x2F;&#x2F;初始化、检测、更新</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><h3 id="9-for-in语句"><a href="#9-for-in语句" class="headerlink" title="9. for/in语句"></a>9. for/in语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(variable in object)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><p>variable是一个变量名，声明一个变量的var语句或者对象的一个属性或者数组的一个元素。</p><p>object是一个对象名或者计算结果为对象的表达式。for/in循环主体对object对象对每个属性执行一次，循环体执行之前，对象的属性名会被作为字符串赋值给variable.在循环体内部可以通过object[varible]访问属性的值    。variable可以是任意表达式。</p><p>for/in循环体并没有指定将对象属性赋给循环变量的顺序。for/in会遍历对象所有可能属性。对象属性被标记不可枚举的不可被遍历出来。</p><h3 id="10-标签语句"><a href="#10-标签语句" class="headerlink" title="10. 标签语句"></a>10. 标签语句</h3><p>identifier：statement，标签语句：标识符加冒号<br>标识符identifier可以是合法的js标识符，不能是保留字，标识符不同于变量名和函数名，所以不用担心重名。给语句添加标识符，起一个名字可以在任意地方引用。</p><h3 id="11-break语句"><a href="#11-break语句" class="headerlink" title="11. break语句"></a>11. break语句</h3><p>break语句会使包含在最内层的循环体立即结束或退出switch语句。语句很简单：<br>    break;<br>当break后面跟标签时，它会跳到标签语句结尾或者终止这个语句。break labelname；</p><h3 id="12-continue语句"><a href="#12-continue语句" class="headerlink" title="12. continue语句"></a>12. continue语句</h3><ul><li><p>continue语句退出当前循环，执行下一次循环，continue;</p></li><li><p>continue语句可以和标签一起使用在ecmascript v3和js1.2中，continue labelname;</p></li><li><p>continue语句只可以出现在while、for、do/while、for/in循环语句体中。<br>执行continue语句时，当前迭代就会终止，开始下一次迭代，这对不同循环是不同的：</p><ul><li>while循环中，会再次检测循环条件，如果是true，继续下一次迭代</li><li>do/while循环中，会跳到循环的底部，开始下一次迭代前首先判断循环条件</li><li>for循环中，会先更新循环变量值，再判断循环条件是否继续下一次迭代</li><li>for/in循环中，以下一个循环属性赋值给变量开始新的迭代</li></ul></li></ul><h3 id="13-var语句"><a href="#13-var语句" class="headerlink" title="13. var语句"></a>13. var语句</h3><p>var语句允许你明确的声明一个或多个变量。如果声明多个变量，用逗号隔开，并可选的初始化声明的变量值。</p><p>var语句通过在封闭函数的调用对象中创建同名的属性来定义变量，如果不在函数内，就在全局对象中创建同名属性来定义变量。</p><p>由var语句创建的特性不能被delete运算符删除。</p><h3 id="14-function语句"><a href="#14-function语句" class="headerlink" title="14. function语句"></a>14. function语句</h3><p>function语句定义了js函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcname</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数体内语句定义时不会被执行，在使用函数调用（）运算符调用时才执行编译。<br>函数定义在解析时发生而不是在运行时发生。<br>函数定义通常出现在代码顶层，它们也可以嵌套在其他函数定义中，但是只能嵌套在函数顶层定义中，也就是说函数定义不能出现在if语句，while循环或其他语句中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(f(<span class="number">4</span>)); <span class="comment">//16，可以在定义f()前调用它</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="number">0</span>; <span class="comment">//该语句重写属性f</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x*x&#125;</span><br><span class="line">alert(f); <span class="comment">//0，函数f已经被变量f覆盖</span></span><br></pre></td></tr></table></figure><h3 id="15-return语句"><a href="#15-return语句" class="headerlink" title="15. return语句"></a>15. return语句</h3><p>运算符()调用函数是一个表达式，表达式的值通过return语句返回。return只能出现在函数体内，出现在其他地方会造成语法错误。return expression;<br>在执行return语句时，会先计算表达式的值，然后返回它的值作为函数的值</p><h3 id="16-throw语句"><a href="#16-throw语句" class="headerlink" title="16. throw语句"></a>16. throw语句</h3><p>所谓异常（exception）就是一个信号，说明发生了某种异常状况或错误。<br>抛出（throw）一个异常，就是用信号通知发生了错误或异常状况。<br>捕获（catch）一个异常就是处理它，即采取必要或适当的行为从异常恢复。在js中，当发生了运行时错误或用throw语句就会抛出异常。<br>throw expression;expression可以是任意类型，通常是Error类或子类的实例。<br>在抛出异常时，javascript解释器会立即停止正常的程序执行，跳到距离最近的异常处理器，即catch语句中。<br>如果抛出的异常中没有catch语句，即会检测次高级封闭代码块，查看是否有异常处理器，直到没有找到为止。</p><h3 id="17-try-catch-finally语句"><a href="#17-try-catch-finally语句" class="headerlink" title="17. try/catch/finally语句"></a>17. try/catch/finally语句</h3><p>try/catch/finally是javascript的异常处理机制。<br>try语句定义异常需要被处理的代码块。<br>catch发生异常时调用的语句块。<br>finally存放清除代码，无论try发生什么，都会被执行。<br>catch和finally都是可选的。但是try块至少跟一个catch或finally块。</p><p>通常情况下,控制流到达try块的尾部,然后开始执行 finally块,以便进行清除操作。如果由于 return语句、 continue句或 break语句使控制流离开了try块,那么在控制流转移到新目的地前, finally块就会被执行。</p><p>如果异常发生在try块中,而且存在一个相关的 catch块处理异常,控制流首先将转移到 catch块,然后再转移到fina1l块。如果没有处理异常的局部 catch块,控制流首先将转移到 finally块,然后向上传播到最近的能够处理异常的 catch从句。</p><p>如果 finally块自身用 return语句、 continue语句、 break语句或 throw语句转移了控制流,或者调用了抛出异常的方法改变了控制流,那么等待的控制流转移将被舍弃,并进行新的转移。例如,如果 finally从句抛出了一个异常,那么该异常将代替处于抛出过程中的异常。如果 finally从句运行到了 return语句,那么即使已经抛出了一个异常,而且该异常还没有被处理,该方法也会正常返回。</p><h3 id="18-with语句"><a href="#18-with语句" class="headerlink" title="18. with语句"></a>18. with语句</h3><p>with语句用于暂时修改作用域链。with (object) statement<br>这一语句能够有效的将object添加到作用域链的顶部，然后执行statement语句，再把作用域链恢复到初始状态。<br>在实际应用中,使用with语句可以减少大量的输入。例如,在客户端的 JavaScript中,深度嵌套的对象层次很常用。例如,可以输入如下的表达式来访问一个HTML表单的元素:</p><p> frames[1].document.forms[0].address.value</p><p>如果需要多次访问这个表单,可以使用with语句将这个表单添加到作用域链中:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">with</span>(<span class="params">frames [<span class="number">1</span>].<span class="built_in">document</span>.forms[<span class="number">0</span>]</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//此处直接访问表单元素</span></span><br><span class="line">    name.value = ‘’;</span><br><span class="line">    address.value = ‘’;</span><br><span class="line">    email.value = ‘’;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然有时使用with语句比较方便,但是人们反对使用它。使用了with语句的javaScript代码很难优化,因为它的运行速度比不使用with语句的等价代码要慢得多。而且,在with语句中的函数定义和变量初始化可能会产生令人惊讶的、相抵触的行为。因此,我们建议避免使用with语句。</p><p>注意,还有其他的、极为合理的方法可以用来节省输入。例如,上面使用with语句可重写为:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> form= frames[<span class="number">1</span>]. <span class="built_in">document</span>. forms[<span class="number">0</span>]</span><br><span class="line">form.name. value=<span class="string">&quot;</span></span><br><span class="line"><span class="string">form. address. value =&quot;</span><span class="string">&quot; form. email. value =&quot;</span><span class="string">&quot;</span></span><br></pre></td></tr></table></figure><h3 id="19-空语句"><a href="#19-空语句" class="headerlink" title="19. 空语句"></a>19. 空语句</h3><p>javascript中最后一个合法语句是空语句: ;</p><p>执行空语句显然不会产生任何作用,也不会执行任何动作。你可能认为使用这样一个语句是毫无意义的,但实践证明,当你想创建一个具有空主体的循环时,空语句是有用的。例如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化数组a</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt; a. length; a[i++] =<span class="number">0</span>) ;</span><br></pre></td></tr></table></figure><p>注意,在for循环、 while循环或者if语句的右括号后加分号会产生bug,这些bug很难被检测出来。例如,下面的代码产生的结果并不是作者想要的:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((a==<span class="number">0</span>) || (b==<span class="number">0</span>));/这行什么都不做</span><br><span class="line">o =<span class="literal">null</span>; <span class="comment">//这行总会被执行</span></span><br></pre></td></tr></table></figure><p>当你打算使用空语句时,最好在代码中使用注释,以清楚地说明是有目的地这样做。例如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;a. length;a[i++]=<span class="number">0</span>)<span class="comment">/*空函数体*/</span> ;</span><br></pre></td></tr></table></figure><h3 id="20-javascript语句小结"><a href="#20-javascript语句小结" class="headerlink" title="20.javascript语句小结"></a>20.javascript语句小结</h3><table><thead><tr><th align="center">语句</th><th align="center">语法</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">break</td><td align="center">break; <br> break labelname;</td><td align="center">退出最内层循环或者退出switch语句，又或者退出label指定的语句</td></tr><tr><td align="center">case</td><td align="center">case expression</td><td align="center">在switch语句中标记一个语句</td></tr><tr><td align="center">continue</td><td align="center">continue;<br>  continue labelname;</td><td align="center">重新开始新的循环或开始指定的label循环</td></tr><tr><td align="center">default</td><td align="center">default:</td><td align="center">在switch语句中指定默认语句</td></tr><tr><td align="center">do/while</td><td align="center">do statement <br> while(expression)</td><td align="center">while循环另一种形式</td></tr><tr><td align="center">空语句</td><td align="center">;</td><td align="center">什么都不做</td></tr><tr><td align="center">for</td><td align="center">for(init;test;increment) statement</td><td align="center">循环</td></tr><tr><td align="center">for/in</td><td align="center">for(variable in object) statement</td><td align="center">遍历一个对象的属性</td></tr><tr><td align="center">function</td><td align="center">function funname(expression){statement}</td><td align="center">函数声明</td></tr><tr><td align="center">if/else</td><td align="center">if(expression){statement} <br> else{}</td><td align="center">条件控制</td></tr><tr><td align="center">label</td><td align="center">identifier: statement</td><td align="center">给语句块指定一个标识符</td></tr><tr><td align="center">return</td><td align="center">return expression</td><td align="center">返回函数值</td></tr><tr><td align="center">switch</td><td align="center">switch(expression){statement}</td><td align="center">由case或default语句标记的多分支语句</td></tr><tr><td align="center">throw</td><td align="center">throw exception</td><td align="center">抛出一个异常</td></tr><tr><td align="center">try</td><td align="center">try{statement} <br> catch(e){statement}<br>  finally{statement}</td><td align="center">捕捉一个异常</td></tr><tr><td align="center">var</td><td align="center">var name1 = value</td><td align="center">声明或初始化变量</td></tr><tr><td align="center">while</td><td align="center">while(expression){statement}</td><td align="center">循环</td></tr><tr><td align="center">with</td><td align="center">with(object) statement</td><td align="center">扩展当前作用域链（不支持使用）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-第五章-表达式和运算符</title>
      <link href="/ZJY.github.io/2021/01/10/javascript-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/ZJY.github.io/2021/01/10/javascript-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="第五章-表达式和运算符"><a href="#第五章-表达式和运算符" class="headerlink" title="第五章-表达式和运算符"></a>第五章-表达式和运算符</h2><h3 id="1-表达式"><a href="#1-表达式" class="headerlink" title="1. 表达式"></a>1. 表达式</h3><p>最简单的表达式可以是直接量或者变量名。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">‘javascript’</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line">num</span><br></pre></td></tr></table></figure><p>直接量表达式的值是直接量本身，变量表达式的值是变量存放的值或引用的值。</p><h3 id="2-运算符概述"><a href="#2-运算符概述" class="headerlink" title="2. 运算符概述"></a>2. 运算符概述</h3><p>有些运算符由标点符号表示+ -，有些是由关键字表示，delete /instanceof</p><table><thead><tr><th align="center">P（运算符优先级）</th><th align="center">A（结合性：L/R）</th><th align="center">运算符</th><th align="center">运算数类型</th><th align="center">所执行的操作</th></tr></thead><tbody><tr><td align="center">15</td><td align="center">L</td><td align="center">.</td><td align="center">对象，标识符</td><td align="center">属性存取</td></tr><tr><td align="center"></td><td align="center">L</td><td align="center">[]</td><td align="center">数组，整数</td><td align="center">数组下标</td></tr><tr><td align="center"></td><td align="center">L</td><td align="center">()</td><td align="center">函数，参数</td><td align="center">函数调用</td></tr><tr><td align="center"></td><td align="center">R</td><td align="center">new</td><td align="center">构造函数调用</td><td align="center">创建新对象</td></tr><tr><td align="center">14</td><td align="center">R</td><td align="center">++</td><td align="center">lvalue</td><td align="center">先递增或后递增的运算（一元的）</td></tr><tr><td align="center"></td><td align="center">R</td><td align="center">–</td><td align="center">lvalue</td><td align="center">先递减或后递减的运算（一元的）</td></tr><tr><td align="center"></td><td align="center">R</td><td align="center">-</td><td align="center">数字</td><td align="center">一元减法（负）</td></tr><tr><td align="center"></td><td align="center">R</td><td align="center">+</td><td align="center">数字</td><td align="center">一元加法）</td></tr><tr><td align="center"></td><td align="center">R</td><td align="center">~</td><td align="center">数字</td><td align="center">按位取补码的操作（一元的）</td></tr><tr><td align="center"></td><td align="center">R</td><td align="center">!</td><td align="center">布尔值</td><td align="center">取逻辑补码的操作（一元的）</td></tr><tr><td align="center"></td><td align="center">R</td><td align="center">delete</td><td align="center">lvalue</td><td align="center">删除一个属性（一元的）</td></tr><tr><td align="center"></td><td align="center">R</td><td align="center">typeof</td><td align="center">任意</td><td align="center">返回数据类型（一元的）</td></tr><tr><td align="center"></td><td align="center">R</td><td align="center">void</td><td align="center">任意</td><td align="center">返回未定义的值（一元的）</td></tr><tr><td align="center">13</td><td align="center">L</td><td align="center">*,/,%</td><td align="center">数字</td><td align="center">乘法，除法， 取余运算</td></tr><tr><td align="center">12</td><td align="center">L</td><td align="center">+,-</td><td align="center">数字</td><td align="center">加法，减法运算</td></tr><tr><td align="center"></td><td align="center">L</td><td align="center">+</td><td align="center">字符串</td><td align="center">连接字符串</td></tr><tr><td align="center">11</td><td align="center">L</td><td align="center">&lt;&lt;</td><td align="center">整数</td><td align="center">左移</td></tr><tr><td align="center"></td><td align="center">L</td><td align="center">&gt;&gt;</td><td align="center">整数</td><td align="center">带符号扩展的右移</td></tr><tr><td align="center"></td><td align="center">L</td><td align="center">&gt;&gt;&gt;</td><td align="center">整数</td><td align="center">带零扩展的右移</td></tr><tr><td align="center">10</td><td align="center">L</td><td align="center">&lt;, &lt;=</td><td align="center">数字或字符串</td><td align="center">小于或小于等于</td></tr><tr><td align="center"></td><td align="center">L</td><td align="center">&gt;, &gt;=</td><td align="center">数字或字符串</td><td align="center">大于或大于等于</td></tr><tr><td align="center"></td><td align="center">L</td><td align="center">instanceof</td><td align="center">对象，构造函数</td><td align="center">检测对象类型</td></tr><tr><td align="center"></td><td align="center">L</td><td align="center">in</td><td align="center">字符串，对象</td><td align="center">检查一个属性是否存在</td></tr><tr><td align="center">9</td><td align="center">L</td><td align="center">==</td><td align="center">任意</td><td align="center">测试相等性</td></tr><tr><td align="center"></td><td align="center">L</td><td align="center">!=</td><td align="center">任意</td><td align="center">测试非相等性</td></tr><tr><td align="center"></td><td align="center">L</td><td align="center">===</td><td align="center">任意</td><td align="center">测试等同性</td></tr><tr><td align="center"></td><td align="center">L</td><td align="center">!==</td><td align="center">任意</td><td align="center">测试非等同性</td></tr><tr><td align="center">8</td><td align="center">L</td><td align="center">&amp;</td><td align="center">整数</td><td align="center">按位与操作</td></tr><tr><td align="center">7</td><td align="center">L</td><td align="center">^</td><td align="center">整数</td><td align="center">按位异或操作</td></tr><tr><td align="center">6</td><td align="center">L</td><td align="center">`</td><td align="center">`</td><td align="center">整数</td></tr><tr><td align="center">5</td><td align="center">L</td><td align="center">&amp;&amp;</td><td align="center">布尔值</td><td align="center">逻辑与操作</td></tr><tr><td align="center">4</td><td align="center">L</td><td align="center">`</td><td align="center"></td><td align="center">`</td></tr><tr><td align="center">3</td><td align="center">R</td><td align="center">？：</td><td align="center">布尔值、任意、任意</td><td align="center">条件运算符</td></tr><tr><td align="center">2</td><td align="center">R</td><td align="center">=</td><td align="center">任意</td><td align="center">赋值运算</td></tr><tr><td align="center"></td><td align="center">R</td><td align="center">*=，/=，%=，+=，-=，&lt;&lt;=,&gt;&gt;=,&gt;&gt;&gt;=,&amp;=,</td><td align="center">=</td><td align="center">任意</td></tr><tr><td align="center">1</td><td align="center">L</td><td align="center"></td><td align="center">任意</td><td align="center">多重计算的操作</td></tr></tbody></table><h4 id="2-1-运算数的个数"><a href="#2-1-运算数的个数" class="headerlink" title="2.1 运算数的个数"></a>2.1 运算数的个数</h4><p>一元运算符: -3 //取反<br>二元运算符： +<br>三元运算符： ?:</p><h4 id="2-2-运算数的优先级"><a href="#2-2-运算数的优先级" class="headerlink" title="2.2 运算数的优先级"></a>2.2 运算数的优先级</h4><p>乘法和除法是优先与加法和减法执行的，赋值的操作优先级很低，几乎最后执行。用括号可以提高优先级。</p><h4 id="2-3-运算数的结合性"><a href="#2-3-运算数的结合性" class="headerlink" title="2.3 运算数的结合性"></a>2.3 运算数的结合性</h4><p>L表示结合性从左到右，R表示结合性从右到左，一个运算符的结合性说明了优先级相等时执行操作的顺序。</p><h3 id="3-算术运算符"><a href="#3-算术运算符" class="headerlink" title="3. 算术运算符"></a>3. 算术运算符</h3><p><b>加法运算符（+）：</b><br>    运算符“+”可以对数字进行加法运算，也可以对字符串进行连接操作。如果一个运算数是字符串，那么另一个运算数会被转换成字符串，进行连接操作。如果“+”运    算符对一个运算数是对象，那么它会把对象转换成可以进行加法运算或者连接操作对数字或字符串，这一转换通过调用对象的valueOf()/toString()来执行的。</p><p><b>减法运算符（-）：</b><br>    把运算符“-”用于二元操作时，它将从第一个运算数减取第二个运算数。如果运算数是非数字的，会将它们转换成数字。</p><p><b>乘法运算符（<em>）：</b><br>    运算符“</em>”会把两个运算数相乘，如果运算数是非数字的，运算符“*”会将它们转换成数字。</p><p><b>除法运算符（/）：</b><br>    运算符“/”将用第一个运算数除以第二个运算数。如果运算数为非数字，则运算符“/”会将它们转为数字。除数为0的结果为正无穷或负无穷。0/0结果为NaN。<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>/<span class="number">0</span> <span class="comment">// Infinity</span></span><br><span class="line">-<span class="number">4</span>/<span class="number">0</span> <span class="comment">//-Infinity</span></span><br><span class="line"><span class="number">0</span>/<span class="number">0</span> <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure><br><b>模运算符（%）：</b><br>    模运算符计算的是第一个运算数对第二个运算数对模，即余数。如果运算数是非数字的，运算符“%”会将它们转换为数字。结果和第一个运算数符号相同。<br>    5%2 // 1<br>    -5%2 //-1<br>    取模运算符也适用于浮点型数字。</p><p><b>一元减法运算符（-）：</b><br>    当“-”被用于一元操作前（一个运算数前），它将执行一元取反操作。如果运算数是非数字的，运算符“-”会将它们转换为数字</p><p><b>一元加法运算符（+）：</b><br>    var a = +10000;”+”什么都没做，只计算参数的值。对于非数字型的运算符，会将运算数转为数字，如果不能被转换，将返回NaN.<br>    +’123’ //123<br>    +’1we’ //NaN</p><p><b>递增运算符（++）：</b><br>    运算符“++”对唯一运算数进行递增操作，如果运算数为非数字，会转为数字。<br>    i = 1; j = ++i;  // i:2,j:2<br>    i = 1; k = i++; //i:2, k:1<br>    如果运算符位于运算数前，即先递增，然后用运算数增长后值计算。<br>    如果运算符位于运算数后，即先运算，后递增，运算的是递增前的值。</p><p><b>递减运算符（–）：</b><br>    运算符“–”是对它惟一的数字运算数进行逆减操作的(如每次减1)，这个运算数必须是一个变量、数组的一个元素或者对象的一个属性。如果该变量元素或属性的值不是数字，运算符“-”首先会将它转换成一个数字。和运算符“++”一样，运算符“-”的实际行为是由它相对于运算数的位置决定的。<br>    如果它位于运算数之前，它就先减少运算数的值，并且返回减少后的运算数的直。如果它位于运算数之后，它将减少运算数的值，但是返回的却是没有减少的值。</p><h3 id="4-相等运算符"><a href="#4-相等运算符" class="headerlink" title="4. 相等运算符"></a>4. 相等运算符</h3><p>相等运算符“==”和等同运算符“===”用于计算两个值是否相等，根据结果返回布尔值。</p><h4 id="4-1-相等运算符（-）和等同运算符（-）"><a href="#4-1-相等运算符（-）和等同运算符（-）" class="headerlink" title="4.1 相等运算符（==）和等同运算符（===）"></a>4.1 相等运算符（==）和等同运算符（===）</h4><p>“==”和“===”都用于检测两个值是否相等。这两个运算符都接受任意类型都运算数。“===”是等同运算符，它采用严格都同一性定义检测两个运算数是否相同。“==”是相等运算符，它采用比较宽松的同一性（允许类型转换）定义检测两个数是否相等。</p><p><b>判断===运算符比较的两个值是否完全相等：</b></p><ul><li><p>如果两个值的类型不同，它们就不相等.</p></li><li><p>如果两个值是数字，而且值相同，那么除非其中一个或两个值都为NaN，否则它们是等同的。值NaN永远不会与其他任何值等同，包括它自身。可用全局函数isNaN（）检测值是否是NaN。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span>==<span class="literal">NaN</span> <span class="comment">//false   NaN===NaN //false</span></span><br></pre></td></tr></table></figure></li><li><p>如果两个值是字符串，而且串中同一位置上字符完全相同，那么它们就是完全等同。如果字符串内容或长度不同，它们就不是等同的。</p></li><li><p>如果两个值都是布尔值true或false，那么它们等同。</p></li><li><p>如果两个值引用的是同一个对象，数组或函数，那么它们完全等同。如果它们引用是不同的对象，即使这两个对象具有完全相同的属性或具有完全相同的元素，它们也不等同。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;<span class="keyword">var</span> b = a; <span class="keyword">var</span> c = &#123;&#125;; <span class="keyword">var</span> d = c; b == d; <span class="comment">//false</span></span><br></pre></td></tr></table></figure></li><li><p>如果两个值都是null或undefined，那么它们完全相同。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true null === undefined //false </span></span><br></pre></td></tr></table></figure></li></ul><p><b>判断==运算符比较的两个值是否相等：</b></p><ul><li>如果两个值具有相同的类型，判断两个值是否相同，如果相同就相等</li><li>如果两个值类型不同，仍然有可能相等。<ul><li>如果一个值是null，另一个值是undefined，它们相等</li><li>如果一个值是数字，另一个值是字符串，把字符串转为数字，再用转换后值比较。</li><li>如果一个值是true,将它转换为1，再进行比较，如果是false，转换为0再比较</li><li>如果一个值是对象，另一个值是数字或字符串，将对象转换为原始类型的值再进行比较。可以使用对象的toString()方法或valueOf()方法将对象转换为原始类型的值。javascript核心语言的内部类通常先尝试valueOf()转换，再尝试toString()转换，但对于Date类，则先执行toString()转换。不属于javascript核心语言的对象可以采用js实现定义的方式把自身转换为原始数值。</li><li>其他的数值组合是不相等的。</li></ul></li></ul><p>如下代码是一个测试相等性的例子，带有类型转换： “1” == true ,true会先转换为1，字符串“1”会转为数字1，结果为true</p><h4 id="4-2-不等运算符（-）和不等同运算符（-）"><a href="#4-2-不等运算符（-）和不等同运算符（-）" class="headerlink" title="4.2 不等运算符（!=）和不等同运算符（!==）"></a>4.2 不等运算符（!=）和不等同运算符（!==）</h4><p>运算符（!=）和（！==）检测情况和（==）和（===）结果相反</p><h3 id="5-关系运算符"><a href="#5-关系运算符" class="headerlink" title="5. 关系运算符"></a>5. 关系运算符</h3><h4 id="5-1-比较运算符"><a href="#5-1-比较运算符" class="headerlink" title="5.1 比较运算符"></a>5.1 比较运算符</h4><p>比较运算符用来确定两个值的相对顺序。包括：</p><ul><li>小于运算符(＜）<ul><li>如果运算符＜的第一个运算数小于它的第二个运算数，它计算的值就为true否则它计算的值为fa1se</li></ul></li><li>大于运算符(＞)<ul><li>如果运算符＞的第一个运算数大于它的第二个运算数，它计算的值就为true，否则计算的值为 false</li></ul></li><li>小于等于运算符(＜=）<ul><li>如果运算符≤=的第一个运算数小于或等于第二个运算数，那么它计算的值就为true，否则计算的值为 false。</li></ul></li><li>大于等于运算符(&gt;=）<ul><li>如果运算符&gt;=的第一个运算数大于或等于第二个运算数，那么它计算的值就为true，否则计算的值为 false。</li></ul></li></ul><p>这些比较运算符的运算数可以是任意类型的，但是只能在数字和字符串上执行比较操作，所有不是数字或字符串的类型将会被转换为数字或字符串。比较和转换规则如下：</p><ul><li>如果两个运算数是数字或者都被转换成了数字，那么将采取数字比较。</li><li>如果两个运算数是字符串或都被转换成了字符串，那么将作为字符串进行比较。</li><li>如果一个运算数是字符串，或者被转换成了字符串，另一个运算数是数字，或者被转换成了数字，那么运算符将会把字符串转换为数字，执行数字比较。如果字符串不代表数字，它将会转换为NaN，比较结果是false。</li><li>如果对象可以被转换为数字或字符串，那么将执行数字转换。例如，比较date对象，可以从数字角度比较。</li><li>如果运算数都不能被转换为数字或字符串，那么结果返回false。</li><li>如果某个运算数是NaN，或者被转换成了NaN，那么结果返回false。</li></ul><h4 id="5-2-in运算符"><a href="#5-2-in运算符" class="headerlink" title="5.2 in运算符"></a>5.2 in运算符</h4><p>in运算符要求做不运算数是一个字符串，或可以被转为字符串，右边的运算数是一个对象或数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> point = &#123; <span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">1</span>&#125;</span><br><span class="line">“x” <span class="keyword">in</span> point;<span class="comment">//true</span></span><br><span class="line">“y” <span class="keyword">in</span> point;<span class="comment">//true</span></span><br><span class="line">“z” <span class="keyword">in</span> point; <span class="comment">//false</span></span><br><span class="line">“toString” <span class="keyword">in</span> point; <span class="comment">//继承属性，true</span></span><br></pre></td></tr></table></figure><h4 id="5-3-instanceof运算符"><a href="#5-3-instanceof运算符" class="headerlink" title="5.3 instanceof运算符"></a>5.3 instanceof运算符</h4><p>instanceof要求左边运算数是一个对象，右边运算数是对象类的名字。所有对象都是Object类的实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">d <span class="keyword">instanceof</span> <span class="built_in">Date</span>; <span class="comment">//true</span></span><br><span class="line">d <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">//true</span></span><br><span class="line">d <span class="keyword">instanceof</span> <span class="built_in">Number</span>; <span class="comment">//false</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">//true</span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">//true</span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>; <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>如果instanceof运算符的左边不是对象，或者右边运算数是一个对象，而不是构造函数，他将返回false. 另外，如果它右边运算数不是一个对象，他将返回运行时错误。</p><h3 id="6-字符串运算符"><a href="#6-字符串运算符" class="headerlink" title="6. 字符串运算符"></a>6. 字符串运算符</h3><p>有几个运算符在运算数是字符串时具有特殊的作用。<br>运算符“+”将连接两个字符串运算数：</p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“hello”+“ ”+“there”； <span class="comment">//hello there</span></span><br></pre></td></tr></table></figure></code></pre><p>运算符&lt;,&lt;=,&gt;,&gt;=将通过比较两个字符串来确定它们顺序。比较采用字母顺序，基于unicode编码标准。所有Latin字母表的大写字母都位于小写字母之前（即小于）。<br>运算符+比较特殊，它给予字符串运算数的优先级比数字运算数高。如果该运算符的一个运算数是字符串，那么另一个将被转换为字符串。进行连接操作。另一方面，如果比较运算符的两个运算数都是字符串，将进行字符串比较;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span> ； <span class="comment">//加法：3</span></span><br><span class="line">“<span class="number">1</span>”+ <span class="number">2</span>;  <span class="comment">//连接运算：“12”</span></span><br><span class="line">“<span class="number">1</span>”+ <span class="number">2</span>； <span class="comment">//连接运算： “12”</span></span><br><span class="line"><span class="number">11</span> &lt; <span class="number">3</span>；<span class="comment">//数字比较运算： false</span></span><br><span class="line">“<span class="number">11</span>” &lt; “<span class="number">3</span>”; <span class="comment">//字符串比较运算； true</span></span><br><span class="line">“<span class="number">11</span>” &lt; <span class="number">3</span>； <span class="comment">//数字比较运算：“11”被转换为11，false，如果只有一个是字符串，那么js会把它转换为数字。</span></span><br><span class="line">“one” &lt; <span class="number">3</span> <span class="comment">//数字比较运算：“one”转换为NaN,false</span></span><br></pre></td></tr></table></figure><h3 id="7-逻辑运算符"><a href="#7-逻辑运算符" class="headerlink" title="7. 逻辑运算符"></a>7. 逻辑运算符</h3><h4 id="7-1-逻辑与运算符（-amp-amp-）"><a href="#7-1-逻辑与运算符（-amp-amp-）" class="headerlink" title="7.1 逻辑与运算符（&amp;&amp;）"></a>7.1 逻辑与运算符（&amp;&amp;）</h4><p>当运算符&amp;&amp;的两个运算数都是布尔值时,它对这两个运算数执行布尔AND操作,即当且仅当它的两个运算数都是true时,它才返回true如果其中一个或两个运算数值为 false,它就返回 false。</p><p>这个运算符的实际行为比较复杂。首先,它将计算第一个运算数,也就是位于它左边的表达式。如果这个表达式的值可以被转换成 false(例如,左边运算数的值为null、0或 undefined),那么运算符将返回左边表达式的值。否则,它将计算第二个运算数,也就是位于它右边的表达式,并且返回这个表达式的值。</p><p>if( a == b) stop(); 等价于(a==b) &amp;&amp; stop();</p><h4 id="7-2-逻辑或运算符（-）"><a href="#7-2-逻辑或运算符（-）" class="headerlink" title="7.2 逻辑或运算符（||）"></a>7.2 逻辑或运算符（||）</h4><p>当运算符Ⅱ的两个运算数都是布尔值时，它对这两个运算数执行布尔或操作，即如果它的两个运算数中有一个值为为true(或者两个都为为true)，那么它就返回为true。如果它的两个运算数值都为false、它就返回false.</p><p>虽然 || 运算符常用为布尔或运算符，但是它和&amp;&amp;运算符一样，行为是比较复杂的.首先，它要计算第一个运算数，即它左边的表达式的值.如果这个表达式的值可以被转换成是真的，那么它就返回左边这个表达式的值。否则，它将计算第二个运算数，即位于它右边的表达式，并且返回该表达式的值.</p><h4 id="7-3-逻辑非运算符"><a href="#7-3-逻辑非运算符" class="headerlink" title="7.3 逻辑非运算符(!)"></a>7.3 逻辑非运算符(!)</h4><p>逻辑非运算符是一个一元运算符，它放在一个运算数之前。它用来对运算数对布尔值取反。对任意值x应用两次该运算符（即!!x）都可以将它转换为一个布尔值。</p><h3 id="8-逐位运算符"><a href="#8-逐位运算符" class="headerlink" title="8. 逐位运算符"></a>8. 逐位运算符</h3><ul><li>按位与运算符(&amp;)<br>运算符&amp;对它的整型参数逐位执行布尔AND操作只有两个运算数中相应的位都为1、那么结果中的这一位才为1。例如，0x1234 &amp; 0x00FF=0×0034</li><li>按位或运算符(｜)<br>运算符｜对它的整型参数逐位执行布尔或操作。如果其中一个运算数中的相应位为%1或者两个运算数中的相应位都为1，那么结果中的这一位就为1。例如，9｜10=11</li><li>按位异或运算符(^)<br>运算符^对它的整型参数逐位执行布尔异或操作.异或是指第一个运算数是true，或者第二个运算数是true，但是两者不能同时为true如果两个运算数中只有一个数的相应位为1(但不能同时为1)，那么结果中的这一位就为1例如，9^10=3。</li><li>按位非运算符(<code>~</code>)<br>运算符<code>~</code>是个一元运算符，它位于一个整型参数之前，它将运算数的所有位取反.根据javascript中带符号的整数的表示方法，对一个值使用<code>~</code>运算符相当于改变它的符号并且减1例如，<code>~</code>0x0f = Oxfffff00或-16</li><li>左移运算符(&lt;&lt;)<br>运算符&lt;&lt;左移第一个运算数中的所有位移动的位数由第二个运算数指定,移动的位数应该是一个0到31的整数。例如,在表达式a&lt;&lt;1中,a的第一位变成了它的第二位,a的第二位变成了它的第三位,以此类推新的第一位用0来补充,舍弃第32位的值。将一个值左移1位相当于对它乘2,左移2位相当于对它乘4,以此类推。例如,7&lt;&lt;1=14</li><li>带符号的右移运算符(&gt;&gt;)<br>运算符&gt;&gt;右移第一个运算数中的所有位,移动的位数由第二个运算数指定,移动的位数应该是一个0到31的整数。舍弃右边移出的位,填补在左边的位由原运算数的符号位决定,以便保持结果的符号与原操作数一致。如果第一个运算数是正的,就用O填补结果的高位;如果第一个运算数是负的,就用1填补结果的高位。将一个值右移1位,相当于用2除它(丢弃余数)右移2位,相当于用4除它,以此类推。例如,7&gt;1=3,-7&gt;&gt;1=-4</li><li>用0补足的右移运算符(&gt;&gt;&gt;)<br>运算符&gt;&gt;&gt;和运算符&gt;一样,只是从左边移入总是0,与原运算数的符号无关。例如,-1&gt;&gt;4=-1,但是-1&gt;&gt;4=268435455(0x0fffffff0)</li></ul><h3 id="9-赋值运算符"><a href="#9-赋值运算符" class="headerlink" title="9. 赋值运算符"></a>9. 赋值运算符</h3><p>运算符=要求它左边对运算数是一个变量，数组的一个元素，或是对象的一个属性，右边的运算数是一个任意的值，任意类型。</p><h4 id="9-1-带操作的运算符"><a href="#9-1-带操作的运算符" class="headerlink" title="9.1 带操作的运算符"></a>9.1 带操作的运算符</h4><p>运算符+=可以作用于数字和字符串，如果它的运算数是数字，执行加法运算和赋值操作，如果是字符串，将执行连接操作和赋值操作。还有-=,*=,&amp;=等。</p><h3 id="10-其他运算符"><a href="#10-其他运算符" class="headerlink" title="10. 其他运算符"></a>10. 其他运算符</h3><h4 id="10-1-条件运算符"><a href="#10-1-条件运算符" class="headerlink" title="10.1 条件运算符(?)"></a>10.1 条件运算符(?)</h4><p>条件运算符是 JavaScript中惟一的三元运算符(带有三个运算数)有时就称它为三元运算符。这个运算符常被写为?:,但是在代码中它却不是这样的,因为这个运算符具有三个运算数,第一个位于?之前,第二个位于?和:之间,第三个位于:之后。可以用如下方式来使用它:</p><p> x&gt;0 ? x<em>y : -x</em>y</p><p>条件运算符的第一个运算数必须是一个布尔值(或能够被转换为布尔值),通常它是一个比较表达式的结果。第二个和第三个运算数可以是任何类型的值。条件运算符的返回值是由第一个运算数的布尔值决定的。如果这个运算数的值为true,那么条件表达式的值就是第二个运算数的值。如果第一个运算数的值为 false,那么条件表达式的值就是第三个运算数的值。</p><h4 id="10-2-typeof运算符"><a href="#10-2-typeof运算符" class="headerlink" title="10.2 typeof运算符"></a>10.2 typeof运算符</h4><p>typeof是个一元运算符,放在一个运算数之前,这个运算数可以是任意类型的。它的返回值是一个字符串,该字符串说明了运算数的类型。</p><p>如果 typeof的运算数是数字、字符串或者布尔值,它返回的结果就是“number”、“string”或“boolean。对对象、数组和null,它返回的是“object。对函数运算数它返回的是“function”。如果运算数是未定义的,它将返回“undefined”</p><p>当 typeof的运算数是 Number、 String或 Boolean这样的包装对象时,它返回的是“object。此外,对Date和 RegExp对象,它也返回“object。对于那些不属于JavaScript核心语言,而是由 JavaScript嵌入的环境提供的对象, typeof的返回值是由实现决定的。但是,在客户端 JavaScript中, typeof对所有的客户端对象返回的都是“object”,这与它对所有核心对象的处理是一样的。</p><p>由于 typeof对所有的对象和数组类型返回的都是“object”,所以它只在区别对象和原始类型时才有用。要区别一种对象类型和另一种对象类型,必须使用其他的方法。例如instanceof运算符和 constructor属性.</p><h4 id="10-3-对象创建运算符-new"><a href="#10-3-对象创建运算符-new" class="headerlink" title="10.3 对象创建运算符(new)"></a>10.3 对象创建运算符(new)</h4><p>new运算符用来创建一个新对象,并调用构造函数初始化它。new是一个一元运算符,出现在构造函数的调用之前。它的语法如下:</p><p>new constructor(arguments)</p><p>constructor必须是一个构造函数表达式其后应该有一个用括号括起来的参数列表,列表中有零或多个参数,参数之间用逗号分隔。 JavaScript简化了该语法,即如果函数调用时没有参数,就可以省去括号这种简化了的语法只适用于运算符new.下面是一些使用new运算符的例子:</p><p> o=new Object; //此处省略了可选的括号</p><p> d=new Date();//返回一个表示当前时间的Date对象</p><p>c= new Rectangle(3.0.4.0,1.52.75);//创建 Rectangle类的对象<br>obj[i]=new constructors[i] ();</p><p>运算符new首先创建一个新对象,该对象的属性都未被定义接下来,它将调用特定的构造函数,传递指定的参数,此外还要把新创建的对象传递给关键字this这样构造函数就可以使用关键字this来初始化新对象.</p><h4 id="10-4-delete运算符"><a href="#10-4-delete运算符" class="headerlink" title="10.4 delete运算符"></a>10.4 delete运算符</h4><p>delete运算符是个一元运算符,它将删除运算数所指定的对象的属性、数组元素或变量(注3)。如果删除操作成功,它将返回true,如果运算数不能被删除,它将返回 false。并非所有的属性和变量都是可以删除的,某些内部的核心属性和客户端属性不能删除,用var语句声明的变量也不能被删除。如果 delete使用的运算数是一个不存在的属性,它将返回true(令人吃惊的是, ECMAScript标准规定,当 delete运算的运算数不是属性、数组元素或变量时,它返回true.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"><span class="keyword">delete</span> o.x</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="keyword">typeof</span> o.x</span><br><span class="line"><span class="string">&quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">delete</span> o.x</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="keyword">delete</span> o</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="keyword">delete</span> <span class="number">1</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">y = <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">delete</span> y</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>delete所能影响的只是属性值，并不能影响这些属性引用的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> my = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">my.a = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">my.b = my.a;</span><br><span class="line"><span class="keyword">delete</span> my.a;</span><br><span class="line"><span class="built_in">console</span>.log(my.b);<span class="comment">//时间值 Mon Jan 11 2021 17:54:58 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure><h4 id="10-5-void运算符"><a href="#10-5-void运算符" class="headerlink" title="10.5 void运算符"></a>10.5 void运算符</h4><p>void是一个一元运算符,它可以出现在任何类型操作数之前。这个运算符的用途比较特殊,它总是舍弃运算数的值,然后返回undefined这种运算符常用在客户端的 javascript:URL中。在这里可以计算表达式的值,而浏览器不会显示出这个值</p><p>例如,可以在HTML的标记中以如下方式使用void运算符:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;javascript: void window.open () &quot;</span>&gt;Open New Window&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>void另一个用途是专门生成undefined值</p><h4 id="10-6-逗号运算符"><a href="#10-6-逗号运算符" class="headerlink" title="10.6 逗号运算符(,)"></a>10.6 逗号运算符(,)</h4><p>逗号运算符非常简单。它先计算其左边的参数,再计算其右边的参数,然后返回右边参数的值。因此,如下的代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">0</span>,j=<span class="number">1</span>,k=<span class="number">2</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">i=<span class="number">0</span>;</span><br><span class="line">j=<span class="number">1</span>;</span><br><span class="line">k=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>这个奇怪的运算符只在个别环境中使用,一般是在只允许出现一个表达式的地方计算几个不同的表达式时才使用的。在实际应用中,逗号运算符只和for循环语句联合使用。</p><h4 id="10-7-数组和对象存取运算符"><a href="#10-7-数组和对象存取运算符" class="headerlink" title="10.7 数组和对象存取运算符"></a>10.7 数组和对象存取运算符</h4><p>运算符“.”左边是一个对象，右边是一个标识符<br>运算符“[]”用于存取数组元素，还可以存取对象的属性。</p><h4 id="10-8-函数调用运算符（）"><a href="#10-8-函数调用运算符（）" class="headerlink" title="10.8 函数调用运算符（）"></a>10.8 函数调用运算符（）</h4><!-- * @Description: javascript-第五章-表达式和运算符 * @version::  * @Author: zhao * @Date: 2021-01-10 22:43:09 * @LastEditors: zhao * @LastEditTime: 2021-01-11 11:37:15-->]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-第四章-变量</title>
      <link href="/ZJY.github.io/2021/01/10/javascript-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%8F%98%E9%87%8F/"/>
      <url>/ZJY.github.io/2021/01/10/javascript-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="第四章-变量"><a href="#第四章-变量" class="headerlink" title="第四章 变量"></a>第四章 变量</h2><h3 id="1-变量的类型"><a href="#1-变量的类型" class="headerlink" title="1.变量的类型"></a>1.变量的类型</h3><p>js是无类型的，变量可以存放任意类型的值</p><h3 id="2-变量的声明"><a href="#2-变量的声明" class="headerlink" title="2.变量的声明"></a>2.变量的声明</h3><p>要使用一个变量，要使用var关键字声明。<br>    var i;<br>    var num;<br>    也可以一次声明多个变量：var i,num;<br>    也可以将变量声明和初始化绑到一块：var message = ‘hello’;<br>    var i=0,k=1;</p><p>var 声明的变量是永久性的，用delete运算符删除变量会引发错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">delete</span> i; <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 10</span></span><br><span class="line">a=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">delete</span> a; <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// a is not defined </span></span><br></pre></td></tr></table></figure><p>重复声明同一个变量是合法的，且不会报错。<br>如果尝试读取一个未声明的变量的值，会引发错误。<br>如果给未用var声明的变量赋值，js会隐式的声明该变量，隐式声明变量会使该变量为全局变量。</p><h3 id="3-变量的作用域"><a href="#3-变量的作用域" class="headerlink" title="3.变量的作用域"></a>3.变量的作用域</h3><p>变量的作用域就是程序中定义变量的区域。全局变量的作用域全局性的，在js中处处有定义。而在函数内部定义的变量只能在函数内部使用，是局部性的。函数的参数也是局部作用域，只在函数内部有定义。<br>在函数内部，局部变量的优先级比同名的全局变量高.</p><h4 id="3-1-没有块级作用域"><a href="#3-1-没有块级作用域" class="headerlink" title="3.1 没有块级作用域"></a>3.1 没有块级作用域</h4><p>即函数中声明的所用变量在整个函数中有定义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> o==<span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> k=<span class="number">0</span>; k&lt;<span class="number">10</span>;k++)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">document</span>.write(k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(i,j,k);</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="literal">null</span>); <span class="comment">// 0 0  10  i,j,k在整个函数中有定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> scope=<span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(scope);</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&#x27;local&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(scope);</span><br><span class="line">&#125;</span><br><span class="line">f(); <span class="comment">// undefined  local</span></span><br></pre></td></tr></table></figure><h4 id="3-2-未定义的变量和未赋值的变量"><a href="#3-2-未定义的变量和未赋值的变量" class="headerlink" title="3.2 未定义的变量和未赋值的变量"></a>3.2 未定义的变量和未赋值的变量</h4><p>var x;  //声明一个未赋值的变量<br>alert(u); //使用未声明的变量将引发错误<br>u=3; //给未声明的变量赋值，将创建该变量</p><h3 id="4-基本类型"><a href="#4-基本类型" class="headerlink" title="4.基本类型"></a>4.基本类型</h3><p>变量具有或存放了值，存放的具体内容就是js所支持的数据类型。<br>基本数据类型：null,number,string,bool,undefined<br>引用数据类型：对象，数组和函数。</p><p>基本类型在内存中具有固定的大小。引用类型没有固定的大小。<br>引用类型，变量存储的是对这个值的引用，通常是指针或内存地址。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//3.14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">A[<span class="number">0</span>]=<span class="number">99</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//[99,2,3]</span></span><br></pre></td></tr></table></figure><p>变量保存了基本数据类型的值，而只保存了对引用类型的引用。</p><h3 id="5-无用存储单元的收集"><a href="#5-无用存储单元的收集" class="headerlink" title="5.无用存储单元的收集"></a>5.无用存储单元的收集</h3><p>由于引用类型没有固定的大小，所以引用类型可能非常的大。由于字符串、数组、对象没有固定大小，所以当知道他们的大小时，才能为他们进行动态的内存分配。</p><p>js程序每次创建字符串、对象和数组时，解释器都要分配内存来储存实体，只要像这样动态的分配了内存，最终都要释放内存以便它们能够被再用。否则，js解释器会消耗所有系统内存，造成系统崩溃。</p><p>js不要求手动释放内存，它使用一种无用存储单元收集方法。当js检测到一个对象不再使用时，就会把它所占用内存释放掉。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = ‘hello’;</span><br><span class="line"><span class="keyword">var</span> u = s.toUppercase();</span><br><span class="line">s = u;</span><br></pre></td></tr></table></figure><p>程序检测到’hello’字符串不再使用，就会释放掉这块内存.</p><h3 id="6-作为属性的变量"><a href="#6-作为属性的变量" class="headerlink" title="6.作为属性的变量"></a>6.作为属性的变量</h3><p>变量和对象的属性基本是一样的，赋值和用法都相同。</p><h4 id="6-1-全局对象"><a href="#6-1-全局对象" class="headerlink" title="6.1 全局对象"></a>6.1 全局对象</h4><p>在js解释器执行前，首先要做的事情之一在任何代码执行之前，创建一个全局对象（global object）。这个对象的属性就是全局变量。</p><p>当js声明一个全局变量时，实际上就是定义了那个全局对象的一个属性。</p><p>在程序的顶层代码中，可以用this代替那个全局对象。<br>在客户端js中，window对象代表浏览器窗口，是包含在窗口中所有js代码的全局对象。这个全局Window对象具有自我引用的window属性，它代替了this属性。可以用来引用全局对象。Window对象定义了全局的核心属性，例如Infinity,parseInt,Math,除此之外还定义了全局的客户端属性，navigator和 screen.</p><h4 id="6-2-局部变量：调用对象"><a href="#6-2-局部变量：调用对象" class="headerlink" title="6.2 局部变量：调用对象"></a>6.2 局部变量：调用对象</h4><p>全局变量是特殊的全局对象的属性，局部变量是调用对象（call object）的属性。</p><p>在执行一个函数时，局部变量和参数是作为调用对象的属性存储的。用一个完全独立的对象存储局部变量可以使js防止同名变量覆盖全局变量的值。</p><h4 id="6-3-javascript的执行环境"><a href="#6-3-javascript的执行环境" class="headerlink" title="6.3 javascript的执行环境"></a>6.3 javascript的执行环境</h4><p>javascript的解释器每次开始执行一个函数时，就会为那个函数创建一个执行环境（execution context）。显然，这个执行环境就是js代码段执行时所在环境。</p><p>所用js函数都有自己的执行环境，有自己的调用对象，调用对象定义了局部变量。运行不属于任何js代码的环境使用的就是全局对象。</p><p>js允许有多个全局执行环境，每个全局执行环境有不同的全局对象（但在在这种情况下，全局对象就不完全是全局的了）。</p><p>一个显而易见的例子就是，每个独立的浏览器窗口或同一窗口不同框架中都定义了独立的全局执行环境。每个框架或窗口中的客户端js代码都运行在自己的执行环境中，具有自己的全局对象。但是这些独立的客户端全局对象，具有将其他对象连接起来的属性。因此，一个框架可以通过parent.frames[1]来引用另一个框架的代码，在第二个框架中可以用表达式parent.frames[0].x来引用第一个框架的全局变量x。</p><h3 id="7-变量的作用域"><a href="#7-变量的作用域" class="headerlink" title="7.变量的作用域"></a>7.变量的作用域</h3><p><img src="/ZJY.github.io/images/scope.png" alt="变量的作用域"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-第三章-数据类型和值</title>
      <link href="/ZJY.github.io/2021/01/10/javascript-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%80%BC/"/>
      <url>/ZJY.github.io/2021/01/10/javascript-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="第三章-数据类型和值"><a href="#第三章-数据类型和值" class="headerlink" title="第三章 数据类型和值"></a>第三章 数据类型和值</h2><p>计算机程序是通过操作值来运行的。能够表示并操作的值的类型称为数据类型。</p><p>javascript允许使用3种基本数据类型：数字、字符串、布尔。此外还支持另外2种小数据类型：null（空）和undefined（未定义），只定义了一个值。</p><p>除了基本数据类型外，javascript还支持复合数据类型-对象，是值的集合。对象有两种，一种是已命名的值的无序集合，另一种是有编号的值的有序集合。后者称为数组。</p><p>javascript还定义了另一种特殊的类型-函数，是具有可执行代码的对象。js为函数定义了专用的语法。</p><p>除了数组和函数还定义了其他专用的对象，这些对象不是新的数据类型而是新的对象类。Date类定义的表示日期的对象。</p><p>RegExp类定义的表示正则表达式的对象。Error类定义的是js程序中发生的语法和运行时错误的对象。</p><h3 id="1-数字"><a href="#1-数字" class="headerlink" title="1.数字"></a>1.数字</h3><p>在js中，不区分整点型和浮点型数字，所有数字都是浮点型的，采用ieee 754标准的64位浮点格式表示</p><h4 id="1-1-整型直接量-十进制"><a href="#1-1-整型直接量-十进制" class="headerlink" title="1.1 整型直接量(十进制)"></a>1.1 整型直接量(十进制)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>   <span class="number">3</span>   <span class="number">1000</span></span><br></pre></td></tr></table></figure><p>整数表示从2<sup>-53</sup> 到2 <sup>53</sup>,使用超过尾数范围的数字，就会失去精确性，<br>有些整数的运算，是对32位进行的，（2<sup>-31</sup> 到 2<sup>31-1</sup>)</p><h4 id="1-2八进制和十六进制直接量"><a href="#1-2八进制和十六进制直接量" class="headerlink" title="1.2八进制和十六进制直接量"></a>1.2八进制和十六进制直接量</h4><p>除了10进制的整型直接量，js还支持8进制和16进制直接量。</p><p>16进制中数字可以用0-9表示，字母可以用a(A)-f(F)表示，代表0-15之间数字。16进制直接量由’0x’ 或‘0X’开头，后面跟16进制数字串。</p><p>0x123 基数是16 //1<em>16</em>16+2*16+3</p><p>尽管ECMAScript标准不支持8进制的直接量，但是javascript的某些实现却允许你使用8进制的直接量。8进制是以0开头，后面跟随0-7直接的数字，</p><p>0377 基数是8 // 3<em>8</em>8+7*8+7</p><p>由于某些js实现支持8进制有些不支持，所以尽量不要使用0开头的整型直接量。</p><h4 id="1-3浮点型直接量"><a href="#1-3浮点型直接量" class="headerlink" title="1.3浮点型直接量"></a>1.3浮点型直接量</h4><p>由整数部分，小数点，小数部分组成，此外还可以用指数计数法表示浮点型直接量，即实数后面跟字母e或者E，后面跟正号和负号，再加一个整型指数。表示前面的实数乘以10的指数次幂。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.14</span></span><br><span class="line"><span class="number">344.89</span></span><br><span class="line"><span class="number">6.34e12</span> <span class="comment">//6.34*1012</span></span><br></pre></td></tr></table></figure><h4 id="1-4特殊数值"><a href="#1-4特殊数值" class="headerlink" title="1.4特殊数值"></a>1.4特殊数值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">Infinity</span>  无穷大</span><br><span class="line">-<span class="literal">Infinity</span>  负无穷大</span><br><span class="line"><span class="literal">NaN</span>    非数字的特殊值，和任何值都不相等，包括自己，用专门的<span class="built_in">isNaN</span>()函数来检测这个值。</span><br><span class="line"><span class="built_in">isFinite</span>()函数来测试一个值是否是<span class="literal">NaN</span>，正无穷大或负无穷大。</span><br><span class="line"><span class="built_in">Number</span>.MAX_VALUE  可表示的最大数字</span><br><span class="line"><span class="built_in">Number</span>.MIN_VALUE   可表示的最小数字（接近于<span class="number">0</span>）</span><br><span class="line"><span class="built_in">Number</span>.NaN  非数字的特殊值</span><br><span class="line"><span class="built_in">Number</span>.POSITION_INFINITY 表示正无穷大的特殊值</span><br><span class="line"><span class="built_in">Number</span>.NEGATIVE_INFINITY 表示负无穷大的特殊值</span><br></pre></td></tr></table></figure><h3 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2.字符串"></a>2.字符串</h3><p>由unicode字符、数字和标点符号组成的序列，表示文本的数据类型。</p><h4 id="2-1-字符串直接量"><a href="#2-1-字符串直接量" class="headerlink" title="2.1 字符串直接量"></a>2.1 字符串直接量</h4><p>由单引号或者双引号扩起来的unicdoe字符序列。可以包含0个或多个字符序列</p><h4 id="2-2-字符串直接量中的转义字符"><a href="#2-2-字符串直接量中的转义字符" class="headerlink" title="2.2 字符串直接量中的转义字符"></a>2.2 字符串直接量中的转义字符</h4><p>反斜杠\后加一个字母就可以表示特殊的用法。\n表示换行符<br>‘you&#39;re right’, \’表示单引号或者撇号</p><h3 id="3-布尔值"><a href="#3-布尔值" class="headerlink" title="3.布尔值"></a>3.布尔值</h3><p>true和false两个值，通常用于控制结果</p><h3 id="4-函数"><a href="#4-函数" class="headerlink" title="4.函数"></a>4.函数</h3><p>一段可执行的代码段，由js定义或由js预定义，可多次执行和调用。js函数是一个真正的数据类型，可以对函数进行操作。</p><p>Math.sin()预定义函数</p><h4 id="4-1-函数直接量"><a href="#4-1-函数直接量" class="headerlink" title="4.1 函数直接量"></a>4.1 函数直接量</h4><p>有关键字function和可选对参数名、用括号括起来对参数列表和花括号括起来定义的。</p><p>除了用函数定义来定义函数：</p><p>function square(x){ return x*x }</p><p>还可以用函数直接量类定义：</p><p>var square = funtion(x) { return x*x }</p><p>如果一个函数值存储在某个对象的属性中，那个这个函数通常被称为方法，属性名称被称为方法名。</p><h3 id="5-对象"><a href="#5-对象" class="headerlink" title="5.对象"></a>5.对象</h3><p>已命名的数据的集合，每个数值都有一个名字,称为对象的属性，通过”.”操作符和属性名访问。</p><h4 id="5-1-创建对象"><a href="#5-1-创建对象" class="headerlink" title="5.1 创建对象"></a>5.1 创建对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/javascript/gi</span>);</span><br></pre></td></tr></table></figure><h4 id="5-2-对象直接量"><a href="#5-2-对象直接量" class="headerlink" title="5.2 对象直接量"></a>5.2 对象直接量</h4><p>var point = {x: 1,y:3}，<br>对象直接量可以嵌套，属性值可以不是常量。</p><h3 id="6-数组"><a href="#6-数组" class="headerlink" title="6.数组"></a>6.数组</h3><p>数值的集合，数组的每个数值都有一个下标，js不支持多维数组，但数组元素可以是数组。数组下标是非负整数</p><h4 id="6-1-数组的创建"><a href="#6-1-数组的创建" class="headerlink" title="6.1 数组的创建"></a>6.1 数组的创建</h4><p>可以通过构造函数Array()创建:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1.2</span>;</span><br><span class="line">arr[<span class="number">1</span>] = ‘javascript’;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1.2</span>,’javascript’);</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>); 创建的是表示<span class="number">10</span>个未定义的数组</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-2-数组直接量"><a href="#6-2-数组直接量" class="headerlink" title="6.2 数组直接量"></a>6.2 数组直接量</h4><p>var arr = [1,2,3,4];<br>数组可以嵌套，var arr = [[1,2,3],2];<br>数组元素不局限于常量：var arr = [1024,1024+1]<br>数组可以存放未定义的元素：var arr = [1,,,,5]</p><h3 id="7-null"><a href="#7-null" class="headerlink" title="7.null"></a>7.null</h3><p>表示“无”值，尝被看作对象类型的特殊值，表示“无对象”的值。js保留字</p><h3 id="8-undefined"><a href="#8-undefined" class="headerlink" title="8.undefined"></a>8.undefined</h3><p>当你使用一个未定义的值，或已定义未赋值的值，或不存在的对象属性时，返回这个值。</p><p>null == undefined  //true</p><p>如果要区分null和undefined可用 === 或者typeof区分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// “object”  </span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// undefined</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> 不是js保留字</span><br><span class="line">ECMAScript v3 定义了名为<span class="literal">undefined</span>的全局变量，值为<span class="literal">undefined</span></span><br></pre></td></tr></table></figure><h3 id="9-Date对象"><a href="#9-Date对象" class="headerlink" title="9.Date对象"></a>9.Date对象</h3><p>表示日期和时间的对象类。可以用运算符new和构造函数Date()创建Date对象</p><h3 id="10-正则表达式"><a href="#10-正则表达式" class="headerlink" title="10.正则表达式"></a>10.正则表达式</h3><p>用于模式匹配和查找替换操作，正则表达式直接量：/^html/</p><h3 id="11-Error"><a href="#11-Error" class="headerlink" title="11.Error"></a>11.Error</h3><p>表示错误的类,每个Error对象都有一个message属性，存放js特定错误消息。预定义的错误对象的类型有Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError和URIError.</p><h3 id="12-基本数据类型的包装对象"><a href="#12-基本数据类型的包装对象" class="headerlink" title="12.基本数据类型的包装对象"></a>12.基本数据类型的包装对象</h3><p>var str =”lfjlajdfasd”;<br>var result = str.substring(1,4);<br>三个基本的数据类型都有一个相应的对象类，js不仅有数字、字符串、布尔类型，还有Number、String、Bool类，这些类是基本数据类型的包装，这些类不仅有基本数据类型的值，还定义了用来运算的属性和方法</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-第二章-词法结构</title>
      <link href="/ZJY.github.io/2021/01/10/javascript-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%AF%8D%E6%B3%95%E7%BB%93%E6%9E%84/"/>
      <url>/ZJY.github.io/2021/01/10/javascript-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%AF%8D%E6%B3%95%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="第二章-词法结构"><a href="#第二章-词法结构" class="headerlink" title="第二章 词法结构"></a>第二章 词法结构</h2><h3 id="1-字符集"><a href="#1-字符集" class="headerlink" title="1.字符集"></a>1.字符集</h3><p>采用16位的unicode编码可以表示任意一种书面语言，javascript是采用unicode字符集编写的。js中任意字符都是用2个字节表示。</p><h3 id="2-区分大小写"><a href="#2-区分大小写" class="headerlink" title="2.区分大小写"></a>2.区分大小写</h3><p>在html中标记和性质名可以任意大小写方式输入，但是在js中通常是小写的。例如，在html中事件处理性质名是onClick，但是在js中只能用onclick。</p><h3 id="3-空白符和换行符"><a href="#3-空白符和换行符" class="headerlink" title="3.空白符和换行符"></a>3.空白符和换行符</h3><p>js会忽略空白符号、制表符、换行符，除非是字符串或正则表达式中。</p><h3 id="4-分号可选"><a href="#4-分号可选" class="headerlink" title="4.分号可选"></a>4.分号可选</h3><p>但是省略分号并不是一个良好的编程习惯，应习惯于使用分号。</p><h3 id="5-注释"><a href="#5-注释" class="headerlink" title="5.注释"></a>5.注释</h3><p>单行： //  多行： /****/</p><h3 id="6-直接量"><a href="#6-直接量" class="headerlink" title="6.直接量"></a>6.直接量</h3><p>就是程序中直接显示的数据值，以下都是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1.2</span></span><br><span class="line">“hello,world”</span><br><span class="line"><span class="literal">null</span>,</span><br><span class="line">True,</span><br><span class="line">False,</span><br><span class="line">/javascript/gi,</span><br><span class="line">&#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:<span class="number">1</span>&#125;, <span class="comment">//对象直接量</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] <span class="comment">//数组直接量</span></span><br></pre></td></tr></table></figure><h3 id="7-标识符"><a href="#7-标识符" class="headerlink" title="7.标识符"></a>7.标识符</h3><p>一个名字，用来命名变量和函数，或者代码中某些循环的标签。<br>命名规则：首字符以字母、下划线和美元符号开头，后面可以是数字、字母、下划线、美元符号</p><h3 id="8-保留字"><a href="#8-保留字" class="headerlink" title="8.保留字"></a>8.保留字</h3><p>不能用作标识符，有特殊意义</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript-第一章-Javascript的概述</title>
      <link href="/ZJY.github.io/2021/01/10/javascript-%E7%AC%AC%E4%B8%80%E7%AB%A0-Javascript%E7%9A%84%E6%A6%82%E8%BF%B0/"/>
      <url>/ZJY.github.io/2021/01/10/javascript-%E7%AC%AC%E4%B8%80%E7%AB%A0-Javascript%E7%9A%84%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Javascript的概述"><a href="#Javascript的概述" class="headerlink" title="Javascript的概述"></a>Javascript的概述</h3><p>JavaScript是一种轻型的，解释型的程序设计语言。具有面向对象的能力。是一种无类型的语言，也就是说变量不必具有明确的类型。<br>除了能够动态的生成浏览器要显示的html文档，js不具备任何图形处理能力。<br>处于安全考虑，客户端javascript不允许对文件进行读写操作。<br>除了能够引发浏览器下载任意url所指对文档以及把html表单内容发送给服务器脚本、电子邮件外，javascript不支持任意形式的联网技术。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
