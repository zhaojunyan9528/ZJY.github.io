<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vue.js的设计与实现</title>
      <link href="/ZJY.github.io/2024/02/26/vue-js%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/ZJY.github.io/2024/02/26/vue-js%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-权衡的艺术"><a href="#第一章-权衡的艺术" class="headerlink" title="第一章 权衡的艺术"></a>第一章 权衡的艺术</h2><p>框架设计是权衡的艺术。</p><p>视图层框架分为：</p><ul><li>命令式：比如Jquery, 注重过程</li><li>声明式：比如Vue, 注重结果</li></ul><p>vuejs封装了过程，内部实现时命令式的暴露给用户声明式。<br>框架本身就是封装了命令式代码才实现了面向用户的声明式。</p><p><strong>声明式代码性能不优于命令式代码的性能。</strong></p><p>声明式代码更新性能消耗= 查找差异的性能消耗 + 直接更新的性能消耗<br>命令式代码更新性能消耗= 直接更新的性能消耗</p><p>声明式代码可维护性强，命令式代码性能更好</p><p>框架设计要做的是：保持可维护性同事性能损失最小。</p><p>最小化找出差异性能消耗：虚拟DOM</p><p>框架设计有纯运行时、纯编译时、运行时+编译时三种方式</p><p>树型结构对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  tag: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">  children: [</span><br><span class="line">    &#123; <span class="attr">tag</span>: <span class="string">&#x27;a&#x27;</span>, <span class="attr">children</span>: <span class="string">&#x27;hello&#x27;</span> &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>纯运行时：通过render函数将树型结构的数据对象递归遍历为DOM元素</p><p>纯编译时：Compiler对象将HTML字符串转换为命令式代码</p><p>运行时+编译时：通过Compiler对象将HTML字符串编译成树型结构的数据对象，再通过render函数将树型结构的数据对象递归遍历为DOM元素</p><p>vue.js采用运行时+编译时</p><h2 id="框架设计的核心要素"><a href="#框架设计的核心要素" class="headerlink" title="框架设计的核心要素"></a>框架设计的核心要素</h2><ul><li>提升用户的开发体验：提供良好的警告信息至关重要，有助于开发者快速定位问题</li><li>控制框架代码的体积</li><li>框架做到良好的tree-shaking：开发环境中打印警告信息，生产环境则不包含提升开发体验的代码</li><li>框架应该输出怎样的构建产物</li><li>特性开关</li><li>错误处理</li><li>良好的typescript类型支持</li></ul><h2 id="第三章-vue-js的设计思路"><a href="#第三章-vue-js的设计思路" class="headerlink" title="第三章 vue.js的设计思路"></a>第三章 vue.js的设计思路</h2><p>使用js对象来描述UI的方式就是虚拟DOM，vuejs也支持使用模版来描述UI，但是使用js对象即虚拟DOM更加灵活，模版描述UI更直观。虚拟DOM和模版都是声明式描述UI。</p><p>渲染函数使用虚拟DOM描述UI</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">onClick</span>: handler&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虚拟dom：使用js对象来描述真实的DOM结构，包含tag、props、children等属性</p><p>渲染器：将虚拟DOM渲染为真实的DOM结构<br>编译器：将模版编译为渲染函数；会将模版内容编译为渲染函数并添加到script标签的组件对象上。</p><p>渲染器的思路：<br>1、创建元素tag<br>2、为元素添加属性和事件<br>3、处理children</p><p>组件本质是一组虚拟DOM元素的封装。<br>无论是使用模版还是直接手写渲染函数，对于一个组件来说它渲染的内容都要通过渲染函数产生。然后渲染器再吧渲染函数产生的虚拟dom渲染为真实的DOM结构。这就是模版的工作原理。</p><p>组件实现依赖于渲染器，模版编译依赖于编译器。</p><h2 id="第四章-响应式系统"><a href="#第四章-响应式系统" class="headerlink" title="第四章 响应式系统"></a>第四章 响应式系统</h2><p>副作用函数：比如一个函数修改了全局变量</p><p>Proxy：拦截对一个对象的基本操作，只能代理一个对象的基本语义。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>布局和包含块</title>
      <link href="/ZJY.github.io/2023/12/07/%E5%B8%83%E5%B1%80%E5%92%8C%E5%8C%85%E5%90%AB%E5%9D%97/"/>
      <url>/ZJY.github.io/2023/12/07/%E5%B8%83%E5%B1%80%E5%92%8C%E5%8C%85%E5%90%AB%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<p>一个元素的尺寸和位置受其包含块的影响，大部分情况下元素的包含块就是最近祖先块元素的内容区域（盒模型的content）</p><h2 id="根据包含块计算百分值"><a href="#根据包含块计算百分值" class="headerlink" title="根据包含块计算百分值"></a>根据包含块计算百分值</h2><ul><li>height、top、bottom属性根据包含块的height计算</li><li>width、left、right、margin、padding属性根据包含块的width计算</li></ul><h2 id="确定包含块"><a href="#确定包含块" class="headerlink" title="确定包含块"></a>确定包含块</h2><p>确定一个元素的包含块的过程依赖于属性position的值：</p><ul><li>如果position的值为static、sticky、relative，包含块可能为最近的祖先块元素的内容区域</li><li>如果position的值为absolute，包含块为最近position不为static的祖先元素的内边距区域</li><li>如果position的值为fixed，在连续媒体的情况下包含块是viewport视口，分页媒体的情况下包含块是分页区域</li><li>如果position的值为absolute或fixed的，包含块也可能是由满足以下条件的最近父级元素的内边距区的边缘组成的：<ul><li>transform 或 perspective 的值不是 none</li><li>will-change 的值是 transform 或 perspective</li><li>filter 的值不是 none 或 will-change 的值是 filter（只在 Firefox 下生效）。</li><li>contain 的值是 layout、paint、strict 或 content（例如：contain: paint;）</li><li>backdrop-filter 的值不是 none（例如：backdrop-filter: blur(10px);）</li></ul></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>这个示例中，P 标签设置为静态定位，所以它的包含块为 <code>&lt;section&gt;</code>，因为距离最近的父节点即是她的包含块。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: beige;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">section</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">160px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>; <span class="comment">/* == 400px * .5 = 200px */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">25%</span>; <span class="comment">/* == 160px * .25 = 40px */</span></span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">5%</span>; <span class="comment">/* == 400px * .05 = 20px */</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5%</span>; <span class="comment">/* == 400px * .05 = 20px */</span></span><br><span class="line">  <span class="attribute">background</span>: cyan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，P 标签的包含块为 <code>&lt;body&gt;</code> 元素，因为 <code>&lt;section&gt;</code> 不再是一个块容器，所以并没有形成一个格式上下文。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: beige;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">section</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline;</span><br><span class="line">  <span class="attribute">background</span>: lightgray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>; <span class="comment">/* == half the body&#x27;s width */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>; <span class="comment">/* <span class="doctag">Note:</span> a percentage would be 0 */</span></span><br><span class="line">  <span class="attribute">background</span>: cyan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例中，P 元素的包含块是 <code>&lt;section&gt;</code>，因为 <code>&lt;section&gt;</code> 的 position 为 absolute 。P 元素的百分值会受其包含块的 padding 所影响。不过，如果包含块的 box-sizing 值设置为 border-box ，就没有这个问题。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: beige;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">section</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">160px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">30px</span> <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>; <span class="comment">/* == (400px + 20px + 20px) * .5 = 220px */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">25%</span>; <span class="comment">/* == (160px + 30px + 30px) * .25 = 55px */</span></span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">5%</span>; <span class="comment">/* == (400px + 20px + 20px) * .05 = 22px */</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5%</span>; <span class="comment">/* == (400px + 20px + 20px) * .05 = 22px */</span></span><br><span class="line">  <span class="attribute">background</span>: cyan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例中，P 元素的 position 为 fixed，所以它的包含块就是初始包含块（在屏幕上，也就是 viewport）。这样的话，P 元素的尺寸大小，将会随着浏览器窗框大小的变化，而变化。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: beige;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">section</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">480px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">15px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>; <span class="comment">/* == (50vw - (width of vertical scrollbar)) */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50%</span>; <span class="comment">/* == (50vh - (height of horizontal scrollbar)) */</span></span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">5%</span>; <span class="comment">/* == (5vw - (width of vertical scrollbar)) */</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5%</span>; <span class="comment">/* == (5vw - (width of vertical scrollbar)) */</span></span><br><span class="line">  <span class="attribute">background</span>: cyan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例中，P 元素的 position 为 absolute，所以它的包含块是<code>&lt;section&gt;</code>，也就是距离它最近的一个 transform 值不为 none 的父元素。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: beige;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">section</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">0deg</span>);</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">160px</span>;</span><br><span class="line">  <span class="attribute">background</span>: lightgray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50%</span>; <span class="comment">/* == 200px */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">25%</span>; <span class="comment">/* == 40px */</span></span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">5%</span>; <span class="comment">/* == 20px */</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">5%</span>; <span class="comment">/* == 20px */</span></span><br><span class="line">  <span class="attribute">background</span>: cyan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常随记</title>
      <link href="/ZJY.github.io/2023/11/03/%E6%97%A5%E5%B8%B8%E9%9A%8F%E8%AE%B0/"/>
      <url>/ZJY.github.io/2023/11/03/%E6%97%A5%E5%B8%B8%E9%9A%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="2023-11-03"><a href="#2023-11-03" class="headerlink" title="2023-11-03"></a>2023-11-03</h2><h3 id="sockjs-node-info-t-时间戳"><a href="#sockjs-node-info-t-时间戳" class="headerlink" title="/sockjs-node/info?t=${时间戳}"></a>/sockjs-node/info?t=${时间戳}</h3><p>当运行npm run dev启动项目后，在浏览器的network中会自动持续发送<code>/sockjs-node/info?t=$&#123;时间戳&#125;</code>请求。</p><p>sockjs-node是什么？<br>sockjs-node是一个JavaScript库，提供跨浏览器的API，创建了一个低延迟、全双工的浏览器和web服务器之间的通道。<br>在项目运行后，会一直调用该接口。<br>SockJS是一个JavaScript库。提供类似于websocket的对象。其作用就是在开发环境下，保证我们在改完代码重写编译后，能够通知浏览器重新加载变更结果。</p><p>这里理解为这个库用来让浏览器和本地之间热更新通信的。</p><p>如果两个地址对接不上，或者更换wifi等都会报错：sockjs-node/info?t= net::ERR_CONNECTION_TIMED_OUT</p><p>需要关闭该请求可以找到node_modules/sockjs-client/dist/sockjs.js ，注释代码的第1603行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// self.xhr.send(payload); 注释掉该行</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  self.emit(<span class="string">&#x27;finish&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  self._cleanup(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上只在本地有效，重新安装依赖或者别的同事都需要重新修改，可添加脚本，当npm install后替换掉node_modules/sockjs-client/dist/sockjs.js该文件</p><p>1.在根目录下新建该文件lib/sockjs.js,拷贝node_modules/sockjs-client/dist/sockjs.js文件并注释掉1603行</p><p>2.在根目录下创建installSockjs.js文件，将node_modules对应文件替换为lib/sockjs.js文件</p><p>3.在package.json的scripts中添加脚本命令：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">&quot;postinstall: node installSockjs.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.最后npm install即可，但是这样作热更新没有了。</p><h3 id="postinstall干什么的？？？"><a href="#postinstall干什么的？？？" class="headerlink" title="postinstall干什么的？？？"></a>postinstall干什么的？？？</h3><p>postinstall是安装完某个包后自动执行的脚本。可以在package.json添加postinstall设置执行的脚本命令，帮我们做一些额外的处理，例如复制文件、创建目录、执行脚本、打印信息等。</p><p>例如：将 dist 目录下的所有文件复制到 public 目录下。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts:&quot;</span> &#123;</span><br><span class="line">  <span class="attr">&quot;postinstall&quot;</span>: <span class="string">&quot;cp -r dist/* public/&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组扩展运算符"><a href="#数组扩展运算符" class="headerlink" title="数组扩展运算符"></a>数组扩展运算符</h3><p>数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。</p><h2 id="2023-11-22"><a href="#2023-11-22" class="headerlink" title="2023-11-22"></a>2023-11-22</h2><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>事件循环：浏览器的核心</p><p>进程：</p><p>何为进程：程序运行需要有他自己专有的内存空间，可以把这块内存空间简单的称为进程</p><p>每个应用至少有一个进程，进程之间相互独立，即使通信也要双方同意。</p><p>何为线程：<br>有了进程后，就可以运行程序，运行程序的称为线程。<br>一个进程至少有一个线程，所以在进程开启后会自动创建一个线程来运行代码，这个线程称为主线程。<br>如果程序需要同时运行多块代码，主线程会启动更多的线程来运行代码。所以一个进程可以包含多个线程。</p><p>浏览器有哪些进程和线程？</p><p>浏览器是一个多进程多线程的应用程序。</p><p>浏览器内部及其复杂，为了避免互相影响，减少崩溃的几率，启动浏览器后，会启动多个进程。</p><p>浏览器进程、网络进程、渲染进程 等</p><p>浏览器主要进程有：</p><p>浏览器进程：<br>负责界面显示、用户交互、子进程管理等，浏览器进程会开启多个线程执行任务。</p><p>网络进程：<br>负责加载网络资源。网络进程内部会开启多个线程来执行不同的网络任务。</p><p>渲染进程：<br>渲染进程开启后，会启动一个渲染主线程，主线程负责html、css、js代码。</p><p>默认情况下，浏览器为每一个标签页开启一个新的渲染进程，保证不同标签页互不影响。</p><p>事件循环发生在渲染主线程。</p><p>渲染主线程是如何工作的？</p><p>渲染主线程是浏览器最繁忙的线程，需要它处理的任务包括但不限于：</p><ul><li>解析html</li><li>解析css</li><li>计算样式</li><li>布局</li><li>处理图层</li><li>每秒把页面画60次</li><li>执行全局js代码</li><li>处理事件监听函数</li><li>执行定时器的回调函数</li><li>…</li></ul><p>渲染主线程如何调度任务呢？排队</p><p>1、最开始的时候，渲染主线程进入一个无限循环<br>2、每一次循环会检查事件队列（消息队列）是否有任务存在，如果有，取出第一个任务在主线程执行，执行完后进入下一个循环；如果没有则进入休眠<br>3、其他所有线程（包括其他进程的线程）可以随时向事件队列添加任务，新任务会添加到事件队列的末尾。在添加新任务时如果主线程处在休眠状态则会唤醒以继续循环拿取任务。</p><p>以上整个过程称为事件循环。</p><p>何为异步？</p><p>代码在执行过程中，会遇到无法立即处理的任务，比如：</p><ul><li>计时完成后需要执行的任务：setTimeout setInterval</li><li>网络通信完成后需要执行的任务：xhr fetch</li><li>用户操作后要执行的任务：addEventListener</li></ul><p>如果让渲染主线程等待这些任务的时机到达，就会导致主线程阻塞，造成浏览器卡死。因此浏览器选择异步来解决问题。</p><p>比如：渲染主线程遇到计时器，通知计时线程去计时，结束该任务，继续循环从事件队列拿取任务，计时线程计时结束后将回调函数包装成任务放进事件队列末尾。</p><p>使用异步的方式，渲染主线程永不阻塞。</p><h3 id="如何理解js中的异步？"><a href="#如何理解js中的异步？" class="headerlink" title="如何理解js中的异步？"></a>如何理解js中的异步？</h3><p>js是一门单线程的语言，运行在浏览器的渲染主线程内，渲染主线程只有一个，承担很多任务，比如解析html、css、计算样式、布局、执行js代码等。如果使用同步的方式就有可能阻塞主线程，导致事件队列的其他任务不能执行，造成渲染主线程白白浪费，页面无法更新，给用户造成卡死现象。<br>所以浏览器使用异步的方式来避免。具体做法是某些任务发生时，如计时器、网络、事件监听，主线程交给其他线程去处理，自身立即结束任务，执行后续代码。当其他线程执行结束时，就将事先传递回调函数包装成任务加入到事件队列末尾，等待主线程调度执行。<br>在这种异步模式下，浏览器永不阻塞，最大限度的保证了单线程的流畅运行。</p><p>js为何会阻碍渲染？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> h1 = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;h1&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;button&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">duration</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">Date</span>.now() + start &lt; duration) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  h1.textContent = <span class="string">&#x27;hahah&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onclick&#x27;</span>)</span><br><span class="line">  delay(<span class="number">3000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码点击按钮时，会打印onclick，延时3秒后h1显示‘hahah’，因为delay方法占据主线程运行3秒，h1.textContent绘制需要事件队列排队等待，造成页面阻塞。</p><p>任务有优先级吗？<br>任务没有优先级，在队列中先进先出<br>但是事件队列是有优先级的。<br>根据w3c最新解释：</p><ul><li>每个任务都有一个类型，同一个类型的任务必须在同一个队列，不同类型的任务可以分属于不同的队列。再一次事件循环中，浏览器可以根据实际情况从不同的队列取出任务执行。</li><li>浏览器必须有一个微队列，微队列中的任务优先于其他任务执行</li></ul><p>随着浏览器的复杂度上升，w3c不再使用宏队列的说法</p><p>在目前chrome的实现中，至少包含以下队列：</p><ul><li>延时队列：用于存放计时器的回调任务，优先级【中】</li><li>交互队列：用于存放用户操作后的回调任务，优先级【高】</li><li>微队列：用户存放最快执行的任务，优先级【最高】</li></ul><p>添加到微队列的方式主要是Promise、MutationObserver<br>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">立即把一个函数添加到微队列</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(函数)</span><br></pre></td></tr></table></figure><p>示例1：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>) <span class="comment">// fn1</span></span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>输出： 2、1</p><p>主线程：全局js<br>微队列：<br>延时队列：fn1<br>交互队列：</p><p>解析：主线程执行全局js，遇到setTimeout，计时线程0秒后将fn1放入延时队列-》继续执行全局js-》输出2-》全局js结束，主线程空，微队列空，执行延时队列fn1-》输出1</p><p>示例2:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">duration</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">Date</span>.now() + start &lt; duration) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">delay()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>输出：等待3秒、2、1</p><p>解析：主线程执行全局js，遇到setTimeout，计时线程0秒后将fn1放入延时队列-》继续执行全局js-》执行delay函数3秒-》输出2-》全局js结束，主线程空，微队列空，执行延时队列fn1-》输出1</p><p>示例3:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>) <span class="comment">// 回调fn1</span></span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>) <span class="comment">// 回调fn2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>输出：3、2、1</p><p>主线程：全局js<br>微队列：fn2<br>延时队列：fn1<br>交互队列：</p><p>解析：<br>  主线程执行全局js，遇到setTimeout，计时线程0秒后将fn1放入延时队列<br>  继续全局js执行，遇Promise，立即将fn2添加到微队列<br>  继续全局js，输出3<br>  全局js结束，主线程空，微队列不为空，执行fn2<br>  输出2，fn2结束，继续循环<br>  微队列空，延迟队列不为空，执行fn1<br>  输出1，fn1结束，继续循环</p><p>示例4:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>) <span class="comment">// fn2</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="comment">// fn3</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(a) <span class="comment">// fn(a)</span></span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>) <span class="comment">// fn4</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>输出：5、4、3、1、2</p><p>主线程：全局js<br>微队列：fn4-&gt;fn(a)-&gt;fn2<br>延时队列：fn3<br>交互队列：</p><p>解析：<br>  主线程执行全局js，遇到setTimeout，计时线程0秒后将fn3放入延时队列<br>  继续全局js执行，遇Promise，立即将fn4添加到微队列<br>  继续全局js，输出5<br>  全局js结束，主线程空，微队列不为空，执行fn4<br>  输出4，结束任务，继续循环，微队列空，查询延时队列不为空<br>  执行fn3，输出3、遇Promise，立即将fn(a)添加到微队列，结束该任务，继续循环<br>  微队列不空，执行fn(a)，输出1，遇Promise，立即将fn2添加到微队列，结束该任务，继续循环<br>  微队列不空，执行fn2，输出2，结束该任务</p><p>示例5:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>) <span class="comment">// fn2</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>) <span class="comment">// fn3</span></span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(a) <span class="comment">// fn(a)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>输出：4、1、2、3</p><p>主线程：全局js<br>微队列：fn(a)-&gt;fn2<br>延时队列：fn3<br>交互队列：</p><p>解析：<br>  主线程执行全局js，遇到setTimeout，计时线程0秒后将fn3放入延时队列<br>  继续全局js执行，遇Promise，立即将fn(a)添加到微队列<br>  继续全局js，输出4<br>  全局js结束，主线程空，微队列不为空，执行fn(a)<br>  输出1，遇Promise，立即将fn2添加到微队列，结束该任务，继续循环<br>  微队列不空，执行fn2，输出2，结束该任务，继续循环<br>  微队列空，延时队列不空，执行fn3，输出3，结束该任务</p><p>阐述js的事件循环：</p><p>事件循环又叫做消息循环，是浏览器的渲染主线程的工作方式。</p><p>在chrome中开启一个无限循环，每次循环从队列中取出第一个任务执行，而其他线程只需要在合适的时机将任务添加到队列末尾。<br>过去把消息队列分为宏队列和微队列，这种说法无法满足复杂的浏览器环境，取而代之的是另一钟灵活的处理方式。</p><p>根据w3c官方解释，每个任务都有一个类型，同一个类型的任务必须在同一个队列，不同任务属于不同的队列。<br>不同的任务队列有不同的优先级，在一次事件循环中，浏览器自行决定选取哪一个队列的任务。但浏览器必须有一个微队列，微队列具有最高的优先级，必须优先调度执行。</p><h3 id="js中计时器能做到精准计时吗？"><a href="#js中计时器能做到精准计时吗？" class="headerlink" title="js中计时器能做到精准计时吗？"></a>js中计时器能做到精准计时吗？</h3><p>不能，因为：</p><ul><li>计算机硬件没有原子钟，无法做到精准计时</li><li>操作系统的计时函数本身就有偏差，js计时器最终调用的是操作系统的函数，所以携带了偏差</li><li>按照w3c的标准，浏览器实现计时器，嵌套超过5层，则会带有4毫秒的最小偏差，计时少于4毫秒又带来偏差</li><li>受事件循环的影响，计时器的回调函数只能在主线程空闲时执行，因此带来偏差</li></ul><p>单线程是异步产生的原因<br>事件循环是异步的实现方式</p><h3 id="浏览器的渲染原理"><a href="#浏览器的渲染原理" class="headerlink" title="浏览器的渲染原理"></a>浏览器的渲染原理</h3><p>当浏览器的网络线程收到HTML文档后，会产生一个渲染任务，并将其传递到渲染主线程的消息队列。<br>在事件循环机制下，渲染主线程取出渲染任务，开启渲染流程。</p><p>整个渲染流程分为多个阶段，分别是：HTML解析、样式计算、布局、分层、绘制、分块、光栅化、画。<br>每个阶段都有明确的输出，上一个阶段的输出是下一个阶段的输入。<br>这样，整个阶段就成为一段严密的流水线。</p><p><strong><em>HTML字符串-〉解析HTML-〉样式计算-〉布局-〉分层-〉绘制-〉分块-〉光栅化-〉画-〉像素信息</em></strong><br>渲染：将html字符串-&gt;像素信息</p><h4 id="1-解析HTML"><a href="#1-解析HTML" class="headerlink" title="1.解析HTML"></a>1.解析HTML</h4><p>**<br>解析过程中遇到css，解析css，遇到js解析js。为了提高效率，浏览器在解析前，会启动一个预解析的线程，率先下载HTML中外部的css文件和外部的js文件。<br>如果主线程解析到link位置，此时外部的css文件还没有解析下载好，主线程不会等待，继续后续HTML的解析。这是因为下载和解析css是在与解析线程中进行的。这就是css不会阻塞HTML解析的根本原因。<br>如果主线程解析道script位置，主线程会停止解析HTML，转而等待js文件下载好，并将全局代码解析完成后，才继续解析HTML。这是因为js代码可能会修改当前的DOM树，所以DOM生成必须暂停。这就是js会阻塞HMTL解析的根本原因。<br>第一步完成后，会生成CSSOM树和DOM树，内部样式、外部样式、内联样式、浏览器默认样式都会包含在CSSOM树。<br>**</p><p>渲染的第一步是解析HTMl，ParseHTML，产生DOM树（Document Object Model）和CSSOM树(css Object Model)</p><p>css样式包括：内部样式style，外部样式link，内联样式，浏览器默认样式<br>js修改style样式，docu.style = ‘’<br>js修改<code>&lt;style&gt;</code>和外部样式，document.styleSheets[0].addRule(‘div’, ‘border: 1px solid #f40’)</p><p>解析HTML，遇到css代码怎么办？<br>为了提高效率，浏览器会启动一个预解析器率先下载和解析css，css不会阻塞解析HTML。</p><h4 id="2、样式计算-recalculate-style"><a href="#2、样式计算-recalculate-style" class="headerlink" title="2、样式计算+ recalculate style"></a>2、样式计算+ recalculate style</h4><p>**<br>主线程遍历整个DOM树，依次为每一个节点计算出最终样式，computed style，<br>在这个过程中，很多预设值会变成绝对值，比如red会变成rgb(255, 0, 0); 相对单位会变成绝对单位，比如em会变成px。<br>这一步完成后，会得到一颗带样式的DOM树<br>**</p><p>getComputedStyle()获取最终样式</p><h4 id="3、布局-Layout"><a href="#3、布局-Layout" class="headerlink" title="3、布局-Layout"></a>3、布局-Layout</h4><p>**<br>接下来是布局，布局完成后会得到布局树。<br>布局阶段会依次遍历DOM树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。<br>大部分时候，DOM树和布局树不是一一对应的。<br>比如dislay:none没有几何信息，因此不会生成到布局树中，又比如使用伪元素选择器，虽然DOM树中不存在这些伪元素节点，但是他们拥有几何信息，所以会生成到布局树。<br>**</p><p>DOM树和布局树不是一一对应的。有几何信息的才会在布局树中出现，display：none不出现<br>文本内容必须放在行盒中。</p><p>document.body.clientWidth,获取的布局信息</p><h4 id="4、分层"><a href="#4、分层" class="headerlink" title="4、分层"></a>4、分层</h4><p>**<br>主线程会使用一套复杂的策略对布局树进行分层。<br>分层的好处在于，将来某一层改变后，仅对该层进行后续处理，从而提高效率。</p><p>滚动条、堆叠上下文、transform、opacity等样式都会影响分层结果。will-change会更大程度影响分层。<br>**</p><h4 id="5、绘制"><a href="#5、绘制" class="headerlink" title="5、绘制"></a>5、绘制</h4><p>**<br>主线程会为每个层单独产生绘制指令集，用于描述每个层的内容该如何画出来。<br>完成绘制后，主线程将绘制信息提交给合成线程，后续工作交由合成线程完成。<br>**</p><h4 id="6、分块"><a href="#6、分块" class="headerlink" title="6、分块"></a>6、分块</h4><p>合成线程会对每个图层进行分块，将其划分为更小的区域。<br>它会从线程池中拿更多线程来完成分块工作。</p><p>分块完成后进入光栅化阶段。</p><h4 id="7-光栅化"><a href="#7-光栅化" class="headerlink" title="7.光栅化"></a>7.光栅化</h4><p>合成线程将块交由GPU进程，完成光栅化，极高速度。<br>GPU进程会开启多个线程完成光栅化，并且优先处理靠近视口区域的块。<br>光栅化的结果是一块一块的位图。</p><h4 id="8-画"><a href="#8-画" class="headerlink" title="8.画"></a>8.画</h4><p>合成线程计算出每个位图的在屏幕上的位置，交由GPU进程最终呈现。</p><p>渲染进程（在沙盒，隔离硬件，安全）：渲染主线程、合成线程</p><p>所以交由GPU进程</p><p>transform发生在合成线程，与渲染主线程无关所以效率高。</p><h3 id="什么是reflow？"><a href="#什么是reflow？" class="headerlink" title="什么是reflow？"></a>什么是reflow？</h3><p>渲染主线程：parse—-computed style—-layout—-layer—-paint<br>合成线程：—-tiling分块—-raster光栅化—-draw-〉</p><p>cssom<br>dom<br>几何信息、布局</p><p>reflow的本质是重新计算布局树。<br>当进行了会影响布局树的操作后，会重新计算布局树，引发layout。<br>为了避免连续多次的操作导致布局树多次计算，浏览器会合并这些操作。当js代码全部执行完后统一计算。所以改动属性引发的reflow是异步的。</p><p>因此js获取布局属性时，可能是重新布局前的信息，无法获取最新的布局信息，浏览器在反复权衡下，最终决定获取布局信息立即reflow。</p><p>doc.style.width = ‘’<br>doc.style.height = ‘’<br>doc.style.margin = ‘’<br>doc.clientWidth // 立即reflow</p><p>哪些操作触发重排？</p><ul><li>更改窗口大小</li><li>更改元素的尺寸、位置、内容</li><li>更改文字大小</li><li>添加或删除可见元素</li><li>页面初始化渲染</li></ul><h3 id="什么是repaint？"><a href="#什么是repaint？" class="headerlink" title="什么是repaint？"></a>什么是repaint？</h3><p>repaint本质是重新根据分层信息计算了绘制指令。<br>当改动了可见样式就需要重新计算，引发repaint。<br>由于元素的布局信息也属于可见样式，所以reflow一定引发repaint。</p><p>哪些操作触发重绘？</p><ul><li>修改元素文本颜色和方向</li><li>修改元素背景色和图片</li><li>修改元素的可见性：如visible</li><li>修改元素的边框和阴影属性</li></ul><h3 id="为什么transform的效率高？"><a href="#为什么transform的效率高？" class="headerlink" title="为什么transform的效率高？"></a>为什么transform的效率高？</h3><p>因为transform既不影响布局也不影响绘制，它影响的是渲染流程的最后一个阶段draw。<br>由于draw阶段在合成线程，所以transform的变化几乎不影响渲染主线程。反之，渲染主线程也不会影响transform的变化。</p><h2 id="2023-11-27"><a href="#2023-11-27" class="headerlink" title="2023-11-27"></a>2023-11-27</h2><h3 id="1-灰阶滤镜"><a href="#1-灰阶滤镜" class="headerlink" title="1.灰阶滤镜"></a>1.灰阶滤镜</h3><p>filter: grayscale(1) 灰阶滤镜 将对应元素的像素点转换为灰色，0是原图，1是全灰，grayscale是filter滤镜中的一种，<br>可以设置在html全局或局部区域上。</p><h3 id="2-js实现无限循环轮播图"><a href="#2-js实现无限循环轮播图" class="headerlink" title="2.js实现无限循环轮播图"></a>2.js实现无限循环轮播图</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Swiper<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    * &#123;</span><br><span class="line">      margin: 0;</span><br><span class="line">      padding: 0;</span><br><span class="line">      box-sizing: border-box;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">      width: 300px;</span><br><span class="line">      height: 200px;</span><br><span class="line">      overflow: hidden;</span><br><span class="line">      border: 1px solid blue;</span><br><span class="line">      position: relative;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.carousel</span> &#123;</span></span><br><span class="line">      display: flex;</span><br><span class="line">      height: 100%;</span><br><span class="line"><span class="css">      <span class="comment">/* transition: 0.5s; */</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.carousel_item</span> &#123;</span></span><br><span class="line">      background-color: aquamarine;</span><br><span class="line">      color: white;</span><br><span class="line">      height: 100%;</span><br><span class="line">      width: 300px;</span><br><span class="line">      min-width: 300px;</span><br><span class="line">      text-align: center;</span><br><span class="line">      font-size: 30px;</span><br><span class="line">      padding-top: 60px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.indicate</span> &#123;</span></span><br><span class="line">      position: absolute;</span><br><span class="line">      bottom: 20px;</span><br><span class="line">      left: 50%;</span><br><span class="line">      transform: translateX(-50%);</span><br><span class="line">      display: flex;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.dot</span> &#123;</span></span><br><span class="line">      width: 10px;</span><br><span class="line">      height: 10px;</span><br><span class="line">      margin: 0 10px 0 0;</span><br><span class="line">      border-radius: 50%;</span><br><span class="line">      border: 2px solid blueviolet;</span><br><span class="line">      background-color: white;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.dot</span><span class="selector-class">.active</span> &#123;</span></span><br><span class="line">      background-color: blueviolet;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;carousel&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;carousel_item&quot;</span> &gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;carousel_item&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;carousel_item&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;indicate&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;dot active&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;dot&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;dot&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 无限循环原理：</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 弹性盒水平排列，设置translateX移动加transition过渡动画</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 克隆第一个轮播图元素到轮播容器末尾，当轮播到最后一个轮播图时即克隆的第一个元素，下标items.length-1</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 指示器active第一个点，过渡动画结束后，立即translateX移动到第一个轮播位置（取消过渡动画），重设轮播的下标为0，实现无痕无限循环轮播</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> doms = &#123;</span></span><br><span class="line"><span class="javascript">      carousel: <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.carousel&#x27;</span>),</span></span><br><span class="line"><span class="javascript">      carouselItems: <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.carousel_item&#x27;</span>),</span></span><br><span class="line"><span class="javascript">      indicators: <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.dot&#x27;</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">moveTo</span>(<span class="params">index</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;moveTo: &#x27;</span> + index)</span></span><br><span class="line"><span class="javascript">      doms.carousel.style.transition = <span class="string">&#x27;0.5s&#x27;</span></span></span><br><span class="line"><span class="javascript">      doms.carousel.style.transform = <span class="string">`translateX(-<span class="subst">$&#123;index&#125;</span>00%)`</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 去除当前选中指示器</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> active = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.dot.active&#x27;</span>)</span></span><br><span class="line"><span class="javascript">      active.classList.remove(<span class="string">&#x27;active&#x27;</span>)</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 重新设置指示器</span></span></span><br><span class="line"><span class="javascript">      doms.indicators[index].classList.add(<span class="string">&#x27;active&#x27;</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="comment">// 给指示器添加点击事件</span></span></span><br><span class="line"><span class="javascript">    doms.indicators.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      item.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">        moveTo(index)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    <span class="comment">// 在轮播收尾各添加一个克隆项</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> firstClone = doms.carouselItems[<span class="number">0</span>].cloneNode(<span class="literal">true</span>)</span></span><br><span class="line">    doms.carousel.appendChild(firstClone)</span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> initialValue = <span class="number">0</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> currentItems = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.carousel_item&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line">      initialValue++</span><br><span class="line"><span class="javascript">      <span class="comment">// 当轮播到最后一张时，轮播指向克隆的第一张，指示器指向第一个，过渡动画结束后移到第一张轮播图</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (initialValue &gt;= currentItems.length + <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="javascript">        doms.carousel.style.transition = <span class="string">&#x27;0.5s&#x27;</span></span></span><br><span class="line"><span class="javascript">        doms.carousel.style.transform = <span class="string">`translateX(-<span class="subst">$&#123;initialValue&#125;</span>00%)`</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 去除当前选中指示器</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> active = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.dot.active&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (active) active.classList.remove(<span class="string">&#x27;active&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 重新设置指示器为第一个</span></span></span><br><span class="line"><span class="javascript">        doms.indicators[<span class="number">0</span>].classList.add(<span class="string">&#x27;active&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line">          initialValue = 0</span><br><span class="line"><span class="javascript">          doms.carousel.style.transition = <span class="string">&#x27;none&#x27;</span></span></span><br><span class="line"><span class="javascript">          doms.carousel.style.transform = <span class="string">`translateX(-<span class="subst">$&#123;initialValue&#125;</span>00%)`</span></span></span><br><span class="line">        &#125;, 500)</span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line">        moveTo(initialValue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, 3000)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-sticky定位"><a href="#3-sticky定位" class="headerlink" title="3.sticky定位"></a>3.sticky定位</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Sticky<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    dl &#123;</span><br><span class="line"><span class="css">      <span class="comment">/* overflow: hidden; */</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    dt &#123;</span><br><span class="line">      background-color: aquamarine;</span><br><span class="line">      font-size: 30px;</span><br><span class="line">      height: 40px;</span><br><span class="line">      position: sticky;</span><br><span class="line">      top: 0;</span><br><span class="line">    &#125;</span><br><span class="line">    dd &#123;</span><br><span class="line">      height: 30px;</span><br><span class="line">      line-height: 30px;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dt</span>&gt;</span>A<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>ALorem, ipsum.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>ANisi, rerum?<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>ANisi, recusandae.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>AIusto, provident!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>AFuga, sed!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>ANemo, nobis?<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>AModi, consequatur.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>ANemo, nihil!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>ARepellat, alias.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>AHic, nostrum!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>AMinima, ducimus.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>ABeatae, a!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>AAccusantium, vel?<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>ACorporis, totam!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>AMinus, sapiente.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>ARem, tenetur.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>ALaboriosam, perferendis.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>AQuisquam, iste!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>AItaque, nihil?<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>AQuos, ipsum.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dt</span>&gt;</span>B<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>BLorem, ipsum.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>BNisi, rerum?<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>BNisi, recusandae.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>BIusto, provident!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>BFuga, sed!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>BNemo, nobis?<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>BModi, consequatur.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>BNemo, nihil!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>BRepellat, alias.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>BHic, nostrum!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>BMinima, ducimus.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>BBeatae, a!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>BAccusantium, vel?<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>BCorporis, totam!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>BMinus, sapiente.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>BRem, tenetur.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>BLaboriosam, perferendis.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>BQuisquam, iste!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>BItaque, nihil?<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>BQuos, ipsum.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>BBeatae, a!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>BAccusantium, vel?<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>BCorporis, totam!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>BMinus, sapiente.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>BRem, tenetur.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>BLaboriosam, perferendis.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>BQuisquam, iste!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>BItaque, nihil?<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>BQuos, ipsum.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dt</span>&gt;</span>C<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CLorem, ipsum.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CNisi, rerum?<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CNisi, recusandae.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CIusto, provident!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CFuga, sed!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CNemo, nobis?<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CModi, consequatur.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CNemo, nihil!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CRepellat, alias.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CHic, nostrum!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CMinima, ducimus.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CBeatae, a!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CAccusantium, vel?<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CCorporis, totam!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CMinus, sapiente.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CRem, tenetur.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CLaboriosam, perferendis.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CQuisquam, iste!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CItaque, nihil?<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CQuos, ipsum.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CMinima, ducimus.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CBeatae, a!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CAccusantium, vel?<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CCorporis, totam!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CMinus, sapiente.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CRem, tenetur.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CLaboriosam, perferendis.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CQuisquam, iste!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CItaque, nihil?<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CQuos, ipsum.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CMinima, ducimus.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CBeatae, a!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CAccusantium, vel?<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CCorporis, totam!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CMinus, sapiente.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CRem, tenetur.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CLaboriosam, perferendis.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CQuisquam, iste!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CItaque, nihil?<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CQuos, ipsum.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CMinima, ducimus.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CBeatae, a!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CAccusantium, vel?<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CCorporis, totam!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CMinus, sapiente.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CRem, tenetur.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CLaboriosam, perferendis.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CQuisquam, iste!<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CItaque, nihil?<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dd</span>&gt;</span>CQuos, ipsum.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，一个 sticky 元素会“固定”在离它最近的一个拥有“滚动机制”的祖先上，如果给其父元素dl设置overflow属性，则该属性失效，如果给body设置overflow属性，则相对于dl元素固定。如果都不设置，则相对于视口。<br>positon: sticky;元素根据正常文档流进行定位，然后相对它的最近滚动祖先和包含块，包括 table-related 元素，基于 top、right、bottom 和 left 的值进行偏移。<br>该值总是创建一个新的层叠上下文。须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</p><h3 id="4-visibilitychange-离开-进入标签页事件-页面可见度"><a href="#4-visibilitychange-离开-进入标签页事件-页面可见度" class="headerlink" title="4.visibilitychange 离开/进入标签页事件-页面可见度"></a>4.visibilitychange 离开/进入标签页事件-页面可见度</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;visibilitychange&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">document</span>.visibilityState) <span class="comment">// hidden, visible</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="5-零宽字符"><a href="#5-零宽字符" class="headerlink" title="5.零宽字符"></a>5.零宽字符</h3><p>零宽字符是一种不可打印的Unicode字符，在浏览器等环境不可见，但是真实存在，获取字符串长度时也会占位置，表示某一种控制功能的字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str1 = <span class="string">&#x27;哈哈\u200d\u200d嘿嘿&#x27;</span></span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">&#x27;哈哈嘿嘿&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(str1, str1.length, str1 === str2) <span class="comment">// 哈哈‍‍嘿嘿 6 false</span></span><br></pre></td></tr></table></figure><h3 id="6-求和"><a href="#6-求和" class="headerlink" title="6.求和"></a>6.求和</h3><p>求1开始的前n项的奇数和</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        result+=<span class="number">2</span>*i+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line">sum(<span class="number">2</span>) <span class="comment">// 4</span></span><br><span class="line">sum(<span class="number">3</span>) <span class="comment">// 9</span></span><br><span class="line">sum(<span class="number">4</span>) <span class="comment">// 16</span></span><br><span class="line">sum(<span class="number">5</span>) <span class="comment">// 25</span></span><br><span class="line">sum(<span class="number">6</span>) <span class="comment">// 36</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n*n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求1开始的前n项的偶数和</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        result+=<span class="number">2</span>*(i+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>) <span class="comment">// 2 = 1*2</span></span><br><span class="line">sum(<span class="number">2</span>) <span class="comment">// 6 = 2*3</span></span><br><span class="line">sum(<span class="number">3</span>) <span class="comment">// 12 = 3*4</span></span><br><span class="line">sum(<span class="number">4</span>) <span class="comment">// 20 = 4*5</span></span><br><span class="line">sum(<span class="number">5</span>) <span class="comment">// 30 = 5*6</span></span><br><span class="line">sum(<span class="number">6</span>) <span class="comment">// 42 = 6*7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n*(n+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求1开始的前n项的和</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        result+=(i+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>) <span class="comment">// 1 = n*(n+1)/2</span></span><br><span class="line">sum(<span class="number">2</span>) <span class="comment">// 3 </span></span><br><span class="line">sum(<span class="number">3</span>) <span class="comment">// 6</span></span><br><span class="line">sum(<span class="number">4</span>) <span class="comment">// 10</span></span><br><span class="line">sum(<span class="number">5</span>) <span class="comment">// 15</span></span><br><span class="line">sum(<span class="number">6</span>) <span class="comment">// 21</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n*(n+<span class="number">1</span>)/<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求1-n之间的奇数和</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i%<span class="number">2</span> = <span class="number">1</span>) &#123;</span><br><span class="line">        result+=i</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line">sum(<span class="number">2</span>) <span class="comment">// 1 </span></span><br><span class="line">sum(<span class="number">3</span>) <span class="comment">// 4</span></span><br><span class="line">sum(<span class="number">4</span>) <span class="comment">// 4</span></span><br><span class="line">sum(<span class="number">5</span>) <span class="comment">// 9</span></span><br><span class="line">sum(<span class="number">6</span>) <span class="comment">// 9</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-文字描边text-stroke"><a href="#7-文字描边text-stroke" class="headerlink" title="7.文字描边text-stroke"></a>7.文字描边text-stroke</h3><p>-webkit-text-stroke: 2px #fff;</p><h3 id="8-js类里创建私有字段"><a href="#8-js类里创建私有字段" class="headerlink" title="8.js类里创建私有字段"></a>8.js类里创建私有字段</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._abc = <span class="number">1</span> <span class="comment">// 以前没有私有字段用_来说明是私有字段但是外部可以访问</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">new</span> A()</span><br><span class="line">    <span class="built_in">console</span>.log(a._abc) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">      #abc; <span class="comment">// 定义一个私有字段</span></span><br><span class="line">      <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.#abc = <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">      #method ()&#123;&#125; <span class="comment">// 私有方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="keyword">new</span> B()</span><br><span class="line">    <span class="built_in">console</span>.log(b, b.#abc) <span class="comment">// private field &#x27;#abc&#x27; must be declared in an enclosing class</span></span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="9-下拉菜单的过渡效果"><a href="#9-下拉菜单的过渡效果" class="headerlink" title="9.下拉菜单的过渡效果"></a>9.下拉菜单的过渡效果</h3><p><strong>css获取焦点设置高度auto展开，但是transition无效，只针对数值有效。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>select-transition<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    * &#123;</span><br><span class="line">      margin: 0;</span><br><span class="line">      padding: 0;</span><br><span class="line">      box-sizing: border-box;</span><br><span class="line">    &#125;</span><br><span class="line">    body &#123;</span><br><span class="line">      padding-left: 100px;</span><br><span class="line">    &#125;</span><br><span class="line">    input &#123;</span><br><span class="line">      width: 400px;</span><br><span class="line">      height: 40px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.select</span> &#123;</span></span><br><span class="line">      width: 400px;</span><br><span class="line">      border-right: 1px solid;</span><br><span class="line">      border-left: 1px solid;</span><br><span class="line">      border-bottom: 1px solid;</span><br><span class="line">      margin-top: -1px;</span><br><span class="line">      height: 0;</span><br><span class="line">      overflow: hidden;</span><br><span class="line">      transition: 1s;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.select</span> &gt; <span class="selector-tag">div</span> &#123;</span></span><br><span class="line">      line-height: 30px;</span><br><span class="line">      padding-left: 20px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-tag">input</span><span class="selector-pseudo">:focus</span> ~ <span class="selector-class">.select</span> &#123;</span></span><br><span class="line">      height: auto</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;select&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Lorem, ipsum.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Ab, vel?<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Voluptatum, iusto.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Atque, repudiandae?<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Corporis, voluptas.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>已知select高度情况下可以设置具体值，比如</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:focus</span> ~ <span class="selector-class">.select</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>设置max-height值也可以实现效果。</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>select-transition<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    * &#123;</span><br><span class="line">      margin: 0;</span><br><span class="line">      padding: 0;</span><br><span class="line">      box-sizing: border-box;</span><br><span class="line">    &#125;</span><br><span class="line">    body &#123;</span><br><span class="line">      padding-left: 100px;</span><br><span class="line">    &#125;</span><br><span class="line">    input &#123;</span><br><span class="line">      width: 400px;</span><br><span class="line">      height: 40px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.select</span> &#123;</span></span><br><span class="line">      width: 400px;</span><br><span class="line">      border-right: 1px solid;</span><br><span class="line">      border-left: 1px solid;</span><br><span class="line">      border-bottom: 1px solid;</span><br><span class="line">      margin-top: -1px;</span><br><span class="line">      height: auto;</span><br><span class="line">      overflow: hidden;</span><br><span class="line">      max-height: 0;</span><br><span class="line">      transition: 1s;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.select</span> &gt; <span class="selector-tag">div</span> &#123;</span></span><br><span class="line">      line-height: 30px;</span><br><span class="line">      padding-left: 20px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-tag">input</span><span class="selector-pseudo">:focus</span> ~ <span class="selector-class">.select</span> &#123;</span></span><br><span class="line">      max-height: 300px;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;select&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Lorem, ipsum.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Ab, vel?<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Voluptatum, iusto.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Atque, repudiandae?<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Corporis, voluptas.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，max-height的值，300px的高度过渡动画为1s，但实际上select真实高度并不一定是300，因此失焦时收起select会有延时</p><p><strong>使用js添加获取/失去焦点事件控制select高度。</strong></p><p>先css设置height为0，获取焦点时，设置高度auto获取实际高度，然后再设置select高度0，再设置获取的实际高度和transition，失焦时隐藏高度</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>select-transition<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    * &#123;</span><br><span class="line">      margin: 0;</span><br><span class="line">      padding: 0;</span><br><span class="line">      box-sizing: border-box;</span><br><span class="line">    &#125;</span><br><span class="line">    body &#123;</span><br><span class="line">      padding-left: 100px;</span><br><span class="line">    &#125;</span><br><span class="line">    input &#123;</span><br><span class="line">      width: 400px;</span><br><span class="line">      height: 40px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.select</span> &#123;</span></span><br><span class="line">      width: 400px;</span><br><span class="line">      border-right: 1px solid;</span><br><span class="line">      border-left: 1px solid;</span><br><span class="line">      border-bottom: 1px solid;</span><br><span class="line">      margin-top: -1px;</span><br><span class="line">      height: 0;</span><br><span class="line">      overflow: hidden;</span><br><span class="line">      transition: 1s;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.select</span> &gt; <span class="selector-tag">div</span> &#123;</span></span><br><span class="line">      line-height: 30px;</span><br><span class="line">      padding-left: 20px;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;select&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Lorem, ipsum.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Ab, vel?<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Voluptatum, iusto.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Atque, repudiandae?<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Corporis, voluptas.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> input = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;input&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> select = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.select&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    input.onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      select.style.transition = <span class="string">&#x27;none&#x27;</span></span></span><br><span class="line"><span class="javascript">      select.style.height = <span class="string">&#x27;auto&#x27;</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 获取select高度</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> height = select.offsetHeight</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(height)</span></span><br><span class="line">      select.style.height = 0</span><br><span class="line"><span class="javascript">      select.offsetHeight <span class="comment">// 获取元素几何信息强制浏览器渲染，因为浏览器js设置dom会合并操作所以需要强制渲染</span></span></span><br><span class="line"><span class="javascript">      select.style.transition = <span class="string">&#x27;1s&#x27;</span></span></span><br><span class="line"><span class="javascript">      select.style.height = height + <span class="string">&#x27;px&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    input.onblur = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      select.style.transition = <span class="string">&#x27;1s&#x27;</span></span></span><br><span class="line"><span class="javascript">      select.style.height = <span class="string">&#x27;0&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>利用css3的scaleY缩放高度。</strong></p><p>注：缩放过程字体会重叠</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>select-transition<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    * &#123;</span><br><span class="line">      margin: 0;</span><br><span class="line">      padding: 0;</span><br><span class="line">      box-sizing: border-box;</span><br><span class="line">    &#125;</span><br><span class="line">    body &#123;</span><br><span class="line">      padding-left: 100px;</span><br><span class="line">    &#125;</span><br><span class="line">    input &#123;</span><br><span class="line">      width: 400px;</span><br><span class="line">      height: 40px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.select</span> &#123;</span></span><br><span class="line">      width: 400px;</span><br><span class="line">      border-right: 1px solid;</span><br><span class="line">      border-left: 1px solid;</span><br><span class="line">      border-bottom: 1px solid;</span><br><span class="line">      margin-top: -1px;</span><br><span class="line">      height: auto;</span><br><span class="line">      overflow: hidden;</span><br><span class="line">      transition: 1s;</span><br><span class="line">      z-index: -1;</span><br><span class="line">      transform-origin: center top;</span><br><span class="line">      transform: scaleY(0);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.select</span> &gt; <span class="selector-tag">div</span> &#123;</span></span><br><span class="line">      line-height: 30px;</span><br><span class="line">      padding-left: 20px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-tag">input</span><span class="selector-pseudo">:focus</span> ~ <span class="selector-class">.select</span> &#123;</span></span><br><span class="line">      transform: scaleY(1);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;select&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Lorem, ipsum.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Ab, vel?<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Voluptatum, iusto.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Atque, repudiandae?<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>Corporis, voluptas.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="10-跨域cors"><a href="#10-跨域cors" class="headerlink" title="10.跨域cors"></a>10.跨域cors</h3><p>CORS是基于http1.1的一种跨域解决方案，全称跨域资源共享。<br>它的总体思路：如果浏览器要跨域访问服务器的资源，需要获取服务器的允许。</p><p>针对不同请求，cors规定里三种不同的交互模式：</p><ul><li>简单请求</li><li>需要预检的请求</li><li>携带身份凭证的请求</li></ul><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><ol><li><p>请求方法属于以下的一种：get、post、head</p></li><li><p>请求头仅包含安全的字段，常见安全字段如下：</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type</li><li>DPR</li><li>Downlink</li><li>Save-Data</li><li>Viewport-Width</li><li>Width</li></ul></li><li><p>请求头如果包含Content-Type，仅限以下值之一：</p><ul><li>text/plain-文本内容数据</li><li>multipart/form-data-文件上传</li><li>application/x-www-form-urlencoded–提交表单</li></ul></li></ol><p>以上三个条件都满足，浏览器判断为简单请求。</p><h4 id="简单请求的交互规范"><a href="#简单请求的交互规范" class="headerlink" title="简单请求的交互规范"></a>简单请求的交互规范</h4><p>当前浏览器某个跨域请求是简单请求时，会发生以下：</p><ol><li>请求头中会自动添加Origin字段，哪个源地址在跨域请求</li><li>服务器响应头应包含Access-Control-Allow-Origin<br>服务器收到响应，如果允许跨域，则在响应头添加Access-Control-Allow-Origin字段，该属性值有：<ul><li>*：允许一切</li><li><code>http://my.com</code>: 只允许<code>http://my.com</code>这个源访问</li></ul></li></ol><h4 id="需要预检的请求"><a href="#需要预检的请求" class="headerlink" title="需要预检的请求"></a>需要预检的请求</h4><p>如果浏览器不认为是简单请求，会按照以下流程进行：</p><ul><li>浏览器发送预检请求，访问服务器是否允许</li><li>服务器允许访问</li><li>浏览器发送真实的请求</li><li>服务器完成真实的响应</li></ul><p>例如以下请求，就是需要预检请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&quot;http://my.com/api/user&quot;</span>, &#123;</span><br><span class="line">  method: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">  header: &#123;</span><br><span class="line">    a:<span class="number">1</span></span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  body: ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="附带身份凭证的请求"><a href="#附带身份凭证的请求" class="headerlink" title="附带身份凭证的请求"></a>附带身份凭证的请求</h4><p>默认情况下，ajax的请求并不会携带cookie，可以配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xhr</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fetch api</span></span><br><span class="line">fetch(url, &#123;</span><br><span class="line">  credentials: <span class="string">&#x27;include&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样，该跨域的请求就是附带身份凭证的请求。当一个请求附带cookie时，无论是简单请求还是预检请求，都会在请求头中添加cookie字段，<br>而服务器响应时需要明确告知客户端服务器允许这样的凭证：Access-Control-Allow-Credentials: true.若服务器没有响应则跨域被拒绝，<br>注意：对于附带身份凭证的请求，服务器不得设置Access-Control-Allow-Origin:*。</p><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>在跨域访问时，js只能拿到一些最基本的响应头，比如：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Progma，如果要访问其他头，需要服务器设置响应头。</p><p>Access-Control-Export-Headers：authorization…,这样浏览器就可以访问authorization响应头了。</p><h3 id="10-解析url中的参数"><a href="#10-解析url中的参数" class="headerlink" title="10.解析url中的参数"></a>10.解析url中的参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseQuery</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> q = &#123;&#125;</span><br><span class="line">  url.replace(<span class="regexp">/([^?&amp;=]+)=([^&amp;]+)/g</span>,</span><br><span class="line">  (_, k, v) =&gt; (q[k] = v))</span><br><span class="line">  <span class="keyword">return</span> q</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = parseQuery(<span class="string">&#x27;http://my.com?a=1&amp;b=2&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> b = parseQuery(<span class="string">&#x27;a=1&amp;b=2&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a, b)</span><br></pre></td></tr></table></figure><p><code>/</code> 和 <code>/g</code>：这两个符号是正则表达式的开始和结束标记，g 标志表示全局搜索，即匹配字符串中所有符合条件的子串，而不是只匹配第一个。</p><p><code>([^?&amp;=]+)</code>：</p><p><code>[]</code>：字符集，匹配方括号中的任意一个字符。<br><code>^</code>：在字符集中，表示非，即不匹配后续列出的字符。<br><code>?&amp;=</code>：列出的字符集，包括问号、等号和与号。<br><code>+</code>：表示匹配一次或多次。<br>所以 <code>([^?&amp;=]+)</code> 匹配一个或多个不是 ?、&amp; 或 = 的字符。这部分通常用于匹配 URL 查询字符串中的参数名。<br>=：匹配等号字符，即 URL 查询字符串中用来分隔参数名和参数值的字符。</p><p><code>([^&amp;]+)</code>：</p><p><code>[^&amp;]</code>：字符集，匹配除了与号 &amp; 以外的任意字符。<br><code>+</code>：表示匹配一次或多次。<br>所以 <code>([^&amp;]+)</code> 匹配一个或多个不是 &amp; 的字符。这部分通常用于匹配 URL 查询字符串中的参数值。</p><h3 id="11-生成随机颜色"><a href="#11-生成随机颜色" class="headerlink" title="11.生成随机颜色"></a>11.生成随机颜色</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span> + <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">0xffffff</span>).toString(<span class="number">16</span>).padEnd(<span class="number">6</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// padEnd() 方法会将当前字符串从末尾开始填充给定的字符串（如果需要会重复填充），直到达到给定的长度。填充是从当前字符串的末尾开始的。</span></span><br><span class="line"><span class="built_in">console</span>.log(randomColor())</span><br></pre></td></tr></table></figure><ol><li>0xffffff 是一个十六进制数，它等于十进制的 16777215</li><li>Math.random() 是 JavaScript 中的一个函数，它返回一个大于等于 0 且小于 1 的伪随机数.</li><li>Math.floor(Math.random() * 0xffffff),向下取整，确保得到的结果是一个0-16777214的整数</li><li>toString(16) 方法将这个随机整数转换为十六进制字符串</li></ol><h3 id="12-js的atob和btoa函数"><a href="#12-js的atob和btoa函数" class="headerlink" title="12.js的atob和btoa函数"></a>12.js的atob和btoa函数</h3><p>btoa() 方法可以将一个二进制字符串（例如，将字符串中的每一个字节都视为一个二进制数据字节）编码为 Base64 编码的 ASCII 字符串.<br>atob() 对经过 base-64 编码的字符串进行解码.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> encodedData = <span class="built_in">window</span>.btoa(<span class="string">&quot;Hello, world&quot;</span>); <span class="comment">// 编码</span></span><br><span class="line"><span class="keyword">let</span> decodedData = <span class="built_in">window</span>.atob(encodedData); <span class="comment">// 解码</span></span><br><span class="line"><span class="built_in">console</span>.log(encodedData, decodedData)</span><br><span class="line"><span class="comment">// SGVsbG8sIHdvcmxk Hello, world</span></span><br></pre></td></tr></table></figure><h3 id="13-判断一个值是否是Promise-Like？"><a href="#13-判断一个值是否是Promise-Like？" class="headerlink" title="13.判断一个值是否是Promise Like？"></a>13.判断一个值是否是Promise Like？</h3><p>和Promise结构类似<br>Promise A+规范：<a href="https://promisesaplus.com/">https://promisesaplus.com/</a><br>“promise”是一个具有符合本规范的then方法的对象或函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPromiseLike</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> value === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> value === <span class="string">&#x27;function&#x27;</span>) &amp;&amp; (<span class="keyword">typeof</span> value.then === <span class="string">&#x27;function&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-手写一个Promise"><a href="#14-手写一个Promise" class="headerlink" title="14.手写一个Promise"></a>14.手写一个Promise</h3><p>promise是一个构造函数，带有then方法<br>它有三种状态：pending 挂起，任务进行中、fulfilled 完成、rejected 失败<br>then方法接收2个参数，onFulfilled 和 onRejected 都是可选参数，它们是异步执行的<br>可以多次对同一个promise调用then方法，从而注册多个onFulfilled或onRejected<br>then方法必须再次返回一个promise<br>Promise(resolve, reject), resolve, reject是函数,改变状态</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> FULLFILLED = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// promise是一个构造函数，带有then方法</span></span><br><span class="line"><span class="comment">// 它有三种状态：pending 挂起，任务进行中、fulfilled 完成、rejected 失败</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  #state = PENDING <span class="comment">// 私有属性，promise初始状态pending</span></span><br><span class="line">  #result = <span class="literal">undefined</span> <span class="comment">// 私有属性，promise结果</span></span><br><span class="line">  #handler = [] <span class="comment">// 保存每次调用then方法的回调onFulfilled, onRejected，resolve，reject</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 改变状态</span></span><br><span class="line">      <span class="built_in">this</span>.#changeState(FULLFILLED, data)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 改变状态</span></span><br><span class="line">      <span class="built_in">this</span>.#changeState(REJECTED, reason)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executor(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  #<span class="function"><span class="title">changeState</span>(<span class="params">state, result</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.#state !== PENDING) <span class="keyword">return</span> <span class="comment">// 状态一旦改变不可再更改</span></span><br><span class="line">    <span class="built_in">this</span>.#state = state</span><br><span class="line">    <span class="built_in">this</span>.#result = result</span><br><span class="line">    <span class="built_in">this</span>.#run() <span class="comment">// 异步的时候这里知道什么时候改变状态</span></span><br><span class="line">  &#125;</span><br><span class="line">  #<span class="function"><span class="title">isPromiseLike</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> value === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> value === <span class="string">&#x27;function&#x27;</span>) &amp;&amp; (<span class="keyword">typeof</span> value.then === <span class="string">&#x27;function&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  #<span class="function"><span class="title">runMicroTask</span>(<span class="params">callback</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(callback, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  #<span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// fulfilled、rejected、pending</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.#state === PENDING) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历then方法的回调执行</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">this</span>.#handler.length) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; onFulfilled, onRejected, resolve, reject &#125; = <span class="built_in">this</span>.#handler.shift()</span><br><span class="line">      <span class="comment">// p.then传递参数 onFulfilled, onRejected：</span></span><br><span class="line">      <span class="comment">// 1.回调不是函数：p.then(null), 直接resolve， rejected</span></span><br><span class="line">      <span class="comment">// 2.回调是函数：函数有执行结果 p.then((res)=&gt; &#123;&#125;, err =&gt; &#123;&#125;)</span></span><br><span class="line">      <span class="comment">// 3.回调的函数的返回结果是promise</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.#state === FULLFILLED) &#123;</span><br><span class="line">        <span class="built_in">this</span>.#runMicroTask(<span class="function">() =&gt;</span> &#123; <span class="comment">// promise运行在微队列中</span></span><br><span class="line">          <span class="comment">// 回调不是函数</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> onFulfilled !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            resolve(<span class="built_in">this</span>.#result)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 回调是函数</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">const</span> data = onFulfilled(<span class="built_in">this</span>.#result) <span class="comment">// 回调的函数返回结果是promise</span></span><br><span class="line">              <span class="keyword">if</span> (<span class="built_in">this</span>.#isPromiseLike(data)) &#123;</span><br><span class="line">                data.then(resolve, reject)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(data)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">              reject(error)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// rejected</span></span><br><span class="line">        <span class="built_in">this</span>.#runMicroTask(<span class="function">() =&gt;</span> &#123; <span class="comment">// promise运行在微队列中</span></span><br><span class="line">          <span class="comment">// 回调不是函数</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            reject(<span class="built_in">this</span>.#result)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 回调是函数</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">const</span> data = onRejected(<span class="built_in">this</span>.#result) <span class="comment">// 回调的函数返回结果是promise</span></span><br><span class="line">              <span class="keyword">if</span> (<span class="built_in">this</span>.#isPromiseLike(data)) &#123;</span><br><span class="line">                data.then(resolve, reject)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(data)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">              reject(error)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// then方法接收2个参数，onFulfilled 和 onRejected 都是可选参数，它们是异步执行的</span></span><br><span class="line">  <span class="comment">// 可以多次对同一个promise调用then方法，从而注册多个onFulfilled或onRejected</span></span><br><span class="line">  <span class="comment">// then方法必须再次返回一个promise</span></span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 如果是同步：状态直接是fulfilled/rejected</span></span><br><span class="line">      <span class="comment">// 异步：pending</span></span><br><span class="line">      <span class="comment">// 可多次调用、可能异步（pending）</span></span><br><span class="line">      <span class="comment">// 保存每次调用then方法的回调onFulfilled, onRejected，resolve，reject，等待完成即状态改变（#changeState）时调用</span></span><br><span class="line">      <span class="built_in">this</span>.#handler.push(&#123;</span><br><span class="line">        onFulfilled,</span><br><span class="line">        onRejected,</span><br><span class="line">        resolve,</span><br><span class="line">        reject</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="built_in">this</span>.#run()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="number">123</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// p.then(</span></span><br><span class="line"><span class="comment">//   null,</span></span><br><span class="line"><span class="comment">//   (err) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     console.log(&#x27;promise-fail1&#x27;, err)</span></span><br><span class="line"><span class="comment">//     return 456</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// ).then(</span></span><br><span class="line"><span class="comment">//   (res) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     console.log(&#x27;promise-success2&#x27;, res)</span></span><br><span class="line"><span class="comment">//   &#125;,</span></span><br><span class="line"><span class="comment">//   (err) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     console.log(&#x27;promise-fail2&#x27;, err)</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// )</span></span><br><span class="line"><span class="comment">// promise-fail1 123</span></span><br><span class="line"><span class="comment">// promise-success2 456</span></span><br><span class="line"></span><br><span class="line">p.then(</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  (err) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise-fail1&#x27;</span>, err)</span><br><span class="line">    <span class="keyword">throw</span> <span class="number">456</span></span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  (res) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise-success2&#x27;</span>, res)</span><br><span class="line">  &#125;,</span><br><span class="line">  (err) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise-fail2&#x27;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// promise-fail1 123</span></span><br><span class="line"><span class="comment">// promise-fail2 456</span></span><br></pre></td></tr></table></figure><h3 id="15-语义化版本"><a href="#15-语义化版本" class="headerlink" title="15.语义化版本"></a>15.语义化版本</h3><p>x.y.z ， x、y、z都是数字，只能增加<br>x：主版本，breaking update， 不兼容式升级，比如vue2-vue3<br>y：次版本，更新兼容以前版本<br>z：修订版本，修复bug，优化等</p><p>1.8.2-&gt;2.0.0<br>1.8.2-&gt;1.9.0</p><p>高位版本增加，低位版本要清零</p><p>0.1.0，主版本0表示测试版本，未正式发布<br>1.2.3-alpha，alpha预发布版本</p><h3 id="16-axios"><a href="#16-axios" class="headerlink" title="16.axios"></a>16.axios</h3><p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p><p>特性</p><p>  从浏览器中创建 XMLHttpRequests<br>  从 node.js 创建 http 请求<br>  支持 Promise API<br>  拦截请求和响应<br>  转换请求数据和响应数据<br>  取消请求<br>  自动转换 JSON 数据<br>  客户端支持防御 XSRF</p><h3 id="17-数据埋点"><a href="#17-数据埋点" class="headerlink" title="17.数据埋点"></a>17.数据埋点</h3><p>服务监控：产品（ARMS、神策，sentry免费）</p><p>  错误监控<br>  性能监控<br>  行为监控</p><p>数据埋点：</p><p>  侵入：监控用户行为，关键业务代码处埋点<br>  非侵入：错误、性能监控，对代码等无侵入，在入口文件收集即可</p><h3 id="18-web性能指标"><a href="#18-web性能指标" class="headerlink" title="18.web性能指标"></a>18.web性能指标</h3><p>评定web应用程序用户体验是否优秀：</p><p>  RAIL模型：Response响应时间、Animation动画流畅不丢帧不跳帧、Idle页面运行过程是否给用户留够交互时间、load加载时间</p><p>衡量的关键指标：</p><ul><li>FCP：首次内容加载经过的时间，从白屏到第一个有意义的内容（可以是文字、图片、按钮或背景色元素，看得见的内容）出现的时间</li><li>LCP：最大内容绘制时间，屏幕内最大的元素加载出来</li><li>CLS：累计偏移，前面有内容突然加载出来导致内容往后挤，破坏用户的操作，比如点击按钮时，前面有内容加载导致按钮往后排，点击到别的按钮等</li><li>TBT：total blocking time总的阻塞时间，从FCP到TTI的时间，TTI表示用户可交互的时间点</li></ul><p>使用Chrome lighthouse工具衡量这些指标</p><p>了解用户真实指标需要收集，第三方库web vitals</p><h3 id="19-从视频文件中提取画面帧"><a href="#19-从视频文件中提取画面帧" class="headerlink" title="19.从视频文件中提取画面帧"></a>19.从视频文件中提取画面帧</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>提取视频文件中的画面帧<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;video&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> file = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;input[type=file]&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    file.onchange = <span class="keyword">async</span> (e) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(e.target.files)</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> file = e.target.files[<span class="number">0</span>]</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 提取第10秒的帧并img预览</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// const frame = await captureFrame(file, 10)</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// createPreview(frame)</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// console.log(frame)</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 每隔1秒提取帧展示</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> frame = <span class="keyword">await</span> captureFrame(file, <span class="number">1</span> * i)</span></span><br><span class="line">        createPreview(frame)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">drawVideo</span>(<span class="params">vdo</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> cvs = <span class="built_in">document</span>.createElement(<span class="string">&#x27;canvas&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> ctx = cvs.getContext(<span class="string">&#x27;2d&#x27;</span>)</span></span><br><span class="line">        cvs.width = vdo.videoWidth</span><br><span class="line">        cvs.height = vdo.videoHeight</span><br><span class="line">        ctx.drawImage(vdo, 0, 0, cvs.width, cvs.height)</span><br><span class="line"><span class="javascript">        cvs.toBlob(<span class="function">(<span class="params">blob</span>) =&gt;</span> &#123;</span></span><br><span class="line">          resolve(&#123;</span><br><span class="line">            blob,</span><br><span class="line">            url: URL.createObjectURL(blob)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">captureFrame</span>(<span class="params">vdoFile, time = <span class="number">0</span></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> vdo = <span class="built_in">document</span>.createElement(<span class="string">&#x27;video&#x27;</span>)</span></span><br><span class="line">        vdo.currentTime = time</span><br><span class="line"><span class="javascript">        vdo.muted = <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">        vdo.autoplay = <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">        vdo.oncanplay = <span class="keyword">async</span> () =&gt; &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">const</span> frame = <span class="keyword">await</span> drawVideo(vdo)</span></span><br><span class="line">          resolve(frame)</span><br><span class="line">        &#125;</span><br><span class="line">        vdo.src = URL.createObjectURL(vdoFile)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">createPreview</span>(<span class="params">frame</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> img = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>)</span></span><br><span class="line">      img.src = frame.url</span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.body.append(img)</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="20-ESMoudle的工作原理"><a href="#20-ESMoudle的工作原理" class="headerlink" title="20.ESMoudle的工作原理"></a>20.ESMoudle的工作原理</h3><p>静态导入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> A <span class="keyword">from</span> <span class="string">&#x27;./A.js&#x27;</span></span><br></pre></td></tr></table></figure><p>动态导入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;./dynmaic.js&#x27;</span>).then(<span class="function"><span class="params">d</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(d.default)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>静态导入解析是在运行之前发生的，动态导入的解析是在运行时发生的。<br>比如import A from ‘./A.js’，会先将A.js转换为完整的引入url：***/A.js，再下载，先模块解析，再运行<br>动态导入：完整URL-》下载js-》解析-》运行-》然后执行then里面语句</p><h3 id="21-defineProperty和proxy"><a href="#21-defineProperty和proxy" class="headerlink" title="21.defineProperty和proxy"></a>21.defineProperty和proxy</h3><p>defineProperty是对象基本操作（内部函数调用），用来定义属性描述符的，不能暴露给开发者，比如get读取属性会调用has方法，delete obj[k] 调用内部函数delete<br>proxy针对所有的操作都可以拦截，也暴露了内部方法。</p><h3 id="22-垃圾回收与内存泄露"><a href="#22-垃圾回收与内存泄露" class="headerlink" title="22.垃圾回收与内存泄露"></a>22.垃圾回收与内存泄露</h3><p>程序运行需要内存空间，可能某一块内存空间不再需要，这块内存空间称为垃圾，回收垃圾的叫垃圾回收器<br>内存泄露：一块内存空间不需要但垃圾回收器没法回收的内存就是内存泄露</p><p>垃圾回收机制：标记清除算法、引用计数算法（不用）</p><p>造成内存泄露的因素：一些未声明直接赋值的变量；未清除的定时器；过度的闭包；未清除的引用元素</p><h3 id="23-解析DOM树"><a href="#23-解析DOM树" class="headerlink" title="23.解析DOM树"></a>23.解析DOM树</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeTag</span>(<span class="params">fragment</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">new</span> DOMParser().parseFromString(fragment, <span class="string">&#x27;text/html&#x27;</span>).body.textContent || <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">removeTag(<span class="string">`&lt;div class=&quot;container&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;h1&gt;DOM Parser&lt;/h1&gt;</span></span><br><span class="line"><span class="string">    &lt;ul&gt;</span></span><br><span class="line"><span class="string">      &lt;li&gt;Lorem.&lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;li&gt;Maiores.&lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;li&gt;Sapiente!&lt;/li&gt;</span></span><br><span class="line"><span class="string">      &lt;li&gt;Doloremque.&lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;`</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// DOM Parser</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">// Lorem.</span></span><br><span class="line"><span class="comment">// Maiores.</span></span><br><span class="line"><span class="comment">// Sapiente!</span></span><br><span class="line"><span class="comment">// Doloremque.</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure><h3 id="22-大文件切片上传"><a href="#22-大文件切片上传" class="headerlink" title="22. 大文件切片上传"></a>22. 大文件切片上传</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>大文件上传切片<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;fileUpload&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./upload.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>upload.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> uploadFile = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#fileUpload&quot;</span>)</span><br><span class="line"></span><br><span class="line">uploadFile.onchange = <span class="keyword">async</span> e =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> file = e.target.files[<span class="number">0</span>]</span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">&quot;upfile&quot;</span>)</span><br><span class="line">  <span class="keyword">const</span> chunks = <span class="keyword">await</span> cutFile(file) <span class="comment">// 获取分片结果</span></span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">&quot;upfile&quot;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;切片：&quot;</span>, chunks)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CHUNK_SIZE = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">5</span> <span class="comment">// 5M</span></span><br><span class="line"><span class="keyword">const</span> THREAD_COUNT = navigator.hardwareConcurrency || <span class="number">4</span> <span class="comment">// 线程数量（切片运行在主线程可能会造成阻塞，可开启别的线程进行分片工作）</span></span><br><span class="line"><span class="comment">// 分片</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">cutFile</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 比如 file.size :70M, chunkCount: 14  workerChunkCount: 4</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="keyword">async</span> (resolve, reject) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> chunkCount = <span class="built_in">Math</span>.ceil(file.size / CHUNK_SIZE) <span class="comment">// 分片数量</span></span><br><span class="line">    <span class="keyword">const</span> workerChunkCount = <span class="built_in">Math</span>.ceil(chunkCount / THREAD_COUNT) <span class="comment">// 每个线程处理的分片数量</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;切片数量&quot;</span>, chunkCount)</span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    <span class="comment">// 切片运行在主线程</span></span><br><span class="line">    <span class="comment">// for (let i = 0; i &lt; chunkCount; i++) &#123;</span></span><br><span class="line">    <span class="comment">//   const chunk = await createChunk(file, i, CHUNK_SIZE)</span></span><br><span class="line">    <span class="comment">//   result.push(chunk)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 开启其他线程去分片提高效率</span></span><br><span class="line">    <span class="keyword">let</span> finishWorker = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> worker = <span class="keyword">new</span> Worker(<span class="string">&quot;./worker.js&quot;</span>, &#123;</span><br><span class="line">        type: <span class="string">&quot;module&quot;</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">// 每个线程起始切片和结束切片索引</span></span><br><span class="line">      <span class="keyword">const</span> startIndex = i * workerChunkCount <span class="comment">// 0-4 4-8 8-12 12-14</span></span><br><span class="line">      <span class="keyword">let</span> endIndex = startIndex + workerChunkCount</span><br><span class="line">      <span class="keyword">if</span> (endIndex &gt; chunkCount) &#123;</span><br><span class="line">        endIndex = chunkCount</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 发送消息</span></span><br><span class="line">      worker.postMessage(&#123;</span><br><span class="line">        file,</span><br><span class="line">        CHUNK_SIZE,</span><br><span class="line">        startIndex,</span><br><span class="line">        endIndex</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">// 处理结束接受消息</span></span><br><span class="line">      worker.onmessage = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e.data) <span class="comment">// 数组</span></span><br><span class="line">        <span class="comment">// 保证切片顺序正确</span></span><br><span class="line">        <span class="comment">// i: index</span></span><br><span class="line">        <span class="comment">// 0: 0-4</span></span><br><span class="line">        <span class="comment">// 1: 4-8</span></span><br><span class="line">        <span class="comment">// 2: 8-12</span></span><br><span class="line">        <span class="comment">// 3: 12-14</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> index = startIndex; index &lt; endIndex; index++) &#123;</span><br><span class="line">          result[index] = e.data[index - startIndex] <span class="comment">// index - startIndex: 0 1 2 3</span></span><br><span class="line">        &#125;</span><br><span class="line">        worker.terminate() <span class="comment">// 收到消息后当前线程切片工作完成，结束线程</span></span><br><span class="line">        finishWorker++</span><br><span class="line">        <span class="keyword">if</span> (finishWorker === THREAD_COUNT) &#123;</span><br><span class="line">          <span class="comment">// 所有线程都完成</span></span><br><span class="line">          resolve(result)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建分片 slice截取</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createChunk</span>(<span class="params">file, index, chunkSize</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> start = index * chunkSize</span><br><span class="line">    <span class="keyword">const</span> end = start + chunkSize</span><br><span class="line">    <span class="keyword">const</span> fileReader = <span class="keyword">new</span> FileReader()</span><br><span class="line">    fileReader.onload = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(&#x27;fileReader-onload&#x27;, e.target.result)</span></span><br><span class="line">      resolve(&#123;</span><br><span class="line">        start,</span><br><span class="line">        end,</span><br><span class="line">        index,</span><br><span class="line">        hash: e.target.result</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    fileReader.readAsArrayBuffer(file.slice(start, end))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>worker.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">onmessage = <span class="keyword">async</span> (e) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> promises = []</span><br><span class="line">  <span class="keyword">const</span> &#123; file, CHUNK_SIZE, startIndex, endIndex &#125; = e.data</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = startIndex; index &lt; endIndex; index++) &#123;</span><br><span class="line">    promises.push(createChunk(file, index, CHUNK_SIZE))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(promises)</span><br><span class="line">  postMessage(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建分片 slice截取</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createChunk</span>(<span class="params">file, index, chunkSize</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> start = index * chunkSize</span><br><span class="line">    <span class="keyword">const</span> end = start + chunkSize</span><br><span class="line">    <span class="keyword">const</span> fileReader = <span class="keyword">new</span> FileReader()</span><br><span class="line">    fileReader.onload = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(&#x27;fileReader-onload&#x27;, e.target.result)</span></span><br><span class="line">      resolve(&#123;</span><br><span class="line">        start,</span><br><span class="line">        end,</span><br><span class="line">        index,</span><br><span class="line">        hash: e.target.result</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    fileReader.readAsArrayBuffer(file.slice(start, end))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不必等到全部切片再上传，可以开启其他线程进行切片，边切片边进行上传</p><p>监听上传进度：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听进度事件  </span></span><br><span class="line">xhr.upload.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (event.lengthComputable) &#123;  </span><br><span class="line">        <span class="keyword">const</span> percentComplete = (event.loaded / event.total) * <span class="number">100</span>;  </span><br><span class="line">        <span class="built_in">console</span>.log(percentComplete + <span class="string">&#x27;% 上传完成&#x27;</span>);  </span><br><span class="line">        <span class="comment">// 这里可以更新进度条或其他UI元素  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过xhr.upload中的progress方法可以实现监控每一个切片上传进度。<br>上传暂停的实现也比较简单，通过xhr.abort可以取消当前未完成上传切片的上传，实现上传暂停的效果，恢复上传就跟断点续传类似，先获取已上传的切片列表，然后重新发送未上传的切片。</p><p>切片计算hash以及整个文件hash：在文件传输过程中，通常会使用哈希值来校验文件在传输过程中是否发生损坏或被篡改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> SparkMD5 = <span class="built_in">require</span>(<span class="string">&#x27;spark-md5&#x27;</span>); <span class="comment">// 按照js-md5 </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateChunkHash</span>(<span class="params">file, chunkSize</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">const</span> fileHash = SparkMD5.ArrayBuffer.hash();  </span><br><span class="line">    <span class="keyword">const</span> chunks = [];  </span><br><span class="line">    <span class="keyword">let</span> offset = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (offset &lt; file.size) &#123;  </span><br><span class="line">        <span class="keyword">const</span> chunk = file.slice(offset, offset + chunkSize);  </span><br><span class="line">        <span class="keyword">const</span> reader = <span class="keyword">new</span> FileReader();  </span><br><span class="line">  </span><br><span class="line">        reader.onload = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;  </span><br><span class="line">            <span class="keyword">const</span> chunkContent = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(event.target.result);  </span><br><span class="line">            fileHash.update(chunkContent);  </span><br><span class="line">            chunks.push(&#123;  </span><br><span class="line">                start: offset,  </span><br><span class="line">                end: offset + chunkSize,  </span><br><span class="line">                hash: crypto.createHash(<span class="string">&#x27;md5&#x27;</span>).update(chunkContent).digest(<span class="string">&#x27;hex&#x27;</span>) <span class="comment">// 单独计算切片文件hash</span></span><br><span class="line">            &#125;);  </span><br><span class="line">            offset += chunkSize;  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 如果已经是最后一个切片，或者文件大小不是切片大小的整数倍  </span></span><br><span class="line">            <span class="keyword">if</span> (offset &gt;= file.size || offset % chunkSize !== <span class="number">0</span>) &#123;  </span><br><span class="line">                <span class="keyword">const</span> finalHash = fileHash.end();  </span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;Final file hash:&#x27;</span>, finalHash);  </span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;Chunk hashes:&#x27;</span>, chunks.map(<span class="function"><span class="params">chunk</span> =&gt;</span> chunk.hash));  </span><br><span class="line">                <span class="comment">// 在这里，你可以将最终的哈希值和每个切片的哈希值发送给服务器  </span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line">  </span><br><span class="line">        reader.readAsArrayBuffer(chunk);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 使用示例  </span></span><br><span class="line"><span class="keyword">const</span> fileInput = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;fileInput&#x27;</span>);  </span><br><span class="line">fileInput.addEventListener(<span class="string">&#x27;change&#x27;</span>, <span class="keyword">async</span> (event) =&gt; &#123;  </span><br><span class="line">    <span class="keyword">const</span> file = event.target.files[<span class="number">0</span>];  </span><br><span class="line">    <span class="keyword">if</span> (file) &#123;  </span><br><span class="line">        <span class="keyword">const</span> chunkSize = <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// 1MB  </span></span><br><span class="line">        calculateChunkHash(file, chunkSize);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>限制切片上传并发请求数量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MAX_CONCURRENT_REQUESTS = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> requests = [];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchWithPool</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将请求包装成Promise</span></span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    <span class="keyword">let</span> formData = <span class="keyword">new</span> FormData()</span><br><span class="line">    formData.append(<span class="string">&#x27;chunk&#x27;</span>, chunk)</span><br><span class="line">    xhr.open(<span class="string">&#x27;POST&#x27;</span>, url, <span class="attr">data</span>: formData);</span><br><span class="line">    xhr.onload = <span class="function">() =&gt;</span> resolve(xhr.responseText);</span><br><span class="line">    xhr.onerror = <span class="function">() =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Network error&#x27;</span>));</span><br><span class="line">    xhr.send();</span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line">  requests.push(promise);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 如果请求数量达到限制，则等待当前请求完成后再发送新的请求</span></span><br><span class="line">  <span class="keyword">if</span> (requests.length &gt;= MAX_CONCURRENT_REQUESTS) &#123;</span><br><span class="line">    <span class="keyword">return</span> promise.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      requests.shift();</span><br><span class="line">      <span class="keyword">return</span> data;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 否则直接返回Promise</span></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用async/await进行请求</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchWithPoolExample</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> chunks = [...];</span><br><span class="line">  <span class="keyword">const</span> results = [];</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> chunk <span class="keyword">of</span> chunks) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> fetchWithPool(chunk);</span><br><span class="line">    results.push(result);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">fetchWithPoolExample();</span><br></pre></td></tr></table></figure><p>如何实现断点续传：<br>切片上传成功后，保存已上传成功的切片信息，当下次传输相同文件时，遍历切片列表，只选择未上传的切片进行上传。</p><p>如何保存已上传切片的信息：</p><ul><li>可以通过locaStorage等方式保存在前端浏览器中，这种方式不依赖于服务端，实现起来也比较方便，缺点在于如果用户清除了本地文件，会导致上传记录丢失</li><li>服务端本身知道哪些切片已经上传，因此可以由服务端额外提供一个根据文件hash查询已上传切片的接口，在上传文件前调用该文件的历史上传记录</li></ul><h3 id="23-单点登录"><a href="#23-单点登录" class="headerlink" title="23.单点登录"></a>23.单点登录</h3><p>多条产品线，共享同一套用户系统，抽离用户系统，形成用户中心</p><p>session+cookie模式：<br>认证中心登录成功后生成用户信息到session表里（sid:身份信息），然后将该 Session ID 存储在 Cookie 中，并返回给客户的端，客户端再次访问业务系统会带上cookie（包含sid），业务系统去认证中心验证sid是否有效，有效就可以访问业务系统登录后的资源。</p><p>认证中心会将用户信息存储session表里，session 存储在服务器里面，当用户同时在线量比较多时，这些 session 会占据较多的内存，需要在服务端定期的去清理过期的 session。</p><p>token模式：</p><p>用户-认证中心登录成功后返回给客户端一个token（jwt），客户端自己存储。客户端再访问业务系统携带token，业务系统自行验证token是否有效。</p><p>token+refresh模式：</p><p>用户-认证中心登录成功后返回给客户端token+refreshToken, token过期时间短，refreshToken长期有效，客户端访问业务系统携带token，由业务系统进行验证，如果token过期，客户端会用refreshToken去认证中心重新获取新的token，再去访问业务系统</p><h3 id="24-LRU缓存置换算法"><a href="#24-LRU缓存置换算法" class="headerlink" title="24.LRU缓存置换算法"></a>24.LRU缓存置换算法</h3><p>LRU：选择最近最久未使用的置换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">  #map;</span><br><span class="line">  #length;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">length</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.#map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    <span class="built_in">this</span>.#length = length</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.$map.get(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="built_in">this</span>.$map.get(key)</span><br><span class="line">    <span class="built_in">this</span>.#map.delete(key)</span><br><span class="line">    <span class="built_in">this</span>.#map.set(key, value)</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">key, value</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.$map.get(key)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.#map.delete(key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.#map.set(key, value)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.#map.size &gt; <span class="built_in">this</span>.#length) &#123;</span><br><span class="line">      <span class="keyword">const</span> firstkey = <span class="built_in">this</span>.#map.keys().next().value</span><br><span class="line">      <span class="built_in">this</span>.#map.delete(firstkey)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="25-判断是不是数组"><a href="#25-判断是不是数组" class="headerlink" title="25.判断是不是数组"></a>25.判断是不是数组</h3><h4 id="1-Object-prototype-toString-call"><a href="#1-Object-prototype-toString-call" class="headerlink" title="1.Object.prototype.toString.call([])"></a>1.Object.prototype.toString.call([])</h4><p>从原型入手，Array.prototype.isPrototypeOf(obj);<br>利用isPrototypeOf()方法判断Array是否在obj的原型链上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = []</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(arr) <span class="comment">// &#x27;[object Array]&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(obj) <span class="comment">// &#x27;[object Object]&#x27;</span></span><br><span class="line"><span class="comment">// but</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toStringTag]: <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(obj1) <span class="comment">// &#x27;[object abc]&#x27;</span></span><br></pre></td></tr></table></figure><p>对象的Symbol.toStringTag属性，指向一个方法。在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制[object Object]或[object Array]中object后面的那个字符串。</p><h4 id="2-instanceof-Array"><a href="#2-instanceof-Array" class="headerlink" title="2.[] instanceof Array"></a>2.[] instanceof Array</h4><p>instanceof检测构造函数的prototype属性是否存在实例对象的原型链上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">const</span> Array1 = <span class="built_in">window</span>.Array</span><br><span class="line"><span class="keyword">const</span> Array2 = iframe.contentWindow.Array</span><br><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> Array2()</span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="3-Array-isArray"><a href="#3-Array-isArray" class="headerlink" title="3.Array.isArray([])"></a>3.Array.isArray([])</h4><p>Array.isArray() 检查传递的值是否为 Array。它不检查值的原型链，也不依赖于它所附加的 Array 构造函数。<br>对于使用数组字面量语法或 Array 构造函数创建的任何值，它都会返回 true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的函数调用都返回 true</span></span><br><span class="line"><span class="built_in">Array</span>.isArray([]);</span><br><span class="line"><span class="built_in">Array</span>.isArray([<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="keyword">new</span> <span class="built_in">Array</span>());</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>));</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>));</span><br><span class="line"><span class="comment">// 鲜为人知的事实：其实 Array.prototype 也是一个数组：</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="built_in">Array</span>.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的函数调用都返回 false</span></span><br><span class="line"><span class="built_in">Array</span>.isArray();</span><br><span class="line"><span class="built_in">Array</span>.isArray(&#123;&#125;);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="literal">undefined</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="number">17</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="string">&quot;Array&quot;</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">32</span>));</span><br><span class="line"><span class="comment">// 这不是一个数组，因为它不是使用数组字面量语法或 Array 构造函数创建的</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(&#123; <span class="attr">__proto__</span>: <span class="built_in">Array</span>.prototype &#125;);</span><br></pre></td></tr></table></figure><p>当检测 Array 实例时，Array.isArray 优于 instanceof，因为 Array.isArray 能跨领域工作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&quot;iframe&quot;</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line"><span class="keyword">const</span> xArray = <span class="built_in">window</span>.frames[<span class="built_in">window</span>.frames.length + <span class="number">1</span>].Array;</span><br><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> xArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确检查 Array</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(arr); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// arr 的原型是 xArray.prototype，它是一个不同于 Array.prototype 的对象</span></span><br><span class="line">arr.__proto__ == xArray.prototype <span class="comment">// true</span></span><br><span class="line">arr.__proto__ == <span class="built_in">Array</span>.prototype <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="26-Reflect的本质"><a href="#26-Reflect的本质" class="headerlink" title="26.Reflect的本质"></a>26.Reflect的本质</h3><p>Reflect: 调用对象的基本方法。</p><p>针对js的对象的基本内部方法有：</p><p><img src="/ZJY.github.io/images/objectbase.png" alt="image"></p><p>支持对象被作为函数调用的其他基础内部方法:</p><p><img src="/ZJY.github.io/images/objectcall.png" alt="image"></p><p>这些对象的基本内部方法不对外暴漏，但是有了Reflect可以通过函数方式调用而不使用语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="comment">// obj.a = &#x27;3&#x27; 语法</span></span><br><span class="line"><span class="built_in">Reflect</span>.set(obj, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123;a: &#x27;3&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>当使用语法obj.a = ‘3’赋值时，执行代码时会先执行一个被封装过后的方法，方法里面调用了内部方法get</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">c</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.a + <span class="built_in">this</span>.b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.c) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [Get]]---(propertyKey, Receiver) → any---返回这个对象里 key 值为 propertyKey 的属性的值。如果必须运行一些的 ECMAScript 代码来检索这个属性值，Receiver 就会作为解析代码时的 this 值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为obj.c调取get内部方法，Receiver即this传递的是obj，所以没办法更改this的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是Reflect可以传递Receiver更改this</span></span><br><span class="line"><span class="built_in">Reflect</span>.get(obj, <span class="string">&#x27;c&#x27;</span>, &#123;<span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span>&#125;) <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">&#x27;c&#x27;</span>)]: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;d&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="number">4</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj)) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br><span class="line"><span class="comment">// Object.keys方法调用的封装后的方法里面设置过滤掉不可枚举的属性，调用内部方法OwnPropertyKeys：返回一个包含所有自身属性 key 值的 List。</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.ownKeys(obj)) <span class="comment">//  [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;d&#x27;, Symbol(c)]</span></span><br><span class="line"><span class="comment">// OwnPropertyKeys对应的Reflect方法ownKeys，Reflect.ownKeys直接调用对象的内部方法可获取全部属性</span></span><br></pre></td></tr></table></figure><h3 id="27-img的srcset、size"><a href="#27-img的srcset、size" class="headerlink" title="27.img的srcset、size"></a>27.img的srcset、size</h3><p>srcset可以设置不同dpr使用的图片尺寸</p><p>图像的尺寸 = css尺寸 *  dpr  图片不会模糊</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">srcset</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">  https://picsum.photos/id/164/150 1x,</span></span></span><br><span class="line"><span class="tag"><span class="string">  https://picsum.photos/id/164/300 2x,</span></span></span><br><span class="line"><span class="tag"><span class="string">  https://picsum.photos/id/164/450 3x,</span></span></span><br><span class="line"><span class="tag"><span class="string">  https://picsum.photos/id/164/600 4x,</span></span></span><br><span class="line"><span class="tag"><span class="string">  https://picsum.photos/id/164/750 5x,</span></span></span><br><span class="line"><span class="tag"><span class="string">  https://picsum.photos/id/164/900 6x,</span></span></span><br><span class="line"><span class="tag"><span class="string">&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>“<a href="https://picsum.photos/id/164/150">https://picsum.photos/id/164/150</a>“ 1x, dpr为1时，使用150的图片</p><p>sizes: 媒体查询来响应图片大小，多个值用逗号隔开<br>例如：sizes=”(max-width: 300px) 50vw, 50vw”，<br>表示当视区宽度不大于300像素时候，图片的宽度限制为50vw，其他情况下，使用50vw,那么当视区宽度为200像素时，图片尺寸等于100px*dpr,<br>假设dpr为2，那么就匹配最接近的即150w</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">srcset</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">    https://picsum.photos/id/164/150 150w,</span></span></span><br><span class="line"><span class="tag"><span class="string">    https://picsum.photos/id/164/300 300w</span></span></span><br><span class="line"><span class="tag"><span class="string">    https://picsum.photos/id/164/600 600w,</span></span></span><br><span class="line"><span class="tag"><span class="string">    https://picsum.photos/id/164/900 900w,</span></span></span><br><span class="line"><span class="tag"><span class="string">    https://picsum.photos/id/164/1200 1200w,</span></span></span><br><span class="line"><span class="tag"><span class="string">  &quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">sizes</span>=<span class="string">&quot;(max-width: 300px) 50vw,</span></span></span><br><span class="line"><span class="tag"><span class="string">  (max-width: 600px) 50vw,</span></span></span><br><span class="line"><span class="tag"><span class="string">  (max-width: 900px) 50vw,</span></span></span><br><span class="line"><span class="tag"><span class="string">  (max-width: 1200px) 50vw,</span></span></span><br><span class="line"><span class="tag"><span class="string">  50vw</span></span></span><br><span class="line"><span class="tag"><span class="string">  &quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="28-es2023中的数组纯函数"><a href="#28-es2023中的数组纯函数" class="headerlink" title="28.es2023中的数组纯函数"></a>28.es2023中的数组纯函数</h3><p>es2023的新数组函数：toSorted、toReversed、toSliced、with(index, value)-arr[index] = value<br>这些数组函数不会改变原数组的值只会返回更改后的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// let arr = [1, 7, 3]</span></span><br><span class="line"><span class="comment">// arr.sort((a, b) =&gt; a + b)</span></span><br><span class="line"><span class="comment">// console.log(arr) // [1, 3, 7]</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> sortArr = arr.toSorted(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b)</span><br><span class="line"><span class="built_in">console</span>.log(sortArr, arr) <span class="comment">// [1, 3, 7]  [1, 7, 3]</span></span><br></pre></td></tr></table></figure><h3 id="29-动态执行js"><a href="#29-动态执行js" class="headerlink" title="29.动态执行js"></a>29.动态执行js</h3><p>1.使用eval: 同步代码,当前作用域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">exec</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">  <span class="built_in">eval</span>(code)</span><br><span class="line">&#125;</span><br><span class="line">exec(<span class="string">&#x27;console.log(&quot;a&quot;, a)&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;sync&#x27;</span>)</span><br><span class="line"><span class="comment">// a 2 </span></span><br><span class="line"><span class="comment">// &#x27;sync&#x27;</span></span><br><span class="line"><span class="comment">// eval: 同步代码,当前作用域</span></span><br></pre></td></tr></table></figure><p>2.setTimeout: 异步，全局作用域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">exec</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(code, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">exec(<span class="string">&#x27;console.log(&quot;a&quot;, a)&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;asynchronous&#x27;</span>)</span><br><span class="line"><span class="comment">// &#x27;asynchronous&#x27;</span></span><br><span class="line"><span class="comment">// a 1</span></span><br></pre></td></tr></table></figure><p>3.创建script标签加入body: 同步，全局作用域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">exec</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">  <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">  script.innerHTML = code</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;</span><br><span class="line">exec(<span class="string">&#x27;console.log(&quot;a&quot;, a)&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;sync&#x27;</span>)</span><br><span class="line"><span class="comment">// a 1</span></span><br><span class="line"><span class="comment">// &#x27;sync&#x27;</span></span><br></pre></td></tr></table></figure><p>4.Function: 同步，全局作用域, 无需创建多余的标签</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ar a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">exec</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">  <span class="keyword">let</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>(code) <span class="comment">// 创建一个function，函数体为code</span></span><br><span class="line">  fn()</span><br><span class="line">&#125;</span><br><span class="line">exec(<span class="string">&#x27;console.log(&quot;a&quot;, a)&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;sync&#x27;</span>)</span><br><span class="line"><span class="comment">// a 1</span></span><br><span class="line"><span class="comment">// &#x27;sync&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="node模块查找策略"><a href="#node模块查找策略" class="headerlink" title="node模块查找策略"></a>node模块查找策略</h3><p>代码使用require、import，根据路径怎么查找文件<br>require(‘./a’) require(‘/a’)</p><p>文件查找：</p><p>  按照路径查找a，后缀补js查找a.js找不到查找a.json还找不到去查找文件夹</p><p>文件夹查找：</p><p>  首先查看a文件夹下面是否有package.json文件，配置”main”: “./t.js”,就去找a/t.js<br>  如果a文件夹下面没有package.json文件或者没有配置main或者配置了一个不存在的路径，就去查找<br>  a文件夹下面有没有index.js, index.json文件</p><p>require(‘a’)：</p><p>内置模块：</p><p>  如果路径直接写名字，首先会去内置模块查找，比如node内置模块http,fs, path等<br>  如果a在内置模块就使用，不是就去第三方模块查找</p><p>第三方模块：</p><p>  从node_modules查找，如果当前node_modules没有a，就去上级目录查找</p><h3 id="vue状态仓库持久化：vuex、pina"><a href="#vue状态仓库持久化：vuex、pina" class="headerlink" title="vue状态仓库持久化：vuex、pina"></a>vue状态仓库持久化：vuex、pina</h3><p>vuex、pina都是存储在内存里，一旦刷新页面就没了</p><p>vuex：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">import</span> counter <span class="keyword">from</span> <span class="string">&#x27;./counter&#x27;</span></span><br><span class="line"><span class="keyword">import</span> persistPligin <span class="keyword">from</span> <span class="string">&quot;./persistPligin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    counter</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [persistPligin]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// persistPligin.js</span></span><br><span class="line"><span class="keyword">const</span> KEY = <span class="string">&#x27;vuex-store&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">store</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 保存仓库数据到本地</span></span><br><span class="line">  <span class="built_in">console</span>.log(store)</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;beforeunload&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">localStorage</span>.setItem(KEY, <span class="built_in">JSON</span>.stringify(store.state))</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 恢复仓库数据</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> localState = <span class="built_in">localStorage</span>.getItem(KEY)</span><br><span class="line">    <span class="keyword">if</span> (localState) &#123;</span><br><span class="line">      store.replaceState(<span class="built_in">JSON</span>.parse(localState))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者使用第三方库比如vuex-persist</p><p>pina：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"><span class="keyword">import</span> persistPligin <span class="keyword">from</span> <span class="string">&quot;./store/persistPligin&quot;</span></span><br><span class="line"><span class="keyword">const</span> pinia = createPinia()</span><br><span class="line">pinia.use(persistPligin)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// persistPligin.js</span></span><br><span class="line"><span class="keyword">const</span> KEY_PREFIX = <span class="string">&#x27;pina_store_&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; store, id &#125; = context</span><br><span class="line">  <span class="keyword">const</span> KEY = KEY_PREFIX + id</span><br><span class="line">  <span class="comment">// 保存仓库数据到本地</span></span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;beforeunload&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">localStorage</span>.setItem(KEY, <span class="built_in">JSON</span>.stringify(store.$state))</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 恢复仓库数据</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> localState = <span class="built_in">localStorage</span>.getItem(KEY)</span><br><span class="line">    <span class="keyword">if</span> (localState) &#123;</span><br><span class="line">      store.$patch(<span class="built_in">JSON</span>.parse(localState))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用第三方插件实现持久话存储</p><h3 id="css选择器focus-within、has、-first-letter、selection"><a href="#css选择器focus-within、has、-first-letter、selection" class="headerlink" title="css选择器focus-within、has、 first-letter、selection"></a>css选择器focus-within、has、 first-letter、selection</h3><p><code>:focus-within</code> CSS 伪类表示当元素或其任意后代元素被聚焦时，将匹配该元素.</p><p>CSS 函数式伪类 <code>:has()</code> 表示一个元素，如果作为参数传递的任何相对选择器在锚定到该元素时，至少匹配一个元素.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:has(+</span> <span class="selector-tag">h2</span>) &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0.25rem</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CSS 伪元素 <code>::first-letter</code>会选中某 block-level element（块级元素）第一行的第一个字母，并且文字所处的行之前没有其他内容</p><p><code>::selection</code> CSS 伪元素应用于文档中被用户高亮的部分（比如使用鼠标或其他选择设备选中的部分）</p><h3 id="文件上传、文件夹、拖拽上传"><a href="#文件上传、文件夹、拖拽上传" class="headerlink" title="文件上传、文件夹、拖拽上传"></a>文件上传、文件夹、拖拽上传</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>上传文件-支持文件夹-拖拽等<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.drop</span> &#123;</span></span><br><span class="line">      width: 800px;</span><br><span class="line">      height: 300px;</span><br><span class="line">      border: 1px solid black;</span><br><span class="line">      border-radius: 10px;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;drop&quot;</span>&gt;</span>拖拽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  &lt;!-+ multiple 支持多选文件 --&gt;</span><br><span class="line">  &lt;!-+ webkitdirectory mozdirectory odirectory 文件支持目录选择--&gt;</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;fileFile&quot;</span> <span class="attr">multiple</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;filepicker&quot;</span> <span class="attr">multiple</span> <span class="attr">webkitdirectory</span> <span class="attr">mozdirectory</span> <span class="attr">odirectory</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;listing&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 选择文件</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;fileFile&quot;</span>).addEventListener(</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;change&quot;</span>,</span></span><br><span class="line">      (event) =&gt; &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> output = <span class="built_in">document</span>.getElementById(<span class="string">&quot;listing&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">const</span> file <span class="keyword">of</span> event.target.files) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(file)</span></span><br><span class="line"><span class="javascript">          <span class="keyword">let</span> item = <span class="built_in">document</span>.createElement(<span class="string">&quot;li&quot;</span>);</span></span><br><span class="line"><span class="javascript">          item.textContent = file.name + <span class="string">&#x27;----&#x27;</span> + file.size;</span></span><br><span class="line">          output.appendChild(item);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="literal">false</span>,</span></span><br><span class="line">    );</span><br><span class="line"><span class="javascript">    <span class="comment">// 选择文件夹</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;filepicker&quot;</span>).addEventListener(</span></span><br><span class="line"><span class="javascript">      <span class="string">&quot;change&quot;</span>,</span></span><br><span class="line">      (event) =&gt; &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> output = <span class="built_in">document</span>.getElementById(<span class="string">&quot;listing&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">const</span> file <span class="keyword">of</span> event.target.files) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(file)</span></span><br><span class="line"><span class="javascript">          <span class="keyword">let</span> item = <span class="built_in">document</span>.createElement(<span class="string">&quot;li&quot;</span>);</span></span><br><span class="line">          item.textContent = file.webkitRelativePath;</span><br><span class="line">          output.appendChild(item);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="literal">false</span>,</span></span><br><span class="line">    );</span><br><span class="line"><span class="javascript">    <span class="comment">// 拖拽</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> drop = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.drop&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    drop.ondragenter = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line">      e.preventDefault()</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    drop.ondragover = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line">      e.preventDefault()</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    drop.ondrop = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line">      e.preventDefault()</span><br><span class="line"><span class="javascript">      <span class="comment">// 如果只支持拖拽文件</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// const files = e.dataTransfer.files</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 支持拖拽文件夹</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> e.dataTransfer.items) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> entry = item.webkitGetAsEntry()</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(entry)</span></span><br><span class="line"><span class="javascript">        <span class="comment">// filesystem: DOMFileSystem: &#123;name: &#x27;http_127.0.0.1_5500:Isolated_AF5320443A64781FE8803A9C403E7049&#x27;, root: DirectoryEntry&#125;</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// fullPath: &quot;/1.js&quot;</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// isDirectory:false</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// isFile:true</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// name: &quot;1.js&quot;</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (entry.isDirectory) &#123; <span class="comment">// 目录                      </span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">const</span> reader = entry.createReader()</span></span><br><span class="line"><span class="javascript">          reader.readEntries(<span class="function">(<span class="params">entries</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(entries)</span></span><br><span class="line">          &#125;)</span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 文件</span></span></span><br><span class="line"><span class="javascript">          entry.file(<span class="function">(<span class="params">f</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(f)</span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="vue组建命名规范"><a href="#vue组建命名规范" class="headerlink" title="vue组建命名规范"></a>vue组建命名规范</h3><p>大驼峰<code>&lt;StarRate&gt;</code>、段横线<code>&lt;star-rate&gt;</code><br>组件命名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> StarRate <span class="keyword">from</span> <span class="string">&#x27;./StarRate&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    abc: StarRate <span class="comment">// abc是组件真实名称</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件中的name：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&#x27;StartRate&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里name的用途：</p><ul><li>组件递归引用</li><li>调试工具显示</li><li>和keep-alive配合</li></ul><h3 id="浏览器自动播放策略"><a href="#浏览器自动播放策略" class="headerlink" title="浏览器自动播放策略"></a>浏览器自动播放策略</h3><p>1、互动后播放</p><p>先尝试自动播放，若发生异常，则引导用户进行互动操作，然后再进行播放</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vdo = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;video&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.play&#x27;</span>)</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">play</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> vdo.play()</span><br><span class="line">    btn.style.display = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">    btn.removeEventListener(<span class="string">&#x27;click&#x27;</span>, play)</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    btn.style.display = <span class="string">&#x27;flex&#x27;</span></span><br><span class="line">    btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, play)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">play()</span><br></pre></td></tr></table></figure><p>2、互动后出声</p><p>先静音播放，然后根据是否能自动播放决定是否取消静音：</p><p>1、能自动播放，取消静音<br>2、不能自动播放，引导用户进行互动操作后取消静音。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vdo = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;video&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.play&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">play</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  vdo.muted = <span class="literal">true</span></span><br><span class="line">  vdo.play()</span><br><span class="line">  <span class="keyword">const</span> ctx = <span class="keyword">new</span> AudioContext() <span class="comment">// 音频上下文</span></span><br><span class="line">  <span class="keyword">const</span> canAutoPlay = ctx.state === <span class="string">&#x27;running&#x27;</span> <span class="comment">// 音频能够播放</span></span><br><span class="line">  ctx.close()</span><br><span class="line">  <span class="keyword">if</span> (canAutoPlay) &#123;</span><br><span class="line">    vdo.muted = <span class="literal">false</span></span><br><span class="line">    btn.style.display = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">    btn.removeEventListener(<span class="string">&#x27;click&#x27;</span>, play)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    btn.style.display = <span class="string">&#x27;flex&#x27;</span></span><br><span class="line">    btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, play)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="web-api"><a href="#web-api" class="headerlink" title="web api"></a>web api</h3><p>环境： 浏览器、node、微信小程序<br>ES: EcmaScript，是一个语言标准，定义语法、标准库，是一个标准文档<br>环境API： 浏览器：Web API</p><p>JS：ES + Web API</p><h3 id="数字字面量"><a href="#数字字面量" class="headerlink" title="数字字面量"></a>数字字面量</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span></span><br><span class="line"><span class="comment">// output: 1</span></span><br><span class="line"><span class="number">08</span></span><br><span class="line"><span class="comment">// output: 8</span></span><br><span class="line"><span class="number">09</span></span><br><span class="line"><span class="comment">// output: 9</span></span><br><span class="line"><span class="number">010</span></span><br><span class="line"><span class="comment">// output: 8 // 数字字面量前面加0，尝试转换8进制，转换不成功转成10进制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 八进制0o</span></span><br><span class="line">0o8</span><br><span class="line"><span class="comment">// output: caught SyntaxError: Invalid or unexpected token</span></span><br><span class="line"><span class="number">0o10</span></span><br><span class="line"><span class="comment">// output:8</span></span><br><span class="line"><span class="number">0o11</span></span><br><span class="line"><span class="comment">// output:9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 十六进制0x</span></span><br><span class="line"><span class="number">0x123456</span></span><br><span class="line"><span class="comment">// output: 1193046</span></span><br><span class="line"><span class="comment">// 二进制0b</span></span><br><span class="line"><span class="number">0b010101</span></span><br><span class="line"><span class="comment">// output：21</span></span><br><span class="line"></span><br><span class="line"><span class="number">1e10</span></span><br><span class="line"><span class="comment">// 10000000000</span></span><br><span class="line"><span class="number">3.14e10</span></span><br><span class="line"><span class="comment">// 31400000000</span></span><br><span class="line"></span><br><span class="line"><span class="number">11.</span>toString()</span><br><span class="line"><span class="comment">// VM2977:1 Uncaught SyntaxError: Invalid or unexpected token</span></span><br><span class="line"><span class="comment">// 11.会认为是小数</span></span><br><span class="line"><span class="number">11.</span>.toString()</span><br><span class="line"><span class="comment">// &#x27;11&#x27;</span></span><br><span class="line"><span class="comment">// 第一个点是小数点，第二个点是调用方法的点</span></span><br></pre></td></tr></table></figure><h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><p>随机16进制颜色</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span> + <span class="built_in">Math</span>.random().toString(<span class="number">16</span>).substring(<span class="number">2</span>, <span class="number">8</span>).padEnd(<span class="number">6</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">randomColor()</span><br><span class="line"><span class="comment">// &#x27;#f371b3&#x27;</span></span><br></pre></td></tr></table></figure><p>随机字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomStr</span>(<span class="params">len = <span class="number">6</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Math.random().toString(36): &#x27;0.d88kqf4iy54&#x27; 截取0. 后11位</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">11</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.random().toString(<span class="number">36</span>).substring(<span class="number">2</span>, <span class="number">2</span>+len).padEnd(len, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> randomStr(<span class="number">11</span>) + randomStr(len + <span class="number">11</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">randomStr(<span class="number">20</span>)</span><br><span class="line"><span class="comment">// &#x27;3oc4csdw5pra4e5zw1tc&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="数字格式化"><a href="#数字格式化" class="headerlink" title="数字格式化"></a>数字格式化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;100000000000&#x27;</span></span><br><span class="line"><span class="comment">// 前瞻运算符匹配位置</span></span><br><span class="line"><span class="keyword">const</span> r = str.replace(<span class="regexp">/\B(?=(\d&#123;3&#125;)+$)/g</span>, <span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(r)</span><br><span class="line"><span class="comment">// 100,000,000,000</span></span><br></pre></td></tr></table></figure><p>(?=)前瞻运算符匹配位置<br>(\d{3})+ 连续3个数字匹配1-多次<br>\B非单词边界，即: ,100,1000,1000, 1前面边界</p><h3 id="层叠规则"><a href="#层叠规则" class="headerlink" title="层叠规则"></a>层叠规则</h3><p>computed style样式计算： 声明、层叠、继承、默认<br>visual fomatting model视觉格式化模型</p><p>层叠：解决样式冲突</p><ul><li><p>比较优先级：</p><ul><li>作者样式表!important</li><li>默认样式表!important</li><li>作者样式表</li><li>默认样式表</li></ul></li><li><p>比较特殊性（权重）（四位：?,?,?,?）高位相同比较下一位</p><ul><li>第一位：内联样式style为1，否则为0</li><li>第二位：元素所属选择器所有的id个数，1个id为1，100个id为100</li><li>第三位：元素所属选择器所有的类选择器+属性选择器+伪类选择器的个数</li><li>第四位：元素所属选择器所有的元素选择器+伪元素选择器的个数</li></ul></li><li><p>源次序：样式在源代码里面的次序，后面样式覆盖前面</p></li></ul><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><ul><li>布尔类型：ture false</li><li>布尔判定：假：null undefined false NaN 0 ‘’<br>if (xxx)<br>xxx || yyy<br>xxx &amp;&amp; yyy<br>xxx ? xxx : yyy</li><li>短路运算<br>xxx || yyy 最后一个运算的是啥就是啥 console.log(0 || NaN) // NaN<br>xxx &amp;&amp; yyy console.log(0 &amp;&amp; NaN) // 0<br>obj.a.b.c.d.e:<br>obj &amp;&amp; obj.a &amp;&amp; obj.a.b &amp;&amp; obj.a.b.c &amp;&amp; obj.a.b.c.d &amp;&amp; obj.a.b.c.d.e<br>obj?.a?.b?.c?.d?.e</li></ul><h3 id="赋值运算"><a href="#赋值运算" class="headerlink" title="赋值运算"></a>赋值运算</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">n</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b = a <span class="comment">// &#123;n: 1&#125;</span></span><br><span class="line">a.x = a = &#123; <span class="attr">n</span>: <span class="number">2</span>&#125; <span class="comment">// </span></span><br><span class="line"><span class="built_in">console</span>.log(a.x) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(b.x) <span class="comment">// &#123; n: 2&#125;</span></span><br></pre></td></tr></table></figure><p>a.x = (a = {n : 2})<br>a的内存空间存一个x属性， a = {n : 2}, 给a重新开辟一块内存，a = {n: 2},此时b = {n: 1, x: undefined},<br>将a = { n: 2}的值赋值给a.x（a.x已经计算过，不再查找）, 即原先a和b共同的内存空间{n: 1, x: undefined}将{n:2}赋值给x，即<code>b = &#123;n:1, x: &#123;n:2&#125;&#125;</code></p><h3 id="js数据类型和typeof"><a href="#js数据类型和typeof" class="headerlink" title="js数据类型和typeof"></a>js数据类型和typeof</h3><p>原始类型：Number、String、Boolean、null、undefined、Symbol、BigInt<br>对应typeof：number、string、boolean、object、undefined、symbol、bigint<br>对象类型：Object<br>对应typeof：object、function</p><h3 id="ssr服务端渲染"><a href="#ssr服务端渲染" class="headerlink" title="ssr服务端渲染"></a>ssr服务端渲染</h3><p>什么是 SSR？​<br>Vue.js 是一个用于构建客户端应用的框架。默认情况下，Vue 组件的职责是在浏览器中生成和操作 DOM。然而，Vue 也支持将组件在服务端直接渲染成 HTML 字符串，作为服务端响应返回给浏览器，最后在浏览器端将静态的 HTML“激活”(hydrate) 为能够交互的客户端应用。</p><p>一个由服务端渲染的 Vue.js 应用也可以被认为是“同构的”(Isomorphic) 或“通用的”(Universal)，因为应用的大部分代码同时运行在服务端和客户端。</p><p>为什么要用 SSR？​<br>与客户端的单页应用 (SPA) 相比，SSR 的优势主要在于：</p><ul><li><p>更快的首屏加载：这一点在慢网速或者运行缓慢的设备上尤为重要。服务端渲染的 HTML 无需等到所有的 JavaScript 都下载并执行完成之后才显示，所以你的用户将会更快地看到完整渲染的页面。除此之外，数据获取过程在首次访问时在服务端完成，相比于从客户端获取，可能有更快的数据库连接。这通常可以带来更高的核心 Web 指标评分、更好的用户体验，而对于那些“首屏加载速度与转化率直接相关”的应用来说，这点可能至关重要。</p></li><li><p>统一的心智模型：你可以使用相同的语言以及相同的声明式、面向组件的心智模型来开发整个应用，而不需要在后端模板系统和前端框架之间来回切换。</p></li><li><p>更好的 SEO：搜索引擎爬虫可以直接看到完全渲染的页面。</p></li></ul><p>使用 SSR 时还有一些权衡之处需要考量：</p><ul><li><p>开发中的限制。浏览器端特定的代码只能在某些生命周期钩子中使用；一些外部库可能需要特殊处理才能在服务端渲染的应用中运行。</p></li><li><p>更多的与构建配置和部署相关的要求。服务端渲染的应用需要一个能让 Node.js 服务器运行的环境，不像完全静态的 SPA 那样可以部署在任意的静态文件服务器上。</p></li><li><p>更高的服务端负载。在 Node.js 中渲染一个完整的应用要比仅仅托管静态文件更加占用 CPU 资源，因此如果你预期有高流量，请为相应的服务器负载做好准备，并采用合理的缓存策略。</p></li></ul><p>在为你的应用使用 SSR 之前，你首先应该问自己是否真的需要它。这主要取决于首屏加载速度对应用的重要程度。例如，如果你正在开发一个内部的管理面板，初始加载时的那额外几百毫秒对你来说并不重要，这种情况下使用 SSR 就没有太多必要了。然而，在内容展示速度极其重要的场景下，SSR 可以尽可能地帮你实现最优的初始加载性能。</p><p>SSR vs. SSG​<br>静态站点生成 (Static-Site Generation，缩写为 SSG)，也被称为预渲染，是另一种流行的构建快速网站的技术。如果用服务端渲染一个页面所需的数据对每个用户来说都是相同的，那么我们可以只渲染一次，提前在构建过程中完成，而不是每次请求进来都重新渲染页面。预渲染的页面生成后作为静态 HTML 文件被服务器托管。</p><p>SSG 保留了和 SSR 应用相同的性能表现：它带来了优秀的首屏加载性能。同时，它比 SSR 应用的花销更小，也更容易部署，因为它输出的是静态 HTML 和资源文件。这里的关键词是静态：SSG 仅可以用于消费静态数据的页面，即数据在构建期间就是已知的，并且在多次部署期间不会改变。每当数据变化时，都需要重新部署。</p><p>如果你调研 SSR 只是为了优化为数不多的营销页面的 SEO (例如 /、/about 和 /contact 等)，那么你可能需要 SSG 而不是 SSR。SSG 也非常适合构建基于内容的网站，比如文档站点或者博客。事实上，你现在正在阅读的这个网站就是使用 VitePress 静态生成的，它是一个由 Vue 驱动的静态站点生成器。</p><p>nuxt.js：一个基于 Vue.js 的服务端渲染应用框架.</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域规定了如何设置变量，当前执行代码对变量的访问权限<br>js采用词法作用域即静态作用域，函数定义的时候就已经确定了作用域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value = <span class="number">2</span></span><br><span class="line">  get()</span><br><span class="line">&#125;</span><br><span class="line">get() <span class="comment">// 1</span></span><br><span class="line">getFn() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>变量对象：当前代码段中，所有的变量、函数、形参等组成的对象<br>全局变量对象variable object VO函数由于被执行才激活actived object AO</p><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>是变量对象的集合，就是变量对象组成的链式结构<br>js中函数存在一个隐式属性[[scopes]]，保存当前函数的执行上下文，数据结构式链式的，因此被称为作用域链。<br>一系列AO对象组成的一个链式结构</p><p>[[scopes]]在函数声明时产生，在函数调用时更新：在函数调用时，将该函数的AO对象压入unnshift到[[scopes]]中</p><p><strong>作用域链的作用：</strong><br>作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，访问到window即终止，作用域链的变量向下访问是禁止的。<br>函数内部可以访问函数外部的变量，函数外部不可以访问函数内部的变量</p><p>函数执行完后作用域链就断开销毁</p><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><p>小记：<br>  loader：test属性表示哪些文件被转换 use属性定义在进行转换时使用哪个loader<br>  css-loader: 将css资源转换成commonjs模块到js中<br>  style-loader：将css-loader生成的js模块的css代码插入到页面的style标签中<br>  less-loader/sass-loader/stylus-loader：将less、sass、stylus编译成css<br>  处理图片资源：<br>  webpack4: file-loader, url-loader<br>  webpack5: asset/resource, asset/inline, asset/source, asset 资源模块类型<br>  rules: [{ test: /.png$/, type: ‘asset’}]<br>  将文件输出到指定资源目录：<br>  rules: [<br>    {<br>      test: /.png$/,<br>      …<br>      generator: {<br>        filename: ‘static/image/[hash][ext]’<br>      }<br>    }<br>  ]<br>  每次构建前清理dist文件夹：<br>  output: { clean: true }<br>  eslint负责语法检验，prettier负责代码风格检测<br>  webpack4使用eslint-laoder，webpack5使用eslint-webpack-plugins<br>  babel负责将es6语法转换为向后兼容的js语法，能够运行在当前浏览器和旧版本浏览器中.babel-loader<br>  babel-preset-env: 只转换语法，不转换新的API</p><p>  HtmlWebpackPlugin:生成一个html5文件将打包输出的所有bundle都都在script标签引入<br>  webpack-dev-server:监听文件改变，自动打包</p><p>  css处理，提取css文件，css-loader和style-loader将css文件打包到js文件中在style标签引入，会使网站出现闪屏<br>  mini-css-extract-plugin:将css文件单独提取出来，在html文件中通过link引入。<br>  rules: [<br>  {<br>    test: /.css$/i,<br>    use: [MiniCssExtractPlugin.loader, “css-loader”],<br>  }]</p><p>  css兼容性处理：postcss-loader postcss postcss-preset-env<br>  在package.json中配置需要浏览器兼容的程度: “browserslint: {…}”<br>  优化和压缩css：css-minimizer-webpack-plugin 配置在optimization: { minimizer: [new CssMinimizerPlugin()]}</p><p>  启用HMR HotMouduleReplacement，热模块更替，在程序运行中添加、删除、更换某个模块的代码而无需加载整个页面，开发时更改某个模块的代码，webpack会默认将所有模块打包编译，速度很慢。devServer: {hot: true},但是hot: true不支持js热模块替换，js更改整个页面都重新刷新.实际使用框架，vue-loader、react-hot-loader解决热更替</p><p>  oneOf: 每个文件只能被一个loader配置处理. rules: [oneOf[…]]</p><p>  开启cache缓存，每次打包都要经过eslint检查和babel编译，可以缓存之前的检查和编译结果，提高打包速度。在babel-loaderder和eslint-plugin的配置开启cache缓存</p><p>  Thread-loader多进程，当项目越来越大，打包速度更慢，使用多线程同时处理js文件，配置时将此loader放置在所有loader之前</p><p>  TerserWebpackPlugin压缩js代码<br>  Tree-shaking：移除未使用代码减少代码体积<br>  减少babel代码体积：@babel/plugin-transform-runtime</p><p>  image-minimizer-webpack-plugin:本地静态图片压缩，减少代码体积</p><p>  代码分割：打包时会把所有js文件打包到一个js文件中，体积太大如果渲染首页，就应该只加载首页所需的js<br>  代码分割：<br>  分割文件，将打包代码分割成多个js文件<br>  按需加载，需要哪个文件加载哪个<br>  配置：optimization.splitChunks</p><p>  自定义loader：clean-log-loader</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// clean-log-loader</span></span><br><span class="line"><span class="comment">// 清理console.log</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> context.replace(<span class="regexp">/console\.log\(.*\);?/g</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  use: [<span class="string">&#x27;./loaders/clean-log-loader&#x27;</span>]</span><br><span class="line">&#125; <span class="comment">// 自定义loader</span></span><br></pre></td></tr></table></figure><p>  loader分为：pre前置loader、normal普通loader、inline内联loader、post后置loader，优先级pre&gt;normal&gt;inline&gt;post</p><p>为什么使用webpack？</p><p>框架、ES6模块化语法，预处理器scss等需要转换为浏览器能识别的js、css等</p><p>webpack静态打包工具, 处理非js文件</p><p>功能：</p><p>开发模式-development：仅能编译JS中的ES6模块化语法<br>生产模式-production：能编译JS中的ES6模块化语法，还能压缩js代码</p><p>安装依赖:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br><span class="line">npm i webpack webpack-cli -D</span><br></pre></td></tr></table></figure><p>webpack编译:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack ./src/main.js --mode=development</span><br></pre></td></tr></table></figure><p>核心概念：</p><p>entry：入口，指定webpack从哪个文件开始打包<br>output: 输出，打包完的代码输出到哪里如何命名等<br>loader：加载器，webpack本身只能处理js、json等资源，其他资源需要借助loader，webpack才能解析<br>plugins：插件，扩展webpack的功能<br>mode：模式，开发:development, 生产production</p><p>webpack配置文件webpack.config.js</p><p>根目录下创建webpack.config.js文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./src/main.js&#x27;</span>, <span class="comment">// 相对路径</span></span><br><span class="line">  <span class="comment">// 输出</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>), <span class="comment">// 绝对路径，__dirname当前目录的目录名</span></span><br><span class="line">    filename: <span class="string">&#x27;main.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// loaders</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: []</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 插件</span></span><br><span class="line">  plugins: [],</span><br><span class="line">  <span class="comment">// 模式</span></span><br><span class="line">  mode: <span class="string">&#x27;development&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行打包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><p>开发模式：<br>1、编译代码，使浏览器能识别：样式资源、字体图标、图片、html等）<br>2、代码质量检查，eslint等</p><p>处理css资源：css-loader</p><p>安装css-loader:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev css-loader style-loader</span><br></pre></td></tr></table></figure><p>配置loader：</p><p>在 webpack 的配置中，loader 有两个属性：</p><ul><li>test 属性，识别出哪些文件会被转换。</li><li>use 属性，定义出在进行转换时，应该使用哪个 loader。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">&#x27;style-loader&#x27;</span>, <span class="comment">// 将css资源创建style标签添加到html文件中生效</span></span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span> <span class="comment">// 将css资源编译成commonjs的模块到js中</span></span><br><span class="line">        ]&#125; <span class="comment">// use执行顺序从右到左</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用less-loader：</p><p>首先，你需要先安装 less 和 less-loader：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install less less-loader --save-dev</span><br></pre></td></tr></table></figure><p>然后将该 loader 添加到 webpack 的配置中去:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">&#x27;style-loader&#x27;</span>, <span class="comment">// 将css资源创建style标签添加到html文件中生效</span></span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span>, <span class="comment">// 将css资源编译成commonjs的模块到js中</span></span><br><span class="line">          <span class="string">&#x27;less-loader&#x27;</span></span><br><span class="line">        ]&#125; <span class="comment">// use执行顺序从右到左</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用sass-loader<br>首先，你需要安装 sass-loader：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install sass-loader sass webpack --save-dev</span><br></pre></td></tr></table></figure><p>然后将本 loader 添加到你的 Webpack 配置:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.s[ac]ss$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="comment">// 将 JS 字符串生成为 style 节点</span></span><br><span class="line">          <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">          <span class="comment">// 将 CSS 转化成 CommonJS 模块</span></span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">          <span class="comment">// 将 Sass 编译成 CSS</span></span><br><span class="line">          <span class="string">&#x27;sass-loader&#x27;</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用stylus-loader，首先，先安装stylus和stylus-loader：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install stylus stylus-loader --save-dev</span><br></pre></td></tr></table></figure><p>将stylus-loader添加到配置中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="comment">// 将 JS 字符串生成为 style 节点</span></span><br><span class="line">          <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">          <span class="comment">// 将 CSS 转化成 CommonJS 模块</span></span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">          <span class="comment">// 将 stylus 编译成 CSS</span></span><br><span class="line">          <span class="string">&#x27;stylus-loader&#x27;</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理图片资源，webpack4处理图片资源使用file-loader和url-loader,现在webpack5，使用资源模块类型(asset module type)，通过添加 4 种新的模块类型，来替换所有这些 loader：</p><ul><li>asset/resource 发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现。</li><li>asset/inline 导出一个资源的 data URI。之前通过使用 url-loader 实现。</li><li>asset/source 导出资源的源代码。之前通过使用 raw-loader 实现。</li><li>asset 在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源体积限制实现</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|webp|svg|jpeg)$/</span>,</span><br><span class="line">        type: <span class="string">&#x27;asset&#x27;</span>, <span class="comment">//asset通用资源类型  自动地在 resource 和 inline 之间进行选择：</span></span><br><span class="line">        <span class="comment">// 小于 8kb 的文件，将会视为 inline 模块类型，否则会被视为 resource 模块类型。</span></span><br><span class="line">        parser: &#123;</span><br><span class="line">          dataUrlCondition: &#123;</span><br><span class="line">            maxSize: <span class="number">10</span> * <span class="number">1024</span> <span class="comment">// 8kb</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将文件输出到指定资源目录：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.(png|jpg|webp|svg|jpeg)$/</span>,</span><br><span class="line">  type: <span class="string">&#x27;asset&#x27;</span>, <span class="comment">//asset通用资源类型  自动地在 resource 和 inline 之间进行选择：</span></span><br><span class="line">  <span class="comment">// 小于 8kb 的文件，将会视为 inline 模块类型，否则会被视为 resource 模块类型。</span></span><br><span class="line">  parser: &#123;</span><br><span class="line">    dataUrlCondition: &#123;</span><br><span class="line">      maxSize: <span class="number">10</span> * <span class="number">1024</span> <span class="comment">// 8kb</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  generator: &#123;</span><br><span class="line">    filename: <span class="string">&#x27;static/images/[hash][ext][query]&#x27;</span> <span class="comment">// 输出文件名,将某些资源发送到指定目录：</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>[hash:10]代表哈希值取10位</p><p>每次构建前清理dist文件夹：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>), <span class="comment">// 绝对路径，__dirname当前目录的目录名</span></span><br><span class="line">    filename: <span class="string">&#x27;main.js&#x27;</span>,</span><br><span class="line">    clean: <span class="literal">true</span> <span class="comment">// 在每次构建前清理 /dist 文件夹</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用字体资源：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.(ttf|woff|woff2)$/</span>, <span class="comment">// 字体资源</span></span><br><span class="line">  type: <span class="string">&#x27;asset/resource&#x27;</span>,</span><br><span class="line">  generator: &#123;</span><br><span class="line">    filename: <span class="string">&#x27;static/media/[hash][ext][query]&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他资源比如map3等也可以像字体资源处理</p><p>处理js资源：<br>针对js兼容性处理，使用babel完成<br>针对代码个格式，使用eslint处理</p><p>Eslint配置文件写法：</p><ul><li><p>.eslintrc.*: 新建文件，位于根目录</p><ul><li>.eslintrc</li><li>.eslintrc.js</li><li>.eslintrc.json</li><li>区别在于配置格式不一样</li></ul></li><li><p>package.json中的eslintConfig中配置</p></li></ul><p>eslint在webpack4是eslint-loader，在webpack5是plugins</p><p>使用eslint需要安装 eslint-webpack-plugin：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install eslint-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure><p>注意: 如果未安装 eslint &gt;= 7 ，你还需先通过 npm 安装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install eslint --save-dev</span><br></pre></td></tr></table></figure><p>然后把插件添加到你的 webpack 配置:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ESLintPlugin = <span class="built_in">require</span>(<span class="string">&#x27;eslint-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> ESLintPlugin(&#123;</span><br><span class="line">      <span class="comment">// 指定文件根目录，类型为字符串,检测哪些文件</span></span><br><span class="line">      context: path.resolve(__dirname, <span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>创建eslint配置文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="keyword">extends</span>: [<span class="string">&#x27;eslint:recommended&#x27;</span>],</span><br><span class="line">  env: &#123;</span><br><span class="line">    node: <span class="literal">true</span>, <span class="comment">// 启动node全局变量</span></span><br><span class="line">    browser: <span class="literal">true</span> <span class="comment">// 启用浏览器全局变量</span></span><br><span class="line">  &#125;,</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    ecmaVersion: <span class="number">6</span>, <span class="comment">// es6</span></span><br><span class="line">    sourceType: <span class="string">&quot;module&quot;</span> <span class="comment">// es module</span></span><br><span class="line">  &#125;,</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="string">&quot;no-var&quot;</span>: <span class="number">2</span> <span class="comment">// 不能使用var定义变量</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Babel将es6语法编写的代码转换为向后兼容的js语法，能够运行在当前和旧版本的浏览器或其他环境中。</p><p>配置文件有多种写法：</p><ul><li>babel.config.*: 新建文件，位于根目录<ul><li>babel.config.js</li><li>babel.config.json</li></ul></li><li>.babelrc.*:新建文件，位于根目录<ul><li>.babelrc</li><li>.babelrc.js</li><li>.babelrc.json</li></ul></li><li>package.json中的label中，不需要创建文件</li></ul><p>使用babel,先安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D babel-loader @babel/core @babel/preset-env webpack</span><br></pre></td></tr></table></figure><p>webpack 配置对象中，需要将 babel-loader 添加到 module 列表中:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.m?js$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          presets: [<span class="string">&#x27;@babel/preset-env&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HtmlWebpackPlugin 简化了 HTML 文件的创建，以便为你的 webpack 包提供服务。这对于那些文件名中包含哈希值，并且哈希值会随着每次编译而改变的 webpack 包特别有用。</p><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev html-webpack-plugin</span><br></pre></td></tr></table></figure><p>该插件将为你生成一个 HTML5 文件， 在 body 中使用 script 标签引入你所有 webpack 生成的 bundle.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack-dev-server监听文件改变，自动打包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack-dev-server -D</span><br></pre></td></tr></table></figure><p>配置webpack.config.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">   <span class="comment">// 开发服务器</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    host: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">    port: <span class="number">3000</span>,</span><br><span class="line">    open: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行命令：<code>npx webpack serve</code></p><p><strong>生产模式：</strong></p><p>优化代码运行性能<br>优化打包速度</p><p>根目录下创建config目录，创建webpack.dev.js和webpack.prod.js</p><p>然后运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npx webpack serve --config ./config/webpack.dev.js // dev</span><br><span class="line">npx webpack --config ./config/webpack.prod.js // prod</span><br></pre></td></tr></table></figure><p>或者加入package.json：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;start&quot;: &quot;npm run dev&quot;,</span><br><span class="line">  &quot;dev&quot;: &quot;webpack serve --config ./config/webpack.dev.js&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;webpack --config ./config/webpack.prod.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>css处理，提取css文件.</strong></p><p>css文件目前被打包到js文件，当js文件加载时，会创建一个style标签来生成样式</p><p>这样对网站不好，会出现闪屏</p><p>单独将css文件分离，用link标签加载性能更好</p><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev mini-css-extract-plugin</span><br></pre></td></tr></table></figure><p>建议 mini-css-extract-plugin 与 css-loader 一起使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&quot;mini-css-extract-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [<span class="keyword">new</span> MiniCssExtractPlugin()],</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行<code>npm run build</code> 打包后的index.html会link引入css文件<br>不要同时使用 style-loader 与 mini-css-extract-plugin。</p><p><strong>css样式兼容性处理.</strong><br>需要安装 postcss-loader 和 postcss, postcss-preset-env</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev postcss-loader postcss postcss-preset-env</span><br></pre></td></tr></table></figure><p>配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              postcssOptions: &#123;</span><br><span class="line">                plugins: [</span><br><span class="line">                  [</span><br><span class="line">                    <span class="string">&#x27;postcss-preset-env&#x27;</span>,</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="comment">// 其他选项</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                  ],</span><br><span class="line">                ],</span><br><span class="line">              &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者使用postcss本身的配置文件postcss.config.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&#x27;postcss-preset-env&#x27;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 其他选项</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在package.json中配置需要浏览器兼容的程度：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;browserslist&quot;: [</span><br><span class="line">  &quot;&gt; 1%&quot;,</span><br><span class="line">  &quot;last 2 versions&quot;,</span><br><span class="line">  <span class="string">&quot;not ie &lt;= 8&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>比如display:flex,打包编译会变成</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">-webkit-box</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">-ms-flexbox</span>;</span><br></pre></td></tr></table></figure><p><strong>优化和压缩css：</strong></p><p>你需要安装 css-minimizer-webpack-plugin：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install css-minimizer-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure><p>接着在 webpack 配置中加入该插件:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&quot;mini-css-extract-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> CssMinimizerPlugin = <span class="built_in">require</span>(<span class="string">&quot;css-minimizer-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/.s?css$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;sass-loader&quot;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimizer: [</span><br><span class="line">      <span class="comment">// 在 webpack@5 中，你可以使用 `...` 语法来扩展现有的 minimizer（即 `terser-webpack-plugin`），将下一行取消注释</span></span><br><span class="line">      <span class="comment">// `...`,</span></span><br><span class="line">      <span class="keyword">new</span> CssMinimizerPlugin(),</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [<span class="keyword">new</span> MiniCssExtractPlugin()],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这将仅在生产环境开启 CSS 优化。</p><p>如果还想在开发环境下启用 CSS 优化，请将 optimization.minimize 设置为 true:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    <span class="comment">// [...]</span></span><br><span class="line">    minimize: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>默认生产模式已开启html压缩和js压缩</p><p>SourceMap: 开发环境中，运行代码source是编译过的。<br>sourcemap是源代码和编译后的代码的映射文件，代码出错后找到源代码出错位置，从而让浏览器提示出错误。</p><p>devtool选项配置sourcemap，不同的值会明显影响到构建(build)和重新构建(rebuild)的速度。<br>值有很多种，但是一般只关心开发和生产模式的值：</p><p>开发模式：devtool: cheap-module-source-map<br>优点：打包编译速度快，只包含行映射<br>缺点：没有列映射</p><p>生产模式：devtool: source-map<br>优点：包含行和列映射<br>缺点：打包编译速度更慢</p><p><strong>启用 HMR: 提升打包构建速度。</strong></p><p>开发时更改一个模块的代码，webpack会默认所有模块全部打包编译，速度很慢。<br>HotModuleReplacement：HMR热模块替换，在程序运行中添加、替换、删除模块而无需重新加载整个页面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    hot: <span class="literal">true</span>, <span class="comment">// 启用 webpack 的 热模块替换</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是hot: true不支持js热模块替换，js更改整个页面都重新刷新</p><p>实际使用框架，vue-loader、react-hot-loader解决热更替</p><p><strong>oneOf: 每个文件只能被一个loader配置处理.</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 每个文件只能被一个loader配置处理</span></span><br><span class="line">      oneOf: [</span><br><span class="line">        &#123;</span><br><span class="line">          test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">          use: [</span><br><span class="line">          <span class="string">&#x27;style-loader&#x27;</span>, <span class="comment">// 将css资源创建style标签添加到html文件中生效</span></span><br><span class="line">          <span class="string">&#x27;css-loader&#x27;</span>, <span class="comment">// 将css资源编译成commonjs的模块到js中</span></span><br><span class="line">          <span class="string">&#x27;less-loader&#x27;</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;, <span class="comment">// use执行顺序从右到左</span></span><br><span class="line">        &#123;</span><br><span class="line">          test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">          use: [</span><br><span class="line">            <span class="comment">// compiles Less to CSS</span></span><br><span class="line">            <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;less-loader&#x27;</span>,</span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line">          use: [</span><br><span class="line">            <span class="comment">// 将 JS 字符串生成为 style 节点</span></span><br><span class="line">            <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">            <span class="comment">// 将 CSS 转化成 CommonJS 模块</span></span><br><span class="line">            <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">            <span class="comment">// 将 Sass 编译成 CSS</span></span><br><span class="line">            <span class="string">&#x27;sass-loader&#x27;</span>,</span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">          use: [</span><br><span class="line">            <span class="comment">// 将 JS 字符串生成为 style 节点</span></span><br><span class="line">            <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">            <span class="comment">// 将 CSS 转化成 CommonJS 模块</span></span><br><span class="line">            <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">            <span class="comment">// 将 stylus 编译成 CSS</span></span><br><span class="line">            <span class="string">&#x27;stylus-loader&#x27;</span>,</span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test: <span class="regexp">/\.(png|jpg|webp|svg|jpeg)$/</span>,</span><br><span class="line">          type: <span class="string">&#x27;asset&#x27;</span>, <span class="comment">//asset通用资源类型  自动地在 resource 和 inline 之间进行选择：</span></span><br><span class="line">          <span class="comment">// 小于 8kb 的文件，将会视为 inline 模块类型，否则会被视为 resource 模块类型。</span></span><br><span class="line">          parser: &#123;</span><br><span class="line">            dataUrlCondition: &#123;</span><br><span class="line">              maxSize: <span class="number">10</span> * <span class="number">1024</span> <span class="comment">// 8kb</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          generator: &#123;</span><br><span class="line">            filename: <span class="string">&#x27;static/images/[hash][ext][query]&#x27;</span> <span class="comment">// 输出文件名,将某些资源发送到指定目录：</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test: <span class="regexp">/\.(ttf|woff|woff2)$/</span>, <span class="comment">// 字体资源</span></span><br><span class="line">          type: <span class="string">&#x27;asset/resource&#x27;</span>,</span><br><span class="line">          generator: &#123;</span><br><span class="line">            filename: <span class="string">&#x27;static/media/[hash][ext][query]&#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">          exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">          loader: <span class="string">&#x27;babel-loader&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><strong>Include/Exclude.</strong></p><p>Include: 包含，只处理xxx文件<br>Exclude: 排除，除列xxx文件都处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  exclude: <span class="regexp">/node_modules/</span>, <span class="comment">// 排除node_modules文件</span></span><br><span class="line">  <span class="comment">// include: path.resolve(__dirname, &#x27;../src&#x27;)</span></span><br><span class="line">  loader: <span class="string">&#x27;babel-loader&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Cache: 开启缓存。</strong></p><p>每次打包都要经过babel编译和eslint检查，速度慢<br>可以缓存之前的babel编译和eslint检查，这样第二次打包速度会更快</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        cacheDirectory: <span class="literal">true</span>, <span class="comment">// 开启babel缓存</span></span><br><span class="line">        cacheCompression: <span class="literal">false</span> <span class="comment">// 关闭缓存文件压缩</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> EslintPlugin(&#123;</span><br><span class="line">    <span class="comment">// 指定文件根目录，类型为字符串,检测哪些文件</span></span><br><span class="line">    context: path.resolve(__dirname, <span class="string">&#x27;../src&#x27;</span>),</span><br><span class="line">    exclude: <span class="string">&quot;node_modules&quot;</span>,</span><br><span class="line">    cache: <span class="literal">true</span>, <span class="comment">// 开启缓存</span></span><br><span class="line">    cacheLocation: path.resolve(__dirname, <span class="string">&#x27;../node_modules/.cache/eslint-webpack-plugin/.eslintcache&#x27;</span>)</span><br><span class="line">  &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>Thread-loader: 多进程。</strong></p><p>项目越来越大时，打包速度更慢，可以开启多进程同时处理js文件。</p><p>使用时，需将此 loader 放置在其他 loader 之前。放置在此 loader 之后的 loader 会在一个独立的 worker 池中运行。</p><p>每个 worker 都是一个独立的 node.js 进程，其开销大约为 600ms 左右。同时会限制跨进程的数据交换。</p><p>请仅在耗时的操作中使用此 loader！<br>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev thread-loader</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        include: path.resolve(<span class="string">&#x27;src&#x27;</span>),</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">&quot;thread-loader&quot;</span>,</span><br><span class="line">          <span class="comment">// 耗时的 loader （例如 babel-loader）</span></span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// with options</span></span><br><span class="line">use: [</span><br><span class="line">  &#123;</span><br><span class="line">    loader: <span class="string">&quot;thread-loader&quot;</span>,</span><br><span class="line">    <span class="comment">// 有同样配置的 loader 会共享一个 worker 池</span></span><br><span class="line">    options: &#123;</span><br><span class="line">      <span class="comment">// 产生的 worker 的数量，默认是 (cpu 核心数 + 1)，或者，</span></span><br><span class="line">      <span class="comment">// 在 require(&#x27;os&#x27;).cpus() 是 undefined 时回退至 1</span></span><br><span class="line">      workers: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 一个 worker 进程中并行执行工作的数量</span></span><br><span class="line">      <span class="comment">// 默认为 20</span></span><br><span class="line">      workerParallelJobs: <span class="number">50</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 额外的 node.js 参数</span></span><br><span class="line">      workerNodeArgs: [<span class="string">&#x27;--max-old-space-size=1024&#x27;</span>],</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 允许重新生成一个僵死的 work 池</span></span><br><span class="line">      <span class="comment">// 这个过程会降低整体编译速度</span></span><br><span class="line">      <span class="comment">// 并且开发环境应该设置为 false</span></span><br><span class="line">      poolRespawn: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 闲置时定时删除 worker 进程</span></span><br><span class="line">      <span class="comment">// 默认为 500（ms）</span></span><br><span class="line">      <span class="comment">// 可以设置为无穷大，这样在监视模式(--watch)下可以保持 worker 持续存在</span></span><br><span class="line">      poolTimeout: <span class="number">2000</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 池分配给 worker 的工作数量</span></span><br><span class="line">      <span class="comment">// 默认为 200</span></span><br><span class="line">      <span class="comment">// 降低这个数值会降低总体的效率，但是会提升工作分布更均一</span></span><br><span class="line">      poolParallelJobs: <span class="number">50</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 池的名称</span></span><br><span class="line">      <span class="comment">// 可以修改名称来创建其余选项都一样的池</span></span><br><span class="line">      name: <span class="string">&quot;my-pool&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 耗时的 loader（例如 babel-loader）</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> threads = os.cpus().length <span class="comment">// 获取cpu的核数量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      use: [</span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">&#x27;thread-loader&#x27;</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            works: threads <span class="comment">// 进程数量</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            cacheDirectory: <span class="literal">true</span>, <span class="comment">// 开启babel缓存</span></span><br><span class="line">            cacheCompression: <span class="literal">false</span> <span class="comment">// 关闭缓存文件压缩</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> EslintPlugin(&#123;</span><br><span class="line">    <span class="comment">// 指定文件根目录，类型为字符串,检测哪些文件</span></span><br><span class="line">    context: path.resolve(__dirname, <span class="string">&#x27;../src&#x27;</span>),</span><br><span class="line">    exclude: <span class="string">&quot;node_modules&quot;</span>,</span><br><span class="line">    cache: <span class="literal">true</span>, <span class="comment">// 开启缓存</span></span><br><span class="line">    cacheLocation: path.resolve(__dirname, <span class="string">&#x27;../node_modules/.cache/eslint-webpack-plugin/.eslintcache&#x27;</span>),</span><br><span class="line">    threads <span class="comment">// 开启多进程和设置多进程数量</span></span><br><span class="line">  &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>TerserWebpackPlugin:该插件使用 terser 来压缩 JavaScript。<br>webpack v5 开箱即带有最新版本的 terser-webpack-plugin。如果你使用的是 webpack v5 或更高版本，同时希望自定义配置，那么仍需要安装 terser-webpack-plugin。如果使用 webpack v4，则必须安装 terser-webpack-plugin v4 的版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install terser-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">&quot;terser-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// css压缩优化</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimizer: [</span><br><span class="line">      <span class="comment">// 在 webpack@5 中，你可以使用 `...` 语法来扩展现有的 minimizer（即 `terser-webpack-plugin`），将下一行取消注释</span></span><br><span class="line">      <span class="comment">// `...`,</span></span><br><span class="line">      <span class="keyword">new</span> CssMinimizerPlugin(),</span><br><span class="line">      <span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">        parallel: threads <span class="comment">// 开启多进程和设置多进程数量</span></span><br><span class="line">      &#125;) <span class="comment">// 压缩js</span></span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>减少代码体积： tree shaking.</strong></p><p>开发时定义了一些工具函数库，或引入第三方工具函数库或组件库</p><p>可能只使用极小一部分功能确需要引入整个库，打包进来体积很大</p><p>Tree shaking一个术语，用于描述移除js中未使用的代码</p><p>webpack默认开启这个功能</p><p>减少babel代码体积：@babel/plugin-transform-runtime</p><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @babel/plugin-transform-runtime -D</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">  use: [</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">&#x27;thread-loader&#x27;</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        works: threads <span class="comment">// 进程数量</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        cacheDirectory: <span class="literal">true</span>, <span class="comment">// 开启babel缓存</span></span><br><span class="line">        cacheCompression: <span class="literal">false</span>, <span class="comment">// 关闭缓存文件压缩</span></span><br><span class="line">        plugins: [<span class="string">&quot;@babel/plugin-transform-runtime&quot;</span>] <span class="comment">// 减少代码体积</span></span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Image minimizer： 图片压缩。</strong></p><p>本地静态图片压缩，减少代码体积</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install image-minimizer-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure><p>无损压缩模式，需要安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install imagemin-gifsicle imagemin-jpegtran imagemin-optipng imagemin-svgo imagemin --save-dev</span><br></pre></td></tr></table></figure><p>有损压缩：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install imagemin-gifsicle imagemin-mozjpeg imagemin-pngquant imagemin-svgo imagemin --save-dev</span><br></pre></td></tr></table></figure><p>配置webpack.config.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ImageMinimizerPlugin = <span class="built_in">require</span>(<span class="string">&quot;image-minimizer-webpack-plugin&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; extendDefaultPlugins &#125; = <span class="built_in">require</span>(<span class="string">&quot;svgo&quot;</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">new</span> ImageMinimizerPlugin(&#123;</span><br><span class="line">  minimizer: &#123;</span><br><span class="line">    implementation: ImageMinimizerPlugin.imageminGenerate,</span><br><span class="line">    options: &#123;</span><br><span class="line">      <span class="comment">// Lossless optimization with custom option</span></span><br><span class="line">      <span class="comment">// Feel free to experiment with options for better result for you</span></span><br><span class="line">      plugins: [</span><br><span class="line">        [<span class="string">&quot;gifsicle&quot;</span>, &#123; <span class="attr">interlaced</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">        [<span class="string">&quot;jpegtran&quot;</span>, &#123; <span class="attr">progressive</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">        [<span class="string">&quot;optipng&quot;</span>, &#123; <span class="attr">optimizationLevel</span>: <span class="number">5</span> &#125;],</span><br><span class="line">        <span class="comment">// Svgo configuration here https://github.com/svg/svgo#configuration</span></span><br><span class="line">        [</span><br><span class="line">          <span class="string">&quot;svgo&quot;</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            plugins: [</span><br><span class="line">              <span class="string">&quot;preset-default&quot;</span>,</span><br><span class="line">              <span class="string">&quot;prefixIds&quot;</span></span><br><span class="line">            ],</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      ],</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure><p><strong>Code Split：代码分割。</strong><br>打包代码时会将所有js文件打包到一个文件中，体积太大了，如果渲染首页，就应该只加载首页的js。</p><p>对js文件进行分割，渲染哪个页面就加载对应js，加载资源少速度更快</p><p>代码分割：<br>1、分割文件，将打包生成的文件进行分割，分为多个js文件<br>2、按需加载，需要哪个文件加载哪个</p><p>配置：optimization.splitChunks</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">&#x27;async&#x27;</span>,</span><br><span class="line">      minSize: <span class="number">20000</span>,</span><br><span class="line">      minRemainingSize: <span class="number">0</span>,</span><br><span class="line">      minChunks: <span class="number">1</span>,</span><br><span class="line">      maxAsyncRequests: <span class="number">30</span>,</span><br><span class="line">      maxInitialRequests: <span class="number">30</span>,</span><br><span class="line">      enforceSizeThreshold: <span class="number">50000</span>,</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        defaultVendors: &#123;</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          priority: -<span class="number">10</span>,</span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">          minChunks: <span class="number">2</span>,</span><br><span class="line">          priority: -<span class="number">20</span>,</span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>自定义loader：</strong></p><p>clean-log-loader</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// clean-log-loader</span></span><br><span class="line"><span class="comment">// 清理console.log</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> context.replace(<span class="regexp">/console\.log\(.*\);?/g</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">  use: [<span class="string">&#x27;./loaders/clean-log-loader&#x27;</span>]</span><br><span class="line">&#125; <span class="comment">// 自定义loader</span></span><br></pre></td></tr></table></figure><p>loader分为：</p><ul><li>pre 前置loader</li><li>normal 普通loader</li><li>inline 内联loader</li><li>post 后置loader</li></ul><p>优先级：前置loader &gt; 普通loader &gt; 内联loader &gt; 后置loader</p><p>同步loader：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> context</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步loader：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">content, map, meta</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> callback = <span class="built_in">this</span>.async();</span><br><span class="line">  someAsyncOperation(content, <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line">    callback(<span class="literal">null</span>, result, map, meta);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>“Raw” Loader:默认情况下，资源文件会被转化为 UTF-8 字符串，然后传给 loader。通过设置 raw 为 true，loader 可以接收原始的 Buffer</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">content</span>) </span>&#123;</span><br><span class="line">  assert(content <span class="keyword">instanceof</span> Buffer);</span><br><span class="line">  <span class="keyword">return</span> someSyncOperation(content);</span><br><span class="line">  <span class="comment">// 返回值也可以是一个 `Buffer`</span></span><br><span class="line">  <span class="comment">// 即使不是 &quot;raw&quot;，loader 也没问题</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports.raw = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>Pitching Loader:loader 总是 从右到左被调用。有些情况下，loader 只关心 request 后面的 元数据(metadata)，并且忽略前一个 loader 的结果。在实际（从右到左）执行 loader 之前，会先 从左到右 调用 loader 上的 pitch 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">content</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someSyncOperation(content, <span class="built_in">this</span>.data.value);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports.pitch = <span class="function"><span class="keyword">function</span> (<span class="params">remainingRequest, precedingRequest, data</span>) </span>&#123;</span><br><span class="line">  data.value = <span class="number">42</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>plugin: 自定义plugin。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * webpack会加载配置文件和命令语句初始化参数，生成compoliler对象，加载配置的插件</span></span><br><span class="line"><span class="comment"> * 变量所有插件，调用的插件的apply方法</span></span><br><span class="line"><span class="comment"> * 开始编译（触发各个hooks钩子事件）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestPlugin</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;testPlugin constructor&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  apply (complier) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;testPlugin apply&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// testPlugin constructor</span></span><br><span class="line"><span class="comment">// testPlugin apply</span></span><br><span class="line"><span class="built_in">module</span>.exports = TestPlugin</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在webpack.config.js配置使用：</span></span><br><span class="line"><span class="keyword">const</span> TestPlugin = <span class="built_in">require</span>(<span class="string">&#x27;../plugins/test-plugin&#x27;</span>) <span class="comment">// 自定义插件</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> TestPlugin()</span><br><span class="line">]</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>complier模块是webpack的主要引擎，通过cli或者node api传递的所有选项创建一个compilation 实例。<br>它扩展（extends）自 Tapable 类，用来注册和调用插件。大多数面向用户的插件会首先在 Compiler 上注册。</p><p>根据使用不同的钩子(hooks)和tap方法，插件可以以不同的方式运行。</p><p>同步tap</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compiler.hooks.compile.tap(<span class="string">&#x27;MyPlugin&#x27;</span>, <span class="function">(<span class="params">params</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;以同步方式触及 compile 钩子。&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对于可以使用 AsyncHook 的 run 阶段， 则需使用 tapAsync 或 tapPromise（以及 tap）方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">compiler.hooks.run.tapAsync(</span><br><span class="line">  <span class="string">&#x27;MyPluginName&#x27;</span>,</span><br><span class="line">  (source, target, routesList, callback) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;以异步方式触及运行钩子。&#x27;</span>);</span><br><span class="line">    callback();</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">compiler.hooks.run.tapPromise(<span class="string">&#x27;MyPluginName&#x27;</span>, <span class="function">(<span class="params">source, target, routesList</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>)).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;以异步的方式触发具有延迟操作的钩子。&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">compiler.hooks.run.tapPromise(</span><br><span class="line">  <span class="string">&#x27;MyPluginName&#x27;</span>,</span><br><span class="line">  <span class="keyword">async</span> (source, target, routesList) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;以异步的方式触发具有延迟操作的钩子。&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>Compilation 模块会被 Compiler 用来创建新的 compilation 对象（或新的 build 对象）。 compilation 实例能够访问所有的模块和它们的依赖（大部分是循环依赖）。 它会对应用程序的依赖图中所有模块， 进行字面上的编译(literal compilation)。 在编译阶段，模块会被加载(load)、封存(seal)、优化(optimize)、 分块(chunk)、哈希(hash)和重新创建(restore)。</p><p>添加注释插件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> EslintPlugin = <span class="built_in">require</span>(<span class="string">&#x27;eslint-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&quot;mini-css-extract-plugin&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> CssMinimizerPlugin = <span class="built_in">require</span>(<span class="string">&#x27;css-minimizer-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">&quot;terser-webpack-plugin&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> ImageMinimizerPlugin = <span class="built_in">require</span>(<span class="string">&quot;image-minimizer-webpack-plugin&quot;</span>)</span><br><span class="line"><span class="comment">// const TestPlugin = require(&#x27;../plugins/test-plugin&#x27;) // 自定义插件</span></span><br><span class="line"><span class="keyword">const</span> BannerWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;../plugins/banner-webpack&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> threads = os.cpus().length <span class="comment">// 获取cpu的核数量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStyleLoader</span>(<span class="params">loader</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    MiniCssExtractPlugin.loader, <span class="comment">// 将css文件单独引入到link</span></span><br><span class="line">    <span class="comment">// &#x27;style-loader&#x27;, // 将css资源创建style标签添加到html文件中生效</span></span><br><span class="line">    <span class="string">&#x27;css-loader&#x27;</span>, <span class="comment">// 将css资源编译成commonjs的模块到js中</span></span><br><span class="line">    &#123;</span><br><span class="line">      loader: <span class="string">&#x27;postcss-loader&#x27;</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        postcssOptions: &#123;</span><br><span class="line">          plugins: [</span><br><span class="line">            [</span><br><span class="line">              <span class="string">&#x27;postcss-preset-env&#x27;</span></span><br><span class="line">            ],</span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    loader</span><br><span class="line">  ].filter(<span class="built_in">Boolean</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./src/main.js&#x27;</span>, <span class="comment">// 相对路径</span></span><br><span class="line">  <span class="comment">// 输出</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;../dist&#x27;</span>), <span class="comment">// 绝对路径，__dirname当前目录的目录名</span></span><br><span class="line">    filename: <span class="string">&#x27;static/js/main.js&#x27;</span>,</span><br><span class="line">    clean: <span class="literal">true</span> <span class="comment">// 在每次构建前清理 /dist 文件夹</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// loaders</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        oneOf: [</span><br><span class="line">          &#123;</span><br><span class="line">            test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            use: getStyleLoader()</span><br><span class="line">          &#125;, <span class="comment">// use执行顺序从右到左</span></span><br><span class="line">          &#123;</span><br><span class="line">            test: <span class="regexp">/\.less$/</span>,</span><br><span class="line">            use: getStyleLoader(<span class="string">&#x27;less-loader&#x27;</span>)</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            test: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line">            use: getStyleLoader(<span class="string">&#x27;sass-loader&#x27;</span>)</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            test: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">            use: getStyleLoader(<span class="string">&#x27;stylus-loader&#x27;</span>)</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            test: <span class="regexp">/\.(png|jpg|webp|svg|jpeg)$/</span>,</span><br><span class="line">            type: <span class="string">&#x27;asset&#x27;</span>, <span class="comment">//asset通用资源类型  自动地在 resource 和 inline 之间进行选择：</span></span><br><span class="line">            <span class="comment">// 小于 8kb 的文件，将会视为 inline 模块类型，否则会被视为 resource 模块类型。</span></span><br><span class="line">            parser: &#123;</span><br><span class="line">              dataUrlCondition: &#123;</span><br><span class="line">                maxSize: <span class="number">10</span> * <span class="number">1024</span> <span class="comment">// 8kb</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            generator: &#123;</span><br><span class="line">              filename: <span class="string">&#x27;static/images/[hash][ext][query]&#x27;</span> <span class="comment">// 输出文件名,将某些资源发送到指定目录：</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            test: <span class="regexp">/\.(ttf|woff|woff2)$/</span>, <span class="comment">// 字体资源</span></span><br><span class="line">            type: <span class="string">&#x27;asset/resource&#x27;</span>,</span><br><span class="line">            generator: &#123;</span><br><span class="line">              filename: <span class="string">&#x27;static/media/[hash][ext][query]&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">            exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            use: [</span><br><span class="line">              &#123;</span><br><span class="line">                loader: <span class="string">&#x27;thread-loader&#x27;</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                  works: threads <span class="comment">// 进程数量</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                  cacheDirectory: <span class="literal">true</span>, <span class="comment">// 开启babel缓存</span></span><br><span class="line">                  cacheCompression: <span class="literal">false</span>, <span class="comment">// 关闭缓存文件压缩</span></span><br><span class="line">                  plugins: [<span class="string">&quot;@babel/plugin-transform-runtime&quot;</span>] <span class="comment">// 减少代码体积</span></span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">// &#123;</span></span><br><span class="line">          <span class="comment">//   test: /\.js$/,</span></span><br><span class="line">          <span class="comment">//   use: [&#x27;./loaders/clean-log-loader&#x27;]</span></span><br><span class="line">          <span class="comment">// &#125; // 自定义loader</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// css压缩优化</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimizer: [</span><br><span class="line">      <span class="comment">// 在 webpack@5 中，你可以使用 `...` 语法来扩展现有的 minimizer（即 `terser-webpack-plugin`），将下一行取消注释</span></span><br><span class="line">      <span class="comment">// `...`,</span></span><br><span class="line">      <span class="keyword">new</span> CssMinimizerPlugin(),</span><br><span class="line">      <span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">        parallel: threads <span class="comment">// 开启多进程和设置多进程数量</span></span><br><span class="line">      &#125;) <span class="comment">// 压缩js</span></span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 插件</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// new TestPlugin(),</span></span><br><span class="line">    <span class="keyword">new</span> BannerWebpackPlugin(&#123;</span><br><span class="line">      author: <span class="string">&#x27;zjy&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> EslintPlugin(&#123;</span><br><span class="line">      <span class="comment">// 指定文件根目录，类型为字符串,检测哪些文件</span></span><br><span class="line">      context: path.resolve(__dirname, <span class="string">&#x27;../src&#x27;</span>),</span><br><span class="line">      exclude: <span class="string">&quot;node_modules&quot;</span>,</span><br><span class="line">      cache: <span class="literal">true</span>, <span class="comment">// 开启缓存</span></span><br><span class="line">      cacheLocation: path.resolve(__dirname, <span class="string">&#x27;../node_modules/.cache/eslint-webpack-plugin/.eslintcache&#x27;</span>),</span><br><span class="line">      threads <span class="comment">// 开启多进程和设置多进程数量</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      <span class="comment">// 以public/index.html为模版，自动引入bundles到body的script</span></span><br><span class="line">      template: path.resolve(__dirname, <span class="string">&#x27;../public/index.html&#x27;</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">&quot;static/css/main.css&quot;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> ImageMinimizerPlugin(&#123;</span><br><span class="line">      minimizer: &#123;</span><br><span class="line">        implementation: ImageMinimizerPlugin.imageminGenerate,</span><br><span class="line">        options: &#123;</span><br><span class="line">          <span class="comment">// Lossless optimization with custom option</span></span><br><span class="line">          <span class="comment">// Feel free to experiment with options for better result for you</span></span><br><span class="line">          plugins: [</span><br><span class="line">            [<span class="string">&quot;gifsicle&quot;</span>, &#123; <span class="attr">interlaced</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">            [<span class="string">&quot;jpegtran&quot;</span>, &#123; <span class="attr">progressive</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">            [<span class="string">&quot;optipng&quot;</span>, &#123; <span class="attr">optimizationLevel</span>: <span class="number">5</span> &#125;],</span><br><span class="line">            <span class="comment">// Svgo configuration here https://github.com/svg/svgo#configuration</span></span><br><span class="line">            [</span><br><span class="line">              <span class="string">&quot;svgo&quot;</span>,</span><br><span class="line">              &#123;</span><br><span class="line">                plugins: [</span><br><span class="line">                  <span class="string">&quot;preset-default&quot;</span>,</span><br><span class="line">                  <span class="string">&quot;prefixIds&quot;</span></span><br><span class="line">                ],</span><br><span class="line">              &#125;,</span><br><span class="line">            ],</span><br><span class="line">          ],</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// 模式</span></span><br><span class="line">  mode: <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">  devtool: <span class="string">&#x27;source-map&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">new</span> BannerWebpackPlugin(&#123;</span><br><span class="line">  author: <span class="string">&#x27;zjy&#x27;</span></span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure><h3 id="原型的作用是什么？"><a href="#原型的作用是什么？" class="headerlink" title="原型的作用是什么？"></a>原型的作用是什么？</h3><p>之所以实现原型，是因为javascript语言要实现面向对象，而原型是实现面向对象的方式之一。</p><p>一个能支持面向对象的语音的特点：能判定一个实例的类型。在javascript中通过原型能知道某个对象所属类型。<br>原型的存在避免了对象类型的丢失。</p><h3 id="Promise解决了什么问题？"><a href="#Promise解决了什么问题？" class="headerlink" title="Promise解决了什么问题？"></a>Promise解决了什么问题？</h3><p>Promise出现最重要的是为了统一js中的异步实现方案。</p><p>Promise也无法消除回调，它只不过通过链式调用的方式让回调变得可控</p><h3 id="async-await"><a href="#async-await" class="headerlink" title="async await"></a>async await</h3><ul><li>async 表示这是一个async函数， await只能用在async函数里面，不能单独使用</li><li>async函数返回一个Promise对象，await就是等待这个promise的返回结果后，再继续执行</li><li>await等待的是一个Promise对象，如果不是Promise对象则用Promise.resolve包装</li><li>异步async 调用和普通函数的使用方式一样</li><li>await 相当于 Promise 的 then ，then指的是成功，不指失败</li><li>await 和 then 的区别就是：then还需要传回调进去，但 await 可以直接得到值</li><li>await后面表达式promise的状态resolve才会执行后面代码，reject需要捕获错误，状态没有改变后面代码不会执行<br>try…catch 可捕获异常，代替了 Promise的 catch</li></ul><p>vue3小记-2024-01-16</p><h2 id="vue3小记"><a href="#vue3小记" class="headerlink" title="vue3小记"></a>vue3小记</h2><h3 id="优点特性"><a href="#优点特性" class="headerlink" title="优点特性"></a>优点特性</h3><p>体积减少、内存占用减少、渲染速度更快</p><p>更好支持ts</p><p>源码：使用Proxy代替defineProperty实现响应式</p><p>重写虚拟DOM实现Tree-shaking</p><h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><ul><li>不能访问this，是undefined</li><li>在beforeCreate钩子之前执行，领先所有钩子</li><li>返回值是对象或者函数：<ul><li>返回值是对象，对象里的方法，属性等都可以在模版中使用</li><li>返回值是函数，<code>return () =&gt; &#39;hello&#39;</code>, 则返回内容渲染到页面</li></ul></li></ul><p>setup和options API的关系：</p><ul><li>setup中的属性、方法可以在data、methods中访问</li><li>data、methods中的配置不能在setup中使用</li><li>两者冲突，setup优先</li></ul><h3 id="ref定义响应式对象"><a href="#ref定义响应式对象" class="headerlink" title="ref定义响应式对象"></a>ref定义响应式对象</h3><p>ref用来定义响应式变量，基本数据类型或者对象类型都可以，返回一个RefImpl对象，简称ref对象或者ref,ref对象的value属性是响应式的。若定义的是对象类型的变量，内部也会调用reactive函数</p><p><code>let name = ref(&#39;zhangsan&#39;)</code>,name不是响应式的，name.value才是响应式的，模版可以直接用name</p><h3 id="reactive定义对象类型的响应式对象"><a href="#reactive定义对象类型的响应式对象" class="headerlink" title="reactive定义对象类型的响应式对象"></a>reactive定义对象类型的响应式对象</h3><p>只能定义对象类型的响应式对象，基本类型用ref</p><p><code>let person = reactive(&#123; name: &#39;Susan&#39;, age: 20&#125;)</code>,是深层次结构的响应式对象</p><p>注意：<code>person = reactive(&#123;name: &#39;susan&#39;, age: 21&#125;)</code>会断开响应式的连接，若需修改整个对象可使用</p><p><code>person = Object.assign(person, &#123;...&#125;)</code></p><h3 id="ref和reactive的对比"><a href="#ref和reactive的对比" class="headerlink" title="ref和reactive的对比"></a>ref和reactive的对比</h3><p>ref用来定义：基本类型数据、对象类型数据</p><p>reactive用来定义：对象类型数据</p><p>区别：</p><ul><li>ref对象使用value属性访问</li><li>reactive重新分配一个对象会失去响应式，可以用Object.assign替换整体</li></ul><p>使用：</p><ul><li>基本数据类型必用ref定义</li><li>层级不深的响应式对象可以用ref也可以用reactive</li><li>层级深的响应式对象用reactive</li></ul><h3 id="toRefs和toRef"><a href="#toRefs和toRef" class="headerlink" title="toRefs和toRef"></a>toRefs和toRef</h3><p>作用：将一个响应式对象的属性转换为ref对象</p><p>区别：toRefs可以批量转换多个属性，toRef单个</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, toRefs, toRef &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">let</span> person = reactive(&#123;</span><br><span class="line">  name: <span class="string">&#x27;susan&#x27;</span>,</span><br><span class="line">  age: <span class="number">23</span>,</span><br><span class="line">  gender: <span class="string">&#x27;woman&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 通过toRefs将person对象中的n个属性批量取出，且依然保持响应式的能力</span></span><br><span class="line"><span class="keyword">let</span> &#123;name, age&#125; = toRefs(person)</span><br><span class="line"><span class="comment">// 通过toRef将person对象中的gender属性取出，且依然保持响应式的能力</span></span><br><span class="line"><span class="keyword">let</span> gender = toRef(person, <span class="string">&#x27;gender&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="computed计算属性"><a href="#computed计算属性" class="headerlink" title="computed计算属性"></a>computed计算属性</h3><p>根据已有数据计算出新数据</p><p>只读计算属性、可修改计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ref, computed&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">let</span> firstName = ref(<span class="string">&#x27;zhang&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> lastName = ref(<span class="string">&#x27;san&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> readonlyFullName = computed(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName.value + <span class="string">&#x27;-&#x27;</span> + lastName.value</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> writableFullName = computed(&#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName.value + <span class="string">&#x27;-&#x27;</span> + lastName.value</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;value has been updated&#x27;</span>, value)</span><br><span class="line">    firstName.value = value.split(<span class="string">&#x27;-&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">    lastName.value = value.split(<span class="string">&#x27;-&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeFullName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  fullName.value = <span class="string">&#x27;li-si&#x27;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="watch监听数据"><a href="#watch监听数据" class="headerlink" title="watch监听数据"></a>watch监听数据</h3><p>第一个参数：侦听源</p><p>第二个参数：数据变化回调函数</p><p>第三个参数：配置项：deep,immediate…</p><p>侦听源：</p><ul><li>函数返回一个值（getter函数）</li><li>ref对象</li><li>响应式对象（reactive）</li><li>以上组合的数组</li></ul><p>当侦听ref对象或reactive对象时，newValue和oldValue相等，因为对象的地址一样，除非响应式连接丢失</p><p>当侦听源是响应式对象(reactive定义)时，侦听器会自动启用深层模式且不可关闭</p><p>如果侦听对象的某个属性，其值为基本类型，必须使用函数返回值形式：newValue和oldValue不相等</p><p>如果其值为对象类型，可直接使用<code>watch(obj.b, ()=&gt;&#123;&#125;,&#123;deep:true&#125;)</code>也可以使用函数式<code>watch(()=&gt;obj.b,()=&gt;&#123;&#125;)</code></p><p>watch也可监听多个源：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch([<span class="function">()=&gt;</span>person.name,person.car],<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;person.car变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">  &#125;,&#123;<span class="attr">deep</span>:<span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h3><p>作用：立即运行一个函数，响应式的追踪其依赖，并在依赖变化时执行函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当高度大于等于180时，取消监听</span></span><br><span class="line"><span class="keyword">const</span> stopWatch = watchEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (height &gt;= <span class="number">180</span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    stopWatch()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>和watch的对比：</p><ul><li>都能监听数据的响应式变化</li><li>watch需要明确指出数据源</li><li>watchEffect不用明确指出数据源，根据函数中用到哪些属性就监听哪些数据</li></ul><h3 id="标签的ref属性"><a href="#标签的ref属性" class="headerlink" title="标签的ref属性"></a>标签的ref属性</h3><p>用于注册模版的引用</p><ul><li>用在普通元素标签上获取的DOM节点</li><li>用在组件标签上获取组件的实例对象</li></ul><p>使用了 <code>&lt;script setup&gt;</code> 的组件是默认私有的：一个父组件无法访问到一个使用了 <code>&lt;script setup&gt;</code> 的子组件中的任何东西，除非子组件在其中通过 defineExpose 宏显式暴露</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Child.vue</span></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> b = ref(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 像 defineExpose 这样的编译器宏不需要导入</span></span><br><span class="line">defineExpose(&#123;</span><br><span class="line">  a,</span><br><span class="line">  b</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="comment">// Parent.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Child ref=<span class="string">&#x27;c1&#x27;</span>/&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> c1 = ref()</span><br><span class="line">cl.value.a <span class="comment">// 1</span></span><br><span class="line">cl.value.b <span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 如果子组件没有显示暴露则a, b不可访问</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="props属性"><a href="#props属性" class="headerlink" title="props属性"></a>props属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script lang&#x3D;&quot;ts&quot; setup name&#x3D;&quot;Person&quot;&gt;</span><br><span class="line">import &#123;defineProps&#125; from &#39;vue&#39;</span><br><span class="line">import &#123;type PersonInter&#125; from &#39;@&#x2F;types&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第一种写法：仅接收</span><br><span class="line">&#x2F;&#x2F; const props &#x3D; defineProps([&#39;list&#39;])</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第二种写法：接收+限制类型</span><br><span class="line">&#x2F;&#x2F; defineProps&lt;&#123;list:Persons&#125;&gt;()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第三种写法：接收+限制类型+指定默认值+限制必要性</span><br><span class="line">let props &#x3D; withDefaults(defineProps&lt;&#123;list?:Persons&#125;&gt;(),&#123;</span><br><span class="line">  list:()&#x3D;&gt;[&#123;id:&#39;asdasg01&#39;,name:&#39;小猪佩奇&#39;,age:18&#125;]</span><br><span class="line">&#125;)</span><br><span class="line">console.log(props)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>分为四个阶段：创建、挂载、更新、销毁</p><p>vue3生命周期：</p><p>创建阶段：setup</p><p>挂载阶段：onBeforeMount、onMounted</p><p>更新阶段：onBeforeUpdate、onUpdated</p><p>销毁阶段：onBeforeUnmount、onUnmounted</p><img src="https://cn.vuejs.org/assets/lifecycle_zh-CN.FtDDVyNA.png" alt="vue3生命周期1" style="zoom:50%;" /><p>vue2生命周期：</p><p>创建阶段：beforeCreate、created</p><p>挂载阶段：beforeMount、mounted</p><p>更新阶段：beforeUpdate、updated</p><p>销毁阶段：beforeDetroy、destroyed</p><p><img src="/ZJY.github.io/images/lifestycle.png" alt="vue2生命周期"></p><h3 id="key的作用"><a href="#key的作用" class="headerlink" title="key的作用"></a>key的作用</h3><p>特殊的 <code>key</code> attribute 被作为 Vue 的虚拟 DOM 算法的提示，以保持对节点身份的持续跟踪。这样 Vue 就可以知道何时能够重用和修补现有节点，以及何时需要对它们重新排序或重新创建。</p><h2 id="vue3非兼容性改变"><a href="#vue3非兼容性改变" class="headerlink" title="vue3非兼容性改变"></a>vue3非兼容性改变</h2><h3 id="全局API"><a href="#全局API" class="headerlink" title="全局API"></a>全局API</h3><ul><li><p>全局API更改为使用应用程序实例</p><table><thead><tr><th align="center">2.x全局API</th><th align="center">3.x实例API</th></tr></thead><tbody><tr><td align="center">Vue.component</td><td align="center">app.component</td></tr><tr><td align="center">Vue.directive</td><td align="center">app.directive</td></tr><tr><td align="center">Vue.config</td><td align="center">app.config</td></tr><tr><td align="center">Vue.mixin</td><td align="center">app.mixin</td></tr><tr><td align="center">Vue.use</td><td align="center">app.use</td></tr><tr><td align="center">Vue.prototype</td><td align="center">app.config.globalProperties</td></tr></tbody></table></li><li><p>全局和内部API都已经经过重构，现已支持TreeShaking（摇树优化）</p></li></ul><h3 id="模版指令"><a href="#模版指令" class="headerlink" title="模版指令"></a>模版指令</h3><ul><li><p>1、v-model在组件上使用已经重新设计，替换掉v-bind.sync</p><ul><li><p>用于自定义组件时，默认的prop属性和事件名已更改：</p><ul><li>prop：value-&gt;modelValue</li><li>event: input-&gt;update:modelValue</li></ul></li><li><p>v-bind的sync修饰符和组件的model属性已移除</p></li><li><p>新增：组件上支持绑定多个v-model</p></li><li><p>新增：v-model修饰符可自定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;ChildComponent v-model&#x3D;&quot;pageTitle&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-+ 是以下的简写: --&gt;</span><br><span class="line"></span><br><span class="line">&lt;ChildComponent</span><br><span class="line">  :modelValue&#x3D;&quot;pageTitle&quot;</span><br><span class="line">  @update:modelValue&#x3D;&quot;pageTitle &#x3D; $event&quot;</span><br><span class="line">&#x2F;&gt;</span><br><span class="line"> &lt;!-+ child --&gt;</span><br><span class="line">defineProps: [&#39;modelValue&#39;]</span><br><span class="line"></span><br><span class="line"> &lt;!-+ 绑定多个值: --&gt;</span><br><span class="line">&lt;ChildComponent v-model:title&#x3D;&quot;pageTitle&quot; v-model:content&#x3D;&quot;pageContent&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-+ 是以下的简写： --&gt;</span><br><span class="line"></span><br><span class="line">&lt;ChildComponent</span><br><span class="line">  :title&#x3D;&quot;pageTitle&quot;</span><br><span class="line">  @update:title&#x3D;&quot;pageTitle &#x3D; $event&quot;</span><br><span class="line">  :content&#x3D;&quot;pageContent&quot;</span><br><span class="line">  @update:content&#x3D;&quot;pageContent &#x3D; $event&quot;</span><br><span class="line">&#x2F;&gt;</span><br><span class="line"> &lt;!-+ child --&gt;</span><br><span class="line">defineProps: [&#39;title&#39;,&#39;pageContent&#39;]</span><br></pre></td></tr></table></figure></li></ul></li><li><p>2、在<code>&lt;template v-for&gt;</code>和v-if等分支使用key发生了变化</p><ul><li>新增：在v-if/v-else/v-else-if等分支可以不再使用key，key现在是自动生成的，如果要使用key，必须保证各分支key是唯一的</li><li>在<code>&lt;template v-for&gt;</code>上key不再添加到子组件，直接添加到template上</li></ul></li><li><p><code>v-if</code>和<code>v-for</code>用在同个元素身上优先级发生了变化</p><ul><li>2.x中<code>v-if</code>和<code>v-for</code>作用在同一个元素，<code>v-for</code>优先作用</li><li>3.x中<code>v-if</code>和<code>v-for</code>作用在同一个元素，<code>v-if</code>优先作用</li></ul></li><li><p><code>v-bind=&quot;object&quot;</code>现在是顺序敏感的</p><ul><li><p><code>v-bind=&quot;object&quot;</code>的绑定顺序影响渲染结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">2.x:独立 attribute 覆盖 object 中定义的内容</span><br><span class="line">&lt;!-+ 模板 --&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;red&quot; v-bind&#x3D;&quot;&#123; id: &#39;blue&#39; &#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;!-+ 结果 --&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;red&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">3.x: 绑定顺序影响渲染结果</span><br><span class="line">&lt;!-+ 模板 --&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;red&quot; v-bind&#x3D;&quot;&#123; id: &#39;blue&#39; &#125;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;!-+ 结果 --&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;blue&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-+ 模板 --&gt;</span><br><span class="line">&lt;div v-bind&#x3D;&quot;&#123; id: &#39;blue&#39; &#125;&quot; id&#x3D;&quot;red&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;!-+ 结果 --&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;red&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li><li><p>v-on:event.native`事件修饰符移除</p><ul><li><code>v-on</code> 的 <code>.native</code> 修饰符已被移除。同时，<a href="https://v3-migration.vuejs.org/zh/breaking-changes/emits-option">新增的 <code>emits</code> 选项</a>允许子组件定义真正会被触发的事件。</li></ul></li></ul><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><ul><li>函数式组件只能通过纯函数创建<ul><li>函数式组件应用场景：（1）函数式组件比有状态组件初始化快得多（2）可以返回多个根组件</li><li>变化：<ul><li>3.x中有状态组件性能提升和函数式组件差距几乎不计，同时支持返回多个根节点</li><li>函数式组件只能接收props和context（attrs、slots、emit）的普通函数创建</li><li>去掉单文件SFC中的template标签的functional属性</li><li>去掉函数创建组件的functional:true选项</li></ul></li></ul></li><li>单文件组件SFC的template标签的functional属性和函数创建的组件的functional:true选项已移除</li><li>异步组件只能通过defineAsyncComponent方法进行创建</li><li>组件事件通过emits选项声明，定义子组件向父组件触发的事件</li></ul><h3 id="渲染函数"><a href="#渲染函数" class="headerlink" title="渲染函数"></a>渲染函数</h3><ul><li>渲染函数API已更改<ul><li><code>h</code>函数需要全局导入，不作为渲染函数的参数render(h,…)</li><li>渲染函数的参数重写，有状态组件和函数式组件表现更加一致</li><li>VNode具有更扁平化的prop结构</li></ul></li><li>$scopeSlots属性已移除，所有插槽都通过$slots作为函数暴露</li><li>$listeners属性移除整合到$attrs中</li><li>$attrs现在包含class和style属性<ul><li>$attrs<code>现在包含了所有传递给组件的 attribute，包括</code>class<code>和</code>style,在vue2中，class和style不在$attrs，被应用到组件的根元素</li></ul></li></ul><h3 id="自定义元素"><a href="#自定义元素" class="headerlink" title="自定义元素"></a>自定义元素</h3><ul><li>自定义元素检测在模版编译时执行而不在运行时</li><li><code>is</code>属性限制只能在<code>component</code>标签使用</li></ul><h3 id="其他小改变"><a href="#其他小改变" class="headerlink" title="其他小改变"></a>其他小改变</h3><ul><li>beforeDestroy、destroy生命周期更改为onBeforeUnmount、onUnmouted</li><li>组件的props属性的default工厂函数不再支持访问this上下文</li><li>自定义指令的生命周期已更改为与组件生命周期保持一致，且移除binding.expression</li><li>监听组件的生命周期由<code>@hook:</code>改为<code>@vue:</code></li><li>data选项只能被声明为一个函数</li><li>mixin的data合并只合并浅层</li><li><code>Transition</code>的class命名已更改：v-enter-&gt;v-enter-from</li><li><code>TransitionGroup</code>不再默认渲染包裹元素</li><li>当侦听watch一个数组时，数组被替换才能监听到，数组变更监听不到需要开启deep</li><li>没有特殊指令的template元素被渲染成普通元素，并将渲染为原生的 <code>&lt;template&gt;</code> 元素，而不是渲染其内部内容</li><li>vue2:当挂载一个具有template的应用时，会替换挂载目标，vue3中被渲染为挂载目标的子元素，即innerHTML</li></ul><h3 id="被移除的API"><a href="#被移除的API" class="headerlink" title="被移除的API"></a>被移除的API</h3><ul><li>移除keyCode作为v-on修饰符的支持</li><li>移除filter过滤器</li><li>移除$on,$off,$once</li><li>移除Sdestroy实例方法</li><li>移除$children,建议使用模版引用ref</li><li>全局的set和delete方法以及实例方法$set,$delete</li></ul><p>———————————————-这里是分割线———————————————-</p><h2 id="vue2小记"><a href="#vue2小记" class="headerlink" title="vue2小记"></a>vue2小记</h2><p>vue是用于创建用户界面的渐进式框架。</p><p>2016，2.0发布</p><p>2020，3.0发布</p><h3 id="vue特点"><a href="#vue特点" class="headerlink" title="vue特点"></a>vue特点</h3><ul><li>采用<strong>组件化</strong>模式，提高代码复用率，且让代码更好维护</li><li>声明式编码，模板语法来声明式地将数据渲染进 DOM 的系统</li><li>使用虚拟dom+diff算法，尽量复用dom节点</li></ul><h3 id="模版语法"><a href="#模版语法" class="headerlink" title="模版语法"></a>模版语法</h3><ul><li>插值语法：，用于解析标签体内容</li><li>指令语法：v-bind, v-if…，用于解析标签属性，解析标签体内容，绑定事件</li></ul><p>V-bind：单向数据绑定，数据只能从data流向页面</p><p>V-model: 双向数据绑定-用于表单元素，数据不仅能从data流向页面，也能从页面流向data</p><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><ul><li>m：model模型，对应data中的数据</li><li>v：view试图负责用户界面，对应模板</li><li>vm：视图模型，vue实例对象，连接view和model之间的桥梁</li></ul><p>View——-viewmodel: dom listeners——&gt;model</p><p>view&lt;—–viewmodel: data binding———-model</p><p>View:Dom   viewmodel: vue.  Model: js object</p><p>viewmodel包含model的数据和view的逻辑，包括数据绑定、事件处理等。viewmodel将数据从model映射到view，并处理用户的交互；当model数据发生改变时，viewmodel更新view以反映变化。</p><p>mvvm的核心优势在于它提供了清晰的职责分离和关注点分离。Model只关心数据和业务逻辑；view只负责界面和布局；viewmodel负责将model的数据和view的显示结合起来，并处理用户的交互操作。</p><h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a>defineProperty</h3><ul><li>value</li><li>Configurable: 是否可配置的，可删除，默认false</li><li>writable：是否可修改，默认false</li><li>enumable：是否可枚举，默认false</li><li>get</li><li>set</li></ul><h3 id="vue中数据代理"><a href="#vue中数据代理" class="headerlink" title="vue中数据代理"></a>vue中数据代理</h3><p>1.vue中数据代理：vm._data.message,也可message</p><p>通过vm对象来代理data中的属性的操作-读/写</p><p>2.vue中数据代理的好处：</p><p>更加方便的操作data中的数据</p><p>3.基本原理：</p><p>通过Object.defineProperty()将data中所有属性添加到vm上</p><p>为每一个添加到vm上的属性都添加getter/setter</p><p>在getter/setter内部去操作（读/写）data中对应的属性</p><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>1.绑定监听：</p><ul><li>v-on:xxx=”fun”</li><li>@xxx=”fun”</li><li>@xxx=”func(params)”</li><li>默认形参event</li><li>隐含属性对象：$event</li></ul><p>2.事件修饰符</p><ul><li>prevent: @event.prevent阻止事件的默认行为event.preventDefault()</li><li>stop: @event.stop阻止事件冒泡行为：event.stopPropagation()</li><li>once: @event.once事件只出发一次</li><li>capture: @event.capture使用事件的捕获模式，由外到内，默认是冒泡模式，由内向外</li><li>self：只有event.target是元素自身时才触发</li><li>passive：立即执行事件的默认行为，无需等待事件回调函数执行完毕，注意：不是所有事件都先执行回调再执行默认行为，比如scroll先滚动再执行回调，但是wheel滚轮事件先执行回调再执行默认行为</li><li>Native:把当前元素当作原生标签使用</li></ul><p>3.按键修饰符：</p><p>按键码：</p><ul><li><code>.enter</code></li><li><code>.delete</code>(捕获“删除”和“退格”键)</li><li><code>.tab</code>特殊，必须配合keydown事件使用</li><li><code>.esc</code></li><li><code>.space</code></li><li><code>.up</code></li><li><code>.down</code></li><li><code>.left</code></li><li><code>.right</code></li></ul><p>系统修饰健：</p><ul><li><code>.ctrl</code></li><li><code>.alt</code></li><li><code>.shift</code></li><li><code>.meta</code></li></ul><p><code>.exact</code> 修饰符允许你控制由精确的系统修饰符组合触发的事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-+ 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span><br><span class="line">&lt;button v-on:click.ctrl&#x3D;&quot;onClick&quot;&gt;A&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-+ 有且只有 Ctrl 被按下的时候才触发 --&gt;</span><br><span class="line">&lt;button v-on:click.ctrl.exact&#x3D;&quot;onCtrlClick&quot;&gt;A&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-+ 没有任何系统修饰符被按下的时候才触发 --&gt;</span><br><span class="line">&lt;button v-on:click.exact&#x3D;&quot;onClick&quot;&gt;A&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure><p>你还可以通过全局 <code>config.keyCodes</code> 对象<a href="https://v2.cn.vuejs.org/v2/api/#keyCodes">自定义按键修饰符别名</a>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以使用 `v-on:keyup.f1`</span></span><br><span class="line">Vue.config.keyCodes.f1 = <span class="number">112</span></span><br></pre></td></tr></table></figure><p>4、表单修饰符</p><ul><li>.lazy 修饰符的作用是将<code>v-model</code>从实时监听的状态变为<code>change</code>状态。换句话说，它会使<code>v-model</code>在输入框失去焦点或者按下回车键时才更新数据.只适用于<code>v-model</code>指令</li><li>.trim 删除内容前后空格</li><li>.number 输入时数字或转为数字</li></ul><h3 id="scroll和wheel事件"><a href="#scroll和wheel事件" class="headerlink" title="scroll和wheel事件"></a>scroll和wheel事件</h3><p>scroll是页面滚动事件，滚动到底部后不会再触发</p><p>wheel是鼠标滚轮事件，滚动到底部后继续滚轮还会触发</p><h3 id="computed计算属性-1"><a href="#computed计算属性-1" class="headerlink" title="computed计算属性"></a>computed计算属性</h3><p><strong>计算属性是基于它们的响应式依赖进行缓存的</strong>。只在相关响应式依赖发生改变时它们才会重新求值。如果你不希望有缓存，请用方法来替代。</p><p>计算属性默认只有 getter，不过在需要时你也可以提供一个 setter：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> names = newValue.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">      <span class="built_in">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">      <span class="built_in">this</span>.lastName = names[names.length + <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在再运行 <code>vm.fullName = &#39;John Doe&#39;</code> 时，setter 会被调用，<code>vm.firstName</code> 和 <code>vm.lastName</code> 也会相应地被更新</p><h3 id="侦听器watch"><a href="#侦听器watch" class="headerlink" title="侦听器watch"></a>侦听器watch</h3><p>当需要在数据变化时执行异步或开销较大的操作时，watch更有用</p><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p><code>v-if</code> 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。</p><p>另一个用于根据条件展示元素的选项是 <code>v-show</code> 指令。不同的是带有 <code>v-show</code> 的元素始终会被渲染并保留在 DOM 中。<code>v-show</code> 只是简单地切换元素的 CSS property <code>display</code></p><h3 id="v-if-vs-v-show"><a href="#v-if-vs-v-show" class="headerlink" title="v-if vs v-show"></a>v-if vs v-show</h3><p><code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p><p><code>v-if</code> 也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p>相比之下，<code>v-show</code> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p><p>一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好。</p><p>当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-for</code> 具有比 <code>v-if</code> 更高的优先级.</p><h3 id="key的作用-1"><a href="#key的作用-1" class="headerlink" title="key的作用"></a><code>key</code>的作用</h3><p>key的特殊attribute主要用于vue的虚拟dom算法，在新旧节点比对时标识vnodes。如果不使用key，vue会最大限度的减少使用动态元素且尽可能的尝试就地修改/复用元素。而使用key，会根据key的变化重新排列元素，并移除key不存在的元素。</p><h3 id="深入响应式原理"><a href="#深入响应式原理" class="headerlink" title="深入响应式原理"></a>深入响应式原理</h3><h4 id="如何追踪变化？"><a href="#如何追踪变化？" class="headerlink" title="如何追踪变化？"></a>如何追踪变化？</h4><p>当把一个普通js对象传给data选项时，vue会遍历data中所有属性，并使用Object.defineProperty()方法将属性转换为getter/setter。</p><p>每个组件实例都对应一个watcher实例，它会把组件渲染过程中所接触过的所有属性记录为依赖。之后当依赖项的setter触发时，会通知watcher实例，从而使它关联的组件重新渲染。</p><p><img src="/ZJY.github.io/images/image-20240121173248736.png" alt="image"></p><h4 id="检测变化的注意事项"><a href="#检测变化的注意事项" class="headerlink" title="检测变化的注意事项"></a>检测变化的注意事项</h4><p>对于对象：无法监听到对象属性的添加/删除，可使用Vue.set()/delete()或者实例的vm.$set()/$delete</p><p>对于数组：1.无法监听到通过数组下标修改值，可使用set或splice方法解决； 2.无法监听到数组长度变化：arr.length = 10,可使用splice方法解决；</p><p>Vue.set/delete,注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象：即不能往vm或者vm._data中添加/删除属性</p><h4 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h4><p>Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：</p><ul><li><code>push()</code></li><li><code>pop()</code></li><li><code>shift()</code></li><li><code>unshift()</code></li><li><code>splice()</code></li><li><code>sort()</code></li><li><code>reverse()</code></li></ul><h4 id="异步更新队列"><a href="#异步更新队列" class="headerlink" title="异步更新队列"></a>异步更新队列</h4><p>vue在更新dom时是异步的。</p><p>当侦听到数据变化时，会开启一个队列，缓冲同一个事件循环队列中所有数据变化。每个组件实例都对应一个watcher实例。当同一个watcher实例被多次触发时，只会推入队列一次。组件数据变更时，vue会在下一次事件循环“tick”中更新组件。</p><p>vue在异步队列中尝试使用原生的<code>Promise.then</code>、<code>MutationObserver</code>、<code>setImmdiate</code>,如果执行环境不支持，则会采用 <code>setTimeout(fn, 0)</code> 代替。</p><h3 id="内置指令"><a href="#内置指令" class="headerlink" title="内置指令"></a>内置指令</h3><p>v-text: 更新元素的textContent</p><p>v-html: 更新元素的innerHTML</p><p>v-if：条件为true，才会渲染到页面</p><p>v-else：分支</p><p>v-show：不管条件是否为真，都渲染到页面，通过控制display属性控制显示/隐藏</p><p>v-for：遍历对象/数组</p><p>v-on：绑定事件监听，简写@</p><p>v-bind：绑定解析表达式。可以简写为：</p><p>v-model：双向数据绑定</p><p>v-clock：防止闪现，避免网速慢导致页面呈现未经vue编译的页面<code>&lt;h&gt;&#123;&#123; xx &#125;&#125;&lt;/h&gt;</code>，配合[v-cloak]{display:none}使用</p><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>全局</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简写时代表 bind 和 update 时触发相同行为</span></span><br><span class="line">Vue.directive(<span class="string">&#x27;my-dir&#x27;</span>, <span class="function"><span class="title">funtion</span>(<span class="params">el, binding</span>)</span> &#123;</span><br><span class="line">              el.innerHTML = binding.value.toUpperCase()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>局部指令：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  ...</span><br><span class="line">  directives: &#123;</span><br><span class="line">    <span class="string">&#x27;my-dir&#x27;</span>: &#123;</span><br><span class="line">      <span class="function"><span class="title">bind</span>(<span class="params">el, binding</span>)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">inserted</span>(<span class="params">el, binding</span>)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">  &lt;h v-my-dir=<span class="string">&#x27;xxx&#x27;</span>&gt;&lt;/h&gt;</span><br></pre></td></tr></table></figure><p>指令何时被调用？</p><p>1.指令与元素第一次绑定时（bind）</p><p>2.模版被重新解析时（update）</p><p>重要的指令生命周期：</p><p>bind(el, binding, vnode, oldNode): 指令与元素第一次绑定时</p><p>Inserted(el, binding, vnode, oldNode): 被绑定元素插入父节点时调用</p><p>Update(el, binding, vnode, oldNode): 指令所在模版被重新解析时</p><h3 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h3><p><img src="/ZJY.github.io/" alt="https://v2.cn.vuejs.org/images/lifecycle.png"></p><ul><li><p>new Vue()</p></li><li><p>Init event &amp; lifecycle:初始化生命周期、事件</p></li><li><p>beforeCreate：data和methods不可访问</p></li><li><p>初始化：数据代理、数据监测</p></li><li><p>created：可访问data中数据、methods方法</p></li><li><p>vue开始编译模版，生成虚拟dom（内存中）</p></li><li><p>beforeMount：页面呈现未经vue编译的dom（<code>&lt;h&gt;&#123;&#123; xx &#125;&#125;&lt;/h&gt;</code>），dom不可操作</p></li><li><p>将内存中虚拟dom生成真实dom并插入到页面</p></li><li><p>mounted：页面呈现经过编译的dom，可操作dom</p></li></ul><p>数据变化</p><ul><li><p>beforeUpate：数据已更新但页面还是旧的</p></li><li><p>生成新的虚拟dom与旧的虚拟节点比对patch</p></li><li><p>Updated：数据和页面保持同步</p></li><li><p>调用vm.$destroy方法</p></li><li><p>beforeDestroy：此时data、methods、指令还可用，但操作数据不再更新</p></li><li><p>移除watchers、子组件、和事件监听（移除自定义事件，原生事件保留）</p></li><li><p>destroyed：组件实例销毁</p></li></ul><h3 id="组件化编程"><a href="#组件化编程" class="headerlink" title="组件化编程"></a>组件化编程</h3><p>模块：</p><p>向外提供特定功能的js程序，一般就是一个js文件</p><p>作用：复用js，简化js的编写，提高js运行效率</p><p>组件：</p><p>用来实现特定功能的代码集合（html、css、js、images）</p><p>作用：复用编码，简化项目编码，提高运行效率</p><p>模块化：</p><p>当应用中的js都以模块来编写这个应用就是一个模块化的应用。</p><p>组件化：</p><p>当应用中的功能都是多组件的方式来编写这个应用就是一个组件化的应用</p><h3 id="vue的版本"><a href="#vue的版本" class="headerlink" title="vue的版本"></a>vue的版本</h3><ul><li>vue.js完整版的版本。包含：核心功能+模版解析器</li><li>vue.runtime.js运行时的版本，包含：核心功能</li></ul><p>单文件组件引入的是运行时的版本，因为运行时版本没有模版解析器，所以不能使用template选项，需要使用render函数接收到的createElement函数来指定渲染内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line"> render: <span class="function"><span class="params">h</span> =&gt;</span>h(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span></span><br><span class="line"> template: <span class="string">`&lt;app&gt;&lt;/app&gt;`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以及使用单文件组件需要vue-template-complier包来解析模版（vue2.x）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  ...,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  render: <span class="function"><span class="params">createElement</span> =&gt;</span> createElement(App),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>将 <code>h</code> 作为 <code>createElement</code> 的别名是 Vue 生态系统中的一个通用惯例，实际上也是 JSX 所要求的。</p><p><code>createElement</code> 到底返回的不是一个真实的dom，是节点描述信息，包括及其子节点的描述信息。我们把这样的节点描述为“虚拟节点 (virtual node)”，也常简写它为“<strong>VNode</strong>”</p><h3 id="混入mixin"><a href="#混入mixin" class="headerlink" title="混入mixin"></a>混入mixin</h3><p>通过混入来分发组件中的可复用功能。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。</p><p>选项合并：</p><ul><li>数据对象data在内部会进行递归合并，发生冲突时以组件数据优先</li><li>同名钩子函数合并为一个数组，并且混入对象钩子函数在组件自身钩子函数之前调用</li><li>值为对象的选项，比如methods、components、directives，将会合并为一个对象，当键名冲突时，使用组件对象的键值对</li></ul><p>注意：<code>Vue.extend()</code> 也使用同样的策略进行合并。</p><p>混入也可以进行全局注册。使用时格外小心！一旦使用全局混入，它将影响<strong>每一个</strong>之后创建的 Vue 实例</p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种：</p><ul><li>添加全局属性或方法</li><li>添加全局的资源：指令、过滤器、过渡等</li><li>通过全局混入添加一些组件选项，比如vue-router</li><li>添加vue实例方法通过把他们添加到Vue.prototype上</li><li>一个库，提供自己的api，同时具有以上一个多个功能，如vue-router</li></ul><h4 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h4><p>通过Vue.use(xxx), 在new Vue()之前调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用 `MyPlugin.install(Vue)`</span></span><br><span class="line">Vue.use(MyPlugin)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...组件选项</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>开发插件通过install方法，传入Vue构造函数和可选options选项对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MyPlugin.install = <span class="function"><span class="keyword">function</span>(<span class="params">Vue, options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 添加全局方法</span></span><br><span class="line">  Vue.myGlobalMethods = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加全局资源</span></span><br><span class="line">   Vue.directive(<span class="string">&#x27;my-directive&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">el, binding</span>) </span>&#123;</span><br><span class="line">     ...</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="comment">// 添加全局混入</span></span><br><span class="line">   Vue.mixin(&#123;</span><br><span class="line">     <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       ...</span><br><span class="line">     &#125;</span><br><span class="line">      ...</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="comment">// 添加实例方法</span></span><br><span class="line">   Vue.prototype.$myMthods = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h3><p>无状态 (没有<a href="https://v2.cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E6%95%B0%E6%8D%AE">响应式数据</a>)，也没有实例 (没有 <code>this</code> 上下文)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;my-component&#x27;</span>, &#123;</span><br><span class="line">  functional: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// Props 是可选的</span></span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 为了弥补缺少的实例</span></span><br><span class="line">  <span class="comment">// 提供第二个参数作为上下文</span></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement, context</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 单文件组件-函数式组件</span></span><br><span class="line">&lt;template functional&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h3 id="配置webpack"><a href="#配置webpack" class="headerlink" title="配置webpack"></a>配置webpack</h3><p>Vue 脚手架隐藏了所有 webpack 相关的配置，若想查看具体的 webpakc 配置， 请执行:vue inspect &gt; output.js</p><p>如果想更改webpack配置，根目录下新建vue.config.js或者package.json中配置”vue”选项</p><h3 id="组件传参-组件通信"><a href="#组件传参-组件通信" class="headerlink" title="组件传参/组件通信"></a>组件传参/组件通信</h3><p>1.父子传参，props传递属性和方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Child :name&#x3D;&quot;name&quot; :getNameFn&#x3D;&quot;getNameFn&quot; &#x2F;&gt;</span><br><span class="line">getNameFn() &#123;...&#125;</span><br><span class="line">&#x2F;&#x2F; child.vue</span><br><span class="line">props: [&#39;name&#39;, &#39;getNameFn&#39;]</span><br><span class="line">&#x2F;&#x2F; 调用父组件传递方法来向父组件传参</span><br><span class="line">this.getNameFn(params)</span><br></pre></td></tr></table></figure><p>2.父子传参，自定义事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Child :name&#x3D;&quot;name&quot; @getNameFn&#x3D;&quot;getNameFn&quot; &#x2F;&gt;</span><br><span class="line">getNameFn() &#123;...&#125;</span><br><span class="line">&#x2F;&#x2F; child.vue</span><br><span class="line">props: [&#39;name&#39;]</span><br><span class="line">&#x2F;&#x2F; 调用子组件自定义方法传参</span><br><span class="line">this.$emit(&#39;getNameFn&#39;, params)</span><br></pre></td></tr></table></figure><p>3.父子传参，父组件监听子组件触发事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;Child :name&#x3D;&quot;name&quot; ref&#x3D;&quot;child&quot; &#x2F;&gt;</span><br><span class="line">mounted() &#123;</span><br><span class="line"> this.$refs.child.$on(&#39;getNameFn&#39;, cb)</span><br><span class="line"> &#x2F;&#x2F; 注意回调函数this指向</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; child.vue</span><br><span class="line">props: [&#39;name&#39;]</span><br><span class="line">&#x2F;&#x2F; 调用子组件自定义方法传参</span><br><span class="line">this.$emit(&#39;getNameFn&#39;, params)</span><br></pre></td></tr></table></figure><p>4.父子传参，v-bind.sync,子组件修改props传参同步给父组件（双向绑定）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;Child :name.sync&#x3D;&quot;name&quot;&#x2F;&gt;</span><br><span class="line">&#x2F;&#x2F; 等价于</span><br><span class="line">&lt;Child v-bind:name.sync&#x3D;&quot;name&quot; &#x2F;&gt;</span><br><span class="line">&#x2F;&#x2F; 等价于</span><br><span class="line">&lt;Child :name&#x3D;&quot;name&quot; @update:name&#x3D;&quot;name &#x3D; $event&quot;&#x2F;&gt;</span><br><span class="line">&#x2F;&#x2F; child</span><br><span class="line">props: [&#39;name&#39;]</span><br><span class="line">&#x2F;&#x2F; 子组件修改props传参同步给父组件</span><br><span class="line">this.$emit(&#39;update:name&#39;, name)</span><br></pre></td></tr></table></figure><p>5.父子传参，自定义组件的v-model：</p><p>一个组件上的 <code>v-model</code> 默认会利用名为 <code>value</code> 的 prop 和名为 <code>input</code> 的事件，但是像单选框、复选框等类型的输入控件需要配置model选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#39;base-checkbox&#39;, &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: &#39;checked&#39;,</span><br><span class="line">    event: &#39;change&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    checked: Boolean</span><br><span class="line">  &#125;,</span><br><span class="line">  template: &#96;</span><br><span class="line">    &lt;input</span><br><span class="line">      type&#x3D;&quot;checkbox&quot;</span><br><span class="line">      v-bind:checked&#x3D;&quot;checked&quot;</span><br><span class="line">      v-on:change&#x3D;&quot;$emit(&#39;change&#39;, $event.target.checked)&quot;</span><br><span class="line">    &gt;</span><br><span class="line">  &#96;</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">&lt;base-checkbox v-model&#x3D;&quot;lovingVue&quot;&gt;&lt;&#x2F;base-checkbox&gt;</span><br></pre></td></tr></table></figure><p>这里的 <code>lovingVue</code> 的值将会传入这个名为 <code>checked</code> 的 prop。同时当 <code>&lt;base-checkbox&gt;</code> 触发一个 <code>change</code> 事件并附带一个新的值的时候，这个 <code>lovingVue</code> 的 property 将会被更新。</p><p>6.跨组件通信，全局事件总线$bus:</p><p>$on(eventName, listener): 绑定自定义事件监听</p><p>$emit(eventName, data): 分发自定义事件</p><p>$off(eventName): 解绑自定义事件</p><p>$once(eventName, listener): 绑定自定义事件只触发一次</p><p>所有组件实例对象的原型对象指向vue的原型对象</p><p>   <code>VueComponent.prototype.__proto__ === Vue.protype</code></p><p>所有vc组件对象都能访问vue原型对象上的属性和方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 尽量早的执行挂载全局事件总线对象的操作</span></span><br><span class="line">    Vue.prototype.$bus = <span class="built_in">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 绑定事件</span></span><br><span class="line"><span class="built_in">this</span>.$bus.$on(<span class="string">&#x27;eventName&#x27;</span>, cb)</span><br><span class="line"><span class="comment">// 分发事件</span></span><br><span class="line"><span class="built_in">this</span>.$bus.$emit(<span class="string">&#x27;eventName&#x27;</span>, params)</span><br><span class="line"><span class="comment">// 解绑事件</span></span><br><span class="line"><span class="built_in">this</span>.$bus.$off(<span class="string">&#x27;eventName&#x27;</span>)</span><br></pre></td></tr></table></figure><p>7.跨组件通信，消息订阅与发布：PubSubJS</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装 npm install -S pubsub-js</span></span><br><span class="line"><span class="keyword">import</span> pubsub <span class="keyword">from</span> <span class="string">&#x27;pubsub-js&#x27;</span></span><br><span class="line"><span class="comment">// 订阅</span></span><br><span class="line">pubsub.subscribe(<span class="string">&#x27;eventName&#x27;</span>, cb)</span><br><span class="line"><span class="comment">// 发布</span></span><br><span class="line">pubsub.publish(<span class="string">&#x27;eventName&#x27;</span>, params)</span><br><span class="line"><span class="comment">// 取消订阅</span></span><br><span class="line">pubsub.unsubscribe(<span class="string">&#x27;eventName&#x27;</span>)</span><br></pre></td></tr></table></figure><p>8.祖孙组件通信，provide/inject</p><p>9.祖孙组件通信，$attrs,$listeners</p><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><ul><li>默认插槽default</li><li>具名插槽</li><li>作用域插槽</li></ul><p>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</p><p>默认插槽default：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 默认插槽-一个不带 name 的 &lt;slot&gt; 出口会带有隐含的名字“default”。</span><br><span class="line">&lt;slot &#x2F;&gt;</span><br><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line"> &lt;my-com&gt;</span><br><span class="line">   &lt;div&gt;</span><br><span class="line">     this is an default slot</span><br><span class="line">   &lt;&#x2F;div&gt;</span><br><span class="line"> &lt;&#x2F;my-com&gt;</span><br></pre></td></tr></table></figure><p> 具名插槽:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;slot name&#x3D;&quot;header&quot;&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">  &lt;&#x2F;header&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;slot&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">  &lt;&#x2F;main&gt;</span><br><span class="line">  &lt;footer&gt;</span><br><span class="line">    &lt;slot name&#x3D;&quot;footer&quot;&gt;&lt;&#x2F;slot&gt;</span><br><span class="line">  &lt;&#x2F;footer&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">  &#x2F;&#x2F; 使用</span><br><span class="line"> &lt;base-layout&gt;</span><br><span class="line">  &lt;template v-slot:header&gt;</span><br><span class="line">    &lt;h1&gt;Here might be a page title&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template v-slot:default&gt;</span><br><span class="line">    &lt;p&gt;A paragraph for the main content.&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;And another one.&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template v-slot:footer&gt;</span><br><span class="line">    &lt;p&gt;Here&#39;s some contact info&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;template&gt;</span><br><span class="line">&lt;&#x2F;base-layout&gt;</span><br><span class="line">&#x2F;&#x2F; 注意 v-slot 只能添加在 &lt;template&gt; 上 </span><br><span class="line">&lt;div slot&#x3D;&quot;footer&quot;&gt;</span><br><span class="line">  &lt;p&gt;Here&#39;s some contact info&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>作用域插槽:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> &lt;span&gt;</span><br><span class="line">  &lt;slot v-bind:user&#x3D;&quot;user&quot;&gt;</span><br><span class="line">    &#123;&#123; user.lastName &#125;&#125;</span><br><span class="line">  &lt;&#x2F;slot&gt;</span><br><span class="line">&lt;&#x2F;span&gt;</span><br><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">&lt;current-user&gt;</span><br><span class="line">  &lt;template v-slot:default&#x3D;&quot;slotProps&quot;&gt;</span><br><span class="line">    &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">  &lt;&#x2F;template&gt;</span><br><span class="line">&lt;&#x2F;current-user&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 解构插槽</span><br><span class="line">&lt;current-user&gt;</span><br><span class="line">  &lt;template v-slot&#x3D;&quot;&#123;user&#125;&quot;&gt;</span><br><span class="line">    &#123;&#123; user.firstName &#125;&#125;</span><br><span class="line">  &lt;&#x2F;template&gt;</span><br><span class="line">&lt;&#x2F;current-user&gt;</span><br></pre></td></tr></table></figure><h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><p>是专门为vuejs应用程序开发的状态管理模式。</p><p>适用于：</p><ul><li>多个组件依赖于同一个状态</li><li>多个组件的行为变更同一个状态</li></ul><p>每个vuex应用的核心是store仓库。存储应用的状态。</p><ul><li><p>vuex的状态存储是响应式的</p></li><li><p>不能直接更改store中的状态，必须显式的提交comit mutation</p></li></ul><h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><ul><li>state： vuex管理的状态对象，唯一数据源；Vuex 的状态存储是响应式的</li><li>getters：从 store 中的 state 中派生出一些状态，包含返回数据的函数。Getter 接受 state 作为其第一个参数。</li><li>mutations：改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 **回调函数 (handler)**。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, n) &#123;</span><br><span class="line">    state.count += n</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.commit(<span class="string">&#x27;increment&#x27;</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//  在组件中使用</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapMutations([</span><br><span class="line">      <span class="string">&#x27;increment&#x27;</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.commit(&#x27;increment&#x27;)`</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// `mapMutations` 也支持载荷：</span></span><br><span class="line">      <span class="string">&#x27;incrementBy&#x27;</span> <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.commit(&#x27;incrementBy&#x27;, amount)`</span></span><br><span class="line">    ]),</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">      add: <span class="string">&#x27;increment&#x27;</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.commit(&#x27;increment&#x27;)`</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用常量替代 Mutation 事件类型</p><p>mutation必须是同步函数</p><ul><li>actions：类似于mutation，不同的是<ul><li>action提交的是mutation，而不是直接修改状态</li><li>action可以包含任意异步操作</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    incrementAsync (&#123; commit &#125;) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        commit(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 分发action</span></span><br><span class="line"><span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//  在组件中使用</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions([</span><br><span class="line">      <span class="string">&#x27;increment&#x27;</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.dispatch(&#x27;increment&#x27;)`</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// `mapActions` 也支持载荷：</span></span><br><span class="line">      <span class="string">&#x27;incrementBy&#x27;</span> <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch(&#x27;incrementBy&#x27;, amount)`</span></span><br><span class="line">    ]),</span><br><span class="line">    ...mapActions(&#123;</span><br><span class="line">      add: <span class="string">&#x27;increment&#x27;</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.dispatch(&#x27;increment&#x27;)`</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Module:模块</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: <span class="function">() =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  state: <span class="function">() =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a <span class="comment">// -&gt; moduleA 的状态</span></span><br><span class="line">store.state.b <span class="comment">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure><p><img src="/ZJY.github.io/images/vuex.png" alt="vuex"></p><h3 id="栈Stack和堆Heap的区别？"><a href="#栈Stack和堆Heap的区别？" class="headerlink" title="栈Stack和堆Heap的区别？"></a>栈Stack和堆Heap的区别？</h3><ul><li>存储方式：<ul><li>栈：线性数据结构，采用先进后出的原则。基本数据类型和引用数据类型的值存储在栈中</li><li>堆：用于动态分配内存的内存池，采用哈希表的数据结构。引用数据类型（数组、对象、函数）的实际值存储在堆中，栈中存储的是是该对象的引用。</li></ul></li><li>内存管理：<ul><li>栈：内存管理是自动的，通过栈指针的上移和下移来自动分配内存和释放内存。</li><li>堆：堆的内存需要程序员手动释放和分配。js中通过垃圾回收器来回收不再使用的对象的内存</li></ul></li><li>大小：<ul><li>栈：大小是固定的，在程序编译阶段就能确定</li><li>堆：大小是动态变化的，需要在运行阶段根据需求动态调整</li></ul></li><li>生命周期<ul><li>栈：具有短暂的生命周期，在函数或代码块执行完毕就释放内存</li><li>堆：具有较长的生命周期，需要手动释放，否则容易内存泄露</li></ul></li></ul><h3 id="js原型链"><a href="#js原型链" class="headerlink" title="js原型链"></a>js原型链</h3><p>所有对象都是通过new 函数创建的，包括let obj = {}</p><p>函数是通过new Function创建的对象</p><p>每个函数都有一个属性prototype,叫做原型，prototype也是个对象，所以也叫原型对象。</p><p>原型的作用：</p><ul><li>1、存放属性和方法共享给实例对象</li><li>2、在js中通过原型实现继承</li></ul><p>每个对象都有一个  <code>__proto__</code>  属性，指向它构造函数的原型对象。</p><p>原型链：</p><p>对象都有<code>__proto__</code>属性，指向他的构造函数的原型对象，原型对象也是原型，也有<code>__proto__</code>属性，指向它的构造函数的原型，这样一层一层形成的链式结构称为原型链，顶层为null。</p><p>prototype 原型对象：</p><ul><li>是函数的一个属性</li><li>是一个对象</li><li>创建函数后自动拥有的一个属性</li></ul><p><code>__proto__</code>隐式原型：</p><ul><li>对象的一个属性</li><li>实例的<code>__proto__</code>属性指向它构造函数的prototype</li></ul><p>constructor:</p><ul><li>对象的一个属性</li><li>指向创建该实例对象的构造函数</li><li>除了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object#null_%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1"><code>null</code> 原型对象</a>之外，任何对象都会在其 <code>[[Prototype]]</code> 上有一个 <code>constructor</code> 属性</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testFun</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> testFun()</span><br><span class="line">obj.__proto__ === testFun.prototype <span class="comment">// true</span></span><br><span class="line">testFun.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">obj.constructor === testFun</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">obj.__proto__ === testFun.prototype</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">obj.__proto__ === obj.constructor.prototype</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>对象有的属性：</p><ul><li><code>__proto__</code></li><li>constructor</li></ul><p>函数有的属性(也是对象)：</p><ul><li><code>__proto__</code>(作为对象)</li><li>constructor(作为对象)</li><li>prototype(作为函数)</li></ul><p>[[Prototype]]和<code>__proto__</code>:</p><p><code>__proto__</code> 属性是 <code>Object.prototype</code> 上一个简单的访问器属性，由 getter 和 setter 函数组成.</p><p><code>__proto__</code> 的 getter 函数暴露了一个对象内部的 <code>[[Prototype]]</code> 的值。对于使用对象字面量创建的对象，该值是 <code>Object.prototype</code>。对于使用数组字面量创建的对象，该值是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array"><code>Array.prototype</code></a>。对于函数，该值是 <code>Function.prototype</code>.</p><p><code>__proto__</code> 的 setter 允许修改一个对象的 <code>[[Prototype]]</code>。提供的值必须是一个对象或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/null"><code>null</code></a>。提供任何其他值都不会产生任何作用</p><h3 id="Ajax、xhr、fetch、axios、promise、jQuery的区别？"><a href="#Ajax、xhr、fetch、axios、promise、jQuery的区别？" class="headerlink" title="Ajax、xhr、fetch、axios、promise、jQuery的区别？"></a>Ajax、xhr、fetch、axios、promise、jQuery的区别？</h3><p>XHR（XMLHttpRequest）：XHR是一种用于发送HTTP请求和接收服务器响应的API，支持异步</p><p>Ajax：Ajax（Asynchronous JavaScript and XML）是一种基于XHR的技术。用于在不刷新页面的情况下实现异步数据交互。</p><p>fetch：是现代浏览器原生提供的API，用于进行网络请求。它返回Promise对象。</p><p>axios：第三方封装库，Axios是一个基于Promise的HTTP客户端，用于浏览器和Node.js</p><p>jQuery：JavaScript库，简化了DOM操作和事件处理，也包括Ajax方法。</p><p>promise：提供了更结构化的异步代码，使得回调地狱（callback hell）问题得以解决，提高了可读性。</p><p>———————————————-这里是分割线———————————————-</p><p>元素垂直水平居中：父元素设置display: flex;子元素设置margin:auto</p><p>padding和margin区别？padding作用于自身，margin作用于外部元素间距</p><p>vw和百分比？vw是可视窗口的width，百分比相对于包含块计算，元素的位置和尺寸由包含块决定，默认是最近祖先块元素的内容区域，width\top\bottom百分比值由包含块的width决定，height\left\right\margin\padding百分比值由包含块的height决定;</p><h3 id="内联元素和块级元素？"><a href="#内联元素和块级元素？" class="headerlink" title="内联元素和块级元素？"></a>内联元素和块级元素？</h3><ul><li>块级元素：block，在正常的流中块级元素前后另起一个新行，从上到下排列;可包含行内元素和其他块级元素；块级元素有：h1-h6, article, div, p, footer, table, audio, video, ul, dd, from, canvas等；可设置width, height, padding, margin值</li><li>内联元素：inline，不以新行开始，从左到右排列可包含数据和其他行内元素，行内元素有：b, big, i, small, tt, abbr, acronym, cite, code, dfn, em, kbd, strong, samp, var, a, bdo, br, img, map, object, q, script, span, sub, sup, button, input, label, select, textarea；可设置padding，margin-left/right值，不可设置width, height, margin-top/bottom</li></ul><p>如何让浏览器支持小于12px字体？缩放：transform: scale(0.5); transform-origin:left top;</p><h3 id="浅拷贝和深拷贝？"><a href="#浅拷贝和深拷贝？" class="headerlink" title="浅拷贝和深拷贝？"></a>浅拷贝和深拷贝？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">4</span></span><br><span class="line"><span class="keyword">let</span> b = a</span><br><span class="line">a = <span class="number">5</span></span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// 5 4</span></span><br><span class="line"><span class="comment">// 解构赋值：一维数组和对象是深拷贝，多维是浅拷贝</span></span><br><span class="line"><span class="keyword">let</span> arr = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line"><span class="keyword">let</span> arr1 = [...arr]</span><br><span class="line">arr1[<span class="number">0</span>].push(<span class="number">7</span>) <span class="comment">// 浅拷贝</span></span><br><span class="line"><span class="comment">// Object.assign(obj1, obj2) // 浅拷贝</span></span><br><span class="line"><span class="comment">// 深拷贝</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj)) <span class="comment">//不能处理undefined、函数、symbol、Date、NaN等值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归-深拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;object&#x27;</span> || value === <span class="literal">null</span>) <span class="keyword">return</span> value</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Array</span>.isArray(value) ? [] : &#123;&#125;</span><br><span class="line">  <span class="built_in">Object</span>.setPrototypeOf(obj, <span class="built_in">Object</span>.getPrototypeOf(value)) <span class="comment">// 原型统一</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="comment">// obj[key] = value[key] // 浅拷贝</span></span><br><span class="line">      obj[key] = deepClone(value[key])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="性能优化？"><a href="#性能优化？" class="headerlink" title="性能优化？"></a>性能优化？</h3><ul><li>加载：<ul><li>1、减少http请求（精灵图，文件合并）</li><li>2、减少文件大小（资源压缩，图片压缩、代码压缩）</li><li>3、CDN（第三方库，大文件，大图放第三方）</li><li>4、SSR服务端渲染、预渲染</li><li>5、懒加载</li><li>6、分包（小程序，加快主页加载速度）</li></ul></li><li>减少DOM操作，避免回流重绘，使用文档碎片</li></ul><h3 id="while循环快还是for循环快？"><a href="#while循环快还是for循环快？" class="headerlink" title="while循环快还是for循环快？"></a>while循环快还是for循环快？</h3><p>for循环比while循环执行速度快。这是因为for循环在内部执行代码块时自增计数器；而while循环需要手动进行边界检查和变量i的自增操作。</p><h3 id="css层叠规则？"><a href="#css层叠规则？" class="headerlink" title="css层叠规则？"></a>css层叠规则？</h3><ul><li>比较优先级</li><li>比较特殊性，权重，四位，前一位相同比较下一位：<ul><li>内联样式为1，否则为0</li><li>所属元素选择器id个数，一个为1，100个为100</li><li>所属元素选择器的类选择器+伪类选择器+属性选择器的个数</li><li>所属元素选择器的元素选择器+伪元素选择器的个数</li></ul></li><li>比较源次序，出现在代码中的次序，后面覆盖前面</li></ul><h3 id="页面上隐藏元素方法？"><a href="#页面上隐藏元素方法？" class="headerlink" title="页面上隐藏元素方法？"></a>页面上隐藏元素方法？</h3><ul><li>不占位<ul><li>给元素设置hidden属性</li><li>display: none;</li><li>width: 0;height: 0;transform: scale(0);但是有些元素设置border宽度会占据空间</li><li>width: 0;height: 0;overflow: hidden;但是有些元素设置border宽度会占据空间</li><li>position: absolute; left/margin-left: -100%;脱离文档流</li><li>position: absolute; z-index: -1;脱离文档流,后面元素覆盖该元素，如果后面元素小可能会覆盖不完全</li><li>font-size: 0;仅对文本内容有效</li></ul></li><li>占位<ul><li>opacity: 0;</li><li>filter: opacity(0);</li><li>visibility: hidden;</li></ul></li></ul><h3 id="元素水平垂直居中？"><a href="#元素水平垂直居中？" class="headerlink" title="元素水平垂直居中？"></a>元素水平垂直居中？</h3><ul><li>定位+margin: 已知被水平垂直居中元素宽高，父相对定位，子绝对定位+top:50%+left:50%+margin: -1/2w 0 0 -1/2h;</li><li>定位+transform:未知居中元素宽高，父相对定位，子绝对定位+top:50%+left:50%+transform: translate(-50%, -50%)</li><li>定位+margin:auto:未知居中元素宽高，父相对定位，子绝对定位+top/left/right/bottom:0+margin: auto;</li><li>flex: 父元素设置display:flex;aligin-items:center;justify-content:center;</li><li>Flex/grid+margin:auto:父元素display:flex/grid;子元素margin:auto;</li></ul><h3 id="Css元素选择器有哪些？"><a href="#Css元素选择器有哪些？" class="headerlink" title="Css元素选择器有哪些？"></a>Css元素选择器有哪些？</h3><ul><li>通配符选择器*</li><li>元素选择器，p, div</li><li>id选择器</li><li>类选择器</li><li>属性选择器: a[class=’test’]</li><li>伪类选择器：:before,:active</li><li>组合选择器：div + p,h1,h2</li></ul><p>css三大特性：继承、层叠、优先级</p><h3 id="css可以继承的属性？"><a href="#css可以继承的属性？" class="headerlink" title="css可以继承的属性？"></a>css可以继承的属性？</h3><ul><li>字体系列的属性：font-size,font-family,font-style,font-weight…</li><li>文本系列的属性：text-align,color,line-height,letter-spacing,word-spacing…</li><li>元素的可见性：visibility, opacity</li><li>表格布局的属性：border-spacing</li><li>列表的属性：list-style</li><li>光标的属性：cursor</li><li>…</li></ul><h3 id="css预处理器？"><a href="#css预处理器？" class="headerlink" title="css预处理器？"></a>css预处理器？</h3><p>css预处理器是一种语言为css添加一些编程的特性，可以在css中使用变量，函数等功能，使css更加直观简洁。</p><p>Sass,less,stylus三种预处理器都有:嵌套，颜色函数，混入，继承，运算符等功能。</p><h3 id="JS组成？"><a href="#JS组成？" class="headerlink" title="JS组成？"></a>JS组成？</h3><p>ECMAscript是国际通过的ecma-262标准化的脚本程序设计语言，js是ecmascript的一种实现</p><ul><li>浏览器中javascript组成：ECMAscript + BOM(浏览器对象模型) + DOM(文档对象模型)</li><li>nodejs中的javascript组成：ECMAscript + NPM（包管理系统）+ Native</li><li>小程序中的javascript组成：ECMAscript + 小程序框架 + 小程序API</li></ul><h3 id="js内置对象有哪些？"><a href="#js内置对象有哪些？" class="headerlink" title="js内置对象有哪些？"></a>js内置对象有哪些？</h3><p>String,Number,Boolean,Function,Date,Math,RegExp,Array,Object…</p><p>Math.abs(),sqrt(),min();String.concat(),slice(),split(),new Date().getFullYear()…</p><h3 id="操作数组的方法？"><a href="#操作数组的方法？" class="headerlink" title="操作数组的方法？"></a>操作数组的方法？</h3><ul><li>改变数组本身的方法：copyWithin() fill() push() pop() unshift() shift() sort() reverse() splice()</li><li>不改变数组本身的方法：concat() join() slice() indexOf() lastIndexOf() toString()…</li><li>迭代/遍历方法：遍历数组每个元素前每个回调函数执行一次，执行回调函数前先缓存数据长度。forEach() map() filter() some() every() reduce() reduceRight() entries() keys() values() find() findIndex()</li></ul><h3 id="js类型检查方法？"><a href="#js类型检查方法？" class="headerlink" title="js类型检查方法？"></a>js类型检查方法？</h3><ul><li>typeof: 可以检测基本数据类型，但不能判断对象，数组和null</li><li>instanceof：判断构造函数的prototype属性是否在实例对象的原型链上，可以判断引用数据类型，但不能判断基本数据类型；依赖于原型链，一旦原型链被修改结果并不准确</li><li>constructor：返回创建对象的构造函数的引用，可以判断number,string, boolean, object,function, array,但是constructor可以被修改结果也并不准确</li><li>Object.prototype.toString.call()返回表示对象的字符串，不依赖于原型链，是一个可靠的类型检查方法，但是对象的Symbol.toStringTag属性的值会改变toString返回字符串的结果。</li><li>Array.isArray()判断一个对象是否是数组</li></ul><h3 id="闭包的理解？"><a href="#闭包的理解？" class="headerlink" title="闭包的理解？"></a>闭包的理解？</h3><p>闭包是由函数以及声明该函数的词法环境组合而成。该环境包含创建闭包时作用域内任何局部变量。</p><p>闭包的特点：</p><p>1、函数嵌套函数 2、函数内部可以访问外部的参数和变量 3、参数和变量不会被垃圾回收机制回收</p><p>闭包是为了设计私有方法和变量。</p><p>优点：避免全局变量的污染</p><p>缺点：由于保留了作用域链，闭包常驻内存，加大内存消耗，使用不当容易造成内存泄露</p><p>解决方法：退出函数前，把不使用的局部变量删除</p><h3 id="事件委托？"><a href="#事件委托？" class="headerlink" title="事件委托？"></a>事件委托？</h3><p>又叫事件代理，基于事件冒泡的机制将事件监听添加到父元素上而不是给子元素添加。事件逐层冒泡到父元素被捕获。</p><p>事件经历三个阶段：</p><p>1、捕获阶段：window对象自上而下到目标对象传播的阶段</p><p>2、目标阶段：真正的目标对象正在处理事件的阶段</p><p>3、冒泡阶段：目标对象从下到上到window对象传播的阶段</p><p>addEventListener(‘eventName’, callback, true/false); 第三个参数，false默认为冒泡，true事件捕获，阻止冒泡，事件委托失效。</p><p>优点：</p><ul><li>减少内存占用，减少事件注册</li><li>新增子元素不需要再注册事件</li></ul><h3 id="基本数据类型和引用数据类型的区别？"><a href="#基本数据类型和引用数据类型的区别？" class="headerlink" title="基本数据类型和引用数据类型的区别？"></a>基本数据类型和引用数据类型的区别？</h3><p>基本数据类型：string, number, boolean, null, undefined, symbol, bigint,值保存在栈内存中</p><p>引用数据类型：object, function, array，对象的引用（地址）保存在栈内存中，真实的值保存在堆内存中</p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>每一个对象都有一个私有属性__proto__指向另一个名为原型prototype的对象。原型对象也有自己的原型，层层向上直到一个原型为null，null没有原型，作为原型链的终止。</p><p>每个引用对象都有一个__proto__属性，是一个对象</p><p>每个函数都有一个prototype原型属性，是一个对象</p><p>每个对象的__proto__指向它构造函数的原型prototype</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let obj &#x3D; &#123;&#125;</span><br><span class="line">obj.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype &#x2F;&#x2F; true</span><br><span class="line">obj.__proto__.constructor &#x3D;&#x3D;&#x3D; Object &#x2F;&#x2F; true</span><br><span class="line">Object.prototype.constructor &#x3D;&#x3D;&#x3D; Object &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><p>每个构造函数都有一个原型属性prototype，该构造函数的实例对象共享原型对象的方法和属性。</p><p>当访问对象的属性或方法时，从自身开始查找，如果查找不到则从__proto__隐式原型中即构造函数的原型对象查找，原型的原型查找，这样一层一层的向上查找形成的链式结构叫原型链。</p><p>一直往上层查找，直到null还没有找到，返回undefined</p><p><code>Object.prototype.__proto__ === null</code></p><h3 id="new关键字的操作"><a href="#new关键字的操作" class="headerlink" title="new关键字的操作"></a>new关键字的操作</h3><ul><li>创建一个空的对象{}</li><li>将新建对象的原型链连接到构造函数的原型对象上(obj._<em>proto</em> = Fn.prototype)</li><li>执行构造函数并将构造函数的this绑定到新建对象上（const _this = Fn.apply(obj, args)）</li><li>如果构造函数返回一个对象则返回这个对象否则返回新创建的对象；</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params">Fn, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  obj.__proto__ = Fn.prototype</span><br><span class="line">  <span class="keyword">const</span> _this = Fn.apply(obj, args)</span><br><span class="line">  <span class="keyword">return</span> _this <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? _this : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="js如何实现继承的？"><a href="#js如何实现继承的？" class="headerlink" title="js如何实现继承的？"></a>js如何实现继承的？</h3><ul><li>1、原型链继承</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;parent&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.type = <span class="string">&#x27;child&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent() <span class="comment">// 继承了Parent，通过原型</span></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child()</span><br><span class="line">child1.play.push(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(child1.play) <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.getName()) <span class="comment">// parent</span></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child()</span><br><span class="line"><span class="built_in">console</span>.log(child2.play) <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.getName()) <span class="comment">// parent</span></span><br></pre></td></tr></table></figure><p>原型链继承的方式，如果子类实例修改了原型上的属性那么所有子类实例都会被影响。</p><ul><li>2、借用构造函数继承（借用父类的构造函数继承父类的属性）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;parent&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="built_in">this</span>) <span class="comment">// 继承Parent的属性</span></span><br><span class="line">  <span class="built_in">this</span>.type = <span class="string">&#x27;child&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child()</span><br><span class="line">child1.play.push(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(child1.play) <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.name) <span class="comment">// parent</span></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child()</span><br><span class="line"><span class="built_in">console</span>.log(child2.play) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>这种方式解决了原型链继承中子类实例修改原型上的属性影响所有实例的问题。但是父类的方法，每个子类实例都需要重新创建一份</p><ul><li>3、组合继承（原型链+借用构造函数）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;parent&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="built_in">this</span>) <span class="comment">// 继承Parent的属性</span></span><br><span class="line">  <span class="built_in">this</span>.type = <span class="string">&#x27;child&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent() <span class="comment">// 继承Parent的方法</span></span><br><span class="line">Child.prototype.constructor = Child <span class="comment">// 修正构造函数指向</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child()</span><br><span class="line">child1.play.push(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(child1.play) <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.getName()) <span class="comment">// parent</span></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child()</span><br><span class="line"><span class="built_in">console</span>.log(child2.play) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.getName()) <span class="comment">// parent</span></span><br></pre></td></tr></table></figure><p>这种方式既解决了原型链继承中子类实例修改原型属性影响所有实例的问题，又解决了借用构造函数继承中子类实例无法继承父类的方法的问题。</p><ul><li>4、Es6 class通过extends实现继承</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;parent&#x27;</span></span><br><span class="line">    <span class="built_in">this</span>.play = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>() <span class="comment">// 调用父类的构造函数</span></span><br><span class="line">    <span class="built_in">this</span>.type = <span class="string">&#x27;child&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child()</span><br><span class="line">child1.play.push(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(child1.getName()) <span class="comment">// Parent</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.play) <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child()</span><br><span class="line"><span class="built_in">console</span>.log(child2.play) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.getName()) <span class="comment">// Parent</span></span><br></pre></td></tr></table></figure><p>这种方式的实现原理其实是基于原型链继承和借用构造函数继承的组合，拥有这两种方式的特点。</p><h3 id="js设计原理"><a href="#js设计原理" class="headerlink" title="js设计原理"></a>js设计原理</h3><ul><li>解释型语言：不需要编译，运行时解析和和执行代码</li><li>动态类型：变量类型在运行时确定</li><li>单线程和异步编程：单线程是异步的原因；事件循环是实现异步的一种方式；回调是处理异步操作的关键</li><li>垃圾回收机制：为了防止内存泄露，内置垃圾回收机制。定期寻找不再使用的变量，并释放他们占用的内存。</li></ul><h3 id="js中的this指向"><a href="#js中的this指向" class="headerlink" title="js中的this指向"></a>js中的this指向</h3><ul><li>在方法中使用，this表示该方法所属的对象</li><li>在全局中使用，this指window对象（浏览器环境）</li><li>在函数中使用，this指window对象（浏览器环境）</li><li>在函数中使用，严格模式下，this为undefined</li><li>在事件监听器中使用，this指接收事件的元素</li><li>显式绑定：可以使用<code>call</code>、<code>apply</code>或<code>bind</code>方法来显式地设置<code>this</code>的值</li><li>构造函数调用：new Person()…Person作为构造函数，this指向新创建的实例对象</li><li>箭头函数中的this：箭头函数没有this，在定义的时候就确定了，如果外层函数有this，就是外层函数的this，否则就是window</li><li>匿名函数中的this：this的值取决于它是如何被调用的。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为普通函数被调用，this指向全局window对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);  </span><br><span class="line">  &#125;;  </span><br><span class="line">  func(); <span class="comment">// this 指向全局对象，通常是 window  </span></span><br><span class="line">&#125;  </span><br><span class="line">example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为某个对象的方法被调用，this指向那个对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;  </span><br><span class="line">  prop: <span class="string">&#x27;Hello&#x27;</span>,  </span><br><span class="line">  method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.prop); <span class="comment">// this 指向 obj  </span></span><br><span class="line">    &#125;)();  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">obj.method(); <span class="comment">// 输出 &quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当使用call apply bind显示设置this时，指向设置的对象</span></span><br><span class="line"><span class="keyword">var</span> value = <span class="string">&#x27;global&#x27;</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> obj = &#123;  </span><br><span class="line">  value: <span class="string">&#x27;local&#x27;</span>  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 使用 call 方法调用匿名函数，并将 this 显式地绑定到 obj  </span></span><br><span class="line">func.call(obj); <span class="comment">// 输出 &quot;local&quot;</span></span><br></pre></td></tr></table></figure><p>匿名函数中的<code>this</code>值取决于它是如何被调用的，而不是它是否是一个匿名函数</p><h3 id="script标签的加载和执行"><a href="#script标签的加载和执行" class="headerlink" title="script标签的加载和执行"></a>script标签的加载和执行</h3><p>同步脚本：浏览器遇到script标签先暂停页面解析，加载完成后执行脚本，继续页面解析渲染；同步脚本会阻塞页面的解析</p><p>把脚本放在head标签里，会等待脚本下载，执行，然后继续后续解析，浏览器在遇到body标签之前不会渲染页面任何部分，造成页面空白且无法进行交互，体验非常不好。推荐将script标签放在body结束标签的前面。</p><p>浏览器允许并行下载js资源，但是script标签的下载仍要阻塞其他资源的下载，如图片，样式表。</p><p>非阻塞脚本：defer</p><p>当解析到带有defer属性的script标签时，会立即下载此js文件，等到页面解析完成后执行js脚本，只针对外部js脚本，严格按照出现顺序执行。脚本加载不阻塞页面解析</p><p>异步脚本：async</p><p>当解析到带有async属性的script标签时，会立即下载此js文件，下载完成后立即执行，执行完成后继续文档解析，只针对外部脚本，因为加载完成后立即执行所以执行脚本顺序不确定。脚本加载不阻塞页面解析</p><p>动态创建script标签：监听window的load事件执行回调（创建script标签并插入body）</p><h3 id="DOMContentLoaded和load事件"><a href="#DOMContentLoaded和load事件" class="headerlink" title="DOMContentLoaded和load事件"></a>DOMContentLoaded和load事件</h3><ul><li>DOMContentLoaded：当初始的文档被解析和加载完成后就触发该事件，而无需等待其他资源比如样式表、图像、子框架的完全加载</li><li>load：当文档和所依赖的资源比如样式表、图像都加载完成后触发该事件</li><li>区别：DOMContentLoaded是HTML文档被解析完成后触发，load在HTML文档及其相关资源都加载完后触发</li></ul><h3 id="setTimeout和setInterval最小执行时间？"><a href="#setTimeout和setInterval最小执行时间？" class="headerlink" title="setTimeout和setInterval最小执行时间？"></a>setTimeout和<code>setInterval</code>最小执行时间？</h3><p>根据HTML5标准，<code>setTimeout</code>的最小执行时间是<strong>4毫秒</strong>，而<code>setInterval</code>的最小执行时间是<strong>10毫秒</strong>。这意味着，如果你尝试设置一个少于这些时间间隔的延迟，浏览器会自动调整它以达到这个最小时间间隔</p><p>这些间隔受操作系统和浏览器等其他因素的影响。</p><h3 id="ES6和ES5的区别？"><a href="#ES6和ES5的区别？" class="headerlink" title="ES6和ES5的区别？"></a>ES6和ES5的区别？</h3><p>js：ECMAscript + BOM + DOM</p><p>ES5: ECMAscript5，ECMAscript的第五次修订，2009</p><p>ES6: ECMAscript6，ECMAscript的第六次修订，2015</p><h3 id="ES6新增哪些特性？"><a href="#ES6新增哪些特性？" class="headerlink" title="ES6新增哪些特性？"></a>ES6新增哪些特性？</h3><ul><li>1、新增let 和const关键字提供块级作用域</li><li>2、新增类class关键字实现继承</li><li>3、新增模块化：import和export实现模块化</li><li>4、新增箭头函数</li><li>5、新增函数参数默认值和剩余参数</li><li>6、新增对象和数组的解构赋值</li><li>7、新增对象和数组的扩展运算符</li><li>8、新增模版字符串``</li><li>9、新增Promise异步编程方案，使得异步可以像同步操作一样进行链式调用解决回调地狱问题</li><li>10、新增Symbol原始数据类型，代表独一无二的值</li><li>11、新增字符和数组的方法：如<code>Array.prototype.includes</code>，<code>String.prototype.startsWith</code>，<code>String.prototype.endsWith</code>等。</li><li>12、新增新的集合类型：如map, set, WeakMap, WeakSet</li><li>13、迭代器和生成器：引入interato接口和for…of循环，以及Generator函数</li></ul><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数提供了一种更简洁的函数书写方式，是匿名函数。当需要维护this上下文的时候使用箭头函数。</p><p>箭头函数没有this绑定，使用外层作用域的this绑定即外层函数的this对象。</p><p>箭头函数没有this、super、arguments和new.target绑定，不可以作为构造函数。</p><p>不可以使用call\apply\bind改变this的指向。</p><h3 id="call-apply-bind三者区别？"><a href="#call-apply-bind三者区别？" class="headerlink" title="call apply bind三者区别？"></a>call apply bind三者区别？</h3><p>都是用来改变this指向和函数的调用，第一个参数都是要调用的函数对象即函数体内的this值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Fun.call(obj, arg1, arg2)</span><br><span class="line">Fun.apply(obj, [arg1, arg2])</span><br><span class="line">Fun.bind(obj)(arg1, arg2) <span class="comment">// bind不能直接调用，返回一个函数后再调用</span></span><br><span class="line">Fun.bind(obj, arg1, arg2)()</span><br></pre></td></tr></table></figure><p>call参数传递参数列表，apply传参是数组，bind返回一个函数再调用，传参和call方法一样</p><h3 id="递归遇到的问题？"><a href="#递归遇到的问题？" class="headerlink" title="递归遇到的问题？"></a>递归遇到的问题？</h3><p>递归的本质是函数调用自身来解决问题。</p><p>递归每次调用都会在函数调用栈新增一个层级，函数调用栈是有大小限制的，调用栈层级过深，可能会超出栈的大小限制导致栈溢出错误。如果不设置递归终止条件会导致无限递归陷入死循环消耗资源。</p><h3 id="ajax是什么？"><a href="#ajax是什么？" class="headerlink" title="ajax是什么？"></a>ajax是什么？</h3><p>ajax是基于XHR的一种技术，用来无需刷新页面异步获取数据并更新页面</p><p>xhr是用来发送http请求和接收服务器响应的api，支持异步</p><p>1、创建xhr对象，let xhr = new XmlHttpRequest()</p><p>2、调用xhr对象的open方法与服务器建立连接</p><p>3、调用xhr对象的send方法发送请求给服务器</p><p>4、监听对象的onreadystate change事件监听服务器与客户端的通信状态</p><p>5、接收并处理服务器响应的数据</p><p>6、将数据更新到页面上</p><h3 id="get和post"><a href="#get和post" class="headerlink" title="get和post"></a>get和post</h3><p>get和post是http协议中两种请求方式。在功能和使用上有些区别：</p><p>1、URL可见性：GET请求的参数通过URL传递，在地址栏可见；POST请求的参数在http请求体中，不可见</p><p>2、传输数据的大小限制：GET请求的数据大小是有限制的，取决于URL的最大长度，这个长度由浏览器和服务器决定，通常是2048个字符；POST请求对数据大小没有限制。</p><p>3、安全性：由于GET请求参数在URL中，会被浏览器缓存、记录在历史记录中，或者被服务器、代理服务器、或用户代理记录到日志文件，因此安全性低；POST请求参数不可见，因此安全性高</p><p>4、编码方式：GET请求只支持URL编码，POST请求支持多种编码方式</p><p>5、缓存：GET请求是可以被缓存的，如果相同的请求被发送，浏览器可能从缓存中读取数据而不像服务器发送请求。POST请求不会被缓存</p><p>6、历史记录：GET请求可以被缓存到浏览器历史记录，而post请求不会。</p><p>7、用途：GET请求通常用来查找或获取数据，而post请求用来提交数据，修改或建立新的资源。</p><h3 id="Promise的内部原理是什么？"><a href="#Promise的内部原理是什么？" class="headerlink" title="Promise的内部原理是什么？"></a>Promise的内部原理是什么？</h3><p>Promise的内部实现原理主要依赖于状态机和事件循环机制。</p><p>Promise有三种状态：pending（进行中）、fulfilled（已成功）、rejected（已失败）。初始状态为pending，并且状态只能从pending转变为fulfilled或rejected，一旦转变就不能再改变。Promise的构造函数接受一个执行器函数作为参数，这个执行器函数内部包含异步操作。执行器函数有两个参数，分别是resolve和reject。当异步操作成功时，调用resolve函数将Promise状态转变为fulfilled；当异步操作失败时，调用reject函数将Promise状态转变为rejected。</p><p>在Promise内部使用了一个叫做thenable的对象用来管理回调函数。当Promise状态转变为fulfilled或rejected时，会依次执行thenable对象中的回调函数。thenable对象具有一个叫做value的属性，用来存储异步操作的结果。</p><p>Promise还有一个核心方法叫做then，用于注册回调函数。then方法接受两个参数，分别是成功回调函数和失败回调函数。当Promise状态已经是fulfilled时，会直接调用成功回调函数，并将value作为参数传入；当Promise状态已经是rejected时，会直接调用失败回调函数，并将value作为参数传入。如果then方法在Promise状态还是pending时被调用，则会将成功回调函数和失败回调函数分别放入thenable对象的回调数组中，待Promise状态转变时再执行。</p><p>在使用Promise时，可以通过链式调用多个then方法，这样可以方便地处理多个异步操作，并保持代码的可读性。在链式调用中，前一个then方法返回的是一个新的Promise对象，后一个then方法中的回调函数会作为这个新Promise对象的回调函数注册。</p><p>总的来说，Promise内部原理主要是通过状态机来管理异步操作的状态，并使用thenable对象和then方法来处理异步操作的结果。这种机制使得Promise能够方便地处理异步操作，提高代码的可读性和可维护性。</p><p>缺点：</p><ol><li><strong>无法取消Promise</strong>：一旦Promise对象被创建并已经开始执行，就无法中途取消。这可能会在一些需要取消异步操作的情况下造成问题。</li><li><strong>错误处理需要显式调用</strong>：如果Promise对象内部抛出了错误，但没有设置<code>.catch</code>方法或<code>reject</code>的回调函数，那么这个错误不会被捕获，也不会抛出到外部，这可能会导致一些问题。</li><li><strong>无法获知进展</strong>：Promise对象只有三种状态：pending、fulfilled、rejected，无法获知异步操作的进展信息（比如完成了多少百分比）。如果需要获知进展，可能需要使用其他方式（比如使用Progress对象）。</li></ol><h3 id="Promise和async-await的区别？"><a href="#Promise和async-await的区别？" class="headerlink" title="Promise和async/await的区别？"></a>Promise和async/await的区别？</h3><p>Promise和async/await都是JavaScript中用于处理异步操作的解决方案，它们有一些相似之处，但也有一些明显的区别。</p><ol><li><strong>语法差异</strong>：Promise使用then()和catch()方法来处理异步操作的结果和错误，而async/await使用更直观的语法，通过async关键字定义异步函数，并在函数内部使用await关键字等待异步操作完成。这使得异步代码看起来更像同步代码，提高了代码的可读性和可维护性。</li><li><strong>错误处理</strong>：Promise通过链式调用的catch()方法来捕获错误，而async/await可以使用try-catch语句来捕获错误。这使得错误处理更加直观和方便。</li><li><strong>应用场景</strong>：Promise更适用于一连串的异步请求，而async/await更适合串行的异步请求之间的依赖关系比较复杂或需要控制执行顺序的情况。async/await更适合业务逻辑处理较为复杂的场景。</li><li><strong>错误堆栈追踪</strong>：使用Promise时，如果发生错误，堆栈追踪会包含Promise内部的异步操作，这可能会使得定位错误变得更加困难。而使用async/await时，错误堆栈追踪会显示在出错的地方，这更方便调试和定位错误。</li></ol><p>在一些简单的异步操作中，Promise可能更加简洁和高效；而在需要处理复杂异步逻辑和错误处理的场景中，async/await可能更加适合。</p><h3 id="浏览器常用存储方式有哪些？"><a href="#浏览器常用存储方式有哪些？" class="headerlink" title="浏览器常用存储方式有哪些？"></a>浏览器常用存储方式有哪些？</h3><ul><li>cookie：由服务器发送并存储在浏览器，并且在同一服务器请求下携带cookies。大小有限通常为4KB，可以通过Expires设置过期时间。通常用来存储用户登录信息、个性化设置等。</li><li>localStorage：本地持久化存储，以key-value形式存储字符串数据，大小为5M或更大。除非主动删除否则永久化存储。</li><li>sessionStorage：用于本地存储，只保存在当前浏览器会话中，关闭浏览器窗口或标签就会被删除。适用于临时数据存储。</li><li>IndexedDB: 基于事务的数据库存储，可以存储大量结构化数据。</li><li>WebSQL：使用SOL数据库在浏览器中存储数据（兼容性和性能不好已被indexedDB取代）</li></ul><p>浏览器中cookie和sessionStorage/localStorage的区别？</p><ul><li>存储大小：cookie存储大小通常为4KB，sessionStorage/localStorage可以达到5M或更大。</li><li>存储位置：cookie存储在浏览器中，sessionStorage/localStorage存储在浏览器内存中，若浏览器设置不保存数据，数据会丢失</li><li>有效时间：cookie在设置有效期内都可用，即使关闭浏览器；localStorage除非主动删除永久可用；sessionStorage在当前浏览器会话中可用，浏览器窗口或标签关闭就被删除</li><li>数据共享：三者都遵循同源共享数据。cookie和localStorage在同源浏览器窗口数据都共享即使不是同一个页面；sessionStorage只在当前会话当前标签/窗口共享数据。</li><li>通信方式：cookie参与服务器通信，sessionStorage/localStorage不会被发送到服务器</li><li>生成方式：cookie由服务器生成发送到浏览器，sessionStorage/localStorage由前端创建</li></ul><h3 id="token存储在哪里？"><a href="#token存储在哪里？" class="headerlink" title="token存储在哪里？"></a>token存储在哪里？</h3><p>token是验证身份的令牌，用户登录成功后服务器根据凭证加密后得倒的字符串。</p><ul><li>localstorage：持久化存储数据，每次调用接口发送请求将token当作字段传给后台。将Token存储在Local Storage中可能会面临XSS攻击的风险，特别是当项目中引入了很多第三方JS类库时。</li><li>sessionStorage：与Local Storage类似，但数据只在当前浏览器会话中有效</li><li>cookies：由服务器发送给浏览器，每次浏览器向同一服务器发送请求都会携带cookies，将token存储在cookies可用自动发送但是不能跨域。容易收到csrf攻击。</li></ul><h3 id="DOM树和渲染树有什么区别？"><a href="#DOM树和渲染树有什么区别？" class="headerlink" title="DOM树和渲染树有什么区别？"></a>DOM树和渲染树有什么区别？</h3><p>DOM树和HTML标签一一对应的，包括head标签和隐藏元素</p><p>DOM树和CSSOM树生成渲染树，渲染树和DOM树不一一对应，只包含可见元素，比如display：none元素包含在DOM树但是不在渲染树，比如伪元素不在DOM树但是在渲染树。</p><h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>jwt（Json web token）用于在网络间安全的传输信息。用于认证、授权、信息交换等场景。</p><p>JWT由Header（头部）、Payload（负载）、Signature（签名）三部分组成，三者都经过base64转码。</p><p>Header头部包含类型和签名算法；Payload负载包含实体（用户）和其他数据的声明；Signature签名：为了验证数据在传输过程中是否被篡改，对头部和负载使用算法进行签名。</p><p>JWT的优点：</p><ul><li>紧凑：非常小巧，可以在URL、HTML表单、HTTP头中使用</li><li>自包含：包含有关用户、签发者等必要信息，不需要从服务器多次查询</li></ul><p>JWT的缺点：</p><ul><li>无法撤销：JWT一经签发不能被更改和撤销，在过期之前即使被窃取都可使用</li><li>增加服务器的负载：因为JWT中信息需要被解码和验证会增加服务器的负载</li></ul><p>JWT通常通过sessionStorage\localStorage\cookies存储在浏览器。</p><p>jwt认证流程：</p><p>1、客户端把账号密码发送给后端接口</p><p>2、服务端核对成功后把用户信息等作为负载，然后把头部和负载分别进行base64编码后进行签名，形成一个jwt</p><p>3、客户端每次发送请求http请求头携带jwt（Authorization）</p><p>4、服务端验证jwt的有效性</p><p>5、验证通过后使用jwt中的用户信息进行操作返回结果</p><h3 id="精灵图和base64区别？"><a href="#精灵图和base64区别？" class="headerlink" title="精灵图和base64区别？"></a>精灵图和base64区别？</h3><p>精灵图：将多张小图整合到一张大图上，通过定位将小图展示到页面上，多次访问可以减少请求，提高加载速度</p><p>Base64图：将图像数据编码为base64字符串的形式。</p><p>base64优点：</p><ul><li>减少http请求次数：图像直接嵌入网页不再发送图片请求，减少http请求次数提高加载速度</li><li>避免跨域问题：图片跟随网页下载，避免了跨域</li></ul><p>缺点：</p><ul><li>增加css文件大小：如果使用大量base64图片会增加css文件大小，影响加载速度</li><li>增加css解析时间：base64编码较长，增加css解析时间，影响网页性能</li><li>浏览器兼容性：老版本浏览器不支持base64格式的图片</li></ul><h3 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h3><p>svg是基于XML语法的图像格式，全称可缩放矢量图。不同于png等基于像素的位图，svg基于矢量数据描述图像内容。</p><p>可无损放大和缩小图片，保持图片的清晰度；svg基于文本可以被编辑和修改；兼容性好，可以同页面元素一样与js和css进行交互。</p><h3 id="npm的底层环境是什么？"><a href="#npm的底层环境是什么？" class="headerlink" title="npm的底层环境是什么？"></a>npm的底层环境是什么？</h3><p>Node Package Manager，node的包管理和分发工具，已经称为分发node模块的标准，是js 的运行环境。</p><p>npm允许开发者从注册表（一个公共的存储库）中安装、更新和管理nodejs所需的库和工具，这些库和工具称为包</p><p>npm组成：网站、注册表、命令行工具</p><h3 id="http协议的协议头和请求头有什么？"><a href="#http协议的协议头和请求头有什么？" class="headerlink" title="http协议的协议头和请求头有什么？"></a>http协议的协议头和请求头有什么？</h3><p>协议头包含请求头和响应头</p><p>请求头：</p><ul><li>Accept：客户端告诉服务器支持的数据类型</li><li>Accept-encoding：客户端告诉服务器支持的压缩格式如gzip</li><li>Accept-Language：客户端告诉服务器所采用的语言</li><li>Host：客户端告诉服务器想要访问的主机名。</li><li>Referer：客户端告诉服务器从那个网页跳转过来</li><li>If-Modified-Since：客户端告诉服务器缓存最后修改时间</li><li>cookie：客户端向服务器发送cookie信息</li><li>user-agent：客户端告诉服务器其所使用的浏览器类型、版本等信息。</li><li>Connection：是否需要持久连接keep-alive</li></ul><p>响应头：</p><ul><li>Content-type：告诉客户端响应体的媒体类型</li><li>Content-length：响应体的长度</li><li>Cache-control：控制网页缓存</li><li>Date：消息被发送的时间和日期</li><li>Server：服务器的名称、版本等信息</li><li>Set-Cookie：向客户端发送cookie</li><li>Location：重定向资源的位置</li></ul><h3 id="浏览器缓存策略"><a href="#浏览器缓存策略" class="headerlink" title="浏览器缓存策略"></a>浏览器缓存策略</h3><p>强缓存：本地读取缓存，从内存(会话级)或硬盘读取   Expires cache-control</p><p>协商缓存：强缓存命中失败，向服务器发送请求，协商缓存，if-modified-since/last-modified.  If-none-match/etag</p><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>浏览器的同源策略：它限制一个源的文档或加载的脚本如何能与另一个源的资源进行交互。它能隔离恶意文档，减少被攻击的媒介。</p><p>如果两个url的协议/域名/端口都相同的话，则这两个url是同源。</p><p>script、link、iframe、img、video、object标签引入的资源可以跨域</p><p>跨域解决方案：</p><ul><li>JSONP：动态创建script标签并插入head中，浏览器会执行script代码，只能发送get请求</li><li>CORS：基于http1.1的跨域解决方案，全称跨域资源共享。简单来说就是浏览器要想跨域访问服务器资源必须经过服务器的允许。</li></ul><p>针对不同请求，cors有三种交互模式：简单请求、带预检的请求、携带cookie的请求</p><p>简单请求：请求方式为get、post、head；请求头仅包含安全的字段Accept、Accept-lanuage、content-type等；有content-type字段且值只能为text/plain application/x-www-form-urlencoded multipart/form-data;</p><p>简单请求请求头携带Origin表明发送跨域请求的源地址，服务器收到请求如果允许跨域访问则在响应头添加Access-Control-Allow-Origin字段</p><p>带预检的请求：非简单请求，先发送预检请求访问服务器是否允许，服务器接收请求允许访问，浏览器发送真实的请求，服务器完成真实的响应</p><p>携带cookie的请求：设置withCredentials: true,当一个请求附带cookie时，无论简单还是预检请求都会在请求头添加cookie字段，而服务器需要在响应头明确表示是否允许Access-Control-Allow-Credential:true</p><ul><li>代理服务器：客户端向代理服务器发送请求，代理服务器再向目标服务器发送请求，然后将结果返回给客户端</li><li>WebSocket：在单tcp连接进行双工通信的协议，允许跨域通信</li><li>window.postMessage:h5的postMessage方法允许跨窗口/跨域通信</li><li>第三方库：jQuery、Axios等也提供了跨域请求的支持</li></ul><h3 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h3><p>防抖：连续触发事件在一段时间内只执行一次，如果时间内再次触发，则重新计时.</p><p>使用场景：用户重复点击按钮，搜索框实时搜索，窗口大小调整</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">if</span> (timer) timer = <span class="literal">null</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      func.apply(context, args)</span><br><span class="line">    &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节流：连续触发函数在一段时间内只执行一次，稀释了函数的执行频率。</p><p>使用场景：鼠标icon定位，页面scorll，窗口调整，抢购和疯狂点击</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        func.apply(context, args)</span><br><span class="line">        timer = <span class="literal">null</span></span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>防抖和节流都用于降低函数的执行频率。不同的是防抖在一段时间后操作，在这段时间内再次触发任务，则重新计时；而节流是一段时间内只执行一次任务，若这段时间内再次触发也不会生效。</p><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>一种轻量级的数据交换格式。是ecmascript的一个子集，使用文本格式来存储和表示数据。简洁、容易阅读。</p><p>SON的基本语法规则包括：</p><ul><li>数据为键值对（key/value pairs）。</li><li>数据由逗号分隔。</li><li>花括号保存对象。</li><li>方括号保存数组。</li></ul><p>JSON的两种基本结构是对象和数组。对象是一个无序的键值对集合，其中每个键值对使用一个冒号分隔，多个键值对之间使用逗号分隔。数组则是一个有序的值列表，其中每个值之间使用逗号分隔。</p><h3 id="当数据没有请求过来时该怎么做"><a href="#当数据没有请求过来时该怎么做" class="headerlink" title="当数据没有请求过来时该怎么做"></a>当数据没有请求过来时该怎么做</h3><p>可以考虑采用一些备选方案，如使用缓存数据、提供占位符或加载默认值等，以保证用户界面的友好性和可用性</p><h3 id="无感登录"><a href="#无感登录" class="headerlink" title="无感登录"></a>无感登录</h3><p>token+refreshToken模式：用户在认证中心登录成功后返回给客户端token+refreshToken,其中token有效期短，refreshToken长期有效，客户端访问业务系统携带token，由业务系统验证通过后返回响应数据，若token过期则返回客户端对应状态码，客户端在响应拦截中拿refreshToken换取新的token保存并替换在本地，用新的token去重新发送业务请求。如果refreshToken过期了，则清除所有token重新进行登录认证。</p><p>方式：1.在响应中拦截，判断过期后调用刷新token接口</p><p>2、设置定时器刷新token接口    3、后端返回过期时间，前端判断token过期调用刷新token接口</p><h3 id="大文件上传"><a href="#大文件上传" class="headerlink" title="大文件上传"></a>大文件上传</h3><h3 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h3><p>组织管理：发挥资源的最大效能</p><p>前端工程化：前端开发的管理工具、降低开发成本，提升开发效率</p><p>项目规模越大，团队成员越多，项目越复杂，管理成本就越高，工程化价格越大。</p><p>前端工程化，选择什么样的工具，如何把这些工具组织起来，形成我们的项目结构，让初中级开发者能够在这套系统里完美的进行协作，高效率的进行开发，是非常有价值的一件事。</p><p>一些官方的脚手架工具比如cli, vite是众多方案里现成的解决方案，不一定适合所有项目，一些复杂的项目需要自行开发脚手架。</p><p>开发者和架构师最大的区别是工程化能力的区别。</p><h4 id="模块化和包管理"><a href="#模块化和包管理" class="headerlink" title="模块化和包管理"></a>模块化和包管理</h4><p>问题、标准、实现</p><p>随着项目的复杂，用分解和聚合的思想来管理项目</p><p>模块化：分解和聚合，解决文件的分解（全局污染）和聚合（依赖混乱）</p><p>模块化：</p><ul><li>标准： CommonJS（CJS，社区标准-nodejs） AMD CMD UMD Ecmascript Module(ESM，官方标准)，常用commonjs、ESM<ul><li>cjs是运行时，运行后才能确定依赖关系<code>const xxx = require(&#39;./1.js&#39;)</code>；ESM是编译时，运行之前就判断依赖关系<code>import xxx from &#39;./1.js&#39;</code>,ESM不需要运行就能确定依赖关系，方便做优化。</li></ul></li><li>实现：浏览器、node、构建工具<ul><li>浏览器支持ESM，只支持官方,<code>&lt;script src=&quot;./1.js&quot; type=&quot;module&quot; &gt;</code></li><li>node支持CJS和ESM</li><li>构建工具：一般都支持CJS和ESM，vue-cli vite car umijs 脚手架内部内置构建工具：webpack、rollup、esbuilder等，推荐使用ESM</li></ul></li></ul><p>包管理：</p><ul><li>包：package，一系列模块的集合, 函数-&gt;文件-&gt;包</li><li>npm：包管理工具，包含：包的属性、registry(包含包的仓库)、cli（command-line interface命令行工具界面），pnpm, yarn, cnpm, bower为了弥补npm的不足，bower支持浏览器环境，其他npm等都是在node环境，常用npm, pnpm, yarn</li></ul><p>框架：约束代码结构，比如vue单文件组件</p><p>库：原本就有自己的结构，调用库的功能</p><p>工程化是前端开发工具，降低开发成功，提高开发效率</p><h4 id="JS工具链"><a href="#JS工具链" class="headerlink" title="JS工具链"></a>JS工具链</h4><p>开发项目除了业务代码外还有别的问题需要解决：</p><ul><li><p>语言问题：html、css（sass/less/stylus等）、js的兼容性和语言增强，兼容性：api兼容（babel、polypill）、语法增强</p><ul><li><p>js语言的处理</p><ul><li>js中常用2个工具Babel,Core-js,Babel负责将最新的ES语法转换为浏览器兼容的语法（比如let, const）；而Core-js提供了必要的polyfill，使开发者使用最新的js特性，而不必担心兼容性问题(比如promise, async/await)；</li><li>Babel: 是一个JavaScript编译器，将最新版本es代码转换为向后兼容的js版本，以便在旧版本浏览器运行。这一功能通过各种插件实现，每一种插件负责转换一种语法，为了简化插件的使用，babe提供一组预设presets，presets是插件的集合，可以预先配置好常用的插件方便开发者使用。babel将代码转换为AST抽象语法树，又转换为代码。babel的插件影响抽象语法树从而最终影响转换结果。</li><li>Core-js：是一个包含javascript标准库polyfill的集合。Polyfill是填充浏览器对ES6+新语法支持不足的工具，为浏览器添加缺失的特性，使开发者可以使用最新的js特性，而不用担心兼容性问题。</li></ul></li><li><p>css语言的处理</p><ul><li><p>css语言的问题：语法缺失（循环、判断、拼接）、功能缺失（颜色函数、数学函数、自定义函数）</p></li><li><p>新语言：在css基础上扩展，sass/less/stylus包含css，新语言-&gt;css预编译器-&gt;css语言, css语言还需要处理别的问题：厂商前缀（autoprefixer）、代码压缩（cssnano）、代码剪枝（purgecss）等，处理这些的问题的工具称为后处理器，处理完成后生成css代码；</p></li><li><p>Sass/less/stylus–&gt;预编译器–&gt;css–&gt;后处理器–&gt;css</p></li><li><p>PostCSS：是一个使用javascript工具转换css的库，不是一个预处理器，而是用来转换css代码的。主要功能包括：</p><ul><li><p>解析css代码转换为抽象语法树AST</p></li><li><p>提供API以修改AST</p></li><li><p>将修改后的AST格式化为新的CSS代码</p><p>postcss本身并不提供任务功能而是依赖于插件来进行css转换，对基于css的AST进行各种操作，包括支持变量和混入、添加浏览器前缀等。postcss使用多种场景包括在css预处理阶段和后处理阶段进行代码转换，也可以结合sass/less/stylus工具使用，以扩展css的功能和兼容性。Tailwind是postcss的一个插件，是个样式库，封装的是css；使用Tailwind时，只需要给组件添加class即可；特点是可定制化程度高和响应式设计。</p></li></ul></li></ul></li></ul></li><li><p>工程问题</p></li><li><p>流程问题</p></li></ul><p>开发和维护的代码于运行时需要的代码不一致，需要进行工程转换，就是构建工具，用来进行工程转换。</p><p>webpack是一种模块打包工具，用于前端资源构建，可以处理js、css、图片等各种文件并将其打包成浏览器可以识别的静态资源。</p><h3 id="html语义化的理解"><a href="#html语义化的理解" class="headerlink" title="html语义化的理解"></a>html语义化的理解</h3><ul><li>使内容更加结构化，即使失去样式也能呈现清晰的结构</li><li>有利于爬虫和seo</li><li>语义化更有可读性，方便团队开发</li><li>方便其他设备解析，比如盲人阅读器渲染页面更易于阅读</li></ul><h3 id="html5的新特性"><a href="#html5的新特性" class="headerlink" title="html5的新特性"></a>html5的新特性</h3><ul><li>语义化的标签</li><li>新增video、audio</li><li>画布canvas</li><li>svg</li><li>drag &amp; drog 拖拽释放API</li><li>input类型：date、datetime、email</li><li>localStorage/sessionStorage</li></ul><h3 id="css3新特性"><a href="#css3新特性" class="headerlink" title="css3新特性"></a>css3新特性</h3><ul><li>边框</li><li>背景属性</li><li>文本阴影</li><li>transform</li><li>transition过渡动画</li><li>animation动画</li><li>渐变</li><li>媒体查询</li><li>弹性盒</li><li>新增选择器：属性、伪类、伪元素选择器</li></ul><h3 id="解决了哪些移动端的兼容问题？"><a href="#解决了哪些移动端的兼容问题？" class="headerlink" title="解决了哪些移动端的兼容问题？"></a>解决了哪些移动端的兼容问题？</h3><p>1、在移动端（特别是 iOS 设备）上，当使用 <code>overflow: scroll</code> 或 <code>overflow: auto</code> 样式时，确实可能会遇到滑动卡顿的问题。</p><p>原因：IOS safari试图减少绘制和合成操作来进行滚动性能优化。</p><p>解决：使用<code>-webkit-overflow-scrolling: touch</code>启用IOS上滚动性能优化。这个属性告诉浏览器使用原生滚动机制，通常可以提供更流畅的滚动体验。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.scroll-element</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: scroll;</span><br><span class="line">  <span class="attribute">-webkit-overflow-scrolling</span>: touch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、在移动端安卓设备上，<code>placeholder</code> 文字在设置行高 (<code>line-height</code>) 后偏上</p><p>解决：避免给有placeholder属性的input/textarea设置行高（line-height: normal）</p><p>3、移动端字体小于12px时异常显示</p><p>解决：先将元素整体尺寸放大一倍，再用transform:scale(0.5)进行缩小，设置基点transform-origin: 0 0;</p><p>4、ios系统在input框禁用时，disabled：true文本内容不显示</p><p>原因：ios系统在input:disabled时透明度为0.3导致视觉上文本不显示</p><p>解决：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:disabled</span>, <span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">&quot;button&quot;</span>]</span><span class="selector-pseudo">:disabled</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、IOS端input输入框首字母会大写</p><p>原因：在 iOS 设备上，虚拟键盘默认会开启首字母大写功能</p><p>解决：<code>autocapitalize=&quot;off&quot;</code> 告诉键盘不要自动将输入的首字母大写，而 <code>autocorrect=&quot;off&quot;</code> 则禁用了自动更正功能</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">autocapitalize</span>=<span class="string">&quot;off&quot;</span> <span class="attr">autocorrect</span>=<span class="string">&quot;off&quot;</span></span></span><br></pre></td></tr></table></figure><p>6、禁用移动端选中文字</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 禁止用户选择文本 */</span>  </span><br><span class="line">* &#123;  </span><br><span class="line">  <span class="attribute">-webkit-touch-callout</span>: none; <span class="comment">/* iOS Safari */</span>  </span><br><span class="line">  <span class="attribute">-webkit-user-select</span>: none; <span class="comment">/* Safari */</span>  </span><br><span class="line">  <span class="attribute">-khtml-user-select</span>: none; <span class="comment">/* Konqueror HTML */</span>  </span><br><span class="line">  <span class="attribute">-moz-user-select</span>: none; <span class="comment">/* Firefox */</span>  </span><br><span class="line">  <span class="attribute">-ms-user-select</span>: none; <span class="comment">/* Internet Explorer/Edge */</span>  </span><br><span class="line">  <span class="attribute">user-select</span>: none; <span class="comment">/* 非前缀版本，目前被大多数浏览器支持 */</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/* 如果需要允许 input 元素内的文本选择，可以单独设置 */</span>  </span><br><span class="line"><span class="selector-tag">input</span> &#123;  </span><br><span class="line">  <span class="attribute">-webkit-user-select</span>: auto; <span class="comment">/* 允许 input 内的文本选择 */</span>  </span><br><span class="line">&#125;</span><br><span class="line">​```</span><br></pre></td></tr></table></figure><p>7、ios识别长串数字为电话</p><p>解决：<code>&lt;meta name=&quot;fomat-dection&quot; content=&quot;telphone=no&quot;</code></p><h3 id="v-for中key的作用"><a href="#v-for中key的作用" class="headerlink" title="v-for中key的作用"></a>v-for中key的作用</h3><p>1、作为元素的唯一标识，避免<code>v-for</code>的“就地更新”策略导致的问题。</p><p>2、更高效的更新虚拟DOM，提高渲染效率</p><p>3、避免带有输入框的DOM产生错误更新造成数据混乱</p><h3 id="created和mounted请求数据有什么区别"><a href="#created和mounted请求数据有什么区别" class="headerlink" title="created和mounted请求数据有什么区别"></a>created和mounted请求数据有什么区别</h3><ul><li><code>created</code>：在组件实例被创建后立即调用，此时组件的DOM尚未被挂载。</li><li><code>mounted</code>：在组件的DOM挂载完成后调用，此时组件已经可以访问到DOM元素。</li></ul><p>通常，<code>created</code>用于在DOM挂载之前发起数据请求并进行预处理，而<code>mounted</code>则用于在DOM挂载完成后执行依赖于DOM的操作</p><h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><p><code>keep-alive</code> 是 Vue.js 中提供的一个内置组件，用于缓存不活动的组件实例，而不是销毁它们。当组件在 <code>&lt;keep-alive&gt;</code> 内被切换时，它的激活和停用状态会被相应触发。</p><p>包裹在动态组件中使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;  </span><br><span class="line">  &lt;component :is&#x3D;&quot;currentComponent&quot;&gt;&lt;&#x2F;component&gt;  </span><br><span class="line">&lt;&#x2F;keep-alive&gt;</span><br></pre></td></tr></table></figure><p>特性</p><ul><li><code>include</code>（字符串或正则表达式）：只有名称匹配的组件会被缓存。</li><li><code>exclude</code>（字符串或正则表达式）：任何名称匹配的组件都不会被缓存。</li></ul><p>生命周期钩子</p><p>当组件被 <code>&lt;keep-alive&gt;</code> 包裹时，会触发两个额外的生命周期钩子：</p><ul><li><code>activated</code>：当组件从缓存中激活时调用。</li><li><code>deactivated</code>：当组件被停用（但不是销毁）时调用。</li></ul><h3 id="element-ui怎么进行表单验证"><a href="#element-ui怎么进行表单验证" class="headerlink" title="element-ui怎么进行表单验证"></a>element-ui怎么进行表单验证</h3><p>Form组件设置model属性进行数据绑定，Form-item组件设置prop属性验证字段名，Form 组件上设置 <code>:rules</code> 属性绑定验证规则对象</p><p>表单校验方式：</p><ul><li><strong>基础校验</strong>：在 <code>el-form-item</code> 中通过 <code>rules</code> 属性进行校验规则的设置或者在<code>form</code>组件添加<code>rules</code>属性绑定表单全部属性检验规则对象</li><li>自定义校验：通过 <code>validator</code> 函数来自定义校验规则。<code>validator</code> 是一个函数，它接收三个参数：<code>rule</code>（校验规则）、<code>value</code>（字段值）和 <code>callback</code>（回调函数）。</li></ul><h3 id="封装axios"><a href="#封装axios" class="headerlink" title="封装axios"></a>封装axios</h3><p>封装axios可以简化代码、同一错误处理、请求拦截和响应拦截等。封装步骤：</p><ul><li>1、安装下载axios</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure><ul><li>2、创建请求文件：在项目的src目录下，创建一个utils文件夹，并在该文件夹下创建一个request.js文件。这个文件将用于封装axios。</li><li>3、在request.js中引入依赖,引入axios和其他你可能需要的依赖，如qs（用于序列化post请求的数据）。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;  </span><br><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">&#x27;qs&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>4、<strong>配置axios</strong>：</li></ul><p>在axios配置默认设置、如baseURL、timeout、请求拦截、响应拦截等</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> service = axios.create(&#123;</span><br><span class="line">  baseURL: process.env.VUE_APP_BASE_API, <span class="comment">// api的base_url  </span></span><br><span class="line">  timeout: <span class="number">5000</span> <span class="comment">// 请求超时时间   </span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 请求拦截</span></span><br><span class="line">service.interceptors.request.use(</span><br><span class="line"> config =&gt; &#123;</span><br><span class="line">    <span class="comment">// 在发送请求之前做些什么  </span></span><br><span class="line">    <span class="comment">// 例如，添加token到请求头  </span></span><br><span class="line">    <span class="keyword">if</span> (store.getters.token) &#123;  </span><br><span class="line">      config.headers[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="string">&#x27;Bearer &#x27;</span> + store.getters.token;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> config; </span><br><span class="line">  &#125;，</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">   <span class="comment">// 对请求错误做些什么  </span></span><br><span class="line">    <span class="built_in">console</span>.log(error); <span class="comment">// for debug  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);  </span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 响应拦截</span></span><br><span class="line">service.interceptors.response.use(</span><br><span class="line"> response =&gt; &#123;</span><br><span class="line">    <span class="comment">// 对响应数据做点什么  </span></span><br><span class="line">    <span class="keyword">return</span> response.data;  </span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    <span class="comment">// 对响应错误做点什么  </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;err&#x27;</span> + error); <span class="comment">// for debug  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);  </span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> service</span><br></pre></td></tr></table></figure><ul><li>5、创建API管理文件</li></ul><p>创建API文件夹，创建管理对应功能模块的api文件，比如用户模块，user.js</p><ul><li>6、在API文件中引入axios</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user.js</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">&#x27;@/utils/request.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getUserList</span>(<span class="params">params</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> request(&#123;  </span><br><span class="line">    url: <span class="string">&#x27;/user/list&#x27;</span>,  </span><br><span class="line">    method: <span class="string">&#x27;get&#x27;</span>,  </span><br><span class="line">    params  </span><br><span class="line">  &#125;);  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createUser</span>(<span class="params">data</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> request(&#123;  </span><br><span class="line">    url: <span class="string">&#x27;/user/create&#x27;</span>,  </span><br><span class="line">    method: <span class="string">&#x27;post&#x27;</span>,  </span><br><span class="line">    data: qs.stringify(data)  </span><br><span class="line">  &#125;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>7、在组件中使用</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getUserList, createUser &#125; <span class="keyword">from</span> <span class="string">&#x27;@/api/user&#x27;</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;  </span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> &#123;  </span><br><span class="line">      userList: []  </span><br><span class="line">    &#125;;  </span><br><span class="line">  &#125;,  </span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;  </span><br><span class="line">    getUserList().then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;  </span><br><span class="line">      <span class="built_in">this</span>.userList = response;  </span><br><span class="line">    &#125;);  </span><br><span class="line">  &#125;,  </span><br><span class="line">  methods: &#123;  </span><br><span class="line">    <span class="function"><span class="title">createNewUser</span>(<span class="params">newData</span>)</span> &#123;  </span><br><span class="line">      createUser(newData).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;  </span><br><span class="line">        <span class="comment">// 处理响应  </span></span><br><span class="line">      &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="vue路由传参方式？"><a href="#vue路由传参方式？" class="headerlink" title="vue路由传参方式？"></a>vue路由传参方式？</h3><ul><li>查询参数query传参：</li></ul><p><code>http://localhost:8080/user?id=123</code>参数显示在url中，通过<code>$route.query.id</code>获取参数</p><ul><li>路由参数：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">  path: <span class="string">&#x27;/user/:id&#x27;</span>,  </span><br><span class="line">  component: User  </span><br><span class="line">&#125;</span><br><span class="line">http:<span class="comment">//localhost:8080/user/123</span></span><br></pre></td></tr></table></figure><p>通过<code>$route.params.id</code>访问这个参数</p><ul><li>编程式导航传参</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// params</span></span><br><span class="line"><span class="built_in">this</span>.$router.push(&#123; <span class="attr">name</span>: <span class="string">&#x27;User&#x27;</span>, <span class="attr">params</span>: &#123; <span class="attr">userId</span>: <span class="number">123</span> &#125;&#125;);</span><br><span class="line"><span class="built_in">this</span>.$router.push(&#123; <span class="attr">path</span>: <span class="string">`/user/<span class="subst">$&#123;userId&#125;</span>`</span> &#125;);</span><br><span class="line"><span class="comment">// query</span></span><br><span class="line"><span class="built_in">this</span>.$router.push(&#123; <span class="attr">path</span>: <span class="string">&#x27;/user&#x27;</span>, <span class="attr">query</span>: &#123;<span class="attr">userId</span>: <span class="number">123</span>&#125; &#125;);</span><br></pre></td></tr></table></figure><p>查询参数（query parameters）与路由参数（route parameters）不同。路由参数是定义在路由配置中的，并且作为 URL 的一部分出现，但它们不会显示在 URL 中（除非你特别配置它们这样做）</p><ul><li><p>路由组件传参</p><ul><li><p>布尔模式：props属性设置为true，<code>route.params</code> 将会被设置为组件属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  props: [<span class="string">&#x27;id&#x27;</span>],</span><br><span class="line">  template: <span class="string">&#x27;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/user/:id&#x27;</span>, <span class="attr">component</span>: User, <span class="attr">props</span>: <span class="literal">true</span> &#125;</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure></li><li><p>对象模式：如果 <code>props</code> 是一个对象，它会被按原样设置为组件属性。当 <code>props</code> 是静态的时候有用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;/user&#x27;</span>,</span><br><span class="line">      component: User,</span><br><span class="line">      props: &#123; <span class="attr">id</span>: <span class="number">123</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></li><li><p>函数模式:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">routes: [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/user&#x27;</span>,</span><br><span class="line">    component: User,</span><br><span class="line">    props: <span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        query: route.query.q,</span><br><span class="line">        name: route.params.name</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>全局前置守卫传参: 可以在beforeEach中访问to和from对象处理和修改传入的参数</p></li></ul></li></ul><h3 id="vue的路由hash模式和history模式的区别？"><a href="#vue的路由hash模式和history模式的区别？" class="headerlink" title="vue的路由hash模式和history模式的区别？"></a>vue的路由hash模式和history模式的区别？</h3><p>vue的路由hash模式和history模式主要区别体现在URL表现形式、页面刷新行为、后端配置需求等方面。</p><ul><li>URL表现形式：hash模式下，页面地址栏地址中URL中会带有“#”以及后面的字符，history模式下URL表现正常。</li><li>页面刷新行为：hash模式下，地址栏回车页面路由正常导航显示，而history模式下，页面刷新可能会404.这是因为history模式的URL资源在服务器中不存在，需要后端进行相应的配置。</li><li>后端配置需求：history模式的URL需要后端进行重写或重定向以便访问不存在的URL资源能正确的返回index.html文件</li><li>兼容性：hash模式支持低版本浏览器，history不支持，因为是html5的api</li></ul><p><code>history.pushState(data, title, url)</code>, <code>history.replace(data, title, url)</code>新增/替换当前历史记录，不会触发<code>window.onpopstate = function()&#123;&#125;</code>监听历史栈的改变的事件，<code>history.forward()前进，history.back()后退,history.go()</code>会触发历史展改变的事件；</p><p>window对象提供了onhashchange事件来监听hash值的改变,一旦url中的hash值发生改变,便会触发该事件。</p><h3 id="路由拦截是怎么实现的？"><a href="#路由拦截是怎么实现的？" class="headerlink" title="路由拦截是怎么实现的？"></a>路由拦截是怎么实现的？</h3><p>一般路由分为静态路由和权限路由，静态路由为登录页面，错误处理404页面等不需要鉴权的路由，在白名单内；权限路由为需要鉴定权限即校验是否登录等校验的路由。一般在全局导航守卫进行拦截：</p><p><strong>全局路由拦截：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">&#x27;router&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  <span class="comment">// ...路由配置  </span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 校验是否登录/认证</span></span><br><span class="line"><span class="keyword">const</span> isValidateLogin = ()&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> whiteList = [<span class="string">&#x27;login&#x27;</span>, <span class="string">&#x27;404&#x27;</span>]</span><br><span class="line"><span class="comment">// 全局前置守卫</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 不在白名单内，需要校验</span></span><br><span class="line">  <span class="keyword">if</span> (!whiteList.includes(to.name)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isValidateLogin()) &#123;</span><br><span class="line">      next()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      next(&#123;</span><br><span class="line">        name: <span class="string">&#x27;login&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>路由独享的拦截：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;  </span><br><span class="line">  routes: [  </span><br><span class="line">    &#123;  </span><br><span class="line">      path: <span class="string">&#x27;/user/:id&#x27;</span>,  </span><br><span class="line">      name: <span class="string">&#x27;user&#x27;</span>,  </span><br><span class="line">      component: User,  </span><br><span class="line">      beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;  </span><br><span class="line">        <span class="comment">// 这里的逻辑和全局守卫类似  </span></span><br><span class="line">        <span class="keyword">const</span> isValidateLogin = ()&#123;&#125;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (!isValidateLogin) &#123;  </span><br><span class="line">          next(<span class="literal">false</span>); <span class="comment">// 阻止导航  </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">          next(); <span class="comment">// 确保一定要调用 next()  </span></span><br><span class="line">        &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// ...其他路由配置  </span></span><br><span class="line">  ]  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>组件内的拦截:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">beforeRouteEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;  </span><br><span class="line">    <span class="comment">// 在路由进入之前被调用  </span></span><br><span class="line">    <span class="comment">// 不能使用 this，因为此时组件实例还没被创建  </span></span><br><span class="line">    next(<span class="function"><span class="params">vm</span> =&gt;</span> &#123;  </span><br><span class="line">      <span class="comment">// 通过 `vm` 访问组件实例  </span></span><br><span class="line">    &#125;);  </span><br><span class="line">  &#125;,  </span><br></pre></td></tr></table></figure><h3 id="vue的动态路由"><a href="#vue的动态路由" class="headerlink" title="vue的动态路由"></a>vue的动态路由</h3><p>vue的动态路由是根据应用程序的状态或用户的权限动态的添加、删除、修改路由。是由<code>router.addRoutes</code>方法实现的，这个方法运行你在运行时向路由表添加更多的路由。</p><p><strong>首先，安装并引入Vue Router</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">&#x27;router&#x27;</span></span><br><span class="line">Vue.use(Router)</span><br></pre></td></tr></table></figure><p><strong>创建一个基本的路由配置：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> baseRoutes = [  </span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/login&#x27;</span>, <span class="attr">component</span>: Login &#125;,  </span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/404&#x27;</span>, <span class="attr">component</span>: NotFound &#125;  </span><br><span class="line">]  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;  </span><br><span class="line">  routes: baseRoutes  </span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><p><strong>创建权限路由：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> authRouter = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/admin&#x27;</span>, <span class="attr">component</span>: AdminPanel, <span class="attr">meta</span>: &#123; <span class="attr">auth</span>: <span class="string">&#x27;AdminPanel&#x27;</span>&#125; &#125;,  </span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/admin/dashboard&#x27;</span>, <span class="attr">component</span>: AdminDashboard, <span class="attr">meta</span>: &#123; <span class="attr">auth</span>: <span class="string">&#x27;AdminDashboard&#x27;</span> &#125; &#125;,</span><br><span class="line">]</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> authRouter</span><br></pre></td></tr></table></figure><p><strong>使用addRoutes方法添加动态路由：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> authRouter <span class="keyword">from</span> <span class="string">&#x27;./authRouter&#x27;</span></span><br><span class="line"><span class="comment">// 根据用户权限获取权限路由</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAuthRoutes</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> authRouter.filter(<span class="function"><span class="params">item</span> =&gt;</span> store.state.auth[item.meta.auth])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据用户权限动态添加路由  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addDynamicRoutes</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> authRoutes = getAuthRoutes()</span><br><span class="line">  <span class="comment">// 确保总是有一个通配符路由指向404页面  </span></span><br><span class="line">  router.addRoutes([  </span><br><span class="line">    ...authRoutes</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;*&#x27;</span>, <span class="attr">redirect</span>: <span class="string">&#x27;/404&#x27;</span> &#125;  </span><br><span class="line">  ]); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局路由守卫拦截判断是否获取获取用户权限，拿到权限后调用addDynamicRoutes()方法添加动态路由</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>在Vue.js中，当页面刷新时，Vue Router会重新加载路由配置，并且只会加载在初始化时定义的路由（即在创建<code>router</code>实例时通过<code>routes</code>选项传入的路由）。动态添加的路由在页面刷新后会丢失，因为它们是在运行时通过<code>addRoutes</code>方法添加到路由表中的。</p><p>如果你希望在页面刷新后仍然保留动态添加的路由，你需要将这些路由持久化到某种存储机制中，并在应用启动时从该存储中恢复它们。</p><p>或者全局路由守卫拦截判断是否获取用户权限，拿到权限后动态添加权限路由；用户权限数据存储在store里不做持久化存储，每次刷新重新拿取用户权限数据进而实现重新添加动态路由。</p><h3 id="如何避免刷新页面二次加载路由"><a href="#如何避免刷新页面二次加载路由" class="headerlink" title="如何避免刷新页面二次加载路由"></a>如何避免刷新页面二次加载路由</h3><p>1、window.location.reload()</p><p>2、新创建的router的matcher替换旧的路由matcher</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createRouter = <span class="function">() =&gt;</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  <span class="comment">// mode: &#x27;history&#x27;, // require service support</span></span><br><span class="line">  scrollBehavior: <span class="function">() =&gt;</span> (&#123; <span class="attr">y</span>: <span class="number">0</span> &#125;),</span><br><span class="line">  routes: constantRouterMap</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = createRouter()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detail see: https://github.com/vuejs/vue-router/issues/1234#issuecomment-357941465</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resetRouter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newRouter = createRouter()</span><br><span class="line">  <span class="comment">// matcher包含了关于路径匹配的所有信息</span></span><br><span class="line">  router.matcher = newRouter.matcher <span class="comment">// reset router</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="vuex刷新数据会丢失吗"><a href="#vuex刷新数据会丢失吗" class="headerlink" title="vuex刷新数据会丢失吗"></a>vuex刷新数据会丢失吗</h3><p>会丢失。vuex的数据是保存在运行内存中的，页面刷新会重新加载vue实例，vuex数据会重新进行初始化。</p><p>解决：</p><p>1、把数据保存在浏览器中cookie, sessionStorage, localStorage</p><p>2、页面刷新的时候再次请求数据达到动态更新</p><p>3、页面刷新前保存数据到本地，初始化state数据从本地存储里获取：<code>beforeunload</code>事件在即将卸载页面（即刷新或关闭页面）时触发，<code>beforeunload</code>事件存储vuex数据</p><h3 id="watch和computed有什么区别？"><a href="#watch和computed有什么区别？" class="headerlink" title="watch和computed有什么区别？"></a>watch和computed有什么区别？</h3><p>watch:</p><ol><li><p>watch 是观察的作用，类似于某些数据的监听回调，可以监听data数据和计算属性</p></li><li><p>无缓存性，页面重新渲染时，即使值没有改变也执行</p></li><li><p>能调用异步函数。</p></li></ol><p>computed：</p><ol><li><p>计算属性，用于计算值等场景</p></li><li><p>computed的值具有缓存性，computed的值在getter执行后是会缓存的，只有它依赖的属性值改变后，下一次获取computed的值才会重新调用getter来计算。</p></li><li><p>computed适用于计算比较消耗性能的计算场景</p></li><li><p>不能调用异步函数。</p></li></ol><p>如果需要基于已有的数据进行计算并缓存结果，那么应该使用<code>computed</code>。而如果需要监听数据的变化并在变化时执行某些操作，那么应该使用<code>watch</code>。</p><h3 id="vuex什么场景使用，属性有哪些？"><a href="#vuex什么场景使用，属性有哪些？" class="headerlink" title="vuex什么场景使用，属性有哪些？"></a>vuex什么场景使用，属性有哪些？</h3><p>vuex用来组件间进行通信。使用场景：用户的个人信息管理模块、购物车模块、订单模块</p><p>vuex属性：</p><ul><li>state：是应用程序中所有组件的状态集合，存储变量</li><li>getters：基于state的计算属性，用于逻辑复杂计算</li><li>mutations：用于提交更改state，同步函数</li><li>actions：类似事件，可以提交mutations来修改state，可以异步操作</li><li>modules：将state分割成模块，每个模块都有state、getters、mutations、actions，使得代码更加模块化和清晰易懂。</li></ul><h3 id="资源提示符"><a href="#资源提示符" class="headerlink" title="资源提示符"></a>资源提示符</h3><p>Script标签:</p><ul><li>defer：边解析HTML文档边下载脚本，解析HTML文档完成后执行脚本；严格按照顺序执行脚本</li><li>async：边解析HTML文档边下载脚本，脚本下载完成后立即执行脚本，然后继续解析文档；因为是下载完成后立即执行，和脚本下载事件有关，所以脚本执行顺序不一致</li></ul><p>link标签：preload和prefetch都是浏览器优化资源加载的机制</p><ul><li>preload：允许浏览器在解析HTML文档时，提前加载资源并缓存那些当前页面需要的资源。</li><li>prefetch：利用浏览器的空闲时间来加载页面将来可能需要的资源的机制。</li></ul><p>Preload和Prefetch的主要区别在于它们加载资源的时机和目的。Preload是在页面渲染过程中提前加载并缓存当前页面需要的资源，以提高页面的渲染速度和性能；而Prefetch则是在浏览器空闲时加载并缓存页面将来可能需要的资源，以提高后续页面的加载速度。这两种机制可以相互结合使用，以最大程度地优化页面的加载速度和性能。</p><h3 id="vue的双向数据绑定的原理"><a href="#vue的双向数据绑定的原理" class="headerlink" title="vue的双向数据绑定的原理"></a>vue的双向数据绑定的原理</h3><p>vue的双向数据绑定是通过数据劫持和发布-订阅模式实现的。劫持和监听所有属性的变动，数据有变动时，触发setter，去通知相关订阅者进行更新。</p><p>实现一个Observer类，递归遍历data，劫持和监听所有属性的变化。数据变动时，触发setter，通知依赖进行更新</p><p>实现一个解析器Compile，解析指令，替换页面中所有变量为数据，初始化渲染页面视图；并对指令的对应节点的绑定相应的更新函数，添加监听数据的订阅者，一旦有变动就进行更新</p><p>实现一个Dep依赖收集起为每个属性设置对应的Dep实例，存储订阅者</p><p>依赖是vue实例、组件中的属性、模版中的表达式等，将依赖抽象为Watcher进行管理，Watcher作为Observer和Compile之间通信的桥梁，可以订阅每个属性的变动，执行绑定的回调函数，从而更新视图。</p><p>整个流程为Data数据通过Observer转换为setter/getter形式来追踪变化，当外界通过Watcher读取数据时，会触发getter从而将watcher添加到依赖中。<br>当数据发生变化，会触发setter，从而向Dep中的依赖（Watcher）发送通知。<br>Watcher接收到通知后，会向外界发送通知，变化通知到外界可能会触发视图更新，也有可能触发用户某个回调函数。</p><h3 id="diff算法和虚拟dom"><a href="#diff算法和虚拟dom" class="headerlink" title="diff算法和虚拟dom"></a>diff算法和虚拟dom</h3><p>虚拟dom，描述元素与元素之间的关系，是一个js对象</p><p>组件内响应式数据，数据变动时，render函数会重新生成一个新的虚拟dom，新的虚拟dom和旧的虚拟dom进行比对，算出最小量更新，最后反映在真实dom上。</p><p>数据更新-&gt;虚拟dom计算变更-&gt;操作真实的dom-&gt;视图更新</p><p>虚拟DOM 表现为一个 Object对象。并且最少包含标签名 (tag)、属性 (attrs) 和子元素对象 (children) 三个属性</p><p>diff算法就是进行虚拟节点对比，并返回一个patch对象，用来存储两个节点不同的地方，最后用patch记录的消息去局部更新Dom。通俗的讲就是：diff的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的DOM打补丁</p><p>通过diff算法比较 新 旧 两个VDOM，将不同的地方进行修改，相同的地方就地复用，最后再通过render函数渲染页面。</p><p><strong>diff算法：</strong></p><p>key是节点的唯一标识，用来表明新旧节点是否同一个dom</p><p>只比对同一层级，不跨级比较</p><p>只有是同一个虚拟节点才比对，不是直接暴力删除生成并插入新dom</p><p>过程：</p><ul><li>调用patch函数，判断oldVnode是不是虚拟节点，不是转换为虚拟节点</li><li>判断oldVnode和vnode是否是同一节点（元素选择器相同且key相同），如果不是，则创建新的节点并删除旧的节点</li><li>是同一个虚拟节点进行精细比较，调用patchVnode函数判断oldVnode和vnode是否指向同一个对象，是则直接返回</li><li>如果oldVnode和vnode都有文本节点且不相同，vnode的文本节点设置为真实dom的文本节点</li><li>如果oldVnode有子节点，vnode没有，删除真实dom对应子节点</li><li>如果oldVnode没有子节点，vnode有，将vnode的子节点真实化后添加到真实dom</li><li>如果oldVnode和vnode都有子节点则执行updateChildren函数比较子节点</li></ul><p>diff比较同级节点：为保证dom顺序和新节点保持一致采用while循环和首尾节点进行比较，给oldVnode和vnode节点数组设置开始结束索引，遍历的过程往中间移动。这样既能实现排序也减小了时间复杂度。两节点比较，有四种比对方式：</p><p>oldStartIndex —&gt; newEndIndex</p><p>oldEndIndex —&gt; newStartIndex</p><p>oldStartIndex —&gt; newStartIndex</p><p>oldEndIndex —&gt; newEndIndex</p><p>如果oldStartIndex和newEndIndex匹配，则将真实dom的第一个元素移动到最右；</p><p>如果oldEndIndex和newStartIndex匹配，则将真实dom的最后一个元素移动到最左；</p><p>匹配过程指针中间移动，直到while循环结束</p><p>如果四种方式都没有匹配，那么：</p><ul><li>遍历vnode数组，在oldVnode用key进行查找</li><li>如果没有找到，当前节点是新节点，创建对应dom元素并插入到真实dom</li><li>如果找到，判断选择器是否相同<ul><li>如果相同：说明是同一个节点，移动到dom元素的最左边</li><li>如果不同，不是一个节点，创建对应的dom元素并插入到真实dom树中</li></ul></li><li>循环结束后，判断oldVnode和vnode是否有剩余：<ul><li>oldVnode有剩余，说明节点被删除，找到dom删除对应节点</li><li>vnode有剩余，说明节点是新增的，则将剩余子节点真实化后添加到真实dom</li></ul></li></ul><h3 id="a链接下载文件"><a href="#a链接下载文件" class="headerlink" title="a链接下载文件"></a>a链接下载文件</h3><p>一、a链接下载文件地址，服务器设置响应头Content-Disposition为attachment告诉浏览器该文件应该被视为附件并进行下载，而不是直接在浏览器中打开。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;/download&quot;</span>&gt;点击下载&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器设置</span></span><br><span class="line">res.setHeader(<span class="string">&#x27;Content-Disposition&#x27;</span>, <span class="string">`attachment; filename=<span class="subst">$&#123;fileName&#125;</span>`</span>); </span><br></pre></td></tr></table></figure><p>二、a链接使用HTML的<code>download</code>属性。<code>download</code>属性告诉浏览器该链接是用于下载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;/path/to/file.ext&quot;</span> download=<span class="string">&quot;file.ext&quot;</span>&gt;点击下载&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>download</code>属性只在同源文件下载时有效。如果尝试跨域下载文件，或者从第三方平台下载文件（例如微信公众号资源图片），浏览器将不会执行下载操作，而是尝试打开或显示该文件。</p><p>三、通过接口请求文件下载，需要传递token验证权限情况</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设你的服务器端点是 /api/download  </span></span><br><span class="line">fetch(<span class="string">&#x27;/api/download&#x27;</span>, &#123;  </span><br><span class="line">  method: <span class="string">&#x27;GET&#x27;</span>, <span class="comment">// 或者 &#x27;POST&#x27;，取决于你的服务器端点要求  </span></span><br><span class="line">  mode: <span class="string">&#x27;cors&#x27;</span>, <span class="comment">// 允许跨域请求  </span></span><br><span class="line">  credentials: <span class="string">&#x27;include&#x27;</span> <span class="comment">// 如果需要发送cookies  </span></span><br><span class="line">&#125;)  </span><br><span class="line">.then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;  </span><br><span class="line">  <span class="comment">// 检查响应状态  </span></span><br><span class="line">  <span class="keyword">if</span> (!response.ok) &#123;  </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Network response was not ok&#x27;</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 由于安全限制，浏览器不会直接处理文件下载，因此我们需要创建一个Blob对象  </span></span><br><span class="line">  <span class="comment">// 并使用URL.createObjectURL()来生成一个指向该Blob的URL，然后创建一个a标签来下载  </span></span><br><span class="line">  <span class="keyword">return</span> response.blob();  </span><br><span class="line">&#125;)  </span><br><span class="line">.then(<span class="function"><span class="params">blob</span> =&gt;</span> &#123;  </span><br><span class="line">  <span class="keyword">const</span> url = <span class="built_in">window</span>.URL.createObjectURL(blob);  </span><br><span class="line">  <span class="keyword">const</span> a = <span class="built_in">document</span>.createElement(<span class="string">&#x27;a&#x27;</span>);  </span><br><span class="line">  a.href = url;  </span><br><span class="line">  a.download = <span class="string">&#x27;filename.ext&#x27;</span>; <span class="comment">// 设置下载的文件名  </span></span><br><span class="line">  a.style.display = <span class="string">&#x27;none&#x27;</span>;  </span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(a);  </span><br><span class="line">  a.click();  </span><br><span class="line">  <span class="built_in">window</span>.URL.revokeObjectURL(url); <span class="comment">// 释放URL对象  </span></span><br><span class="line">  <span class="built_in">document</span>.body.removeChild(a); <span class="comment">// 清理a标签  </span></span><br><span class="line">&#125;)  </span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;  </span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">&#x27;There was a problem with the fetch operation:&#x27;</span>, error);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意这种下载文件方式，要浏览器先传输文件到内存中，再触发下载到本地，如果文件过大会占用浏览器大量内存，且等待一段时间才触发下载弹出下载保存窗口。</p><p>四、解决需要验证权限的文件下载</p><p>先发送请求服务器返回set-cookie，浏览器保存在本地，再创建a标签下载文件，a标签会自动携带cookie，服务器验证通过后将文件传输直接触发文件下载，从网络IO变为文件IO，不经过浏览器，下载更快</p><h3 id="设计私有属性"><a href="#设计私有属性" class="headerlink" title="设计私有属性"></a>设计私有属性</h3><p>1、通常约定在属性名称前加上一个下划线<code>_</code></p><p>2、使用Symbol类型来创建一个唯一的、不可变的属性键</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PRIVATE_ATTR = <span class="built_in">Symbol</span>(<span class="string">&#x27;privateAttr&#x27;</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;  </span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;  </span><br><span class="line">    <span class="built_in">this</span>[PRIVATE_ATTR] = <span class="literal">null</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">setPrivateAttr</span>(<span class="params">value</span>)</span> &#123;  </span><br><span class="line">    <span class="built_in">this</span>[PRIVATE_ATTR] = value;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">getPrivateAttr</span>(<span class="params"></span>)</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>[PRIVATE_ATTR];  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 使用示例  </span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> MyClass();  </span><br><span class="line">obj.setPrivateAttr(<span class="string">&#x27;hello&#x27;</span>);  </span><br><span class="line"><span class="built_in">console</span>.log(obj.getPrivateAttr()); <span class="comment">// 输出: hello  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 尝试直接访问私有属性会失败  </span></span><br><span class="line"><span class="comment">// console.log(obj.PRIVATE_ATTR); // undefined</span></span><br><span class="line"><span class="comment">// 但是可以通过Object.getOwnPropertySymbols()方法获取</span></span><br></pre></td></tr></table></figure><p>3、es6中在属性名称前加<code>#</code></p><p>4、使用对象weakmap：WeakMap允许你存储对象的私有数据，这些数据只能通过WeakMap本身来访问</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> privateData = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;  </span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;  </span><br><span class="line">    privateData.set(<span class="built_in">this</span>, &#123; <span class="attr">privateAttr</span>: <span class="literal">null</span> &#125;);  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">setPrivateAttr</span>(<span class="params">value</span>)</span> &#123;  </span><br><span class="line">    <span class="keyword">const</span> data = privateData.get(<span class="built_in">this</span>);  </span><br><span class="line">    data.privateAttr = value;  </span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">getPrivateAttr</span>(<span class="params"></span>)</span> &#123;  </span><br><span class="line">    <span class="keyword">const</span> data = privateData.get(<span class="built_in">this</span>);  </span><br><span class="line">    <span class="keyword">return</span> data.privateAttr;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 使用示例  </span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> MyClass();  </span><br><span class="line">obj.setPrivateAttr(<span class="string">&#x27;hello&#x27;</span>);  </span><br><span class="line"><span class="built_in">console</span>.log(obj.getPrivateAttr()); <span class="comment">// 输出: hello  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 尝试直接访问私有属性会失败  </span></span><br><span class="line"><span class="comment">// console.log(obj.privateAttr); // undefined</span></span><br></pre></td></tr></table></figure><p>5、使用ts的private声明定义变量</p><p>6、使用闭包和弱引用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个只能在类的实例内部访问的属性。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">  <span class="comment">// 私有属性  </span></span><br><span class="line">  <span class="keyword">let</span> _privateAttr = <span class="literal">null</span>;  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 公共方法  </span></span><br><span class="line">  <span class="built_in">this</span>.setPrivateAttr = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;  </span><br><span class="line">    _privateAttr = value;  </span><br><span class="line">  &#125;;  </span><br><span class="line">  </span><br><span class="line">  <span class="built_in">this</span>.getPrivateAttr = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> _privateAttr;  </span><br><span class="line">  &#125;;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 使用示例  </span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> MyClass();  </span><br><span class="line">obj.setPrivateAttr(<span class="string">&#x27;hello&#x27;</span>);  </span><br><span class="line"><span class="built_in">console</span>.log(obj.getPrivateAttr()); <span class="comment">// 输出: hello  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 尝试直接访问私有属性会失败  </span></span><br><span class="line"><span class="comment">// console.log(obj._privateAttr); // undefined</span></span><br></pre></td></tr></table></figure><h3 id="vuex是如何实现响应式的？"><a href="#vuex是如何实现响应式的？" class="headerlink" title="vuex是如何实现响应式的？"></a>vuex是如何实现响应式的？</h3><p>在 Vuex 中，state 对象在初始化时被递归地应用了 Object.defineProperty()，将其属性转换为 getter/setter，从而使得当 state 中的数据发生变化时，Vue 能够感知到这些变化并触发相应的更新。</p><p>需要注意的是，Vuex 的 state 中的数据必须是提前定义好的初始化属性，动态添加的属性是无法保证响应式的。如果需要动态添加属性，可以使用 Vue.set(obj, key, value) 方法或者通过创建一个新的对象来替换旧的对象。</p><h3 id="如何封装一个组件"><a href="#如何封装一个组件" class="headerlink" title="如何封装一个组件"></a>如何封装一个组件</h3><ul><li>定义组件，包含模版、脚本、样式</li><li>注册组件：<ul><li>全局注册：main.js文件引入组件，Vue.components(‘Child’, Child)</li><li>局部注册：父组件引入组件，components选项配置</li></ul></li><li>使用组件：组件模版中直接使用组件<code>&lt;Child /&gt;</code></li><li>传递数据：<ul><li>父向子传值：通过props属性</li><li>子与父通信：子组件$emit事件与父组件通信</li></ul></li><li>插槽：可以在组件模版中插入内容</li></ul><h3 id="如何搭建一个脚手架？"><a href="#如何搭建一个脚手架？" class="headerlink" title="如何搭建一个脚手架？"></a>如何搭建一个脚手架？</h3><ul><li>安装nodejs、npm、vue-cli <code>npm install -g @vue/cli</code></li><li>命令创建vue项目：<code>vue create my-project</code></li><li>选择预设配置</li><li>安装依赖</li><li>启动开发服务器</li></ul><h3 id="如何封装一个可复用的组件？"><a href="#如何封装一个可复用的组件？" class="headerlink" title="如何封装一个可复用的组件？"></a>如何封装一个可复用的组件？</h3><ul><li>简洁的API提供清晰的props和events作为输入和输出，避免直接操作父组件的状态或子组件的数据；</li><li>良好的文档和示例；</li><li>无副作用不依赖于外部的全局状态或变量；避免修改全局状态；</li><li>良好的错误处理；</li><li>组件尽可能独立，不依赖于其他特定组件或库；</li><li>随着项目的发展和需求的变化持续进行维护；</li><li>考虑扩展性比如提供插槽或mixins使组件更加灵活和可扩展；</li><li>提供默认样式组：但也要允许通过CSS变量或自定义类名来覆盖这些样式</li></ul><h3 id="首屏优化怎么做？"><a href="#首屏优化怎么做？" class="headerlink" title="首屏优化怎么做？"></a>首屏优化怎么做？</h3><ul><li>使用路由懒加载</li><li>非首屏组件使用异步组件</li><li>首屏不重要的组件延迟加载</li><li>静态资源放cdn上</li><li>减少首屏js、css等资源文件的大小</li><li>使用服务端渲染</li><li>使用精灵图和base64图减少http请求</li><li>开启gzip压缩</li><li>图片懒加载</li><li>做loading动画优化用户体验</li></ul><h3 id="vue3性能为什么比vue2好？"><a href="#vue3性能为什么比vue2好？" class="headerlink" title="vue3性能为什么比vue2好？"></a>vue3性能为什么比vue2好？</h3><p>基于proxy的响应式系统提供了更精细的控制和更好的性能</p><p>vue3对模版编译器和运行时进行了重构和优化，减少了库的体积，提高了加载速度。</p><p>Vue 3 中的编译器增加了更多的编译时优化，包括模板中静态节点的标记、事件处理函数的缓存等：</p><ul><li>静态节点标记：vue3在编译阶段就将静态节点提取出来，并在运行时使用，避免了不必要的渲染。</li><li>事件处理函数的缓存：vue3的编译器会识别出不依赖于响应式数据的事件处理函数，并将他们缓存起来，以避免每次渲染时都重新创建分配内存</li></ul><p>diff算法优化：</p><ul><li>静态节点提升：在编译阶段将静态节点提取出来，在运行时不需要参与diff算法比对，减少了需要比较的节点数量</li></ul><h3 id="vue3为什么使用proxy？"><a href="#vue3为什么使用proxy？" class="headerlink" title="vue3为什么使用proxy？"></a>vue3为什么使用proxy？</h3><p><strong>更全面的数据劫持</strong>：</p><p>Proxy 可以劫持整个对象，而不仅仅是对象的属性。这意味着无论对象如何变化（例如属性的添加、删除或修改），Proxy 都能捕捉到这些变化，并触发相应的响应。相比之下，Object.defineProperty 只能劫持已经存在的属性，对于新增或删除的属性无法感知。</p><p><strong>数组的支持</strong>：</p><p>Proxy 对数组的支持更好。在 Vue 2 中，为了实现对数组方法的劫持，不得不通过重写数组原型上的方法来实现。这样做不仅增加了代码的复杂性，而且可能引发一些不易察觉的问题。而 Proxy 可以直接监听数组的变化，无需额外处理。</p><h3 id="对组件的理解"><a href="#对组件的理解" class="headerlink" title="对组件的理解"></a>对组件的理解</h3><p>可复用的vue实例，拥有完整的生命周期，接收特定的输入以产生输出。</p><p>组件的目的就是将UI划分出可独立的、可复用的部分，使代码可维护提高开发效率。</p><h3 id="nuxtjs"><a href="#nuxtjs" class="headerlink" title="nuxtjs"></a>nuxtjs</h3><p>是基于vuejs的框架，关注的是应用的ui渲染。它预设了使用vuejs开发服务端渲染应用所需的各种配置。并提供了<code>nuxt generate</code>命令对基于vuejs的应用生成静态站点的功能。</p><p>优点：</p><ul><li>基于服务端ssr渲染：生成的带有html的内容，有利于搜索引擎的搜索，并优化了首屏加载时间</li><li>强大的路由管理，开发者可以实现单页应用（SPA）和多页应用（MPA）之间的无缝切换</li><li>Nuxt.js还支持异步数据加载、中间件、布局、EcmaScript6和EcmaScript7的语法</li></ul><h3 id="渲染方式"><a href="#渲染方式" class="headerlink" title="渲染方式"></a>渲染方式</h3><p>客户端渲染：用户访问url，请求html文件，前端根据路由动态渲染页面内容，关键链路较长，有一定的白屏时间</p><p>服务端渲染：用户访问url，服务端根据访问路径请求所需数据，拼接成html字符串，返回给前端，前端接收到html已有部分内容</p><p>预渲染：构建阶段生成匹配预渲染路径的html文件（每个需要预渲染的路由都有一个对应的 html），构建处理的html已有部分内容</p><p>服务端渲染：发送请求-服务器请求数据渲染html-包含首屏的html</p><p>预渲染：发送请求-包含首屏的html</p><p>客户端渲染：发送请求-html-js加载并动态渲染</p><h3 id="工作中遇到的难题"><a href="#工作中遇到的难题" class="headerlink" title="工作中遇到的难题"></a>工作中遇到的难题</h3><p>开发app对接高德地图，实现员工当天轨迹图展示，配置好权限和key后，发现真机运行正常，打包到测试机上运行其他页面正常，轨迹图页面白屏（android）。</p><p>android studio真机运行，排查后发现缺少高德地图的依赖库，导致页面白屏，下载最新依赖并引入后，仍然存在问题；<br>初步排查是离线打包配置及相关文件和最新依赖资源版本不匹配的原因，重新创建android/ios原生工程，进行基础库和应用配置，完成后再次打包地图页面正常。得出结论依赖库版本和工程相关配置及文件相关联，需要同步配置。</p><p>接着根据需求，绘制员工轨迹图，且缩放视野以包含所有给定的坐标点（include-points， markers， polyline），发现android地图标记点气泡消失，经排查发现缩放过程中地图放大再移动到某个标记点后，标记点气泡消失，缩小后气泡又出现；因ios版本正常，确定非api使用问题，社区上报bug并证实是官方bug。</p><h3 id="will-change"><a href="#will-change" class="headerlink" title="will-change"></a>will-change</h3><p>will-change是CSS中的一个属性，用于提前通知浏览器哪些元素的属性即将发生变化，以便浏览器能提前做好对应的优化准备工作，提高浏览器的页面渲染性能。有助于避免元素属性变化时导致页面卡顿失帧等交互体验不佳的问题。此外，当元素的属性变化完成后，应尽快移除will-change属性，以避免不必要的性能损耗。</p><h3 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h3><ol><li><p><strong>数据请求封装</strong>：<br>在小程序中，我会使用内置的<code>wx.request</code> API来进行网络通信。封装时，我会创建一个单独的服务模块或类，统一处理所有HTTP请求，便于管理和维护。示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// request.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  wx.showLoading(&#123; <span class="attr">title</span>: <span class="string">&#x27;加载中...&#x27;</span> &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    wx.request(&#123;</span><br><span class="line">      ...options,</span><br><span class="line">      success: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        wx.hideLoading();</span><br><span class="line">        resolve(res.data);</span><br><span class="line">      &#125;,</span><br><span class="line">      fail: <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        wx.hideLoading();</span><br><span class="line">        reject(err);</span><br><span class="line">      &#125;,</span><br><span class="line">      complete: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此基础上，可以增加错误处理、重试机制、缓存策略（如对GET请求结果做本地缓存）以及拦截器的设计，比如在请求前后执行通用操作。</p></li><li><p><strong>参数传递方法</strong>：<br>小程序中页面间的参数传递主要有以下方式：</p><ul><li>在<code>wx.navigateTo</code>、<code>wx.redirectTo</code>或<code>wx.switchTab</code>等路由跳转API中，可以在<code>options</code>对象中加入<code>params</code>字段，用于传递JSON格式的参数。</li><li>也可以在URL后面附加query参数，如<code>wx.navigateTo(&#123;url: &#39;../targetPage/index?param1=value1&amp;param2=value2&#39;&#125;)</code>，在目标页面的<code>onLoad</code>生命周期函数中通过<code>options.query</code>获取。</li></ul></li><li><p><strong>性能优化</strong>：</p><ul><li>使用分包加载，将大的小程序拆分为多个子包，按需加载，提高首屏加载速度。</li><li>对于静态资源如图片，使用CDN加速，并合理设置缓存策略，如<code>&lt;image src=&quot;&quot; mode=&quot;aspectFit&quot; lazy-load/&gt;</code>实现图片懒加载。</li><li>减少不必要的网络请求，合并多次请求为一次，合理利用缓存，避免重复获取数据。</li><li>优化布局，尽量减少层级过深的嵌套，运用flex布局减少布局计算消耗。</li><li>对频繁变动的部分采用虚拟列表等技术优化渲染性能。</li></ul></li><li><p><strong>小程序优点</strong>：</p><ul><li>即点即用，无需下载安装，易于推广和分享。</li><li>离线缓存能力强，用户体验好，加载速度快。</li><li>提供丰富的API接口，如地理位置、支付、授权等，方便构建完整的业务闭环。</li><li>与微信生态深度融合，可以便捷地实现微信账号体系登录、微信支付、社交分享等功能。</li></ul></li><li><p><strong>小程序缺点</strong>：</p><ul><li>平台兼容性差，无法在非微信环境下运行。</li><li>分发渠道相对单一，依赖微信平台，传播受到一定限制。</li><li>生态系统相对封闭，与Web标准有一定的差异，代码难以复用到其他平台。</li></ul></li><li><p><strong>WXML与HTML的差异</strong>：</p><ul><li>WXML是微信小程序自定义的一种标记语言，它类似HTML，但提供了微信特有的标签，如<code>wx:if</code>用于条件渲染，<code>wx:for</code>用于列表渲染，数据绑定采用<code>&#123;&#123; &#125;&#125;</code>语法而非HTML的data-*属性。</li><li>WXML不支持所有HTML标签，但提供了与小程序功能紧密相关的标签，如<code>&lt;view&gt;</code>代替<code>&lt;div&gt;</code>，<code>&lt;button&gt;</code>支持开放能力等。</li></ul></li><li><p><strong>小程序生命周期</strong>：</p><ul><li>onLoad：页面加载时触发，此时可以做一些初始化工作，如从服务器获取数据。</li><li>onShow：页面显示/切回来时触发，每次打开页面都会调用，可用来处理页面显示相关逻辑。</li><li>onReady：页面初次渲染完成时触发，此时可以获取到页面的一些DOM信息。</li><li>onHide：页面从前台切换到后台时触发，可以在此时清除定时器，保存数据等。</li><li>onUnload：页面卸载时触发，用于清理页面资源。</li></ul></li><li><p><strong>登录流程</strong>：</p><ul><li>用户首先点击登录按钮，触发<code>wx.login</code>获取临时登录凭证（code）。</li><li>将code传送到服务器，服务器调用微信接口换取用户的唯一标识（openid）和session_key。</li><li>若需要用户信息，调用<code>wx.getUserInfo</code>并获取用户同意授权后得到加密的用户信息。</li><li>服务器解密用户信息，并结合openid和session_key生成自定义的token，返回给客户端进行后续身份验证和鉴权。</li></ul></li><li><p><strong>页面下拉刷新与上拉加载</strong></p><ul><li>下拉刷新：在页面json文件或Page构造器的options中设置<code>enablePullDownRefresh</code>为true，然后在Page的<code>onPullDownRefresh</code>方法中发起数据更新请求，请求完成后调用<code>wx.stopPullDownRefresh()</code>结束刷新动画。</li><li>上拉加载更多：在Page中监听<code>onReachBottom</code>事件，当页面滚动到底部时触发该事件，执行获取更多数据的逻辑。</li></ul></li><li><p><strong>组件化开发</strong></p><ul><li>在小程序中，创建自定义组件需在components目录下创建一个文件夹，包含index.wxml、index.wxss、index.js和index.json四个文件。</li><li>在index.js中定义组件，通过properties接受外部传入的props，通过setData更新组件内部数据，并在wxml中绑定数据和事件。</li><li>外部页面使用自定义组件时，如同普通标签一样引用，并通过属性传递数据给组件。组件内部事件通过<code>this.triggerEvent</code>触发，外部页面通过catchEvent接收。</li></ul></li></ol><h3 id="小程序底层"><a href="#小程序底层" class="headerlink" title="小程序底层"></a>小程序底层</h3><p>小程序的底层实现通常是指其运行环境和架构设计。以微信小程序为例，其底层架构主要特点包括以下几个方面：</p><ol><li><p><strong>双线程模型</strong>：</p><ul><li><p><strong>逻辑层（App Service）</strong>：小程序的业务逻辑层运行在一个独立的JsCore线程中，这个线程并不直接访问或操作DOM，从而保证了更高的安全性。在此环境中，开发者编写的所有业务逻辑、数据处理、网络请求等均在此线程上执行。</p></li><li><p><strong>渲染层（View Layer）</strong>：负责界面渲染，基于WebView组件，在不同的WebView线程中执行。每个小程序页面都有对应的WebView实例来渲染界面。由于没有直接暴露DOM API，而是通过一套自定义的视图层描述语言（WXML、WXSS）来构建界面。</p></li></ul></li><li><p><strong>通信机制</strong>：逻辑层与渲染层之间通过系统提供的WeixinJsBridge（或称JSBridge）进行通信。逻辑层会将处理后的数据发送给渲染层，触发界面更新；同时，渲染层的用户交互事件会被传递回逻辑层进行处理。</p></li><li><p><strong>框架特性</strong>：微信小程序框架基于浏览器内核重构，但剥离了DOM和BOM相关的API，提供了自己的API集，如setData方法用于更新视图。此外，还提供了丰富的组件库和API，支持调用微信的原生能力，如获取用户信息、支付、地理位置等功能。</p></li><li><p><strong>混合渲染</strong>：虽然渲染层基于WebView，但在实现上结合了Web渲染与Native渲染的优势，采取了一种Hybrid模式，部分功能调用原生模块来提升性能和用户体验。</p></li></ol><p>综上所述，小程序的底层设计兼顾了Web开发的便捷性和原生应用的性能优势，通过定制化的开发环境和框架体系来确保小程序具有轻量化、高性能的特点，并且易于接入特定平台（如微信）提供的丰富服务。随着技术发展，不同小程序框架可能会有不同的优化策略和技术路线，但核心思想基本围绕高效渲染、安全隔离以及灵活调用平台能力等方面展开。<br><strong>HTML：</strong></p><p>请解释HTML5的新特性及语义化标签的意义。</p><p>新特性：</p><p>多媒体支持：</p><p><code>&lt;audio&gt;</code> 和 <code>&lt;video&gt;</code> 标签允许直接在网页中嵌入音频和视频内容，无需第三方插件，提供了原生的播放控制功能。<br><code>&lt;canvas&gt;</code> 元素提供了在网页上进行图形绘制的能力，可以创建动态图形和游戏。<br><code>&lt;svg&gt;</code> 支持矢量图形，允许在网页中直接嵌入可缩放的矢量图形内容。</p><p>离线存储：</p><p>应用程序缓存（Application Cache，现已被Service Worker取代）允许Web应用程序在离线状态下依然可用。<br>IndexedDB 和 Web Storage（包括localStorage和sessionStorage）提供了持久化数据存储的方式。</p><p>Web Workers：</p><p>允许在后台线程中运行JavaScript，从而不会阻塞UI线程，提高复杂计算任务的性能。</p><p>Web Sockets：</p><p>实现了双向通信，使得服务器和客户端之间能够实时、全双工的数据传输。<br>地理定位：</p><p>Geolocation API 可以获取用户的地理位置信息。</p><p>表单控件增强：</p><p>新增了<code>&lt;input type=&quot;date&quot;&gt;</code>、<code>&lt;input type=&quot;time&quot;&gt;</code>、<code>&lt;input type=&quot;email&quot;&gt;</code>、<code>&lt;input type=&quot;url&quot;&gt;</code>、<code>&lt;input type=&quot;search&quot;&gt;</code>等类型的输入控件，提高了表单数据验证和用户输入体验。</p><p>语义化标签是为了增强HTML文档结构的逻辑性，使内容具有明确的意义，不仅帮助开发者组织文档，而且利于搜索引擎抓取和解析，提升可访问性和用户体验</p><h3 id="举例说明行内元素、块级元素和空元素，并解释其特点"><a href="#举例说明行内元素、块级元素和空元素，并解释其特点" class="headerlink" title="举例说明行内元素、块级元素和空元素，并解释其特点"></a>举例说明行内元素、块级元素和空元素，并解释其特点</h3><p>在HTML中，元素根据其显示方式和行为可以分为行内元素、块级元素和空元素.</p><ol><li>行内元素（Inline Elements）</li></ol><p>行内元素不会开始新的行，它们只会占据其内容本身的宽度和高度。行内元素通常用于表示文本或文本的一部分，例如链接、强调的文本等。</p><p>例子：<span> <a> <strong> <em></p><p>特点：</p><p>不会独占一行，和其他行内元素并排显示。<br>宽度和高度由内容决定，不能设置固定的宽高。<br>只能容纳文本或其他行内元素，不能包含块级元素。</p><ol><li>块级元素（Block Elements）</li></ol><p>块级元素会开始新的行，并尽可能占据其父元素的全部宽度。块级元素通常用于布局和结构化内容，例如段落、标题、列表等。</p><p>例子：<code>&lt;div&gt;</code> <code>&lt;p&gt;</code> <code>&lt;h1&gt;</code> <code>&lt;h6&gt;</code> <code>&lt;ul&gt;</code> <code>&lt;li&gt;</code></p><p>特点：</p><p>独占一行，垂直排列。<br>宽度默认为其父元素的100%，高度由内容决定。<br>可以设置宽度、高度、内外边距等样式属性。<br>可以包含其他块级元素和行内元素。</p><ol><li>空元素（Void Elements）</li></ol><p>空元素是指那些没有内容，只有起始标签的元素。它们通常用于表示那些不需要包含任何文本或其他元素的元素，例如换行符、图像等。</p><p>例子： <code>&lt;br&gt;``&lt;img&gt;``&lt;input&gt;``&lt;hr&gt;</code></p><p>特点：</p><p>只有起始标签，没有结束标签。<br>不能包含任何内容。<br>主要用于表示特定的功能或效果，例如换行、插入图像等。</p><p><strong>CSS：</strong></p><p>介绍一下CSS盒模型的不同类型（标准盒模型与IE盒模型）以及如何切换这两种模型。</p><p>标准盒模型（W3C盒模型）：</p><p>在标准盒模型中，width和height属性仅包含内容（content）的宽度和高度，即元素的实际内容所占的空间。内边距（padding）、边框（border）和外边距（margin）都不包括在width和height中。这意味着，如果你设置了一个元素的width和height，并且这个元素有内边距或边框，那么元素的实际显示尺寸会比你设定的尺寸大。</p><p>IE盒模型（怪异盒模型）：</p><p>在IE盒模型中，width和height属性则包含了内容、内边距和边框的总宽度和总高度。这意味着，如果你设置了一个元素的width和height，这个尺寸就包括了内容、内边距和边框，外边距则仍然不包括在内。因此，在IE盒模型中，元素的实际显示尺寸与你设定的尺寸一致，除非有外边距。</p><p>如何切换这两种模型：</p><p>在CSS3中，可以通过设置元素的box-sizing属性来切换盒模型。box-sizing属性有两个值：content-box和border-box。</p><p>当box-sizing设置为content-box时，使用的是标准盒模型。元素的width和height只包括内容的宽度和高度，内边距和边框会增加元素的实际显示尺寸。<br>当box-sizing设置为border-box时，使用的是IE盒模型。元素的width和height包括内容、内边距和边框的总宽度和总高度，元素的实际显示尺寸与你设定的尺寸一致。</p><h3 id="如何实现响应式布局？介绍几种常见的方法和技术"><a href="#如何实现响应式布局？介绍几种常见的方法和技术" class="headerlink" title="如何实现响应式布局？介绍几种常见的方法和技术"></a>如何实现响应式布局？介绍几种常见的方法和技术</h3><p>一套代码适应不同的屏幕尺寸。<br>1、百分比布局</p><p>百分比相对于包含块计算，元素的位置和尺寸由包含块决定，默认是最近祖先块元素的内容区域，width\top\bottom百分比值由包含块的width决定，height\left\right\margin\padding百分比值由包含块的height决定</p><p>2、媒体查询布局</p><p>通过@media 媒体查询，可以通过给不同屏幕的大小编写不同的样式来实现响应式的布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: aqua;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">1280px</span>) &#123;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">980px</span>) &#123;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">765px</span>) &#123;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>响应式缺点：如果浏览器大小改变时，需要改变的样式太多，那么多套样式代码会很繁琐。</p><p>3、rem 响应式布局</p><p>em 是相对于 html 根元素的字体大小的单位。</p><p>我们通过修改 html 中 font-size 的字体大小来控制 rem 的大小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123; <span class="attribute">font-size</span>: <span class="number">10px</span>;&#125;<span class="selector-class">.box</span> &#123; <span class="attribute">width</span>: <span class="number">10rem</span>; <span class="attribute">height</span>: <span class="number">20rem</span>;&#125;</span><br></pre></td></tr></table></figure><p>当 html 中 font-size: 10px; 时，此时 1rem = 10px，所以 box 盒子的宽高分别为：100px 和 200px;</p><p>当我们把 html 中 font-size: 20px; 时，此时 1rem = 20px,此时 box 盒子的宽高就为 200px 和 400px;</p><p>在实际的开发中，我们通常会以 750px 的移动端设计稿来开发。1rem = 75px</p><p>我们在代码写完后，统一会把所有 px 单位全部转成 rem 来实现.<br>js 动态修改 html 根元素的 font-size 的大小，能适配不同尺寸的屏幕</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">initPage()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initPage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clientWidth =</span><br><span class="line">    <span class="built_in">document</span>.documentElement.clientWidth || <span class="built_in">document</span>.body / clientWidth <span class="comment">//获取屏幕可视区宽</span></span><br><span class="line">  <span class="keyword">var</span> html = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;html&quot;</span>)[<span class="number">0</span>] <span class="comment">//获取html根元素</span></span><br><span class="line">  html.style.fontSize = clientWidth / <span class="number">10</span> + <span class="string">&quot;px&quot;</span> <span class="comment">//动态设置font-size大小</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onresize = initPage</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>flexible.js 原理就是根据不同的屏幕宽度动态的设置网页中 html 根节点的 font-size</p><p>4、vw 和 vh响应式布局<br>vw 和 vh 分别相对的是视图窗口的宽度和视图窗口的高度。<br>在宽为 750px 的设计稿下，把 px 转换为 vw，是用 px/7.5 得到对应的 vw 单位，即750px为100vw</p><p>5、flex 弹性布局</p><p>在父元素上，我们经常会用到的有关弹性布局的属性主要有 flex-direction , flex-wrap , justify-content , align-items , align-content ，这几个属性分别从 主轴的方向、是否换行、项目在主轴上的对齐方式、项目在交叉轴上的对齐方式、项目在多根轴线上的对齐方式来规范了项目在父元素中的弹性。</p><p>在子元素上，我们经常会用到的有关弹性布局的属性主要有 order , flex-grow , flex-shrink ,flex-basis , align-self ，这几个属性分别从 项目的排序、项目放大比例、项目缩小比例、项目占据主轴空间、单个项目在交叉轴上的对齐方式来规范了项目自身的弹性。</p><h3 id="实现数组去重的方法有哪些？"><a href="#实现数组去重的方法有哪些？" class="headerlink" title="实现数组去重的方法有哪些？"></a>实现数组去重的方法有哪些？</h3><p><strong>1、使用Set数据结构（ES6）：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> uniqueArray = [...new <span class="built_in">Set</span>(array)];</span><br></pre></td></tr></table></figure><p><strong>2、借助indexOf函数: indexOf() 方法返回数组中第一次出现给定元素的下标，如果不存在则返回 -1.</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> uniqueArray = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (uniqueArray.indexOf(array[i] === -<span class="number">1</span>)) &#123;</span><br><span class="line">    uniqueArray.push(array[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、借助filter方法:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> uniqueArray = array.filter(<span class="function">(<span class="params">element, index, self</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> self.indexOf(element) === -<span class="number">1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>4、利用reduce方法:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> uniqueArray = array.reduce(<span class="function">(<span class="params">calcResult, current</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!calcResult.includes(current)) &#123;</span><br><span class="line">    calcResult.push(current)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> calcResult</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure><p><strong>性能优化：</strong></p><p>如何提高网页加载速度和首屏渲染时间？<br>资源压缩</p><p>如何减少重绘和回流？请举例说明。</p><ol><li><strong>批量修改DOM和样式</strong>：</li></ol><ul><li>尽量将多个DOM操作集中在一起执行，而不是分散在不同的事件或者循环中逐个修改。例如：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的做法（每次循环都会引起回流）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line"> <span class="built_in">document</span>.getElementById(<span class="string">&#x27;list&#x27;</span>).style.height = i + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的做法（一次性设置，仅触发一次回流）</span></span><br><span class="line"><span class="keyword">let</span> newHeight;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line"> newHeight = i + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;list&#x27;</span>).style.height = newHeight;</span><br></pre></td></tr></table></figure><ol><li><strong>使用CSS类代替内联样式</strong>：</li></ol><ul><li>修改类名而不是直接修改元素样式，可以避免连续的样式变更引起的重绘。</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* CSS */</span></span><br><span class="line"><span class="selector-class">.hidden</span> &#123; <span class="attribute">display</span>: none; &#125;</span><br><span class="line"><span class="selector-class">.visible</span> &#123; <span class="attribute">display</span>: block; &#125;</span><br><span class="line"></span><br><span class="line">// <span class="selector-tag">JavaScript</span></span><br><span class="line">element.classList.add(&#x27;hidden&#x27;); // 更改类名而非 style.display</span><br></pre></td></tr></table></figure><ol><li><strong>避免不必要的布局信息查询</strong>：</li></ol><ul><li>查询布局信息（如offsetTop/Left、scrollWidth/Height等）也会触发回流。在不需要精确值时，考虑延后获取或使用MutationObserver观察变化。</li></ul><ol start="2"><li><strong>利用层叠上下文（Composite Layers）</strong>：</li></ol><ul><li>如果元素有独立动画，可以通过<code>will-change</code>属性或者3D变换（translateZ(0)）创建一个新的层，使得重绘只发生在单独的合成层上，不影响主文档流。</li></ul><ol start="3"><li><strong>使用CSS3硬件加速</strong>：</li></ol><ul><li>对于动画，使用transform和opacity属性，这两个属性的变化不会触发重排，只会触发重绘，并且可以被GPU硬件加速。</li></ul><ol start="4"><li><strong>虚拟DOM</strong>：</li></ol><ul><li>使用像React或Vue这样的现代前端框架，它们提供了虚拟DOM机制，只有当实际视图需要更新时才会对比并最小化地更新真实DOM，从而减少回流和重绘的发生。</li></ul><ol start="5"><li><strong>懒加载和异步更新</strong>：</li></ol><ul><li>对于不在可视区域内的图片或动态内容，延迟加载直到进入视窗再进行渲染，可以有效避免非必要的计算和渲染。</li></ul><ol start="6"><li><strong>分离读写操作</strong>：</li></ol><ul><li>如果既有读取又有修改DOM的操作，尽量先完成读取，然后集中进行写入，避免读写交错引起的多次回流。</li></ul><ol start="7"><li><strong>减少不必要的DOM节点数量</strong>：</li></ol><ul><li>减少冗余DOM节点和深度嵌套结构，特别是对于动态生成的内容，可以显著降低回流发生的频率和范围。</li></ul><p>通过上述方法和原则，可以有效地减少重绘和回流，从而提高页面的运行效率和用户交互体验。</p><h3 id="请解释前端资源懒加载和预加载的策略"><a href="#请解释前端资源懒加载和预加载的策略" class="headerlink" title="请解释前端资源懒加载和预加载的策略"></a>请解释前端资源懒加载和预加载的策略</h3><p>前端资源懒加载（Lazy Loading）和预加载（Preloading）是两种截然不同的资源加载策略，它们分别用于优化网页性能和用户体验：</p><p><strong>懒加载（Lazy Loading）</strong>：<br>懒加载是一种按需加载的技术，主要用于延后加载那些并非页面初始渲染所必需的资源，尤其是对于长页面或包含大量图片、视频等内容的网站尤其有用。具体来说，懒加载的做法包括但不限于：</p><ul><li><p>图片懒加载：当页面加载时，不是一次性加载所有图片，而是仅加载首屏可见区域的图片，其他图片在用户滚动到相应位置时才开始加载，从而减少初次加载的带宽消耗和时间成本。</p><ul><li>懒加载通常应用于图片、视频、Ajax请求等领域，通过监听滚动事件、 Intersection Observer API 等方式实现。<br>IntersectionObserver API用于监控dom元素是否进入可视区域或者与某个祖先元素的交叉状态</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> IntersectionObserver(<span class="function">(<span class="params">entries, observer</span>) =&gt;</span> &#123;</span><br><span class="line">  entries.forEach(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.isIntersecting) &#123; <span class="comment">// 如果元素进入了可视区域</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Element is now visible&#x27;</span>);</span><br><span class="line">      <span class="comment">// 在这里可以进行懒加载图片或其他资源的操作</span></span><br><span class="line">      loadImage(entry.target);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, &#123; <span class="attr">threshold</span>: <span class="number">0.5</span> &#125;); <span class="comment">// 设置阈值为0.5，表示当元素50%的部分进入视窗时触发回调</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察目标元素</span></span><br><span class="line">observer.observe(<span class="built_in">document</span>.querySelector(<span class="string">&#x27;#lazy-image&#x27;</span>));</span><br><span class="line"><span class="comment">// 动态加载图片</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImage</span>(<span class="params">imageElement</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 假设我们有一个数据结构存储了需要懒加载图片的真实URL</span></span><br><span class="line">  <span class="keyword">const</span> imageSources = &#123;</span><br><span class="line">    <span class="string">&#x27;lazy-image-1&#x27;</span>: <span class="string">&#x27;path/to/image1.jpg&#x27;</span>,</span><br><span class="line">    <span class="comment">// ...其他图片路径</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取该元素对应的图片源</span></span><br><span class="line">  <span class="keyword">let</span> src = imageSources[imageElement.id]; <span class="comment">// 这里假设元素id对应图片源的键名</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确保已经获取到图片源</span></span><br><span class="line">  <span class="keyword">if</span> (src) &#123;</span><br><span class="line">    <span class="comment">// 创建一个新的Image对象</span></span><br><span class="line">    <span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当图片加载完成时执行的回调函数</span></span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 图片加载成功后，将src属性赋给DOM元素</span></span><br><span class="line">      imageElement.src = src;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 可能还需要添加一些额外逻辑，比如显示加载完成后的效果</span></span><br><span class="line">      imageElement.classList.remove(<span class="string">&#x27;loading&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 图片加载失败时的处理</span></span><br><span class="line">    img.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">&#x27;Failed to load image:&#x27;</span>, src);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始加载图片</span></span><br><span class="line">    img.src = src;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(<span class="string">&#x27;No image source found for element with id:&#x27;</span>, imageElement.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>批量图片懒加载：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt; img class=&quot;lazy&quot; data-src=&quot;path/to/image1.jpg&quot; alt=&quot;Lazy loaded image&quot;&gt;</span><br><span class="line"><span class="comment">&lt;!-- 其他需要懒加载的图片...</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化Intersection Observer实例</span></span><br><span class="line"><span class="keyword">let</span> lazyImages = [];</span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> IntersectionObserver(</span><br><span class="line">  (entries, observer) =&gt; &#123;</span><br><span class="line">    entries.forEach(<span class="function">(<span class="params">entry</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (entry.isIntersecting) &#123;</span><br><span class="line">        loadAndReplaceImage(entry.target);</span><br><span class="line">        observer.unobserve(entry.target);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">threshold</span>: <span class="number">0.5</span> &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收集所有需要懒加载的图片</span></span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.lazy&#x27;</span>).forEach(<span class="function">(<span class="params">img</span>) =&gt;</span> &#123;</span><br><span class="line">  lazyImages.push(img);</span><br><span class="line">  observer.observe(img);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载并替换图片的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadAndReplaceImage</span>(<span class="params">imgElement</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> realSrc = imgElement.dataset.src;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建新的Image对象</span></span><br><span class="line">  <span class="keyword">let</span> newImage = <span class="keyword">new</span> Image();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 图片加载成功</span></span><br><span class="line">  newImage.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    imgElement.src = realSrc;</span><br><span class="line">    imgElement.classList.remove(<span class="string">&#x27;lazy&#x27;</span>); <span class="comment">// 移除懒加载类，可选</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 图片加载失败</span></span><br><span class="line">  newImage.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&#x27;Failed to load image:&#x27;</span>, realSrc);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始加载图片</span></span><br><span class="line">  newImage.src = realSrc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听滚动事件，仅当Intersection Observer不支持时才需要</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;IntersectionObserver&#x27;</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果浏览器支持Intersection Observer，则无需额外处理滚动事件</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 若不支持Intersection Observer，可以在此处添加滚动事件监听并手动检查图片是否在视口中</span></span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 实现滚动时检查图片位置的逻辑</span></span><br><span class="line">    <span class="comment">// 但请注意，这种方法效率较低，应尽量优先使用Intersection Observer API</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>动态模块懒加载：在单页应用（SPA）中，根据用户的导航行为，延迟加载未访问路由对应的JavaScript或CSS资源。</p></li></ul><p>懒加载的优势在于：</p><ul><li>减少初始加载时间，提高页面的首屏加载速度。</li><li>减轻服务器压力，特别是当同时在线用户数较多时，能够显著降低服务器带宽需求。</li><li>改善用户在移动设备上浏览时的数据流量消耗。</li></ul><p><strong>预加载（Preloading）</strong>：<br>预加载则是指在用户尚未明确请求之前，预测并主动加载可能会用到的资源。这可以是即将浏览到的图片、视频，或者是即将跳转的页面所需的资源等。例如：</p><ul><li>预加载图片：创建一个新的Image对象，设置其<code>src</code>属性指向待加载的图片地址，浏览器会在后台开始加载，一旦用户需要时，图片已存在于缓存中，可以直接渲染。</li><li>预加载资源链接：通过HTML <code>&lt;link rel=&quot;preload&quot;&gt;</code> 标签预先告知浏览器加载指定的资源，这些资源可能是CSS样式表、JavaScript文件或其他类型的内容。</li></ul><p>预加载的优点在于：</p><ul><li>缩短用户交互时的等待时间，提升用户体验，因为相关资源已经在用户可能需要之前加载完毕。</li><li>当用户实际访问时，资源可以直接从缓存中读取，减少了网络延迟。</li></ul><p>综合来看，懒加载和预加载虽然方向相反，但都是为了优化网页性能和用户体验，只是应用场景和目标有所差异。懒加载适用于节省初次加载资源量和时间的情况，而预加载更注重提升后续操作的流畅度和响应性。</p><h3 id="请描述CommonJS、AMD、ES6-Modules之间的区别"><a href="#请描述CommonJS、AMD、ES6-Modules之间的区别" class="headerlink" title="请描述CommonJS、AMD、ES6 Modules之间的区别"></a>请描述CommonJS、AMD、ES6 Modules之间的区别</h3><p>CommonJS、AMD 和 ES6 Modules（也称为 ECMAScript Modules，简称 ESM）是JavaScript中三种不同的模块化规范，它们的主要区别在于设计目的、工作原理以及使用场景：</p><ol><li><strong>CommonJS</strong>：</li></ol><ul><li>设计初衷：CommonJS 主要应用于服务器端，由 Node.js 实现并流行起来，适用于非浏览器环境。</li><li>工作原理：CommonJS 是同步的模块加载机制，模块在运行时通过<code>require</code>函数导入，通过<code>module.exports</code>或<code>exports</code>导出。每个模块在执行时有自己的全局作用域，模块加载后立即执行，输出的是导出对象的一个副本。</li><li>使用场景：常用于Node.js的服务器端编程，如在express框架中加载中间件和路由模块。</li></ul><ol start="2"><li>**Asynchronous Module Definition (AMD)**：</li></ol><ul><li>设计初衷：AMD 是面向浏览器环境设计的，由 RequireJS 首先提出并广泛应用，解决浏览器环境下异步加载模块的需求。</li><li>工作原理：AMD 使用异步方式加载模块，模块的加载和执行是分离的。通过<code>define</code>函数定义模块，通过<code>require</code>函数异步加载模块，并在回调函数中使用加载完成的模块。AMD 支持模块的动态加载和依赖管理。</li><li>使用场景：适用于浏览器端的复杂单页面应用，特别是需要异步加载和模块按需加载的场景。</li></ul><ol start="3"><li>**ECMAScript Modules (ES6 Modules)**：</li></ol><ul><li>设计初衷：ES6 Modules 是 ECMAScript 6 标准中正式引入的模块系统，它既适用于浏览器环境也适用于非浏览器环境。</li><li>工作原理：ESM 使用<code>import</code>关键字导入模块，通过<code>export</code>关键字导出模块成员。模块的加载是静态的（静态分析时就可以确定模块依赖），并且默认支持异步加载（尽管现代浏览器也支持同步模块加载）。模块在导入时不会立即执行，而是等到导入它的模块需要时才执行。</li><li>使用场景：现代浏览器和Node.js（v14+ 版本后支持原生ESM）中广泛使用。ESM已经成为主流的模块化标准，并逐渐取代CommonJS和AMD成为统一的模块化解决方案。</li></ul><p>总结来说，CommonJS 适合于服务器端的同步环境，AMD 主要解决浏览器环境下的异步模块加载问题，而 ES6 Modules 则是新一代标准化的模块系统，旨在为浏览器和服务器两端提供一种统一的、强大的模块化解决方案。</p><h3 id="如何配置Webpack进行项目构建？列举几个常用的Loader和Plugin"><a href="#如何配置Webpack进行项目构建？列举几个常用的Loader和Plugin" class="headerlink" title="如何配置Webpack进行项目构建？列举几个常用的Loader和Plugin"></a>如何配置Webpack进行项目构建？列举几个常用的Loader和Plugin</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">name: <span class="string">&#x27;[name].bundle.js&#x27;</span>,</span><br><span class="line">  path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// Loader配置</span></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    <span class="comment">// 处理JS文件的Babel Loader</span></span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      use: [<span class="string">&#x27;babel-loader&#x27;</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 处理CSS文件的CSS Loader和Style Loader</span></span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 处理图片的File Loader</span></span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.(png|jpg|jpeg|gif|svg)$/</span>,</span><br><span class="line">      use: [&#123;</span><br><span class="line">        loader: <span class="string">&#x27;file-loader&#x27;</span>,</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Webpack是一个模块打包工具，用于处理前端资源的转换、合并、压缩等工作。配置Webpack进行项目构建主要涉及以下几个步骤：</p><ol><li><p>创建<code>webpack.config.js</code>配置文件。</p></li><li><p>配置入口（entry）和出口（output）。</p></li><li><p>添加Loader用于处理不同类型的文件。</p></li><li><p>使用Plugin增强Webpack功能。</p><p>以下是配置Webpack的基本结构以及一些常用的Loader和Plugin示例：</p></li></ol><p> <strong>基本配置示例：</strong></p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 入口文件</span></span><br><span class="line">  entry: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  <span class="comment">// 输出目录和文件名</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    file  options: &#123;</span><br><span class="line">            outputPath: <span class="string">&#x27;images/&#x27;</span>,</span><br><span class="line">            publicPath: <span class="string">&#x27;../images/&#x27;</span>,</span><br><span class="line">            name: <span class="string">&#x27;[name].[hash:8].[ext]&#x27;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// Plugin配置</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 生成HTML文件的HtmlWebpackPlugin</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">&#x27;./public/index.html&#x27;</span>,</span><br><span class="line">      filename: <span class="string">&#x27;index.html&#x27;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 优化CSS提取的MiniCssExtractPlugin</span></span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename: <span class="string">&#x27;[name].css&#x27;</span>,</span><br><span class="line">      chunkFilename: <span class="string">&#x27;[id].css&#x27;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 代码压缩的UglifyJsPlugin（Webpack 4）或TerserPlugin（Webpack 5）</span></span><br><span class="line">    <span class="keyword">new</span> TerserPlugin(),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> <strong>常用Loader：</strong></p><ul><li><strong>Babel Loader</strong>：用于将ES6及以上版本的JavaScript代码转换为向后兼容的JavaScript代码。</li><li><strong>CSS Loader</strong>：将CSS文件作为模块导入，支持CSS Modules和CSS源码转换。</li><li><strong>Style Loader</strong> 或 <strong>MiniCssExtractPlugin</strong>：前者将CSS内联到JavaScript中，后者则将CSS抽取到单独的CSS文件中。</li><li><strong>File Loader</strong> 或 <strong>Url Loader</strong>：处理项目中的图片、字体等文件，将其转化为base64编码或输出到指定目录。</li><li><strong>TS Loader</strong>：处理TypeScript文件，将其转换为JavaScript。</li></ul><p> <strong>常用Plugin：</strong></p><ul><li><p><strong>HtmlWebpackPlugin</strong>：根据模板生成HTML文件，并自动注入编译产出的JS/CSS资源。</p></li><li><p><strong>MiniCssExtractPlugin</strong>：从JS文件中提取CSS代码，生成单独的CSS文件。</p></li><li><p><strong>CopyWebpackPlugin</strong>：复制项目中的静态资源到输出目录。</p></li><li><p><strong>CleanWebpackPlugin</strong>：在每次构建前清除输出目录。</p></li><li><p><strong>DefinePlugin</strong>：在编译阶段替换全局变量，常用于设置环境变量。</p></li><li><p><strong>UglifyJsPlugin</strong>（Webpack 4）或 <strong>TerserPlugin</strong>（Webpack 5）：用于压缩JavaScript代码，优化文件大小。</p><p>根据项目需求，还可以添加更多Loader和Plugin，例如SourceMap相关的插件、热更新插件（HotModuleReplacementPlugin）等。</p></li></ul><p><strong>异步编程：</strong></p><p>请解释Promise、async/await的区别与联系，并写出对应的错误处理方式。</p><p>Promise、async/await都是JavaScript中用于处理异步操作的重要工具，它们之间存在紧密的联系和区别。</p><p>Promise</p><p>Promise是JavaScript中用于处理异步操作的对象。它有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。一旦Promise的状态从pending变为fulfilled或者rejected，就不会再改变。Promise的主要方法是.then()（用于指定fulfilled时的回调函数）和.catch()（用于指定rejected时的回调函数）。</p><p>Async/Await</p><p>Async/Await是基于Promise的语法糖，使得异步代码看起来像同步代码，易于理解和编写。async函数总是返回一个Promise对象，await只能用在async函数内部，await后面跟的是一个Promise对象，返回的是Promise对象的结果。</p><p>区别</p><p>语法：Promise的语法较为繁琐，需要通过.then()和.catch()来处理异步操作的结果和错误。而async/await的语法更接近于同步代码，更易于理解和编写。<br>错误处理：在Promise中，错误需要通过.catch()方法捕获。而在async/await中，错误可以直接通过try/catch捕获。<br>联系</p><p>基于Promise：async/await实际上是基于Promise实现的，async函数返回的是一个Promise对象。<br>目的相同：无论是Promise还是async/await，它们的主要目的都是为了处理JavaScript中的异步操作，使得代码更易于管理和理解。<br>错误处理方式</p><p>Promise的错误处理：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;  </span><br><span class="line">    <span class="comment">// 模拟异步操作  </span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;  </span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Promise failed&#x27;</span>));  </span><br><span class="line">    &#125;, <span class="number">1000</span>);  </span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line">promise  </span><br><span class="line">    .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;  </span><br><span class="line">        <span class="built_in">console</span>.log(result);  </span><br><span class="line">    &#125;)  </span><br><span class="line">    .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;  </span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;Promise error:&#x27;</span>, error);  </span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>Async/Await的错误处理：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunction</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;  </span><br><span class="line">            <span class="comment">// 模拟异步操作  </span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;  </span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Async/Await failed&#x27;</span>));  </span><br><span class="line">            &#125;, <span class="number">1000</span>);  </span><br><span class="line">        &#125;);  </span><br><span class="line">        <span class="built_in">console</span>.log(result);  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;  </span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&#x27;Async/Await error:&#x27;</span>, error);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">asyncFunction();</span><br></pre></td></tr></table></figure><p>  在以上两个例子中，无论是使用Promise还是async/await，当异步操作失败时，都会通过.catch()方法或try/catch块捕获并处理错误。</p><h3 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h3><ul><li>代码优化<ul><li>压缩和合并css和js等资源文件，使用uglifyjs, Terser</li><li>避免全局变量，减少查找全局过程消耗时间，补全文件引用路径，减少查询消耗</li><li>利用冒泡给父元素绑定事件代理子元素事件处理，事件委托减少事件注册绑定梳理，减少内存消耗</li><li>优化css选择器避免过于复杂的选择器查询影响性能</li><li>更新体积更小的新版本，比如xlsx新版本比旧版本体积小，且支持按需引入<code>import &#123;utils&#125; from &#39;xlsx</code>，可以tree-shaking；</li><li>尽量减少第三方库的使用，比如时间格式化库，手写实现，减少代码体积</li><li>小数据量的请求合并到其他接口，减少首屏请求数量</li><li>页面响应慢可以添加骨架屏或者loading</li></ul></li><li>图片优化<ul><li>压缩图片资源，比如使用tinypng工具压缩图片</li><li>选用合适的图片格式，比如jpeg, png, webp<ul><li>jpeg：有损压缩格式，高压缩率 优点：保持高质量图片同时文件较小 缺点：压缩损失图片质量</li><li>png：无损压缩格式 优点：保留原始图像的质量，支持透明通道， 缺点：文件大</li><li>webp：具有较高的压缩率和图像质量，支持透明通道和动画，缺点：老版本浏览器不支持此格式</li></ul></li><li>使用srcset和sizes属性针对不同屏幕尺寸引入不同图片大小的资源</li></ul></li><li>网络请求优化<ul><li>减少http请求：合并css和js资源，使用css scriptes和base64图片</li><li>使用cdn部署静态资源，利用cdn和缓存和分布式特性</li><li>浏览器缓存：设置http header（Cache-control, Etag, Last-Modified）缓存资源减少http请求</li></ul></li><li>渲染优化<ul><li>减少dom元素布局变动和style变动，减少dom重排和重绘，使用DocumentFragment</li><li>使用虚拟列表：大量数据列表使用虚拟列表，只渲染当前视窗的数据，随着滚动，销毁不在视窗的元素并创建进入视窗的元素</li><li>对于复杂计算和处理逻辑，使用Web Worker线程处理，避免阻塞主线程</li><li>使用css3硬件加速动画性能，比如will-change, transform, requestAnimationFrame</li></ul></li><li>代码拆分和加载<ul><li>使用webpack将文件拆分成chunk，在首屏按需加载模块</li><li>动态import（）实现路由懒加载</li><li>使用preload和prefetch对关键性资源和后续可能访问资源进行提前加载</li><li>异步加载js避免阻塞主线程，defer， async</li></ul></li><li>服务器SSR渲染：提高首屏加载速度，更好的SEO</li><li>对于静态页面使用SSG渲染：在构建过程就生成了页面</li></ul><p>杭萧crm通过客户管理，项目管理，办公功能以及数据统计与分析能力，为用户提供了一个全面、高效的工作平台。<br>包含工作台，排行榜，待办，我的四个核心板块。<br>工作台作为首界面展示了各项业务的核心数据，包含不同项目阶段的统计以及对应的财务指标；通过工作指示、日总结、任务简报等功能模块确保员工掌握自身工作进度和目标；员工分布、员工在线统计等功能配合团队业绩个人业绩使管理者更清晰掌握员工和业务的状态。</p><p>排行榜：结合规章制度按月度，季度，年度等对全集团，分公司，部门以及个人业绩进行多项关键考核指标排名，促进良性竞争，掌控业务进度。</p><p>待办包含全业务流程审批，加强内部协作。</p><p>我的板块包含工作总结，打卡记录等自我管理模块，以及客户模块和通讯录，还详细划分项目各阶段入口，保证用户掌控项目全过程，包括从跟进，有效，投标，中标，合同签订到收款的过程，形成了一套完整的项目管理和客户关系管理的体系。</p><h3 id="组件封装之messageBox"><a href="#组件封装之messageBox" class="headerlink" title="组件封装之messageBox"></a>组件封装之messageBox</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click&#x3D;&quot;showMessageBox(&#39;是否确认删除？&#39;, &#123;</span><br><span class="line">    confirm: () &#x3D;&gt; &#123; &#x2F;&#x2F; todo something &#125;,</span><br><span class="line">    cancel: () &#x3D;&gt; &#123; &#x2F;&#x2F; todo something &#125;</span><br><span class="line">  &#125;)&quot;&gt;删除&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; showMessageBox &#125; from &#39;.&#x2F;showMessageBox.js&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123; showMessageBox &#125; &#x2F;&#x2F; 或者全局</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><strong>组件封装思路：用createVnode或者jsx编写组件结构—–用render方法渲染在一个div里——用appendChild方法添加到页面.</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// messageBox.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createVnode , render &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">showMessageBox</span>(<span class="params">content, handler</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// js: vnode</span></span><br><span class="line">  <span class="comment">// let messageBox = createVnode(&#x27;div&#x27;, &#123;</span></span><br><span class="line">  <span class="comment">//   class: &#x27;divcover&#x27;,</span></span><br><span class="line">  <span class="comment">//   [</span></span><br><span class="line">  <span class="comment">//     createVnode(&#x27;div&#x27;, &#123;</span></span><br><span class="line">  <span class="comment">//       class: &#x27;messageContent&#x27;</span></span><br><span class="line">  <span class="comment">//     &#125;, content)</span></span><br><span class="line">  <span class="comment">//   ]</span></span><br><span class="line">  <span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// jsx：项目需支持</span></span><br><span class="line">  <span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> messageBox = <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cover&quot;</span>&gt;</span></span></span><br><span class="line">    &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">      &lt;div&gt;&#123; content &#125;&lt;/div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">          // 移除</span><br><span class="line">          document.body.removeChild(div)</span><br><span class="line">          console.log(&#x27;取消&#x27;)</span><br><span class="line">          handler.cancel &amp;&amp; handler.cancel()</span><br><span class="line">        &#125;&#125;&gt;取消&lt;/button&gt;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; &#123;</span><br><span class="line">          // 移除</span><br><span class="line">          document.body.removeChild(div)</span><br><span class="line">          console.log(&#x27;确定&#x27;)</span><br><span class="line">          handler.confirm &amp;&amp; handler.confirm()</span><br><span class="line">        &#125;&#125;&gt;确定&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用vue创建组件messageBox，用createVnode(messageBox)生成vnode</span></span><br><span class="line">  render(messageBox, div)</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="怎样排查页面加载慢？"><a href="#怎样排查页面加载慢？" class="headerlink" title="怎样排查页面加载慢？"></a>怎样排查页面加载慢？</h3><ul><li><p>资源加载慢</p><ul><li>浏览器开发者工具-性能面板录制-查找netweork，查看哪些文件大，加载慢，当前页面不需要或者点击才需要的资源使用异步加载；按需加载页面资源；webpack工具打包压缩资源；开启gzip数据压缩</li></ul></li><li><p>js执行慢</p><ul><li>若js执行慢，则使用console.time或者perfomance.now检测哪段同步代码执行慢</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// console.time()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> aT = performance.now()</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">  div.innerHTML = i</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// console.timeEnd()</span></span><br><span class="line"><span class="keyword">let</span> bT = performance.now()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bT - aT)</span><br></pre></td></tr></table></figure><p>或者在网站index.html加入js代码将window.performance传给接口进行分析用户网站性能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">  $.ajax(&#123;</span><br><span class="line">    url: <span class="string">&#x27;api/&#x27;</span>,</span><br><span class="line">    data: <span class="built_in">window</span>.performance</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="string">``</span></span><br><span class="line"></span><br><span class="line">  其他分析工具: 开发者工具lighthouse, js库web-vitals</span><br><span class="line"></span><br><span class="line">+ 页面绘制慢</span><br><span class="line"></span><br><span class="line">### 项目难点亮点</span><br><span class="line"></span><br><span class="line">+ 移动端</span><br><span class="line">  + 多屏幕适配：利用rem或者px转vw（webpack集成），媒体查询或js解决；</span><br><span class="line">  + 高还原设计稿要求</span><br><span class="line">+ B端公司后台</span><br><span class="line">  + 大文件上传、断点续传</span><br><span class="line">+ 可视化</span><br><span class="line">  + echarts图表，高度定制地图、流程图等</span><br><span class="line">+ websocket：实时消息提醒，在线多人协作</span><br><span class="line">+ webGL：3d模型</span><br><span class="line">+ canvas</span><br><span class="line"></span><br><span class="line">工作亮点：</span><br><span class="line"></span><br><span class="line">+ 前端规范定制，并落实到工程化工具：git提交自动eslint代码检查；git提交信息格式检查</span><br><span class="line">+ 封装组件：pc端一般组件二次封装（列表组件：查询+表格+分页+操作按钮：添加/导出等；添加/编辑表单弹窗组件：弹窗+表单；）</span><br><span class="line"></span><br><span class="line">### js对象的原始值转换</span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>.toPrimitive是一种特殊的<span class="built_in">Symbol</span>值，它可以作为对象的属性键，用于定义对象在被转换为原始值时的行为。当一个对象被转换为原始值时，JavaScript引擎会尝试调用对象上的<span class="built_in">Symbol</span>.toPrimitive方法来确定转换的结果。比如对象&#123;[<span class="built_in">Symbol</span>.toPrimitive]: <span class="function">() =&gt;</span> <span class="number">1</span>&#125;转换成原始值就是<span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">需要注意的是，<span class="built_in">Symbol</span>.toPrimitive必须为函数，不然会报错.</span><br><span class="line"></span><br><span class="line">**将对象转换成数字:**</span><br><span class="line"></span><br><span class="line">将对象转换成数字时，首先会调用<span class="built_in">Symbol</span>.toPrimitive方法，如果<span class="built_in">Symbol</span>.toPrimitive不存在或者返回的不是js原始值（以下省略原始值这一条规则），则会调用valueOf方法，如果valueOf不存在，则会调用toString方法，如果toString也不存在，转换就会报错：<span class="string">`TypeError: Cannot convert object to primitive value`</span>，意思是无法将对象转换成原始值。</span><br><span class="line">总的来说，调用顺序是：<span class="built_in">Symbol</span>.toPrimitive -&gt; valueOf -&gt; toString。</span><br><span class="line"></span><br><span class="line">对象的<span class="built_in">Symbol</span>.toStringTag属性，指向一个方法。在该对象上面调用<span class="built_in">Object</span>.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制[object <span class="built_in">Object</span>]或[object <span class="built_in">Array</span>]中object后面的那个字符串。</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string">let obj = &#123;</span></span><br><span class="line"><span class="string">  [Symbol.toStringTag]: &#x27;abc&#x27; // </span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">obj.toString() // &#x27;[object abc]&#x27;</span></span><br><span class="line"><span class="string">String(obj) // &#x27;[object abc]&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// js中可以使用+号将其他类型转换成number，和Number()的作用一样，为了表达式的简洁，以下将使用+代替Number()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line">+&#123;[<span class="built_in">Symbol</span>.toPrimitive]: <span class="function">() =&gt;</span> <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">+&#123;<span class="attr">valueOf</span>: <span class="function">() =&gt;</span> <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">+&#123;<span class="attr">toString</span>: <span class="function">() =&gt;</span> <span class="number">2</span>&#125; <span class="comment">// 没错，toString方法可以返回number、boolean乃至其他类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 优先调用Symbol.toPrimitive，所以返回0</span></span><br><span class="line">+&#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.toPrimitive]: <span class="function">() =&gt;</span> <span class="number">0</span>,</span><br><span class="line">    valueOf: <span class="function">() =&gt;</span> <span class="number">1</span>,</span><br><span class="line">    toString: <span class="function">() =&gt;</span> <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 如果返回的原始值不是`number`类型，则会再次进行转换；</span></span><br><span class="line"><span class="comment">// &#123;[Symbol.toPrimitive]: () =&gt; &quot;0&quot;&#125;转换成原始值为字符串&quot;0&quot;；</span></span><br><span class="line"><span class="comment">// 接着再将这个字符串&quot;0&quot;转换成数字0。</span></span><br><span class="line">+&#123;[<span class="built_in">Symbol</span>.toPrimitive]: <span class="function">() =&gt;</span> <span class="string">&quot;0&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NaN</span></span><br><span class="line"><span class="comment">// 空对象中不存在Symbol.toPrimitive方法，会调用valueOf方法；</span></span><br><span class="line"><span class="comment">// 对象的valueOf默认会返回自身，也就是说没有返回原始值，继续调用toString方法；</span></span><br><span class="line"><span class="comment">// 对象的toString方法默认会返回&quot;[object &quot; + 对象.constructor.name + &quot;]&quot;，在这里将被转换成&quot;[object Object]&quot;；</span></span><br><span class="line"><span class="comment">// 由于&quot;[object Object]&quot;属于原始类型，则js将其转换成number类型，当然它一眼看上去就不是个数字，只能转换成了NaN。</span></span><br><span class="line">+&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错 TypeError: Cannot convert object to primitive value</span></span><br><span class="line"><span class="comment">// Object.create(null)创建的对象没有原型链，也就是没有valueOf和toString更没有Symbol.toPrimitive，所以只能转换失败了</span></span><br><span class="line">+<span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 666</span></span><br><span class="line"><span class="comment">// parseInt和parseFloat如果传入对象，会先将对象转换成字符串，可以参考“将对象转换成字符串”部分内容</span></span><br><span class="line"><span class="built_in">parseInt</span>(&#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.toPrimitive]: <span class="function">() =&gt;</span> <span class="string">&quot;666&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 666</span></span><br><span class="line"><span class="comment">// Math对象中的方法如果传入了对象，先会将对象转换成number，然后才进行计算</span></span><br><span class="line"><span class="built_in">Math</span>.floor(&#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.toPrimitive]: <span class="function">() =&gt;</span> <span class="number">666.6</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// null对象比较特殊，转换成number是0</span></span><br><span class="line">+<span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NaN</span></span><br><span class="line"><span class="comment">// undefined对象比较特殊，转换成number是NaN</span></span><br><span class="line">+<span class="keyword">void</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>将对象转换成字符串:</strong></p><p>一般情况下，我们会使用String()或者xx.toString()将对象转换为字符串，但是他们是有些区别的。String()方法会优先尝试调用对象中的Symbol.toPrimitive方法；如果Symbol.toPrimitive不存在，则会尝试调用对象中的toString方法。<br>用String()转换对象成字符串的顺序为：Symbol.toPrimitive -&gt; toString，是的，不会调用valueOf。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &quot;Hello, Symbol.toPrimitive!&quot;</span></span><br><span class="line"><span class="built_in">String</span>(&#123;[<span class="built_in">Symbol</span>.toPrimitive]: <span class="function">() =&gt;</span> <span class="string">&quot;Hello, Symbol.toPrimitive!&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;Hello, toString!&quot;</span></span><br><span class="line"><span class="built_in">String</span>(&#123;<span class="attr">toString</span>: <span class="function">() =&gt;</span> <span class="string">&quot;Hello, toString!&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;Hello, Symbol.toPrimitive!&quot;</span></span><br><span class="line"><span class="built_in">String</span>(&#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.toPrimitive]: <span class="function">() =&gt;</span> <span class="string">&quot;Hello, Symbol.toPrimitive!&quot;</span>,</span><br><span class="line">    toString: <span class="function">() =&gt;</span> <span class="string">&quot;Hello, toString!&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="comment">// 空对象中不存在Symbol.toPrimitive方法，会调用toString方法；</span></span><br><span class="line"><span class="comment">// 对象的toString方法默认会返回&quot;[object &quot; + 对象.constructor.name + &quot;]&quot;，在这里将被转换成&quot;[object Object]&quot;；</span></span><br><span class="line"><span class="built_in">String</span>(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="comment">// 由于对象转换成字符串时不会调用valueOf，所以会调用默认的toString方法，可以参考String(&#123;&#125;)</span></span><br><span class="line"><span class="built_in">String</span>(&#123;</span><br><span class="line">    valueOf: <span class="function">() =&gt;</span> <span class="string">&quot;Hello, valueOf!&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;Hello, Symbol.toPrimitive!&quot;</span></span><br><span class="line"><span class="comment">// 使用模板字符串转换对象时，规则与String()相同，优先使用Symbol.toPrimitive</span></span><br><span class="line"><span class="string">`<span class="subst">$&#123;&#123;[<span class="built_in">Symbol</span>.toPrimitive]: () =&gt; <span class="string">&quot;Hello, Symbol.toPrimitive!&quot;</span>, toString: () =&gt; <span class="string">&quot;Hello, toString!&quot;</span>&#125;&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错 TypeError: Cannot convert object to primitive value</span></span><br><span class="line"><span class="comment">// Object.create(null)创建的对象没有原型链，也就是没有toString更没有Symbol.toPrimitive，所以只能转换失败了</span></span><br><span class="line"><span class="comment">// 顺便一提，`$&#123;Object.create(null)&#125;`也会报这个错</span></span><br><span class="line"><span class="built_in">String</span>(<span class="built_in">Object</span>.create(<span class="literal">null</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;&#123;&#125;&quot;</span></span><br><span class="line"><span class="comment">// JSON.stringify会忽略对象中的方法，不受原始值转换规则的约束，所以这里的值为&quot;&#123;&#125;&quot;</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.toPrimitive]: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;a:1&#125;&quot;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;null&quot;</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;undefined&quot;</span></span><br><span class="line"><span class="comment">// undefined不属于对象，放在这里只是为了方便对比</span></span><br><span class="line"><span class="comment">// void 0实际上就是undefined</span></span><br><span class="line"><span class="built_in">String</span>(<span class="keyword">void</span> <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><strong>将对象转换成布尔值:</strong></p><p>对象转换成布尔值的规则比较特殊，不论对象里面是否有Symbol.toPrimitive、valueOf或者toString，都为true</p><p><strong>将对象转换成大整数（BigInt）:</strong></p><p>对象转换成BigInt的规则和转换成number的规则类似都是按照Symbol.toPrimitive -&gt; valueOf -&gt; toString的顺序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 111n</span></span><br><span class="line">BigInt(&#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.toPrimitive]: <span class="function">() =&gt;</span> <span class="string">&quot;111&quot;</span>,</span><br><span class="line">    valueOf: <span class="function">() =&gt;</span> <span class="string">&quot;222&quot;</span>,</span><br><span class="line">    toString: <span class="function">() =&gt;</span> <span class="string">&quot;333&quot;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="拖拽元素"><a href="#拖拽元素" class="headerlink" title="拖拽元素"></a>拖拽元素</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>拖拽<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.list</span> &#123;</span></span><br><span class="line">      margin-top: 2rem;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.item</span> &#123;</span></span><br><span class="line">      width: 300px;</span><br><span class="line">      height: 60px;</span><br><span class="line">      line-height: 60px;</span><br><span class="line">      background-color: green;</span><br><span class="line">      color: white;</span><br><span class="line">      border-radius: 10px;</span><br><span class="line">      padding-left: 10px;</span><br><span class="line">      margin-bottom: 10px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.item</span><span class="selector-class">.moving</span> &#123;</span></span><br><span class="line">      background-color: transparent;</span><br><span class="line"><span class="css">      <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#eee</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 获取列表元素</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> list = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.list&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> sourceNode = <span class="literal">null</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 拖拽开始</span></span></span><br><span class="line"><span class="javascript">    list.ondragstart = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 在ondragstart中添加样式</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        e.target.classList.add(<span class="string">&#x27;moving&#x27;</span>);</span></span><br><span class="line">      &#125;, 0);</span><br><span class="line"><span class="javascript">      <span class="comment">// 记录拖拽开始时的元素</span></span></span><br><span class="line">      sourceNode = e.target</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="comment">// 拖拽进入</span></span></span><br><span class="line"><span class="javascript">    list.ondragenter = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 阻止默认行为</span></span></span><br><span class="line">      e.preventDefault();</span><br><span class="line"><span class="javascript">      <span class="comment">// 如果目标元素是列表或者拖拽开始时的元素，则直接返回</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (e.target === list || e.target === sourceNode) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;打印&#x27;</span>, e.target);</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 获取列表中子元素的索引</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> children = [...list.children];</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> sourceIndex = children.indexOf(sourceNode);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> targetIndex = children.indexOf(e.target);</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 如果源元素索引小于目标元素索引，则目标元素向下移</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (sourceIndex &lt; targetIndex) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;打印&#x27;</span>, <span class="string">&#x27;下移&#x27;</span>)</span></span><br><span class="line">        list.insertBefore(sourceNode, e.target.nextElementSibling);</span><br><span class="line"><span class="javascript">      <span class="comment">// 否则，目标元素向上移</span></span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;打印&#x27;</span>, <span class="string">&#x27;上移&#x27;</span>)</span></span><br><span class="line">        list.insertBefore(sourceNode, e.target);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="comment">// 拖拽移动</span></span></span><br><span class="line"><span class="javascript">    list.ondragover = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 阻止默认行为</span></span></span><br><span class="line">      e.preventDefault();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="comment">// 拖拽结束</span></span></span><br><span class="line"><span class="javascript">    list.ondragend = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 移除样式</span></span></span><br><span class="line"><span class="javascript">      e.target.classList.remove(<span class="string">&#x27;moving&#x27;</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="大屏数据如何实现实时更新？"><a href="#大屏数据如何实现实时更新？" class="headerlink" title="大屏数据如何实现实时更新？"></a>大屏数据如何实现实时更新？</h3><ul><li>websocket</li><li>Server-Sent Events（SSE，服务器发送事件）是一种简单的技术，允许服务器通过HTTP连接向客户端推送实时更新。与WebSocket相比，SSE是一种单向通信机制，只允许服务器向客户端发送消息。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dataList;</span><br><span class="line"><span class="comment">// 创建一个新的EventSource对象，连接到http://localhost:8080/getList这个地址</span></span><br><span class="line"><span class="keyword">const</span> source = <span class="keyword">new</span> EventSource(<span class="string">&#x27;http://localhost:8080/getList&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// EventSource: 0: connecting 1:open 2: closed</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听source对象打开连接的事件</span></span><br><span class="line">source.onopen = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onopen---&#x27;</span>, event)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 监听source对象接收到消息的事件</span></span><br><span class="line">source.onmessage = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onmessage---&#x27;</span>, event)</span><br><span class="line">  <span class="comment">// 将收到的消息转换为JSON格式，赋值给dataList</span></span><br><span class="line">  dataList = <span class="built_in">JSON</span>.parse(event.data)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;dataList&#x27;</span>, dataList)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 监听source对象发生错误的事件</span></span><br><span class="line">source.onerror = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onerror---&#x27;</span>, event)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 监听source对象关闭连接的事件</span></span><br><span class="line">source.onclose = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onclose---&#x27;</span>, event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数参数和默认值"><a href="#函数参数和默认值" class="headerlink" title="函数参数和默认值"></a>函数参数和默认值</h3><p>函数参数默认值，传参为undefined才取默认值。<br>函数参数和arguments是一一对应的，比如fn(a,b) fn(1,2)。arguments[0]等于a，在函数中，修改a的值，arguments[0]也跟着改变，除非使用严格模式。<br>但是如果函数参数设置了默认值，修改a后，arguments[0]还是最初传参的值，不会跟随a改变。</p><p>函数如果设置了默认值，形参的长度计算到默认值前面，即fn(a,b=2,c),fn.length参数长度为1，fn(a,b,c=3),fn.length为2.</p><p>函数参数默认值即可以设置字面量也可以设置表达式，表达式的值只有在调用的时候才计算，即参数为undefined的时候才去计算表达式取默认值。</p><p>函数参数的暂时性死区，fn(a,b=getvalue(a))可以，但是fn(a=getvalue(b), b)会报错，let定义变量在声明前不可使用，暂时性死区.</p><h3 id="css属性值的计算过程"><a href="#css属性值的计算过程" class="headerlink" title="css属性值的计算过程"></a>css属性值的计算过程</h3><p>css属性值的计算过程computed style：</p><ul><li>1、确定声明值（找到作者和默认样式表没有冲突的属性直接确定下来属性值）</li><li>2、层叠（比较重要性，比较权重，比较源次序）</li><li>3、继承（对仍然没有值的属性若可以继承则使用继承，有些属性不能继承）</li><li>4、使用默认属性（对仍然没有值的属性直接使用默认值）。从每一个元素css属性没有值到所有css属性都有值就是计算过程。</li></ul><h3 id="类型转换规则"><a href="#类型转换规则" class="headerlink" title="类型转换规则"></a>类型转换规则</h3><p>1、原始转数字</p><ul><li><p>true: 1</p></li><li><p>false: 0</p></li><li><p>null: 0</p></li><li><p>undefined: NaN</p></li><li><p>string:</p><ul><li>空字符串（含空白字符，\n\r\t等）：0</li><li>非空字符串，去掉引号， 不是数字就是NaN<br>2、所有转bool</li></ul></li><li><p>null：false</p></li><li><p>undefined: false</p></li><li><p>number:</p><ul><li>0: false</li><li>NaN: false</li><li>其他: true</li></ul></li><li><p>string</p><ul><li>空字符串：false</li><li>其他: true</li></ul></li><li><p>对象/数组：true<br>3、原始转字符串</p></li><li><p>null: “null”</p></li><li><p>undefined: “undefined”</p></li><li><p>number: “数字”</p></li><li><p>bool：true-“true” false-“false”<br>4、对象转原始<br>先调用valueOf()—-得到的是对象？重新调用toString()—-得到的还是对象？报错<br>[]转原始，[].toString()结果为’’ {}转原始为’[object object]’</p></li></ul><h3 id="js运算规则"><a href="#js运算规则" class="headerlink" title="js运算规则"></a>js运算规则</h3><p>1、算术运算<br><code>+ - * / % ++ --</code><br>转换为原始类型：</p><ul><li>转换为数字，然后运算</li><li>特殊情况：x+y,x和y有一个是字符串，转换为字符串进行拼接</li><li>特殊情况：NaN和任何类型运算得到的还是NaN</li></ul><p>举例：<br>null + undefined 转换为数字，0 + NaN ，结果为NaN<br>[] + {} :先转换为原始值：’’ + ‘[object object]’, 结果为’[object object]’<br>2、比较运算</p><blockquote><p>&lt; &gt;= &lt;= == != === !===</p></blockquote><ul><li>当运算符为&gt; &lt; &gt;= &lt;=:<ul><li>转换为原始类型：<ul><li>转换为数字，进行比较</li><li>特殊情况：两端全是字符串，比较字典的顺序</li><li>特殊情况：两端存在NaN，一定是false</li></ul></li><li>举例：null &gt; undefined —转为数字： 0 &gt; NaN, 结果为false</li><li>举例：null &lt; undefined —转为数字： 0 &lt; NaN, 结果为false</li></ul></li><li>当运算符为==：<ul><li>两端类型相同，比较值</li><li>两端都是原始类型，转换为数字比较</li><li>一端是原始类型一端是对象类型，将对象转为原始类型后进行比较</li><li>特殊情况，null和undefined只有与自身比较或者相互比较才为true null == null undefined == undefined null == undefined null == 0为false</li><li>特殊情况：两端存在NaN，一定是false</li></ul></li><li>当运算符为===:<ul><li>类型和值必须都相等才为true</li><li>特殊情况：两端存在NaN，一定是false</li></ul></li><li>当运算符为!= !==:对相等和全等取反<br>3、逻辑运算<br>! &amp;&amp; || ?:<br>转换为boolean：</li><li>x&amp;&amp;y: x：false，返回x，x为true，返回y</li><li>x||y: x:true,返回x，x：false，返回y<br>返回最后一次运算</li></ul><h3 id="for循环和forEach循环"><a href="#for循环和forEach循环" class="headerlink" title="for循环和forEach循环"></a>for循环和forEach循环</h3><p>for循环是js提出就有的循环方法。forEach是ES5提出的，挂在在可叠戴对象原型上的方法。<br>forEach是一个迭代器，负责遍历可迭代对象。</p><p>es6引入了interable对象，可迭代对象，Array, Map, Set, String, arguments, NodeList都属于interable类型，他们特点就是都有[Symbol.iterator]方法，包含它的对象都被认为是可迭代的iterable.</p><p><strong>for和forEach的本质区别：</strong><br>for循环是一种循环机制，用来遍历出数组。forEach是一个迭代器，负责遍历可迭代对象。</p><p>可迭代对象调用内部的<code>[Symbol.iterator]</code>生成了迭代器对象，访问迭代器的next()方法来访问内部的值。每次调用next()方法，返回一个保护value和done属性的值，value为yield的返回值，done表示是否结束。这也是for…of的原理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">let</span> iterator = arr[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>for…of</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item) <span class="comment">// 1 2 3 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把调用next返回的值保存在item中过，直到value为undefined跳出循环。</p><p><strong>for和forEach的语法区别：</strong></p><ul><li>forEach的参数：<code>arr.forEach((self, index, arr) =&gt; &#123;&#125;, this)</code>, this回调函数中this的指向</li><li>forEach的中断：for循环可以通过break, continue进行中断或跳出循环的操作，但是forEach不支持return continue break, 可以使用try/catch跳出循环</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">  arr1.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (item === <span class="number">3</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;loopterminate&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(item)</span><br><span class="line">  &#125;)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e.message !== <span class="string">&#x27;loopterminate&#x27;</span>) <span class="keyword">throw</span> e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>forEach删除自身原始，index不可以被重置，但是for循环删除自身元素可以重新设置index值</li><li>for循环可以控制循环起点，index = 1, forEach循环起点只能为0</li></ul><p><strong>for和forEach的性能区别：</strong></p><ul><li>性能比较：for &gt; forEach &gt; map</li><li>原因分析：for循环没有额外的函数调用栈和上下文，实现简单。forEach函数包含了参数和上下文，性能低于for。map会返回一个新的数组，数组的创建和赋值会分配内存空间，带来较大的性能开销。</li></ul>]]></content>
      
      
      <categories>
          
          <category> + + 笔记 + Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> + 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记打包内存溢出Last few GCs（FATAL ERROR: Reached heap limit Allocation failed - JavaScript heap out of memory）</title>
      <link href="/ZJY.github.io/2023/09/27/%E8%AE%B0%E6%89%93%E5%8C%85%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BALast-few-GCs%EF%BC%88FATAL-ERROR-Reached-heap-limit-Allocation-failed-JavaScript-heap-out-of-memory%EF%BC%89/"/>
      <url>/ZJY.github.io/2023/09/27/%E8%AE%B0%E6%89%93%E5%8C%85%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BALast-few-GCs%EF%BC%88FATAL-ERROR-Reached-heap-limit-Allocation-failed-JavaScript-heap-out-of-memory%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>项目环境：<br>node：16.15.1<br>框架：vue3、typescript<br>打包工具：vite</p><p>当运行npm run build时打包报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Last few GCs [ 8844 ： 999992A17EC9D459 ] 52995 ms ： (average mu = 9 ． 489 ， current mu [ 8844 ： 999992A17EC9D459 ] 52196 ms ： (average mu = 9 ． 489 ， current mu [ 8844 ： 999992A17EC9D459 ] 57289 ms ： Scavenge 2922 ． 1 （ 2979 ． 8 ） 9 ． 229 ） allocation failure Scavenge 2929 ． 4 （ 2981 ． 6 ） 9 ． 229 ） allocation failure Scavenge 2939 ． 9 （ 2983 ． 6 ） 一 &gt; 2921 ． 3 （ 2981 ． 1 ） 凹 B ， 一 &gt; 2927 ． 2 （ 2983 ． 6 ） 凹 B ， 一 &gt; 2929 ． 4 （ 2193 ． 3 ） 凹 B ， 81 ． 6 / 9 ． 9 ms 69 ． 9 / 9 ． 9 ms 5996 ． 8 / 9 ． 9 ms (average mu = 9 ． 489 ， current mu = 9 ． 229 ） allocation failure </span><br><span class="line">&lt;--- JS stacktrace ---&gt;  FATAL ERROR: Reached heap limit AIIocation failed - JavaScript heap out Of memory ...</span><br></pre></td></tr></table></figure><p>解决思路：</p><p>方式一：<br>vscode终端运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$env:NODE_OPTIONS&#x3D;&quot;--max-old-space-size&#x3D;8192&quot;</span><br></pre></td></tr></table></figure><p>方式二：<br>在打包时加上：npm run build –max_old_space_size=8192</p><p>方式三：<br>在package.json的script的打包命令添加：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;build&quot;: &quot;vite build &amp;&amp; node --max_old_space_size=8192&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 问题&amp;总结 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Proxy和Reflect</title>
      <link href="/ZJY.github.io/2023/06/07/Proxy%E5%92%8CReflect/"/>
      <url>/ZJY.github.io/2023/06/07/Proxy%E5%92%8CReflect/</url>
      
        <content type="html"><![CDATA[<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>Proxy对象用于创建对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。</p><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure><p>参数：</p><p><code>target</code><br>要使用Proxy包装的对象(可以是任何类型的对象，包括数组，函数，甚至另一个代理)</p><p><code>handler</code><br>一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。</p><h3 id="handler对象的方法"><a href="#handler对象的方法" class="headerlink" title="handler对象的方法"></a>handler对象的方法</h3><p>handler 对象是一个容纳一批特定属性的占位符对象。它包含有 Proxy 的各个捕获器（trap）。</p><p>traps:提供属性访问的方法</p><p>所有的捕捉器是可选的。如果没有定义某个捕捉器，那么就会保留源对象的默认行为。</p><p><code>handler.getPrototypeOf()</code><br>Object.getPrototypeOf 方法的捕获器</p><p><code>handler.setPrototypeOf()</code><br>Object.setPrototypeOf 方法的捕获器</p><p><code>handler.isExtensible()</code><br>Object.isExtensible 方法的捕捉器</p><p><code>handler.preventExtensions()</code><br>Object.preventExtensions 方法的捕捉器</p><p><code>handler.getOwnPropertyDescriptor()</code><br>Object.getOwnPropertyDescriptor 方法的捕捉器</p><p><code>handler.defineProperty()</code><br>Object.defineProperty 方法的捕捉器</p><p><code>handler.has()</code><br>in 操作符的捕捉器</p><p><code>handler.get()</code><br>属性读取操作的捕捉器</p><p><code>handler.set()</code><br>属性设置操作的捕捉器</p><p><code>handler.deleteProperty()</code><br>delete 操作符的捕捉器</p><p><code>handler.ownKeys()</code><br>Object.getOwnPropertyNames方法和Object.getOwnPropertySymbols方法的捕获器</p><p><code>handler.apply()</code><br>函数调用操作符的捕获器</p><p><code>handler.construct()</code><br>new 操作符的捕获器</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>当对象中不存在属性名时，默认返回值为 37</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params">obj, prop</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> prop <span class="keyword">in</span> obj ? obj[prop] : <span class="number">37</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line">p.a = <span class="number">1</span>;</span><br><span class="line">p.b = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.a, p.b);      <span class="comment">// 1, undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;c&#x27;</span> <span class="keyword">in</span> p, p.c); <span class="comment">// false, 37</span></span><br></pre></td></tr></table></figure><p>无操作转发代理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">p.a = <span class="number">37</span>;   <span class="comment">// 操作转发到目标</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(target.a);    <span class="comment">// 37. 操作已经被正确地转发</span></span><br></pre></td></tr></table></figure><p>通过代理，你可以轻松地验证向一个对象的传.set</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> validator = &#123;</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">obj, prop, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">&#x27;age&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">Number</span>.isInteger(value)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;The age is not an integer&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (value &gt; <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">&#x27;The age seems invalid&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The default behavior to store the value</span></span><br><span class="line">    obj[prop] = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, validator);</span><br><span class="line"></span><br><span class="line">person.age = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.age);</span><br><span class="line"><span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">person.age = <span class="string">&#x27;young&#x27;</span>;</span><br><span class="line"><span class="comment">// 抛出异常：Uncaught TypeError: The age is not an integer</span></span><br><span class="line"></span><br><span class="line">person.age = <span class="number">300</span>;</span><br><span class="line"><span class="comment">// 抛出异常：Uncaught RangeError: The age seems invalid</span></span><br></pre></td></tr></table></figure><p>vue采用什么数据劫持？<br>vue2： Object.defineProperty<br>vue3: Proxy</p><p>为什么取代？<br>1.对象直接添加新的属性或删除已有的属性，界面不会自动更新，不是响应式<br>2.直接通过下标arr[1] = “xx”更改元素或数组长度，界面不会自动更新。<br>vue2的响应式的核心是通过defineProperty对对象已有的属性值的读取和修改进行劫持。<br>只能劫持对象的属性，我们需要对每个对象的每个属性进行遍历，无法监控到数组下标的变化。</p><p>通过Proxy代理：拦截对象本身的操作，如属性的添加、删除，值的读写；可以监听对象而非属性，监听数组的变化。</p><p>Proxy缺点：<br>Object.defineProperty: IE8以下不兼容<br>Proxy：IE9以下不兼容，Edge12+支持</p><h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><p>Reflect是js内置的对象，提供拦截js操作的方法，和proxy handler方法相同。Reflect不是个函数对象，因此它是不可构造的。</p><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>Reflect并不是一个构造函数，所以不能通过new运算符进行调用，也不能作为一个函数来调用。<br>Reflect的所有属性和方法都是静态的，像Math对象。</p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>Reflect 对象提供了以下静态方法，这些方法与 proxy handler 方法的命名相同。</p><p><code>Reflect.defineProperty(target, propertyKey, attributes)</code><br>和Object.defineProperty()类似，如果设置成功返回true</p><p><code>Reflect.deleteProperty(target, propertyKey)</code><br>作为函数的delete操作符，相当于执行delete target[name]</p><p><code>Reflect.getOwnPropertyDescriptor(target, propertyKey)</code><br>类似于 Object.getOwnPropertyDescriptor()。如果对象中存在该属性，则返回对应的属性描述符，否则返回 undefined。</p><p><code>Reflect.getPrototypeOf(target)</code><br>类似于Object.getPrototypeOf()</p><p><code>Reflect.setPrototypeOf(target, prototype)</code><br>设置对象原型的函数。返回一个 Boolean，如果更新成功，则返回 true</p><p><code>Reflect.has(target, propertyKey)</code><br>判断一个对象是否存在某个属性，和 in 运算符 的功能完全相同。</p><p><code>Reflect.get(target, propertyKey[,receiver])</code><br>获取对象身上某个属性的值，类似于target[name]</p><p><code>Reflect.set(target, propertyKey, value[, receiver])</code><br>将值分配给属性的函数。返回一个Boolean，如果更新成功，则返回true。</p><p><code>Reflect.isExtensible(target)</code><br>类似于 Object.isExtensible().</p><p><code>Reflect.preventExtensions(target)</code><br>类似于 Object.preventExtensions()。返回一个Boolean。</p><p><code>Reflect.ownKeys(target)</code><br>返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 Object.keys(), 但不会受enumerable 影响).</p><p><code>Reflect.apply(target, thisArugument, argumentsList)</code><br>对一个函数进行调用操作，同时可以传入一个数组作为调用参数。和 Function.prototype.apply() 功能类似。</p><p><code>Reflect.construct(target, argumentsList[, newTarget])</code><br>对构造函数进行new操作，相当于执行，new target(…args)</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>检查一个对象是否有特定属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> duck = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Maurice&#x27;</span>,</span><br><span class="line">  color: <span class="string">&#x27;white&#x27;</span>,</span><br><span class="line">  greeting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Quaaaack! My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.has(duck, <span class="string">&#x27;color&#x27;</span>);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Reflect</span>.has(duck, <span class="string">&#x27;haircut&#x27;</span>);</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>返回对象自身的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.ownKeys(duck);</span><br><span class="line"><span class="comment">// [ &quot;name&quot;, &quot;color&quot;, &quot;greeting&quot; ]</span></span><br></pre></td></tr></table></figure><p>为这个对象添加一个新的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.set(duck, <span class="string">&#x27;eyes&#x27;</span>, <span class="string">&#x27;black&#x27;</span>);</span><br><span class="line"><span class="comment">// returns &quot;true&quot; if successful</span></span><br><span class="line"><span class="comment">// &quot;duck&quot; now contains the property &quot;eyes: &#x27;black&#x27;&quot;</span></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(duck)</span><br><span class="line"><span class="comment">// (5) [&#x27;name&#x27;, &#x27;color&#x27;, &#x27;greeting&#x27;, &#x27;eyes&#x27;]</span></span><br></pre></td></tr></table></figure><p>获取某个属性的描述：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.getOwnPropertyDescriptor(duck, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123;value: &#x27;Maurice&#x27;, writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h2><p>Object.getPrototypeOf()静态方法返回指定对象的原型（即[[Prototype]]属性的值）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(proto);</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(obj) === proto; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h2><p>Object.setPrototypeOf()静态方法可以将一个指定的对象的原型（即内部的[[Propotype]]的值）设置成另一个对象或null值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> parent = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.foo);</span><br><span class="line"><span class="comment">// Expected output: undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, parent);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line">  <span class="comment">// [[Prototype]]: &#123;</span></span><br><span class="line">  <span class="comment">//   foo: &#x27;bar&#x27;,</span></span><br><span class="line">  <span class="comment">//   [[Prototype]]: Object</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.foo);</span><br><span class="line"><span class="comment">// Expected output: &quot;bar&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h2><p>Object.defineProperty()静态方法会在一个指定的对象新增一个属性或修改现有属性，并返回此对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(object1, <span class="string">&#x27;property1&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="number">42</span>,</span><br><span class="line">  writable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">object1.property1 = <span class="number">77</span>;</span><br><span class="line"><span class="comment">// Throws an error in strict mode</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(object1.property1);</span><br><span class="line"><span class="comment">// Expected output: 42</span></span><br></pre></td></tr></table></figure><h2 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor()"></a>Object.getOwnPropertyDescriptor()</h2><p>Object.getOwnPropertyDescriptor()静态方法返回一个对象，该对象描述给定对象属性的配置（即直接存在于对象上而不在原型链上的属性）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;</span><br><span class="line">  property1: <span class="number">42</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> descriptor1 = <span class="built_in">Object</span>.getOwnPropertyDescriptor(object1, <span class="string">&#x27;property1&#x27;</span>);</span><br><span class="line"><span class="comment">// &#123;value: 42, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(descriptor1.configurable);</span><br><span class="line"><span class="comment">// Expected output: true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(descriptor1.value);</span><br><span class="line"><span class="comment">// Expected output: 42</span></span><br></pre></td></tr></table></figure><h2 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h2><p>Object.getOwnPropertyNames()静态方法返回一个数组，其包含对象种所有自有属性（包括不可枚举属性，但不包含使用symbol作为key的属性）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="built_in">Symbol</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> object1 = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span>,</span><br><span class="line">  [target]: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(object1));</span><br><span class="line"><span class="comment">// Expected output: Array [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure><h2 id="Object-getOwnPropertySymbols"><a href="#Object-getOwnPropertySymbols" class="headerlink" title="Object.getOwnPropertySymbols()"></a>Object.getOwnPropertySymbols()</h2><p>Object.getOwnPropertySymbols()静态方法返回一个包含给定对象自有Symbol属性的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">Symbol</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> b = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line">object1[a] = <span class="string">&#x27;localSymbol&#x27;</span>;</span><br><span class="line">object1[b] = <span class="string">&#x27;globalSymbol&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(object1);</span><br><span class="line"><span class="comment">//  [Symbol(a), Symbol(b)]</span></span><br></pre></td></tr></table></figure><h2 id="Object-isExtensible"><a href="#Object-isExtensible" class="headerlink" title="Object.isExtensible()"></a>Object.isExtensible()</h2><p>Object.isExtensible()静态方法判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(object1)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(object1)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(object1)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>默认情况下，对象是可扩展的：可以向它们添加新属性，并且它们的 [[Prototype]] 可以被重新赋值。可以使用 Object.preventExtensions()、Object.seal()、Object.freeze() 或 Reflect.preventExtensions() 中的任一方法将对象标记为不可扩展。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新对象是可拓展的。</span></span><br><span class="line"><span class="keyword">const</span> empty = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.isExtensible(empty); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 它们可以变为不可拓展的</span></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(empty);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(empty)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据定义，密封对象是不可拓展的。</span></span><br><span class="line"><span class="keyword">const</span> sealed = <span class="built_in">Object</span>.seal(&#123;&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(sealed)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据定义，冻结对象同样也是不可拓展的。</span></span><br><span class="line"><span class="keyword">const</span> frozen = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(frozen)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="Object-preventExtensions"><a href="#Object-preventExtensions" class="headerlink" title="Object.preventExtensions()"></a>Object.preventExtensions()</h2><p>Object.preventExtensions()静态方法可以防止新属性被添加（即阻止对象被扩展）。它还可以阻止对象的原型被重新指定。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(object1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(object1, <span class="string">&#x27;property1&#x27;</span>, &#123;</span><br><span class="line">    value: <span class="number">42</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">  <span class="comment">// Expected output: TypeError: Cannot define property property1, object is not extensible</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h2><p>Object.keys()静态方法返回一个给定对象的自身可枚举字符串属性名组成的数组(不包含Symbol)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> d= <span class="built_in">Symbol</span>(<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> object1 = &#123;</span><br><span class="line">  a: <span class="string">&#x27;somestring&#x27;</span>,</span><br><span class="line">  b: <span class="number">42</span>,</span><br><span class="line">  c: <span class="literal">false</span>,</span><br><span class="line">  [d]: <span class="string">&#x27;test&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(object1));</span><br><span class="line"><span class="comment">// Expected output: Array [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure><h2 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h2><p>Object.values()静态方法返回一个给定对象的自身可枚举字符串键属性的值组成的数组(不包含Symbol)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> d= <span class="built_in">Symbol</span>(<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> object1 = &#123;</span><br><span class="line">  a: <span class="string">&#x27;somestring&#x27;</span>,</span><br><span class="line">  b: <span class="number">42</span>,</span><br><span class="line">  c: <span class="literal">false</span>,</span><br><span class="line">  [d]: <span class="string">&#x27;test&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(object1));</span><br><span class="line"><span class="comment">// Expected output: Array [&#x27;somestring&#x27;, 42, false]</span></span><br></pre></td></tr></table></figure><h2 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h2><p>Object.entries()静态方法返回一个数组，包含对象自身可枚举字符串键属性的键值对。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;</span><br><span class="line">  a: <span class="string">&#x27;somestring&#x27;</span>,</span><br><span class="line">  b: <span class="number">42</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(object1))</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//   [&#x27;a&#x27;, &#x27;somestring&#x27;]</span></span><br><span class="line"><span class="comment">//   [&#x27;b&#x27;, 42]</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure><h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><p>Object.assign()静态方法将一个或多个源对象所有自身可枚举属性（包含Symbol）复制到目标对象中，并返回修改后的目标对象。目标对象也将被修改。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source = &#123; <span class="attr">b</span>: <span class="number">4</span>, <span class="attr">c</span>: <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>:<span class="number">3</span>, <span class="attr">d</span>: <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> returnedTarget = <span class="built_in">Object</span>.assign(target, source, source1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(target);</span><br><span class="line"><span class="comment">// Expected output: Object &#123; a: 1, b: 3, c: 5, d: 6 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(returnedTarget === target); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果目标对象与源对象具有相同的键（属性名），则目标对象中的属性将被源对象中的属性覆盖，后面的源对象的属性将类似地覆盖前面的源对象的同名属性。</p><p>Object.assign() 方法只会拷贝源对象可枚举的的自有属性到目标对象。该方法在源对象上使用 [[Get]]，在目标对象上使用 [[Set]]，因此它会调用 getter 和 setter。故它对属性进行赋值，而不仅仅是复制或定义新的属性。如果要合并的源对象包含 getter，这可能使其不适合将新属性合并到原型中.</p><p>字符串和 Symbol 类型属性都会被复制.</p><p>Object.assign()是浅拷贝，只复制属性值。</p><h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h2><p>Object.create()静态方法以一个现有对象为原型，创建一个新的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  isHuman: <span class="literal">false</span>,</span><br><span class="line">  printIntroduction: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>. Am I human? <span class="subst">$&#123;<span class="built_in">this</span>.isHuman&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="built_in">Object</span>.create(person);</span><br><span class="line"></span><br><span class="line">me.name = <span class="string">&#x27;Matthew&#x27;</span>; <span class="comment">// &quot;name&quot; is a property set on &quot;me&quot;, but not on &quot;person&quot;</span></span><br><span class="line">me.isHuman = <span class="literal">true</span>; <span class="comment">// Inherited properties can be overwritten</span></span><br><span class="line"></span><br><span class="line">me.printIntroduction();</span><br><span class="line"><span class="comment">// Expected output: &quot;My name is Matthew. Am I human? true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(me)</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   isHuman: true</span></span><br><span class="line"><span class="comment">//   name: &quot;Matthew&quot;</span></span><br><span class="line"><span class="comment">//   [[Prototype]]: Object</span></span><br><span class="line"><span class="comment">//     isHuman: false</span></span><br><span class="line"><span class="comment">//     printIntroduction: ƒ ()</span></span><br><span class="line"><span class="comment">//     [[Prototype]]: Object</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(me) === person <span class="comment">// true</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象</title>
      <link href="/ZJY.github.io/2023/06/06/%E5%AF%B9%E8%B1%A1/"/>
      <url>/ZJY.github.io/2023/06/06/%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>对象是一组属性的集合，无序的数据结构，类似于key-value<br>创建对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">person.name = <span class="string">&#x27;lucy&#x27;</span></span><br><span class="line">person.age = <span class="number">20</span></span><br><span class="line">person.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方式二：</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;lucy&#x27;</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方式三：</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, prop, options)</span><br></pre></td></tr></table></figure><h3 id="Object-defineProperty-obj-prop-options"><a href="#Object-defineProperty-obj-prop-options" class="headerlink" title="Object.defineProperty(obj, prop, options)"></a>Object.defineProperty(obj, prop, options)</h3><p>参数：</p><ul><li>obj： 对象</li><li>prop： 属性</li><li>options： 选项配置<ul><li>writable: true/false 是否可修改</li><li>value：属性的值，默认undefined</li><li>enumable: 是否可枚举，for…in遍历</li><li>configurable: 属性是否可删除；是否可配置其他配置项</li><li>get： 读取属性时的前置调用</li><li>set：设置属性时的前置调用</li></ul></li></ul><h3 id="Object-getOwnPropertyDescriptor返回对象的属性描述"><a href="#Object-getOwnPropertyDescriptor返回对象的属性描述" class="headerlink" title="Object.getOwnPropertyDescriptor返回对象的属性描述"></a>Object.getOwnPropertyDescriptor返回对象的属性描述</h3><h3 id="Object-assign-target-sourceObj-…sourceObj-合并对象"><a href="#Object-assign-target-sourceObj-…sourceObj-合并对象" class="headerlink" title="Object.assign(target, sourceObj, …sourceObj)合并对象"></a>Object.assign(target, sourceObj, …sourceObj)合并对象</h3><p>接收参数为一个目标对象和一个或多个源对象作为参数，只复制源对象的可枚举属性和自由属性。先使用符合条件的源对象的属性的get访问器获取属性的值，再用目标对象的set方法设置属性的值。<br>注意：Object.assign()是浅拷贝，异常会终止并提前退出，返回一个尽量部分完成的版本。</p><h3 id="Object-is-静态方法确定两个值是否为相同值。"><a href="#Object-is-静态方法确定两个值是否为相同值。" class="headerlink" title="Object.is() 静态方法确定两个值是否为相同值。"></a>Object.is() 静态方法确定两个值是否为相同值。</h3><p>语法： Object.is(value1, value2)<br>返回值：指示两个参数是否相同的值<br>判断两个值是否相同值，如果以下其中一项成立，则两个值相同：</p><ul><li>都是undefiend</li><li>都是null</li><li>都是true或者都是false</li><li>都是长度相同、字符形同、顺序相同的字符串</li><li>都是相同的对象（意味着两个值引用了内存中同一个对象）</li><li>都是BigInt且具有相同的数值</li><li>都是Symbol且引用相同的symbol值</li><li>都是数字，且：<ul><li>都是+0</li><li>都是-0</li><li>都是NaN</li><li>都有相同的值，非零且都不是NaN</li></ul></li></ul><p>Object.is() 和 === 之间的唯一区别在于它们处理带符号的 0 和 NaN 值的时候。=== 运算符（和 == 运算符）将数值 -0 和 +0 视为相等，但是会将 NaN 视为彼此不相等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">0</span> === <span class="number">0</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(-<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="为什么vue的data是函数形式-data-return-，methods是对象-methods"><a href="#为什么vue的data是函数形式-data-return-，methods是对象-methods" class="headerlink" title="为什么vue的data是函数形式(data() {return {} })，methods是对象(methods: {})?"></a>为什么vue的data是函数形式(data() {return {} })，methods是对象(methods: {})?</h2><p>组件是可复用的，如果data是一个对象，则所有组件实例共享同一个对象，造成数据污染；调用data函数返回一个的新的独立对象，如果可以保证组件是唯一的也可以不写函数直接写对象。</p><p>methods装的是函数方法，只需要调用不需要改变，所以多个组件实例共享同一个函数没有影响，反而只需要更少的空间，和把公有方法放原型链上相似。</p><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>每个对象（object）都有一个私有属性指向另一个名为原型（prototype）的对象。原型对象也有一个自己的原型，层层向上直到一个对象的原型为 null。根据定义，null 没有原型，并作为这个原型链（prototype chain）中的最后一个环节。</p><p>JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</p><p>所有引用类型都有__proto__隐式原型属性，是一个对象<br>所有函数都有一个prototype原型属性，是一个对象<br>所有引用类型的__proto__都指向它构造函数的prototype</p><p>工厂模式：批量创建结构类似的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">  o.name = name</span><br><span class="line">  o.age = age</span><br><span class="line">  o.job = job</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数模式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">  <span class="built_in">this</span>.job = job</span><br><span class="line">  <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;lucy&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;software engineer&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> Person(<span class="string">&#x27;greg&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;Doctor&#x27;</span>)</span><br><span class="line">person1.sayName()</span><br><span class="line">person2.sayName()</span><br></pre></td></tr></table></figure><p>构造函数需要使用new关键字</p><p>new 关键字会进行如下操作：</p><ul><li>创建一个空的简单js对象（即{}）；</li><li>为新创建的对象添加属性<strong>proto</strong>,将该属性链接到构造函数的原型对象；</li><li>将新创建的对象作为this的上下文；</li><li>如果该函数没有返回对象，则返回this；</li></ul><p>每一个实例的公共方法和属性都是再new语法和构造过程中创建的</p><p>每个构造函数都有一个原型属性，所有该构造函数创建的实例都共享这个构造函数的原型属性。<br>当访问对象的一个属性时，会先在这个对象的属性中查找，如果没有找到就去它的<strong>proto__隐式原型中查找，即它的构造函数的prototype，如果还没有找到就去构造函数的prototype.__proto__中查找，这样一层一层的向上查找形成的链式结构叫原型链。一直往上层查找，直到null还没有找到，返回undefined<br>Object.prototype.__proto</strong> === null</p><h3 id="constructor属性"><a href="#constructor属性" class="headerlink" title="constructor属性"></a>constructor属性</h3><p>除了null原型对象外，任何对象都会再其[[prototype]]上有一个constructor属性。使用字面量创建的对象也会有一个指向该对象构造函数类型的 constructor 属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 = &#123;&#125;;</span><br><span class="line">o1.constructor === <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o2.constructor === <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a1 = [];</span><br><span class="line">a1.constructor === <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a2 = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">a2.constructor === <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> n = <span class="number">3</span>;</span><br><span class="line">n.constructor === <span class="built_in">Number</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>constructor 属性通常来自构造函数的 prototype 属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Fn.prototype = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> Fn()</span><br><span class="line">f.constructor === <span class="built_in">Array</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">obj.__proto__ === <span class="built_in">Object</span>.prototype</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">obj.constructor === <span class="built_in">Object</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">obj.__proto__ === obj.constructor.prototype</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="判断对象自有属性还是原型属性"><a href="#判断对象自有属性还是原型属性" class="headerlink" title="判断对象自有属性还是原型属性"></a>判断对象自有属性还是原型属性</h3><ol><li>Object.hasOwnProperty(‘property’)方法返回一个布尔值，表示对象自有属性（而不是继承来的属性）中是否具有指定的属性。</li><li>for…in 语句以任意顺序迭代一个对象的除Symbol以外的可枚举属性，包括继承的可枚举属性。</li><li>Object.keys()静态方法返回一个由给定对象自身的可枚举的字符串键属性名组成的数组(不包含Symbol)</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> triangle = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ColoredTriangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ColoredTriangle.prototype = triangle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> ColoredTriangle();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj.hasOwnProperty(prop)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`obj.<span class="subst">$&#123;prop&#125;</span> = <span class="subst">$&#123;obj[prop]&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// &quot;obj.color = red&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`obj.<span class="subst">$&#123;prop&#125;</span> = <span class="subst">$&#123;obj[prop]&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// obj.color = red</span></span><br><span class="line"><span class="comment">// obj.a = 1</span></span><br><span class="line"><span class="comment">// obj.b = 2</span></span><br><span class="line"><span class="comment">// obj.c = 3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(triangle))</span><br><span class="line"><span class="comment">//  [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><p>键的顺序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 键的顺序随机的类数组对象</span></span><br><span class="line"><span class="keyword">const</span> anObj = &#123; <span class="number">100</span>: <span class="string">&quot;a&quot;</span>, <span class="number">2</span>: <span class="string">&quot;b&quot;</span>, <span class="number">7</span>: <span class="string">&quot;c&quot;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(anObj)); <span class="comment">// [&#x27;2&#x27;, &#x27;7&#x27;, &#x27;100&#x27;]</span></span><br><span class="line"><span class="comment">// (3) [&#x27;2&#x27;, &#x27;7&#x27;, &#x27;100&#x27;]</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> anObj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 7</span></span><br><span class="line"><span class="comment">// 100</span></span><br></pre></td></tr></table></figure><p>先数字字符串按生序再字母字符串按添加顺序再Symbol键名</p><p>Object.keys()和for…in枚举顺序是不固定的</p><p>Object.keys()获取自身可枚举属性所有键的数组（不包含Symbol健名）<br>Object.values()获取自身可枚举属性所有值的数组（不包含Symbol健值）<br>Object.entries()获取自身可枚举属性所有键值对的数组（不包含Symbol健值对）</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生成器</title>
      <link href="/ZJY.github.io/2023/06/02/%E7%94%9F%E6%88%90%E5%99%A8/"/>
      <url>/ZJY.github.io/2023/06/02/%E7%94%9F%E6%88%90%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>生成器可以在函数内暂停和恢复执行。</p><h2 id="生成器基础"><a href="#生成器基础" class="headerlink" title="生成器基础"></a>生成器基础</h2><p>生成器的形式是函数，在函数名前面加“*”，表示它是一个生成器。所有可以定义函数的地方都可以定义生成器，除了箭头函数。<br>标识生成器函数的星号不受空格限制。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成器函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">Fun</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 生成器函数表达式</span></span><br><span class="line"><span class="keyword">let</span> fun = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 对象字面量</span></span><br><span class="line"><span class="keyword">let</span> foo = &#123;</span><br><span class="line">  * <span class="function"><span class="title">fun</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 作为实例方法的生成器函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  * <span class="function"><span class="title">fun</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 作为静态方法的生成器函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> * <span class="function"><span class="title">fun</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用生成器函数会产生一个生成器对象。生成器对象一开始是暂停（Suspend）状态。与迭代器相似，生成器也实现了Iterator接口，因此具有next()方法。调用这个方法会让生成器开始或恢复执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> g = generatorFn()</span><br><span class="line"><span class="built_in">console</span>.log(g)</span><br><span class="line"><span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>next()方法的返回值类似迭代器，有一个done属性和value属性。函数体为空的生成器函数中间不会停留。调用next()就会让生成器到达done: true状态。</p><p>value属性是生成器函数的返回值，默认undefiend，可以通过生成器函数的返回值指定：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = generatorFn()</span><br><span class="line"><span class="built_in">console</span>.log(g) <span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next()) <span class="comment">// &#123;value: &#x27;foo&#x27;, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>生成器实现了Iterator接口，它们默认的迭代器是自引用的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g === g[<span class="built_in">Symbol</span>.iterator]() <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="通过yield中断执行"><a href="#通过yield中断执行" class="headerlink" title="通过yield中断执行"></a>通过yield中断执行</h2><p>yield关键字可以让生成器停止和开始执行。</p><p>生成器函数在遇到yield关键字之前正常执行，遇到这个关键字后，停止执行，函数作用域的状态会被保留，停止执行的生成器函数只能调用生成器对象的next()方法来恢复执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = generatorFn()</span><br><span class="line"><span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: false&#125;</span></span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>yield有点像函数的中间返回语句，它生成的值会作为next()方法的返回对象。通过yield关键字退出的生成器函数处于done: false状态，通过return退出的生成器函数会处于done: true状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;zoo&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = generatorFn()</span><br><span class="line">g.next()</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="string">&#x27;foo&#x27;</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// &#123;value: &#x27;bar&#x27;, done: false&#125;</span></span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// &#123;value: &#x27;zoo&#x27;, done: true&#125;</span></span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>生成器函数内部的执行流程会针对每个生成器对象区分作用域，在一个生成器对象上调用next()不会影响其他生成器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g1 = generatorFn()</span><br><span class="line"><span class="keyword">let</span> g2 = generatorFn()</span><br><span class="line">g1.next()</span><br><span class="line"><span class="comment">// &#123;value: &#x27;foo&#x27;, done: false&#125;</span></span><br><span class="line">g2.next()</span><br><span class="line"><span class="comment">// &#123;value: &#x27;foo&#x27;, done: false&#125;</span></span><br></pre></td></tr></table></figure><p><strong><em>yield关键字只能在生成器函数内部使用，用在其他地方会抛出错误。</em></strong><br><strong><em>yield关键字必须直接位于生成器函数定义中，出现在嵌套的生成器函数会抛出错误。</em></strong></p><h3 id="1-生成器函数作为可迭代对象"><a href="#1-生成器函数作为可迭代对象" class="headerlink" title="1.生成器函数作为可迭代对象"></a>1.生成器函数作为可迭代对象</h3><p>显式调用生成器对象的next()方法的作用不大，把生成器对象当成可迭代对象会更加方便：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> generatorFn()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="2-使用yield实现输入输出"><a href="#2-使用yield实现输入输出" class="headerlink" title="2.使用yield实现输入输出"></a>2.使用yield实现输入输出</h3><p>第一次调用next()方法传入的值不会被使用，因为这一次调用为了开始执行生成器函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFn</span>(<span class="params">initial</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(initial)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">yield</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = generatorFn(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">g.next(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// &#123;value: undefined, done: false&#125;</span></span><br><span class="line">g.next(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// &#123;value: undefined, done: false&#125;</span></span><br><span class="line">g.next(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>yield关键字可同时用于输入和输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">yield</span> <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = generatorFn()</span><br><span class="line"></span><br><span class="line">g.next()</span><br><span class="line"><span class="comment">// &#123;value: &#x27;foo&#x27;, done: false&#125;</span></span><br><span class="line">g.next(<span class="string">&#x27;bar&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123;value: &#x27;bar&#x27;, done: true&#125;</span></span><br><span class="line">g.next(<span class="string">&#x27;bar1&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><h3 id="3-产生可迭代对象"><a href="#3-产生可迭代对象" class="headerlink" title="3.产生可迭代对象"></a>3.产生可迭代对象</h3><p>可以使用星号增强yield的行为，让它能够迭代一个可迭代对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) &#123;</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = generatorFn()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> g) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> * [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g1 = generatorFn1()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> g1) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>与生成器函数类似，yield关键字星号不受两侧空格影响：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span>* [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">yield</span> *[<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">    <span class="keyword">yield</span> * [<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g1 = generatorFn1()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> g1) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 7</span></span><br></pre></td></tr></table></figure><h3 id="4-使用yield实现递归"><a href="#4-使用yield实现递归" class="headerlink" title="4.使用yield实现递归"></a>4.使用yield实现递归</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">nTimes</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> * nTimes(n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">yield</span> n - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> nTimes(<span class="number">3</span>)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h2 id="生成器作为默认迭代器"><a href="#生成器作为默认迭代器" class="headerlink" title="生成器作为默认迭代器"></a>生成器作为默认迭代器</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    * [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">yield</span> * <span class="built_in">this</span>.values</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> Foo()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> f) &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(x)   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h2 id="提前终止生成器"><a href="#提前终止生成器" class="headerlink" title="提前终止生成器"></a>提前终止生成器</h2><p>一个实现Iterator接口的对象一定有next()方法和一个可选的return()方法用于提前终止迭代器。<br>生成器对象除了有next,return方法还有throw()方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> g = generatorFn()</span><br><span class="line"><span class="built_in">console</span>.log(g)</span><br><span class="line"><span class="built_in">console</span>.log(g.next)</span><br><span class="line"><span class="built_in">console</span>.log(g.return)</span><br><span class="line"><span class="built_in">console</span>.log(g.throw)</span><br><span class="line"></span><br><span class="line"><span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="comment">// ƒ next() &#123; [native code] &#125;</span></span><br><span class="line"><span class="comment">// ƒ return() &#123; [native code] &#125;</span></span><br><span class="line"><span class="comment">// ƒ throw() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure><p>return和throw都可以强制生成器进入关闭状态。</p><h3 id="1-return"><a href="#1-return" class="headerlink" title="1.return()"></a>1.return()</h3><p>提供给return的值就是终止迭代器对象的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> * [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = generatorFn()</span><br><span class="line"><span class="built_in">console</span>.log(g)</span><br><span class="line"><span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.return(<span class="number">4</span>))</span><br><span class="line"><span class="comment">// &#123;value: 4, done: true&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g)</span><br><span class="line"><span class="comment">// generatorFn &#123;&lt;closed&gt;&#125;</span></span><br></pre></td></tr></table></figure><p>与迭代器不同，所有生成器对象都有return方法，只要通过它进入关闭状态就无法恢复了，后续调用next()会显示done: true状态，而提供的任何值都不会被存储。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> * [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = generatorFn()</span><br><span class="line"><span class="built_in">console</span>.log(g)</span><br><span class="line"><span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.return(<span class="number">4</span>))</span><br><span class="line"><span class="comment">// &#123;value: 4, done: true&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g)</span><br><span class="line"><span class="comment">// generatorFn &#123;&lt;closed&gt;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next(<span class="number">5</span>))</span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-throw"><a href="#2-throw" class="headerlink" title="2.throw()"></a>2.throw()</h3><p>throw方法会在暂停的时候提供一个错误注入到生成器对象中，如果错误未被处理，生成器就会关闭：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> * [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = generatorFn()</span><br><span class="line"><span class="built_in">console</span>.log(g)</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    g.throw(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;catch:&#x27;</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(g)</span><br><span class="line"><span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="comment">// catch: foo</span></span><br><span class="line"><span class="comment">// generatorFn &#123;&lt;closed&gt;&#125;</span></span><br></pre></td></tr></table></figure><p>如果在生成器函数内部处理了这个错误，生成器就不会被关闭，而且还可以恢复执行，错误处理会跳过yield，因此在这个例子中会跳过一个值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">generatorFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">yield</span> i</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;catch:&#x27;</span>, error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = generatorFn()</span><br><span class="line"><span class="built_in">console</span>.log(g)</span><br><span class="line"><span class="comment">// generatorFn &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line">g.next()</span><br><span class="line">&#123;<span class="comment">/* &#123;value: 1, done: false&#125; */</span>&#125;</span><br><span class="line">g.throw(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">&#123;<span class="comment">/*  catch: foo */</span>&#125;</span><br><span class="line">g.next()</span><br><span class="line">&#123;<span class="comment">/* &#123;value: 3, done: false&#125; */</span>&#125;</span><br></pre></td></tr></table></figure><p>如果生成器函数还没有开始执行，那么调用throw抛出的错误不会在函数内部被捕获，因为这相当于在函数块外部抛出了错误。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>迭代器是一个可以由任意对象实现的接口，支持连续获取对象产出的每一个值。任何实现 Iterable 接口的对象都有一个 Symbol.iterator 属性，这个属性引用默认迭代器。默认迭代器就像一个迭代器 工厂，也就是一个函数，调用之后会产生一个实现 Iterator 接口的对象。 </p><p>迭代器必须通过连续调用 next()方法才能连续取得值，这个方法返回一个 IteratorObject。这 个对象包含一个 done 属性和一个 value 属性。前者是一个布尔值，表示是否还有更多值可以访问；后 者包含迭代器返回的当前值。这个接口可以通过手动反复调用 next()方法来消费，也可以通过原生消 费者，比如 for-of 循环来自动消费。</p><p>生成器是一种特殊的函数，调用之后会返回一个生成器对象。生成器对象实现了 Iterable 接口， 因此可用在任何消费可迭代对象的地方。生成器的独特之处在于支持 yield 关键字，这个关键字能够 暂停执行生成器函数。使用 yield 关键字还可以通过 next()方法接收输入和产生输出。在加上星号之 后，yield 关键字可以将跟在它后面的可迭代对象序列化为一连串值。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>稀疏数组的理解</title>
      <link href="/ZJY.github.io/2023/06/02/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"/>
      <url>/ZJY.github.io/2023/06/02/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>数组可以包含“空槽”，这与用值undefined填充的槽不一样。空槽可以用以下方式创建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array构造函数</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">Array</span>(<span class="number">5</span>) <span class="comment">// [empty × 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组字面量中的连续逗号：</span></span><br><span class="line"><span class="keyword">const</span> b = [<span class="number">1</span>,<span class="number">2</span>,,,<span class="number">5</span>] <span class="comment">// [1,2,empty × 2, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接给大于数组length的索引设置以形成空槽：</span></span><br><span class="line"><span class="keyword">let</span> c = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">c[<span class="number">4</span>] = <span class="number">5</span> <span class="comment">// [1,2,empty × 2, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过设置length长度拉长一个数组：</span></span><br><span class="line"><span class="keyword">const</span> d = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">d.length = <span class="number">5</span> <span class="comment">// [1, 2, empty × 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过delete删除一个元素：</span></span><br><span class="line"><span class="keyword">const</span> e = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">delete</span> e[<span class="number">2</span>]; <span class="comment">// [ 1, 2, &lt;1 empty item&gt;, 4, 5 ]</span></span><br></pre></td></tr></table></figure><p>在某些操作中，空槽的行为就像它们被填入了undefined一样。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, , , <span class="number">5</span>]; <span class="comment">// 创建一个稀疏数组</span></span><br><span class="line"><span class="comment">// 通过索引访问：</span></span><br><span class="line">arr[<span class="number">2</span>] <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// for...of</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开运算</span></span><br><span class="line"><span class="keyword">const</span> another = [...arr] <span class="comment">// [1,2,undefined, undefined, 5]</span></span><br></pre></td></tr></table></figure><p>在其他方法中，特别是数组迭代中，空槽是被跳过的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,,,<span class="number">5</span>] <span class="comment">// [1, 2, empty, empty, 5]</span></span><br><span class="line"><span class="keyword">const</span> another = [...arr] <span class="comment">// [1, 2, undefined, undefined, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map</span></span><br><span class="line">arr.map(<span class="function">(<span class="params">i</span>) =&gt;</span> i + <span class="number">1</span>) <span class="comment">// [2, 3, empty × 2, 6]</span></span><br><span class="line">another.map(<span class="function">(<span class="params">i</span>) =&gt;</span> i + <span class="number">1</span>) <span class="comment">// [2, 3, NaN, NaN, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach</span></span><br><span class="line">arr.forEach(<span class="function">(<span class="params">i</span>) =&gt;</span> <span class="built_in">console</span>.log(i)) <span class="comment">// 1, 2, 5</span></span><br><span class="line">another.forEach(<span class="function">(<span class="params">i</span>) =&gt;</span> <span class="built_in">console</span>.log(i)) <span class="comment">// 1, 2, undefined, undefined, 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filter</span></span><br><span class="line">arr.filter(<span class="function">() =&gt;</span> <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// (3) [1, 2, 5]</span></span><br><span class="line">another.filter(<span class="function">() =&gt;</span> <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// (5) [1, 2, undefined, undefined, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// some</span></span><br><span class="line">arr.some(<span class="function">(<span class="params">k</span>) =&gt;</span> !k);</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">another.some(<span class="function">(<span class="params">k</span>) =&gt;</span> !k);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性迭代</span></span><br><span class="line"><span class="built_in">Object</span>.keys(arr)</span><br><span class="line"><span class="comment">// (3) [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;4&#x27;]</span></span><br><span class="line"><span class="built_in">Object</span>.keys(another)</span><br><span class="line"><span class="comment">// (5) [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.values(arr)</span><br><span class="line"><span class="comment">// (3) [1, 2, 5]</span></span><br><span class="line"><span class="built_in">Object</span>.values(another)</span><br><span class="line"><span class="comment">// (5) [1, 2, undefined, undefined, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (3) [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;4&#x27;]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> another) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (5) [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在对象中展开，使用属性枚举，而不是数组迭代器</span></span><br><span class="line"><span class="keyword">const</span> target = &#123;...arr&#125;</span><br><span class="line"><span class="comment">// &#123;0: 1, 1: 2, 4: 5&#125;</span></span><br><span class="line"><span class="keyword">const</span> target1 = &#123;...another&#125;</span><br><span class="line"><span class="comment">// &#123;0: 1, 1: 2, 2: undefined, 3: undefined, 4: 5&#125;</span></span><br></pre></td></tr></table></figure><p>稀疏数组中的空槽在数组方法之间的行为不一致。通常，旧方法会跳过空槽，而新方法将它们视为 undefined。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Array.from()的使用</title>
      <link href="/ZJY.github.io/2023/06/02/Array-from%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/ZJY.github.io/2023/06/02/Array-from%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Array.from()静态方法从可迭代或类数组对象创建一个新的浅拷贝的数组实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(<span class="string">&#x27;foo&#x27;</span>))</span><br><span class="line"><span class="comment">// [&#x27;f&#x27;, &#x27;o&#x27;, &#x27;o&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function"><span class="params">x</span> =&gt;</span> x + x))</span><br><span class="line"><span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike)</span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike, mapFn?)</span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike, mapFn?, thisArg?)</span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><code>arrayLike</code><br>想要转换成数组的可迭代或类数组对象</p><p><code>mapFn</code>(可选)<br>调用数组每个元素的函数。如果提供，每个添加到数组的值首先传递给该函数，然后将mapFn的返回值添加到数组中。该函数提供以下参数：</p><p>  element<br>  数组当前正在处理的元素</p><p>  index<br>  数组当前正在处理的元素的索引</p><p><code>thisArg</code>(可选)<br>执行mapFn时用作this的值</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>一个新的数组实例</p><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><ul><li>可迭代对象（例如map和set）</li><li>类数组对象（带有length属性和索引元素的对象）</li></ul><p>Array.from不会创建<a href="/ZJY.github.io/2023/06/02/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/" title="稀疏数组">稀疏数组</a>,如果arrayLike缺少一些索引属性，那么这些属性在数组中将是undefined。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(&#123;<span class="attr">length</span>: <span class="number">5</span>&#125;))</span><br><span class="line"><span class="comment">// [undefined, undefined, undefined, undefined, undefined]</span></span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="从字符串构建数组"><a href="#从字符串构建数组" class="headerlink" title="从字符串构建数组"></a>从字符串构建数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="comment">// [ &quot;f&quot;, &quot;o&quot;, &quot;o&quot; ]</span></span><br></pre></td></tr></table></figure><h3 id="从Set构建数组"><a href="#从Set构建数组" class="headerlink" title="从Set构建数组"></a>从Set构建数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>, <span class="string">&quot;foo&quot;</span>]);</span><br><span class="line"><span class="built_in">Array</span>.from(set);</span><br><span class="line"><span class="comment">// [ &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot; ]</span></span><br></pre></td></tr></table></figure><h3 id="从Map构建数组"><a href="#从Map构建数组" class="headerlink" title="从Map构建数组"></a>从Map构建数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">4</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">8</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">Array</span>.from(map);</span><br><span class="line"><span class="comment">// [[1, 2], [2, 4], [4, 8]]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapper = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;a&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;2&quot;</span>, <span class="string">&quot;b&quot;</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">Array</span>.from(mapper.values());</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;];</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from(mapper.keys());</span><br><span class="line"><span class="comment">// [&#x27;1&#x27;, &#x27;2&#x27;];</span></span><br></pre></td></tr></table></figure><h3 id="从NodeList创建数组"><a href="#从NodeList创建数组" class="headerlink" title="从NodeList创建数组"></a>从NodeList创建数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> images = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;img&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(images)</span><br><span class="line"><span class="keyword">const</span> sources = <span class="built_in">Array</span>.from(images, <span class="function">(<span class="params">image</span>) =&gt;</span> image.src);</span><br><span class="line"><span class="built_in">console</span>.log(sources)</span><br><span class="line"><span class="keyword">const</span> insecureSources = sources.filter(<span class="function">(<span class="params">link</span>) =&gt;</span> link.startsWith(<span class="string">&quot;http://&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(insecureSources)</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// NodeList(14) [img, img, img, img, img, img, img, img, img, img, img, img, img, img]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (14)[&#x27;http://localhost:8080/static/image/manage/unfold.svg&#x27;, &#x27;http://localhost:8080/static/image/workbench/workInstructions.svg&#x27;, &#x27;http://localhost:8080/static/image/workbench/day.svg&#x27;, &#x27;http://localhost:8080/static/image/workbench/briefing.svg&#x27;, &#x27;http://localhost:8080/static/image/workbench/feedback.svg&#x27;, &#x27;http://localhost:8080/static/image/workbench/schedule.svg&#x27;, &#x27;http://localhost:8080/static/image/workbench/task.svg&#x27;, &#x27;http://localhost:8080/static/image/workbench/achievement.svg&#x27;, &#x27;http://localhost:8080/static/image/workbench/waitclock.svg&#x27;, &#x27;http://localhost:8080/static/image/tabber/workbench-on.png&#x27;, &#x27;http://localhost:8080/static/image/tabber/ranking-list.png&#x27;, &#x27;http://localhost:8080/static/image/tabber/punch.png&#x27;, &#x27;http://localhost:8080/static/image/tabber/handle.png&#x27;, &#x27;http://localhost:8080/static/image/tabber/wode.png&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// (14)[&#x27;http://localhost:8080/static/image/manage/unfold.svg&#x27;, &#x27;http://localhost:8080/static/image/workbench/workInstructions.svg&#x27;, &#x27;http://localhost:8080/static/image/workbench/day.svg&#x27;, &#x27;http://localhost:8080/static/image/workbench/briefing.svg&#x27;, &#x27;http://localhost:8080/static/image/workbench/feedback.svg&#x27;, &#x27;http://localhost:8080/static/image/workbench/schedule.svg&#x27;, &#x27;http://localhost:8080/static/image/workbench/task.svg&#x27;, &#x27;http://localhost:8080/static/image/workbench/achievement.svg&#x27;, &#x27;http://localhost:8080/static/image/workbench/waitclock.svg&#x27;, &#x27;http://localhost:8080/static/image/tabber/workbench-on.png&#x27;, &#x27;http://localhost:8080/static/image/tabber/ranking-list.png&#x27;, &#x27;http://localhost:8080/static/image/tabber/punch.png&#x27;, &#x27;http://localhost:8080/static/image/tabber/handle.png&#x27;, &#x27;http://localhost:8080/static/image/tabber/wode.png&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="从类数组构建数组（arguments）"><a href="#从类数组构建数组（arguments）" class="headerlink" title="从类数组构建数组（arguments）"></a>从类数组构建数组（arguments）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure><h3 id="使用箭头函数和-Array-from"><a href="#使用箭头函数和-Array-from" class="headerlink" title="使用箭头函数和 Array.from()"></a>使用箭头函数和 Array.from()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="function">(<span class="params">x</span>) =&gt;</span> x + x)</span><br><span class="line"><span class="comment">// [2,4,6]</span></span><br><span class="line"><span class="built_in">Array</span>.from(&#123;<span class="attr">length</span>: <span class="number">5</span>&#125;, <span class="function">(<span class="params">v, i</span>) =&gt;</span> i)</span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><h3 id="序列生成器range"><a href="#序列生成器range" class="headerlink" title="序列生成器range"></a>序列生成器range</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列生成器函数（通常称为“range”，例如 Clojure、PHP 等）</span></span><br><span class="line"><span class="keyword">const</span> range = <span class="function">(<span class="params">start, stop, step</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: (stop - start) / step + <span class="number">1</span> &#125;, <span class="function">(<span class="params">_, i</span>) =&gt;</span> start + i * step);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成的数字范围 0..4</span></span><br><span class="line">range(<span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成的数字范围 1..10，步长为 2</span></span><br><span class="line">range(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// [1, 3, 5, 7, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Array.from 生成字母表，并将其序列排序</span></span><br><span class="line">range(<span class="string">&quot;A&quot;</span>.charCodeAt(<span class="number">0</span>), <span class="string">&quot;Z&quot;</span>.charCodeAt(<span class="number">0</span>), <span class="number">1</span>).map(<span class="function">(<span class="params">x</span>) =&gt;</span></span><br><span class="line">  <span class="built_in">String</span>.fromCharCode(x),</span><br><span class="line">);</span><br><span class="line"><span class="comment">// [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;]</span></span><br></pre></td></tr></table></figure><h3 id="在非数组构造函数上调用-from"><a href="#在非数组构造函数上调用-from" class="headerlink" title="在非数组构造函数上调用 from()"></a>在非数组构造函数上调用 from()</h3><p>from() 方法可以在任何构造函数上调用，只要该构造函数接受一个表示新数组长度的单个参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NotArray</span>(<span class="params">len</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;NotArray called with length&quot;</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可迭代对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from.call(NotArray, <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>])));</span><br><span class="line"><span class="comment">// NotArray called with length undefined</span></span><br><span class="line"><span class="comment">// NotArray &#123; &#x27;0&#x27;: &#x27;foo&#x27;, &#x27;1&#x27;: &#x27;bar&#x27;, &#x27;2&#x27;: &#x27;baz&#x27;, length: 3 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类数组对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from.call(NotArray, &#123; <span class="attr">length</span>: <span class="number">1</span>, <span class="number">0</span>: <span class="string">&quot;foo&quot;</span> &#125;));</span><br><span class="line"><span class="comment">// NotArray called with length 1</span></span><br><span class="line"><span class="comment">// NotArray &#123; &#x27;0&#x27;: &#x27;foo&#x27;, length: 1 &#125;</span></span><br></pre></td></tr></table></figure><p>当 this 值不是构造函数，返回一个普通的数组对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from.call(&#123;&#125;, &#123; <span class="attr">length</span>: <span class="number">1</span>, <span class="number">0</span>: <span class="string">&quot;foo&quot;</span> &#125;)); <span class="comment">// [ &#x27;foo&#x27; ]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记flutter关于Android license status unknown</title>
      <link href="/ZJY.github.io/2023/05/31/%E8%AE%B0flutter%E5%85%B3%E4%BA%8EAndroid-license-status-unknown/"/>
      <url>/ZJY.github.io/2023/05/31/%E8%AE%B0flutter%E5%85%B3%E4%BA%8EAndroid-license-status-unknown/</url>
      
        <content type="html"><![CDATA[<p>运行<code>flutter doctor -v</code>显示：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">✗ Android license status unknown.</span><br><span class="line">      Run `flutter doctor --android-licenses` to accept the SDK licenses.</span><br><span class="line">      See https://flutter.dev/docs/get-started/install/macos#android-setup <span class="keyword">for</span></span><br><span class="line">      <span class="built_in">more</span> details.</span><br></pre></td></tr></table></figure><p>按照提示运行<code>flutter doctor --android-licenses</code>：</p><p><img src="/ZJY.github.io/images/flutter_license.jpg" alt="flutter"></p><p>显示java Runtime版本不匹配，查看android sdk命令行工具版本是否和java版本匹配：</p><p>查看java版本：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br><span class="line"></span><br><span class="line">java version &quot;<span class="number">1</span>.<span class="number">8</span>.<span class="number">0</span>_251&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build <span class="number">1</span>.<span class="number">8</span>.<span class="number">0</span>_251-b08)</span><br><span class="line">Java HotSpot(TM) <span class="number">64</span>-Bit Server VM (build <span class="number">25</span>.<span class="number">251</span>-b08, mixed <span class="built_in">mode</span>)</span><br></pre></td></tr></table></figure><p>查看android sdk命令行工具版本：</p><p><img src="/ZJY.github.io/images/flutter_java_version.jpg" alt="flutter"></p><p>重新选择命令行版本：</p><p><img src="/ZJY.github.io/images/flutter_line_version.jpg" alt="flutter"></p><p>然后apply，重新运行<code>flutter doctor --android-licenses</code>：</p><p><img src="/ZJY.github.io/images/flutter_license_done.jpg" alt="flutter"></p><p>重新运行<code>flutter doctor -v</code>:</p><p><img src="/ZJY.github.io/images/flutter_doctor_done.jpg" alt="flutter"></p>]]></content>
      
      
      <categories>
          
          <category> 问题&amp;总结 </category>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记flutter关于Unable to find bundled Java version</title>
      <link href="/ZJY.github.io/2023/05/31/%E8%AE%B0flutter%E5%85%B3%E4%BA%8EUnable-to-find-bundled-Java-version/"/>
      <url>/ZJY.github.io/2023/05/31/%E8%AE%B0flutter%E5%85%B3%E4%BA%8EUnable-to-find-bundled-Java-version/</url>
      
        <content type="html"><![CDATA[<p>先查看flutter版本：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter --version</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Flutter <span class="number">1</span>.<span class="number">20</span>.<span class="number">2</span> • channel stable • &lt;https://github.com/flutter/flutter.git&gt;</span><br><span class="line">Framework • revision bbfbf1770c (<span class="number">2</span> 年 <span class="number">10</span> 个月前) • <span class="number">2020</span>-<span class="number">08</span>-<span class="number">13</span> <span class="number">08</span>:<span class="number">33</span>:<span class="number">09</span> -<span class="number">0700</span></span><br><span class="line">Engine • revision <span class="number">9</span>d5b21729f</span><br><span class="line">Tools • Dart <span class="number">2</span>.<span class="number">9</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure><p>感觉是版本太低，因为很久没更新，尝试更新：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter upgrade</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/ZJY.github.io/images/flutter_version.jpg" alt="flutter"></p><p>解决cmdline-tools component is missing问题，在Androidstudio安装这个东西：</p><p><img src="/ZJY.github.io/images/flutter_comline.jpg" alt="flutter"></p><p>最后apply，等待安装即可</p>]]></content>
      
      
      <categories>
          
          <category> 问题&amp;总结 </category>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记flutter关于Flutter plugin not installed</title>
      <link href="/ZJY.github.io/2023/05/31/%E8%AE%B0flutter%E5%85%B3%E4%BA%8EFlutter-plugin-not-installed/"/>
      <url>/ZJY.github.io/2023/05/31/%E8%AE%B0flutter%E5%85%B3%E4%BA%8EFlutter-plugin-not-installed/</url>
      
        <content type="html"><![CDATA[<p><img src="/ZJY.github.io/images/flutter_plugins.jpg" alt="flutter"></p><p>Android Studio 安装好flutter插件，执行flutter doctor -v 还是提示了图中错误：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">✗ Flutter plugin <span class="keyword">not</span> installed; this adds Flutter specific functionality.</span><br><span class="line">✗ Dart plugin <span class="keyword">not</span> installed; this adds Dart specific functionality.</span><br></pre></td></tr></table></figure><p>解决方法:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s ~/Library/Application\ Support/Google/AndroidStudio2022.<span class="number">2</span>/plugins ~/Library/Application\ Support/AndroidStudio2022.<span class="number">2</span></span><br></pre></td></tr></table></figure><p>结果：<br><img src="/ZJY.github.io/images/flutter_plugins_installed.jpg" alt="flutter"></p>]]></content>
      
      
      <categories>
          
          <category> 问题&amp;总结 </category>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语句和声明</title>
      <link href="/ZJY.github.io/2023/05/22/%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%A3%B0%E6%98%8E/"/>
      <url>/ZJY.github.io/2023/05/22/%E8%AF%AD%E5%8F%A5%E5%92%8C%E5%A3%B0%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p>JavaScript 应用程序是由许多语法正确的语句组成的。单个语句可以跨多行。如果每个语句用分号隔开，那么多个语句可以在一行中出现。</p><p>**语句和声明（按类别分类）</p><h2 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h2><h3 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h3><p>  一个块语句可以用来管理零个或多个语句。该区块是由一对大括号分隔.<br>  语法：<br>  块声明：{ statement }<br>  标记块声明： LabelIdentifier: { StatementList }</p><p>  <strong><em>通过var声明的变量或者非严格模式下 (non-strict mode) 创建的函数声明没有块级作用域。</em></strong></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 输出结果是 2，因为块中的 var x语句与块前面的var x语句作用域相同</span></span><br></pre></td></tr></table></figure><p>  <strong><em>使用let和const声明的变量是有块级作用域的</em></strong></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> c = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> c = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// 输出 1，而且不会报错</span></span><br></pre></td></tr></table></figure><p>  <strong><em>使用function</em></strong></p><p>  函数声明同样被限制在声明他的语句块内：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foo(<span class="string">&#x27;outside&#x27;</span>);  <span class="comment">// TypeError: foo is not a function</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">location</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;foo is called &#x27;</span> + location);</span><br><span class="line">  &#125;</span><br><span class="line">  foo(<span class="string">&#x27;inside&#x27;</span>); <span class="comment">// 正常工作并且打印 &#x27;foo is called inside&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>  终止当前循环、switch或label语句，使程序跳到下一条语句执行。<br>  语法：break [label]<br>  label 可选,与语句标签相关联的标识符。如果 break 语句不在一个循环或 switch 语句中，则该项是必须的。</p><p>  终止循环：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testBreak</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; <span class="number">6</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> i * x; <span class="comment">// 当 i 为 3 时，会中止 while 循环，然后返回 3 * x 的值。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  终止switch语句：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> food = <span class="string">&quot;sushi&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (food) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;sushi&quot;</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Sushi is originally from Japan.&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;pizza&quot;</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Pizza is originally from Italy.&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;I have never heard of that dish.&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  终止label语句：<br>  一个 break 语句必须内嵌在它引用的标记中.</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">block_1:&#123;</span><br><span class="line">  <span class="built_in">console</span>.log (<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">  <span class="keyword">break</span> block_2;            <span class="comment">// SyntaxError: label not found</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">block_2:&#123;</span><br><span class="line">  <span class="built_in">console</span>.log (<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">outer_block:&#123;</span><br><span class="line"></span><br><span class="line">  inner_block:&#123;</span><br><span class="line">    <span class="built_in">console</span>.log (<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span> outer_block;      <span class="comment">// breaks out of both inner_block and outer_block</span></span><br><span class="line">    <span class="built_in">console</span>.log (<span class="string">&#x27;:-(&#x27;</span>);    <span class="comment">// skipped</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log (<span class="string">&#x27;2&#x27;</span>);        <span class="comment">// skipped</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  break 语句不能在 function 函数体中直接使用:</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testBreak</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; <span class="number">6</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">      (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;)();</span><br><span class="line">    &#125;</span><br><span class="line">    i += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> i * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">testBreak(<span class="number">1</span>); <span class="comment">// SyntaxError: Illegal break statement</span></span><br></pre></td></tr></table></figure>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">block_1: &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">  ( <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">break</span> block_1; <span class="comment">// SyntaxError: Undefined label &#x27;block_1&#x27;</span></span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>  终止执行当前或标签循环的语句，执行下一个迭代循环<br>  语法：continue [label]</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i === <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  text = text + i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(text); <span class="comment">// &quot;012456789&quot;</span></span><br></pre></td></tr></table></figure><p>  与 break 语句的区别在于，continue 并不会终止循环的迭代，而是：</p><ul><li>在while循环中，控制流跳转回条件判断</li><li>在for循环中，控制流跳转到更新语句</li></ul><h3 id="Empty"><a href="#Empty" class="headerlink" title="Empty"></a>Empty</h3><p>  ;<br>  空语句用来表示没有语句的情况，尽管js语法期望有语句提供。</p><h3 id="if…else"><a href="#if…else" class="headerlink" title="if…else"></a>if…else</h3><p>  如果指定的条件是 true，则执行相匹配的一个语句，若为 false，则执行另一个语句。</p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>  计算表达式，将子句于表达式的值做匹配，执行与该值相关联的语句。<br>  使用 严格运算符 (en-US)，===做匹配</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">  <span class="keyword">case</span> value1:</span><br><span class="line">    <span class="comment">// 当 expression 的结果与 value1 匹配时，执行此处语句</span></span><br><span class="line">    [<span class="keyword">break</span>;]</span><br><span class="line">  <span class="keyword">case</span> value2:</span><br><span class="line">    <span class="comment">// 当 expression 的结果与 value2 匹配时，执行此处语句</span></span><br><span class="line">    [<span class="keyword">break</span>;]</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">case</span> valueN:</span><br><span class="line">    <span class="comment">// 当 expression 的结果与 valueN 匹配时，执行此处语句</span></span><br><span class="line">    [<span class="keyword">break</span>;]</span><br><span class="line">  [<span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 如果 expression 与上面的 value 值都不匹配，执行此处语句</span></span><br><span class="line">    [<span class="keyword">break</span>;]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  如果你忘记添加 break，那么代码将会从值所匹配的 case 语句开始运行，然后持续执行下一个 case 语句而不论值是否匹配。<br>  可以把 default 放到 case 之间</p><p>  <strong><em>switch语句内的块级作用域</em></strong></p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> action = <span class="string">&#x27;say_hello&#x27;</span>;</span><br><span class="line"><span class="keyword">switch</span> (action) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;say_hello&#x27;</span>:</span><br><span class="line">    <span class="keyword">let</span> message = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;0 ~5&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;say_hi&#x27;</span>:</span><br><span class="line">    <span class="keyword">let</span> message = <span class="string">&#x27;hi&#x27;</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">6</span>: </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Empty action received.&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Identifier &#x27;message&#x27; has already been declared</span></span><br></pre></td></tr></table></figure><p>  导致这一问题的根本原因在于两个 let 语句处于同一个块级作用域，所以它们被认为是同一个变量名的重复声明。</p><p>  通过把 case 语句包装到括号里面，我们就可以轻松解决这个问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> action = <span class="string">&#x27;say_hello&#x27;</span>;</span><br><span class="line"><span class="keyword">switch</span> (action) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;say_hello&#x27;</span>: &#123;</span><br><span class="line">    <span class="keyword">let</span> message = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;0 ~5&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;say_hi&#x27;</span>:&#123;</span><br><span class="line">    <span class="keyword">let</span> message = <span class="string">&#x27;hi&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">6</span>: &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">default</span>:&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Empty action received.&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h3><p>  抛出一个用户定义的异常。<br>  当前函数的执行将被停止（throw 之后的语句将不会执行），并且控制将被传递到调用堆栈中的第一个 catch 块。如果调用者函数中没有 catch 块，程序将会终止。</p><p>  语法：throw expression<br>  expression: 要抛出的表达式</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRectArea</span>(<span class="params">width, height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isNaN</span>(width) || <span class="built_in">isNaN</span>(height)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Parameter is not a number!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  getRectArea(<span class="number">3</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(e);</span><br><span class="line">  <span class="comment">// Expected output: Error: Parameter is not a number!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="try…catch"><a href="#try…catch" class="headerlink" title="try…catch"></a>try…catch</h3><p>  标记一个语句块，并指定一个应该抛出异常的反馈。</p><p>  try语句包含了由一个或者多个语句组成的try块，和至少一个catch块或者一个finally块的其中一个，或者两个兼有，下面是三种形式的try声明：<br>  1.try…catch<br>  2.try…finally<br>  3.try…catch…finally</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  nonExistentFunction();</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(error);</span><br><span class="line">  <span class="comment">// Expected output: ReferenceError: nonExistentFunction is not defined</span></span><br><span class="line">  <span class="comment">// (Note: the exact output may be browser-dependent)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  catch子句包含try块中抛出异常时要执行的语句。如果在try块中有任何一个语句（或者从try块中调用的函数）抛出异常，控制立即转向catch子句。如果在try块中没有异常抛出，会跳过catch子句。</p><p>  finally子句在try块和catch块之后执行但是在下一个try声明之前执行。无论是否有异常抛出或捕获它总是执行。</p><p>  嵌套try语句：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;oops&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">&quot;outer&quot;</span>, ex.message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// &quot;finally&quot;</span></span><br><span class="line"><span class="comment">// &quot;outer&quot; &quot;oops&quot;</span></span><br></pre></td></tr></table></figure><p>  现在，如果我们已经在 try 语句中，通过增加一个 catch 语句块捕获了异常.</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;oops&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&quot;inner&quot;</span>, ex.message);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">&quot;outer&quot;</span>, ex.message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// &quot;inner&quot; &quot;oops&quot;</span></span><br><span class="line"><span class="comment">// &quot;finally&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;oops&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&quot;inner&quot;</span>, ex.message);</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">&quot;outer&quot;</span>, ex.message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// &quot;inner&quot; &quot;oops&quot;</span></span><br><span class="line"><span class="comment">// &quot;finally&quot;</span></span><br><span class="line"><span class="comment">// &quot;outer&quot; &quot;oops&quot;</span></span><br></pre></td></tr></table></figure><p>从 finally 语句块返回:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;oops&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">&quot;inner&quot;</span>, ex.message);</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&quot;outer&quot;</span>, ex.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：此 try catch 语句需要在 function 中运行才能作为函数的返回值，否则直接运行会报语法错误</span></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// &quot;inner&quot; &quot;oops&quot;</span></span><br><span class="line"><span class="comment">// &quot;finally&quot;</span></span><br></pre></td></tr></table></figure><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><p>  var 语句 用于声明一个函数范围或全局范围的变量，并可将其初始化为一个值（可选）。</p><p>  var声明的变量具有变量提升，“hoisting”就像是把所有的变量声明移动到函数或者全局代码的开头位置。这意味着变量可以在声明之前使用.<br>  var创建的全局变量会作为window对象的属性</p><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>  let 语句声明一个块级作用域的局部变量，并可以初始化为一个值（可选）。<br>  与var区别：</p><ul><li>var声明的变量作用域是全局或整个函数的，而let声明是块级的</li><li>let声明的变量不会在作用域中提升，他是编译时才初始化。</li><li>var创建的全局变量会作为window对象的属性,而let不会</li><li>var可以重复声明同一个变量，let不可以</li><li>var声明变量前访问undefined，let声明变量前访问抛出referenceError,暂时性死区</li></ul><p>作用域规则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">varTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">2</span>; <span class="comment">// same variable!</span></span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// 2 var 声明的变量的作用域是整个封闭函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">letTest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span>; <span class="comment">// different variable</span></span><br><span class="line">    <span class="built_in">console</span>.log(x); <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在全局作用域中，let 和 var 不一样，它不会在全局对象上创建属性。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.x); <span class="comment">// &quot;global&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.y); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>重复声明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(x) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">let</span> foo;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">let</span> foo; <span class="comment">// SyntaxError for redeclaration.</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x) &#123;</span><br><span class="line">  <span class="keyword">let</span> foo;</span><br><span class="line">  <span class="keyword">let</span> foo; <span class="comment">// SyntaxError thrown.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>case子句同属一个作用域，将case用块{}包裹可以创建一个新的作用域的词法环境，就不会产生重复声明的错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(x) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">    <span class="keyword">let</span> foo;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">    <span class="keyword">let</span> foo;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暂时性死区: 从块作用域开始到执行声明变量的行之前，let或const声明的变量都处于“暂时性死区”（temporal dead zone, TDZ）.<br>当变量处于暂时性死区时，其尚未初始化，访问变量会抛出ReferenceError.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="comment">// TDZ starts at beginning of scope</span></span><br><span class="line">  <span class="built_in">console</span>.log(bar); <span class="comment">// undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(foo); <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">var</span> bar = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="number">2</span>; <span class="comment">// End of TDZ (for foo)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用术语”temporal”是因为区域取决于代码执行的顺序（时间），而不是编写的顺序（位置）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// TDZ starts at beginning of scope</span></span><br><span class="line">  <span class="keyword">const</span> func = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(letVar); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Within the TDZ letVar access throws `ReferenceError`</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> letVar = <span class="number">3</span>; <span class="comment">// End of TDZ (for letVar)</span></span><br><span class="line">  func(); <span class="comment">// Called outside TDZ!  output: 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暂时性死区与typeof：<br>如果使用typeof检测在暂时性死区中的变量，会抛出ReferenceError。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> i); <span class="comment">// Uncaught ReferenceError: i is not defined</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>与使用typeof检测值为undefined的未声明变量不同：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> i); <span class="comment">// undefinded</span></span><br></pre></td></tr></table></figure><p>暂时性死区和词法作用域：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="number">33</span>;</span><br><span class="line">  <span class="keyword">if</span>(foo) &#123;</span><br><span class="line">    <span class="keyword">let</span> foo = (foo + <span class="number">55</span>); <span class="comment">// Uncaught ReferenceError: Cannot access &#x27;foo&#x27; before initialization</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>if(foo)，foo有值，执行if块内代码，表达式foo + 55, 此时foo还未初始化处于暂时先死区，会抛出ReferenceError</p><p>其他情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">2</span>; <span class="comment">// Uncaught SyntaxError: Identifier &#x27;x2&#x27; has already been declared</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">2</span>; <span class="comment">// right</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> z = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> z = <span class="number">3</span> <span class="comment">// Uncaught SyntaxError: Identifier &#x27;z&#x27; has already been declared</span></span><br></pre></td></tr></table></figure><p>var声明会将变量提升到块的顶部，这会导致重复声明变量。</p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>  声明一个只读的命名常量。</p><ul><li>全局或块级作用域</li><li>无法重复声明</li><li>不能通过赋值改变</li><li>全局常量不会变为 window 对象的属性</li><li>必须在声明的同一语句中指定它的值</li></ul><h2 id="函数和类"><a href="#函数和类" class="headerlink" title="函数和类"></a>函数和类</h2><h3 id="function"><a href="#function" class="headerlink" title="function"></a>function</h3><p>  声明一个指定参数的函数。</p><p>  有条件的创建函数：</p><p>  函数可以被有条件来声明，这意味着，函数声明可能出现在一个 if 语句里，但是，这种声明方式在不同的浏览器里可能有不同的效果。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hoisted = <span class="string">&quot;foo&quot;</span> <span class="keyword">in</span> <span class="built_in">this</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`&#x27;foo&#x27; name <span class="subst">$&#123;hoisted ? <span class="string">&quot;is&quot;</span> : <span class="string">&quot;is not&quot;</span>&#125;</span> hoisted. typeof foo is <span class="subst">$&#123;<span class="keyword">typeof</span> foo&#125;</span>`</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123; <span class="comment">// 注意，即使把上面代码中的 if(false) 改为 if(true)，结果也是一样的</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Chrome 里：</span></span><br><span class="line"><span class="comment">// &#x27;foo&#x27; 变量名被提升，但是 typeof foo 为 undefined</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 在 Firefox 里：</span></span><br><span class="line"><span class="comment">// &#x27;foo&#x27; 变量名被提升。但是 typeof foo 为 undefined</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 在 Edge 里：</span></span><br><span class="line"><span class="comment">// &#x27;foo&#x27; 变量名未被提升。而且 typeof foo 为 undefined</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 在 Safari 里：</span></span><br><span class="line"><span class="comment">// &#x27;foo&#x27; 变量名被提升。而且 typeof foo 为 function</span></span><br></pre></td></tr></table></figure><p>  <strong>函数声明提升:</strong></p><p>  JavaScript 中的函数声明被提升到了函数定义。你可以在函数声明之前使用该函数：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hoisted(); <span class="comment">// logs &quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hoisted</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  函数表达式不会被提升：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">notHoisted(); <span class="comment">// TypeError: notHoisted is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> notHoisted = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="function-1"><a href="#function-1" class="headerlink" title="function*"></a>function*</h3><p>  function* 这种声明方式 (function关键字后跟一个星号）会定义一个生成器函数 (generator function)，它返回一个 Generator 对象</p><h3 id="async-function"><a href="#async-function" class="headerlink" title="async function"></a>async function</h3><p>  使用指定的参数声明一个异步函数。</p><h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>  指return 语句终止函数的执行，并返回一个指定的值给函数调用者。</p><h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p>  class声明创建一个基于原型继承的具有给定名称的新类。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="do…while"><a href="#do…while" class="headerlink" title="do…while"></a>do…while</h3><p>  创建一个循环来执行语句，直到该语句条件表达式的值为 false。先执行语句，再执行条件表达式，该语句至少会执行一次。</p><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>  创建一个由 3 个可选的表达式组成的循环，该循环用括号包裹，分号分割，并在循环体中执行语句。</p><h3 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h3><p>  for…in 语句以任意顺序迭代一个对象的除Symbol以外的可枚举属性，包括继承的可枚举属性。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> triangle = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ColoredTriangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ColoredTriangle.prototype = triangle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> ColoredTriangle();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`obj.<span class="subst">$&#123;prop&#125;</span> = <span class="subst">$&#123;obj[prop]&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// &quot;obj.color = red&quot;</span></span><br><span class="line"><span class="comment">// &quot;obj.a = 1&quot;</span></span><br><span class="line"><span class="comment">// &quot;obj.b = 2&quot;</span></span><br><span class="line"><span class="comment">// &quot;obj.c = 3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自身属性</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj.hasOwnProperty(prop)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`obj.<span class="subst">$&#123;prop&#125;</span> = <span class="subst">$&#123;obj[prop]&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// &quot;obj.color = red&quot;</span></span><br></pre></td></tr></table></figure><h3 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h3><p>  for…of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句.</p><p>  示例：</p><p>  迭代Array：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterable = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 20</span></span><br><span class="line"><span class="comment">// 30</span></span><br></pre></td></tr></table></figure><p>  迭代String：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterable = <span class="string">&quot;boo&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;b&quot;</span></span><br><span class="line"><span class="comment">// &quot;o&quot;</span></span><br><span class="line"><span class="comment">// &quot;o&quot;</span></span><br></pre></td></tr></table></figure><p>  迭代TypedArray:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterable = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0x00</span>, <span class="number">0xff</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 255</span></span><br></pre></td></tr></table></figure><p>  迭代Map：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterable = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&quot;a&quot;</span>, <span class="number">1</span>], [<span class="string">&quot;b&quot;</span>, <span class="number">2</span>], [<span class="string">&quot;c&quot;</span>, <span class="number">3</span>]]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(entry);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [&quot;a&quot;, 1]</span></span><br><span class="line"><span class="comment">// [&quot;b&quot;, 2]</span></span><br><span class="line"><span class="comment">// [&quot;c&quot;, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>  迭代Set：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterable = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>  迭代 arguments 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> argument <span class="keyword">of</span> <span class="built_in">arguments</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(argument);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>  迭代DOM集合：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：这只能在实现了 NodeList.prototype[Symbol.iterator] 的平台上运行</span></span><br><span class="line"><span class="keyword">let</span> articleParagraphs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;article &gt; p&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> paragraph <span class="keyword">of</span> articleParagraphs) &#123;</span><br><span class="line">  paragraph.classList.add(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  关闭迭代器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> o <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(o); <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">break</span>; <span class="comment">// closes iterator, triggers return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for-await…of"><a href="#for-await…of" class="headerlink" title="for await…of"></a>for await…of</h3><p>  在异步可迭代对象、类数组对象、迭代器和生成器上迭代，调用自定义迭代钩子，其中包含要为每个不同属性的值执行的语句。</p><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>  创建一个循环语句，循环会一直持续到该语句条件表达式的值为 false。先执行条件表达式，然后执行语句。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="debugger"><a href="#debugger" class="headerlink" title="debugger"></a>debugger</h3><p>  调用可用的调试功能。如果没有调试功能可用，该语句不生效。</p><h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><p>  export 语句用于从模块中导出实时绑定的函数、对象或原始值，以便其他程序可以通过 import 语句使用它们.</p><p>  无论您是否声明，导出的模块都处于严格模式。export 语句不能用在嵌入式脚本中。</p><p>  存在两种 exports 导出方式：</p><ul><li>命名导出（每个模块包含任意数量）</li><li>默认导出（每个模块包含一个）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出单个特性</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name1, name2, …, nameN; <span class="comment">// also var, const</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name1 = …, name2 = …, …, nameN; <span class="comment">// also var, const</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">FunctionName</span>(<span class="params"></span>)</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出列表</span></span><br><span class="line"><span class="keyword">export</span> &#123; name1, name2, …, nameN &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重命名导出</span></span><br><span class="line"><span class="keyword">export</span> &#123; variable1 <span class="keyword">as</span> name1, variable2 <span class="keyword">as</span> name2, …, nameN &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构导出并重命名</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> &#123; name1, <span class="attr">name2</span>: bar &#125; = o;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> expression;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">…</span>) </span>&#123; … &#125; <span class="comment">// also class, function*</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">name1</span>(<span class="params">…</span>) </span>&#123; … &#125; <span class="comment">// also class, function*</span></span><br><span class="line"><span class="keyword">export</span> &#123; name1 <span class="keyword">as</span> <span class="keyword">default</span>, … &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出模块合集</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> …; <span class="comment">// does not set the default export</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">as</span> name1 <span class="keyword">from</span> …; <span class="comment">// Draft ECMAScript® 2O21</span></span><br><span class="line"><span class="keyword">export</span> &#123; name1, name2, …, nameN &#125; <span class="keyword">from</span> …;</span><br><span class="line"><span class="keyword">export</span> &#123; import1 <span class="keyword">as</span> name1, import2 <span class="keyword">as</span> name2, …, nameN &#125; <span class="keyword">from</span> …;</span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> &#125; <span class="keyword">from</span> …;</span><br></pre></td></tr></table></figure><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>  用来导入外部模块或script中导出的函数。</p><p>  无论是否声明了 strict mode，导入的模块都运行在严格模式下。在浏览器中，import 语句只能在声明了 type=”module” 的 script 的标签中使用。</p><p>  此外，还有一个类似函数的动态 import()，它不需要依赖 type=”module” 的 script 标签。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> defaultExport <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;<span class="comment">// 导入默认值</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> name <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>; <span class="comment">// 导入整个模块的内容</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">export</span> &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>; <span class="comment">// 导入单个接口</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">export</span> <span class="keyword">as</span> alias &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>; <span class="comment">// 导入带有别名的接口</span></span><br><span class="line"><span class="keyword">import</span> &#123; export1 , export2 &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>; <span class="comment">// 导入多个接口</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo , bar &#125; <span class="keyword">from</span> <span class="string">&quot;module-name/path/to/specific/un-exported/file&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; export1 , export2 <span class="keyword">as</span> alias2 , [...] &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;  <span class="comment">// 导入时重命名接口</span></span><br><span class="line"><span class="keyword">import</span> defaultExport, &#123; <span class="keyword">export</span> [ , [...] ] &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> defaultExport, * <span class="keyword">as</span> name <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;module-name&quot;</span>; <span class="comment">// 整个模块仅为副作用（中性词，无贬义含义）而导入，而不导入模块中的任何内容（接口）。这将运行模块中的全局代码，但实际上不导入任何值。</span></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">import</span>(<span class="string">&quot;module-name&quot;</span>);<span class="comment">//这是一个处于第三阶段的提案。动态导入</span></span><br></pre></td></tr></table></figure><h3 id="import-meta"><a href="#import-meta" class="headerlink" title="import.meta"></a>import.meta</h3><p>  向 JavaScript 模块公开上下文特定的元数据的元属性。</p><h3 id="label"><a href="#label" class="headerlink" title="label"></a>label</h3><p>  带标识的语句，与break或continue语句一起使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">loop1:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span> loop1;</span><br><span class="line">  &#125;</span><br><span class="line">  str = str + i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br><span class="line"><span class="comment">// Expected output: &quot;0234&quot;</span></span><br></pre></td></tr></table></figure><h3 id="with"><a href="#with" class="headerlink" title="with"></a>with</h3><p>  拓展一个语句的作用域.不建议使用</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闭包的理解</title>
      <link href="/ZJY.github.io/2023/05/22/%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/ZJY.github.io/2023/05/22/%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>闭包（closure）是一个函数以及其周边环境状态（词法环境）的引用的组合。换言之，闭包让开发者在内部函数可以访问外部函数的作用域。在js中，闭包会随着函数的创建而被同时创建。</p><h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&quot;Mozilla&quot;</span>; <span class="comment">// name 是一个被 init 创建的局部变量</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">displayName</span>(<span class="params"></span>) </span>&#123; <span class="comment">// displayName() 是内部函数，一个闭包</span></span><br><span class="line">      alert(name); <span class="comment">// 使用了父函数中声明的变量</span></span><br><span class="line">  &#125;</span><br><span class="line">  displayName();</span><br><span class="line">&#125;</span><br><span class="line">init(); <span class="comment">// alert &#x27;Mozilla&#x27;</span></span><br></pre></td></tr></table></figure><p>词法（lexical）一词指的是，词法作用域根据源代码中声明变量的位置来确定该变量在何处可用。嵌套函数可以访问声明于它们外部作用域的变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;Mozilla&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">displayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> displayName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myFunc = makeFunc();</span><br><span class="line">myFunc();</span><br></pre></td></tr></table></figure><p>以上例子，displayName函数在执行前，从外部函数返回。</p><p>在一些编程语言中，一个函数的局部变量仅存在于函数的执行期间，一旦makeFunc()执行完毕，name变量就不能访问里。<br>然而代码仍按期运行，js情况于此不同。</p><p>原因在于，js的函数形成了闭包。<strong>闭包是由函数以及声明该函数的词法环境组合而成的。</strong> 该环境包含了闭包创建时作用域内的任何局部变量。</p><p>示例makeAdder函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add5 = makeAdder(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> add10 = makeAdder(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add5(<span class="number">2</span>));  <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(add10(<span class="number">2</span>)); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>add5 和 add10 都是闭包。它们共享相同的函数定义，但是保存了不同的词法环境。在 add5 的环境中，x 为 5。而在 add10 中，x 则为 10。</p><h3 id="用闭包模拟私有方法"><a href="#用闭包模拟私有方法" class="headerlink" title="用闭包模拟私有方法"></a>用闭包模拟私有方法</h3><p>java中的私有方法只能被同一个类中的其他方法所调用，而js中没有这种支持，但可以使用闭包来模拟私有方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Counter = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> privateCounter = <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">changeBy</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    privateCounter += val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="function"><span class="title">increment</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      changeBy(<span class="number">1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">decrement</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      changeBy(-<span class="number">1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">value</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="built_in">console</span>.log(Counter.value()); <span class="comment">/* logs 0 */</span></span><br><span class="line">Counter.increment();</span><br><span class="line">Counter.increment();</span><br><span class="line"><span class="built_in">console</span>.log(Counter.value()); <span class="comment">/* logs 2 */</span></span><br><span class="line">Counter.decrement();</span><br><span class="line"><span class="built_in">console</span>.log(Counter.value()); <span class="comment">/* logs 1 */</span></span><br></pre></td></tr></table></figure><p>在之前的示例中，每个闭包都有它自己的词法环境；而这次我们只创建了一个词法环境，为三个函数所共享：Counter.increment，Counter.decrement 和 Counter.value。</p><h3 id="在循环中创建闭包：一个常见的错误"><a href="#在循环中创建闭包：一个常见的错误" class="headerlink" title="在循环中创建闭包：一个常见的错误"></a>在循环中创建闭包：一个常见的错误</h3><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;help&quot;</span>&gt;</span>Helpful notes will appear here<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>E-mail: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;email&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;name&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Age: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;age&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showHelp</span>(<span class="params">help</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;help&#x27;</span>).innerHTML = help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupHelp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> helpText = [</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your e-mail address&#x27;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your full name&#x27;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your age (you must be over 16)&#x27;</span>&#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; helpText.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = helpText[i];</span><br><span class="line">    <span class="built_in">document</span>.getElementById(item.id).onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      showHelp(item.help);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupHelp();</span><br></pre></td></tr></table></figure><p>是赋值给 onfocus 的是闭包,这三个闭包在循环中被创建，但他们共享了同一个词法作用域，在这个作用域中存在一个变量 item。这是因为变量 item 使用 var 进行声明，由于变量提升，所以具有函数作用域。当 onfocus 的回调执行时，item.help 的值被决定。由于循环在事件触发之前早已执行完毕，变量对象 item（被三个闭包所共享）已经指向了 helpText 的最后一项。</p><p><strong><em>解决这个问题的一种方案是使用更多的闭包：</em></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showHelp</span>(<span class="params">help</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;help&#x27;</span>).innerHTML = help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeHelpCallback</span>(<span class="params">help</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    showHelp(help);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupHelp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> helpText = [</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your e-mail address&#x27;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your full name&#x27;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your age (you must be over 16)&#x27;</span>&#125;</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; helpText.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = helpText[i];</span><br><span class="line">    <span class="built_in">document</span>.getElementById(item.id).onfocus = makeHelpCallback(item.help);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupHelp();</span><br></pre></td></tr></table></figure><p>这段代码可以如我们所期望的那样工作。所有的回调不再共享同一个环境， makeHelpCallback 函数为每一个回调创建一个新的词法环境.</p><p><strong><em>另一种方法使用了匿名闭包：</em></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showHelp</span>(<span class="params">help</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;help&#x27;</span>).innerHTML = help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupHelp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> helpText = [</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your e-mail address&#x27;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your full name&#x27;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your age (you must be over 16)&#x27;</span>&#125;</span><br><span class="line">    ];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; helpText.length; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> item = helpText[i];</span><br><span class="line">      <span class="built_in">document</span>.getElementById(item.id).onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        showHelp(item.help)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)() <span class="comment">// 马上把当前循环项的 item 与事件回调相关联起来</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupHelp();</span><br></pre></td></tr></table></figure><p><strong><em>如果不想使用更多的闭包，可以用es6引入的let const关键词：</em></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showHelp</span>(<span class="params">help</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;help&#x27;</span>).innerHTML = help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupHelp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> helpText = [</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your e-mail address&#x27;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your full name&#x27;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your age (you must be over 16)&#x27;</span>&#125;</span><br><span class="line">    ];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; helpText.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> item = helpText[i];</span><br><span class="line">    <span class="built_in">document</span>.getElementById(item.id).onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      showHelp(item.help) <span class="comment">// 每个闭包都绑定了块作用域的变量</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupHelp();</span><br></pre></td></tr></table></figure><p>这个例子使用 const 而不是 var，因此每个闭包都绑定了块作用域的变量，这意味着不再需要额外的闭包。</p><p><strong><em>另一个可选方案是使用forEach()遍历helpText数组并给每一个input添加监听器：</em></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showHelp</span>(<span class="params">help</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;help&#x27;</span>).innerHTML = help;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupHelp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> helpText = [</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;email&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your e-mail address&#x27;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your full name&#x27;</span>&#125;,</span><br><span class="line">      &#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;help&#x27;</span>: <span class="string">&#x27;Your age (you must be over 16)&#x27;</span>&#125;</span><br><span class="line">    ];</span><br><span class="line">  </span><br><span class="line">  helpText.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(item.id).onfocus = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      showHelp(item.help)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupHelp();</span><br></pre></td></tr></table></figure><h3 id="性能考量"><a href="#性能考量" class="headerlink" title="性能考量"></a>性能考量</h3><p>如果不是某些特定任务需要使用闭包，在其他函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。</p><p>例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用时，方法都会被重新赋值一次（也就是说，对于每个对象的创建，方法都会被重新赋值）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params">name, message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name.toString();</span><br><span class="line">  <span class="built_in">this</span>.message = message.toString();</span><br><span class="line">  <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.getMessage = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.message;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关联到对象的原型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params">name, message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name.toString();</span><br><span class="line">  <span class="built_in">this</span>.message = message.toString();</span><br><span class="line">&#125;</span><br><span class="line">MyObject.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line">MyObject.prototype.getMessage = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.message;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>继承的原型可以为所有对象共享，不必在每一次创建对象时定义方法.</p><p>使用闭包可以隐藏变量以及防止变量被篡改和作用域的污染，从而实现封装。</p><p>闭包是为了设计私有方法和变量。<br>优点：避免全局变量的污染<br>缺点：由于保留了作用域链,闭包常驻内存，加大内存使用，使用不当容易造成内存泄漏<br>解决方法是：在退出函数之前，将不使用的局部变量全部删除；</p><p>闭包的三大特性：</p><p>函数嵌套函数<br>函数内部可以引用外部的参数和变量<br>参数和变量不会被垃圾回收机制回收</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代器</title>
      <link href="/ZJY.github.io/2023/05/19/%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
      <url>/ZJY.github.io/2023/05/19/%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>可迭代对象（Iterables）是可以使用 for..of 进行迭代的对象。</p><p>从技术上讲，可迭代对象必须实现 Symbol.iterator 方法。</p><p><strong><em>理解迭代：</em></strong></p><p>  循环是迭代的基础<br>  迭代会在一个有序集合上进行（有序可以理解为集合中所有项都可以按照既定的顺序被遍历到，特别是开始和结束项都有明确的定义）</p><p>数组是有序集合中最典型的例子</p><p>内置可迭代对象（实现Iterable接口，暴露Symbol.iterator属性作为默认迭代器，在es6中）：</p><ul><li>字符串</li><li>数组</li><li>映射</li><li>集合</li><li>arguments对象</li><li>NodeList等DOM集合类型</li></ul><p>Symbol.iterator这个默认迭代器必须引用一个迭代器工厂函数，调用这个工厂函数必须返回一个新的迭代器</p><p>检查是否存在默认迭代器属性可以暴露这个工厂函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两种类型都没有实现迭代器工厂函数</span></span><br><span class="line"><span class="built_in">console</span>.log(num[<span class="built_in">Symbol</span>.iterator]) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="built_in">Symbol</span>.iterator]) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>).set(<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>).set(<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>().add(<span class="string">&#x27;a&#x27;</span>).add(<span class="string">&#x27;b&#x27;</span>).add(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些类型都实现迭代器工厂函数</span></span><br><span class="line"><span class="built_in">console</span>.log(str[<span class="built_in">Symbol</span>.iterator]) <span class="comment">// ƒ values() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="built_in">Symbol</span>.iterator]) <span class="comment">// ƒ values() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map[<span class="built_in">Symbol</span>.iterator]) <span class="comment">// ƒ values() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(set[<span class="built_in">Symbol</span>.iterator]) <span class="comment">// ƒ values() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(divs[<span class="built_in">Symbol</span>.iterator]) <span class="comment">// ƒ values() &#123; [native code] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用这个工厂函数会生成一个迭代器</span></span><br><span class="line"><span class="built_in">console</span>.log(str[<span class="built_in">Symbol</span>.iterator]()) <span class="comment">// StringInterator &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="built_in">Symbol</span>.iterator]()) <span class="comment">// Array Iterator &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map[<span class="built_in">Symbol</span>.iterator]()) <span class="comment">// MapInterator &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(set[<span class="built_in">Symbol</span>.iterator]()) <span class="comment">// SetInterator &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(divs[<span class="built_in">Symbol</span>.iterator]()) <span class="comment">// Array Iterator &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>实际写代码过程不需要显示调用这个工厂函数来生产迭代器</p><p>实现可迭代协议的所有类型都会自动兼容接收可迭代对象的任何语言特性。</p><p>接收可迭代对象的原生语言特性包括：</p><ul><li>for-of循环</li><li>数组解构</li><li>扩展操作符</li><li>Array.from()</li><li>创建集合</li><li>创建映射</li><li>Promise.all()接收由promise组成的可迭代对象</li><li>Promise.race()接收由promise组成的可迭代对象</li><li>yeild*操作法，在生成器中使用</li></ul><p>迭代器协议定义了如何从一个对象中生成一系列的值<br>当一个对象实现了next()方法时，他就成为了一个迭代器。<br>next()方法必须返回一个带有2个属性的对象：</p><ul><li>value(下一个值,有值done为false，undefined：done为true)</li><li>done(true或false)</li></ul><p>数组演示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="built_in">Symbol</span>.iterator]) <span class="comment">// ƒ values() &#123; [native code] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line"><span class="built_in">console</span>.log(iter) <span class="comment">// Array Iterator()</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()) <span class="comment">// &#123;value: &#x27;foo&#x27;, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()) <span class="comment">// &#123;value: &#x27;bar&#x27;, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()) <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()) <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>只要迭代器到达done:true状态后续调用next()就一直返回同样的值了</p><p>迭代器并不与可迭代对象的某个时刻的快照绑定，而仅仅是使用游标来记录遍历历程。<br>如果可迭代对象在迭代期间被修改了，那么迭代器也会变化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="built_in">Symbol</span>.iterator]) <span class="comment">// ƒ values() &#123; [native code] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line"><span class="built_in">console</span>.log(iter) <span class="comment">// Array Iterator()</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()) <span class="comment">// &#123;value: &#x27;foo&#x27;, done: false&#125;</span></span><br><span class="line"></span><br><span class="line">arr.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()) <span class="comment">// &#123;value: &#x27;test&#x27;, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()) <span class="comment">// &#123;value: &#x27;bar&#x27;, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next()) <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>自定义的可迭代对象：</strong></p><p>当每次调用 next() 时, 这个可迭代对象会无限返回：10、20、30、40……</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自制的可迭代对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNumbers</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      n += <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">value</span>:n, <span class="attr">done</span>:<span class="literal">false</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建可迭代对象</span></span><br><span class="line"><span class="keyword">const</span> n = myNumbers();</span><br><span class="line">n.next(); <span class="comment">// Returns &#123;value: 10, done: false&#125;</span></span><br><span class="line">n.next(); <span class="comment">// Returns &#123;value: 20, done: false&#125;</span></span><br><span class="line">n.next(); <span class="comment">// Returns &#123;value: 30, done: false&#125;</span></span><br></pre></td></tr></table></figure><p>注意：自制的可迭代对象存在问题，它不支持 JavaScript 中的 for..of 语句。</p><p>JavaScript 中的可迭代对象是具有 Symbol.iterator 属性的对象。</p><p>Symbol.iterator 是一个返回 next() 函数的函数。</p><p>只能被迭代一次的可迭代对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">limit</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.limit = limit;</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.count &lt;= <span class="built_in">this</span>.limit) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="built_in">this</span>.count++ &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = <span class="keyword">new</span> Counter(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 未输出console</span></span><br></pre></td></tr></table></figure><p>为让一个可迭代对象可以创建多个迭代器，必须每创建一个迭代器就对应一个新的计数器，为此可以将计数器让在闭包里。通过闭包返回迭代器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">limit</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.limit = limit;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">      <span class="keyword">let</span> count = <span class="number">1</span></span><br><span class="line">      <span class="keyword">let</span> limit = <span class="built_in">this</span>.limit</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= limit) &#123;</span><br><span class="line">              <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: count++ &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> counter = <span class="keyword">new</span> Counter(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p><strong>提前终止迭代器：</strong></p><p>可选的return方法可以用于指定在迭代器提前关闭时的逻辑。执行迭代的结构要想让迭代器知道它不想可迭代对象耗尽时，就可以“关闭”迭代器。可能的情况有：</p><ul><li>for-of循环通过break,continue,return,throw提前退出</li><li>解构操作并未消费所有值</li></ul><p>return方法必须返回一个有效的IteratorResult对象。简单情况下可以只返回{done: true}</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">limit</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.limit = limit;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">      <span class="keyword">let</span> count = <span class="number">1</span></span><br><span class="line">      <span class="keyword">let</span> limit = <span class="built_in">this</span>.limit</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= limit) &#123;</span><br><span class="line">              <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: count++ &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="comment">// 可选的return方法</span></span><br><span class="line">          <span class="keyword">return</span>() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;exiting early&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> counter = <span class="keyword">new</span> Counter(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt;<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// exiting early</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次迭代重新开始</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>如果迭代器没有关闭，则还可以继续上次离开的地方继续迭代。比如，数组的迭代器就是不能关闭的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">3</span>) <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iter) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>因为return方法是可选的，所以并非所有迭代器都是可以关闭的.</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>promise的all和race</title>
      <link href="/ZJY.github.io/2023/05/19/promise%E7%9A%84all%E5%92%8Crace/"/>
      <url>/ZJY.github.io/2023/05/19/promise%E7%9A%84all%E5%92%8Crace/</url>
      
        <content type="html"><![CDATA[<h2 id="记Promise-all和race方法使用"><a href="#记Promise-all和race方法使用" class="headerlink" title="记Promise.all和race方法使用"></a>记Promise.all和race方法使用</h2><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>Promise.all()方法接收一个promise的iterable类型（注：Array, Map, Set都属于es6的iterable类型）的输入，并返回一个Promise实例，那么输入的所有promise的resolve回调的结果是一个数组。<br>这个Promise的resolve回调执行是在所有输入的promise的resolve回调都结束，或者输入的iterable里没有promise了的时候。<br>他的reject回调执行时，只要任何一个输入的promise的reject回调执行或者输入不合法的promise就会立即抛出错误，并且reject的是第一个抛出的错误信息。</p><p><strong><em>Promise.all 等待所有都完成或第一个失败。</em></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="number">1337</span>;</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>, <span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3]).then(<span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(values); <span class="comment">// [3, 1337, &quot;foo&quot;]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>p2非promise值<br><strong><em>如果请求参数中包含非promise值，这些值会被忽略，但仍然返回在数组中。</em></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.all([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.all([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>, <span class="built_in">Promise</span>.resolve(<span class="number">444</span>)]);</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="built_in">Promise</span>.all([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>, <span class="built_in">Promise</span>.reject(<span class="number">555</span>)]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(p);</span><br><span class="line">    <span class="built_in">console</span>.log(p2);</span><br><span class="line">    <span class="built_in">console</span>.log(p3);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span> &#123;&lt;fulfilled&gt;: <span class="built_in">Array</span>(<span class="number">3</span>)&#125;</span><br><span class="line"><span class="built_in">Promise</span> &#123;&lt;fulfilled&gt;: <span class="built_in">Array</span>(<span class="number">4</span>)&#125;</span><br><span class="line"><span class="built_in">Promise</span> &#123;&lt;rejected&gt;: <span class="number">555</span>&#125;</span><br></pre></td></tr></table></figure><p>只要任何一个输入的promise的reject回调执行,就会reject</p><p><strong><em>Promise.all的异步和同步：</em></strong></p><p>如果传入的可迭代对象是空的，就是同步：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.all([])</span><br><span class="line"><span class="built_in">console</span>.log(p)</span><br><span class="line"><span class="comment">// Promise &#123;&lt;fulfilled&gt;: Array(0)&#125;</span></span><br></pre></td></tr></table></figure><p>异步(<strong><em>即使参数不是promise值，也是异步的</em></strong>):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> resolvedPromisesArray = [<span class="built_in">Promise</span>.resolve(<span class="number">33</span>), <span class="built_in">Promise</span>.resolve(<span class="number">44</span>)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.all(resolvedPromisesArray);</span><br><span class="line"><span class="built_in">console</span>.log(p);</span><br><span class="line"></span><br><span class="line"><span class="comment">// using setTimeout we can execute code after the stack is empty</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise &#123; &lt;state&gt;: &quot;pending&quot; &#125;</span></span><br><span class="line"><span class="comment">// Promise &#123; &lt;state&gt;: &quot;fulfilled&quot;, &lt;value&gt;: Array[2] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.all([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(p)</span><br><span class="line"><span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br></pre></td></tr></table></figure><p>如果 Promise.all 失败，也是一样的异步:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mixedPromisesArray = [<span class="number">1</span>, <span class="built_in">Promise</span>.resolve(<span class="number">33</span>), <span class="built_in">Promise</span>.reject(<span class="number">44</span>)];</span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.all(mixedPromisesArray);</span><br><span class="line"><span class="built_in">console</span>.log(p);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(p);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br><span class="line">&#123;<span class="comment">/* Promise &#123;&lt;rejected&gt;: 44&#125; */</span>&#125;</span><br></pre></td></tr></table></figure><p><strong><em>Promise.all 的快速返回失败行为</em></strong><br>Promise.all 在任意一个传入的 promise 失败时返回失败</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="string">&#x27;one&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">2000</span>, <span class="string">&#x27;two&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">3000</span>, <span class="string">&#x27;three&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">4000</span>, <span class="string">&#x27;four&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p5 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">&#x27;reject&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3, p4, p5]).then(<span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(values);</span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reason)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//From console:</span></span><br><span class="line"><span class="comment">//&quot;reject&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//You can also use .catch</span></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3, p4, p5]).then(<span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(values);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reason)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//From console:</span></span><br><span class="line"><span class="comment">//&quot;reject&quot;</span></span><br></pre></td></tr></table></figure><p>需要特别注意的是，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，即p4的结果在前，即便p4的结果获取的比p1要晚。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>, <span class="string">&#x27;one&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">200</span>, <span class="string">&#x27;two&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">300</span>, <span class="string">&#x27;three&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">400</span>, <span class="string">&#x27;four&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p4, p1, p2, p3]).then(<span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(values); <span class="comment">// [&#x27;four&#x27;, &#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]</span></span><br><span class="line">&#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reason)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>Promise.race(iterable)方法返回一个promise，一旦迭代器中某个promise解决或拒绝，返回的promise就会解决或拒绝。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">500</span>, <span class="string">&#x27;one&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>, <span class="string">&#x27;two&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([promise1, promise2]).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// two</span></span><br><span class="line">  <span class="comment">// Both resolve, but promise2 is faster</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong><em>Promise.race的异步性</em></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.race([<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="built_in">console</span>.log(p)</span><br><span class="line"><span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.race([<span class="built_in">Promise</span>.resolve(<span class="number">22</span>),<span class="number">2</span>])</span><br><span class="line"><span class="built_in">console</span>.log(p)</span><br><span class="line"><span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br></pre></td></tr></table></figure><p>setTimeout示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">500</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// &quot;two&quot;</span></span><br><span class="line">  <span class="comment">// 两个都完成，但 p2 更快</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">100</span>, <span class="string">&quot;three&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p4 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(reject, <span class="number">500</span>, <span class="string">&quot;four&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([p3, p4]).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// &quot;three&quot;</span></span><br><span class="line">  <span class="comment">// p3 更快，所以它完成了</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 未被调用</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p5 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, <span class="number">500</span>, <span class="string">&quot;five&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p6 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(reject, <span class="number">100</span>, <span class="string">&quot;six&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([p5, p6]).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 未被调用</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(reason); <span class="comment">// &quot;six&quot;</span></span><br><span class="line">  <span class="comment">// p6 更快，所以它失败了</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react基础知识</title>
      <link href="/ZJY.github.io/2023/04/11/react%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/ZJY.github.io/2023/04/11/react%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>React 是一个用于构建用户界面的 JavaScript 库。</p><ul><li>原生js操作Dom繁琐、效率低</li><li>原生js直接操作dom，浏览器进行大量重绘重排</li><li>原生js没有组件化编码，代码复用率低</li></ul><p>React的特点：</p><ul><li>采用组件化模式、声明式编码，提高开发效率和组件复用率</li><li>在React Native中使用React语法进行移动端开发</li><li>使用虚拟dom+diff算法，减少与真实dom的交互</li></ul><h3 id="1-使用react-jsx"><a href="#1-使用react-jsx" class="headerlink" title="1.使用react(jsx)"></a>1.使用react(jsx)</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;like_button_container&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@18/umd/react.development.js&quot;</span> <span class="attr">crossorigin</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@18/umd/react-dom.development.js&quot;</span> <span class="attr">crossorigin</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用jsx --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/babel-standalone@6/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 可以在任何 &lt;script&gt; 标签内使用 JSX，方法是在为其添加 type=&quot;text/babel&quot; 属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> vDom = (</span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>hello react<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span><br><span class="line">  )</span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> domContainer = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#like_button_container&#x27;</span>);</span></span><br><span class="line">  ReactDOM.createRoot(domContainer).render(vDom)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>虚拟dom是object类型的对象，比真实dom轻，最终会渲染成真实dom</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> vDom, vDom <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// object true</span></span><br></pre></td></tr></table></figure><h3 id="2-jsx"><a href="#2-jsx" class="headerlink" title="2.jsx"></a>2.jsx</h3><p>JSX 是 JavaScript XML 的简写，表示 JavaScript 代码中写 XML（HTML）格式的代码。一种在React组件内部构建标签的类XML语法。</p><p>语法规则：<br>  定义虚拟dom时，不要写引号，使用小括号()<br>  使用jsx表达式时，用{}包裹<br>  样式的类名，使用className属性, style内联样式使用<code>&#123;&#123; &#125;&#125;</code><br>  只有一个根标签<br>  标签必须闭合<br>  标签首字母：若小写字母开头，则转为html标签同名元素，如果没有对应同名元素则报错；若大写字母开头，就去渲染对应的组件，如果没有定义就报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [<span class="string">&#x27;Angular&#x27;</span>, <span class="string">&#x27;React&#x27;</span>, <span class="string">&#x27;Vue&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> listItems = data.map(<span class="function">(<span class="params">item</span>) =&gt;</span></span><br><span class="line">  &lt;li key=&#123;item&#125;&gt;&#123;item&#125;&lt;/li&gt;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> vDom = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;xxxxxx&lt;/h1&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123; listItems &#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> domContainer = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#test&#x27;</span>);</span><br><span class="line">ReactDOM.createRoot(domContainer).render(vDom)</span><br></pre></td></tr></table></figure><h3 id="state和事件处理"><a href="#state和事件处理" class="headerlink" title="state和事件处理"></a>state和事件处理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// this是类的实例对象</span></span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">speak</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 方法放在了类的原型对象上，Person.prototype.speak</span></span><br><span class="line">    <span class="comment">// 通过实例对象调用的方法，this就是实例对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`my name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>, age is <span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age, sex</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// this是类的实例对象</span></span><br><span class="line">    <span class="built_in">super</span>(name, age)</span><br><span class="line">    <span class="built_in">this</span>.sex = sex</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">&#x27;lucy&#x27;</span>, <span class="number">20</span>)</span><br><span class="line">p1.speak()</span><br><span class="line"><span class="built_in">console</span>.log(p1) <span class="comment">// Person: &#123; name: &#x27;lucy&#x27;, age: 20, Prototype: &#123;constructor, speak&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> Student(<span class="string">&#x27;xiaomi&#x27;</span>, <span class="number">22</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1)</span><br><span class="line">s1.speak()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weather</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数。</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props)</span><br><span class="line">    <span class="comment">// 在 constructor() 函数中不要调用 setState() 方法。如果你的组件需要使用内部 state，请直接在构造函数中为 this.state 赋值初始 state</span></span><br><span class="line">    <span class="comment">// 只能在构造函数中直接为 this.state 赋值。如需在其他方法中赋值，你应使用 this.setState() 替代</span></span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      isHot: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.handleClick = <span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">handleClick</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(this)</span></span><br><span class="line">    <span class="comment">// handleClick作为onclick的回调，不是通过实例对象调用的是直接调用的， 所以this是undefined， 需要bind绑定this（实例对象）</span></span><br><span class="line">    <span class="built_in">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">      isHot: !prevState.isHot</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>today is &#123;this.state.isHot ? &#x27;hot&#x27;: &#x27;cold&#x27;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.createRoot(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>)).render(<span class="xml"><span class="tag">&lt;<span class="name">Weather</span> /&gt;</span></span>)</span><br></pre></td></tr></table></figure><p>state不可直接更改，通过setState更改，合并更新;<br>constructor构造器只执行一次，render调用1-n次;</p><p>通常，在 React 中，构造函数仅用于以下两种情况：</p><ul><li>通过给 this.state 赋值对象来初始化内部 state。</li><li>为事件处理函数绑定实例</li></ul><p>简写state和方法调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">state = &#123; <span class="attr">isHot</span>: <span class="literal">false</span> &#125; <span class="comment">// 不需要contructor</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;(e)</span> =&gt;</span> this.handleClick()&#125;&gt;today is &#123;this.state.isHot ? &#x27;hot&#x27;: &#x27;cold&#x27;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 或者 */</span></span><br><span class="line">handleClick = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.setState(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">    isHot: !prevState.isHot</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, age &#125; = <span class="built_in">this</span>.props</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;name: &#123; name &#125;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;age: &#123; age &#125;&lt;/li&gt;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = &#123; <span class="attr">name</span>: <span class="string">&#x27;lucy&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;</span><br><span class="line">ReactDOM.createRoot(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>)).render(<span class="xml"><span class="tag">&lt;<span class="name">Woman</span> &#123;<span class="attr">...p</span>&#125;/&gt;</span></span>) <span class="comment">// 多个props</span></span><br><span class="line"><span class="comment">// ReactDOM.createRoot(document.getElementById(&#x27;test&#x27;)).render(&lt;Woman name=&quot;lucy&quot;/&gt;) // 单个props</span></span><br></pre></td></tr></table></figure><p>约束props类型和必传,默认值：<br>引入<code>&lt;script src=&quot;https://unpkg.com/prop-types@15.6/prop-types.js&quot;&gt;&lt;/script&gt;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Woman.propTypes = &#123;</span><br><span class="line">  name: PropTypes.string.isRequired,</span><br><span class="line">  age: PropTypes.number</span><br><span class="line">&#125;</span><br><span class="line">Woman.defaultProps = &#123;</span><br><span class="line">  name: <span class="string">&#x27;cassie&#x27;</span>,</span><br><span class="line">  age: <span class="number">99</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简写：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    name: PropTypes.string.isRequired,</span><br><span class="line">    age: PropTypes.number</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    name: <span class="string">&#x27;cassie&#x27;</span>,</span><br><span class="line">    age: <span class="number">99</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数式组件使用props：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.createRoot(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>)).render(<span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">&quot;lucy&quot;</span>/&gt;</span></span>)</span><br></pre></td></tr></table></figure><p><strong>注意：组件无论是使用函数声明还是通过 class 声明，都决不能修改自身的 props.</strong></p><h3 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h3><p>string类型的refs</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串ref</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">handleLeft</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// const input = document.getElementById(&#x27;left&#x27;)</span></span><br><span class="line">    <span class="comment">// alert(&#x27;input-left: &#x27;+ input.value)</span></span><br><span class="line">    alert(<span class="string">&#x27;input-left: &#x27;</span>+ <span class="built_in">this</span>.refs.left.value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">handleBlur</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// const input = document.getElementById(&#x27;right&#x27;)</span></span><br><span class="line">    <span class="comment">// alert(&#x27;input-right: &#x27;+ input.value)</span></span><br><span class="line">    alert(<span class="string">&#x27;input-right: &#x27;</span>+ <span class="built_in">this</span>.refs.right.value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input ref=<span class="string">&quot;left&quot;</span> id=<span class="string">&quot;left&quot;</span> type=<span class="string">&quot;text&quot;</span> placeholder=<span class="string">&quot;please input&quot;</span> /&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">this</span>.handleLeft(e)&#125;&gt;click me left&lt;/button&gt;</span><br><span class="line">        &lt;input ref=<span class="string">&quot;right&quot;</span> id=<span class="string">&quot;right&quot;</span> onBlur=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">this</span>.handleBlur(e)&#125; type=<span class="string">&quot;text&quot;</span> placeholder=<span class="string">&quot;please input&quot;</span> /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.createRoot(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>)).render(<span class="xml"><span class="tag">&lt;<span class="name">Demo</span> /&gt;</span></span>)</span><br></pre></td></tr></table></figure><p>createRef创建的ref和回调ref：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props)</span><br><span class="line">    <span class="built_in">this</span>.leftRef = React.createRef()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">handleLeft</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// const input = document.getElementById(&#x27;left&#x27;)</span></span><br><span class="line">    <span class="comment">// alert(&#x27;input-left: &#x27;+ input.value) // 原生js</span></span><br><span class="line">    <span class="comment">// alert(&#x27;input-left: &#x27;+ this.refs.left.value) // string类型的refs（过时）</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.leftRef);</span><br><span class="line">    alert(<span class="string">&#x27;input-left: &#x27;</span>+ <span class="built_in">this</span>.leftRef.current.value) <span class="comment">// createRef方式</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">handleBlur</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// const input = document.getElementById(&#x27;right&#x27;)</span></span><br><span class="line">    <span class="comment">// alert(&#x27;input-right: &#x27;+ input.value)</span></span><br><span class="line">    <span class="comment">// alert(&#x27;input-right: &#x27;+ this.refs.right.value)</span></span><br><span class="line">    alert(<span class="string">&#x27;input-right: &#x27;</span> + <span class="built_in">this</span>.rightRef.value) <span class="comment">// 回调refs</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input ref=&#123;<span class="built_in">this</span>.leftRef&#125; id=<span class="string">&quot;left&quot;</span> type=<span class="string">&quot;text&quot;</span> placeholder=<span class="string">&quot;please input&quot;</span> /&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">this</span>.handleLeft(e)&#125;&gt;click me left&lt;/button&gt;</span><br><span class="line">        &lt;input ref=&#123;<span class="function"><span class="params">current</span> =&gt;</span> <span class="built_in">this</span>.rightRef = current&#125; id=<span class="string">&quot;right&quot;</span> onBlur=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">this</span>.handleBlur(e)&#125; type=<span class="string">&quot;text&quot;</span> placeholder=<span class="string">&quot;please input&quot;</span> /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.createRoot(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>)).render(<span class="xml"><span class="tag">&lt;<span class="name">Demo</span> /&gt;</span></span>)</span><br></pre></td></tr></table></figure><p><strong>关于回调 refs 的说明:</strong></p><p>如果 ref 回调函数是以内联函数的方式定义的，在更新过程中它会被执行两次，第一次传入参数 null，然后第二次会传入参数 DOM 元素。这是因为在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的。</p><p>通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免上述问题，但是大多数情况下它是无关紧要的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">this</span>.inputText = <span class="literal">null</span></span><br><span class="line"><span class="built_in">this</span>.rightRef1 = <span class="function">(<span class="params">current</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;回调refs-class-绑定函数&#x27;</span>, current);</span><br><span class="line">  <span class="built_in">this</span>.inputText = current</span><br><span class="line">&#125;</span><br><span class="line">&lt;input ref=&#123;<span class="built_in">this</span>.rightRef1&#125; id=<span class="string">&quot;right&quot;</span> onBlur=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">this</span>.handleBlur1(e)&#125; type=<span class="string">&quot;text&quot;</span> placeholder=<span class="string">&quot;please input&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><p>React事件的命名采用小驼峰式camelCase, 而不是纯小写。<br>使用jsx语法时，需要传入一个函数作为事件处理函数，而不是一个字符串。<br>不能通过return false的方式阻止默认行为，必须显式使用e.preventDefault().<br>在js中，class的方法默认不会绑定this，可以使用onClick={() =&gt; this.handleClick()}或者handleClick = () =&gt; {}来绑定this<br>通过事件委托方式<br>向事件处理程序传递参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">this</span>.deleteRow(id, e)&#125;&gt;Delete Row&lt;<span class="regexp">/button&gt; /</span><span class="regexp">/ 箭头函数</span></span><br><span class="line"><span class="regexp">&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/</span>button&gt; <span class="comment">// Function.prototype.bind ,事件对象以及更多的参数将会被隐式的传递</span></span><br></pre></td></tr></table></figure><p>受控组件：表单数据是由React组件来管理的（state）<br>非受控组件：表单数据由DOM节点来处理（ref）。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p><strong><em>挂载</em></strong></p><p>当组件实例被创建并插入dom时，其生命周期调用顺序如下：</p><ul><li>contructor()</li><li>static getDerivedStateFromProps()</li><li>render()</li><li>componentDidMount()</li></ul><p>当组件的props或state发生变化时会触发更新。更新的生命周期调用顺序如下：</p><ul><li>static getDerivedStateFromProps()</li><li>shouldComponentUpdate() 必须有返回值，返回值为假值，则不进行组件更新（强制更新除外）</li><li>render()</li><li>getSnapshotBeforeUpdate()</li><li>componentDidUpdate()</li></ul><p><strong><em>卸载</em></strong></p><p>当组件从 DOM 中移除时会调用如下方法：</p><ul><li>componentWillUnmount()</li></ul><p><a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">生命周期图</a></p><p>新的生命周期比旧生命周期相比：废弃componentWillMount,componentWillUpdate,componentWillReceiveProps,新增getDerivedStateFromProps、getSnapshotBeforeUpdate</p><p><strong>getDerivedStateFromProps：</strong></p><p>会在调用 render 方法之前调用并且在初始挂载及后续更新时都会被调用。<br>它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。</p><p><strong>getSnapshotBeforeUpdate：</strong></p><p>getSnapshotBeforeUpdate() 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。<br>此生命周期方法的任何返回值将作为参数传递给 componentDidUpdate()。</p><h3 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h3><p>单个代理：</p><p>在package.json里配置proxy：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;proxy&quot;</span>: <span class="string">&quot;http://localhost:5000&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在setupProxy配置多个代理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; createProxyMiddleware &#125; = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">app</span>) </span>&#123;</span><br><span class="line">  app.use(</span><br><span class="line">    createProxyMiddleware(<span class="string">&#x27;/api1&#x27;</span>, &#123;</span><br><span class="line">      target: <span class="string">&#x27;http://localhost:5000&#x27;</span>,</span><br><span class="line">      changeOrigin: <span class="literal">true</span>,</span><br><span class="line">      pathRewrite: &#123;</span><br><span class="line">        <span class="string">&#x27;^/api1&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    createProxyMiddleware(<span class="string">&#x27;/api2&#x27;</span>, &#123;</span><br><span class="line">      target: <span class="string">&#x27;http://localhost:5001&#x27;</span>,</span><br><span class="line">      changeOrigin: <span class="literal">true</span>,</span><br><span class="line">      pathRewrite: &#123;</span><br><span class="line">        <span class="string">&#x27;^/api2&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用需要加前缀：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">getData = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  axios.get(<span class="string">&#x27;http://localhost:3000/api1/students&#x27;</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;success&#x27;</span>, res)</span><br><span class="line">  &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;error&#x27;</span>, error)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">getCarData = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  axios.get(<span class="string">&#x27;http://localhost:3000/api2/cars&#x27;</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;success&#x27;</span>, res)</span><br><span class="line">  &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;error&#x27;</span>, error)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决多路径刷新页面样式丢失问题"><a href="#解决多路径刷新页面样式丢失问题" class="headerlink" title="解决多路径刷新页面样式丢失问题"></a>解决多路径刷新页面样式丢失问题</h3><p>1.public/index.html引入样式不写 ./ 写 /<br>2.public/index.html引入样式不写 ./ 写 %PUBLIC_URL%<br>3.使用HashRouter</p><h3 id="Redirect的使用"><a href="#Redirect的使用" class="headerlink" title="Redirect的使用"></a>Redirect的使用</h3><p>一般卸载路由注册的最下方，当所有路由都无法匹配时，跳转到redirect所指定的路由</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Route path=<span class="string">&quot;/home&quot;</span> component=&#123;Home&#125; /&gt;</span><br><span class="line">  &lt;Route path=<span class="string">&quot;/about&quot;</span> component=&#123;About&#125; /&gt;</span><br><span class="line">  &lt;Redirect to=<span class="string">&quot;/home&quot;</span> /&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure><h3 id="路由组件和一般组件"><a href="#路由组件和一般组件" class="headerlink" title="路由组件和一般组件"></a>路由组件和一般组件</h3><p><strong>路由匹配:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&quot;/about&quot;</span> component=&#123;About&#125; /&gt; <span class="comment">// 路由组件</span></span><br><span class="line">&lt;About  /&gt; <span class="comment">// 一般组件</span></span><br></pre></td></tr></table></figure><p><strong>存放位置:</strong></p><p>一般组件：compoents<br>路由组件：pages</p><p><strong>接收到props不同：</strong></p><p>一般组件：组件标签传递什么就接收什么<br>路由组件：接收到3个固定属性history,location,match</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">history</span><br><span class="line">  action: <span class="string">&quot;PUSH&quot;</span></span><br><span class="line">  block: ƒ block(prompt)</span><br><span class="line">  createHref: ƒ createHref(location)</span><br><span class="line">  go: ƒ go(n)</span><br><span class="line">  goBack: ƒ goBack()</span><br><span class="line">  goForward: ƒ goForward()</span><br><span class="line">  length: <span class="number">32</span></span><br><span class="line">  listen: ƒ listen(listener)</span><br><span class="line">  location: &#123;<span class="attr">pathname</span>: <span class="string">&#x27;/home&#x27;</span>, <span class="attr">search</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">hash</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">state</span>: <span class="literal">undefined</span>, <span class="attr">key</span>: <span class="string">&#x27;x2v2h1&#x27;</span>&#125;</span><br><span class="line">  push: ƒ push(path, state)</span><br><span class="line">  replace: ƒ replace(path, state)</span><br><span class="line"></span><br><span class="line">location:</span><br><span class="line">  hash: <span class="string">&quot;&quot;</span></span><br><span class="line">  key: <span class="string">&quot;x2v2h1&quot;</span></span><br><span class="line">  pathname: <span class="string">&quot;/home&quot;</span></span><br><span class="line">  search: <span class="string">&quot;&quot;</span></span><br><span class="line">  state: <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">match:</span><br><span class="line">  isExact: <span class="literal">true</span></span><br><span class="line">  params: &#123;&#125;</span><br><span class="line">  path: <span class="string">&quot;/home&quot;</span></span><br><span class="line">  url: <span class="string">&quot;/home&quot;</span></span><br></pre></td></tr></table></figure><h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p>1.注册子路由要写父路由的path</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--/home</span><br><span class="line">  --/home/news</span><br></pre></td></tr></table></figure><p>2.路由的匹配是按照注册路由的顺序进行的</p><h3 id="路由组件传递params参数-地址栏可见"><a href="#路由组件传递params参数-地址栏可见" class="headerlink" title="路由组件传递params参数(地址栏可见)"></a>路由组件传递params参数(地址栏可见)</h3><p>1.传递</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&#123;<span class="string">`/home/message/detail/<span class="subst">$&#123;item.id&#125;</span>/<span class="subst">$&#123;item.title&#125;</span>`</span>&#125;&gt;&#123;item.message&#125;&lt;/Link&gt;</span><br></pre></td></tr></table></figure><p>2.接收</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&quot;/home/message/detail/:id/:title&quot;</span> component=&#123;MessageDetail&#125;&gt;&lt;/Route&gt;</span><br></pre></td></tr></table></figure><p>3.获取值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; id, title &#125; = <span class="built_in">this</span>.props.match.params</span><br></pre></td></tr></table></figure><h3 id="路由组件传递search参数-地址栏可见"><a href="#路由组件传递search参数-地址栏可见" class="headerlink" title="路由组件传递search参数(地址栏可见)"></a>路由组件传递search参数(地址栏可见)</h3><p>1.传递</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&#123;<span class="string">`/home/message/detail/?id=<span class="subst">$&#123;item.id&#125;</span>&amp;title=<span class="subst">$&#123;item.title&#125;</span>`</span>&#125;&gt;&#123;item.message&#125;&lt;/Link&gt;</span><br><span class="line">&lt;Link to=&#123;&#123;</span><br><span class="line">  pathname: <span class="string">`/home/message/detail`</span>,</span><br><span class="line">  search: <span class="string">`?id=<span class="subst">$&#123;item.id&#125;</span>&amp;title=<span class="subst">$&#123;item.title&#125;</span>`</span></span><br><span class="line">&#125;&#125;&gt;&#123;item.message&#125;&lt;/Link&gt;</span><br></pre></td></tr></table></figure><p>2.接收</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&quot;/home/message/detail&quot;</span> component=&#123;MessageDetail&#125;&gt;&lt;/Route&gt;</span><br></pre></td></tr></table></figure><p>3.获取值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">&#x27;qs&#x27;</span></span><br><span class="line"><span class="keyword">const</span> search = qs.parse(<span class="built_in">this</span>.props.location.search.replace(<span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;&#x27;</span>))  <span class="comment">// result: &#123;id: xxx, title: xxx&#125;</span></span><br><span class="line"><span class="keyword">const</span> &#123; id, title &#125; = search</span><br></pre></td></tr></table></figure><h3 id="路由组件传递state参数-地址栏不可见"><a href="#路由组件传递state参数-地址栏不可见" class="headerlink" title="路由组件传递state参数(地址栏不可见)"></a>路由组件传递state参数(地址栏不可见)</h3><p>1.传递</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&#123;&#123;</span><br><span class="line">  pathname: <span class="string">`/home/message/detail`</span>,</span><br><span class="line">  state: &#123; <span class="attr">id</span>: item.id, <span class="attr">title</span>: item.title&#125;</span><br><span class="line">&#125;&#125;&gt;&#123;item.message&#125;&lt;/Link&gt;</span><br></pre></td></tr></table></figure><p>2.接收</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&quot;/home/message/detail&quot;</span> component=&#123;MessageDetail&#125;&gt;&lt;/Route&gt;</span><br></pre></td></tr></table></figure><p>3.获取值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; id, title &#125; = <span class="built_in">this</span>.props.location.state  <span class="comment">// state: &#123;id: xxx, title: xxx&#125;</span></span><br></pre></td></tr></table></figure><p><strong>参数地址栏不可见，刷新也能保留参数，但是清除浏览器历史记录后state为undefined.</strong></p><h3 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// push-search参数</span></span><br><span class="line"><span class="built_in">this</span>.props.history.push(<span class="string">`/home/message/detail/?id=<span class="subst">$&#123;item.id&#125;</span>&amp;title=<span class="subst">$&#123;item.title&#125;</span>`</span>)</span><br><span class="line"><span class="comment">// push-params</span></span><br><span class="line"><span class="built_in">this</span>.props.history.push(<span class="string">`/home/message/detail/<span class="subst">$&#123;item.id&#125;</span>/<span class="subst">$&#123;item.title&#125;</span>`</span>)</span><br><span class="line"><span class="comment">// push-state</span></span><br><span class="line"><span class="built_in">this</span>.props.history.push(<span class="string">`/home/message/detail`</span>, &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">title</span>: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// replace-search参数</span></span><br><span class="line"><span class="built_in">this</span>.props.history.replace(<span class="string">`/home/message/detail/?id=<span class="subst">$&#123;item.id&#125;</span>&amp;title=<span class="subst">$&#123;item.title&#125;</span>`</span>)</span><br><span class="line"><span class="comment">// replace-params</span></span><br><span class="line"><span class="built_in">this</span>.props.history.replace(<span class="string">`/home/message/detail/<span class="subst">$&#123;item.id&#125;</span>/<span class="subst">$&#123;item.title&#125;</span>`</span>)</span><br><span class="line"><span class="comment">// replace-state</span></span><br><span class="line"><span class="built_in">this</span>.props.history.replace(<span class="string">`/home/message/detail`</span>, &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">title</span>: <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前进</span></span><br><span class="line"><span class="built_in">this</span>.props.history.goForward()</span><br><span class="line"><span class="comment">// 后退</span></span><br><span class="line"><span class="built_in">this</span>.props.history.goBack()</span><br><span class="line"><span class="comment">// 前进/后退</span></span><br><span class="line"><span class="built_in">this</span>.props.history.go(n) <span class="comment">// n为正负整数，正前进，负后退</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="withRouter"><a href="#withRouter" class="headerlink" title="withRouter"></a>withRouter</h3><p>一般组件没有history,location, match这三个属性，要使用路由可以用withRouter<br>可以通过 withRouter 高阶组件访问 history 对象的属性和最近的 <code>&lt;Route&gt;</code> 的 match 。 当路由渲染时， withRouter 会将已经更新的 match ， location 和 history 属性传递给被包裹的组件.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeaderRouter</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  forward = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;forward&#x27;</span>)</span><br><span class="line">    <span class="built_in">this</span>.props.history.goForward()</span><br><span class="line">  &#125;</span><br><span class="line">  back = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;back&#x27;</span>, <span class="built_in">this</span>.props.history)</span><br><span class="line">    <span class="built_in">this</span>.props.history.goBack()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;HeaderRouter&lt;/h1&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.forward&#125;&gt;前进&lt;/button&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.back&#125;&gt;后退&lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(HeaderRouter)</span><br></pre></td></tr></table></figure><h3 id="BrowserRouter-和-HashRouter-的区别"><a href="#BrowserRouter-和-HashRouter-的区别" class="headerlink" title="BrowserRouter 和 HashRouter 的区别"></a>BrowserRouter 和 HashRouter 的区别</h3><p><strong>底层原理不一样：</strong></p><p>BrowserRouter使用h5的history API，不兼容ie9及以下版本<br>HashRouter 使用的是URL的哈希值</p><p><strong>url表现形式不一样：</strong></p><p>BrowserRouter的路径使用/， 例如 “<a href="http://localhost:3000/home/news">http://localhost:3000/home/news</a>“<br>HashRouter的路径使用#， 例如 “<a href="http://localhost:3000/#home/news">http://localhost:3000#home/news</a>“</p><p><strong>刷新后对路由state参数的影响：</strong></p><p>BrowserRouter：没有影响，state保存在history中<br>HashRouter：导致路由state参数的丢失</p><h3 id="antd-使用"><a href="#antd-使用" class="headerlink" title="antd 使用"></a>antd 使用</h3><p>1.安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install antd --save</span><br><span class="line">yarn add antd</span><br></pre></td></tr></table></figure><p>2.引入<br>antd.js 和 antd.min.js 依赖 react、react-dom、dayjs，请确保提前引入这些文件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于 antd 组件的默认文案是英文，所以需要修改为中文</span></span><br><span class="line"><span class="keyword">import</span> dayjs <span class="keyword">from</span> <span class="string">&#x27;dayjs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dayjs/locale/zh-cn&#x27;</span></span><br><span class="line"><span class="keyword">import</span> zhCN <span class="keyword">from</span> <span class="string">&#x27;antd/locale/zh_CN&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;antd/dist/reset.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; ConfigProvider &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"></span><br><span class="line">dayjs.locale(<span class="string">&#x27;zh-cn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;ConfigProvider locale=&#123;zhCN&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;/ConfigProvider&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="使用antd-icon图标"><a href="#使用antd-icon图标" class="headerlink" title="使用antd-icon图标"></a>使用antd-icon图标</h3><p>1.安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save @ant-design/icons</span><br></pre></td></tr></table></figure><p>2.引入&amp;使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  HomeOutlined,</span><br><span class="line">  LoadingOutlined,</span><br><span class="line">  SettingFilled,</span><br><span class="line">  SmileOutlined,</span><br><span class="line">  SyncOutlined,</span><br><span class="line">  SearchOutlined</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;@ant-design/icons&#x27;</span></span><br><span class="line"></span><br><span class="line">&lt;HomeOutlined  style=&#123;&#123; <span class="attr">fontSize</span>: <span class="string">&#x27;20px&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span> &#125;&#125; /&gt;</span><br><span class="line">&lt;LoadingOutlined style=&#123;&#123; <span class="attr">fontSize</span>: <span class="string">&#x27;20px&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span> &#125;&#125; /&gt;</span><br><span class="line">&lt;SettingFilled  style=&#123;&#123; <span class="attr">fontSize</span>: <span class="string">&#x27;20px&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;green&#x27;</span> &#125;&#125; /&gt;</span><br><span class="line">&lt;SmileOutlined  style=&#123;&#123; <span class="attr">fontSize</span>: <span class="string">&#x27;20px&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;pink&#x27;</span> &#125;&#125; /&gt;</span><br><span class="line">&lt;SyncOutlined  style=&#123;&#123; <span class="attr">fontSize</span>: <span class="string">&#x27;20px&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;yellow&#x27;</span> &#125;&#125; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;Button type=<span class="string">&quot;primary&quot;</span> icon=&#123;<span class="xml"><span class="tag">&lt;<span class="name">SearchOutlined</span> /&gt;</span></span>&#125;&gt;primary Button&lt;/Button&gt;</span><br></pre></td></tr></table></figure><h3 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h3><p>Redux 是一个使用叫做 “action” 的事件来管理和更新应用状态的模式和工具库 它以集中式 Store（centralized store）的方式对整个应用中使用的状态进行集中管理，其规则确保状态只能以可预测的方式更新。<br>Redux 使用 “单向数据流</p><ol><li>1个专门用于做状态管理的js库，不是react的插件库</li><li>它可以用在react、angular、vue等项目中，但基本与react配合使用</li><li>作用：集中式管理react应用中共享的状态</li></ol><p><strong>1.store:</strong></p><p>  当前 Redux 应用的 state 存在于一个名为 store 的对象中。<br>  store 是通过传入一个 reducer 来创建的，并且有一个名为 getState 的方法，它返回当前状态值：</p><p><strong>2.action:</strong></p><p>  action 是一个具有 type 字段的普通 JavaScript 对象。你可以将 action 视为描述应用程序中发生了什么的事件.<br>  action 对象可以有其他字段，其中包含有关发生的事情的附加信息。按照惯例，我们将该信息放在名为 payload 的字段中。<br>  action creator 是一个创建并返回一个 action 对象的函数</p><p><strong>3.reducer:</strong></p><p>  reducer 是一个函数，接收当前的 state 和一个 action 对象，必要时决定如何更新状态，并返回新状态。函数签名是：(state, action) =&gt; newState。 你可以将 reducer 视为一个事件监听器，它根据接收到的 action（事件）类型处理事件。</p><p>Dispatch:Redux store 有一个方法叫 dispatch。更新 state 的唯一方法是调用 store.dispatch() 并传入一个 action 对象。 store 将执行所有 reducer 函数并计算出更新后的 state，调用 getState() 可以获取新 state.<br>Selector: Selector 函数可以从 store 状态树中提取指定的片段。随着应用变得越来越大，会遇到应用程序的不同部分需要读取相同的数据，selector 可以避免重复这样的读取逻辑</p><p><strong>Redux 数据流:</strong><br>早些时候，我们谈到了“单向数据流”，它描述了更新应用程序的以下步骤序列：</p><ul><li>State 描述了应用程序在特定时间点的状况</li><li>基于 state 来渲染视图</li><li>当发生某些事情时（例如用户单击按钮），state 会根据发生的事情进行更新</li><li>基于新的 state 重新渲染视图</li><li>具体来说，对于 Redux，我们可以将这些步骤分解为更详细的内容：</li></ul><p>初始启动：</p><ul><li>使用最顶层的 root reducer 函数创建 Redux store</li><li>store 调用一次 root reducer，并将返回值保存为它的初始 state</li><li>当视图 首次渲染时，视图组件访问 Redux store 的当前 state，并使用该数据来决定要呈现的内容。同时监听 store 的更新，以便他们可以知道 state 是否已更改。</li></ul><p>更新环节：</p><ul><li>应用程序中发生了某些事情，例如用户单击按钮</li><li>dispatch 一个 action 到 Redux store，例如 dispatch({type: ‘counter/increment’})</li><li>store 用之前的 state 和当前的 action 再次运行 reducer 函数，并将返回值保存为新的 state</li><li>store 通知所有订阅过的视图，通知它们 store 发生更新</li><li>每个订阅过 store 数据的视图 组件都会检查它们需要的 state 部分是否被更新。</li><li>发现数据被更新的每个组件都强制使用新数据重新渲染，紧接着更新网页</li></ul><p>Redux 使用 “单向数据流”:</p><ul><li>State 描述了应用程序在某个时间点的状态，视图基于该 state 渲染</li><li>当应用程序中发生某些事情时：<ul><li>视图 dispatch 一个 action</li><li>store 调用 reducer，随后根据发生的事情来更新 state</li><li>store 将 state 发生了变化的情况通知 UI</li></ul></li><li>视图基于新 state 重新渲染</li></ul><p>Redux 有这几种类型的代码</p><ul><li>Action 是有 type 字段的纯对象，描述发生了什么</li><li>Reducer 是纯函数，基于先前的 state 和 action 来计算新的 state</li><li>每当 dispatch 一个 action 后，store 就会调用 root reducer.</li></ul><p>(Redux原理图)<a href="https://img1.baidu.com/it/u=549036950,105530499&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPG?w=913&amp;h=500">https://img1.baidu.com/it/u=549036950,105530499&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPG?w=913&amp;h=500</a><br>(Redux原理图)<a href="https://cn.redux.js.org/assets/images/ReduxDataFlowDiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif">https://cn.redux.js.org/assets/images/ReduxDataFlowDiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif</a></p><p>同步action: 一般对象类型{type: ‘’, data: null}为同步action<br>异步action：返回值为函数为异步action</p><p>redux-thunk 来开发特定的异步逻辑（异步action）</p><p>redux: js库<br>react-redux:react插件库</p><p>react-redux:<br>容器组件：负责和redux同学，将结果交给ui组件<br>ui组件：不能使用任何redux的api，只负责页面交互、呈现</p><p>如何创建容器组件，react-redux的connect函数：<br>容器组件会传给ui组件2个参数：mapStateToProps状态映射为props；映射操作状态的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(mapStateToProps, mapDispatchToProps)(CountUI)</span><br></pre></td></tr></table></figure><p>容器中的store是靠props传进去，不是在容器直接引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    count: state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    increment: <span class="function">(<span class="params">number</span>) =&gt;</span> &#123; dispatch(createIncrementAction(number)) &#125;,</span><br><span class="line">    decrement: <span class="function">(<span class="params">number</span>) =&gt;</span> &#123; dispatch(createDecrementAction(number)) &#125;,</span><br><span class="line">    incrementAsyc: <span class="function">(<span class="params">number, time</span>) =&gt;</span> &#123; dispatch(createIncrementActionAsync(number, time)) &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>connect参数可简写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(</span><br><span class="line">  state =&gt; (&#123;<span class="attr">count</span>: state&#125;), </span><br><span class="line">  &#123;</span><br><span class="line">    increment: createIncrementAction,</span><br><span class="line">    decrement: createDecrementAction,</span><br><span class="line">    incrementAsyc: createIncrementActionAsync</span><br><span class="line">  &#125;)(CountUI)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"></span><br><span class="line">&lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">  &lt;App /&gt;</span><br><span class="line">&lt;/Provider&gt;</span><br></pre></td></tr></table></figure><h3 id="Redux的reducer一定要是纯函数"><a href="#Redux的reducer一定要是纯函数" class="headerlink" title="Redux的reducer一定要是纯函数"></a>Redux的reducer一定要是纯函数</h3><p>纯函数：只要函数的调用参数相同，就永远返回相同的结果。</p><p>实现纯函数：</p><ol><li>不修改入参</li><li>不执行有副作用的操作（修改函数之外的其他变量、API调用等）</li><li>不调用其他非纯函数（Date.now()）<br>保证纯函数的原则，则每当我们dispatch一个相同的action，且初状态相同，则<br>总是能得到一个相同的结果（状态变化），因此可以实现redux的时间旅行功能。</li></ol><h3 id="使用redux-devtools工具（浏览器插件）"><a href="#使用redux-devtools工具（浏览器插件）" class="headerlink" title="使用redux-devtools工具（浏览器插件）"></a>使用redux-devtools工具（浏览器插件）</h3><p>1.安装redux-devtools插件</p><p>2.项目安装插件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save redux-devtools-extension</span><br></pre></td></tr></table></figure><p>3.项目使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore, applyMiddleware, combineReducers &#125; from &#39;redux&#39;</span><br><span class="line">&#x2F;&#x2F; 使用 Thunk Middleware 来做异步 Action</span><br><span class="line">import thunk from &#39;redux-thunk&#39;</span><br><span class="line">import &#123; composeWithDevTools &#125; from &#39;redux-devtools-extension&#39; &#x2F;&#x2F; 此处引入</span><br><span class="line"></span><br><span class="line">import countReducer from &#39;.&#x2F;reducers&#x2F;count.js&#39;</span><br><span class="line">import personReducer from &#39;.&#x2F;reducers&#x2F;person.js&#39;</span><br><span class="line"></span><br><span class="line">export default createStore(combineReducers(&#123;</span><br><span class="line">  count: countReducer,</span><br><span class="line">  person: personReducer</span><br><span class="line">&#125;), composeWithDevTools(applyMiddleware(thunk)))</span><br></pre></td></tr></table></figure><h3 id="打包本地运行"><a href="#打包本地运行" class="headerlink" title="打包本地运行"></a>打包本地运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成build文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> static server:</span></span><br><span class="line">npm install -g serve</span><br><span class="line">serve -s build</span><br></pre></td></tr></table></figure><h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><p><strong>setState更新状态的2种方法：</strong></p><p>setState(nextState, callback?):<br>  nextState: 对象或函数。如果将一个对象作为nextState传递，它将被浅合并到this.state中。<br>  callback: 可选的回调函数。如果指定，React将在提交更新后（状态更新界面也更新后）调用您提供的回调。</p><p>setState(updater, callback?):<br>  updater: 更新器函数。它必须是纯的，应该以state和props作为参数，并且应该返回要浅合并到this.state中的对象。React将把你的updater函数放在队列中，并重新呈现你的组件<br>  callback: 可选的回调函数。如果指定，React将在提交更新后（状态更新界面也更新后）调用您提供的回调。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象式</span></span><br><span class="line"><span class="keyword">const</span> &#123; count &#125; = <span class="built_in">this</span>.state</span><br><span class="line"><span class="built_in">this</span>.setState(&#123;</span><br><span class="line">  count: count + <span class="number">1</span></span><br><span class="line">&#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.count)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数式</span></span><br><span class="line"><span class="comment">// this.setState((state) =&gt; (&#123;count: state.count + 1&#125;))</span></span><br><span class="line"><span class="built_in">this</span>.setState(<span class="function">(<span class="params">state, props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(state, props)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    count: state.count + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>总结： 对象式的setState是函数式的setState的简写方式，语法糖<br>使用规则：</p><ol><li>如果新状态不依赖于原状态，使用对象式</li><li>如果新状态依赖于原状态，使用函数式</li><li>如果要在setState执行后获取最新的状态数据，要在callback回调函数中读取</li></ol><h3 id="路由懒加载-lazy-amp-Suspense"><a href="#路由懒加载-lazy-amp-Suspense" class="headerlink" title="路由懒加载(lazy &amp; Suspense)"></a>路由懒加载(lazy &amp; Suspense)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, lazy, Suspense &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="comment">// 懒加载</span></span><br><span class="line"><span class="keyword">const</span> Home = lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../pages/Home&#x27;</span>))</span><br><span class="line"><span class="keyword">const</span> About = lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../pages/About&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结合：</span></span><br><span class="line">&lt;Suspense fallback=&#123;<span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>&#125;&gt;</span><br><span class="line">  &lt;Switch&gt;</span><br><span class="line">    &lt;Route path=<span class="string">&quot;/home&quot;</span> component=&#123;Home&#125; /&gt;</span><br><span class="line">    &lt;Route path=<span class="string">&quot;/about&quot;</span> component=&#123;About&#125; /&gt;</span><br><span class="line">    &#123;<span class="comment">/* &lt;Redirect to=&quot;/home&quot; /&gt; */</span>&#125;</span><br><span class="line">  &lt;/Switch&gt;</span><br><span class="line">&lt;/Suspense&gt;</span><br></pre></td></tr></table></figure><h3 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h3><ul><li>react16.8版本增加的新特性新语法</li><li>可以让你在函数式组件中使用state以及其他react特性</li></ul><p>常用hooks：</p><ol><li>State hook: useState()</li><li>Effect hook: useEffect()</li><li>Ref hook: useRef()</li></ol><p><strong>useState():</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = useState(initalValue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比如：</span></span><br><span class="line"><span class="keyword">const</span> [age, setAge] = useState(<span class="number">28</span>);</span><br><span class="line"><span class="keyword">const</span> [name, setName] = useState(<span class="string">&#x27;Taylor&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> [todos, setTodos] = useState(<span class="function">() =&gt;</span> createTodos());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// setCount(count + 1)</span></span><br><span class="line">  setCount(<span class="function"><span class="params">count</span> =&gt;</span> count + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>useEffect():</strong></p><p>useEffect(effect: React.EffectCallback, deps?: React.DependencyList | undefined): void</p><p>effect hook可以让你在函数组件中执行副作用操作（用于模拟类组件中的生命周期钩子）<br>effect中的副作用操作：</p><ol><li>发ajax请求</li><li>设置订阅/定时器</li><li>手动更改dom</li></ol><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在此处可执行副作用操作</span></span><br><span class="line">  <span class="comment">// dosomething...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123; <span class="comment">// 在组件卸载前执行</span></span><br><span class="line">    <span class="comment">// 做收尾，比如清除定时器取消订阅</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, [depsList]) <span class="comment">// 依赖的state，如果[]则只会在第一次render后执行</span></span><br></pre></td></tr></table></figure><p>可以把useEffect hook看成以下三个函数的组合：</p><ul><li>componentDitMount()</li><li>componentDidUpdate()</li><li>componentWillUnmount()</li></ul><p><strong>useRef():</strong></p><p>useRef 是一个 React Hook，它能让你引用一个不需要渲染的值。改变 ref 不会触发重新渲染，所以 ref 不适合用于存储期望显示在屏幕上的信息。如有需要，使用 state 代替</p><p><strong><em>用 ref 引用一个值:</em></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ref = useRef(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ref.current = ref.current + <span class="number">1</span>;</span><br><span class="line">    alert(<span class="string">&#x27;You clicked &#x27;</span> + ref.current + <span class="string">&#x27; times!&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">      Click me!</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要在渲染期间写入 或者读取 ref.current</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 🚩 不要在渲染期间写入 ref</span></span><br><span class="line">  myRef.current = <span class="number">123</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 🚩 不要在渲染期间读取 ref</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;myOtherRef.current&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件处理程序或者 effects 中读取和写入 ref。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ✅ 你可以在 effects 中读取和写入 ref</span></span><br><span class="line">    myRef.current = <span class="number">123</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ✅ 你可以在事件处理程序中读取和写入 ref</span></span><br><span class="line">    doSomething(myOtherRef.current);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>通过 ref 操作 DOM:</em></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 击按钮将会聚焦 input：</span></span><br><span class="line"><span class="keyword">import</span> &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef(<span class="literal">null</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    inputRef.current.focus();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;input ref=&#123;inputRef&#125; /&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">        Focus the input</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取自定义组件的 ref:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; forwardRef, useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyInput = forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Form</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    inputRef.current.focus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;MyInput ref=&#123;inputRef&#125; /&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">        Focus the input</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文档碎片Fragment"><a href="#文档碎片Fragment" class="headerlink" title="文档碎片Fragment"></a>文档碎片Fragment</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;&gt;</span><br><span class="line">  &lt;OneChild /&gt;</span><br><span class="line">  &lt;AnotherChild /&gt;</span><br><span class="line">&lt;/&gt;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">&lt;Fragment&gt;</span><br><span class="line">  &lt;OneChild /&gt;</span><br><span class="line">  &lt;AnotherChild /&gt;</span><br><span class="line">&lt;/Fragment&gt;</span><br><span class="line"><span class="comment">// or 遍历添加key</span></span><br><span class="line">&lt;Fragment key=&#123;<span class="number">1</span>&#125;&gt;</span><br><span class="line">  &lt;OneChild /&gt;</span><br><span class="line">  &lt;AnotherChild /&gt;</span><br><span class="line">&lt;/Fragment&gt;</span><br></pre></td></tr></table></figure><h3 id="createContext"><a href="#createContext" class="headerlink" title="createContext"></a>createContext</h3><p>createContext 能让你创建一个 context 以便组件能够提供和读取。方便后代组件祖组件之间通信。</p><p>1.创建上下文</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, createContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.创建上下文</span></span><br><span class="line"><span class="keyword">const</span> UsernameContext = createContext()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.传递</span></span><br><span class="line">&lt;UsernameContext.Provider value=&#123;&#123;...this.state&#125;&#125;&gt;</span><br><span class="line">  &lt;B  /&gt;</span><br><span class="line">&lt;/UsernameContext.Provider&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.接收使用</span></span><br><span class="line"><span class="comment">// c组件</span></span><br><span class="line"><span class="comment">// static contextType适用于类式组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> contextType = UsernameContext <span class="comment">// 声明接收context</span></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div style=&#123;&#123;<span class="attr">margin</span>: <span class="string">&#x27;20px 0 0 40px&#x27;</span>&#125;&#125;&gt;</span><br><span class="line">        &lt;h1&gt;组件C：&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;从B组件接收到的username: &#123;<span class="built_in">this</span>.context.username&#125;  age:&#123;<span class="built_in">this</span>.context.age&#125;&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Consumer适用于函数和类式组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div style=&#123;&#123;<span class="attr">margin</span>: <span class="string">&#x27;20px 0 0 40px&#x27;</span>&#125;&#125;&gt;</span><br><span class="line">      &lt;h1&gt;组件C：&lt;/h1&gt;</span><br><span class="line">      &lt;h2&gt;从B组件接收到的username: </span><br><span class="line">        &lt;UsernameContext.Consumer&gt;</span><br><span class="line">          &#123;</span><br><span class="line">            value =&gt; <span class="string">`<span class="subst">$&#123;value.username&#125;</span>   age: <span class="subst">$&#123;value.age&#125;</span>`</span></span><br><span class="line">          &#125;</span><br><span class="line">        &lt;/UsernameContext.Consumer&gt;</span><br><span class="line">      &lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h3><p>PureComponent会在shouldComponentUpdate对props和state进行浅比较，跳过不必要的更新，提高组件性能。<br>但是props 和 state 不能使用同一个引用。</p><p>以下不回触发render：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">this</span>.state</span><br><span class="line">obj.name = <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="built_in">this</span>.setState(obj)</span><br></pre></td></tr></table></figure><h3 id="render-props向组件内部传入带内容的标签"><a href="#render-props向组件内部传入带内容的标签" class="headerlink" title="render props向组件内部传入带内容的标签"></a>render props向组件内部传入带内容的标签</h3><p>vue中使用slot插槽<br>react中：render props 或者children props</p><p>render props:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;app:&lt;/h1&gt;</span><br><span class="line">      &lt;A render=&#123;<span class="function">(<span class="params">name</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">B</span> <span class="attr">name</span>=<span class="string">&#123;name&#125;/</span>&gt;</span></span>&#125; /&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    name: <span class="string">&#x27;react&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;h1&gt;A:&lt;/h1&gt;</span><br><span class="line">        &#123;<span class="built_in">this</span>.props.render(<span class="built_in">this</span>.state.name)&#125;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是B: &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>children props: 不能传递props</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;app:&lt;/h1&gt;</span><br><span class="line">      &lt;A&gt;</span><br><span class="line">        &lt;B  /&gt;</span><br><span class="line">      &lt;/A&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    name: <span class="string">&#x27;react&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;h1&gt;A:&lt;/h1&gt;</span><br><span class="line">        &#123;<span class="built_in">this</span>.props.children&#125;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// B...</span></span><br></pre></td></tr></table></figure><h3 id="错误边界"><a href="#错误边界" class="headerlink" title="错误边界"></a>错误边界</h3><p>error boundary错误边界：用来捕获后代组件错误，渲染出备用页面</p><p>只能捕获后<strong>代组件生命周期</strong>产生的错误，不能捕获自己组件产生的错误和其他组件在合成事件 定时器中产生的错误</p><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">state = &#123;</span><br><span class="line">  error: <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">getDerivedStateFromError</span>(<span class="params">error</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    hasError: error</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">componentDidCatch</span>(<span class="params">error, info</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 可以统计页面的错误，发送请求到后台去</span></span><br><span class="line">  <span class="built_in">console</span>.log(error, info)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组件通信方式"><a href="#组件通信方式" class="headerlink" title="组件通信方式"></a>组件通信方式</h3><p>组件间关系：</p><ul><li>父子组件 (props)</li><li>兄弟组件（非嵌套组件）(消息订阅-发布 集中式管理)</li><li>祖孙组件（跨级组件）(消息订阅-发布 集中式管理 context)</li></ul><p>通信方式：</p><ul><li>props: children props / render props</li><li>消息订阅-发布：pubs-sub</li><li>集中式管理：redux等</li><li>context： createContext、Provider、Consumer</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue3</title>
      <link href="/ZJY.github.io/2023/04/06/vue3/"/>
      <url>/ZJY.github.io/2023/04/06/vue3/</url>
      
        <content type="html"><![CDATA[<h1 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h1><p>安装全局vue-cli</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure><p>查看vue-cli版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue -V</span><br></pre></td></tr></table></figure><p>查看局部安装的vue-cli版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 首先进入局部安装目录</span></span><br><span class="line">npx vue -V</span><br></pre></td></tr></table></figure><p>创建vue项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx vue create my-project</span><br><span class="line">cd my-project</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure><h2 id="全局API"><a href="#全局API" class="headerlink" title="全局API"></a>全局API</h2><h3 id="createApp创建应用实例"><a href="#createApp创建应用实例" class="headerlink" title="createApp创建应用实例"></a>createApp创建应用实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line">createApp(App).use(router).mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"><span class="comment">// app.mount()将应用实例挂载在一个容器元素中。</span></span><br></pre></td></tr></table></figure><h2 id="组合式-API"><a href="#组合式-API" class="headerlink" title="组合式 API"></a>组合式 API</h2><h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><p>setup() 钩子是在组件中使用组合式 API 的入口，通常只在以下情况下使用：</p><ul><li>需要在非单文件组件中使用组合式 API 时。</li><li>需要在基于选项式 API 的组件中集成基于组合式 API 的代码时。</li></ul><p>在模板中访问从 setup 返回的 ref 时，它会自动浅层解包，因此你无须再在模板中为它写 .value</p><p>setup() 自身并不含对组件实例的访问权，即在 setup() 中访问 this 会是 undefined。你可以在选项式 API 中访问组合式 API 暴露的值，但反过来则不行。</p><p>setup返回的对象会和data和methods合并，setup优先级更高。</p><p>setup() 应该同步地返回一个对象。唯一可以使用 async setup() 的情况是，该组件是 Suspense 组件的后裔。</p><h3 id="ref"><a href="#ref" class="headerlink" title="ref()"></a>ref()</h3><p>接受一个内部值，返回一个响应式的、可更改的 ref 对象，此对象只有一个指向其内部值的属性 .value.</p><p>如果将一个对象赋值给 ref，那么这个对象将通过 reactive() 转为具有深层次响应式的对象。这也意味着如果对象中包含了嵌套的 ref，它们将被深层地解包.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要通过value属性访问值</span></span><br><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(count.value) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">count.value++</span><br><span class="line"><span class="built_in">console</span>.log(count.value) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h1&gt;c: &#123;&#123; a &#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;h1&gt;d: &#123;&#123; d.msg &#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    let a &#x3D; ref(1)</span><br><span class="line">    let b &#x3D; ref(1)</span><br><span class="line">    const d &#x3D; ref(&#123;</span><br><span class="line">      msg: &#39;hello&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">    const handleClick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">      a.value++</span><br><span class="line">      b.value++</span><br><span class="line">      d.value.msg &#x3D; &#39;test&#39;</span><br><span class="line">      console.log(&#39;handleClick-setup&#39;)</span><br><span class="line">      &#x2F;&#x2F; ElMessage.info(&#39;handleClick-setip&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">      a,</span><br><span class="line">      b,</span><br><span class="line">      d,</span><br><span class="line">      handleClick</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive()"></a>reactive()</h3><p>返回一个对象的响应式代理。</p><p>响应式转换是“深层”的：它会影响到所有嵌套的属性。一个响应式对象也将深层地解包任何 ref 属性，同时保持响应性。</p><p>值得注意的是，当访问到某个响应式数组或 Map 这样的原生集合类型中的 ref 元素时，不会执行 ref 的解包。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个响应式对象：</span></span><br><span class="line"><span class="keyword">const</span> obj = reactive(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line">obj.count++</span><br><span class="line"><span class="built_in">console</span>.log(obj.count) <span class="comment">// 1  无需通过.value属性访问值</span></span><br></pre></td></tr></table></figure><p>ref 的解包：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = ref(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> obj = reactive(&#123; count &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ref 会被解包</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.count === count.value) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 会更新 `obj.count`</span></span><br><span class="line">count.value++</span><br><span class="line"><span class="built_in">console</span>.log(count.value) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.count) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也会更新 `count` ref</span></span><br><span class="line">obj.count++</span><br><span class="line"><span class="built_in">console</span>.log(obj.count) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(count.value) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>注意当访问到某个响应式数组或 Map 这样的原生集合类型中的 ref 元素时，不会执行 ref 的解包：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> books = reactive([ref(<span class="string">&#x27;Vue 3 Guide&#x27;</span>)])</span><br><span class="line"><span class="comment">// 这里需要 .value</span></span><br><span class="line"><span class="built_in">console</span>.log(books[<span class="number">0</span>].value) <span class="comment">// Vue 3 Guide</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = reactive(<span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;count&#x27;</span>, ref(<span class="number">0</span>)]]))</span><br><span class="line"><span class="comment">// 这里需要 .value</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">&#x27;count&#x27;</span>)?.value) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h3 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs()"></a>toRefs()</h3><p>将一个响应式对象转换为一个普通对象，这个普通对象的每个属性都是指向源对象相应属性的 ref。每个单独的 ref 都是使用 toRef() 创建的.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  bar: <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stateAsRefs = toRefs(state)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">stateAsRefs 的类型：&#123;</span></span><br><span class="line"><span class="comment">  foo: Ref&lt;number&gt;,</span></span><br><span class="line"><span class="comment">  bar: Ref&lt;number&gt;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个 ref 和源属性已经“链接上了”</span></span><br><span class="line">state.foo++</span><br><span class="line"><span class="built_in">console</span>.log(stateAsRefs.foo.value) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">stateAsRefs.foo.value++</span><br><span class="line"><span class="built_in">console</span>.log(state.foo) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>toRefs 在调用时只会为源对象上可以枚举的属性创建 ref。如果要为可能还不存在的属性创建 ref，请改用 toRef.</p><h3 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a>toRef</h3><p>基于响应式对象上的一个属性，创建一个对应的 ref。这样创建的 ref 与其源属性保持同步：改变源属性的值将更新 ref 的值，反之亦然.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  bar: <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fooRef = toRef(state, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更改该 ref 会更新源属性</span></span><br><span class="line">fooRef.value++</span><br><span class="line"><span class="built_in">console</span>.log(state.foo) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更改源属性也会更新该 ref</span></span><br><span class="line">state.foo++</span><br><span class="line"><span class="built_in">console</span>.log(fooRef.value) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>请注意，这不同于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fooRef = ref(state.foo)</span><br></pre></td></tr></table></figure><p>上面这个 ref 不会和 state.foo 保持同步，因为这个 ref() 接收到的是一个纯数值</p><h3 id="比较vue2和vue3的响应式"><a href="#比较vue2和vue3的响应式" class="headerlink" title="比较vue2和vue3的响应式"></a>比较vue2和vue3的响应式</h3><p>vue2的问题：<br>1.对象直接添加新的属性或删除已有的属性，界面不会自动更新，不是响应式<br>2.直接通过下标arr[1] = ‘xxx’更改元素或数组长度，界面不会自动更新。</p><p>以上问题vue3不会出现。</p><p>vue2的响应式的核心是通过defineProperty对对象已有的属性值的读取和修改进行劫持</p><p>vue3的核心：<br>通过Proxy代理：拦截对象本身的操作，如属性的添加、删除，值的读写。。<br>通过Reflect反射：动态对代理对象的属性进行相应的操作</p><h3 id="setup-的参数"><a href="#setup-的参数" class="headerlink" title="setup()的参数"></a>setup()的参数</h3><p>setup 函数的第一个参数是组件的 props。和标准的组件一致，一个 setup 函数的 props 是响应式的，并且会在传入新的 props 时同步更新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: <span class="built_in">String</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(props.title)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：如果你解构了 props 对象，解构出的变量将会丢失响应性。因此我们推荐通过 props.xxx 的形式来使用其中的 props</p><p>如果你确实需要解构 props 对象，或者需要将某个 prop 传到一个外部函数中并保持响应性，那么你可以使用 toRefs() 和 toRef() 这两个工具函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 将 `props` 转为一个其中全是 ref 的对象，然后解构</span></span><br><span class="line">  <span class="keyword">const</span> &#123; title &#125; = toRefs(props)</span><br><span class="line">  <span class="comment">// `title` 是一个追踪着 `props.title` 的 ref</span></span><br><span class="line">  <span class="built_in">console</span>.log(title.value)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 或者，将 `props` 的单个属性转为一个 ref</span></span><br><span class="line">  <span class="keyword">const</span> title = toRef(props, <span class="string">&#x27;title&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入 setup 函数的第二个参数是一个 Setup 上下文对象。上下文对象暴露了其他一些在 setup 中可能会用到的值:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params">props, context</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 透传 Attributes（非响应式的对象，等价于 $attrs）</span></span><br><span class="line">  <span class="built_in">console</span>.log(context.attrs)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插槽（非响应式的对象，等价于 $slots）</span></span><br><span class="line">  <span class="built_in">console</span>.log(context.slots)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 触发事件（函数，等价于 $emit）</span></span><br><span class="line">  <span class="built_in">console</span>.log(context.emit)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 暴露公共属性（函数）</span></span><br><span class="line">  <span class="built_in">console</span>.log(context.expose)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">setup</span>(<span class="params">props, &#123; attrs, slots, emit, expose &#125;</span>)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>attrs 和 slots 都是有状态的对象，它们总是会随着组件自身的更新而更新。这意味着你应当避免解构它们，并始终通过 attrs.x 或 slots.x 的形式使用其中的属性。此外还需注意，和 props 不同，attrs 和 slots 的属性都不是响应式的。如果你想要基于 attrs 或 slots 的改变来执行副作用，那么你应该在 onBeforeUpdate 生命周期钩子中编写相关逻辑。</p><p>暴露公共属性:expose 函数用于显式地限制该组件暴露出的属性，当父组件通过模板引用访问该组件的实例时，将仅能访问 expose 函数暴露出的内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params">props, &#123; expose &#125;</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 让组件实例处于 “关闭状态”</span></span><br><span class="line">  <span class="comment">// 即不向父组件暴露任何东西</span></span><br><span class="line">  expose()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> publicCount = ref(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> privateCount = ref(<span class="number">0</span>)</span><br><span class="line">  <span class="comment">// 有选择地暴露局部状态</span></span><br><span class="line">  expose(&#123; <span class="attr">count</span>: publicCount &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="computed"><a href="#computed" class="headerlink" title="computed()"></a>computed()</h3><p>接受一个 getter 函数，返回一个只读的响应式 ref 对象。<br>该 ref 通过 .value 暴露 getter 函数的返回值。<br>它也可以接受一个带有 get 和 set 函数的对象来创建一个可写的 ref 对象。</p><p>创建一个只读的计算属性 ref：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = ref(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> plusOne = computed(<span class="function">() =&gt;</span> count.value + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(plusOne.value) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">plusOne.value++ <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>创建一个可写的计算属性 ref：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-input v-model&#x3D;&quot;firstname&quot; placeholder&#x3D;&quot;firstname&quot;&gt;&lt;&#x2F;el-input&gt;&lt;br&gt;</span><br><span class="line">  &lt;el-input v-model&#x3D;&quot;secondname&quot; placeholder&#x3D;&quot;secondname&quot;&gt;&lt;&#x2F;el-input&gt;&lt;br&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; fullname &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;el-button @click&#x3D;&quot;handleUpdate&quot;&gt;update&lt;&#x2F;el-button&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">setup() &#123;</span><br><span class="line">  const user &#x3D; reactive(&#123;</span><br><span class="line">    firstname: &#39;john&#39;,</span><br><span class="line">    secondname: &#39;lucy&#39;</span><br><span class="line">  &#125;)</span><br><span class="line">  const fullname &#x3D; computed(&#123;</span><br><span class="line">    get: () &#x3D;&gt; user.firstname + &#39;-&#39; + user.secondname,</span><br><span class="line">    set: (val) &#x3D;&gt; &#123;</span><br><span class="line">    [user.firstname, user.secondname] &#x3D; val.split(&#39;-&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  const handleUpdate &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    fullname.value &#x3D; &#39;jay-young&#39;</span><br><span class="line">  &#125;</span><br><span class="line">  return &#123;</span><br><span class="line">    ...toRefs(user),</span><br><span class="line">    fullname,</span><br><span class="line">    handleUpdate</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="watch"><a href="#watch" class="headerlink" title="watch()"></a>watch()</h3><p>侦听一个或多个响应式数据源，并在数据源变化时调用所给的回调函数。</p><p>watch() 默认是懒侦听的，即仅在侦听源发生变化时才执行回调函数。</p><p>第一个参数是侦听器的源.<br>第二个参数是在发生变化时要调用的回调函数<br>第三个可选的参数是一个对象，支持以下这些选项：immediate/deep/flush/(onTrack / onTrigger)</p><p>侦听一个 getter 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听响应式对象时需要使用函数</span></span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line">watch(</span><br><span class="line">  () =&gt; state.count,</span><br><span class="line">  (count, prevCount) =&gt; &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 当直接侦听一个响应式对象时，侦听器会自动启用深层模式：</span></span><br><span class="line">watch(state, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* 深层级变更状态所触发的回调 */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>侦听一个 ref：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line">watch(count, <span class="function">(<span class="params">count, prevCount</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当侦听多个来源时，回调函数接受两个数组，分别对应来源数组中的新值和旧值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch([fooRef, barRef], <span class="function">(<span class="params">[foo, bar], [prevFoo, prevBar]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect()"></a>watchEffect()</h3><p>立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。</p><p>不需要侦听器的源，只要其依赖改变就更新，immediate值默认为true</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fullname = ref(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">watchEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  fullname.value = user.firstname + <span class="string">&#x27;-&#x27;</span> + user.secondname</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h3><p>onBeforeMount(): 注册一个钩子，在组件被挂载之前被调用。<br>onMounted(): 注册一个回调函数，在组件挂载完成后执行。</p><p>onBeforeUpdate()​: 注册一个钩子，在组件即将因为响应式状态变更而更新其 DOM 树之前调用.<br>onUpdated(): 注册一个回调函数，在组件因为响应式状态变更而更新其 DOM 树之后调用。</p><p>onBeforeUnmount()​: 注册一个钩子，在组件实例被卸载之前调用。<br>onUnmounted(): 注册一个回调函数，在组件实例被卸载之后调用。</p><p>onActivated()​: 注册一个回调函数，若组件实例是 <code>&lt;KeepAlive&gt;</code> 缓存树的一部分，当组件被插入到 DOM 中时调用。<br>onDeactivated()​: 注册一个回调函数，若组件实例是 <code>&lt;KeepAlive&gt;</code> 缓存树的一部分，当组件从 DOM 中被移除时调用</p><p>onErrorCaptured()​: 注册一个钩子，在捕获了后代组件传递的错误时调用。</p><p>vue2和vue3生命周期对比：</p><table><thead><tr><th>vue2生命周期</th><th>vue3生命周期</th></tr></thead><tbody><tr><td>beforeCreated</td><td>setup</td></tr><tr><td>created</td><td>setup</td></tr><tr><td>beforeMounted</td><td>onBeforeMount</td></tr><tr><td>mounted</td><td>onMounted</td></tr><tr><td>beforeUpdate</td><td>onBeforeUpdate</td></tr><tr><td>updated</td><td>onUpdated</td></tr><tr><td>beforeDestroy</td><td>onBeforeUnmount</td></tr><tr><td>destroyed</td><td>onUnmounted</td></tr><tr><td>activated</td><td>onActivated</td></tr><tr><td>deactivated</td><td>onDeactivated</td></tr></tbody></table><h3 id="ref获取元素"><a href="#ref获取元素" class="headerlink" title="ref获取元素"></a>ref获取元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-input v-model&#x3D;&quot;secondname&quot; ref&#x3D;&quot;inputRef&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">setup() &#123;</span><br><span class="line">  const inputRef &#x3D; ref&lt;HTMLElement | null&gt;(null)</span><br><span class="line">  &#x2F;&#x2F; 生命周期</span><br><span class="line">  onMounted() &#123;</span><br><span class="line">    inputRef.value &amp;&amp; inputRef.value.focus()</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 或者</span><br><span class="line">  nextTick(() &#x3D;&gt; &#123;</span><br><span class="line">    inputRef.value &amp;&amp; inputRef.value.focus()</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    inputRef</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;  </span><br></pre></td></tr></table></figure><h3 id="自定义hook函数"><a href="#自定义hook函数" class="headerlink" title="自定义hook函数"></a>自定义hook函数</h3><p>ref, computed, watch, reactive, onMounted等都是hook函数，不过是vue内置hook.</p><p>创建一个函数，必须用use开头<br>函数必须return一些数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&#123;&#123; x &#125;&#125; - &#123;&#123; y &#125;&#125;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function useMousePostion() &#123;</span><br><span class="line">  const x &#x3D; ref(-1)</span><br><span class="line">  const y &#x3D; ref(-1)</span><br><span class="line"></span><br><span class="line">  const updatePosition &#x3D; (e: MouseEvent) &#x3D;&gt; &#123;</span><br><span class="line">    x.value &#x3D; e.pageX</span><br><span class="line">    y.value &#x3D; e.pageY</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onMounted(() &#x3D;&gt; &#123;</span><br><span class="line">    document.addEventListener(&#39;click&#39;, updatePosition)</span><br><span class="line">  &#125;)</span><br><span class="line">  onUnmounted(() &#x3D;&gt;&#123;</span><br><span class="line">    document.removeEventListener(&#39;click&#39;, updatePosition)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    x, y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">setup() &#123;</span><br><span class="line">  const &#123; x, y &#125; &#x3D; useMousePostion()</span><br><span class="line">  return &#123;</span><br><span class="line">    x,</span><br><span class="line">    y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="shallowReactive-和shallowRef"><a href="#shallowReactive-和shallowRef" class="headerlink" title="shallowReactive()和shallowRef()"></a>shallowReactive()和shallowRef()</h3><p>shallowReactive： reactive() 的浅层作用形式。</p><p>和 reactive() 不同，这里没有深层级的转换：一个浅层响应式对象里只有根级别的属性是响应式的。属性的值会被原样存储和暴露，这也意味着值为 ref 的属性不会被自动解包了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = shallowReactive(&#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  nested: &#123;</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更改状态自身的属性是响应式的</span></span><br><span class="line">state.foo++</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...但下层嵌套对象不会被转为响应式</span></span><br><span class="line">isReactive(state.nested) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不是响应式的</span></span><br><span class="line">state.nested.bar++</span><br></pre></td></tr></table></figure><p>和shallowRef: ref() 的浅层作用形式。</p><p>和 ref() 不同，浅层 ref 的内部值将会原样存储和暴露，并且不会被深层递归地转为响应式。只有对 .value 的访问是响应式的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = shallowRef(&#123; <span class="attr">count</span>: <span class="number">1</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不会触发更改</span></span><br><span class="line">state.value.count = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 会触发更改</span></span><br><span class="line">state.value = &#123; <span class="attr">count</span>: <span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="toRaw-和markRaw"><a href="#toRaw-和markRaw" class="headerlink" title="toRaw()和markRaw()"></a>toRaw()和markRaw()</h3><p>toRaw(): 根据一个 Vue 创建的代理返回其原始对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> reactiveFoo = reactive(foo)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(toRaw(reactiveFoo) === foo) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>markRaw(): 将一个对象标记为不可被转为代理。返回该对象本身</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = markRaw(&#123;&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(isReactive(reactive(foo))) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也适用于嵌套在其他响应性对象</span></span><br><span class="line"><span class="keyword">const</span> bar = reactive(&#123; foo &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(isReactive(bar.foo)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="手动实现reactive"><a href="#手动实现reactive" class="headerlink" title="手动实现reactive"></a>手动实现reactive</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, prop</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;劫持get()&#x27;</span>, prop)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, prop, val</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;劫持set()&#x27;</span>, prop, val)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, prop, val)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">deleteProperty</span>(<span class="params">target, prop</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;劫持deleteProperty()&#x27;</span>, prop)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.deleteProperty(target, prop)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (target &amp;&amp; <span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.entries(target).forEach(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        target[key] = reactive(value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowReactive</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (target &amp;&amp; <span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: &#123;</span><br><span class="line">    d: <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">state.a <span class="comment">// 劫持get() a</span></span><br><span class="line">state.c.d <span class="comment">// 劫持get() c   劫持get() d</span></span><br><span class="line">state.c.d = <span class="number">33</span> <span class="comment">// 劫持get() c   劫持set() d 33</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shallowstate = shallowReactive(&#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: &#123;</span><br><span class="line">    d: <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">shallowstate.a <span class="comment">// 劫持get() a</span></span><br><span class="line">shallowstate.c.d <span class="comment">// 劫持get() c</span></span><br><span class="line">shallowstate.c.d = <span class="number">33</span> <span class="comment">// 劫持get() c</span></span><br></pre></td></tr></table></figure><h3 id="手动实现ref"><a href="#手动实现ref" class="headerlink" title="手动实现ref"></a>手动实现ref</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受一个内部值，返回一个响应式的、可更改的 ref 对象，此对象只有一个指向其内部值的属性 .value。</span></span><br><span class="line"><span class="comment">// 如果将一个对象赋值给 ref，那么这个对象将通过 reactive() 转为具有深层次响应式的对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ref</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (target &amp;&amp; <span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    target = ref(target)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    _value: target,</span><br><span class="line">    <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;获取get&#x27;</span>, <span class="built_in">this</span>._value)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>._value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> <span class="title">value</span>(<span class="params">val</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;设置set&#x27;</span>, val)</span><br><span class="line">      <span class="built_in">this</span>._value = val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 和 ref() 不同，浅层 ref 的内部值将会原样存储和暴露，并且不会被深层递归地转为响应式。只有对 .value 的访问是响应式的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowRef</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    _value: target,</span><br><span class="line">    <span class="keyword">get</span> <span class="title">value</span>() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;获取get&#x27;</span>, <span class="built_in">this</span>._value)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>._value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> <span class="title">value</span>(<span class="params">val</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;设置set&#x27;</span>, val)</span><br><span class="line">      <span class="built_in">this</span>._value = val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="新组件和API"><a href="#新组件和API" class="headerlink" title="新组件和API"></a>新组件和API</h2><p>1.Fragment片段</p><p>vue2: 必须有一个根标签<br>vue3: 组件可以没有根标签，多个组件包含在template中<br>好处： 减少标签层级，减少内存占用</p><p>2.Teleport瞬移</p><p>让组件的html可以在父界面外的组件任一标签处插入</p><p>3.Suspense异步组件</p><h3 id="1-新的全局API"><a href="#1-新的全局API" class="headerlink" title="1.新的全局API"></a>1.新的全局API</h3><ul><li>createApp()</li><li>app.mount()</li><li>app.provide()</li><li>app.component()</li><li>app.directive()</li><li>app.use()</li><li>app.mixin()</li><li>app.version</li><li>app.config</li></ul><h3 id="v-model的变化"><a href="#v-model的变化" class="headerlink" title="v-model的变化"></a>v-model的变化</h3><p>在表单上使用没有变化。<br>在组件上使用的时候，默认的属性名和事件变化, sync修饰符移除，使用v-model</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// modelValue</span></span><br><span class="line">&lt;Child v-model=<span class="string">&quot;msg&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Child.vue</span></span><br><span class="line">props: [<span class="string">&#x27;modelValue&#x27;</span>] <span class="comment">// value =&gt; modelValue</span></span><br><span class="line">emit(<span class="string">&quot;update: modelValue&quot;</span>, <span class="string">&#x27;111&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// name</span></span><br><span class="line">&lt;Child v-model:name=<span class="string">&quot;msg&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Child.vue</span></span><br><span class="line">props: [<span class="string">&#x27;name&#x27;</span>] <span class="comment">// value =&gt; modelValue</span></span><br><span class="line">emit(<span class="string">&quot;update: name&quot;</span>, <span class="string">&#x27;111&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="v-if-与-v-for-一起使用-v-if优先级更高（vue2版本v-for优先级高）"><a href="#v-if-与-v-for-一起使用-v-if优先级更高（vue2版本v-for优先级高）" class="headerlink" title="v-if 与 v-for 一起使用,v-if优先级更高（vue2版本v-for优先级高）"></a>v-if 与 v-for 一起使用,v-if优先级更高（vue2版本v-for优先级高）</h3>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5存储方式</title>
      <link href="/ZJY.github.io/2022/10/28/HTML5%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/"/>
      <url>/ZJY.github.io/2022/10/28/HTML5%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>html5存储方式</p><ol><li>cookie</li><li>localStorage</li><li>sessionStorage</li><li>离线缓存application cache</li><li>Service Workers</li><li>Web SQL</li><li>IndexedDB</li></ol><h2 id="1-cookie"><a href="#1-cookie" class="headerlink" title="1.cookie"></a>1.cookie</h2><p>存储在用户客户端<br>cookie是一段不超过4KB的小型文本数据，由一个名称name,一个值value和其他几个用于控制cookie有效期、安全性、使用范围的可选属性组成。其中：</p><ul><li>Name/Value:设置Cookie的名称及相对应的值</li><li>Expires属性：设置Cookie的生存期。有两种存储类型的Cookie：会话性与持久性。Expires属性缺省时，为会话性Cookie，仅保存在客户端内存中，并在用户关闭浏览器时失效；持久性Cookie会保存在用户的硬盘中，直至生存期到或用户直接在网页中单击“注销”等按钮结束会话时才会失效。</li><li>Path属性：定义了Web站点上可以访问该Cookie的目录</li><li>Domain属性：指定了可以访问该 Cookie 的 Web 站点或域</li><li>Secure属性：指定是否使用HTTPS安全协议发送Cookie</li><li>HTTPOnly 属性 ：用于防止客户端脚本通过document.cookie属性访问Cookie</li></ul><h2 id="2-本地存储localStorage"><a href="#2-本地存储localStorage" class="headerlink" title="2.本地存储localStorage"></a>2.本地存储localStorage</h2><p>以键值对（key-value）的方式存储，存储的数据已字符串形式存在，永久存储，永不失效，除非手动删除。<br>每个域名5M。<br>常用API：getItem,setItem,removeItem,key,clear<br>localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份localStorage数据。</p><h2 id="3-本地存储sessionStorage"><a href="#3-本地存储sessionStorage" class="headerlink" title="3.本地存储sessionStorage"></a>3.本地存储sessionStorage</h2><p>协议，域名，端口和窗口<br>session，只要关闭浏览器（也包括浏览器的标签页），就会被清空</p><h2 id="4-离线缓存（application-cache）"><a href="#4-离线缓存（application-cache）" class="headerlink" title="4.离线缓存（application cache）"></a>4.离线缓存（application cache）</h2><p>本地缓存应用所需的文件</p><p>1.配置manifest文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">&quot;demo.appcache&quot;</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要在web服务器配置正确的 MIME-type，即 “text/cache-manifest”。</p><p>2.manifest文件</p><ul><li>CACHE MANIFEST：此标题下列出的文件将在首次下载后进行缓存。</li><li>NETWORK：不会被缓存，需要下载，若和CACHE文件有冲突则以CACHE为主</li><li>FALLBACK：无法被访问时的回退页面如404</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">&#x2F;buju.css</span><br><span class="line"></span><br><span class="line">NETWORK:</span><br><span class="line">&#x2F;source&#x2F;images</span><br><span class="line"></span><br><span class="line">FALLBACK:</span><br><span class="line">base64.html</span><br></pre></td></tr></table></figure><p>优势：离线浏览、加快页面加载速度、减少服务器负载</p><p>注意事项：<br>每个站点离线存储容量限制5M<br>manifest文件中缓存的文件如果有一个不能下载整个更新过程失败，浏览器继续使用老的缓存。<br>使用manifest文件的html必须和manifest文件同源<br>FALLBACK中的资源必须和manifest文件同源<br>在manifest中使用的相对路径,相对参照物为manifest文件<br>站点中的其他页面即使没有设置manifest属性，请求的资源如果在缓存中也从缓存中访问<br>当manifest文件发生改变时，资源请求本身也会触发更新</p><p>3.浏览器是怎么对离线资源进行管理和加载？<br>在线情况下，浏览器碰到manifest配置，就去请求manifest文件，如果是第一次访问app，就根据manifest文件去下载要离线缓存的资源，并存储。如果已经访问过app并且离线资源已经存储，就使用离线资源，再比对manifest文件有没有改动，如果有重新下载资源并存储。<br>离线情况下，浏览器就直接使用离线存储的资源。</p><h2 id="5-Service-Workers离线存储"><a href="#5-Service-Workers离线存储" class="headerlink" title="5.Service Workers离线存储"></a>5.Service Workers离线存储</h2><p>1.使用前设置<br>在支持Service Workers的浏览器中很多特性没有默认开启，需要开启浏览器的相关配置。</p><ul><li>Firefox Nightly: 访问 about:config 并设置 dom.serviceWorkers.enabled 的值为 true; 重启浏览器；</li><li>Chrome Canary: 访问 chrome://flags 并开启 experimental-web-platform-features; 重启浏览器 (注意：有些特性在 Chrome 中没有默认开放支持)；</li><li>Opera: 访问 opera://flags 并开启 ServiceWorker 的支持; 重启浏览器。</li></ul><p>出于安全原因，Service Workers 要求必须在 HTTPS 下才能运行。为了便于本地开发，localhost 也被浏览器认为是安全源。</p><p>2.使用<br>1）注册</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;serviceWorker&#x27;</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">  navigator.serviceWorker.register(</span><br><span class="line">    <span class="string">&#x27;/servicework.js&#x27;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      scope: <span class="string">&#x27;/&#x27;</span> <span class="comment">// 参数是选填的，可以被用来指定你想让 service worker 控制的内容的子目录</span></span><br><span class="line">    &#125;</span><br><span class="line">  ).then(<span class="function"><span class="keyword">function</span>(<span class="params">reg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Registration succeeded. Scope is &#x27;</span> + reg.scope);</span><br><span class="line">  &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Registration failed with &#x27;</span> + error);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service worker 只能抓取在 service worker scope 里从客户端发出的请求。</p><p>2)安装和激活：填充你的缓存</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.addEventListener(<span class="string">&#x27;install&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(<span class="string">&#x27;v1&#x27;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cache.addAll([</span><br><span class="line">        <span class="string">&#x27;/buju.css&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;buju.html&#x27;</span></span><br><span class="line">      ])</span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;创建缓存失败&#x27;</span>, error)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意：localStorage跟service worker的cache工作原理类似，但是他是同步的，所以不能在sw内使用，IndexedDB可以在service worker内做数据存储</p><p>3)自定义请求的响应<br>每次任何被Service Worker控制的资源被请求到时，都会触发fetch事件，这些资源包括指定scope内的文档，和这些文档内引用的任何资源。<br>在service worker上添加一个fetch事件监听器，接着调用respondWidth方法来劫持我们的http响应，然后自己处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.addEventListener(<span class="string">&#x27;fetch&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 如果没有在缓存中找到匹配的资源，你可以告诉浏览器对着资源直接去 fetch 默认的网络请求</span></span><br><span class="line">      <span class="keyword">return</span> response || fetch(event.request).then(<span class="function"><span class="keyword">function</span> (<span class="params">resp</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> caches.open(<span class="string">&#x27;v1&#x27;</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">cache</span>) </span>&#123;</span><br><span class="line">          cache.put(event.request, resp.clone())</span><br><span class="line">          <span class="keyword">return</span> resp</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">// 这里我们用 fetch(event.request) 返回了默认的网络请求，它返回了一个 promise。</span></span><br><span class="line">      <span class="comment">// 当网络请求的 promise 成功的时候，我们 通过执行一个函数用 caches.open(&#x27;v1&#x27;) 来抓取我们</span></span><br><span class="line">      <span class="comment">// 的缓存，它也返回了一个 promise。当这个 promise 成功的时候， cache.put() 被用来把这些</span></span><br><span class="line">      <span class="comment">// 资源加入缓存中。资源是从 event.request 抓取的，它的响应会被 response.clone() 克隆一份</span></span><br><span class="line">      <span class="comment">// 然后被加入缓存。这个克隆被放到缓存中，它的原始响应则会返回给浏览器来给调用它的页面。</span></span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> caches.match(<span class="string">&#x27;/fallback.html&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 当请求没有匹配到请求的资源网络也不可用时，请求会失败，提供一个回退方案</span></span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>caches.match(event.request) 允许我们对网络请求的资源和 cache 里可获取的资源进行匹配，查看是否缓存中有相应的资源</p><p>4)更新你的service worker<br>如果你的sw已被安装，但是刷新页面的时候发现一个新的版本可用，新版的sw会在后台安装，但是没被激活，当不再有任何已加载的页面在使用旧版的 service worker 的时候，新版本才会激活。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">&#x27;install&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(<span class="string">&#x27;v2&#x27;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cache.addAll([</span><br><span class="line">        <span class="string">&#x27;/buju.css&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;buju.html&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;responsive.html&#x27;</span></span><br><span class="line">      ])</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除旧缓存</span></span><br><span class="line">self.addEventListener(<span class="string">&#x27;activate&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cacheWhitelist = [<span class="string">&#x27;v2&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.keys().then(<span class="function"><span class="keyword">function</span>(<span class="params">keyList</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.all(keyList.map(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheWhitelist.indexOf(key) === -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> caches.delete(key);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;))</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="6-Web-SQL"><a href="#6-Web-SQL" class="headerlink" title="6.Web SQL"></a>6.Web SQL</h2><p>Web SQL数据库API并不是HTML5规范的一部分，但它是一个独立的规范，引入了一组使用SQL操作客户端数据库的APIs。<br>但由于兼容性和性能问题，Web SQL已经被IndexedDB所取代。</p><p>核心方法</p><ul><li>openDatabase：使用现有的数据库或新建的数据库创建一个数据库对象</li><li>transaction： 控制一个事务，以及基于这种情况执行提交或回滚</li><li>executeSql：用于执行实际的SQL查询</li></ul><p>1.打开数据库</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db = openDatabase(<span class="string">&#x27;mydb&#x27;</span>, <span class="string">&#x27;1.0&#x27;</span>, <span class="string">&#x27;TEST DB&#x27;</span>, <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>, fn);</span><br></pre></td></tr></table></figure><p>2.执行查询操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db = openDatabase(<span class="string">&#x27;mydb&#x27;</span>, <span class="string">&#x27;1.0&#x27;</span>, <span class="string">&#x27;TEST DB&#x27;</span>, <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">db.transaction(<span class="function"><span class="keyword">function</span> (<span class="params">tx</span>) </span>&#123;</span><br><span class="line">    tx.executeSql(<span class="string">&#x27;CREATE TABLE IF NOT EXISTS WIN (id unique, name)&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3.插入数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db = openDatabase(<span class="string">&#x27;mydb&#x27;</span>, <span class="string">&#x27;1.0&#x27;</span>, <span class="string">&#x27;Test DB&#x27;</span>, <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">db.transaction(<span class="function"><span class="keyword">function</span> (<span class="params">tx</span>) </span>&#123;</span><br><span class="line">   tx.executeSql(<span class="string">&#x27;CREATE TABLE IF NOT EXISTS WIN (id unique, name)&#x27;</span>);</span><br><span class="line">   tx.executeSql(<span class="string">&#x27;INSERT INTO WIN (id, name) VALUES (1, &quot;winty&quot;)&#x27;</span>);</span><br><span class="line">   tx.executeSql(<span class="string">&#x27;INSERT INTO WIN (id, name) VALUES (2, &quot;LuckyWinty&quot;)&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>4.读取数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">db.transaction(<span class="function"><span class="keyword">function</span> (<span class="params">tx</span>) </span>&#123;</span><br><span class="line">   tx.executeSql(<span class="string">&#x27;SELECT * FROM WIN&#x27;</span>, [], <span class="function"><span class="keyword">function</span> (<span class="params">tx, results</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> len = results.rows.length, i;</span><br><span class="line">      msg = <span class="string">&quot;&lt;p&gt;查询记录条数: &quot;</span> + len + <span class="string">&quot;&lt;/p&gt;&quot;</span>;</span><br><span class="line">      <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#status&#x27;</span>).innerHTML +=  msg;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">         alert(results.rows.item(i).name );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;, <span class="literal">null</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="/ZJY.github.io/images/websql.jpg" alt="image"></p><h2 id="7-indexedDB"><a href="#7-indexedDB" class="headerlink" title="7.indexedDB"></a>7.indexedDB</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dbName = <span class="string">&#x27;helloIndexedDB&#x27;</span>, version = <span class="number">1</span>, storeName = <span class="string">&#x27;helloStore&#x27;</span></span><br><span class="line"><span class="keyword">let</span> indexedDB = <span class="built_in">window</span>.indexedDB</span><br><span class="line"><span class="keyword">let</span> db</span><br><span class="line"><span class="keyword">const</span> request = indexedDB.open(dbName, version)</span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  db = event.target.result <span class="comment">// 数据库对象</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;数据库打开成功&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">request.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;数据库打开报错&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数据库创建或升级时触发</span></span><br><span class="line">request.onupgradeneeded = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onupgradeneeded&#x27;</span>)</span><br><span class="line">  db = event.target.result <span class="comment">// 数据库对象</span></span><br><span class="line">  <span class="keyword">let</span> objStore</span><br><span class="line">  <span class="keyword">if</span> (!db.objectStoreNames.contains(storeName)) &#123;</span><br><span class="line">    objStore = db.createObjectStore(storeName, &#123;<span class="attr">keyPath</span>: <span class="string">&#x27;id&#x27;</span>&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 添加数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addData</span>(<span class="params">db, storeName, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> request = db.transaction([storeName], <span class="string">&#x27;readwrite&#x27;</span>)</span><br><span class="line">    .objectStore(storeName) <span class="comment">// 仓库对象</span></span><br><span class="line">    .add(data)</span><br><span class="line">  request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;数据写入成功&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  request.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;数据写入失败&#x27;</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(event.target.error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据id获取数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDataBykey</span>(<span class="params">db, storeName, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> req = db.transaction([storeName]).objectStore(storeName).get(key)</span><br><span class="line">  req.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;查询结果&#x27;</span>, req.result)</span><br><span class="line">  &#125;</span><br><span class="line">  req.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;查询失败&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据id修改数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateDB</span>(<span class="params">db, storeName, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> req = db.transaction([storeName], <span class="string">&#x27;readwrite&#x27;</span>)</span><br><span class="line">    .objectStore(storeName)</span><br><span class="line">    .put(data)</span><br><span class="line">  req.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;数据更新成功&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  req.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;数据更新失败&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据id删除数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteBD</span>(<span class="params">db, storeName, id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> req = db.transaction([storeName], <span class="string">&#x27;readwrite&#x27;</span>)</span><br><span class="line">    .objectStore(storeName)</span><br><span class="line">    .delete(id)</span><br><span class="line">  req.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;数据删除成功&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  req.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;数据删除失败&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于打开indexDB是异步的加个定时器避免 db对象还没获取到值导致 报错</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  addData(db, storeName, &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    name: <span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    desc: <span class="string">&#x27;a girl&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  getDataBykey(db, storeName, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  updateDB(db, storeName, &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">desc</span>: <span class="string">&#x27;a boy&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// deleteBD(db, storeName, 1)</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>indexDB兼容性存在一定的问题，异步获取数据，根据浏览器规则存储在50-250M，并且用户清除浏览器缓存时不会将其清除。<br>在使用时切记只有当修改新增数据库表单时才需要增加版本号，如果只是修改数据库表单里面的数据是不需要改变版本号的。</p><p>封装类库</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">openDB</span>(<span class="params">dbName, storeName, version = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> indexedDB = <span class="built_in">window</span>.indexedDB</span><br><span class="line">    <span class="keyword">let</span> db</span><br><span class="line">    <span class="keyword">const</span> request = indexedDB.open(dbName, version)</span><br><span class="line">    request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">      db = event.target.result <span class="comment">// 数据库对象</span></span><br><span class="line">      resolve(db)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    request.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">      reject(event)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    request.onupgradeneeded = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 数据库创建或升级的时候会触发</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;onupgradeneeded&#x27;</span>)</span><br><span class="line">      db = event.target.result <span class="comment">// 数据库对象</span></span><br><span class="line">      <span class="keyword">let</span> objectStore</span><br><span class="line">      <span class="keyword">if</span> (!db.objectStoreNames.contains(storeName)) &#123;</span><br><span class="line">        objectStore = db.createObjectStore(storeName, &#123; <span class="attr">keyPath</span>: <span class="string">&#x27;id&#x27;</span> &#125;) <span class="comment">// 创建表</span></span><br><span class="line">        <span class="comment">// objectStore.createIndex(&#x27;name&#x27;, &#x27;name&#x27;, &#123; unique: true &#125;) // 创建索引 可以让你搜索任意字段</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 新增数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addData</span>(<span class="params">db, storeName, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> request = db.transaction([storeName], <span class="string">&#x27;readwrite&#x27;</span>) <span class="comment">// 事务对象 指定表格名称和操作模式（&quot;只读&quot;或&quot;读写&quot;）</span></span><br><span class="line">      .objectStore(storeName) <span class="comment">// 仓库对象</span></span><br><span class="line">      .add(data)</span><br><span class="line"> </span><br><span class="line">    request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">      resolve(event)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    request.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(event.target.error)</span><br><span class="line">      reject(event)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  openDB,</span><br><span class="line">  addData,</span><br><span class="line">  getDataByKey,</span><br><span class="line">  cursorGetData,</span><br><span class="line">  getDataByIndex,</span><br><span class="line">  cursorGetDataByIndex,</span><br><span class="line">  updateDB,</span><br><span class="line">  deleteDB,</span><br><span class="line">  deleteDBAll,</span><br><span class="line">  closeDB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">import</span> IndexDB <span class="keyword">from</span> <span class="string">&#x27;./IndexDB.js&#x27;</span></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dbName = <span class="string">&#x27;myDB&#x27;</span>, storeName = <span class="string">&#x27;db_1&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> db = <span class="keyword">await</span> IndexDB.openDB(dbName, storeName, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">var</span> data = <span class="keyword">await</span> IndexDB.addData(db, storeName, &#123;</span><br><span class="line">    id: <span class="number">111</span>, <span class="comment">// 必须且值唯一</span></span><br><span class="line">    name: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    age: <span class="number">18</span>,</span><br><span class="line">    desc: <span class="string">&#x27;helloWord&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/ZJY.github.io/images/indexedDB.jpg" alt="image"></p><h3 id="浏览器常用存储方式有哪些？"><a href="#浏览器常用存储方式有哪些？" class="headerlink" title="浏览器常用存储方式有哪些？"></a>浏览器常用存储方式有哪些？</h3><ul><li>cookie：本身用于浏览器和server通讯，由服务器发送给浏览器存储，并且每次浏览器向同一服务器发送请求时，都会携带这些Cookies。本身存储大小有限（通常为4KB），并且可以设置过期时间。通常用来存储用户登录信息，个性化设置等。</li><li>localStorage：用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。以key-value的形式存储，存储数据以字符串形式存在，大小通常为5M或更大。适用于存储大量持久数据。</li><li>sessionStorage：用于本地存储，数据在当前浏览器窗口或标签关闭后自动删除。适用于存储临时数据只在当前会话中保存。</li><li>IndexedDB：IndexedDB 是一个事务型数据库，用于在客户端存储大量结构化数据。</li><li>Web SQL：一种使用 SQL 的数据库，用于在浏览器中存储数据。</li></ul><h3 id="浏览器cookie和sessionStorage-localStorage的区别"><a href="#浏览器cookie和sessionStorage-localStorage的区别" class="headerlink" title="浏览器cookie和sessionStorage/localStorage的区别"></a>浏览器cookie和sessionStorage/localStorage的区别</h3><ul><li>存储大小：cookie数据大小不能超过4K。sessionStorage和localStorage可以达到5M或更大。</li><li>有效时间：localStorage存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除。cookie设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。</li><li>存储位置：cookie数据存储在浏览器中；sessionStorage和localStorage数据存储在浏览器内存中；如果浏览器配置为默认不保存数据，那么数据将会丢失。</li><li>数据共享：cookie、session和localStorage都遵循同源原则进行数据共享。cookie和localStorage在所有同源窗口中都是共享的；sessionStorage在不同的浏览器窗口中不共享。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于husky+lint-staged代码规范</title>
      <link href="/ZJY.github.io/2022/09/29/%E5%85%B3%E4%BA%8Ehusky-lint-staged%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
      <url>/ZJY.github.io/2022/09/29/%E5%85%B3%E4%BA%8Ehusky-lint-staged%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h2 id="一-husky"><a href="#一-husky" class="headerlink" title="一.husky"></a>一.husky</h2><p>文档：<a href="https://typicode.github.io/husky/#/?id=install">https://typicode.github.io/husky/#/?id=install</a></p><h3 id="1-安装配置"><a href="#1-安装配置" class="headerlink" title="1.安装配置"></a>1.安装配置</h3><p>安装老版本husky4.x:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install husky@4.3.8 lint-staged --dev</span><br></pre></td></tr></table></figure><p>配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;husky&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;hooks&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;pre-commit&quot;</span>: <span class="string">&quot;lint-staged&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;lint-staged&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;*.js&quot;</span>: <span class="string">&quot;yarn lint&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>git commit时触发pre-commit钩子，运行lint-staged命令，对*.js执行eslint命令。lint要在scripts提前配置好</p><p>husky新版本</p><p>1.安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install husky --save-dev</span><br></pre></td></tr></table></figure><p>2.使git hooks生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx husky install</span><br></pre></td></tr></table></figure><p>3.在安装后自动启用 git hooks</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm set-script prepare &quot;husky install&quot;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;prepare&quot;</span>: <span class="string">&quot;husky install&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以手动添加prepare<br>若是使用yarn 安装则需要将prepare换成postinstall， 见husky文档</p><p>4.创建一个precommit hook</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx husky add .husky/pre-commit &quot;npm run lint&quot; </span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行完之后在 .husky 目录下会多一个 pre-commit 的文件，里面的 npm run lint 就是这个 hook 要执行的命令，后续要改也可以直接改这个文件。</span></span><br><span class="line">git add .husky/pre-commit</span><br></pre></td></tr></table></figure><p>提交代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;feat(husky): test&quot;</span><br></pre></td></tr></table></figure><p>如果npm run lint失败会自动停掉代码提交并给出错误提示信息<br>lint的是全部文件，校验很慢，如果需要校验暂存文件，需要使用lint-staged</p><h2 id="二-lint-staged"><a href="#二-lint-staged" class="headerlink" title="二.lint-staged"></a>二.lint-staged</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install lint-staged --save-dev</span><br></pre></td></tr></table></figure><h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;lint-staged&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;*.&#123;js,vue&#125;&quot;</span>: <span class="string">&quot;npm run lint&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-设置precommit运行为lint-staged"><a href="#3-设置precommit运行为lint-staged" class="headerlink" title="3.设置precommit运行为lint-staged"></a>3.设置precommit运行为lint-staged</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx husky add .husky/pre-commit &quot;npx lint-staged&quot;</span><br></pre></td></tr></table></figure><p>或者手动修改.husky/pre-commit</p><h2 id="三-uninstall-husky"><a href="#三-uninstall-husky" class="headerlink" title="三.uninstall husky"></a>三.uninstall husky</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall husky &amp;&amp; git config --unset core.hooksPath</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 问题&amp;总结 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript入门实战书籍笔记</title>
      <link href="/ZJY.github.io/2022/09/15/typescript%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0/"/>
      <url>/ZJY.github.io/2022/09/15/typescript%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>TypeScript是一门专为开发大规模JavaScript应用程序而设计的编程语言，是JavaScript的超集，包含了JavaScript现有的全部功能，并且使用了与JavaScript相同的语法和语义。</p><p>TypeScript代码不能直接运行，它需要先被编译成JavaScript代码然后才能运行。Type-Script编译器（tsc）将负责把TypeScript代码编译为JavaScript代码</p><h2 id="第一章-TypeScript语言基础"><a href="#第一章-TypeScript语言基础" class="headerlink" title="第一章 TypeScript语言基础"></a>第一章 TypeScript语言基础</h2><h3 id="1-1-变量"><a href="#1-1-变量" class="headerlink" title="1.1 变量"></a>1.1 变量</h3><p>可以用变量来存储和操作数据。当我们操作变量时，实际上操作的是变量对应的存储地址中的数据。</p><p>变量名也叫标识符，定义规则：</p><ol><li>允许包含字母、下划线、数字和美元符号”$”</li><li>允许包含unicode转义序列，如”\u0069\u{6F}”</li><li>仅允许使用字母、unicdoe转义序列，下划线，美元符号”$”作为第一个字符</li><li>标识符区分大小写</li><li>不允许使用保留字作为标识符</li></ol><p>变量声明：var, let, const   let和const声明变量具有块级作用域<br>块级作用域的概念包含了两部分，即块和作用域。变量的作用域指的是该变量的可访问区域，一个变量只能在其所处的作用域内被访问，在作用域外是不可见的。块级作用域中的块指的是“块语句”。块语句用于将零条或多条语句组织在一起。在语法上，块语句使用一对大括号“{}”来表示</p><h3 id="1-2-注释"><a href="#1-2-注释" class="headerlink" title="1.2 注释"></a>1.2 注释</h3><p>TypeScript支持三种类型的注释：</p><ol><li>单行注释</li><li>多行注释</li><li>区域注释</li></ol><p>单行注释：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// single line comment</span></span><br></pre></td></tr></table></figure><p>多行注释:</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * multi-line comment</span></span><br><span class="line"><span class="comment"> * multi-line comment</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>区域注释：区域注释不是一种新的注释语法，它借助单行注释的语法实现了定义代码折叠区域的功能</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span> <span class="comment">//#region 区域描述</span></span><br><span class="line"><span class="number">02</span> </span><br><span class="line"><span class="number">03</span> <span class="keyword">let</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="number">04</span> </span><br><span class="line"><span class="number">05</span> <span class="comment">//#endregion</span></span><br></pre></td></tr></table></figure><h3 id="1-3-数据类型"><a href="#1-3-数据类型" class="headerlink" title="1.3 数据类型"></a>1.3 数据类型</h3><p>在ECMAScript 2015规范中定义了如下七种数据类型：</p><ol><li>Undefined</li><li>Null</li><li>Boolean</li><li>Number</li><li>String</li><li>Symbol</li><li>Object</li></ol><p>其中，Undefined、Null、Boolean、String、Symbol和Number类型是原始数据类型，Object类型是非原始数据类型。原始数据类型是编程语言内置的基础数据类型，可用于构造复合类型。</p><h4 id="1-3-1-Undefined"><a href="#1-3-1-Undefined" class="headerlink" title="1.3.1 Undefined"></a>1.3.1 Undefined</h4><p>Undefined类型只包含一个值，即undefined。在变量未被初始化时，它的值为undefined。</p><h4 id="1-3-2-Null"><a href="#1-3-2-Null" class="headerlink" title="1.3.2 Null"></a>1.3.2 Null</h4><p>Null类型也只包含一个值，即null。我们通常使用null值来表示未初始化的对象。此外，null值也常被用在JSON文件中，表示一个值不存在。</p><h4 id="1-3-3-Boolean"><a href="#1-3-3-Boolean" class="headerlink" title="1.3.3 Boolean"></a>1.3.3 Boolean</h4><p>Boolean类型包含两个逻辑值，分别是true和false。</p><h4 id="1-3-4-String"><a href="#1-3-4-String" class="headerlink" title="1.3.4 String"></a>1.3.4 String</h4><p>String类型表示文本字符串，它由0个或多个字符构成.<br>Javascript使用utf-16编码来表示一个字符。utf-16编码以2个字节表示一个编码单元，每个字符使用一个编码单元或者两个编码单元来表示。在底层存储中，字符串是由零个或多个16位无符号整数构成的有序序列。<br>ECMAScript 2015规定了字符串允许的最大长度为2的53次方-1，该数值也是JavaScript所能安全表示的最大整数。</p><h4 id="1-3-5-Number"><a href="#1-3-5-Number" class="headerlink" title="1.3.5 Number"></a>1.3.5 Number</h4><p>Javascript不详细区分整数、浮点数以及带符号的数字类型。使用双精度的64位浮点数字格式（IEEE 754）来表示数字，因此数字本质上都是浮点数。在该格式中，符号占1位（bit），指数部分占11位，小数部分占52位，共64位。</p><h4 id="1-3-6-Symbol"><a href="#1-3-6-Symbol" class="headerlink" title="1.3.6 Symbol"></a>1.3.6 Symbol</h4><p>Symbol是ECMAScript 2015新引入的原始类型。<br>Symbol值有一个重要特征，每个Symbol值都是唯一且不可改变的。Symbol值的应用场景是作为对象的属性名。</p><p>JavaScript提供了一个全局的“Symbol()”函数来创建Symbol类型的值。我们可以将“Symbol()”函数想象成GUID（全局唯一标识符）的生成器，每次调用“Symbol()”函数都会生成一个完全不同的Symbol值。</p><h4 id="1-3-7-Object"><a href="#1-3-7-Object" class="headerlink" title="1.3.7 Object"></a>1.3.7 Object</h4><p>对象是属性的集合。对象属性使用键值来标识，键值只能为字符串或Symbol值，空字符串也是合法的键值。</p><h3 id="1-4-字面量"><a href="#1-4-字面量" class="headerlink" title="1.4 字面量"></a>1.4 字面量</h3><p>在计算机科学中，字面量用于在源代码中表示某个固定值。在JavaScript程序中，字面量不是变量，它是直接给出的固定值。</p><h4 id="1-4-1-Null字面量"><a href="#1-4-1-Null字面量" class="headerlink" title="1.4.1 Null字面量"></a>1.4.1 Null字面量</h4><p>Null字面量只有一个，记作null。</p><h4 id="1-4-2-Boolean字面量"><a href="#1-4-2-Boolean字面量" class="headerlink" title="1.4.2 Boolean字面量"></a>1.4.2 Boolean字面量</h4><p>Boolean字面量有两个，分别记作true和false。</p><h4 id="1-4-3-Number字面量"><a href="#1-4-3-Number字面量" class="headerlink" title="1.4.3 Number字面量"></a>1.4.3 Number字面量</h4><p>Number字面量包含4类：</p><ol><li>二进制整数字面量：以0b或者0B开头，只包含数字0或1</li><li>八进制整数字面量：以0o或者0O开头,只包含数字0到7</li><li>十进制数字字面量：一串数字组成，支持整数、小数、科学记数法</li><li>十六进制整数字面量：以0x或者0X开头,可以包含数字0至9、小写字母a至f以及大写字母A至F</li></ol><h4 id="1-4-4-字符串字面量"><a href="#1-4-4-字符串字面量" class="headerlink" title="1.4.4 字符串字面量"></a>1.4.4 字符串字面量</h4><p>字符串字面量是使用一对单引号或双引号包围起来的Unicode字符.<br>字符串字面量中可以包含Unicode转义序列和十六进制转义序列。</p><h4 id="1-4-5-模版字面量"><a href="#1-4-5-模版字面量" class="headerlink" title="1.4.5 模版字面量"></a>1.4.5 模版字面量</h4><p>模板字面量是ECMAScript 2015引入的新特性，它提供了一种语法糖来帮助构造字符串。<br>模板字符串的基本语法是使用反引号“`”替换了字符串字面量中的单、双引号</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> const template = `</span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>昵称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>多米<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>女<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">12 `;</span><br></pre></td></tr></table></figure><p>字符串占位符：“${}”</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const root = &#x27;https://www.bai.com&#x27;</span><br><span class="line">const url = `$&#123;root&#125;?a=1`</span><br></pre></td></tr></table></figure><h3 id="1-5-对象"><a href="#1-5-对象" class="headerlink" title="1.5 对象"></a>1.5 对象</h3><p>在JavaScript中，对象属于非原始类型。同时，对象也是一种复合数据类型，它由若干个对象属性构成。对象属性可以是任意数据类型，如数字、函数或者对象等。当对象属性为函数时，我们通常称之为方法。</p><h4 id="1-5-1-对象字面量"><a href="#1-5-1-对象字面量" class="headerlink" title="1.5.1 对象字面量"></a>1.5.1 对象字面量</h4><p>1.数据属性<br>数据属性由属性名和属性值组成：<br>{<br>  PropertyName: PropertyValue,<br>}</p><p>对象属性名可以为标识符、字符串字面量和数字字面量，对象属性值可以为任意值</p><p>2.存取器属性<br>一个存取器属性由一个或两个存取器方法组成，分别为get方法和set方法两种。<br>如果一个属性只定义了get方法而没有定义对应的set方法，那么该属性就成了只读属性。</p><h4 id="1-5-2-原型对象"><a href="#1-5-2-原型对象" class="headerlink" title="1.5.2 原型对象"></a>1.5.2 原型对象</h4><p>每个对象都有一个原型。对象的原型既可以是一个对象，即原型对象，也可以是null值。原型对象又有其自身的原型，对象的原型会形成一条原型链，原型链将终止于null值。<br>原型能够用来在不同对象之间共享属性和方法，JavaScript中的继承机制也是通过原型来实现的。<br>原型的作用主要体现在查询对象某个属性或方法时会沿着原型链依次向后搜索，如果直到原型链尽头null值也没有查询到对应属性，那么会返回undefined。</p><p>注：原型对象在属性查询和属性设置时起到的作用是不对等的。在查询对象属性时会考虑对象的原型，但是在设置对象属性时不会考虑对象的原型，而是直接修改对象本身的属性值。</p><h3 id="1-6-数组"><a href="#1-6-数组" class="headerlink" title="1.6 数组"></a>1.6 数组</h3><p>数组是一组有序元素的集合，它使用数字作为元素索引值。数组属于对象数据类型。</p><h4 id="1-6-1-数组字面量"><a href="#1-6-1-数组字面量" class="headerlink" title="1.6.1 数组字面量"></a>1.6.1 数组字面量</h4><p>数组字面量是常用的创建数组的方法。 const colors = [‘red’, ‘green’]</p><h4 id="1-6-2-数组中元素"><a href="#1-6-2-数组中元素" class="headerlink" title="1.6.2 数组中元素"></a>1.6.2 数组中元素</h4><p>数组中元素可以是数字，函数或对象，可以是任意类型的值。通过数字索引访问，从0开始，访问越界不会报错，返回undefined</p><h3 id="1-7-函数"><a href="#1-7-函数" class="headerlink" title="1.7 函数"></a>1.7 函数</h3><p>JavaScript中的函数是“头等函数”，它具有以下特性：</p><ol><li>函数可以赋值给变量或对象属性</li><li>函数可以作为函数的返回值</li><li>函数可以作为另一个函数的参数传递</li></ol><h4 id="1-7-1-函数声明"><a href="#1-7-1-函数声明" class="headerlink" title="1.7.1 函数声明"></a>1.7.1 函数声明</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params">param1,param2,...</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-7-2-函数表达式"><a href="#1-7-2-函数表达式" class="headerlink" title="1.7.2 函数表达式"></a>1.7.2 函数表达式</h4><p>函数表达式中的函数名是可选的。当没有指定函数名时，该函数也叫作匿名函数。</p><p>立即执行的函数表达式：在定义时就立即被调用的函数表达式</p><p>定义方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure><p>包围函数表达式的()叫分组运算符，将函数置于分组运算符之内时，该函数即成了函数表达式。</p><p>立即执行的函数表达式两个特点：</p><ol><li>能够创建新的作用域，函数内部不会对外部产生影响，提供了一定数据封装性</li><li>立即执行的函数表达式自身不会对外部作用域产生任何影响，无法通过函数表达式来访问。</li></ol><h4 id="1-7-3-箭头函数"><a href="#1-7-3-箭头函数" class="headerlink" title="1.7.3 箭头函数"></a>1.7.3 箭头函数</h4><p>箭头函数是ECMAScript 2015中新增的特性，用来定义匿名的函数表达式。<br>箭头函数一定是匿名函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(params1, param2, ...) =&gt; &#123; <span class="comment">// body &#125;</span></span><br></pre></td></tr></table></figure><p>箭头函数没有this绑定，使用外层作用域的this绑定。</p><h2 id="第二章-TypeScript语言进阶"><a href="#第二章-TypeScript语言进阶" class="headerlink" title="第二章 TypeScript语言进阶"></a>第二章 TypeScript语言进阶</h2><h3 id="2-1-BigInt"><a href="#2-1-BigInt" class="headerlink" title="2.1 BigInt"></a>2.1 BigInt</h3><p>一个新的原始数据类型，属性数值类型的一种。<br>目前，JavaScript语言中共有以下七种原始数据类型：</p><ol><li>Undefined</li><li>Null</li><li>Boolean</li><li>String</li><li>Number</li><li>BigInt</li><li>Symbol</li></ol><p>BigInt能表示任意精度的整数，尤其是大于2的53次方-1的整数。</p><h4 id="2-1-1-创建BigInt"><a href="#2-1-1-创建BigInt" class="headerlink" title="2.1.1 创建BigInt"></a>2.1.1 创建BigInt</h4><ol><li>使用BigInt字面量</li><li>使用BigInt()函数</li></ol><p>BigInt字面量的语法是在一个整数后面添加一个小写字母“n”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unit = <span class="number">1n</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> unit1 = BigInt(<span class="number">1</span>) <span class="comment">// 1n</span></span><br></pre></td></tr></table></figure><h4 id="2-1-2-BigInt与Number"><a href="#2-1-2-BigInt与Number" class="headerlink" title="2.1.2 BigInt与Number"></a>2.1.2 BigInt与Number</h4><p>BigInt类型的值与Number类型的值可以进行相等关系比较，在进行严格相等比较时，两者用不相等。BigInt类型的值与Number类型的值不允许进行混合数学运算。<br>可以通过Number()函数将BigInt类型的值转换为Number类型的值，但是会损失精度。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="number">1n</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="2-2-展开运算符"><a href="#2-2-展开运算符" class="headerlink" title="2.2 展开运算符"></a>2.2 展开运算符</h3><p>…expression</p><h4 id="2-2-1-展开数组字面量"><a href="#2-2-1-展开数组字面量" class="headerlink" title="2.2.1 展开数组字面量"></a>2.2.1 展开数组字面量</h4><p>数组字面量中的展开运算符可以应用在任何可迭代对象上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstHalfYearSeasons = [<span class="string">&#x27;Spring&#x27;</span>, <span class="string">&#x27;Summer&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> seasons = [...firstHalfYearSeasons, <span class="string">&#x27;Fall&#x27;</span>, <span class="string">&#x27;Winter&#x27;</span>];</span><br><span class="line">seasons; <span class="comment">// [&quot;Spring&quot;, &quot;Summer&quot;, &quot;Fall&quot;, &quot;Winter&quot;]</span></span><br></pre></td></tr></table></figure><h4 id="2-2-2-展开对象字面量"><a href="#2-2-2-展开对象字面量" class="headerlink" title="2.2.2 展开对象字面量"></a>2.2.2 展开对象字面量</h4><p>对象字面量的展开运算符会将操作数自身可枚举属性复制到当前对象字面量中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> point2d = &#123;</span><br><span class="line">  x: <span class="number">0</span>,</span><br><span class="line">  y: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> point3d = &#123;</span><br><span class="line">  ...point2d,</span><br><span class="line">  z: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">point3d <span class="comment">// &#123; x: 0, y: 0, z: 0 &#125;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-3-展开函数参数"><a href="#2-2-3-展开函数参数" class="headerlink" title="2.2.3 展开函数参数"></a>2.2.3 展开函数参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> max = <span class="built_in">Math</span>.max(...nums);</span><br><span class="line">max;  <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h3 id="2-3-解构"><a href="#2-3-解构" class="headerlink" title="2.3 解构"></a>2.3 解构</h3><h4 id="2-3-1-数组解构"><a href="#2-3-1-数组解构" class="headerlink" title="2.3.1 数组解构"></a>2.3.1 数组解构</h4><p>赋值运算符右侧为需要解构的数组，赋值运算符左侧是解构赋值的目标，在解构赋值的同时也支持声明新的变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> point = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">const</span> [x, y] = point</span><br><span class="line">x <span class="comment">// 0</span></span><br><span class="line">y <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h4 id="2-3-2-对象解构"><a href="#2-3-2-对象解构" class="headerlink" title="2.3.2 对象解构"></a>2.3.2 对象解构</h4><p>赋值运算符右侧为需要解构的对象，赋值运算符左侧是解构赋值的目标，在解构赋值的同时也支持声明新的变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> point = &#123;<span class="attr">x</span>:<span class="number">0</span>, <span class="attr">y</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;x, y&#125; = point</span><br><span class="line">x <span class="comment">// 0</span></span><br><span class="line">y <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="2-4-可选链运算符"><a href="#2-4-可选链运算符" class="headerlink" title="2.4 可选链运算符"></a>2.4 可选链运算符</h3><p>当尝试访问对象属性时，如果对象的值为undefined或null，那么属性访问将产生错误。为了提高程序的健壮性，在访问对象属性时通常需要检查对象是否已经初始化，只有当对象不为undefined和null时才去访问对象的属性。</p><h4 id="2-4-1-基础语法"><a href="#2-4-1-基础语法" class="headerlink" title="2.4.1 基础语法"></a>2.4.1 基础语法</h4><p>由”?.”组成，有以下三种语法：</p><ol><li>可选静态属性访问</li><li>可选计算属性访问</li><li>可选的函数调用或方法调用</li></ol><p>可选的静态属性访问：obj?.prop<br>如果obj的值为null或者undefined，那么表达式的求值结果为undefined，否则为obj.prop</p><p>可选计算属性访问: obj?.[expression]<br>如果obj的值为null或者undefined，那么表达式的求值结果为undefined，否则为obj.[expression]</p><p>可选的函数调用或方法调用: fn?.()<br>如果fn的值为null或者undefined，那么表达式的求值结果为undefined，否则为fn()</p><h4 id="2-4-2-短路求值"><a href="#2-4-2-短路求值" class="headerlink" title="2.4.2 短路求值"></a>2.4.2 短路求值</h4><p>如果可选链运算符左侧操作数的求值结果为undefined或null，那么右侧的操作数不会再被求值，我们将这种行为称作短路求值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a1 = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b1 = <span class="literal">undefined</span></span><br><span class="line">b1?.[++a1]</span><br><span class="line">a1 <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>二元逻辑运算符“&amp;&amp;”和“||”也具有短路求值的特性。</p><h3 id="2-5-空值合并运算符"><a href="#2-5-空值合并运算符" class="headerlink" title="2.5 空值合并运算符"></a>2.5 空值合并运算符</h3><p>语法：a ?? b</p><p>当且仅当”??”运算符左侧操作数a的值为undefined或null时，返回右侧操作数b；否则返回左侧操作数a</p><h2 id="第三章-TypeScript类型基础"><a href="#第三章-TypeScript类型基础" class="headerlink" title="第三章 TypeScript类型基础"></a>第三章 TypeScript类型基础</h2><h3 id="3-1-类型注解"><a href="#3-1-类型注解" class="headerlink" title="3.1 类型注解"></a>3.1 类型注解</h3><p>:Type</p><p>const greeting:string = ‘Hello’</p><p>TypeScript中的类型注解是可选的，编译器在大部分情况下都能够自动推断出表达式的类型</p><h3 id="3-2-类型检查"><a href="#3-2-类型检查" class="headerlink" title="3.2 类型检查"></a>3.2 类型检查</h3><p>类型检查是验证程序中类型约束是否正确的过程。<br>类型检查既可以在程序编译时进行，即静态类型检查；也可以在程序运行时进行，即动态类型检查。TypeScript支持静态类型检查，JavaScript支持动态类型检查。</p><p>TypeScript提供了两种静态类型检查模式：</p><ol><li><p>非严格类型检查（默认方式）。</p><p>非严格类型检查是TypeScript默认的类型检查模式。在该模式下，类型检查的规则相对宽松。例如，在非严格类型检查模式下不会对undefined值和null值做过多限制，允许将undefined值和null值赋值给string类型的变量。</p></li><li><p>严格类型检查</p></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;strict&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会尽可能地发现代码中的错误，例如，在严格类型检查模式下不允许将undefined值和null值赋值给string类型的变量。</p><h3 id="3-3-原始类型"><a href="#3-3-原始类型" class="headerlink" title="3.3 原始类型"></a>3.3 原始类型</h3><p>TypeScript中的原始类型包含以下几种：</p><ol><li>boolean</li><li>string</li><li>number</li><li>bigint</li><li>symbol</li><li>undefined</li><li>null</li><li>void</li><li>枚举类型</li><li>字面量类型</li></ol><h4 id="3-3-1-boolean"><a href="#3-3-1-boolean" class="headerlink" title="3.3.1 boolean"></a>3.3.1 boolean</h4><p>TypeScript中的boolean类型对应于JavaScript中的Boolean原始类型。该类型能够表示两个逻辑值：true和false。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> yes:<span class="built_in">boolean</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">const</span> no:<span class="built_in">boolean</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure><h4 id="3-3-2-string"><a href="#3-3-2-string" class="headerlink" title="3.3.2 string"></a>3.3.2 string</h4><p>TypeScript中的string类型对应于JavaScript中的String原始类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo:<span class="built_in">string</span> = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"><span class="keyword">const</span> bar:<span class="built_in">string</span> = <span class="string">`bar,<span class="subst">$&#123;foo&#125;</span>`</span></span><br></pre></td></tr></table></figure><h4 id="3-3-3-number"><a href="#3-3-3-number" class="headerlink" title="3.3.3 number"></a>3.3.3 number</h4><p>TypeScript中的number类型对应于JavaScript中的Number原始类型。该类型能够表示采用双精度64位二进制浮点数格式存储的数字。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二进制数</span></span><br><span class="line"><span class="keyword">const</span> bin:<span class="built_in">number</span> = <span class="number">0b1010</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 八进制数</span></span><br><span class="line"><span class="keyword">const</span> oct:<span class="built_in">number</span> = <span class="number">0o744</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 十进制数</span></span><br><span class="line"><span class="keyword">const</span> integer:<span class="built_in">number</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> float:<span class="built_in">number</span> = <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 十六进制数</span></span><br><span class="line"><span class="keyword">const</span> hex:<span class="built_in">number</span> = <span class="number">0xffffff</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-3-4-bigint"><a href="#3-3-4-bigint" class="headerlink" title="3.3.4 bigint"></a>3.3.4 bigint</h4><p>TypeScript中的bigint类型对应于JavaScript中的BigInt原始类型。该类型能够表示任意精度的整数，但也仅能表示整数</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二进制数</span></span><br><span class="line"><span class="keyword">const</span> bin:<span class="built_in">number</span> = <span class="number">0b1010n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 八进制数</span></span><br><span class="line"><span class="keyword">const</span> oct:<span class="built_in">number</span> = <span class="number">0o744n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 十进制数</span></span><br><span class="line"><span class="keyword">const</span> integer:<span class="built_in">number</span> = <span class="number">10n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 十六进制数</span></span><br><span class="line"><span class="keyword">const</span> hex:<span class="built_in">number</span> = <span class="number">0xffffffn</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-3-5-symbol与unique-symbol"><a href="#3-3-5-symbol与unique-symbol" class="headerlink" title="3.3.5 symbol与unique symbol"></a>3.3.5 symbol与unique symbol</h4><p>TypeScript中的symbol类型对应于JavaScript中的Symbol原始类型。该类型能够表示任意的Symbol值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义Symbol</span></span><br><span class="line"><span class="keyword">const</span> key: symbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="comment">// Well-Known Symbol</span></span><br><span class="line"><span class="keyword">const</span> symbolHasInstance: symbol = <span class="built_in">Symbol</span>.hasInstance;</span><br></pre></td></tr></table></figure><p>字面量能够表示一个固定值。例如，数字字面量“3”表示固定数值“3”.<br>symbol类型不同于其他原始类型，它不存在字面量形式<br>symbol类型的值只能通过”Symbol()”和”Symbol.for()”来创建或者直接饮用某个well-known Symbol值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s0: symbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> s1: symbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> s2: symbol = <span class="built_in">Symbol</span>.hasInstance;</span><br><span class="line"><span class="keyword">const</span> s3: symbol = s0;</span><br><span class="line">s0 <span class="comment">// Symbol()</span></span><br><span class="line">s1 <span class="comment">// Symbol(foo)</span></span><br><span class="line">s2 <span class="comment">// Symbol(Symbol.hasInstance)</span></span><br><span class="line">s3 <span class="comment">// Symbol()</span></span><br></pre></td></tr></table></figure><p>为了能够将一个Symbol值视作表示固定值的字面量，TypeScript引入了“unique symbol”类型.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s0: unique symbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> s1: unique symbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;s1&#x27;</span>);</span><br></pre></td></tr></table></figure><p>“unique symbol”类型的主要用途是用作接口、类等类型中的可计算属性名.<br>因为如果使用可计算属性名在接口中添加了一个类型成员，那么必须保证该类型成员的名字是固定的，否则接口定义将失去意义。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s0: unique symbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> s1: symbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;s1&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s0,s1)</span><br><span class="line"><span class="keyword">interface</span> foo &#123;</span><br><span class="line">    [s0]: <span class="built_in">String</span>,</span><br><span class="line">    [s1]: <span class="built_in">String</span> <span class="comment">// A computed property name in an interface must refer to an expression whose type is a literal type or a &#x27;unique symbol&#x27; type. 计算属性名称必须引用类型为字面量类型或者&#x27;unique symbol&#x27;类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TypeScript中只允许使用const声明或readonly属性声明来定义“unique symbol”类型的值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须使用const声明</span></span><br><span class="line"><span class="keyword">const</span> a: unique symbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> WithUniqueSymbol &#123;</span><br><span class="line">    <span class="comment">// 必须使用readonly修饰符</span></span><br><span class="line">    <span class="keyword">readonly</span> b: unique symbol;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 必须使用static和readonly修饰符</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">readonly</span> c: unique symbol = <span class="built_in">Symbol</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用let或var声明定义“unique symbol”类型的变量，那么将产生错误，因为标识符与Symbol值之间的绑定是可变的</p><p>“unique symbol”类型的值只允许使用“Symbol()”函数或“Symbol.for()”方法的返回值进行初始化，因为只有这样才能够“确保”引用了唯一的Symbol值.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a: unique symbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> b: unique symbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;desc&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c: unique symbol = a;</span><br><span class="line"><span class="comment">// 错误：a的类型与c的类型不兼容</span></span><br></pre></td></tr></table></figure><p>使用相同的参数调用“Symbol.for()”方法实际上返回的是相同的Symbol值<br>因此，可能出现多个“unique symbol”类型的值实际上是同一个Symbol值的情况。由于设计上的局限性，TypeScript目前无法识别出这种情况.<br>在设计上，每一个“unique symbol”类型都是一种独立的类型。在不同的“unique symbol”类型之间不允许相互赋值；在比较两个“unique symbol”类型的值时，也将永远返回false.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> e: unique symbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;same&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> f: unique symbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;same&#x27;</span>); </span><br><span class="line"><span class="keyword">if</span>(e === f) &#123; </span><br><span class="line">  <span class="comment">// false</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;equal&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注：</span></span><br><span class="line"><span class="keyword">const</span> e: unique symbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;same&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> f: unique symbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line"><span class="comment">// 此时e和f相等，打印equal,但Symbol(&#x27;same&#x27;)和Symbol(&#x27;same&#x27;)；</span></span><br><span class="line"><span class="comment">// Symbol(&#x27;same&#x27;)和Symbol.for(&#x27;same&#x27;)不相等，不知道为啥，应该是都不相等的，但运行代码能打印equal</span></span><br></pre></td></tr></table></figure><p>“unique symbol”类型是symbol类型的子类型，可以将“unique symbol”类型赋值给symbol类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f: unique symbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> g:symbol = f</span><br></pre></td></tr></table></figure><h4 id="3-3-6-Nullable"><a href="#3-3-6-Nullable" class="headerlink" title="3.3.6 Nullable"></a>3.3.6 Nullable</h4><p>TypeScript中的Nullable类型指的是值可以为undefined或null的类型。</p><ol><li>undefined类型：只包含一个值，即undefined</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo:<span class="literal">undefined</span> = <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><ol start="2"><li>null类型：只包含一个值，即null</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo:<span class="literal">null</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure><ol start="3"><li>strictNullChecks,即严格的null检查模式，同时作用于undefined类型和null类型检查<br>默认不启用该选项，在不启用时允许将undefined和null值赋值给string类型等其他类型，如下：</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * strictNullChecks:false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> m1:<span class="built_in">boolean</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> m2:<span class="built_in">string</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> m3:<span class="built_in">number</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> m4:bigint = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> m5:symbol = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> m6:<span class="literal">null</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> m7:<span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n1:<span class="built_in">boolean</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> n2:<span class="built_in">string</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> n3:<span class="built_in">number</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> n4:bigint = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> n5:symbol = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> n6:<span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> n7:<span class="literal">undefined</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>当启用strictNullChecks编译选项时，undefined和null值不能再赋值给不相关的类型，undefined只能赋值给undefined，null值也只能赋值给null。<br>但是undefined值和null值允许赋值给顶端类型，同时undefined值也允许赋值给void类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> m1:<span class="built_in">void</span> = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> m2:<span class="built_in">any</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> m3:unknown = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n2:<span class="built_in">any</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> n3:unknown = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null和undefined是两个不同的类型</span></span><br><span class="line"><span class="keyword">let</span> foo:<span class="literal">undefined</span> = <span class="literal">null</span> <span class="comment">// 编译错误 null不能赋值给undefined</span></span><br><span class="line"><span class="keyword">let</span> bar:<span class="literal">null</span> = <span class="literal">undefined</span> <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure><h4 id="3-3-7-void"><a href="#3-3-7-void" class="headerlink" title="3.3.7 void"></a>3.3.7 void</h4><p>void类型表示某个值不存在，该类型用作函数的返回值类型。</p><p>除了将void类型作为函数返回值类型外，在其他地方使用void类型是无意义的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">message:<span class="built_in">string</span></span>):<span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启用strictNullChecks时只允许将undefined赋值给void</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * strictNullChecks:true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foos</span>(<span class="params"></span>):<span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params"></span>):<span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">//wrong: Type &#x27;null&#x27; is not assignable to type &#x27;void&#x27;.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * strictNullChecks:false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foos</span>(<span class="params"></span>):<span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params"></span>):<span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-枚举类型"><a href="#3-4-枚举类型" class="headerlink" title="3.4 枚举类型"></a>3.4 枚举类型</h3><p>枚举类型由0个或多个枚举成员构成，每个枚举成员都是命名的常量。<br>枚举类型是ts中的原始类型，由enum关键字定义。枚举类型分为：</p><ol><li>数值型枚举</li><li>字符串枚举</li><li>异构型枚举</li></ol><h4 id="3-4-1-数值型枚举"><a href="#3-4-1-数值型枚举" class="headerlink" title="3.4.1 数值型枚举"></a>3.4.1 数值型枚举</h4><p>由一组命名的数值常量构成,是nunber类型的子类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Direction &#123;</span><br><span class="line">  Up, <span class="comment">// 0</span></span><br><span class="line">  Right, <span class="comment">// 1</span></span><br><span class="line">  Down, <span class="comment">// 2</span></span><br><span class="line">  Left <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> direction: Direction = Direction.Up</span><br></pre></td></tr></table></figure><p>如果在定义枚举时没有设置枚举成员的值，那么TypeScript将自动计算枚举成员的值。根据TypeScript语言的规则，第一个枚举成员的值为0，其后每个枚举成员的值等于前一个枚举成员的值加1.</p><p>在定义数值型枚举时，可以为一个或多个枚举成员设置初始值。对于未指定初始值的枚举成员，其值为前一个枚举成员的值加1.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Direction &#123;</span><br><span class="line">  Up = <span class="number">1</span>, <span class="comment">// 1</span></span><br><span class="line">  Right, <span class="comment">// 2</span></span><br><span class="line">  Down = <span class="number">10</span>, <span class="comment">// 10</span></span><br><span class="line">  Left <span class="comment">// 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举类型时number类型的子类型，所以可以将数值型枚举类型赋值给number类型：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num: <span class="built_in">number</span> = Direction.Up</span><br></pre></td></tr></table></figure><p>number类型的值也可以赋值给枚举类型，即使不在枚举类型枚举成员列表中也不会出错。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> d1: Direction = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> d2: Direction = <span class="number">100</span></span><br></pre></td></tr></table></figure><h4 id="3-4-2-字符串枚举"><a href="#3-4-2-字符串枚举" class="headerlink" title="3.4.2 字符串枚举"></a>3.4.2 字符串枚举</h4><p>字符串枚举类型成员必须由字符串字面量或另一个字符串枚举成员来初始化，不存在自增行为。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Direction &#123;</span><br><span class="line">  Up = <span class="string">&#x27;up&#x27;</span>,</span><br><span class="line">  Right = <span class="string">&#x27;right&#x27;</span>,</span><br><span class="line">  Down = <span class="string">&#x27;down&#x27;</span>,</span><br><span class="line">  Left = <span class="string">&#x27;left&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  U = Up,</span><br><span class="line">  R = Right,</span><br><span class="line">  D = Down,</span><br><span class="line">  L = Left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串枚举类型是字符串的子类型，因此允许将字符串枚举类型赋值给string类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str: <span class="built_in">string</span> = Direction.Up</span><br></pre></td></tr></table></figure><p>但是反过来将string类型赋值给字符串枚举类型，将产生编译错误。</p><h4 id="3-4-3-异构型枚举"><a href="#3-4-3-异构型枚举" class="headerlink" title="3.4.3 异构型枚举"></a>3.4.3 异构型枚举</h4><p>TypeScript允许在一个枚举中同时定义数值型枚举成员和字符串枚举成员，我们将这种类型的枚举称作异构型枚举。不推荐使用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Color &#123;</span><br><span class="line">  Black = <span class="number">0</span>,</span><br><span class="line">  White = <span class="string">&#x27;white&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在定义异构型枚举时，不允许使用计算的值作为枚举成员的初始值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Color &#123;</span><br><span class="line">  Black = <span class="number">0</span> + <span class="number">0</span>, <span class="comment">// 在具有字符串值成员的枚举中不允许计算值。</span></span><br><span class="line">  White = <span class="string">&#x27;white&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在异构型枚举中，必须为字符串枚举成员之后的数值型枚举成员定义初始值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> ColorA &#123;</span><br><span class="line">  Black,</span><br><span class="line">  White = <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">enum</span> ColorB &#123;</span><br><span class="line">  White = <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">  Black <span class="comment">// wrong: Enum member must have initializer.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-4-枚举成员映射"><a href="#3-4-4-枚举成员映射" class="headerlink" title="3.4.4 枚举成员映射"></a>3.4.4 枚举成员映射</h4><p>不论哪种类型枚举，都可以通过枚举成员名去访问枚举成员值。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> ColorA &#123;</span><br><span class="line">    Black,</span><br><span class="line">    White = <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(ColorA.Black) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(ColorA.White) <span class="comment">// &#x27;1&#x27;</span></span><br></pre></td></tr></table></figure><p>对于数值型枚举，不仅可以通过枚举成员名访问枚举成员值，还可以通过枚举成员值去获取枚举成员名。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Bool &#123;</span><br><span class="line">    True = <span class="number">0</span>,</span><br><span class="line">    False = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Bool.True) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(Bool.False) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(Bool[Bool.True]) <span class="comment">// &#x27;True&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(Bool[Bool.False]) <span class="comment">// &#x27;False&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(Bool[<span class="number">0</span>]) <span class="comment">// &#x27;True&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(Bool[<span class="number">1</span>]) <span class="comment">// &#x27;False&#x27;</span></span><br></pre></td></tr></table></figure><p>对于字符串枚举和异构型枚举，则不能够通过枚举成员值去获取枚举成员名.</p><h4 id="3-4-5-常量枚举成员和计算枚举成员"><a href="#3-4-5-常量枚举成员和计算枚举成员" class="headerlink" title="3.4.5 常量枚举成员和计算枚举成员"></a>3.4.5 常量枚举成员和计算枚举成员</h4><p>每个枚举成员都有一个值，根据枚举成员值的定义可以将枚举成员划分为以下两类：</p><ol><li>常量枚举成员</li><li>计算枚举成员</li></ol><p>常量枚举表达式的具体规则如下：</p><p>  常量枚举表达式可以是数字字面量、字符串字面量和不包含替换值的模板字面量。<br>  常量枚举表达式可以是对前面定义的常量枚举成员的引用<br>  常量枚举表达式可以是用分组运算符包围起来的常量枚举表达式。<br>  常量枚举表达式中可以使用一元运算符“+”“-”“~”，操作数必须为常量枚举表达式<br>  常量枚举表达式中可以使用二元运算符“+”“-”“*”“**”“/”“%”“&lt;&lt;”“&gt;&gt;”“&gt;&gt;&gt;”“&amp;”“|”“^”，两个操作数必须为常量枚举表达式。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Foo &#123;</span><br><span class="line">  A = <span class="number">0</span>,</span><br><span class="line">  B = <span class="string">&#x27;B&#x27;</span>,</span><br><span class="line">  C = <span class="string">`C`</span>,</span><br><span class="line">  D = A,</span><br><span class="line"></span><br><span class="line">  E = -<span class="number">1</span>, <span class="comment">// 一元运算符</span></span><br><span class="line">  F = <span class="number">12</span> + <span class="number">3</span>, <span class="comment">// 二元运算符</span></span><br><span class="line">  G = (<span class="number">1</span>/<span class="number">1</span>) * <span class="number">3</span> <span class="comment">// 分组运算符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字面量枚举成员是常量枚举成员的子集，字面量枚举成员是指满足下列条件之一的枚举成员，具体条件如下：</p><p>  枚举成员没有定义初始值<br>  枚举成员的初始值为数字字面量、字符串字面量和不包含替换值的模板字面量。<br>  枚举成员的初始值为对其他字面量枚举成员的引用</p><p>除常量枚举成员之外的其他枚举成员都属于计算枚举成员。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Foo &#123;</span><br><span class="line">  A = <span class="string">&#x27;A&#x27;</span>.length,</span><br><span class="line">  B = <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-6-联合枚举类型"><a href="#3-4-6-联合枚举类型" class="headerlink" title="3.4.6 联合枚举类型"></a>3.4.6 联合枚举类型</h4><p>当枚举类型中的成员全是常量枚举成员时，该枚举类型成了联合枚举类型。</p><p>联合枚举类型中的枚举成员除了能表示一个常量外，还能够表示一种类型，即联合枚举成员类型。<br>联合枚举成员类型是联合枚举类型的子类型，因此可以将联合枚举成员类型赋值给联合枚举类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Direction &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Right,</span><br><span class="line">    Down,</span><br><span class="line">    Left</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> up: Direction.Up = Direction.Up</span><br><span class="line"><span class="built_in">console</span>.log(up) <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">const</span> dir: Direction = up</span><br><span class="line"><span class="built_in">console</span>.log(dir) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h4 id="3-4-7-const枚举类型"><a href="#3-4-7-const枚举类型" class="headerlink" title="3.4.7 const枚举类型"></a>3.4.7 const枚举类型</h4><p>枚举类型是ts对js的扩展，js本身并不支持枚举类型。在编译时，ts会将枚举类型编译为js对象。</p><p>const枚举类型将在编译阶段被完全删除，并且在使用了const枚举类型的地方将const枚举成员的值内联到代码中。</p><p>const枚举类型使用“const enum”关键字定义，示例如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">enum</span> Direction &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Right,</span><br><span class="line">    Down,</span><br><span class="line">    Left</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> directions = [</span><br><span class="line">    Direction.Up,</span><br><span class="line">    Direction.Right,</span><br><span class="line">    Direction.Down,</span><br><span class="line">    Direction.Left</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>编译后:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> directions = [</span><br><span class="line">  <span class="number">0</span> <span class="comment">/* Up */</span>,</span><br><span class="line">  <span class="number">1</span> <span class="comment">/* Right */</span>,</span><br><span class="line">  <span class="number">2</span> <span class="comment">/* Down */</span>,</span><br><span class="line">  <span class="number">3</span> <span class="comment">/* Left */</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><h3 id="3-5-字面量类型"><a href="#3-5-字面量类型" class="headerlink" title="3.5 字面量类型"></a>3.5 字面量类型</h3><p>每一个字面量类型都只有一个可能的值，即字面量本身。</p><h4 id="3-5-1-boolean字面量类型"><a href="#3-5-1-boolean字面量类型" class="headerlink" title="3.5.1 boolean字面量类型"></a>3.5.1 boolean字面量类型</h4><ol><li>true字面量类型</li><li>false字面量类型</li></ol><p>原始类型boolean等同于由true字面量类型和false字面量类型构成的组合类型。<br>true字面量类型只能接受true值；同理，false字面量类型只能接受false值，示例如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a: <span class="literal">true</span> = <span class="literal">true</span></span><br><span class="line">cosnt b: <span class="literal">false</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>boolean字面量类型是boolean类型的子集，因此可以将boolean字面量类型赋值给boolean类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a: <span class="literal">true</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> b: <span class="literal">false</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> c: <span class="built_in">boolean</span>;</span><br><span class="line">c = a;</span><br><span class="line">c = b;</span><br></pre></td></tr></table></figure><h4 id="3-5-2-string字面量类型"><a href="#3-5-2-string字面量类型" class="headerlink" title="3.5.2 string字面量类型"></a>3.5.2 string字面量类型</h4><p>字符串字母量和模版字面量都可以创建字符串。字符串字面量和不带参数的模版字面量可以作为string字面量。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a: <span class="string">&#x27;hello&#x27;</span> = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">const</span> b: <span class="string">`world`</span> = <span class="string">`world`</span></span><br><span class="line"><span class="keyword">let</span> c: <span class="built_in">string</span></span><br><span class="line">c = a</span><br><span class="line">c = b</span><br></pre></td></tr></table></figure><p>string字面量类型是string类型的子类型，因此可以将string字面量类型赋值给string类型.</p><h4 id="3-5-3-数字字面量类型"><a href="#3-5-3-数字字面量类型" class="headerlink" title="3.5.3 数字字面量类型"></a>3.5.3 数字字面量类型</h4><p>number字面量<br>bigint字面量</p><p>所有的二进制、八进制、十进制、十六进制都可以作为数字字面量类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a0: <span class="number">0b1</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> b0: <span class="number">0o1</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> c0: <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> d0: <span class="number">0x1</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a1: <span class="number">0b1n</span> = <span class="number">1n</span></span><br><span class="line"><span class="keyword">const</span> b1: <span class="number">0o1n</span> = <span class="number">1n</span></span><br><span class="line"><span class="keyword">const</span> c1: <span class="number">1n</span> = <span class="number">1n</span></span><br><span class="line"><span class="keyword">const</span> d1: <span class="number">0x1n</span> = <span class="number">1n</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> e: -<span class="number">10</span> = -<span class="number">10</span> <span class="comment">// 正负数都可以当数字字面量</span></span><br><span class="line"><span class="keyword">const</span> f: -<span class="number">10n</span> = -<span class="number">10n</span></span><br></pre></td></tr></table></figure><p>number字面量类型和biginit字面量类型是number类型和bigint的子类型，所以可以进行赋值</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num: <span class="built_in">number</span> = a0</span><br><span class="line"><span class="keyword">const</span> num1: bigint = a1</span><br></pre></td></tr></table></figure><h4 id="3-5-4-枚举成员字面量类型"><a href="#3-5-4-枚举成员字面量类型" class="headerlink" title="3.5.4 枚举成员字面量类型"></a>3.5.4 枚举成员字面量类型</h4><p>联合枚举成员类型也可以将其称作枚举成员字面量类型，因为联合枚举成员类型使用枚举成员字面量形式表示。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">enum</span> Direction &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Right,</span><br><span class="line">    Down,</span><br><span class="line">    Left</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> up: Direction.Up = Direction.Up</span><br><span class="line"><span class="keyword">const</span> right: Direction.Right = Direction.Right</span><br></pre></td></tr></table></figure><h3 id="3-6-单元类型"><a href="#3-6-单元类型" class="headerlink" title="3.6 单元类型"></a>3.6 单元类型</h3><p>单元类型也叫单例类型，是指仅包含一个可能值的类型。<br>ts的单元类型有以下：</p><ol><li>undefined</li><li>null</li><li>unique symbol</li><li>void</li><li>联合枚举成员类型</li><li>字面量类型</li></ol><h3 id="3-7-顶端类型"><a href="#3-7-顶端类型" class="headerlink" title="3.7 顶端类型"></a>3.7 顶端类型</h3><p>顶端类型涵盖了类型系统中所有可能的值。<br>ts中有以下2种顶端类型：</p><ol><li>any</li><li>unknown</li></ol><h4 id="3-7-1-any"><a href="#3-7-1-any" class="headerlink" title="3.7.1 any"></a>3.7.1 any</h4><p>any类型使用any关键字作为标识。在ts中，所有类型都是any的子类型，所以可以将任何类型的值赋值给any，也可以将any类型的值赋值给任意类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">x = <span class="literal">true</span>; <span class="comment">// boolean</span></span><br><span class="line">x = <span class="string">&#x27;hi&#x27;</span>; <span class="comment">// string</span></span><br><span class="line">x = <span class="number">3.14</span>; <span class="comment">// number</span></span><br><span class="line">x = <span class="number">99999n</span>; <span class="comment">// bigint</span></span><br><span class="line">x = <span class="built_in">Symbol</span>(); <span class="comment">// Symbol</span></span><br><span class="line">x = <span class="literal">undefined</span>; <span class="comment">// undefined</span></span><br><span class="line">x = <span class="literal">null</span>; <span class="comment">// null</span></span><br><span class="line">x = &#123;&#125;;</span><br><span class="line">x = [];</span><br><span class="line">x = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: <span class="built_in">boolean</span>   = x;</span><br><span class="line"><span class="keyword">let</span> b: <span class="built_in">string</span>    = x;</span><br><span class="line"><span class="keyword">let</span> c: <span class="built_in">number</span>    = x;</span><br><span class="line"><span class="keyword">let</span> d: bigint    = x;</span><br><span class="line"><span class="keyword">let</span> e: symbol    = x;</span><br><span class="line"><span class="keyword">let</span> f: <span class="built_in">void</span>      = x;</span><br><span class="line"><span class="keyword">let</span> g: <span class="literal">undefined</span> = x;</span><br><span class="line"><span class="keyword">let</span> h: <span class="literal">null</span>      = x;</span><br></pre></td></tr></table></figure><p>使用any类型来跳过编译器的类型检查</p><p>ts中类型注解是可选的，若没有声明类型注解编译器又无法自动推断，那么这个值的默认类型为any类型<br>如果想避免这种情况，可以启用–noImplicitAny编译选项，当启用时，发生隐式的any类型转换,那么会产生编译错误.</p><h4 id="3-7-2-unknown"><a href="#3-7-2-unknown" class="headerlink" title="3.7.2 unknown"></a>3.7.2 unknown</h4><p>unknown类型使用unknown关键字作为标识.根据顶端类型的性质，任何其他类型都能够赋值给unknown类型，该行为与any类型是一致的.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: unknown;</span><br><span class="line"></span><br><span class="line">x = <span class="literal">true</span>; <span class="comment">// boolean</span></span><br><span class="line">x = <span class="string">&#x27;hi&#x27;</span>; <span class="comment">// string</span></span><br><span class="line">x = <span class="number">3.14</span>; <span class="comment">// number</span></span><br><span class="line">x = <span class="number">99999n</span>; <span class="comment">// bigint</span></span><br><span class="line">x = <span class="built_in">Symbol</span>(); <span class="comment">// Symbol</span></span><br><span class="line">x = <span class="literal">undefined</span>; <span class="comment">// undefined</span></span><br><span class="line">x = <span class="literal">null</span>; <span class="comment">// null</span></span><br><span class="line">x = &#123;&#125;;</span><br><span class="line">x = [];</span><br><span class="line">x = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>unknown类型比any类型安全，unknown类型只可以赋值给any类型和unknown类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: unknown</span><br><span class="line"></span><br><span class="line"><span class="comment">// right</span></span><br><span class="line"><span class="keyword">let</span> a1: unknown = x</span><br><span class="line"><span class="keyword">let</span> b1: <span class="built_in">any</span> = x</span><br><span class="line"><span class="comment">// wrong</span></span><br><span class="line"><span class="keyword">let</span> a: <span class="built_in">boolean</span>   = x;</span><br><span class="line"><span class="keyword">let</span> b: <span class="built_in">string</span>    = x;</span><br><span class="line"><span class="keyword">let</span> c: <span class="built_in">number</span>    = x;</span><br><span class="line"><span class="keyword">let</span> d: bigint    = x;</span><br><span class="line"><span class="keyword">let</span> e: symbol    = x;</span><br><span class="line"><span class="keyword">let</span> f: <span class="built_in">void</span>      = x;</span><br><span class="line"><span class="keyword">let</span> g: <span class="literal">undefined</span> = x;</span><br><span class="line"><span class="keyword">let</span> h: <span class="literal">null</span>      = x;</span><br></pre></td></tr></table></figure><p>在程序中使用unknown类型时，我们必须将其细化为某种具体类型，否则将产生编译错误.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">message: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> message.length; <span class="comment">// 无编译错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1(<span class="literal">undefined</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params">message: unknown</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> message.length; <span class="comment">// wrong : Cannot read properties of undefined (reading &#x27;length&#x27;) </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> message === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> message.length </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f2(<span class="literal">undefined</span>);</span><br></pre></td></tr></table></figure><p>  TypeScript中仅有any和unknown两种顶端类型。<br>  TypeScript中的所有类型都能够赋值给any类型和unknown类型，相当于两者都没有写入的限制。<br>  any类型能够赋值给任何其他类型，唯独不包括马上要介绍的never类型。<br>  unknown类型仅能够赋值给any类型和unknown类型。<br>  在使用unknown类型之前，必须将其细化为某种具体类型，而使用any类型时则没有任何限制。<br>  unknown类型相当于类型安全的any类型。这也是在有了any类型之后，TypeScript又引入unknown类型的根本原因。</p><h3 id="3-8-尾端类型"><a href="#3-8-尾端类型" class="headerlink" title="3.8 尾端类型"></a>3.8 尾端类型</h3><p>尾端类型是所有类型的子类型，也称作0类型或空类型。<br>ts中只存在一种尾端类型。即never</p><h4 id="3-8-1-never"><a href="#3-8-1-never" class="headerlink" title="3.8.1 never"></a>3.8.1 never</h4><p>never类型： </p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="built_in">never</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>never类型是其他类型的子类型，所以允许赋值给任何类型<br>never类型不是任何类型的子类型，除never类型自身外，其他类型的值都不能赋值给never类型。any类型也不可以赋值给never类型。</p><p>使用场景：</p><ol><li><p>never类型可以作为函数的返回值，表示该函数无法返回一个值。没有return语句的函数返回值类型是void，只有函数无法返回一个值的情况函数返回值才是never类型。比如函数抛出异常或者返回体内无限循环永不结束</p></li><li><p>在“条件类型”中常使用never类型来帮助完成一些类型运算</p></li><li><p>类型推断，在ts编译器执行类型推断操作时，如果发现无可用的类型那么推断结果为never类型</p></li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">message: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> message === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    message <span class="comment">// string</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    message <span class="comment">// never</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-9-数组类型"><a href="#3-9-数组类型" class="headerlink" title="3.9 数组类型"></a>3.9 数组类型</h3><h4 id="3-9-1-数组类型定义"><a href="#3-9-1-数组类型定义" class="headerlink" title="3.9.1 数组类型定义"></a>3.9.1 数组类型定义</h4><ol><li>简便数组类型表示法</li><li>泛型数组类型表示法</li></ol><p>简便数组类型表示法：<br>TElement[]<br>TElement代表数组元素的类型，[]代表数组类型。例：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> digits: <span class="built_in">number</span>[] = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>如果数组中元素为复合类型，例既有number又有string，TElement需要用分组运算符()包裹</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> red: (<span class="built_in">number</span> | <span class="built_in">string</span>)[] = [<span class="string">&#x27;red&#x27;</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>泛型数组类型表示法:泛型数组类型表示法就是使用泛型来表示数组类型,语法：<br>Array<TElement> Array代表数组类型；“<TElement>”是类型参数的语法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> digits1: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> red1: <span class="built_in">Array</span>&lt;<span class="built_in">number</span> | <span class="built_in">string</span>&gt; = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>, <span class="string">&#x27;red&#x27;</span>] <span class="comment">// 数组元素复合类型</span></span><br></pre></td></tr></table></figure><h4 id="3-9-2-数组元素类型"><a href="#3-9-2-数组元素类型" class="headerlink" title="3.9.2 数组元素类型"></a>3.9.2 数组元素类型</h4><p>在定义了数组类型之后，当访问数组元素时能够获得正确的元素类型信息。示例如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> digits1: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> zero: <span class="built_in">number</span> = digits1[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">const</span> zero1 = digits1[<span class="number">0</span>] <span class="comment">// zero1 为number</span></span><br><span class="line"><span class="keyword">const</span> out: <span class="built_in">number</span> = digits1[<span class="number">100</span>] <span class="comment">// 及时越界还是会得到声明的数组元素类型</span></span><br></pre></td></tr></table></figure><h4 id="3-9-3-只读数组"><a href="#3-9-3-只读数组" class="headerlink" title="3.9.3 只读数组"></a>3.9.3 只读数组</h4><p>只读数组与常规数组的区别在于，只读数组仅允许程序读取数组元素而不允许修改数组元素。</p><p>ts提供以下3种方式定义只读数组：</p><ol><li>使用ReadonlyArray<T>内置类型</li><li>使用readonly修饰符</li><li>使用Readonly<T>工具类型</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> red: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = [<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="keyword">const</span> green: <span class="keyword">readonly</span> <span class="built_in">number</span>[] = [<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>] <span class="comment">// readonly不允许和泛型数组表示法一起使用</span></span><br><span class="line"><span class="keyword">const</span> green1: <span class="keyword">readonly</span> <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>] <span class="comment">// wrong</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> blue: Readonly&lt;<span class="built_in">number</span>[]&gt; = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>] <span class="comment">// 类型参数T的值为数组类型“number[]”，而不是数组元素类型number</span></span><br></pre></td></tr></table></figure><p>注：在进行赋值操作时，允许将常规数组类型赋值给只读数组类型，但是不允许将只读数组类型赋值给常规数组类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> digits: <span class="built_in">number</span>[] = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">const</span> ra: <span class="keyword">readonly</span> <span class="built_in">number</span>[] = digits</span><br><span class="line"><span class="keyword">const</span> a: <span class="built_in">number</span>[] = arr <span class="comment">// wrong</span></span><br></pre></td></tr></table></figure><h3 id="3-10-元组类型"><a href="#3-10-元组类型" class="headerlink" title="3.10 元组类型"></a>3.10 元组类型</h3><p>元组表示有限元素构成的有序列表，js没有元组定义，ts中使用数组表示元组。<br>在ts中元组是数组的子类型，元组是长度固定的数组，并且数组中每个元素类型都是确定的。</p><h4 id="3-10-1-元组的定义"><a href="#3-10-1-元组的定义" class="headerlink" title="3.10.1 元组的定义"></a>3.10.1 元组的定义</h4><p>语法如下：<br>[T0, T1, …Tn]<br>该语法中的T0、T1和Tn表示元组中元素的类型，针对元组中每一个位置上的元素都需要定义其数据类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> point: [<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="keyword">const</span> score: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">&#x27;math&#x27;</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure><p>赋值时必须保持类型兼容和数量一致</p><h4 id="3-10-2-只读元组"><a href="#3-10-2-只读元组" class="headerlink" title="3.10.2 只读元组"></a>3.10.2 只读元组</h4><p>只读元组类型是只读数组类型的子类型。定义只读元组有以下两种方式：</p><ol><li>使用readonly修饰符</li><li>使用Readonly<T>工具类型</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> point: <span class="keyword">readonly</span> [<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="keyword">const</span> score: Readonly&lt;[<span class="built_in">string</span>, <span class="built_in">number</span>]&gt; = [<span class="string">&#x27;math&#x27;</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure><p>注：在给只读元组类型赋值时，允许将常规元组赋值给只读元组类型，不允许将只读元组赋值给常规元组类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> point: [<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> point1: <span class="keyword">readonly</span> [<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x: <span class="keyword">readonly</span> [<span class="built_in">number</span>, <span class="built_in">number</span>] = point</span><br><span class="line"><span class="keyword">const</span> y: [<span class="built_in">number</span>, <span class="built_in">number</span>] = point1 <span class="comment">// wrong</span></span><br></pre></td></tr></table></figure><h4 id="3-10-3-访问元组中的元素"><a href="#3-10-3-访问元组中的元素" class="headerlink" title="3.10.3　访问元组中的元素"></a>3.10.3　访问元组中的元素</h4><p>在访问元组中指定位置上的元素时，编译器能够推断出相应的元素类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> score: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">&#x27;math&#x27;</span>, <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = score[<span class="number">0</span>] <span class="comment">// string</span></span><br><span class="line"><span class="keyword">const</span> b = score[<span class="number">1</span>] <span class="comment">// number</span></span><br><span class="line"><span class="keyword">const</span> c: <span class="built_in">number</span> = score[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">const</span> d = score[<span class="number">2</span>] <span class="comment">// wrong 访问元组中不存在元素编译错误</span></span><br></pre></td></tr></table></figure><h4 id="3-10-4-元组类型中的可选元素"><a href="#3-10-4-元组类型中的可选元素" class="headerlink" title="3.10.4 元组类型中的可选元素"></a>3.10.4 元组类型中的可选元素</h4><p>定义元组可选元素的语法是在元素类型之后添加一个问号“?”，具体语法如下所示：<br>[T0?, T1?, …Tn?]<br>如果元组中同时存在可选元素和必选元素，那么可选元素必须位于必选元素之后，具体语法如下所示：<br>[T0, T1?, …, Tn?]</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tuple: [<span class="built_in">boolean</span>, <span class="built_in">string</span>?, <span class="built_in">number</span>?] = [<span class="literal">true</span>, <span class="string">&#x27;yes&#x27;</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">tuple = [<span class="literal">true</span>];</span><br><span class="line">tuple = [<span class="literal">true</span>, <span class="string">&#x27;yes&#x27;</span>];</span><br><span class="line">tuple = [<span class="literal">true</span>, <span class="string">&#x27;yes&#x27;</span>, <span class="number">1</span>];</span><br></pre></td></tr></table></figure><h4 id="3-10-5-元组类型中的剩余元素"><a href="#3-10-5-元组类型中的剩余元素" class="headerlink" title="3.10.5　元组类型中的剩余元素"></a>3.10.5　元组类型中的剩余元素</h4><p>语法：[…T[]]<br>T表示剩余元素的类型。</p><p>如果元组类型的定义中含有剩余元素，那么该元组的元素数量是开放的，它可以包含零个或多个指定类型的剩余元素。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tuple: [<span class="built_in">number</span>, ...string[]];</span><br><span class="line"></span><br><span class="line">tuple = [<span class="number">0</span>];</span><br><span class="line">tuple = [<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">tuple = [<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">tuple = [<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br></pre></td></tr></table></figure><h4 id="3-10-6-元组的长度"><a href="#3-10-6-元组的长度" class="headerlink" title="3.10.6　元组的长度"></a>3.10.6　元组的长度</h4><p>对于不包含可选元素和剩余元素的元组而言，元组中元素的数量是固定的。<br>TypeScript编译器能够识别出元组的长度并充分利用该信息来进行类型检查</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">point: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 编译器推断出length的类型为数字字面量类型2</span></span><br><span class="line">    <span class="keyword">const</span> length = point.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (length === <span class="number">3</span>) &#123;       <span class="comment">// 编译错误！条件表达式永远为 false</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于包含可选元素的元组，元组长度不固定，编译器能够根据元组可选元素识别出元组所有可能的长度，构造出一个联合类型来表示元组的长度</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tuple: [<span class="built_in">boolean</span>, <span class="built_in">string</span>?, <span class="built_in">number</span>?] = [<span class="literal">true</span>, <span class="string">&#x27;yes&#x27;</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> len = tuple.length <span class="comment">// 1|2|3</span></span><br><span class="line">len = <span class="number">1</span></span><br><span class="line">len = <span class="number">2</span></span><br><span class="line">len = <span class="number">3</span></span><br><span class="line">len = <span class="number">4</span> <span class="comment">//wrong: Type &#x27;4&#x27; is not assignable to type &#x27;1 | 2 | 3&#x27;.</span></span><br></pre></td></tr></table></figure><p>如果元组类型中定义了剩余元素，该元组length属性的类型将放宽为number类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tuple: [<span class="built_in">number</span>, ...string[]] = [<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> len = tuple.length <span class="comment">// number</span></span><br></pre></td></tr></table></figure><h4 id="3-10-7-元组类型与数组类型的兼容性"><a href="#3-10-7-元组类型与数组类型的兼容性" class="headerlink" title="3.10.7　元组类型与数组类型的兼容性"></a>3.10.7　元组类型与数组类型的兼容性</h4><p>元组类型是数组类型的子类型，只读元组类型是只读数组类型的子类型,允许将元组类型赋值给类型兼容的元组类型和数组类型<br>元组类型允许赋值给常规数组类型和只读数组类型，但只读元组类型只允许赋值给只读数组类型<br>由于数组类型是元组类型的父类型，因此不允许将数组类型赋值给元组类型</p><h3 id="3-11-对象类型"><a href="#3-11-对象类型" class="headerlink" title="3.11 对象类型"></a>3.11 对象类型</h3><p>三种基本的对象类型：</p><p>  Object类型（首字母为大写字母O）<br>  object类型（首字母为小写字母o）<br>  对象类型字面量</p><h4 id="3-11-1-Object"><a href="#3-11-1-Object" class="headerlink" title="3.11.1 Object"></a>3.11.1 Object</h4><p>这里的Object是指Object类型而不是Object()构造函数。<br>Object.prototype是一个特殊的对象，是js中的公共原型对象。<br>Object类型是Object.prototype对象的类型。主要作用是描述js中几乎所有共享（通过原型继承）的属性和方法。</p><p>类型兼容性：除了undefined和null外其他类型都可以赋值给Object类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="built_in">Object</span></span><br><span class="line">x = <span class="literal">true</span></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">x = <span class="string">&#x27;str&#x27;</span></span><br><span class="line">x = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">x = <span class="literal">undefined</span> <span class="comment">// 编译错误：Type &#x27;undefined&#x27; is not assignable to type &#x27;Object&#x27;.</span></span><br><span class="line">x = <span class="literal">null</span> <span class="comment">// 编译错误： Type &#x27;null&#x27; is not assignable to type &#x27;Object&#x27;.</span></span><br></pre></td></tr></table></figure><p>Object类型描述了所有对象共享的属性和方法，而JavaScript允许在原始值上直接访问这些方法，因此TypeScript允许将原始值赋值给Object类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str: <span class="built_in">Object</span> = <span class="string">&#x27;str&#x27;</span></span><br><span class="line">str.valueOf()</span><br></pre></td></tr></table></figure><p>js存在自动封箱操作，当在原始值上调用某个方法时，js会对原始值进行封箱操作，并将其转化为对象类型，然后再调用相应的方法。</p><p>封箱（boxing）指将原始值包装成一个对象的过程，执行封箱操作后，就能像使用对象一样使用原始数据类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动封箱，将&#x27;hi&#x27;转换为String对象类型</span></span><br><span class="line"><span class="string">&#x27;hi&#x27;</span>.toUpperCase();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动封箱，将3转换为Number对象类型</span></span><br><span class="line"><span class="comment">// 注意：这里使用了两个点符号</span></span><br><span class="line"><span class="number">3.</span>.toString()</span><br></pre></td></tr></table></figure><p>注：不要将Object类型应用于自定义变量，参数或属性等类型，因为Object类型是Object.prototype对象的类型，是所有对象共享的属性和方法。</p><h4 id="3-11-2-object"><a href="#3-11-2-object" class="headerlink" title="3.11.2 object"></a>3.11.2 object</h4><p>非原始类型。<br>在object类型中不允许读取和访问自定义属性，只允许访问对象的共享属性和方法，也就是Object类型中定义的属性和方法。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj: <span class="built_in">object</span> = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;</span><br><span class="line">obj.x <span class="comment">// 编译错误 Property &#x27;x&#x27; does not exist on type &#x27;object&#x27;.</span></span><br><span class="line"></span><br><span class="line">obj.toString() <span class="comment">// right</span></span><br></pre></td></tr></table></figure><p>不允许将原始类型赋值给object类型，这和Object类型不一样，Object类型允许将原始类型赋值给它。<br>只要非原始类型也就是对象类型才能赋值给object类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nonPrimitive: <span class="built_in">object</span>;</span><br><span class="line"><span class="comment">// wrong</span></span><br><span class="line">nonPrimitive = <span class="number">1</span></span><br><span class="line">nonPrimitive = <span class="literal">true</span></span><br><span class="line">nonPrimitive = <span class="string">&#x27;str&#x27;</span></span><br><span class="line">nonPrimitive = <span class="literal">undefined</span></span><br><span class="line">nonPrimitive = <span class="literal">null</span></span><br><span class="line">nonPrimitive = <span class="built_in">Symbol</span>()</span><br><span class="line">nonPrimitive = <span class="number">1n</span></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">nonPrimitive = &#123;&#125;;</span><br><span class="line">nonPrimitive = &#123; <span class="attr">x</span>: <span class="number">0</span> &#125;;</span><br><span class="line">nonPrimitive = [<span class="number">0</span>];</span><br><span class="line">nonPrimitive = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">nonPrimitive = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure><p>object类型仅能够赋值给3种类型：</p><ol><li>顶端类型any和unknown: 因为任何类型都是顶端类型的子类型</li><li>Object类型</li><li>空对象类型字面量{}</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nonPrimitive: <span class="built_in">object</span> = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a: <span class="built_in">any</span> = nonPrimitive;</span><br><span class="line"><span class="keyword">const</span> b: unknown = nonPrimitive;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj: <span class="built_in">Object</span> = nonPrimitive</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1: &#123;&#125; = nonPrimitive</span><br></pre></td></tr></table></figure><h4 id="3-11-3-对象类型字面量"><a href="#3-11-3-对象类型字面量" class="headerlink" title="3.11.3 对象类型字面量"></a>3.11.3 对象类型字面量</h4><p>对象类型字面量是定义对象类型的方法之一。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> point: &#123; <span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>&#125; = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><p>对象类型字面量的类型成员可分为以下五类：</p><ol><li>属性签名</li><li>调用签名</li><li>构造签名</li><li>方法签名</li><li>索引签名</li></ol><p>属性签名：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> point: &#123;<span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span> &#125; = &#123; <span class="attr">x</span>:<span class="number">0</span>, <span class="attr">y</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可计算属性签名</span></span><br><span class="line"><span class="keyword">const</span> a: <span class="string">&#x27;a&#x27;</span> = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">let</span> obj: &#123;</span><br><span class="line">  [a]: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可计算属性名的类型为“unique symbol”类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1: &#123; x; y&#125; <span class="comment">// 允许省略签名类型，该属性类型默认为any</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">&#123;</span><br><span class="line">  x: <span class="built_in">any</span>; <span class="comment">// noImplicitAny启用时，编译错误</span></span><br><span class="line">  y: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选属性</span></span><br><span class="line"><span class="keyword">let</span> point1: &#123; <span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>, z?: <span class="built_in">number</span>&#125;</span><br><span class="line">point = &#123;<span class="attr">x</span>:<span class="number">0</span>,<span class="attr">y</span>:<span class="number">1</span>&#125;</span><br><span class="line">point = &#123;<span class="attr">x</span>:<span class="number">0</span>,<span class="attr">y</span>:<span class="number">1</span>, z=<span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只允许访问已经定义的必选属性和可选属性</span></span><br><span class="line">point.x;</span><br><span class="line">point.y;</span><br><span class="line">point.z;</span><br><span class="line"></span><br><span class="line">point.t; <span class="comment">// wrong</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只读属性</span></span><br><span class="line"><span class="keyword">let</span> point2 : &#123;</span><br><span class="line">  <span class="keyword">readonly</span> x: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">readonly</span> y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line">point2 = &#123; <span class="attr">x</span>:<span class="number">0</span>, <span class="attr">y</span>:<span class="number">0</span>&#125;</span><br><span class="line"><span class="comment">// 只读属性的值在初始化后不允许再被修改</span></span><br><span class="line">point2.x = <span class="number">1</span> <span class="comment">// wrong</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不允许在空对象类型访问任何自定义属性</span></span><br><span class="line"><span class="keyword">const</span> point3: &#123;&#125; = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;;</span><br><span class="line"> </span><br><span class="line">point3.x;</span><br><span class="line"><span class="comment">//    ~</span></span><br><span class="line"><span class="comment">//    编译错误！属性 &#x27;x&#x27; 不存在于类型 &#x27;&#123;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">point3.y;</span><br><span class="line"><span class="comment">//    ~</span></span><br><span class="line"><span class="comment">//    编译错误！属性 &#x27;y&#x27; 不存在于类型 &#x27;&#123;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在空对象类型字面量&#123;&#125;上，允许访问对象公共的属性和方法，也就是Object类型上定义的方法和属性。</span></span><br><span class="line">point3.valueOf()</span><br></pre></td></tr></table></figure><h4 id="3-11-4-弱类型"><a href="#3-11-4-弱类型" class="headerlink" title="3.11.4 弱类型"></a>3.11.4 弱类型</h4><p>弱类型同时满足以下条件的对象类型：</p><ol><li>对象类型中至少包含一个属性。</li><li>对象类型中所有属性都是可选属性。</li><li>对象类型中不包含字符串索引签名、数值索引签名、调用签名和构造签名</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> config: &#123;</span><br><span class="line">  url?: <span class="built_in">string</span>,</span><br><span class="line">  <span class="keyword">async</span>?: <span class="built_in">boolean</span>,</span><br><span class="line">  timeout?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-12-函数类型"><a href="#3-12-函数类型" class="headerlink" title="3.12 函数类型"></a>3.12 函数类型</h3><h4 id="3-12-1-常规参数类型"><a href="#3-12-1-常规参数类型" class="headerlink" title="3.12.1 常规参数类型"></a>3.12.1 常规参数类型</h4><p>函数形参类型定义：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数表达式和匿名函数</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y <span class="comment">// 参数x 和 y没有定义类型，也无法推断类型，那么x和y隐式获得any类型，如果启用了noImplicitAny,那么会产生编译错误，可以指明为any类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-12-2-可选函数参数类型"><a href="#3-12-2-可选函数参数类型" class="headerlink" title="3.12.2 可选函数参数类型"></a>3.12.2 可选函数参数类型</h4><p>在调用函数时，编译器会检查传入实际参数的个数与函数定义中形式参数的个数是否相等。如果两者不相等，则会产生编译错误。如果一个参数是可选参数，那么就需要在函数类型定义中明确指定。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可选参数位于必选参数后面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y?: <span class="built_in">number</span>, z?: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + (y ?? <span class="number">0</span>) + (z ?? <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-12-3-默认参数类型"><a href="#3-12-3-默认参数类型" class="headerlink" title="3.12.3 默认参数类型"></a>3.12.3 默认参数类型</h4><p>如果定义了默认参数，并且默认参数在参数列表的末尾，那么该参数将被视为可选参数。例：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y <span class="comment">// y为可选参数，其类型被推断为number</span></span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">3</span>) <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span> = <span class="number">0</span>, y: <span class="built_in">number</span></span>) </span>&#123;&#125; <span class="comment">// 此时x不是可选参数，为必选参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x?: <span class="built_in">number</span> = <span class="number">0</span></span>) </span>&#123;&#125; <span class="comment">// 编译错误，同一个参数不能同时出现默认参数和可选参数</span></span><br></pre></td></tr></table></figure><h4 id="3-12-4-剩余参数类型"><a href="#3-12-4-剩余参数类型" class="headerlink" title="3.12.4 剩余参数类型"></a>3.12.4 剩余参数类型</h4><p>剩余参数类型处理的是多个参数，剩余参数类型应该为数组类型或者元组类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">...args: <span class="built_in">number</span>[]</span>) </span>&#123;&#125;</span><br><span class="line">f()</span><br><span class="line">f(<span class="number">1</span>)</span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元组类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">...args: [<span class="built_in">boolean</span>, <span class="built_in">number</span>]</span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">args_0: <span class="built_in">boolean</span>, args_1: <span class="built_in">number</span></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选元素的元组类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f0</span>(<span class="params">...args: [<span class="built_in">boolean</span>, <span class="built_in">string</span>?]</span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">args_0: <span class="built_in">boolean</span>, args_1?: <span class="built_in">string</span></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带有剩余元素的元组类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f0</span>(<span class="params">...args: [<span class="built_in">boolean</span>, ...<span class="built_in">string</span>[]]</span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">args_0: <span class="built_in">boolean</span>, ...args_1: <span class="built_in">string</span>[]</span>)</span></span><br></pre></td></tr></table></figure><h4 id="3-12-5-解构参数类型"><a href="#3-12-5-解构参数类型" class="headerlink" title="3.12.5 解构参数类型"></a>3.12.5 解构参数类型</h4><p>解构可以用在函数参数列表中。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f0</span>(<span class="params">[x,y]</span>) </span>&#123;&#125;</span><br><span class="line">f0([<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">&#123;x,y&#125;</span>) </span>&#123;&#125;</span><br><span class="line">f1(&#123;<span class="attr">x</span>:<span class="number">0</span>,<span class="attr">y</span>:<span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类型注解为解构参数添加类型信息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f0</span>(<span class="params">[x,y]: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) </span>&#123;&#125;</span><br><span class="line">f0([<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">&#123;x,y&#125;: &#123;x: <span class="built_in">number</span>, y: <span class="built_in">number</span>&#125;</span>) </span>&#123;&#125;</span><br><span class="line">f1(&#123;<span class="attr">x</span>:<span class="number">0</span>,<span class="attr">y</span>:<span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure><h4 id="3-12-6-返回值类型"><a href="#3-12-6-返回值类型" class="headerlink" title="3.12.6　返回值类型"></a>3.12.6　返回值类型</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f0</span>(<span class="params"></span>):<span class="title">void</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>):<span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span> <span class="comment">// right</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// wrong</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span> <span class="comment">// wrong</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span> <span class="comment">// wrong</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// strictNullChecks= false void类型返回值可以返回null值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-12-7-函数类型字面量"><a href="#3-12-7-函数类型字面量" class="headerlink" title="3.12.7 函数类型字面量"></a>3.12.7 函数类型字面量</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> add: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f: <span class="function">(<span class="params"><span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">//      ~~~~~~</span></span><br><span class="line"><span class="comment">//      编译错误 形参必须命名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 形参和实际参数名不必相同</span></span><br><span class="line"><span class="keyword">let</span> f: <span class="function">(<span class="params">x: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">f = <span class="function"><span class="keyword">function</span> (<span class="params">y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar: <span class="function">() =&gt;</span> ; <span class="comment">// 编译错误，必须指定函数返回值类型</span></span><br></pre></td></tr></table></figure><h4 id="3-12-8-调用签名"><a href="#3-12-8-调用签名" class="headerlink" title="3.12.8 调用签名"></a>3.12.8 调用签名</h4><p>函数是一个可调用的对象，可以用对象类型来表示函数类型。<br>若在对象类型中定义了调用签名类型成员，那么我们称该对象类型为调用签名类型。语法：<br>{<br>  (parameterList): Type<br>}<br>parameterList表示函数参数形式参数列表类型，Type表示返回值类型，两者都是可选的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add: &#123; <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> &#125;</span><br><span class="line">add = <span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数类型字母量完全等同于仅包含一个类型成员且是调用签名类型的对象类型字面量</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  (parameterList) : Type</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简写为：</span></span><br><span class="line">(parameterList) =&gt; Type</span><br><span class="line"><span class="comment">// 函数类型字面量</span></span><br><span class="line"><span class="keyword">const</span> abs0: <span class="function">(<span class="params">x: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="built_in">Math</span>.abs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用签名</span></span><br><span class="line"><span class="keyword">const</span> abs1: &#123; (x: <span class="built_in">number</span>): <span class="built_in">number</span> &#125; = <span class="built_in">Math</span>.abs</span><br><span class="line"></span><br><span class="line">abs0(-<span class="number">1</span>) === abs1(-<span class="number">1</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="3-12-9-构造函数类型字面量"><a href="#3-12-9-构造函数类型字面量" class="headerlink" title="3.12.9 构造函数类型字面量"></a>3.12.9 构造函数类型字面量</h4><p>构造函数用来创建和初始化对象，比如js内置构造函数Date，const date = new Date()</p><p>构造函数类型字面量定义构造函数类型方法之一，语法如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> (parameterList) =&gt; Type</span><br></pre></td></tr></table></figure><p>new关键字，parameterList构造函数形式参数列表类型，Type是返回值类型<br>JavaScript提供了一个内置的Error构造函数，它接受一个可选的message作为参数并返回新创建的Error对象，示例如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="built_in">Error</span>()</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error message&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用构造函数字面量来表示Error构造函数类型</span></span><br><span class="line"><span class="keyword">let</span> ErrorConsturctior: <span class="keyword">new</span> (message?: <span class="built_in">string</span>) =&gt; <span class="built_in">Error</span></span><br></pre></td></tr></table></figure><h4 id="3-12-10-构造签名"><a href="#3-12-10-构造签名" class="headerlink" title="3.12.10 构造签名"></a>3.12.10 构造签名</h4><p>构造签名与调用签名类似，若在对象类型中定义了构造签名类型成员，那么称该对象为构造签名类型，语法如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">new</span> (parameterList): Type </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>new是运算符关键字，ParameterList表示构造函数形式参数列表类型，Type表示构造函数返回值类型，两者都是可选的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Dog: &#123; <span class="keyword">new</span> (name: <span class="built_in">string</span>): <span class="built_in">Object</span> &#125;</span><br><span class="line">Dog = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog(<span class="string">&#x27;huahua&#x27;</span>)</span><br></pre></td></tr></table></figure><p>构造函数字面量完全等同于一个仅包含一个构造函数签名类型的成员的对象类型字面量。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">new</span> (parameterList): Type</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简写为：</span></span><br><span class="line"><span class="keyword">new</span> (parameterList) =&gt; Type</span><br></pre></td></tr></table></figure><h4 id="3-12-11-调用签名和构造签名"><a href="#3-12-11-调用签名和构造签名" class="headerlink" title="3.12.11 调用签名和构造签名"></a>3.12.11 调用签名和构造签名</h4><p>有一些函数被设计为既可以作为普通函数使用，同时又可以作为构造函数来使用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a: <span class="built_in">number</span> = <span class="built_in">Number</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> b: <span class="built_in">Number</span> = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>在对象类型中同时定义调用签名和构造签名，既可以被调用，又可以作为构造函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">new</span> (x: <span class="built_in">number</span>): <span class="built_in">Number</span>; <span class="comment">// 构造签名</span></span><br><span class="line">  (x: <span class="built_in">number</span>): <span class="built_in">number</span> <span class="comment">// 调用签名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> F: &#123;</span><br><span class="line">  <span class="keyword">new</span> (x: <span class="built_in">number</span>): <span class="built_in">Number</span>; <span class="comment">// 构造签名</span></span><br><span class="line">  (x: <span class="built_in">number</span>): <span class="built_in">number</span> <span class="comment">// 调用签名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a: <span class="built_in">number</span> = F(<span class="number">1</span>) <span class="comment">// 普通函数调用</span></span><br><span class="line"><span class="keyword">const</span> b: <span class="built_in">Number</span> = <span class="keyword">new</span> F(<span class="number">1</span>) <span class="comment">// 构造函数调用</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-12-12-重载函数"><a href="#3-12-12-重载函数" class="headerlink" title="3.12.12 重载函数"></a>3.12.12 重载函数</h4><p>重载函数是指一个函数同时拥有多个同类的函数签名，比如一个函数拥有2个及以上调用签名，一个构造函数同时拥有2个及以上构造签名。<br>函数重载定义组成：</p><ol><li>一条或多条函数重载语句</li><li>一条函数实现语句</li></ol><p>函数重载：不带有函数体的函数声明语句。只存在于代码编译阶段，生成js代码后会被删除</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span></span>; <span class="comment">// 函数重载</span></span><br></pre></td></tr></table></figure><p>函数重载允许存在一个或多个，只有多于1个的才有意义。函数重载不允许使用默认参数，函数重载位于函数体实现之前，必须和函数实现中的函数名一致。例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">any</span>[], y: <span class="built_in">any</span>[]</span>): <span class="title">any</span>[]</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">any</span>[], y: <span class="built_in">number</span> | <span class="built_in">any</span>[]</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 实现代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数重载和函数重载，函数重载和函数体实现语句中间不允许出现别的语句，否则编译错误。</p><p>函数实现：包含了函数体代码，存在编译前和编译后，只允许有一个函数实现且位于所有函数重载之后。</p><p>函数实现必须兼容每个函数重载中的函数签名。函数实现的函数签名类型必须能够赋值给函数重载的函数签名类型。</p><h4 id="3-12-13-函数中this值的类型"><a href="#3-12-13-函数中this值的类型" class="headerlink" title="3.12.13 函数中this值的类型"></a>3.12.13 函数中this值的类型</h4><p>this是js中关键字，表示调用函数的对象或实例对象。<br>默认情况，编译器会将函数中的this值设为any类型，允许程序在this上执行任意的操作。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 以下语句均没有错误</span></span><br><span class="line">  <span class="built_in">this</span>.a = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">this</span>.b++;</span><br><span class="line">  <span class="built_in">this</span>.c = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当启用了–noImplicitThis编译选项时，如果this值默认获得了any类型，那么将产生编译错误；如果函数体中没有引用this值，则没有任何影响.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 以下语句均没有错误</span></span><br><span class="line">  <span class="built_in">this</span>.a = <span class="literal">true</span>; <span class="comment">// &#x27;this&#x27; implicitly has type &#x27;any&#x27; because it does not have a type annotation.</span></span><br><span class="line">  <span class="built_in">this</span>.b++; <span class="comment">// wrong  this隐式地any类型，因为没有给this添加类型注解</span></span><br><span class="line">  <span class="built_in">this</span>.c = <span class="function">() =&gt;</span> &#123;&#125;; <span class="comment">// wrong</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ts支持在函数形式参数列表中定义this参数来描述this值的类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"><span class="built_in">this</span>: &#123;name: <span class="built_in">string</span>&#125;</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;str&#x27;</span></span><br><span class="line">    <span class="built_in">this</span>.name = <span class="number">0</span> <span class="comment">// wrong: Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this参数固定使用this作为参数名，是可选参数，若存在必须在形式参数列表的第一位。this参数的类型即为函数体中this值的类型。<br>this参数不同于常规的函数形式参数，它只存在于编译阶段，在编译生成的JavaScript代码中会被完全删除，在运行时的代码中不存在这个this参数。</p><p>如果我们想要定义一个纯函数或者是不想让函数代码依赖于this的值，那么在这种情况下可以明确地将this参数定义为void类型。这样做之后，在函数体中就不允许读写this的属性和方法</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"><span class="built_in">this</span>: <span class="built_in">void</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;str&#x27;</span> <span class="comment">// wrong: Property &#x27;name&#x27; does not exist on type &#x27;void&#x27;.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当调用定义了this参数的函数时，若this值的实际类型与函数定义中的期望类型不匹配，则会产生编译错误</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"><span class="built_in">this</span>: &#123; baz: <span class="built_in">string</span>&#125;, bar: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">0</span>) <span class="comment">// wrong: The &#x27;this&#x27; context of type &#x27;void&#x27; is not assignable to method&#x27;s &#x27;this&#x27; of type &#x27;&#123; baz: string; &#125;&#x27;.</span></span><br><span class="line">foo(&#123;<span class="attr">baz</span>: <span class="string">&#x27;str&#x27;</span>&#125;, <span class="string">&#x27;str&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="3-13-接口"><a href="#3-13-接口" class="headerlink" title="3.13 接口"></a>3.13 接口</h3><p>接口也能表示对象类型，只在编译阶段存在，无法表示原始类型</p><h4 id="3-13-1-接口声明"><a href="#3-13-1-接口声明" class="headerlink" title="3.13.1 接口声明"></a>3.13.1 接口声明</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> InterfaceName &#123;</span><br><span class="line">  TypeMember,</span><br><span class="line">  TypeMember,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>interface关键字，InterfaceName接口名，它必须是合法的标识符通常首字母大写；TypeMember表示接口的类型成员。<br>接口类型的类型成员分为：</p><ol><li>属性签名</li><li>调用签名</li><li>构造签名</li><li>方法签名</li><li>索引签名</li></ol><h4 id="3-13-2-属性签名"><a href="#3-13-2-属性签名" class="headerlink" title="3.13.2 属性签名"></a>3.13.2 属性签名</h4><p>PropertyName: Type; PropertyName表示对象名称，可以为标识符、字符串、数字和可计算属性名；Type表示属性类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span>,</span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-13-3-调用签名"><a href="#3-13-3-调用签名" class="headerlink" title="3.13.3 调用签名"></a>3.13.3 调用签名</h4><p>调用签名定义了该对象类型表示的函数在调用时的类型参数、参数列表和返回值类型。<br>(parameterList): Type<br>ParameterList表示函数形式参数列表类型；Type表示函数返回值类型，两者都是可选的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ErrorConsturctior &#123;</span><br><span class="line">  (message?: <span class="built_in">string</span>): <span class="built_in">Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-13-4-构造签名"><a href="#3-13-4-构造签名" class="headerlink" title="3.13.4 构造签名"></a>3.13.4 构造签名</h4><p>构造签名定义了该对象类型表示的构造函数在使用new运算符调用时的参数列表和返回类型。</p><p>new (parameterList): Type</p><p>new是运算符关键字；ParameterList表示构造函数形式参数列表类型；Type表示构造函数返回值类型，两者都是可选的.</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ErrorConsturctior &#123;</span><br><span class="line">  <span class="keyword">new</span> (message?: <span class="built_in">string</span>): <span class="built_in">Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-13-5-方法签名"><a href="#3-13-5-方法签名" class="headerlink" title="3.13.5 方法签名"></a>3.13.5 方法签名</h4><p>方法签名是声明函数类型的属性成员的简写。<br>PropertyName(parameterList): Type</p><p>PropertyName表示对象属性名，可以是标识符，数字，字符串，可计算的属性名；<br>parameterList为可选的方法形式参数列表类型；<br>Type为可选的方法返回值类型。<br>方法签名是在调用签名之前加属性名作为方法名。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Document &#123;</span><br><span class="line">  getElementById(elementId: <span class="built_in">string</span>): HTMLElement | <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-13-6-索引签名"><a href="#3-13-6-索引签名" class="headerlink" title="3.13.6 索引签名"></a>3.13.6 索引签名</h4><p>js支持使用索引去访问对象的属性，即通过方括号”[]”语法去访问对象属性。<br>索引签名有2种：</p><ol><li>字符串索引签名</li><li>数值索引签名</li></ol><p>字符串索引签名：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[indexName: <span class="built_in">string</span>]: Type</span><br></pre></td></tr></table></figure><p>indexName表示索引名，任意合法的标识符必须为string类型.索引名只起占位作用，不代表真实的对象属性名；<br>Type表示索引值的类型，可以为任意类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  [prop: <span class="built_in">number</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj: A = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">obj[<span class="number">0</span>] <span class="comment">// string</span></span><br></pre></td></tr></table></figure><p>若接口中同时存在字符串索引和数字索引，那么数值索引的类型必须能够赋值给字符串索引的签名的类型，因为在js中属性名只能为字符串或Symbol。js也允许使用数字等其他值作为索引，但最终会被转换为字符串类型。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  [prop: <span class="built_in">string</span>]: <span class="built_in">number</span>,</span><br><span class="line">  [prop: <span class="built_in">number</span>]: <span class="number">0</span> | <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  [prop: <span class="built_in">string</span>]: <span class="number">0</span> | <span class="number">1</span>,</span><br><span class="line">  [prop: <span class="built_in">number</span>]: <span class="built_in">number</span> <span class="comment">// 编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-13-7-可选属性和方法"><a href="#3-13-7-可选属性和方法" class="headerlink" title="3.13.7 可选属性和方法"></a>3.13.7 可选属性和方法</h4><p>默认情况下，接口中属性签名和方法签名定义的对象属性都是必选的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Foo &#123;</span><br><span class="line">    x: <span class="built_in">string</span>,</span><br><span class="line">    y(): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a: Foo = &#123; <span class="attr">x</span>: <span class="string">&#x27;hi&#x27;</span>&#125; <span class="comment">// wrong 缺少属性y</span></span><br><span class="line"><span class="keyword">const</span> b: Foo = &#123; <span class="function"><span class="title">y</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;&#125; <span class="comment">// wrong 缺少属性x</span></span><br><span class="line"><span class="keyword">const</span> c: Foo = &#123; <span class="comment">// right</span></span><br><span class="line">    x: <span class="string">&#x27;hi&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">y</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在属性名或者方法名后面添加?表示可选</p><p>propertyName?: Type<br>propertyName?(parameterList): Type</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Foo &#123;</span><br><span class="line">    x?: <span class="built_in">string</span>,</span><br><span class="line">    y?(): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a: Foo = &#123; <span class="attr">x</span>: <span class="string">&#x27;hi&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> b: Foo = &#123; <span class="function"><span class="title">y</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;&#125;</span><br><span class="line"><span class="keyword">const</span> c: Foo = &#123;</span><br><span class="line">    x: <span class="string">&#x27;hi&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">y</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> d: Foo = &#123;&#125;</span><br></pre></td></tr></table></figure><p>如果接口中定义了重载方法，那么所有重载方法签名必须同时为必须或可选的。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Foo &#123;</span><br><span class="line">    a(): <span class="built_in">void</span>,</span><br><span class="line">    a(x: <span class="built_in">string</span>): <span class="built_in">void</span>,</span><br><span class="line"></span><br><span class="line">    b?(): <span class="built_in">void</span>,</span><br><span class="line">    b?(x: <span class="built_in">string</span>): <span class="built_in">void</span></span><br><span class="line"></span><br><span class="line">    c(): <span class="built_in">void</span>,</span><br><span class="line">    c?(x: <span class="built_in">string</span>): <span class="built_in">void</span> <span class="comment">// wrong 重载方法签名必须同时为可选的或必选的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-13-8-只读属性和方法"><a href="#3-13-8-只读属性和方法" class="headerlink" title="3.13.8 只读属性和方法"></a>3.13.8 只读属性和方法</h4><p>在接口声明中，readonly修复符能够定义只读属性，readonly修饰符只允许在属性签名和索引签名中使用。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    <span class="keyword">readonly</span> a: <span class="built_in">string</span>,</span><br><span class="line">    <span class="keyword">readonly</span> [prop: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若接口中只定义了只读的索引签名，那么接口中所有属性都是只读的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    <span class="keyword">readonly</span> [prop: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj: A = &#123; <span class="attr">x</span>: <span class="string">&#x27;a&#x27;</span> &#125;</span><br><span class="line">obj[x] = <span class="string">&#x27;b&#x27;</span> <span class="comment">// wrong 只读</span></span><br></pre></td></tr></table></figure><p>如果接口中既定义了只读索引签名，又定义了非只读的属性签名，那么非只读的属性签名定义的属性依旧是非只读的，除此之外的所有属性都是只读的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    <span class="keyword">readonly</span> [prop: <span class="built_in">string</span>]: <span class="built_in">number</span>,</span><br><span class="line">    x: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj: A = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span>&#125;</span><br><span class="line">obj[<span class="string">&#x27;x&#x27;</span>] = <span class="number">2</span></span><br><span class="line">obj[<span class="string">&#x27;y&#x27;</span>] = <span class="number">2</span> <span class="comment">// wrong 只读</span></span><br></pre></td></tr></table></figure><h4 id="3-13-9-接口的继承"><a href="#3-13-9-接口的继承" class="headerlink" title="3.13.9 接口的继承"></a>3.13.9 接口的继承</h4><p>接口可以继承其他的对象类型，这相当于将对象类型中成员复制到当前接口中，可以继承的对象类型如下：</p><ol><li>接口</li><li>对象类型的类型别名</li><li>类</li><li>对象类型的交叉类型</li></ol><p>接口继承需要使用extends关键字。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Style &#123;</span><br><span class="line">    color: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Cricle <span class="keyword">extends</span> Shape, Style &#123;</span><br><span class="line">    radius: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c: Cricle = &#123;</span><br><span class="line">    name: <span class="string">&#x27;circle&#x27;</span>,</span><br><span class="line">    color: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">    radius: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果子接口与父接口之间存在同名的类型成员，那么子接口中的类型成员具有更高的优先级。同时，子接口与父接口中的同名类型成员必须是类型兼容的。也就是说，子接口中同名类型成员的类型需要能够赋值给父接口中同名类型成员的类型，否则将产生编译错误</p><p>如果仅是多个父接口之间存在同名的类型成员，而子接口本身没有该同名类型成员，那么父接口中同名类型成员的类型必须是完全相同的，否则将产生编译错误。解决方法是子接口中定义一个同名的类型成员，拥有更高的优先级，同时应兼容父接口的同名类型成员。</p><h3 id="3-14-类型别名"><a href="#3-14-类型别名" class="headerlink" title="3.14 类型别名"></a>3.14 类型别名</h3><h4 id="3-14-1-类型别名声明"><a href="#3-14-1-类型别名声明" class="headerlink" title="3.14.1 类型别名声明"></a>3.14.1 类型别名声明</h4><p>type AliasName = Type<br>在该语法中，type是声明类型别名的关键字；AliasName表示类型别名的名称；Type表示类型别名关联的具体类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point = &#123; <span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span> &#125;</span><br></pre></td></tr></table></figure><p>类型别名引用的类型可以为任意类型，例如原始类型、对象类型、联合类型和交叉类型等</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringType = <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BooleanType = <span class="literal">true</span> | <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point = &#123; <span class="attr">x</span>: <span class="built_in">number</span>; y: <span class="built_in">number</span>; z?: <span class="built_in">number</span> &#125;;</span><br></pre></td></tr></table></figure><p>在类型别名中，也可以引用其他类型别名</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Numeric = <span class="built_in">number</span> | bigint;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string | number | bigint</span></span><br><span class="line"><span class="keyword">type</span> StringOrNumber = <span class="built_in">string</span> | Numeric;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DecimalDigit = <span class="number">0</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span> | <span class="number">6</span> | <span class="number">7</span> | <span class="number">8</span> | <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> digit: DecimalDigit = <span class="number">6</span>; </span><br></pre></td></tr></table></figure><h4 id="3-14-2-递归的类型别名"><a href="#3-14-2-递归的类型别名" class="headerlink" title="3.14.2 递归的类型别名"></a>3.14.2 递归的类型别名</h4><p>一般情况下，在类型别名声明中赋值运算符的右侧不允许引用当前定义的类型别名。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T = T <span class="comment">// wrong</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入解析css</title>
      <link href="/ZJY.github.io/2022/07/14/css-%E7%AC%94%E8%AE%B0/"/>
      <url>/ZJY.github.io/2022/07/14/css-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="第一章-层叠、优先级和继承"><a href="#第一章-层叠、优先级和继承" class="headerlink" title="第一章 层叠、优先级和继承"></a>第一章 层叠、优先级和继承</h3><p>css里的c代表cascade,层叠，层叠决定了如何解决冲突，是css语言的基础。层叠会依据三种条件解决冲突。</p><p>(1) 样式表的来源：样式是从哪里来的，包括你的样式和浏览器默认样式等。</p><p>(2) 选择器优先级：哪些选择器比另一些选择器更重要。</p><p>(3) 源码顺序：样式在样式表里的声明顺序。</p><p>声明：color: black;<br>包含在大括号内的一组声明被称作一个声明块。<br>声明块前面有一个选择器.<br>选择器和声明块一起组成了规则集（ruleset）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>样式表的来源</p><p>你添加到网页里的样式表并不是浏览器唯一使用的样式表，还有其他类型或来源的样式表。你的样式表属于作者样式表，除此之外还有用户代理样式表，即浏览器默认样式。用户代理样式表优先级低，你的样式会覆盖它们.</p><p>! important声明会被当作更高优先级的来源，因此总体的优先级按照由高到低排列如下所示：<br>(1) 作者的！important<br>(2) 作者的样式表<br>(3) 用户代理样式表</p><p>层叠规则顺序：不同来源的声明-内联声明-选择器优先级声明-源码顺序声明</p></li><li><p>理解优先级</p><p>浏览器将优先级分为两部分：HTML的行内样式和选择器的样式。</p></li><li><p>行内样式<br>如果用HTML的style属性写样式，这个声明只会作用于当前元素。实际上行内元素属于“带作用域的”声明，它会覆盖任何来自样式表或者<code>&lt;style&gt;</code>标签的样式。行内样式没有选择器，因为它们直接作用于所在的元素</p></li><li><p>选择器优先级<br>伪类选择器（:hover）和属性选择器（[type=”input”]）与一个类选择器的优先级相同。<br>通用选择器（*）和组合选择器（&gt;,+,~）对优先级无影响。</p></li><li><p>源码顺序<br>层叠的第三步，也是最后一步，是源码顺序。如果两个声明的来源和优先级相同，其中一个声明在样式表中出现较晚，或者位于页面较晚引入的样式表中，则该声明胜出。</p></li><li><p>层叠值<br>浏览器遵循三个步骤，即来源，优先级，源码顺序来解析网页上每个元素的每个属性。<br>处理层叠的两条通用法则：<br>1.在选择器中不要使用ID<br>2.不要使用!important</p></li><li><p>继承</p><p>如果一个元素的某个属性没有层叠值，则可能继承祖先元素的值。比如给<code>&lt;body&gt;</code>元素加上font-family,<br>就不必给每个元素明确指定字体。但不是所有属性都能被继承。只有特定属性能被继承，主要和文本相关的<br>属性：<br> color、font、font-family、font-size、font-weight、font-variant、font-style、<br> line-height、letter-spacing、text-align、text-indent、text-transform、white-space<br> word-spacing</p><p>还有一些其他属性能被继承，比如列表属性：<br> list-style、list-style-type、list-style-position、list-style-image</p><p>表格的边框属性: border-collapse、border-spacing 也能被继承</p></li><li><p>特殊值</p><p>有两个特殊值可以赋给任意属性，用于控制层叠：inherit和initial</p></li><li><p>inherit关键字<br>可以用继承代替一个层叠值，比如覆盖另一个值，这样该元素就会继承其父元素的值。</p></li><li><p>initial关键字<br>每个css属性都有初始默认值，给属性设置initial会有效将其重置为默认值，比如给<code>&lt;body&gt;</code>设置color: #111; 那么默认的其子元素文本颜色都继承这个属性值，给其设置color: initial，会使其文本颜色变为<br>color: black; 因为黑色是color属性的初始值。</p><p>注：声明display: initial等价于display: inline。不管应用于哪种类型的元素，他都不会等于display:block。因为initial重置的是属性的初始值，而不是元素的初始值。inline才是display属性<br>的初始值。</p></li><li><p>简写属性</p><p>简写属性是用于同时给多个属性赋值的属性。比如font是一个简写属性，还有：background,border,border-width</p></li><li><p>简写属性会默默覆盖其他样式<br>大多数简写可以省略一些值，只指定我们关注的值，但这样仍然会设置省略的值，即它们会被隐式的设置为初始值initial.这样会覆盖其他定义的样式</p></li><li><p>理解简写值的顺序<br>可以设置border: 1px solid black或者border: black 1pxsolid，两者都会生效。这是因为浏览器知道宽度、颜色、边框样式分别对应什么类型的值。但是有很多属性的值很模糊。在这种情况下，值的顺序很关键</p><p>（1）上、右、下、左<br>margin、padding、边框属性<br>（2）水平、垂直<br>上右下左只适合给盒子设置四个方向的值的属性。还有一些属性只支持最多指定两个值，这些属性包括background-position、box-shadow、text-shadow，比如box-shadow: 10px 2px #000;<br>指定水平方向偏移量10px，垂直方向偏移量2px，先水平再垂直</p></li></ol><h3 id="第二章-相对单位"><a href="#第二章-相对单位" class="headerlink" title="第二章 相对单位"></a>第二章 相对单位</h3><p>1.em<br>em的复杂之处在于同时用它指定一个元素的字号和其他属性。这时，浏览器必须先计算字号，然后使用这个计算值去算出其余的属性值。这两类属性可以拥有一样的声明值，但是计算值不一样。<br>例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">  font-size: 1.2em; // 计算值为16*1.2=19.2px</span><br><span class="line">  padding: 1.2em; // 计算值为19.2*1.2=23.04px</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字体缩小的问题</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0.8em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span> <span class="comment">&lt;!-- font-size: 16px * 0.8 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>top level<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="comment">&lt;!-- font-size: 16px * 0.8 * 0.8 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>second level<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="comment">&lt;!-- font-size: 16px * 0.8 * 0.8 * 0.8--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>third level<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.rem<br>在文档中，根节点是所有其他元素的祖先节点。根节点有一个伪类选择器（:root），可以用来选中它自己。这等价于类型选择器html，但是html的优先级相当于一个类名，而不是一个标签.<br>rem是root em的缩写。rem不是相对于当前元素，而是相对于根元素的单位.不管在文档的什么位置使用rem,1.2rem都会有相同的计算值：1.2乘以根元素的字号.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;  <span class="comment">/*  :root伪类相当于类型选择器html */</span></span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1em</span>; <span class="comment">/* 根元素上的em是相对于浏览器默认值的，16px  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0.8rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿不准的时候，用rem设置字号，用px设置边框，用em设置其他大部分属性.</p><p>em和rem都是相对于font-size定义的。</p><p>3.视口的相对单位<br>视口——浏览器窗口里网页可见部分的边框区域。它不包括浏览器的地址栏、工具栏、状态栏。</p><p>vh：视口高度的1/100。<br>vw：视口宽度的1/100。<br>vmin：视口高度的1/100。1. vw：视口宽度的1/100。<br>vmax：视口宽、高中较大的一方的1/100。</p><p>当一个元素的宽和高为90vmin时，不管视口的大小或者方向是什么，总会显示成一个稍小于视口的正方形</p><p>vw可以结合calc()设置字号，对于iphone6 375到1200px，字号从11.75到20px</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="built_in">calc</span>(<span class="number">0.5em</span> + <span class="number">1vw</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.自定义属性即css变量</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attribute">--main-foot</span>: Arial, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="built_in">var</span>(--main-foot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>var()函数接受第二个参数，它指定了备用值。如果第一个参数指定的变量未定义，那么就会使用第二个值</p><p>如果var()函数算出来的是一个非法值，对应的属性就会设置为其初始值。比如，如果在padding: var(–brand-color)中的变量算出来是一个颜色，它就是一个非法的内边距值。这种情况下，内边距会设置为0.</p><p>自定义属性就像作用域变量一样,自定义属性就像作用域变量一样</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attribute">--main-color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.panel</span> &#123;</span><br><span class="line">  <span class="attribute">--main-color</span>: white</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--main-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>黑色<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;panel&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>白色<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用js改变属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rootElement = <span class="built_in">document</span>.documentElement;</span><br><span class="line">rootElement.style.setProperty(<span class="string">&#x27;--main-color&#x27;</span>, <span class="string">&#x27;#ccc&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="第三章-盒模型"><a href="#第三章-盒模型" class="headerlink" title="第三章 盒模型"></a>第三章 盒模型</h3><p>1.盒模型<br>box-sizing: content-box; 设置元素宽高只设置内容盒子大小<br>box-sizing: border-box; width和height属性会设置内容、内边距及边框的大小总和。</p><figure class="highlight plain"><figcaption><span>&#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  box-sizing: border-box;</span><br><span class="line">&#125;</span><br><span class="line">*,</span><br><span class="line">::before,</span><br><span class="line">::after &#123;</span><br><span class="line">  box-sizing: .inherit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>盒模型通常不会被继承，但是使用inherit关键字可以强制继承.这样可以不覆盖第三方组件的盒模型.</p><p>2.垂直居中<br>如果给块级元素设置vertical-align:middle;块级元素的内容不会垂直居中，vertical-align声明只会影响行内元素或者table-cell元素。对于行内元素，它控制着该元素跟同一行内其他元素之间的对齐关系。比如一行内图片和文字对齐方式。</p><p>3.负外边距<br>负外边距的具体行为取决于设置在元素的哪边。如果设置左边或顶部的负外边距，元素就会相应地向左或向上移动，导致元素与它前面的元素重叠，如果设置右边或者底部的负外边距，并不会移动元素，而是将它后面的元素拉过来。给元素底部加上负外边距并不等同于给它下面的元素顶部加上负外边距</p><p>4.外边距折叠<br>所有相邻的顶部和底部外边距会折叠到一起，即使两个元素不是相邻的兄弟节点也会产生外边距折叠。只有上下外边距会产生折叠，左右外边距不会折叠。<br>折叠外边距的大小等于相邻外边距中的最大值</p><h3 id="第七章-定位和层叠上下文"><a href="#第七章-定位和层叠上下文" class="headerlink" title="第七章 定位和层叠上下文"></a>第七章 定位和层叠上下文</h3><p>1.固定和绝对定位可以设置top,right,bottom,left改变定位元素的大小，相对定位不可以<br>2.固定定位相对于视口定位，绝对定位相对于最近定位父元素定位，如果没有定位父元素，则相对于初始包含块定位<br>3.初始包含块是视口和html根元素之间的内容<br>4.相对定位，left和right， top和bottom不能同时使用，left和right一起使用时，right会被忽略，top和bottom一起使用时right会被忽略<br>5.通常情况下（使用定位之前），元素在HTML里出现的顺序决定了绘制的顺序。<br>6.浏览器会先绘制所有非定位的元素，然后绘制定位元素。默认情况下，所有的定位元素会出现在非定位元素前面。<br>7.相对定位依赖于文档流，绝对定位元素依赖于它的定位祖先节点。这时候需要用z-index属性来控制它们的层叠行为。<br>8.z-index属性的值可以是任意整数（正负都行）。z表示的是笛卡儿x-y-z坐标系里的深度方向。拥有较高z-index的元素出现在拥有较低z-index的元素前面。拥有负数z-index的元素出现在静态元素后面<br>9.z-index只在定位元素上生效，不能控制静态元素；给一个定位元素添加z-index属性可以创建层叠上下文。<br>10.一个层叠上下文包含一个元素或由浏览器一起绘制的一组元素。其中一个元素作为层叠上下文的根，比如给一个定位元素设置z-index属性，该元素就是新的层叠上下问的根。<br>11.层叠上下文负责决定哪些元素出现在另一些元素前面，而BFC负责处理文档流，以及元素是否会重叠<br>12.创建层叠上下文方式：给定位元素添加z-index属性，opacity属性小于1，transform、，filter属性，跟节点html<br>13.所有层叠上下文内的元素会按照以下顺序，从后到前叠放：</p><p>  1.层叠上下文的根<br>  2.z-index为负的定位元素（及其子元素）<br>  3.非定位元素<br>  4.z-index为auto的定位元素（及其子元素）<br>  5.z-index为正的定位元素（及其子元素）</p><h3 id="第八章-响应式设计"><a href="#第八章-响应式设计" class="headerlink" title="第八章 响应式设计"></a>第八章 响应式设计</h3><p>1.响应式设计的三大原则如下</p><p>  (1) 移动优先。这意味着在实现桌面布局之前先构建移动版的布局。不要忘记给视口添加meta标签。<br>  (2) @media规则。使用这个样式规则，可以为不同大小的视口定制样式。用这一语法，通常叫作媒体查询（media queries），写的样式只在特定条件下才会生效。使用媒体查询，按照视口从小到大的顺序渐进增强网页。<br>  (3) 流式布局（fluid layout）。这种方式允许容器根据视口宽度缩放尺寸。</p><p>选择器</p><p>1.基础选择器</p><ol><li>tagname——类型选择器或者标签选择器。该选择器匹配目标元素的标签名。它的优先级是0,0,1。例如：p、h1、strong。</li><li>class——类选择器。该选择器匹配class属性中有指定类名的元素。它的优先级是0,1,0。例如：.media、.nav-menu。</li><li>#id——ID选择器。该选择器匹配拥有指定ID属性的元素。它的优先级是1,0,0。例如：#sidebar。</li><li>＊——通用选择器。该选择器匹配所有元素。它的优先级是0,0,0。</li></ol><p>2.组合器</p><ol><li>子组合器（&gt;）——匹配的目标元素是其他元素的直接后代。例如：.parent &gt; .child。</li><li>相邻兄弟组合器（+）——匹配的目标元素紧跟在其他元素后面。例如：p + h2。</li><li>通用兄弟组合器（~）——匹配所有跟随在指定元素之后的兄弟元素。注意，它不会选中目标元素之前的兄弟元素。例如：li.active ~ li。</li></ol><p>3.伪类选择器</p><p>伪类选择器用于选中处于某个特定状态的元素。伪类选择器始终以一个冒号（:）开始。优先级等于一个类选择器（0,1,0）</p><ol><li>:first-child——匹配的元素是其父元素的第一个子元素。</li><li>:last-child——匹配的元素是其父元素的最后一个子元素。</li><li>:only-child——匹配的元素是其父元素的唯一一个子元素（没有兄弟元素）。</li><li>:nth-child(an+b)——匹配的元素在兄弟元素中间有特定的位置。</li><li>:nth-last-child(an+b)——类似于：nth-child()，但不是从第一个元素往后数，而是从最后一个元素往前数。</li><li>:first-of-type——类似于：first-child，但不是根据在全部子元素中的位置查找元素，而是根据拥有相同标签名的子元素中的数字顺序查找第一个元素。</li><li>:last-of-type——匹配每种类型的最后一个子元素。</li><li>:only-of-type——该选择器匹配的元素是满足该类型的唯一一个子元素。</li><li>:nth-of-type(an+b)——根据目标元素在特定类型下的数字顺序以及特定公式选择元素，类似于：nth-child。</li><li>nth-last-of-type(an+b)——根据元素类型以及特定公式选择元素，从其中最后一个元素往前算，类似于：nth-last-child。</li><li>:not(<code>&lt;selector&gt;</code>)——匹配的元素不匹配括号内的选择器。括号内的选择器必须是基础选择器，它只能指定元素本身，无法用于排除祖先元素，同时不允许包含另一个排除选择器。</li><li>:empty——匹配的元素必须没有子元素。注意，如果元素包含空格就无法由该选择器匹配，因为空格在DOM中属于文本节点。</li><li>:focus——匹配通过鼠标点击、触摸屏幕或者按Tab键导航而获得焦点的元素。</li><li>:hover——匹配鼠标指针正悬停在其上方的元素。</li><li>:root——匹配文档根元素.</li><li>:disabled——匹配已禁用的元素，包括input、select以及button元素。</li><li>:enabled——匹配已启用的元素，即那些能够被激活或者接受焦点的元素。</li><li>:checked——匹配已经针对选定的复选框、单选按钮或选择框选项。</li><li>:invalid——根据输入类型中的定义，匹配有非法输入值的元素。例如，当<input type="email">的值不是一个合法的邮箱地址时，该元素会被匹配（Level4）。</li><li>:valid——匹配有合法值的元素（Level4）。</li><li>:required——匹配设置了required属性的元素（Level4）。</li><li>:optional——匹配没有设置required属性的元素</li></ol><p>4.伪元素选择器</p><p>伪元素类似于伪类，但是它不匹配特定状态的元素，而是匹配在文档中没有直接对应HTML元素的特定部分.<br>以双冒号（::）开头，尽管大多数浏览器也支持单冒号的语法以便向后兼容。伪元素选择器的优先级与类型选择器（0,0,1）相等</p><ol><li>::before——创建一个伪元素，使其成为匹配元素的第一个子元素。该元素默认是行内元素，可用于插入文字、图片或其他形状。必须指定content属性才能让元素出现，例如：.menu::before。</li><li>::after——创建一个伪元素，使其成为匹配元素的最后一个子元素。该元素默认是行内元素，可用于插入文字、图片或其他形状。必须指定content属性才能让元素出现，例如：.menu::after。1.</li><li>::first-letter——用于指定匹配元素的第一个文本字符的样式，例如：h2::first-letter。</li><li>::first-line——用于指定匹配元素的第一行文本的样式。</li><li>::selection——用于指定用户使用鼠标高亮选择的任意文本的样式。通常用于改变选中文本的background-color。只有少数属性可以使用，包括color、background-color、cursor、text-decoration。</li></ol><p>5.属性选择器</p><p>属性选择器用于根据HTML属性匹配元素。其优先级与一个类选择器（0,1,0）相等</p><p>以下选择器区分大小写：</p><ol><li>[attr]——匹配的元素拥有指定属性attr，无论属性值是什么，例如：input[disabled]。</li><li>[attr=”value”]——匹配的元素拥有指定属性attr，且属性值等于指定的字符串值，例如：input[type=”radio”]。</li><li>[attr^=”value”]——“开头”属性选择器。该选择器匹配的元素拥有指定属性attr，且属性值的开头是指定的字符串值，例如：a[href^=”https”]。</li><li>[attr$=”value”]——“结尾”属性选择器。该选择器匹配的元素拥有指定属性attr，且属性值的结尾是指定的字符串值，例如：a[href$= “.pdf”]。</li><li>[attr＊=”value”]——“包含”属性选择器。该选择器匹配的元素拥有指定属性attr，且属性值包含指定的字符串值，例如：[class＊=”sprite-“]。</li><li>[attr~=”value”]——“空格分隔的列表”属性选择器。该选择器匹配的元素拥有指定属性attr，且属性值是一个空格分隔的值列表，列表中的某个值等于指定的字符串值，例如：a[rel=”author”]。</li><li>[attr|=”value”]——匹配的元素拥有指定属性attr，且属性值要么等于指定的字符串值，要么以该字符串开头且紧跟着一个连字符（-）。适用于语言属性，因为该属性有时候会指定一种语言的子集（比如墨西哥西班牙语，es-MX，或者普通的西班牙语，es），例如：[lang|=”es”]。</li></ol><p>不区分大小写的属性选择器：将i添加到结束方括号前面，input[value=”search”i]</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一题</title>
      <link href="/ZJY.github.io/2022/03/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/ZJY.github.io/2022/03/28/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-js中-和-的区别？"><a href="#1-js中-和-的区别？" class="headerlink" title="1.js中 ?? 和 || 的区别？"></a>1.js中 ?? 和 || 的区别？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value1  ??  value2</span><br><span class="line">value1  ||  value2</span><br></pre></td></tr></table></figure><p>相同点：</p><p>  用法相同，都是符号前后是值，中间是符号。根据前面的值判断返回value1还是value2。</p><p>不同点：</p><p>  1.使用??时，只有当value1的值为null或undefined时才返回value2，否则返回value1<br>  2.使用||时，value1会转换为bool值，为true时返回value1,  false时返回value2</p><p>??更适合不知道变量是否有值时使用</p><h3 id="2-URI和URL的区别"><a href="#2-URI和URL的区别" class="headerlink" title="2.URI和URL的区别"></a>2.URI和URL的区别</h3><p>1.URI：统一资源标识符（Uniform Resource Identifier,URI）是一个标识某个互联网资源的字符串。表示Web上可用的每种资源-html文档、图像、视频片段、程序等由一个URI进行标识。</p><p>URI格式：[协议名]://[用户名]:[密码]@[服务器地址]:[端口号]/[路径]?[查询字符串]#[片段id]</p><p>2.URL：统一资源定位符（Uniform Resource Locator），采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。URL是URI概念的一种实现方式。</p><p>URL下列三部分组成:第一部分是协议（或称为服务方式）；第二部分是存有该资源的主机IP地址（有时也包括端口号）；第三部分是主机资源的具体地址。</p><p>3.URI和URL之间的区别</p><p>URI和URL都定义了资源是什么，但URL还定义了该如何访问资源。URL是一种具体的URI，它是URI的一个子集，它不仅唯一标识资源，而且还提供了定位该资源的信息。URI 是一种语义上的抽象概念，可以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位，是绝对的。</p><h3 id="3-Http中的301，302，303，307，308相应状态码"><a href="#3-Http中的301，302，303，307，308相应状态码" class="headerlink" title="3.Http中的301，302，303，307，308相应状态码"></a>3.Http中的301，302，303，307，308相应状态码</h3><p>1、301 Move Permanently</p><p>  表明资源永久的移动到了一个新的URI，任何未来对这个资源的引用都应该使用新的URI</p><p>2、302 Found</p><p>  表明资源临时的移动到了一个新的URI，由于重定向是临时的，所以之后的请求还应该使用原本的URI<br>  服务器会在响应头的Location字段放上这个不同的URI，浏览器可以使用这个URI进行自动重定向<br>  注：由于历史原因，用户代理可能会在重定向后把请求的post改为get方法。</p><p>3、303 See Other</p><p>  303 状态码表示服务器要将浏览器重定向到另一个资源，这个资源的 URI 会被写在响应 Header 的 Location 字段。从语义上讲，重定向到的资源并不是你所请求的资源，而是对你所请求资源的一些描述。<br>  303 常用于将 POST 请求重定向到 GET 请求，比如你上传了一份个人信息，服务器发回一个 303 响应，将你导向一个“上传成功”页面。<br>  不管原请求是什么方法，重定向请求的方法都是 GET（或 HEAD，不常用）</p><p>4、307 Temporary Redirect</p><p>  307 的定义实际上和 302 是一致的，唯一的区别在于，307 状态码不允许浏览器将原本为 POST 的请求重定向到 GET 请求上</p><p>5、308 Permanent Redirect</p><p>  308 的定义实际上和 301 是一致的，唯一的区别在于，308 状态码不允许浏览器将原本为 POST 的请求重定向到 GET 请求上</p><p>6、302和303、307的关系</p><p>302允许各种各样的重定向，一般情况下都会重定向到get，但不能确保post重定向到post<br>303只允许任意请求重定向到get<br>307和302一样，但不允许post到get的重定向</p><h3 id="4-link和-import引入css的区别？"><a href="#4-link和-import引入css的区别？" class="headerlink" title="4.link和@import引入css的区别？"></a>4.link和@import引入css的区别？</h3><p>1、link是HTML的的标签，除了链接样式表还可以设置RSS，rel等属性，@import只能加载css<br>2、link会在页面加载时同时加载，@import会在页面加载完成后再加载<br>3、link无兼容性问题，@import是在css2.1提出，低版本浏览器不支持<br>4、可以通过js操作dom将link样式表插入文档改变样式，@import不支持</p><h3 id="5-圣杯布局和双飞翼布局"><a href="#5-圣杯布局和双飞翼布局" class="headerlink" title="5.圣杯布局和双飞翼布局"></a>5.圣杯布局和双飞翼布局</h3><p>三栏布局，两边固宽</p><p>圣杯布局：三栏利用float和负margin并列，利用父容器的padding给两边空出空间</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>圣杯布局<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hahahhaha<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">60px</span> <span class="number">0</span> <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: aquamarine;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: darkkhaki;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="built_in">calc</span>(-<span class="number">100%</span> - <span class="number">30px</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: firebrick;</span><br><span class="line">  <span class="comment">/* margin-left: -60px;</span></span><br><span class="line"><span class="comment">  position: relative;</span></span><br><span class="line"><span class="comment">  left: 60px; */</span></span><br><span class="line">  <span class="attribute">margin-right</span>: -<span class="number">60px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双飞翼布局：三栏利用float和负margin并列，中间栏加一层容器，利用margin给两栏空出空间</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>双飞翼布局<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>hahahhaha<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left1&quot;</span>&gt;</span>left1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right1&quot;</span>&gt;</span>right1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container1</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container1</span> <span class="selector-class">.main1</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: aquamarine;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">60px</span> <span class="number">0</span> <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left1</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: darkkhaki;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right1</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: firebrick;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flex布局也可实现三栏布局</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left2&quot;</span>&gt;</span>left2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main2&quot;</span>&gt;</span></span><br><span class="line">    flex</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right2&quot;</span>&gt;</span>right2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">1px</span> solid;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span> <span class="number">1</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main2</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: aquamarine;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: darkkhaki;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: firebrick;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/ZJY.github.io/images/buju.jpg" alt="image"></p><p>圣杯和双飞翼中间栏放首位可保证首先渲染，但是中间栏宽度小于左栏会页面错乱</p><h3 id="6-用递归算法实现，数组长度为5且元素的随机整数数在2-32间不重复的值"><a href="#6-用递归算法实现，数组长度为5且元素的随机整数数在2-32间不重复的值" class="headerlink" title="6.用递归算法实现，数组长度为5且元素的随机整数数在2-32间不重复的值"></a>6.用递归算法实现，数组长度为5且元素的随机整数数在2-32间不重复的值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomArr5</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  arr = arr || []</span><br><span class="line">  <span class="keyword">if</span> (arr.length === <span class="number">5</span>) <span class="keyword">return</span> arr</span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">2</span> + <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">31</span>)</span><br><span class="line">  <span class="keyword">if</span> (!arr.includes(num)) arr.push(num)</span><br><span class="line">  <span class="keyword">return</span> randomArr5(arr)</span><br><span class="line">&#125;</span><br><span class="line">randomArr5() <span class="comment">// [30, 19, 28, 3, 11]</span></span><br></pre></td></tr></table></figure><p>随机数2-32，数组长度5且元素不重复，递归</p><h3 id="7-html的元素有哪些（包含h5）？"><a href="#7-html的元素有哪些（包含h5）？" class="headerlink" title="7. html的元素有哪些（包含h5）？"></a>7. html的元素有哪些（包含h5）？</h3><p>块元素：<br>html、body、head、header、nav、section、main、aside、footer页面结构<br>article、h1-h6、p 文章<br>div<br>ul、ol、li、dl、dt、dd 列表<br>table、tr、td、thead、tbody表格<br>form表单</p><p>行内元素：<br>a(inline)<br>span(inline)<br>img(inline)<br>strong(inline)、i(inline)、em(inline)文本内容<br>label(inline)<br>canvas(inline)<br>audio(inline,无controls值为none)、video(inline)媒体</p><p>行内块元素：<br>input(inline-block)<br>select(inline-block)<br>button(inline-block)</p><h3 id="8-css3新特效有哪些？"><a href="#8-css3新特效有哪些？" class="headerlink" title="8.css3新特效有哪些？"></a>8.css3新特效有哪些？</h3><p>1.边框属性<br>border-image(边框图片)、border-radius(边框圆角)、box-shadow(边框阴影)</p><p>2.背景属性<br>backgrou-image: url(),url();多背景图片<br>background-clip: border-box/padding-box/content-box;背景图片绘制区域，默认border-box图片被剪裁到边框盒<br>background-origin: padding-box/border-box/content-box;图片相对于什么位置定位，默认值padding-box<br>background-size: auto/cover/contain/length/%;景图像的尺寸</p><p>3.文本属性<br>text-shadow文本阴影<br>word-wrap: normal/break-word; 允许长单词或URL换行<br>word-break: normal/keep-all(只允许在半角空格或连字符处换行)/break-all(允许在单词内换行)</p><p>4.transform属性<br>2D或3D变换，允许元素进行旋转、移动、缩放、倾斜<br>transform：</p><ul><li>none：不进行任何转换</li><li>matrix(n,n,n,n,n,n):定义2D转换，使用六个值的矩阵</li><li>matrix3d(n,…n):定义3D转换，使用16个值的矩阵</li><li>translate(x,y):定义2D转换</li><li>translate3d(x,y,z): 定义3D转换</li><li>translateX(x): 定义转换，只是用 X 轴的值。</li><li>translateY(y): 定义转换，只是用 Y 轴的值。</li><li>translateZ(z): 定义转换，只是用 Z 轴的值。</li><li>scale(x,y): 定义2D缩放转换</li><li>scale3d(x,y,z): 定义3D缩放转换</li><li>scaleX(x): 通过设置 X 轴的值来定义缩放转换。</li><li>scaleY(y): 通过设置 Y 轴的值来定义缩放转换。</li><li>scaleZ(z): 通过设置 Z 轴的值来定义缩放转换。</li><li>rotate(angle): 定义 2D 旋转，在参数中规定角度</li><li>rotate(x,y,angle): 定义3D旋转</li><li>rotateX(angle): 定义沿着 X 轴的 3D 旋转</li><li>rotatezY(angle): 定义沿着 Y 轴的 3D 旋转</li><li>rotateZ(angle): 定义沿着 Z 轴的 3D 旋转</li><li>skew(x-angle,y-angle): 定义沿着x轴和y轴倾斜转换</li><li>skewX(angle): 定义沿着X轴的2D倾斜转换</li><li>skewY(angle):定义沿着y轴的2D倾斜转换</li></ul><p>5.过渡动画transition<br>transition: property duration timing-function delay;</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">transion</span>: <span class="selector-tag">width</span> 2<span class="selector-tag">s</span>;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.animation动画</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">animation</span>: myFirst <span class="number">5s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@keyframes</span> myFirst&#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.弹性盒子flexbox</p><p>8.多媒体查询@media</p><p>9.渐变<br>linear-gradient 线性渐变<br>radial-gradient 径向渐变</p><h3 id="9-写一个方法去掉字符串中的空格，要求传入不同的类型分别能去掉前、后、前后、中间的空格"><a href="#9-写一个方法去掉字符串中的空格，要求传入不同的类型分别能去掉前、后、前后、中间的空格" class="headerlink" title="9.写一个方法去掉字符串中的空格，要求传入不同的类型分别能去掉前、后、前后、中间的空格"></a>9.写一个方法去掉字符串中的空格，要求传入不同的类型分别能去掉前、后、前后、中间的空格</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trim</span>(<span class="params">str, type = <span class="string">&#x27;all&#x27;</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Type = &#123;</span><br><span class="line">        left: <span class="regexp">/^\s+/g</span>,</span><br><span class="line">        right: <span class="regexp">/\s+$/g</span>,</span><br><span class="line">        all: <span class="regexp">/\s+/g</span>,</span><br><span class="line">        both: <span class="regexp">/^\s+|\s+$/g</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type === <span class="string">&#x27;center&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> leftStr = str.match(<span class="regexp">/^\s+/g</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">let</span> rightStr = str.match(<span class="regexp">/\s+$/g</span>)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> leftStr + str.replace(<span class="regexp">/\s+/g</span>,<span class="string">&#x27;&#x27;</span>) + rightStr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.replace(Type[type], <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> strs = <span class="string">&#x27;  12 3  4  56 &#x27;</span></span><br><span class="line">trim(strs) <span class="comment">// all &#x27;123456&#x27;</span></span><br><span class="line">trim(strs, <span class="string">&#x27;left&#x27;</span>) <span class="comment">// left &#x27;12 3  4  56 &#x27;</span></span><br><span class="line">trim(strs, <span class="string">&#x27;right&#x27;</span>) <span class="comment">// right &#x27;  12 3  4  56&#x27;</span></span><br><span class="line">trim(strs, <span class="string">&#x27;both&#x27;</span>) <span class="comment">// both &#x27;12 3  4  56&#x27;</span></span><br><span class="line">trim(strs, <span class="string">&#x27;center&#x27;</span>) <span class="comment">// center &#x27;  123456 &#x27;</span></span><br></pre></td></tr></table></figure><h3 id="10-HTML全局属性（global-attribute）有哪些？"><a href="#10-HTML全局属性（global-attribute）有哪些？" class="headerlink" title="10.HTML全局属性（global attribute）有哪些？"></a>10.HTML全局属性（global attribute）有哪些？</h3><p>全局属性是所有HTML元素共有的属性，它们可以用于所有元素，即使属性对某些元素不起作用。</p><p>1.accesskey提供了为当前元素生成键盘快捷键的提示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">accesskey</span>=<span class="string">&quot;n&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>windows系统使用alt+n快捷键可快速选择对应元素<br>mac系统使用crtl+option+n快捷键</p><p>2.autocapitalize控制用户输入如何自动大写</p><p>3.class</p><p>4.contenteditable元素是否可以被编辑</p><p>5.data-* 自定义数据属性</p><p>6.dir指示元素中文本方向的枚举属性（ltr、rtl、auto）</p><p>7.draggable,枚举属性，指示是否可以使用Drog盒Drop API拖动元素</p><p>8.hidden隐藏元素</p><p>9.id唯一标识符</p><p>10.lang：定义元素的语言，xml:lang优先于它</p><p>11.spellcheck:是否启动拼写和语法检查</p><p>12.slot插槽，具有slot属性的元素被分配给由<code>&lt;slot&gt;</code>元素创建的沟槽，其name属性的值与slot属性的值匹配。</p><p>13.style内联样式</p><p>14.tabindex规定元素的tab键控制次序</p><p>15.title</p><p>16.translate页面本地化时是否转换元素的属性值及其Text 节点子节点的值</p><p>17.还有事件处理程序属性：onabort, onautocomplete, onautocompleteerror, onblur, oncancel, oncanplay, oncanplaythrough, onchange, onclick, onclose, oncontextmenu, oncuechange, ondblclick, ondrag, ondragend, ondragenter, ondragexit, ondragleave, ondragover, ondragstart, ondrop, ondurationchange, onemptied, onended, onerror, onfocus, oninput, oninvalid, onkeydown, onkeypress, onkeyup, onload, onloadeddata, onloadedmetadata, onloadstart, onmousedown, onmouseenter, onmouseleave, onmousemove, onmouseout, onmouseover, onmouseup, onmousewheel, onpause, onplay, onplaying, onprogress, onratechange, onreset, onresize, onscroll, onseeked, onseeking, onselect, onshow, onsort, onstalled, onsubmit, onsuspend, ontimeupdate, ontoggle, onvolumechange, onwaiting</p><h3 id="11-页面上隐藏元素的方法有哪些？"><a href="#11-页面上隐藏元素的方法有哪些？" class="headerlink" title="11.页面上隐藏元素的方法有哪些？"></a>11.页面上隐藏元素的方法有哪些？</h3><p>1.给元素设置hidden属性，不占位<br>2.display:none;不占位<br>6.width:0;height:0;transform:scale(0);不占位；有些元素有border值依然会占位，有宽高<br>3.visibility:hidden;占位<br>4.opacity: 0;/filter: opacity(0);占位<br>5.filter: opacity(0);占位<br>7.width:0;height:0;overflow:hidden;不占位；有些元素有border值依然会占位，有宽高<br>8.position:absolute;left/margin-left:-1000%;脱离文档流不占位<br>9.position:absolute;z-index: -1;脱离文档流不占位,但是后面元素只是盖在该元素上面，如果后面元素比该元素小只会隐藏一部分<br>10.font-size:0;不占位仅对文本内容有效</p><h3 id="12-去除字符串中最后一个指定的字符"><a href="#12-去除字符串中最后一个指定的字符" class="headerlink" title="12.去除字符串中最后一个指定的字符"></a>12.去除字符串中最后一个指定的字符</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delChar</span>(<span class="params">str, char</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> str !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;not string&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> lastIndex = str.lastIndexOf(char)</span><br><span class="line">    <span class="keyword">if</span> (lastIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> str.substring(<span class="number">0</span>, lastIndex) + str.substring(lastIndex + char.length)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;not find &#x27;</span>,char)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">delChar(<span class="string">&#x27;abniok9866dasd%fnad#fv%vvv&#x27;</span>, <span class="string">&#x27;d#&#x27;</span>) <span class="comment">// &#x27;abniok9866dasd%fnafv%vvv&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正则</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delLastAnyChar</span>(<span class="params">str, char</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// [^]表示任意字符 .查找单个字符除换行和行结束符，单行模式下，[^]就是.,但是多行模式下，[^]可以匹配到\n</span></span><br><span class="line">  <span class="comment">// [^]*表示任意长度字符 ()表示元组，$1表示匹配到的第一个()内容</span></span><br><span class="line">  <span class="keyword">let</span> reg = <span class="keyword">new</span> Reg(<span class="string">`(^[^]*)(<span class="subst">$&#123;char&#125;</span>)([^]*$)`</span>)</span><br><span class="line">  <span class="keyword">return</span> str.replace(reg, <span class="string">&#x27;$1$3&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">delLastAnyChar(<span class="string">&#x27;acdabdbde&#x27;</span>, <span class="string">&#x27;bd&#x27;</span>) <span class="comment">// acdabde</span></span><br></pre></td></tr></table></figure><h3 id="13-HTML5离线存储方式有哪些，怎么使用，原理是什么？"><a href="#13-HTML5离线存储方式有哪些，怎么使用，原理是什么？" class="headerlink" title="13.HTML5离线存储方式有哪些，怎么使用，原理是什么？"></a>13.HTML5离线存储方式有哪些，怎么使用，原理是什么？</h3><p>浏览器检测是否在线 navigator.onLine 返回true/false</p><p>查看<a href="/ZJY.github.io/2022/10/28/HTML5%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/" title="HTML5存储方式">HTML5存储方式</a></p><h3 id="14-css选择器有哪些？哪些属性可继承？"><a href="#14-css选择器有哪些？哪些属性可继承？" class="headerlink" title="14.css选择器有哪些？哪些属性可继承？"></a>14.css选择器有哪些？哪些属性可继承？</h3><p><strong>选择器:</strong></p><ul><li>通用选择器  * 匹配文档内所有元素</li><li>元素选择其 elementName</li><li>类选择器 .className</li><li>id选择器 #idName</li><li>组合选择器<ul><li>element,element  h1,h2 {}</li><li>element element  body h1 {} 嵌套选择器或后代选择器</li><li>element &gt; element  div &gt; p, ul &gt; li</li><li>element + element  div + p 相邻同级选择器</li><li>element1～element2  p~ul p和ul具有相同的父元素， ul在p后面，不必紧跟</li></ul></li><li>属性选择器<ul><li>[attr]  a[class] a[target]</li><li>[attr=value]  p[class=”title”]</li><li>[attr<code>~</code>=value] p[class<code>~</code>=”test”] 包含指定属性值的元素，基于属性值空格分隔开的属性(“test a”包含，”test_a”不包含)</li><li>[attr|=value] [lang|=en] 用于选择指定属性具有指定值开始的元素(en-us,en)</li><li>[attr^=value] [class^=”test”] 匹配元素属性值带指定的值开始的元素(test,test_a)</li><li>[attr$=value] [class$=”test”] 匹配元素属性值带指定的值结尾的元素(test, a_test)</li><li>[attr*=value] [class*=”test”] 匹配元素属性值包含指定值的元素(test,a_test,test_a)</li></ul></li><li>伪类选择器<br>:active,:after,:before,:checked,:disabled,:empty,:enabled,:first-child,:first-letter,:first-of-type,:focus,:hover,:in-range,:invalid,:lang(),:last-child,:last-of-type,:link,:not,:nth-child(),:nth-last-child(),:nth-last-of-type(),:nth-of-type(),:only-child,:optional,:out-of-range,:read-only,:read-write,:required,:root,::selection,:target,:valid,:visited</li></ul><p><strong>可继承的属性:</strong></p><ul><li>字体系列属性<br>font-family,font-weight,font-size,font-style,font-variant,font-stretch,font-size-adjust</li><li>文本系列属性<br>text-align, line-height, word-spacing, letter-spacing, text-transform, direction, color</li><li>元素可见性<br>visibility, opacity</li><li>表格布局属性</li><li>列表属性</li><li>光标属性 cursor<br>…</li></ul><h3 id="15-写一个方法把下划线命名转成大驼峰命名"><a href="#15-写一个方法把下划线命名转成大驼峰命名" class="headerlink" title="15.写一个方法把下划线命名转成大驼峰命名"></a>15.写一个方法把下划线命名转成大驼峰命名</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toCamelCase</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (str.split(<span class="string">&#x27;_&#x27;</span>).length === <span class="number">1</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">let</span> arr = str.split(<span class="string">&#x27;_&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      res =  res + item.substr(<span class="number">0</span>,<span class="number">1</span>).toUpperCase() + item.substr(<span class="number">1</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line">toCamelCase(<span class="string">&#x27;a_project_name_title&#x27;</span>) <span class="comment">// &#x27;AProjectNameTitle&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正则</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toCamelCase</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!str.length) <span class="keyword">return</span></span><br><span class="line">    str = str.replace(<span class="regexp">/(_)(\w)/g</span>, <span class="function">(<span class="params">match,$<span class="number">1</span>,$<span class="number">2</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> $<span class="number">2.</span>toUpperCase()</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> str.substr(<span class="number">0</span>,<span class="number">1</span>).toUpperCase() + str.substr(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">toCamelCase(<span class="string">&#x27;test_project_container&#x27;</span>) <span class="comment">// TestProjectContainer</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toCamelCase</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.replace(<span class="regexp">/(^|_)(\w)/g</span>,<span class="function">(<span class="params">m,$<span class="number">1</span>,$<span class="number">2</span></span>)=&gt;</span>$<span class="number">2.</span>toUpperCase());</span><br><span class="line">&#125;</span><br><span class="line">toCamelCase(<span class="string">&#x27;test_project_container&#x27;</span>) <span class="comment">// TestProjectContainer</span></span><br></pre></td></tr></table></figure><h3 id="16-简述超链接target属性的取值和作用"><a href="#16-简述超链接target属性的取值和作用" class="headerlink" title="16.简述超链接target属性的取值和作用"></a>16.简述超链接target属性的取值和作用</h3><table><thead><tr><th align="center">target值</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">_blank</td><td align="center">在新的窗口打开被链接的文档</td></tr><tr><td align="center">_self</td><td align="center">默认，在相同框架中打开被链接的文档</td></tr><tr><td align="center">_parent</td><td align="center">在父框架集中打开被链接的文档</td></tr><tr><td align="center">_top</td><td align="center">在整个窗口中（最顶层框架集）打开被链接的文档</td></tr><tr><td align="center">framename</td><td align="center">在指定的框架中打开被链接的文档</td></tr></tbody></table><h3 id="17-CSS3新增伪类有哪些并简要描述？"><a href="#17-CSS3新增伪类有哪些并简要描述？" class="headerlink" title="17.CSS3新增伪类有哪些并简要描述？"></a>17.CSS3新增伪类有哪些并简要描述？</h3><table><thead><tr><th align="center">新增伪类</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">:first-of-type</td><td align="center">p:first-of-type 选择的每个 p 元素是其父元素的第一个 p 元素</td></tr><tr><td align="center">:last-of-type</td><td align="center">p:last-of-type 匹配元素其父级是特定类型的最后一个子元素</td></tr><tr><td align="center">:only-of-type</td><td align="center">p:only-of-type 匹配p的父元素的唯一子元素p</td></tr><tr><td align="center">:only-child</td><td align="center">p:only-child 匹配p元素的父元素唯一的子元素p元素</td></tr><tr><td align="center">:nth-child(n)</td><td align="center">p:nth-child(2) 选择所有 p 元素的父元素的第二个子元素(不是第二个子p元素)</td></tr><tr><td align="center">:enabled</td><td align="center">input:enabled 选择所有启用的元素</td></tr><tr><td align="center">:disabled</td><td align="center">input:disabled 选择所有禁用的元素</td></tr><tr><td align="center">:checked</td><td align="center">input:checked 选择所有选中的元素</td></tr><tr><td align="center">:empty</td><td align="center">p:empty 选择所有没有子元素的p元素</td></tr><tr><td align="center">:focus</td><td align="center">input:focus 选择元素输入后具有焦点</td></tr><tr><td align="center">:root</td><td align="center">选择文档的根元素</td></tr></tbody></table><h3 id="18-写一个把字符串大小写切换的方法？"><a href="#18-写一个把字符串大小写切换的方法？" class="headerlink" title="18.写一个把字符串大小写切换的方法？"></a>18.写一个把字符串大小写切换的方法？</h3><p>例：aBcdEFg –&gt; AbCDefG</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">caseConvert</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> str) &#123;</span><br><span class="line">        res+= i.toLowerCase() === i ? i.toUpperCase() : i.toLowerCase()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line">caseConvert(<span class="string">&#x27;aBcdEfGD&#x27;</span>) <span class="comment">// AbCDeFgd</span></span><br><span class="line"><span class="comment">// 正则</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">caseConvert</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(<span class="regexp">/([a-z]*)([A-Z]*)/g</span>, <span class="function">(<span class="params">m, s1, s2</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;s1.toUpperCase()&#125;</span><span class="subst">$&#123;s2.toLowerCase()&#125;</span>`</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">caseConvert(<span class="string">&#x27;例：aBcdEFg&#x27;</span>) <span class="comment">// AbCDefG</span></span><br></pre></td></tr></table></figure><h3 id="19-label都有哪些作用？"><a href="#19-label都有哪些作用？" class="headerlink" title="19.label都有哪些作用？"></a>19.label都有哪些作用？</h3><p>1.关联表单控件，扩大点选范围<br>2.关联表单控件，聚焦到关联输入框<br>3.为input元素定义的标记<br>4.利用label”模拟”button来解决不同浏览器原生button样式不同的问题</p><h3 id="20-用css创建一个三角形，并简述原理"><a href="#20-用css创建一个三角形，并简述原理" class="headerlink" title="20. 用css创建一个三角形，并简述原理"></a>20. 用css创建一个三角形，并简述原理</h3><p>当width和height为0时，设置border会将其分割成45度的等腰三角形，设置上下左右border宽度或颜色透明即可得到三角形</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">width</span>: 0;</span><br><span class="line"><span class="selector-tag">height</span>: 0;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">inline-block</span>;</span><br><span class="line"><span class="selector-tag">border</span>: 10<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">red</span>;</span><br><span class="line"><span class="selector-tag">border-bottom-color</span>: <span class="selector-tag">transparent</span>;</span><br><span class="line"><span class="selector-tag">border-left-color</span>: <span class="selector-tag">transparent</span>;</span><br><span class="line"><span class="selector-tag">border-right-color</span>: <span class="selector-tag">transparent</span>;</span><br></pre></td></tr></table></figure><p>若要获取左直角等三角形，只需修改上下左右边框颜色透明</p><h3 id="21-写一个去除制表符和换行符的方法"><a href="#21-写一个去除制表符和换行符的方法" class="headerlink" title="21.写一个去除制表符和换行符的方法"></a>21.写一个去除制表符和换行符的方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeTab</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(<span class="regexp">/\n|\t/g</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">removeTab(<span class="string">&#x27;h\taha\nfdals&#x27;</span>) <span class="comment">// hahafdals</span></span><br></pre></td></tr></table></figure><h3 id="22-iframe框架都有哪些优缺点"><a href="#22-iframe框架都有哪些优缺点" class="headerlink" title="22.iframe框架都有哪些优缺点?"></a>22.iframe框架都有哪些优缺点?</h3><p>缺点：<br>1.会产生多个页面，不容易管理<br>2.多iframe的页面会增加服务器的http请求<br>3.每个iframe对应一个页面，其多余的css和js文件的载入会增加请求的开销<br>4.window.onload事件会在所有的iframe加载完成后才触发，会造成页面阻塞<br>5.如果iframe内有滚动条，会影响用户的使用体验<br>6.代码复杂，无法被一些搜索引擎索引到，对搜索引擎不友好</p><p>优点：<br>1.投放广告之类的飘窗无疑是最好的选择<br>2.重载时只需要重载页面中的一个iframe，不需要重载整个页面<br>3.可以实现异步刷新，单个iframe刷新不影响整个窗口的刷新（在FormData无法使用时，可以实现无刷新上传）<br>4.可以实现跨域，每个iframe的源可以不相同（方便引入第三方内容）<br>5.多页面应用时，对于共同的header，footer可以使用iframe加载，拆分代码（方便制作导航栏）<br>6.技术容易掌握。可主要应用于不需要搜索引擎来搜索的页面</p><h3 id="23-简述你对BFC规范的理解"><a href="#23-简述你对BFC规范的理解" class="headerlink" title="23.简述你对BFC规范的理解"></a>23.简述你对BFC规范的理解</h3><p>查看<a href="/ZJY.github.io/2021/01/14/css-BFC/" title="css-BFC块级格式化上下文">css-BFC块级格式化上下文</a></p><h3 id="24-统计某一字符或字符串在另一个字符串中出现的次数"><a href="#24-统计某一字符或字符串在另一个字符串中出现的次数" class="headerlink" title="24.统计某一字符或字符串在另一个字符串中出现的次数"></a>24.统计某一字符或字符串在另一个字符串中出现的次数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countTarget</span>(<span class="params">str, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(target.match(str)) &#123;</span><br><span class="line">        target = target.replace(str, <span class="string">&quot; &quot;</span>)</span><br><span class="line">        count++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countTarget</span>(<span class="params">str, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> target.match(<span class="keyword">new</span> <span class="built_in">RegExp</span>(str, <span class="string">&#x27;g&#x27;</span>)).length</span><br><span class="line">&#125;</span><br><span class="line">countTarget(<span class="string">&quot;ad&quot;</span>, <span class="string">&quot;dasdlajdadeorwad&quot;</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="25-清除浮动的方式有哪些及优缺点"><a href="#25-清除浮动的方式有哪些及优缺点" class="headerlink" title="25.清除浮动的方式有哪些及优缺点"></a>25.清除浮动的方式有哪些及优缺点</h3><p>1.触发父元素BFC<br>如给父元素设置overflow:hidden，特别注意的是：在IE6中还需要触发hasLayout，例如给父元素设置zoom:1</p><p>原理是触发父级BFC后，父元素在计算高度时，浮动的子元素也会参与计算</p><p>优点<br>代码简洁</p><p>缺点<br>设置overflow:hidden容易造成不会自动换行导致超出的尺寸被隐藏掉，无法显示要溢出的元素</p><p>2.给父元素设置高度<br>优点<br>代码简洁</p><p>缺点<br>不够灵活，只适用于高度固定的布局</p><p>3.添加额外标签<br>在最后一个浮动元素的后面新加一个标签如</p><p>，并在其CSS样式中设置clear: both<br>优点<br>代码简洁，兼容性好</p><p>缺点<br>额外增加无语义html元素，代码语义化差，后期维护成本大</p><p>4.使用after伪元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;.&quot;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  <span class="attribute">visibility</span>:hidden;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  // 注意此处是为了兼容IE6和IE7浏览器，即触发hasLayoutcs</span><br><span class="line">  <span class="selector-tag">zoom</span>: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点<br>符合闭合浮动思想，结构语义化正确</p><p>缺点<br>代码量多，因为IE6-7下不支持after伪元素，需要额外写 zoom:1来 触发hasLayout</p><h3 id="26-写一个加密字符串的方法"><a href="#26-写一个加密字符串的方法" class="headerlink" title="26.写一个加密字符串的方法"></a>26.写一个加密字符串的方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.base-64加密</span></span><br><span class="line"><span class="keyword">let</span> tempStr = <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="keyword">let</span> tempPass = <span class="built_in">window</span>.btoa(tempStr) <span class="comment">// &#x27;aGVsbG8gd29ybGQ=&#x27;</span></span><br><span class="line"><span class="comment">// base-64解密</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.atob(tempPass)) <span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encode</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> btoa(<span class="built_in">encodeURIComponent</span>(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decode</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">decodeURIComponent</span>(atob(str));</span><br><span class="line">&#125;</span><br><span class="line">encode(<span class="string">&#x27;hello world&#x27;</span>) <span class="comment">// &#x27;aGVsbG8lMjB3b3JsZA==&#x27;</span></span><br><span class="line">decode(<span class="string">&#x27;aGVsbG8lMjB3b3JsZA==&#x27;</span>) <span class="comment">//&#x27;hello world&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encodeStr</span>(<span class="params">str, padding</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !str</span><br><span class="line">    ? str</span><br><span class="line">    : str.split(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      .map(<span class="function"><span class="params">s</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">String</span>.fromCharCode(s.charCodeAt() + padding)</span><br><span class="line">      &#125;)</span><br><span class="line">      .join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decodeStr</span>(<span class="params">str, padding</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !str</span><br><span class="line">    ? str</span><br><span class="line">    : str.split(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      .map(<span class="function"><span class="params">s</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">String</span>.fromCharCode(s.charCodeAt() - padding)</span><br><span class="line">      &#125;)</span><br><span class="line">      .join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">encodeStr(<span class="string">&#x27;hello world!&#x27;</span>, <span class="number">10</span>) <span class="comment">// &#x27;rovvy*\x81y|vn+&#x27;</span></span><br><span class="line">decodeStr(<span class="string">&#x27;rovvy*\x81y|vn+&#x27;</span>, <span class="number">10</span>) <span class="comment">// &#x27;hello world!&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="27-浏览器内多个标签页之间的通信方式有哪些"><a href="#27-浏览器内多个标签页之间的通信方式有哪些" class="headerlink" title="27.浏览器内多个标签页之间的通信方式有哪些?"></a>27.浏览器内多个标签页之间的通信方式有哪些?</h3><p>1.websocket 可跨域<br>WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议</p><p>2.postMessage 可跨域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) <span class="comment">// 接收消息</span></span><br><span class="line"><span class="built_in">window</span>.parent.postMessage(<span class="string">&#x27;msg&#x27;</span>, <span class="string">&#x27;*&#x27;</span>) <span class="comment">// 发送消息 window.frames[0].postMessage Window.frames +索引值（命名或数字）</span></span><br></pre></td></tr></table></figure><p>3.SharedWorker<br>作为浏览器的一个新特性，可以提供一个额外的线程来执行一些js代码（真正的多线程），并且不会影响到浏览器用户界面，但是不能DOM操作</p><p>4.Server-Sent Events<br>HTML5 服务器发送事件（server-sent event）允许网页获得来自服务器的更新。<br>Server-Sent 事件指的是网页自动获取来自服务器的更新。</p><p>5.localStorage（可以添加事件监听）</p><p>6.Cookies(Cookies在同一个域名内，并且目录也得相同)</p><p>7.BroadcastChannel(Chrome商店的api)<br>这个方式，只要是在同一原始域和用户代理下，所有窗口、iframe之间都可以进行交互。这个感觉就有点类似于广播了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在一个页面上，触发事件，引发以下代码执行</span></span><br><span class="line"><span class="comment">//创建一个名字是mychannel的对象。记住这个名字，下面会用到</span></span><br><span class="line"><span class="keyword">let</span> cast = <span class="keyword">new</span> BroadcastChannel(<span class="string">&#x27;mychannel&#x27;</span>); </span><br><span class="line"><span class="keyword">let</span> myObj = &#123; <span class="attr">from</span>: <span class="string">&quot;children1&quot;</span>, <span class="attr">content</span>: <span class="string">&quot;add&quot;</span> &#125;;</span><br><span class="line">cast.postMessage(myObj)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment">//在子页面上，定义以下代码(当前页面也可以接收消息)</span></span><br><span class="line"><span class="comment">//创建一个和刚才的名字一样的对象</span></span><br><span class="line"><span class="keyword">let</span> cast1 = <span class="keyword">new</span> BroadcastChannel(<span class="string">&#x27;mychannel&#x27;</span>);</span><br><span class="line">cast1.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    alert(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="28-简述下你理解的优雅降级和渐进增强"><a href="#28-简述下你理解的优雅降级和渐进增强" class="headerlink" title="28.简述下你理解的优雅降级和渐进增强"></a>28.简述下你理解的优雅降级和渐进增强</h3><p>渐进增强（Progressive Enhancement）：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。</p><p>优雅降级（Graceful Degradation）：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。</p><p>在传统软件开发中，经常会提到向上兼容和向下兼容的概念。渐进增强相当于向上兼容，而优雅降级相当于向下兼容.</p><h3 id="29-写一个判断数据类型的方法"><a href="#29-写一个判断数据类型的方法" class="headerlink" title="29.写一个判断数据类型的方法"></a>29.写一个判断数据类型的方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(val).replace(<span class="regexp">/\[object\s|\]/g</span>, <span class="string">&#x27;&#x27;</span>).toLowerCase()</span><br><span class="line">&#125;</span><br><span class="line">getType(<span class="literal">null</span>) <span class="comment">// null</span></span><br><span class="line">getType(<span class="literal">undefined</span>) <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line">getType(<span class="string">&#x27;&#x27;</span>) <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line">getType([]) <span class="comment">// &#x27;array&#x27;</span></span><br><span class="line">getType(&#123;&#125;) <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line">getType(<span class="literal">true</span>) <span class="comment">// &#x27;boolean&#x27;</span></span><br><span class="line">getType(<span class="built_in">Number</span>) <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line">getType(<span class="number">12</span>) <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line">getType(<span class="built_in">Symbol</span>(<span class="string">&#x27;1&#x27;</span>)) <span class="comment">// &#x27;symbol&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="30-viewport常见设置都有哪些？"><a href="#30-viewport常见设置都有哪些？" class="headerlink" title="30.viewport常见设置都有哪些？"></a>30.viewport常见设置都有哪些？</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该meta标签的作用是让当前viewport的宽度等于设备的宽度.同时不允许用户手动缩放<br>meta viewport有6个属性（content设置内容），如下：</p><table><thead><tr><th align="center">属性</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">width</td><td align="center">设置viewport  的宽度，为一个正整数，或字符串”width-device”</td></tr><tr><td align="center">initial-scale</td><td align="center">设置页面的初始缩放值，为一个数字，可以带小数</td></tr><tr><td align="center">minimum-scale</td><td align="center">允许用户的最小缩放值，为一个数字，可以带小数</td></tr><tr><td align="center">maximum-scale</td><td align="center">允许用户的最大缩放值，为一个数字，可以带小数</td></tr><tr><td align="center">height</td><td align="center">设置layout viewport  的高度，这个属性对我们并不重要，很少使用</td></tr><tr><td align="center">user-scalable</td><td align="center">是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes代表允许</td></tr></tbody></table><p>此外，在安卓中还支持 target-densitydpi 这个私有属性，它表示目标设备的密度等级，作用是决定css中的1px代表多少物理像素.<br>target-densitydpi:值可以为一个数值或 high-dpi 、 medium-dpi、 low-dpi、 device-dpi 这几个字符串中的一个<br>当 target-densitydpi=device-dpi 时， css中的1px会等于物理像素中的1px。</p><p>首先如果不设置meta viewport标签，那么移动设备上浏览器默认的宽度值为800px，980px，1024px等这些，总之是大于屏幕宽度的。这里的宽度所用的单位px都是指css中的px，它跟代表实际屏幕物理像素的px不是一回事.</p><p>第二、每个移动设备浏览器中都有一个理想的宽度，这个理想的宽度是指css中的宽度，跟设备的物理宽度没有关系，在css中，这个宽度就相当于100%的所代表的那个宽度。我们可以用meta标签把viewport的宽度设为那个理想的宽度，如果不知道这个设备的理想宽度是多少，那么用device-width这个特殊值就行了，同时initial-scale=1也有把viewport的宽度设为理想宽度的作用.</p><p>可以同时使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="31-对比下px、em、rem有什么不同？"><a href="#31-对比下px、em、rem有什么不同？" class="headerlink" title="31.对比下px、em、rem有什么不同？"></a>31.对比下px、em、rem有什么不同？</h3><p>px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。</p><p>em单位名称为相对长度单位。相对于当前对象内文本的字体尺寸.em的值并不是固定的；</p><p>rem是CSS3新增的一个相对单位（root em，根em）,仍然是相对大小，但相对的只是HTML根元素</p><h3 id="32-简要描述下什么是回调函数并写一个例子出来"><a href="#32-简要描述下什么是回调函数并写一个例子出来" class="headerlink" title="32.简要描述下什么是回调函数并写一个例子出来"></a>32.简要描述下什么是回调函数并写一个例子出来</h3><p>回调函数：做为实参数传入函数，并在该外部函数内调用，用以完成某些任务。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeting</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&#x27;Hello,&#x27;</span> + name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processUserInput</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = prompt(<span class="string">&#x27;Please enter your name.&#x27;</span>);</span><br><span class="line">  callback(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">processUserInput(greeting); </span><br></pre></td></tr></table></figure><p>以上示例为同步回调，它是立即执行的。<br>回调函数经常被用于在一个异步操作完成后执行代码，它们被称为异步回调.<br>一个常见的例子是在 promise 末尾添加的 .then 内执行回调函数（在 promise 被兑现或拒绝时执行）</p><h3 id="33-你对标签语义化的理解是什么？"><a href="#33-你对标签语义化的理解是什么？" class="headerlink" title="33.你对标签语义化的理解是什么？"></a>33.你对标签语义化的理解是什么？</h3><p>代码结构清晰，方便阅读，有利于团队合作开发。</p><p>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以语义的方式来渲染网页。</p><p>有利于搜索引擎优化（SEO）。</p><h3 id="34-css常用的布局方式有哪些？"><a href="#34-css常用的布局方式有哪些？" class="headerlink" title="34.css常用的布局方式有哪些？"></a>34.css常用的布局方式有哪些？</h3><p>流式布局: 最基本的布局，就是顺着 html 像流水一样流下来<br>绝对定位：利用postion: absolute进行绝对定位的布局<br>flaot布局：浮动布局，最初用来解决多栏布局，比如圣杯、双飞燕布局都可以用float实现<br>栅格布局：bootstrap布局，把页面分为24列，通过row和col布局<br>flex布局：css3的布局，弹性布局”，用来为盒状模型提供最大的灵活性<br>grid布局：网格布局</p><h3 id="35-简要描述下JS有哪些内置的对象"><a href="#35-简要描述下JS有哪些内置的对象" class="headerlink" title="35.简要描述下JS有哪些内置的对象"></a>35.简要描述下JS有哪些内置的对象</h3><p><strong>标准内置对象分类:</strong></p><p><strong>值属性</strong><br>这些全局属性返回一个简单值，这些值没有自己的属性和方法</p><ul><li>Infinity： 一个数值，表示无穷大</li><li>NaN: 全局属性 NaN 是一个表示非数字的值。</li><li>undefined: 表示原始值undefined，是js的一个原始数据类型</li><li>globalThis: 全局属性gobalThis包含全局的this，类似全局对象</li></ul><p><strong>函数属性</strong><br>全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将值返回给调用者。</p><ul><li>eval():会将传入的字符串当做 JavaScript 代码进行执行。</li><li>isFinite(): 判断传入参数是否是一个有限数值。参数会首先转为一个数值。</li><li>isNaN(): 判断传入参数是否是NaN</li><li>parseFloat():解析一个参数（必要时先转换为字符串）并返回一个浮点数。</li><li>parseInt(): parseInt(string, radix) 解析一个字符串并返回指定基数的十进制整数，radix 是 2-36 之间的整数，表示被解析字符串的基数.</li><li>decodeURI(): 函数能解码由encodeURI 创建或其它流程得到的统一资源标识符（URI）。</li><li>decodeURIComponent(): 方法用于解码由 encodeURIComponent 方法或者其它类似方法编码的部分统一资源标识符（URI）</li><li>encodeURI(): 函数通过将特定字符的每个实例替换为一个、两个、三或四转义序列来对统一资源标识符 (URI) 进行编码</li><li>encodeURIComponent(): 函数通过将一个，两个，三个或四个表示字符的 UTF-8 编码的转义序列替换某些字符的每个实例来编码 URI</li></ul><p><strong>基本对象</strong><br>顾名思义，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象</p><ul><li>Object</li><li>Function</li><li>Boolean</li><li>Symbol</li></ul><p><strong>错误对象</strong><br>错误对象是一种特殊的基本对象。它们拥有基本的 Error 类型，同时也有多种具体的错误类</p><ul><li>Error：当运行时错误产生时，Error 对象会被抛出。Error 对象也可用于用户自定义的异常的基础对象</li><li>EvalError： 错误原因与eval()有关</li><li>RangeError: 错误原因：数值变量或参数超出其有效范围</li><li>ReferenceError: 无效引用</li><li>SyntaxError： 语法错误</li><li>TypeError: 变量或参数不属于有效类型</li><li>URIError：给encodeURI和decodeURI传递的参数无效</li><li>AggregateError:其中包裹了由一个操作产生且需要报告的多个错误。如：Promise.any() 产生的错误。</li><li>InternalError: 创建一个代表 Javascript 引擎内部错误的异常抛出的实例。如：递归太多。</li></ul><p><strong>数字和日期对象</strong><br>用来表示数字、日期和执行数学计算的对象。</p><ul><li>Number</li><li>BigInt</li><li>Math</li><li>Date</li></ul><p><strong>字符串</strong><br>用来表示和操作字符串的对象</p><ul><li>String</li><li>RegExp</li></ul><p><strong>可索引的集合对象</strong><br>这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。</p><ul><li>Array</li><li>Int8Array</li><li>Uint8Array</li><li>Uint8ClampedArray</li><li>Int16Array</li><li>Uint16Array</li><li>Int32Array</li><li>Uint32Array</li><li>Float32Array</li><li>Float64Array</li><li>BigInt64Array</li><li>BigUint64Array</li></ul><p><strong>使用键的集合对象</strong><br>这些集合对象在存储数据时会使用到键，包括可迭代的Map 和 Set，支持按照插入顺序来迭代元素。</p><ul><li>Map</li><li>Set</li><li>WeakMap</li><li>WeakSet</li></ul><p>….</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects">JavaScript 标准内置对象(MDN</a></p><h3 id="36-常见的浏览器内核都有哪些？并介绍下你对内核的理解"><a href="#36-常见的浏览器内核都有哪些？并介绍下你对内核的理解" class="headerlink" title="36.常见的浏览器内核都有哪些？并介绍下你对内核的理解"></a>36.常见的浏览器内核都有哪些？并介绍下你对内核的理解</h3><p>浏览器内核分为渲染引擎和js引擎。渲染引擎负责页面的渲染，js引擎负责执行解析js。<br>之后，由于js引擎越来越独立，现在所说的浏览器内核大都指渲染引擎。<br>目前主流的浏览器内核有：</p><ul><li>Trident:由微软开发的即ie内核</li><li>Gecko：使用c++开发的渲染引擎，firefox内核</li><li>Blink：Opera&gt;12.18,chrome&gt;=28,edge使用的内核</li><li>Webkit：chrome&lt;28和safari使用的内核</li><li>Presto:Opera &lt;= 12.18</li></ul><h3 id="37-说说你对css盒子模型的理解"><a href="#37-说说你对css盒子模型的理解" class="headerlink" title="37.说说你对css盒子模型的理解"></a>37.说说你对css盒子模型的理解</h3><p>完整的 CSS 盒模型应用于块级盒子，内联盒子只使用盒模型中定义的部分内容。模型定义了盒的每个部分 —— margin, border, padding, and content</p><p>CSS 中组成一个块级盒子需要：</p><ul><li>Content box: 这个区域是用来显示内容，大小可以通过设置 width 和 height.</li><li>Padding box: 包围在内容区域外部的空白区域；大小通过 padding 相关属性设置</li><li>Border box: 边框盒包裹内容和内边距。大小通过 border 相关属性设置。</li><li>Margin box: 这是最外面的区域，是盒子和其他元素之间的空白区域。大小通过 margin 相关属性设置。</li></ul><p><strong>标准盒模型</strong><br>在标准模型中，如果你给盒设置 width 和 height，实际设置的是 content box。padding 和 border 再加上设置的宽高一起决定整个盒子的大小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">350px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">25px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">25px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span> solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用标准模型宽度 = 410px (350 + 25 + 25 + 5 + 5)，高度 = 210px (150 + 25 + 25 + 5 + 5)，padding 加 border 再加 content box。</p><p><strong>替代（IE）盒模型</strong><br>宽度是可见宽度，所以内容宽度是该宽度减去边框和填充部分。</p><p>默认浏览器会使用标准模型。如果需要使用替代模型，您可以通过为其设置 box-sizing: border-box 来实现。</p><h3 id="38-写一个获取当前url查询字符串中的参数的方法"><a href="#38-写一个获取当前url查询字符串中的参数的方法" class="headerlink" title="38.写一个获取当前url查询字符串中的参数的方法"></a>38.写一个获取当前url查询字符串中的参数的方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUrlParams</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (url.split(<span class="string">&#x27;?&#x27;</span>).length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> urlParams = url.split(<span class="string">&#x27;?&#x27;</span>)[<span class="number">1</span>].split(<span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> res = &#123;&#125;</span><br><span class="line">    urlParams.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> temp = item.split(<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">      res[temp[<span class="number">0</span>]] = temp[<span class="number">1</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">getUrlParams(<span class="string">&#x27;http://192.168.1.200:8080?a=1&amp;b=2&#x27;</span>) <span class="comment">// &#123;a: &#x27;1&#x27;, b:&#x27;2&#x27;&#125;</span></span><br><span class="line"><span class="comment">// 正则</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUrlParams</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> params = &#123;&#125;</span><br><span class="line">  url.replace(<span class="regexp">/([^&amp;=?]+)=([^&amp;]+)/g</span>, <span class="function">(<span class="params">m, $<span class="number">1</span>, $<span class="number">2</span></span>) =&gt;</span> &#123;</span><br><span class="line">    params[$<span class="number">1</span>] = $<span class="number">2</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> params</span><br><span class="line">&#125;</span><br><span class="line">getUrlParams(<span class="string">&#x27;http://192.168.1.200:8080?a=1&amp;b=2&#x27;</span>) <span class="comment">// &#123;a: &#x27;1&#x27;, b:&#x27;2&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="39-网页应用从服务器主动推送到客户端有那些方式？"><a href="#39-网页应用从服务器主动推送到客户端有那些方式？" class="headerlink" title="39.网页应用从服务器主动推送到客户端有那些方式？"></a>39.网页应用从服务器主动推送到客户端有那些方式？</h3><p><strong>webSocket</strong><br>WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议</p><p>WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p><p><strong>eventsource(SSE)</strong><br>EventSource 接口是 Web 内容与服务器发送的事件的接口。一个 EventSource 实例打开一个持久连接 HTTP 服务器，它发送事件的 text/event-stream 格式。连接保持打开状态，直到通过调用关闭 EventSource.close()。</p><p>与 WebSockets 不同，服务器发送的事件是单向的。也就是说，数据消息是从服务器到客户端（例如用户的 Web 浏览器）沿一个方向传递的</p><p><strong>Web Push</strong><br>就是用户订阅了一个站点的 Web Push 服务后，即使用户关闭了浏览器，一旦站点主动发送推送消息，用户都能收到，只要你的电脑是开着的。这是目前谷歌和苹果在 Chrome 和 Safari 上都力推的一种全新推送服务，Firefox 最近也加入了这个阵营。</p><p>但是由于需要 GCM 支持，所以这个方法并不常见</p><h3 id="40-html5中的form怎么关闭自动完成？"><a href="#40-html5中的form怎么关闭自动完成？" class="headerlink" title="40.html5中的form怎么关闭自动完成？"></a>40.html5中的form怎么关闭自动完成？</h3><p>autocomplete设置off，有时不生效<br>在浏览器设置里自动填充模块关闭</p><h3 id="41-before和-after中单冒号和双冒号的区别是什么，这两个伪元素有什么作用？"><a href="#41-before和-after中单冒号和双冒号的区别是什么，这两个伪元素有什么作用？" class="headerlink" title="41.::before和:after中单冒号和双冒号的区别是什么，这两个伪元素有什么作用？"></a>41.::before和:after中单冒号和双冒号的区别是什么，这两个伪元素有什么作用？</h3><p>::和:是css3为了区分伪类和伪元素的，:表示伪类，::表示伪元素<br>::before是在元素前面插入内容，::after则是在元素后面插入内容，不过需要content配合，并且插入的内容是inline的。</p><h3 id="43-http都有哪些状态码？"><a href="#43-http都有哪些状态码？" class="headerlink" title="43.http都有哪些状态码？"></a>43.http都有哪些状态码？</h3><p><strong>HTTP状态码分类:</strong></p><table><thead><tr><th align="center">分类</th><th align="center">分类描述</th></tr></thead><tbody><tr><td align="center">1**</td><td align="center">信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td align="center">2**</td><td align="center">成功，操作被成功接收并处理</td></tr><tr><td align="center">3**</td><td align="center">重定向，需要进一步的操作以完成请求</td></tr><tr><td align="center">4**</td><td align="center">客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td align="center">5**</td><td align="center">服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><p><strong>常见状态码:</strong></p><table><thead><tr><th align="center">状态码</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">200</td><td align="center">成功</td></tr><tr><td align="center">301</td><td align="center">永久重定向</td></tr><tr><td align="center">302</td><td align="center">临时重定向</td></tr><tr><td align="center">304</td><td align="center">使用缓存，不改变</td></tr><tr><td align="center">400</td><td align="center">客户端请求的语法错误，服务器无法理解</td></tr><tr><td align="center">403</td><td align="center">服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td align="center">404</td><td align="center">找不到资源</td></tr><tr><td align="center">405</td><td align="center">客户端请求中的方法被禁止</td></tr><tr><td align="center">413</td><td align="center">由于请求的实体过大，服务器无法处理，因此拒绝请求</td></tr><tr><td align="center">500</td><td align="center">服务器内部错误</td></tr><tr><td align="center">502</td><td align="center">Bad Gateway作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响</td></tr><tr><td align="center">504</td><td align="center">网关超时</td></tr></tbody></table><h3 id="44-为什么HTML5只需要写就可以？"><a href="#44-为什么HTML5只需要写就可以？" class="headerlink" title="44.为什么HTML5只需要写就可以？"></a>44.为什么HTML5只需要写<!DOCTYPE HTML>就可以？</h3><p>因为html5和html4基于的基准不一样。html4基于SGML，因此除了DOCTYPE外还需要引入DTD来告诉浏览器用什么标准来渲染。DTD还区分严格模式和怪异模式。如果不写，浏览器自由发挥会变成怪异模式。<br>html5不基于SGML因此不需要DTD，但还是需要DOCTYPE来规范浏览器渲染行为。</p><p>SGML是通用标记语言的合集，有html、xml，因此需要DTD来指定使用哪种规范</p><p>DOCTYPE（Document Type Declaration）用于声明文档类型和DTD（Document Type Definition）规范，确保不同浏览器以相同的方式解析文档，以及执行相同的渲染模式。<br>DTD就是文档类型定义，一种标记符的语法规则，保证SGML和XML文档格式的合法性。</p><h3 id="45-什么是闭包？优缺点分别是什么？"><a href="#45-什么是闭包？优缺点分别是什么？" class="headerlink" title="45.什么是闭包？优缺点分别是什么？"></a>45.什么是闭包？优缺点分别是什么？</h3><p>闭包是一个函数以及捆绑的周边环境状态（词法环境）的引用的组合。换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。闭包会随着函数的创建而被同时创建。</p><p><strong>闭包:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&quot;Mozilla&quot;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">displayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> displayName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myFunc = makeFunc();</span><br><span class="line">myFunc();</span><br></pre></td></tr></table></figure><p><strong>for循环：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>xxxxxxxxxxx<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>xxxxxxxxxxx<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>xxxxxxxxxxx<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>xxxxxxxxxxx<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> liElements = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt; liElements.length; i++)&#123;</span><br><span class="line">  liElements[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i) <span class="comment">// 因为 变量i 是公用一个词法环境，所以最终输出的都一样，都输出 4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决这个问题的一种方案是使用更多的闭包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> liElements = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt; liElements.length; i++)&#123;</span><br><span class="line">  (liElements[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;)() <span class="comment">// 匿名闭包</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 闭包-函数工厂</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt; liElements.length; i++)&#123;</span><br><span class="line">  liElements[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    conFun(i)()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">conFun</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// const let</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt; liElements.length; i++)&#123;</span><br><span class="line">  liElements[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>性能考量:</strong><br>使用闭包可以隐藏变量以及防止变量被篡改和作用域的污染，从而实现封装。<br>而缺点就是由于保留了作用域链，会增加内存的开销。因此需要注意内存的使用，并且防止内存泄露的问题.<br>解决方法是：在退出函数之前，将不使用的局部变量全部删除；闭包会在函数外部，改变函数内部变量的值。</p><h3 id="46-title与h1的区别、b与strong的区别、i与em的区别？"><a href="#46-title与h1的区别、b与strong的区别、i与em的区别？" class="headerlink" title="46.title与h1的区别、b与strong的区别、i与em的区别？"></a>46.title与h1的区别、b与strong的区别、i与em的区别？</h3><p><strong>title与h1的区别:</strong></p><ul><li>定义<br>title是网站标题，一个页面只能有一个<br>h1是文章主题</li><li>作用<br>title概括网站信息，可以直接告诉搜索引擎和用户这 个网站是关于什么主题和内容的，是显示在网页Tab栏里的；<br>h1突出文章主题，面对用户，更突出其视觉效果，指向 页面主体信息，是显示在网页中的。</li><li>注意<br>如果title为空，但是页面存在h1,b,strong标签，搜索引擎会默认页面title为h1内的内容，所以 得出结论h1是在没有外界干扰下除title以外第二个能强调页面主旨的标记，在一个页面中应该使用且只使用一次h1标记。</li></ul><p><strong>b与strong的区别：</strong></p><ul><li>定义<br>b(bold)是实体标签，用来给文字加粗<br>strong是逻辑标签，作用是加强字符语气</li><li>区别<br>b标签只是加粗的样式，没有实际含义，常用来表达无强调或着中意味的粗体文字<br>trong表示标签内字符重要，用以强调，其默认格式是加粗，但是可以通过css添加样式，使用别的样式强调。在使用阅读设备时，会重读</li><li>建议：为了符合css3的规范语义化，b应尽量少用而改用strong</li></ul><p><strong>i与em的区别：</strong></p><ul><li>定义<br>i(italic)是实体标签，用来使字符倾斜<br>em(emphasis)是逻辑标签，作用是强调文本内容</li><li>区别<br>i标签只是斜体的样式，没有实际含义，常用来表达无强调或着重意味的斜体，比如生物学名、术语、外来语；<br>em表示标签内字符重要，用以强调，其默认格式是斜体，但是可以通过CSS添加样式。在使用阅读设备时，会重读</li><li>建议：为了符合CSS3的规 范，i应尽量少用而改用em。</li></ul><p>物理元素是告诉浏览器我应该以何种格式显示文字，逻辑元素告诉浏览器这些文字有怎么样的重要性。<br>对于搜索引擎来说em和strong比i和b要重视的多。</p><h3 id="47-style标签写在body前和body后的区别是什么？"><a href="#47-style标签写在body前和body后的区别是什么？" class="headerlink" title="47.style标签写在body前和body后的区别是什么？"></a>47.style标签写在body前和body后的区别是什么？</h3><p>在 HTML4 的时候，不应该把 style 放到 body 中间。</p><p>浏览器在渲染页面时 DOM 和 CSSOM 是并行的，然后两者结合形成 Render Tree 显示页面。从直觉上来说，style 写在 body 前不会对 DOM 的渲染进行阻塞；而写在 body 内会对 DOM 渲染进行阻塞。会产生 FOUC（Flash of Unstyled Content) 的现象，既一瞬间的白屏或者样式的突然变化（原因是 Render Tree 重新生成了）。</p><p>不过 W3C 在 HTML5.2 的定义中对于 style 标签的使用的定义中是允许将 style 放到 body 中的.</p><h3 id="48-写一个数组去重的方法（支持多维数组）"><a href="#48-写一个数组去重的方法（支持多维数组）" class="headerlink" title="48.写一个数组去重的方法（支持多维数组）"></a>48.写一个数组去重的方法（支持多维数组）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatArr</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(item)) &#123;</span><br><span class="line">        result = result.concat(...flatArr(item))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.push(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dupRemove</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    arr = flatArr(arr)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</span><br><span class="line">&#125;</span><br><span class="line">dupRemove([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>], <span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>]],<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">9</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>, <span class="number">5</span>]]]) <span class="comment">// [1, 2, 3, 4, 5, 6, 8, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.不展开数组去重</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dupRemove</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  arr = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</span><br><span class="line">  arr.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(item)) &#123;</span><br><span class="line">      arr[index] = dupRemove(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line">dupRemove([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>], <span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>]],<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">9</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>, <span class="number">5</span>]]]) <span class="comment">// [1, 2, 3, Array(2), Array(4), 5, 6, 8, 4, 9, Array(3), Array(3), Array(2), Array(4)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dupRemove</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...new <span class="built_in">Set</span>(arr.flat(<span class="literal">Infinity</span>))]</span><br><span class="line">&#125;</span><br><span class="line">dupRemove([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>,<span class="number">5</span>], <span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>]],<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">9</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,[<span class="number">4</span>, <span class="number">5</span>]]]) <span class="comment">// [1, 2, 3, 4, 5, 6, 8, 9]</span></span><br></pre></td></tr></table></figure><h3 id="49-元素的alt和title有什么区别？"><a href="#49-元素的alt和title有什么区别？" class="headerlink" title="49.元素的alt和title有什么区别？"></a>49.元素的alt和title有什么区别？</h3><p><strong>alt：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;#&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;alt 信息&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>当图片不输出信息的时候，会显示 alt 信息， 鼠标放上去没有信息。<br>当图片正常读取，不会出现 alt 信息。</p><p><strong>title：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;#&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;alt 信息&quot;</span> <span class="attr">title</span>=<span class="string">&quot;title 信息&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>当图片不输出信息的时候，会显示 alt 信息，鼠标放上去会出现 title 信息。<br>当图片正常输出的时候，不会出现 alt 信息，鼠标放上去会出现 title 信息。</p><h3 id="50-请描述margin边界叠加是什么及解决方案"><a href="#50-请描述margin边界叠加是什么及解决方案" class="headerlink" title="50.请描述margin边界叠加是什么及解决方案"></a>50.请描述margin边界叠加是什么及解决方案</h3><p>块的上外边距 (margin-top)和下外边距 (margin-bottom)有时合并 (折叠) 为单个边距，其大小为单个边距的最大值 (或如果它们相等，则仅为其中一个)，这种行为称为边距折叠。</p><p>注：有设定float和position=absolute的元素不会产生外边距重叠行为。</p><p>有三种情况会形成外边距重叠：</p><ul><li>同一层相邻元素之间<br>相邻的两个元素之间的外边距重叠，除非后一个元素加上<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear%3E">clear-fix 清除浮动</a></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child(1)</span>&#123;</span></span><br><span class="line">  margin-bottom: 13px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-tag">p</span><span class="selector-pseudo">:nth-child(2)</span>&#123;</span></span><br><span class="line">  margin-top: 87px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>下边界范围会...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>...会跟这个元素的上边界范围重叠。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>没有内容将父元素和后代元素分开<br>如果没有边框border，内边距padding，行内内容，也没有创建块级格式上下文或清除浮动来分开一个块级元素的上边界margin-top 与其内一个或多个后代块级元素的上边界margin-top；或没有边框，内边距，行内内容，高度height，最小高度min-height或 最大高度max-height 来分开一个块级元素的下边界margin-bottom与其内的一个或多个后代后代块元素的下边界margin-bottom，则就会出现父块元素和其内后代块元素外边界重叠，重叠部分最终会溢出到父级块元素外面。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line">    section    &#123;</span><br><span class="line">        margin-top: 13px;</span><br><span class="line">        margin-bottom: 87px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    header &#123;</span><br><span class="line">        margin-top: 87px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    footer &#123;</span><br><span class="line">        margin-bottom: 13px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span>上边界重叠 87<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">main</span>&gt;</span><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span>下边界重叠 87 不能再高了<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>空的块级元素<br>当一个块元素上边界margin-top 直接贴到元素下边界margin-bottom时也会发生边界折叠。这种情况会发生在一个块元素完全没有设定边框border、内边距padding、高度height、最小高度min-height 、最大高度max-height 、内容设定为 inline 或是加上clear-fix的时候。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">​​​​​​p &#123;</span><br><span class="line">  margin: 0;</span><br><span class="line">&#125;</span><br><span class="line">div &#123;</span><br><span class="line">  margin-top: 13px;</span><br><span class="line">  margin-bottom: 87px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>上边界范围是 87 ...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>... 上边界范围是 87<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解决方法，可以通过触发BFC解决：</p><ul><li>1、根元素，即 html</li><li>2、float 的值不为 none（默认）</li><li>3、overflow 的值不为 visible（默认）</li><li>4、display 的值为 inline-block、table-cell、table-caption</li><li>5、position 的值为 absolute 或 fixed</li><li>6.外层padding</li><li>7.透明边框border:1px solid transparent;</li></ul><h3 id="51-返回到顶部的方法有哪些？"><a href="#51-返回到顶部的方法有哪些？" class="headerlink" title="51.返回到顶部的方法有哪些？"></a>51.返回到顶部的方法有哪些？</h3><p>1.window.scrollTo(0,0) ie支持不好<br>2.window.scroll(0,0) 和scrollTo类似<br>3.<code>&lt;a href=&quot;#&quot;&gt;top&lt;/a&gt;</code><br>4.location.href += ‘#’;当这个方法执行多次即有多个 # 时，页面不会有响应。<br>5.document.documentElement.scrollTop = 0;<br>6.锚点法，在顶部加个标签</p><h3 id="52-解释下-CSS-sprites的原理和优缺点分别是什么？"><a href="#52-解释下-CSS-sprites的原理和优缺点分别是什么？" class="headerlink" title="52.解释下 CSS sprites的原理和优缺点分别是什么？"></a>52.解释下 CSS sprites的原理和优缺点分别是什么？</h3><p>将一个页面涉及到的所有零星图片都包含到一张大图中， 利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位， 访问页面时避免图片载入缓慢的现象。</p><p><strong>优点：</strong><br>1.减少网页的http请求，从而大大的提高页面的性能<br><strong>缺点：</strong><br>图片合并麻烦<br>图片适应性差：在高分辨的屏幕下自适应页面，若图片不够宽会出现背景断裂。<br>图片定位繁琐<br>可维护性差</p><h3 id="53-typeof-‘abc’-和typeof-‘abc’都是string-那么typeof是操作符还是函数？"><a href="#53-typeof-‘abc’-和typeof-‘abc’都是string-那么typeof是操作符还是函数？" class="headerlink" title="53.typeof(‘abc’)和typeof ‘abc’都是string, 那么typeof是操作符还是函数？"></a>53.typeof(‘abc’)和typeof ‘abc’都是string, 那么typeof是操作符还是函数？</h3><p>typeof是操作符不是函数，括号只是进行分组而非函数。</p><h3 id="54-说说你对SVN和GIT的理解和区别"><a href="#54-说说你对SVN和GIT的理解和区别" class="headerlink" title="54.说说你对SVN和GIT的理解和区别"></a>54.说说你对SVN和GIT的理解和区别</h3><p>svn是集中式的，允许单次下载单文件修改，因为对每个文件都有对应的.svn文件控制<br>git是分布式的，每次clone都是获得一个完整的代码版本，可以不依赖服务器本地独立运行项目</p><h3 id="55-怎样在页面上实现一个圆形的可点击区域？"><a href="#55-怎样在页面上实现一个圆形的可点击区域？" class="headerlink" title="55.怎样在页面上实现一个圆形的可点击区域？"></a>55.怎样在页面上实现一个圆形的可点击区域？</h3><p>1.DOM 元素配合 border-radius: 50% 即可实现圆形点击区域<br>2.利用 <code>&lt;map&gt;</code>和 <code>&lt;area&gt;</code>标签设置圆形点击区域。参考文章:<a href="https://www.zhangxinxu.com/wordpress/2017/05/html-area-map/">HTML 标签及在实际开发中的应用</a><br>3.利用 SVG 作出圆形，然后添加点击事件。<br>4.如果在 canvas 上，就需要画出圆形，然后计算鼠标的坐标是否落在圆内。</p><h3 id="56-什么是FOUC？你是如何避免FOUC的？"><a href="#56-什么是FOUC？你是如何避免FOUC的？" class="headerlink" title="56.什么是FOUC？你是如何避免FOUC的？"></a>56.什么是FOUC？你是如何避免FOUC的？</h3><p>FOUC 即 Flash of Unstyled Content，是指页面一开始以样式 A（或无样式）的渲染，突然变成样式B。原因是样式表晚于 HTML 加载导致页面重新进行绘制。</p><ul><li>通过 @import 方式导入样式表</li><li>style 标签在 body 中</li></ul><p>解决方法：把 link 标签将样式放在 head 中</p><h3 id="57-你理解的”use-strict”-是什么-使用它有什么优缺点？"><a href="#57-你理解的”use-strict”-是什么-使用它有什么优缺点？" class="headerlink" title="57.你理解的”use strict”;是什么?使用它有什么优缺点？"></a>57.你理解的”use strict”;是什么?使用它有什么优缺点？</h3><p>JavaScript 严格模式（strict mode）即在严格的条件下运行。</p><p><strong>为什么使用严格模式:</strong></p><ul><li>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</li><li>消除代码运行的一些不安全之处，保证代码运行的安全；</li><li>提高编译器效率，增加运行速度；</li><li>为未来新版本的Javascript做好铺垫。</li></ul><p><strong>严格模式的限制:</strong></p><p>不允许使用未声明的变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line">x = <span class="number">3.14</span>; <span class="comment">// 报错 (x 未定义)</span></span><br></pre></td></tr></table></figure><p>不允许删除变量或对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">delete</span> x; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>不允许删除函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">delete</span> x <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>不允许变量重名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params">p1, p1</span>) </span>&#123;&#125;;   <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>不允许使用八进制：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">010</span>;             <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>不允许使用转义字符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> x = \<span class="number">010</span>;            <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>不允许对只读属性赋值:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;x&quot;</span>, &#123;<span class="attr">value</span>:<span class="number">0</span>, <span class="attr">writable</span>:<span class="literal">false</span>&#125;);</span><br><span class="line"></span><br><span class="line">obj.x = <span class="number">3.14</span>;            <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>不允许对一个使用getter方法读取的属性进行赋值:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="keyword">get</span> <span class="title">x</span>() &#123;<span class="keyword">return</span> <span class="number">0</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line">obj.x = <span class="number">3.14</span>;            <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>不允许删除一个不允许删除的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">Object</span>.prototype; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>变量名不能使用 “eval” 字符串:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">eval</span> = <span class="number">3.14</span>;         <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>变量名不能使用 “arguments” 字符串:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">arguments</span> = <span class="number">3.14</span>;    <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>不允许使用以下这种语句:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">with</span> (<span class="built_in">Math</span>)&#123;x = cos(<span class="number">2</span>)&#125;; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>由于一些安全原因，在作用域 eval() 创建的变量不能被调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="built_in">eval</span> (<span class="string">&quot;var x = 2&quot;</span>);</span><br><span class="line">alert (x);               <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>禁止this关键字指向全局对象:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">this</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 返回false，因为&quot;this&quot;指向全局对象，&quot;!this&quot;就是false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"><span class="meta">    &quot;use strict&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">this</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 返回true，因为严格模式下，this的值为undefined，所以&quot;!this&quot;为true。</span></span><br></pre></td></tr></table></figure><p>保留关键字:</p><p>implements<br>interface<br>let<br>package<br>private<br>protected<br>public<br>static<br>yield</p><p>注： “use strict” 指令只允许出现在脚本或函数的开头。</p><h3 id="58-可替换元素"><a href="#58-可替换元素" class="headerlink" title="58.可替换元素"></a>58.可替换元素</h3><p>在css中，可替换元素的展现效果不是由css来控制的，这些元素是一种外部对象，它们外观的渲染是独立于css的。简单来说，它们的内容不受当前文档样式的影响。CSS 可以影响可替换元素的位置，但不会影响到可替换元素自身的内容。</p><p>CSS 能对可替换元素产生的唯一影响在于，部分属性支持控制元素内容在其框中的位置或定位方式</p><p>可替换元素有：</p><ul><li>iframe</li><li>video</li><li>embed</li><li>img</li></ul><p>用 CSS content 属性插入的对象是匿名的可替换元素。它们并不存在于 HTML 标记中，因此是“匿名的“。</p><p>某些 CSS 属性可用于指定 可替换元素中包含的内容对象 在该元素的盒区域内的位置或定位方式</p><ul><li>object-fit<br>指定可替换元素的内容对象在元素盒区域中的填充方式（有些类似于 background-size ）</li><li>object-position<br>指定可替换元素的内容对象在元素盒区域中的位置。（类似于 background-position ）</li></ul><h3 id="59-css重的content属性有什么作用？有哪些场景可以用到？"><a href="#59-css重的content属性有什么作用？有哪些场景可以用到？" class="headerlink" title="59.css重的content属性有什么作用？有哪些场景可以用到？"></a>59.css重的content属性有什么作用？有哪些场景可以用到？</h3><p>css中的content属性用于::before和::after伪元素中插入内容。使用content属性拆入的内容都是匿名的<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Replaced_element">可替换元素</a>。</p><p>content的值：</p><ul><li>none: 不会产生伪元素</li><li>normal: before 和 :after 伪类元素中会被视为 none</li><li><code>&lt;string&gt;</code>: 文本内容</li><li><code>&lt;uri&gt;</code>: url(‘<a href="http://www.example.com/test.html&#39;),URI">http://www.example.com/test.html&#39;),URI</a> 值会指定一个外部资源（比如图片）</li><li><code>&lt;counter&gt;</code>:计数器可以指定两种不同的函数：counter() 或 counters()</li><li>attr(x): 将元素的x属性以字符串形式返回。如果该元素没有 X 属性，则返回一个空字符串。区分大小写的属性返回值依赖文挡的语言设定。</li><li>open-quote | close-quote：这些值会被 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/quotes">quotes</a> 中定义的字符串替换</li><li>no-open-quote | no-close-quote:不会生产任何内容，但是会改变（增加或降低）引号层级。</li></ul><h3 id="60-“attribute”和“property”有什么不同？"><a href="#60-“attribute”和“property”有什么不同？" class="headerlink" title="60.“attribute”和“property”有什么不同？"></a>60.“attribute”和“property”有什么不同？</h3><p><strong>property:</strong></p><ul><li>是DOM的属性，js中的对象</li><li>读取方式，element.id,element.value,element.className</li><li>设置方式：element.id = newId</li><li>对大小写敏感</li></ul><p><strong>attribute：</strong></p><ul><li>是HTML的属性，直接在html标签添加的都是attribute属性</li><li>读取方式：element.getAttribute(“attrName”),比如element.getAttribute(‘class’)</li><li>设置方式：element.setAttribute(“attrName”, value)</li></ul><h3 id="61-请描述HTML元素的显示优先级"><a href="#61-请描述HTML元素的显示优先级" class="headerlink" title="61.请描述HTML元素的显示优先级"></a>61.请描述HTML元素的显示优先级</h3><p>元素的显示优先级，即元素覆盖次序的规则。显示优先级规则如下：</p><ul><li>帧元素（frameset）&gt; 表单元素 &gt; 非表单元素；</li><li>有窗口元素 &gt; 无窗口元素；</li><li>同一类元素间，z-index 值大的元素 &gt; z-index 值小的元素。</li></ul><p>表单元素：文本输入框、密码输入框、单选框、复选框、文本输入域、列表框等等；</p><p>非表单元素：a、div、table、span 等等；</p><p>有窗口元素：select 元素、object 元素、frames 元素等等；</p><p>无窗口元素：大部分 html 元素都是无窗口元素，如 a、table 等等</p><h3 id="62-要让Chrome支持小于12px的文字怎么做？"><a href="#62-要让Chrome支持小于12px的文字怎么做？" class="headerlink" title="62.要让Chrome支持小于12px的文字怎么做？"></a>62.要让Chrome支持小于12px的文字怎么做？</h3><ol><li>改用图片</li><li>使用 -webkit-text-size-adjust:none; 但是不支持chrome 27.0以上版本</li><li>使用 transform: scale()缩小</li></ol><ul><li>transform 对行内元素无效，因此要么使用 display: block; 要么使用 display: inline-block;</li><li>transform 即使进行了缩放，原来元素还是会占据对应的位置。因此需要做调整，最好是在外面再包一层元素，以免影响其他元素。</li></ul><h3 id="63-身份证号校验的方法"><a href="#63-身份证号校验的方法" class="headerlink" title="63.身份证号校验的方法"></a>63.身份证号校验的方法</h3><p>身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)</p><h3 id="64-谈谈你对input元素中readonly和disabled属性的理解"><a href="#64-谈谈你对input元素中readonly和disabled属性的理解" class="headerlink" title="64.谈谈你对input元素中readonly和disabled属性的理解"></a>64.谈谈你对input元素中readonly和disabled属性的理解</h3><p><strong>readonly:</strong><br>这个布尔属性指明无法修改控件的值。如果控件的type属性为hidden,range,color,checkbox,radio,file,此属性将被忽略。可以被提交，可以tab获取焦点</p><p><strong>disabled:</strong><br>这个布尔属性指明表单控件不可用。特别是在禁用的控件中，click事件将不会被分发。并且，禁用的控件的值在提交表单时也不会被提交。如果 type 属性为 hidden，此属性将被忽略。不可获取焦点。</p><h3 id="65-说说你对line-height是如何理解的"><a href="#65-说说你对line-height是如何理解的" class="headerlink" title="65.说说你对line-height是如何理解的"></a>65.说说你对line-height是如何理解的</h3><p>line-height CSS 属性用于设置多行元素的空间量，如多行文本的间距。对于块级元素，它指定元素行盒（line boxes）的最小高度。对于非替代的 inline 元素，它用于计算行盒（line box）的高度。</p><p>line-height 属性被指定为以下任何一个：</p><ul><li>一个数字： line-height: 2;</li><li>一个长度： line-height: 2em;</li><li>一个百分比： line-height: 30%;</li><li>关键词：normal</li></ul><p><strong>取值：</strong></p><ul><li>normal: 取决于用户端，桌面浏览器（包括 Firefox）使用默认值，约为1.2，这取决于元素的 font-family。</li><li>数字：该属性的应用值是这个无单位数字&lt;数字&gt;乘以该元素的字体大小</li><li>长度：line-height: 2em;。以 em 为单位的值可能会产生不确定的结果。</li><li>百分比： 与元素自身的字体大小有关。计算值是给定的百分比值乘以元素计算出的字体大小</li></ul><h3 id="66-写一个方法验证是否是中文？"><a href="#66-写一个方法验证是否是中文？" class="headerlink" title="66.写一个方法验证是否是中文？"></a>66.写一个方法验证是否是中文？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用的Unicode 编码 4e00 和 9fa5 分别表示第一个汉字和最后一个汉字的编码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isChinese</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> re = <span class="regexp">/^[\u4e00-\u9fa5]+$/</span>;</span><br><span class="line">  <span class="keyword">return</span> re.test(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="67-来说说你对重绘和重排的理解，以及如何优化"><a href="#67-来说说你对重绘和重排的理解，以及如何优化" class="headerlink" title="67.来说说你对重绘和重排的理解，以及如何优化?"></a>67.来说说你对重绘和重排的理解，以及如何优化?</h3><p>浏览器渲染过程如下：</p><ul><li>解析HTML，生成DOM树，解析CSS，生成CSSOM树</li><li>将DOM树和CSSOM树结合，生成渲染树(Render Tree)</li><li>Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）</li><li>Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</li><li>Display:将像素发送给GPU，展示在页面上</li></ul><p>通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流</p><p>我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。</p><p>何时发生回流重绘</p><ul><li>添加或删除可见的DOM元素</li><li>元素的位置发生变化</li><li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li><li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。</li><li>页面一开始渲染的时候（这肯定避免不了）</li><li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</li></ul><p>注意：回流一定会触发重绘，而重绘不一定会回流根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。</p><p>当你获取布局信息的操作的时候，会强制队列刷新</p><p>最小化重绘和重排：</p><p>  批量修改DOM：<br>  使元素脱离文档流<br>  对其进行多次修改<br>  将元素带回到文档中。</p><p>有三种方式可以让DOM脱离文档流：</p><p>  隐藏元素，应用修改，重新显示<br>  使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。<br>  将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。</p><h3 id="68-js放在html的-lt-body-gt-和-lt-head-gt-有什么区别？"><a href="#68-js放在html的-lt-body-gt-和-lt-head-gt-有什么区别？" class="headerlink" title="68.js放在html的&lt;body&gt;和&lt;head&gt;有什么区别？"></a>68.js放在html的<code>&lt;body&gt;</code>和<code>&lt;head</code>&gt;有什么区别？</h3><p>点击查看<a href="/ZJY.github.io/2021/04/11/script%E6%A0%87%E7%AD%BE%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/" title="script标签的加载和执行">script标签的加载和执行</a></p><h3 id="69-说说浏览器解析CSS选择器的过程？"><a href="#69-说说浏览器解析CSS选择器的过程？" class="headerlink" title="69.说说浏览器解析CSS选择器的过程？"></a>69.说说浏览器解析CSS选择器的过程？</h3><p><strong>浏览器渲染过程：</strong><br><img src="/ZJY.github.io/images/browerRender.png" alt="images"></p><p>浏览器渲染分为两部分：</p><ul><li>HTML Parser生成DOM树;</li><li>CSS Parser生成Style Rules;</li></ul><p>之后DOM树和Style Rules会生产Render Tree渲染树，结合Layout绘制在屏幕上，从而展现出来。</p><p><strong>CSS 选择器解析顺序：</strong><br>解析 CSS 选择器时是从右往左解析。<br>如果采用从左至右的方式读取 CSS 规则，那么大多数规则读到最后（最右）才会发现是不匹配的，这样会做费时耗能，最后有很多都是无用的；而如果采取从右向左的方式，那么只要发现最右边选择器不匹配，就可以直接舍弃了，避免了许多无效匹配。</p><p>浏览器 CSS 匹配核心算法的规则是以从右向左方式匹配节点的。这样做是为了减少无效匹配次数，从而匹配快、性能更优。</p><h3 id="70-你对new-运算符的理解是什么？手动实现一个new方法"><a href="#70-你对new-运算符的理解是什么？手动实现一个new方法" class="headerlink" title="70.你对new 运算符的理解是什么？手动实现一个new方法"></a>70.你对new 运算符的理解是什么？手动实现一个new方法</h3><p>new 运算符创建一个用户定义的对象类型的实例或者具有构造函数的内置对象的实例。</p><p><strong>语法：</strong><br>new constructor[(arguments)]</p><p>参数：</p><ul><li>constructor: 一个指定对象实例的类型的类或函数</li><li>arguments：一个用于被constructor调用的参数列表。</li></ul><p>描述：</p><p>new 关键字会进行如下操作：</p><ul><li>创建一个空的简单js对象（即{}）；</li><li>为新创建的对象添加属性<strong>proto</strong>,将该属性链接到构造函数的原型对象；</li><li>将新创建的对象作为this的上下文；</li><li>如果该函数没有返回对象，则返回this；</li></ul><p>创建一个用户自定义对象需要两步：<br>1.通过编写函数来定义对象类型<br>2.通过new来创建对象实例</p><p>下面的代码将一个值为 null 的 color 属性添加到 car 类型的所有对象，然后仅在实例对象 car1 中用字符串 “black” 覆盖该值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">car1 = <span class="keyword">new</span> Car();</span><br><span class="line">car2 = <span class="keyword">new</span> Car();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(car1.color);    <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">Car.prototype.color = <span class="string">&quot;original color&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(car1.color);    <span class="comment">// original color</span></span><br><span class="line"></span><br><span class="line">car1.color = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(car1.color);   <span class="comment">// black</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(car1.__proto__.color) <span class="comment">//original color</span></span><br><span class="line"><span class="built_in">console</span>.log(car2.__proto__.color) <span class="comment">//original color</span></span><br><span class="line"><span class="built_in">console</span>.log(car1.color)  <span class="comment">// black</span></span><br><span class="line"><span class="built_in">console</span>.log(car2.color) <span class="comment">// original color</span></span><br></pre></td></tr></table></figure><p>如果你没有使用 new 运算符，构造函数会像其他的常规函数一样被调用，并不会创建一个对象。在这种情况下， this 的指向也是不一样的。</p><p>对象类型和对象实例:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// car汽车对象类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">make, model, year</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.make = make;</span><br><span class="line">   <span class="built_in">this</span>.model = model;</span><br><span class="line">   <span class="built_in">this</span>.year = year;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对象实例</span></span><br><span class="line"><span class="keyword">var</span> mycar = <span class="keyword">new</span> Car(<span class="string">&quot;Eagle&quot;</span>, <span class="string">&quot;Talon TSi&quot;</span>, <span class="number">1993</span>);</span><br></pre></td></tr></table></figure><p>对象属性为其他对象:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义了一个对象叫做 person：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name = name;</span><br><span class="line">   <span class="built_in">this</span>.age = age;</span><br><span class="line">   <span class="built_in">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实例化两个新的 person 对象如下：</span></span><br><span class="line"><span class="keyword">var</span> rand = <span class="keyword">new</span> Person(<span class="string">&quot;Rand McNally&quot;</span>, <span class="number">33</span>, <span class="string">&quot;M&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> ken = <span class="keyword">new</span> Person(<span class="string">&quot;Ken Jones&quot;</span>, <span class="number">39</span>, <span class="string">&quot;M&quot;</span>);</span><br><span class="line"><span class="comment">// 可以重写 car 的定义，添加一个值为 person 对象的 owner 属性，如下：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">make, model, year, owner</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.make = make;</span><br><span class="line">   <span class="built_in">this</span>.model = model;</span><br><span class="line">   <span class="built_in">this</span>.year = year;</span><br><span class="line">   <span class="built_in">this</span>.owner = owner;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实例化新的对象</span></span><br><span class="line"><span class="keyword">var</span> car1 = <span class="keyword">new</span> Car(<span class="string">&quot;Eagle&quot;</span>, <span class="string">&quot;Talon TSi&quot;</span>, <span class="number">1993</span>, rand);</span><br><span class="line"><span class="keyword">var</span> car2 = <span class="keyword">new</span> Car(<span class="string">&quot;Nissan&quot;</span>, <span class="string">&quot;300ZX&quot;</span>, <span class="number">1992</span>, ken);</span><br><span class="line"><span class="built_in">console</span>.log(car2.owner.name) <span class="comment">// Ken Jones</span></span><br></pre></td></tr></table></figure><p><strong>模拟new：</strong></p><p>Object.create()方法创建一个新的对象,使用现有的对象来提供新创建对象的<strong>proto</strong>.<br>语法：Object.create(proto, [propertiesObject])：</p><ul><li>参数proto为新创建对象的原型对象</li><li>propertiesObject:可选,需要传入一个对象.该对象的属性类型<br>查看-<a href="/ZJY.github.io/2021/03/01/javascript%E7%9A%84Object-create%E6%96%B9%E6%B3%95/" title="javascript的Object.create方法">javascript的Object.create方法</a></li></ul><p>apply用来重新定义this对象的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_new</span>(<span class="params">fn, ...arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(fn.prototype)</span><br><span class="line">  <span class="comment">// obj: &#123;</span></span><br><span class="line">  <span class="comment">//   __proto__: &#123;</span></span><br><span class="line">  <span class="comment">//     fn.prototype</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="keyword">const</span> _this = fn.apply(obj, arg) <span class="comment">// _this对象的this指向obj</span></span><br><span class="line">  <span class="keyword">return</span> _this <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? _this : obj</span><br></pre></td></tr></table></figure><p>扩展：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object.create示例：</span></span><br><span class="line"><span class="keyword">var</span> aObj = &#123;</span><br><span class="line">    a:<span class="string">&#x27;zjy&#x27;</span>,</span><br><span class="line">    b:<span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">    c:<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;n:&#x27;</span>+n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> _aObj = <span class="built_in">Object</span>.create(aObj,&#123;</span><br><span class="line">    txt:&#123;</span><br><span class="line">        value:<span class="string">&#x27;Object.create()方法的继承&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(_aObj);</span><br><span class="line"><span class="comment">// _aObj&#123;</span></span><br><span class="line"><span class="comment">//     txt:&#x27;Object.create()方法的继承&#x27;,</span></span><br><span class="line"><span class="comment">//     __proto__:&#123;</span></span><br><span class="line"><span class="comment">//         a:&#x27;zjy&#x27;,</span></span><br><span class="line"><span class="comment">//         b:&#x27;name&#x27;,</span></span><br><span class="line"><span class="comment">//         c:funtion()</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">_aObj.c(<span class="string">&#x27;haha&#x27;</span>); <span class="comment">// n:haha</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// call/apply/bind示例：</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;wang&#x27;</span>,age = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;zhang&#x27;</span>,</span><br><span class="line">    objAag: <span class="built_in">this</span>.age,</span><br><span class="line">    myFun:<span class="function"><span class="keyword">function</span>(<span class="params">fm,t</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;年龄&#x27;</span> + <span class="built_in">this</span>.age,<span class="string">&#x27;来自 &#x27;</span>+ fm+<span class="string">&#x27; 去往&#x27;</span>+t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> db = &#123;</span><br><span class="line">    name:<span class="string">&#x27;dema&#x27;</span>,</span><br><span class="line">    age: <span class="number">99</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.myFun.call(db,<span class="string">&#x27;成都&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>); <span class="comment">//dema年龄99 来自 成都 去往上海</span></span><br><span class="line">obj.myFun.apply(db,[<span class="string">&#x27;成都&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>]); <span class="comment">//dema年龄99 来自 成都 去往上海</span></span><br><span class="line">obj.myFun.bind(db,[<span class="string">&#x27;成都&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>])(); <span class="comment">//dema年龄99 来自 成都,上海 去往undefined</span></span><br><span class="line">obj.myFun.bind(db,<span class="string">&#x27;成都&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>)(); <span class="comment">//dema年龄99 来自 成都 去往上海</span></span><br><span class="line">obj.myFun.bind(db)(<span class="string">&#x27;成都&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>); <span class="comment">// dema年龄99 来自 成都 去往上海</span></span><br></pre></td></tr></table></figure><h3 id="71-关于-lt-form-gt-标签的enctype属性你有哪些了解？"><a href="#71-关于-lt-form-gt-标签的enctype属性你有哪些了解？" class="headerlink" title="71.关于&lt;form&gt;标签的enctype属性你有哪些了解？"></a>71.关于<code>&lt;form&gt;</code>标签的enctype属性你有哪些了解？</h3><p>当method属性为post时，enctype就是将表单的内容提交给服务器的MIME类型。可能的值有：</p><ul><li>application/x-www-form-urlencoded: 未指定属性时的默认值，在发送前对所有字符进行编码（将空格转换为 “+” 符号，特殊字符转换为 ASCII HEX 值）。</li><li>mulipart/form-data:当表单包含type=file的input元素时使用此值。</li><li>text/plain: 表单以纯文本形式进行编码.将空格转换为 “+” 符号，但不编码特殊字符.</li></ul><h3 id="72-说说CSS的优先级是如何计算的？"><a href="#72-说说CSS的优先级是如何计算的？" class="headerlink" title="72.说说CSS的优先级是如何计算的？"></a>72.说说CSS的优先级是如何计算的？</h3><p>优先级就是分配给指定的 CSS 声明的一个权重，它由 匹配的选择器中的 每一种选择器类型的 数值 决定。<br>当同一个元素有多个声明的时候，优先级才会有意义</p><p>css里的c代表cascade,层叠，层叠决定了如何解决冲突，是css语言的基础。层叠会依据三种条件解决冲突。</p><p>(1) 样式表的来源：样式是从哪里来的，包括你的样式和浏览器默认样式等。</p><p>(2) 选择器优先级：哪些选择器比另一些选择器更重要。</p><p>(3) 源码顺序：样式在样式表里的声明顺序。</p><p><strong>1.样式表的来源:</strong></p><p>  你添加到网页里的样式表并不是浏览器唯一使用的样式表，还有其他类型或来源的样式表。你的样式表属于作者样式表，除此之外还有用户代理样式表，即浏览器默认样式。用户代理样式表优先级低，你的样式会覆盖它们.</p><p>  ! important声明会被当作更高优先级的来源，因此总体的优先级按照由高到低排列如下所示：<br>  (1) 作者的！important<br>  (2) 作者的样式表<br>  (3) 用户代理样式表</p><p>  层叠规则顺序：不同来源的声明-内联声明-选择器优先级声明-源码顺序声明</p><p><strong>2.选择器优先级：</strong></p><p>伪类选择器（:hover）和属性选择器（[type=”input”]）与一个类选择器的优先级相同。<br>通用选择器（*）和组合选择器（&gt;,+,~）对优先级无影响。</p><p>!important &gt; 内联样式 &gt; id &gt; 类选择器((例如，.example)，属性选择器（例如，[type=”radio”]）和伪类（例如，:hover）) &gt; 类型选择器（例如，h1）和伪元素（例如，::before） &gt; * &gt; 继承 &gt;默认</p><h3 id="73-0-1-0-2、0-1-0-3和0-1-0-2分别等于多少？并解释下为什么？"><a href="#73-0-1-0-2、0-1-0-3和0-1-0-2分别等于多少？并解释下为什么？" class="headerlink" title="73.0.1 + 0.2、0.1 + 0.3和0.1 * 0.2分别等于多少？并解释下为什么？"></a>73.0.1 + 0.2、0.1 + 0.3和0.1 * 0.2分别等于多少？并解释下为什么？</h3><p>Javascript不详细区分整数、浮点数以及带符号的数字类型。使用双精度的64位浮点数字格式（IEEE 754）来表示数字，因此数字本质上都是浮点数。在该格式中，符号占1位（bit），指数部分占11位，小数部分占52位，共64位。</p><p>简单来说就是js中采用IEEE754的双精度标准，因为精度不足导致的问题。</p><p>0.1不再是 0.1 了，而是变成了 0.100000000000000002</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.100000000000000002</span> === <span class="number">0.1</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>0.2 :0.200000000000000002</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.200000000000000002</span> === <span class="number">0.2</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>由此我们可以得出:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.30000000000000004</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>所以0.1+0.2 != 0.3</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>((<span class="number">0.1</span>+<span class="number">0.2</span>).toFixed(<span class="number">10</span>)) === <span class="number">0.3</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="74-对属性data-的理解"><a href="#74-对属性data-的理解" class="headerlink" title="74.对属性data-的理解"></a>74.对属性data-的理解</h3><p>data-*全局属性是一类被称为自定义数据属性的属性，它赋予我们在所有 HTML 元素上嵌入自定义数据属性的能力，并可以通过脚本在 HTML 与 DOM 表现之间进行专有数据的交换。</p><p><strong>HTML语法.</strong></p><p>所有元素上以data-开头的属性为数据属性。</p><p>比如说你有一篇文章，而你又想要存储一些不需要显示在浏览器上的额外信息。请使用 data 属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;article</span><br><span class="line">  id=&quot;electriccars&quot;</span><br><span class="line">  data-columns=&quot;3&quot;</span><br><span class="line">  data-index-number=&quot;12314&quot;</span><br><span class="line">  data-parent=&quot;cars&quot;&gt;</span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure><p>写入数据属性:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> article = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#electriccars&#x27;</span>);</span><br><span class="line"></span><br><span class="line">article.dataset.column = <span class="number">5</span>; <span class="comment">// 将column修改为5</span></span><br><span class="line"><span class="built_in">console</span>.log(article.dataset.columns); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p><strong>JavaScript 访问.</strong></p><p>可以使用getAttribute()配合它们完整的 HTML 名称去读取它们.</p><p>为了使用dataset对象去获取到数据属性，需要获取属性名中data-之后的部分 (要注意的是破折号连接的名称需要改写为骆驼拼写法 (如”index-number”转换为”indexNumber”))。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> article = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#electriccars&#x27;</span>);</span><br><span class="line"></span><br><span class="line">article.dataset.columns <span class="comment">// &quot;3&quot;</span></span><br><span class="line">article.dataset.indexNumber <span class="comment">// &quot;12314&quot;</span></span><br><span class="line">article.dataset.parent <span class="comment">// &quot;cars&quot;</span></span><br></pre></td></tr></table></figure><p><strong>CSS 访问.</strong></p><p>data 设定为 HTML 属性，他们同样能被CSS访问</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="built_in">attr</span>(data-parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也同样可以在 CSS 中使用属性选择器根据 data 来改变样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span><span class="selector-attr">[data-columns=<span class="string">&#x27;3&#x27;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">article</span><span class="selector-attr">[data-columns=<span class="string">&#x27;4&#x27;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="75-如何快速让一个数组乱序"><a href="#75-如何快速让一个数组乱序" class="headerlink" title="75.如何快速让一个数组乱序"></a>75.如何快速让一个数组乱序</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = array.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">let</span> j = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (i + <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">var</span> target = array[j]</span><br><span class="line">    array[j] = array[i]</span><br><span class="line">    array[i] = target </span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line">shuffle([ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> ]) <span class="comment">//  [1, 3, 9, 4, 8, 10, 7, 2, 6, 5]</span></span><br></pre></td></tr></table></figure><h3 id="76-请说说-lt-script-gt-、-lt-script-async-gt-和-lt-script-defer-gt-的区别"><a href="#76-请说说-lt-script-gt-、-lt-script-async-gt-和-lt-script-defer-gt-的区别" class="headerlink" title="76.请说说&lt;script&gt;、&lt;script async&gt;和&lt;script defer&gt;的区别?"></a>76.请说说<code>&lt;script&gt;</code>、<code>&lt;script async&gt;</code>和<code>&lt;script defer&gt;</code>的区别?</h3><p>点击查看<a href="/ZJY.github.io/2021/04/11/script%E6%A0%87%E7%AD%BE%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/" title="script标签的加载和执行">script标签的加载和执行</a></p><h3 id="77-写一个判断设备来源的方法"><a href="#77-写一个判断设备来源的方法" class="headerlink" title="77.写一个判断设备来源的方法"></a>77.写一个判断设备来源的方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkPlatform</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> userAgentInfo = navigator.userAgent;</span><br><span class="line">  <span class="keyword">const</span> Agents = [<span class="string">&#x27;Android&#x27;</span>, <span class="string">&#x27;iPhone&#x27;</span>, <span class="string">&#x27;SysbianOS&#x27;</span>, <span class="string">&#x27;Windows Phone&#x27;</span>, <span class="string">&#x27;iPad&#x27;</span>, <span class="string">&#x27;iPod&#x27;</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; Agents.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (userAgentInfo.indexOf(Agents[i]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> alert(<span class="string">&#x27;当前为移动端设备，机型为：&#x27;</span> + Agents[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> alert(<span class="string">&#x27;当前为PC端&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">checkPlatform();</span><br></pre></td></tr></table></figure><p>或者<a href="https://github.com/matthewhudson/current-device">https://github.com/matthewhudson/current-device</a></p><h3 id="78-解释下你对GBK和UTF-8的理解？并说说页面上产生乱码的可能原因"><a href="#78-解释下你对GBK和UTF-8的理解？并说说页面上产生乱码的可能原因" class="headerlink" title="78.解释下你对GBK和UTF-8的理解？并说说页面上产生乱码的可能原因"></a>78.解释下你对GBK和UTF-8的理解？并说说页面上产生乱码的可能原因</h3><p><strong>GBK编码：</strong><br>是指中国的中文字符，其它它包含了简体中文与繁体中文字符，另外还有一种字符“gb2312”，这种字符仅能存储简体中文字符。</p><p><strong>UTF-8编码：</strong><br>它是一种全国家通过的一种编码，如果你的网站涉及到多个国家的语言，那么建议你选择UTF-8编码。由于 UTF-8 包含了多种语言，也因此其占用的空间会比较大一些。</p><p>而网页产生乱码往往是因为编码与解码不匹配造成的。一般我们会在<code>&lt;meta&gt;</code> 标签中设置 charset 来决定网页采用的编码。如果引用的文件为其他格式，则会出现无法解释或者解释不对的字符，即乱码问题。</p><h3 id="79-说说你对z-index的理解"><a href="#79-说说你对z-index的理解" class="headerlink" title="79.说说你对z-index的理解"></a>79.说说你对z-index的理解</h3><p>查看<a href="/ZJY.github.io/2021/04/11/css%E4%B8%AD%E7%9A%84z-index%E5%B1%9E%E6%80%A7/" title="css中的z-index属性">css中的z-index属性</a></p><h3 id="80-说说bind、call、apply的区别？并手写实现一个bind的方法"><a href="#80-说说bind、call、apply的区别？并手写实现一个bind的方法" class="headerlink" title="80.说说bind、call、apply的区别？并手写实现一个bind的方法"></a>80.说说bind、call、apply的区别？并手写实现一个bind的方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;wang&#x27;</span>,age = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;zhang&#x27;</span>,</span><br><span class="line">    objAag: <span class="built_in">this</span>.age,</span><br><span class="line">    myFun:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;年龄&#x27;</span> + <span class="built_in">this</span>.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.objAag; <span class="comment">//17</span></span><br><span class="line">obj.myFun(); <span class="comment">//zhang年龄undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用call/apply/bind</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db = &#123;</span><br><span class="line">    name:<span class="string">&#x27;dema&#x27;</span>,</span><br><span class="line">    age: <span class="number">99</span></span><br><span class="line">&#125;</span><br><span class="line">obj.myFun.call(db); <span class="comment">// dema年龄99</span></span><br><span class="line">obj.myFun.apply(db); <span class="comment">// dema年龄99</span></span><br><span class="line">obj.myFun.bind(db)(); <span class="comment">// dema年龄99</span></span><br></pre></td></tr></table></figure><p>以上除了bind多了个（）外，结果都一致，由此可知，bind返回的是一个新函数，必须调用它能执行</p><p>call/apply/bind 传参数区别</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;wang&#x27;</span>,age = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;zhang&#x27;</span>,</span><br><span class="line">    objAag: <span class="built_in">this</span>.age,</span><br><span class="line">    myFun:<span class="function"><span class="keyword">function</span>(<span class="params">fm,t</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;年龄&#x27;</span> + <span class="built_in">this</span>.age,<span class="string">&#x27;来自 &#x27;</span>+ fm+<span class="string">&#x27; 去往&#x27;</span>+t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> db = &#123;</span><br><span class="line">    name:<span class="string">&#x27;dema&#x27;</span>,</span><br><span class="line">    age: <span class="number">99</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.myFun.call(db,<span class="string">&#x27;成都&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>); <span class="comment">//dema年龄99 来自 成都 去往上海</span></span><br><span class="line">obj.myFun.apply(db,[<span class="string">&#x27;成都&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>]); <span class="comment">//dema年龄99 来自 成都 去往上海</span></span><br><span class="line">obj.myFun.bind(db,[<span class="string">&#x27;成都&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>])(); <span class="comment">//dema年龄99 来自 成都,上海 去往undefined</span></span><br><span class="line">obj.myFun.bind(db,<span class="string">&#x27;成都&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>)(); <span class="comment">//dema年龄99 来自 成都 去往上海</span></span><br><span class="line">obj.myFun.bind(db)(<span class="string">&#x27;成都&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>); <span class="comment">// dema年龄99 来自 成都 去往上海</span></span><br></pre></td></tr></table></figure><p>call 、bind 、 apply 这三个函数的第一个参数都是 this 的指向对象,第二个参数：<br>call的参数直接放进去，多个参数用逗号分隔<br>apply的第二个参数是数组<br>bind 除了返回是函数以外，它 的参数和 call 一样</p><p><strong>实现:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context = <span class="built_in">window</span></span>) </span>&#123;</span><br><span class="line">  context.fn = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">var</span> result = context.fn(...args)</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context = <span class="built_in">window</span></span>) </span>&#123;</span><br><span class="line">  context.fn = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">var</span> result</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>])</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.fn()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !=== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> <span class="built_in">this</span>.call(context, ...args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="81-git-branch"><a href="#81-git-branch" class="headerlink" title="81.git branch"></a>81.git branch</h3><p>git branch: 不带参数命令，获取本地仓库的分支列表，并显示当前所在分支，即head指向的分支</p><p>git branch -v: 查看每个分支的最后一次commit提交信息</p><p>git branch –merged: 查看已经合并到当前分支的分支</p><p>git branch –no-merged: 查看没有合并到当前分支的分支</p><p> git branch -D branchname: 强制删除某个分支，会丢失被删除的分支上面的所有内容。</p><h3 id="82-说说你对影子-Shadow-DOM的了解"><a href="#82-说说你对影子-Shadow-DOM的了解" class="headerlink" title="82.说说你对影子(Shadow)DOM的了解"></a>82.说说你对影子(Shadow)DOM的了解</h3><p>Shadow Dom是对标记结构、样式和行为的封装，Shadow DOM 接口可以将一个隐藏的独立的DOM附加到另一个元素上。<br>Shadow DOM 内部的元素始终不会影响到它外部的元素。<br>比如你所能看到的只是一个 <code>&lt;video&gt;</code> 标签，实际上，在它的 Shadow DOM 中，包含了一系列的按钮和其他控制器</p><p><strong>基本用法.</strong></p><p>可以使用 Element.attachShadow() 方法来将一个 shadow root(shadow tree 的根节点) 附加到任何一个元素上。它接受一个配置对象作为参数，该对象有一个 mode 属性，值可以是 open 或者 closed。</p><p>open 表示可以通过页面内的 JavaScript 方法来获取 Shadow DOM，例如使用 Element.shadowRoot 属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myShadowDom = myCustomElem.shadowRoot</span><br></pre></td></tr></table></figure><p>mode 设置为 closed，那么就不可以从外部获取 Shadow DOM 了——myCustomElem.shadowRoot 将会返回 null.<br>浏览器中的某些内置元素就是如此，例如video，包含了不可访问的 Shadow DOM。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> shadow = <span class="built_in">this</span>.attachShadow(&#123;<span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> para = <span class="built_in">document</span>.createElement(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">shadow.appendChild(para);</span><br></pre></td></tr></table></figure><p>将 Shadow DOM 附加到一个元素之后，就可以使用 DOM APIs 对它进行操作，就和处理常规 DOM 一样。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_shadow_DOM">使用 shadow DOM(MDN)</a></p><h3 id="83-怎样修改chrome记住密码后自动填充表单的黄色背景？"><a href="#83-怎样修改chrome记住密码后自动填充表单的黄色背景？" class="headerlink" title="83.怎样修改chrome记住密码后自动填充表单的黄色背景？"></a>83.怎样修改chrome记住密码后自动填充表单的黄色背景？</h3><p>-webkit-text-fill-color: red; 设置文本颜色<br>-webkit-box-shadow: 0 0 0 1000px white inset; 设置内阴影</p><h3 id="84-说说你对arguments的理解，它是数组吗？"><a href="#84-说说你对arguments的理解，它是数组吗？" class="headerlink" title="84.说说你对arguments的理解，它是数组吗？"></a>84.说说你对arguments的理解，它是数组吗？</h3><p>arguments是一个对应于传递给函数的参数的类数组对象。</p><p>类数组意味着arguments有长度属性并且属性的索引时从零开始的，但是并没有Array的内置方法，比如forEach()和map()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">arguments</span>))</span><br><span class="line">  <span class="comment">// output:  &quot;[object Arguments]&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// expected output: 1</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  <span class="comment">// expected output: 2</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">2</span>]);</span><br><span class="line">  <span class="comment">// expected output: 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>arguments对象是所有函数（非箭头函数）都可用的局部变量。可以使用arguments对象在函数中引用函数的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">arguments</span>[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">arguments</span>[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>也可以被设置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>arguments没有Array内置方法，但是可以转化为Array：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">arguments</span>))</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// expected output: 1</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  <span class="comment">// expected output: 2</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">2</span>]);</span><br><span class="line">  <span class="comment">// expected output: 3</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;args&#x27;</span>, args)</span><br><span class="line">  <span class="comment">// output: &quot;args&quot; Array [0, 2, 3]</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> args1 = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;args1&#x27;</span>, args1)</span><br><span class="line">  <span class="comment">// output: &quot;args1&quot; Array [0, 2, 3]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> args2 = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;args2&#x27;</span>, args2)</span><br><span class="line">  <span class="comment">// output: &quot;args2&quot; Array [0, 2, 3]</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> args3 = [...arguments]</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;args3&#x27;</span>, args3)</span><br><span class="line">  <span class="comment">// output: &quot;args3&quot; Array [0, 2, 3]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>arguments.callee指向参数所属的当前执行的函数。</p><h3 id="85-说说你对-lt-meta-gt-标签的理解"><a href="#85-说说你对-lt-meta-gt-标签的理解" class="headerlink" title="85.说说你对&lt;meta&gt;标签的理解"></a>85.说说你对<code>&lt;meta&gt;</code>标签的理解</h3><p>文档级元数据元素,表示那些不能被其他html元相关元素（base、link、script、style、title）之一表示的任何元数据信息。</p><p>meta 元素定义的元数据的类型包括以下几种：</p><ul><li>如果设置了name属性，meta元素提供的是文档级别的元数据，应用于整个页面。</li><li>如果设置了http-equiv属性，meta元素则是编译指令，提供的信息与类似命名的http头部相同。</li><li>如果设置了charset属性，meta元素是一个字符集声明，告诉文档用哪种字符编码。</li><li>如果设置了itemprop属性，meta元素提供用户自定义的元数据。</li></ul><p><strong>属性：</strong></p><p>备注： 全局属性 name 在 <code>&lt;meta&gt;</code>元素中具有特殊的语义；另外，在同一个 <code>&lt;meta&gt;</code>标签中，name, http-equiv 或者 charset 三者中任何一个属性存在时，itemprop 属性不能被使用。</p><ul><li>charset<br>声明字符编码，如果使用了这个属性，其值必须是与ASCLL大小写无关的“utf-8“</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>content<br>此属性包含http-equiv 或name 属性的值，具体取决于所使用的值。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;3;url=https://www.mozilla.org&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>http-equiv<br>属性定义了一个编译指示指令。这个属性叫做 http-equiv(alent) 是因为所有允许的值都是特定 HTTP 头部的名称，如下:<ul><li>content-security-policy 它允许页面作者定义当前页的内容策略 (en-US)。内容策略主要指定允许的服务器源和脚本端点，这有助于防止跨站点脚本攻击。</li><li>content-type 如果使用这个属性，其值必须是”text/html; charset=utf-8”。注意：该属性只能用于 MIME type 为 text/html 的文档，不能用于 MIME 类型为 XML 的文档。</li><li>default-style 设置默认 CSS 样式表组的名称。</li><li>x-ua-compatible 如果指定，则 content 属性必须具有值 “IE=edge”。用户代理必须忽略此指示。</li><li>refresh 这个属性指定：<br>如果 content 只包含一个正整数，则为重新载入页面的时间间隔 (秒)；<br>如果 content 包含一个正整数，并且后面跟着字符串 ‘;url=’ 和一个合法的 URL，则是重定向到指定链接的时间间隔 (秒)</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 可以在 https 协议下请求 http --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;upgrade-insecure-requests&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li>name<br>name 和 content 属性可以一起使用，以名 - 值对的方式给文档提供元数据，其中 name 作为元数据的名称，content 作为元数据的值。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 移动端页面设置视口宽度等于设备宽度，并禁止缩放。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 禁止将页面中的数字识别为电话号码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;format-detection&quot;</span> <span class="attr">content</span>=<span class="string">&quot;telephone=no&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- name=author: 用来设置作者，给 SEO 使用 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- name=keywords: 网页的关键字，给 SEO 使用 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- name=description: 页面的描述，在浏览器用作书签时会显示对应的内容 --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="87-rgba-和opacity这两个的透明效果有什么区别呢？"><a href="#87-rgba-和opacity这两个的透明效果有什么区别呢？" class="headerlink" title="87.rgba()和opacity这两个的透明效果有什么区别呢？"></a>87.rgba()和opacity这两个的透明效果有什么区别呢？</h3><p><strong>opacity:</strong></p><p>指定了一个元素的不透明度。换言之，opacity 属性指定了一个元素后面的背景的被覆盖程度。<br>当 opacity 属性的值应用于某个元素上时，是把这个元素（包括它的内容）当成一个整体看待，即使这个值没有被子元素继承。<br>因此，一个元素和它包含的子元素都会具有和元素背景相同的透明度，哪怕这个元素和它的子元素有不同的 opacity 属性值。</p><p><strong><em>使用 opacity 属性，当属性值不为 1 时，会把元素放置在一个新的层叠上下文中。</em></strong></p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 完全不透明 */</span></span><br><span class="line"><span class="selector-tag">opacity</span>: 1;</span><br><span class="line"><span class="selector-tag">opacity</span>: 1.0;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 半透明 */</span></span><br><span class="line"><span class="selector-tag">opacity</span>: 0.6;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 完全透明 */</span></span><br><span class="line"><span class="selector-tag">opacity</span>: 0.0;</span><br><span class="line"><span class="selector-tag">opacity</span>: 0;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">opacity</span>: <span class="selector-tag">inherit</span>;</span><br></pre></td></tr></table></figure><p><strong>rgba():</strong></p><p>rgba 只对颜色（backgorund-color、color）有影响，放在background的话只对背景颜色有影响，不会影响其他内容及子元素。</p><h3 id="88-解释代码意思"><a href="#88-解释代码意思" class="headerlink" title="88.解释代码意思"></a>88.解释代码意思</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[].forEach.call($$(<span class="string">&quot;*&quot;</span>),<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123; </span><br><span class="line">  a.style.outline=<span class="string">&quot;1px solid #&quot;</span>+(~~(<span class="built_in">Math</span>.random()*(<span class="number">1</span>&lt;&lt;<span class="number">24</span>))).toString(<span class="number">16</span>) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>作用：</strong><br>给页面所有 dom 元素添加随机颜色的边框。</p><p><strong>解析：</strong></p><ul><li>[].forEach.call() =&gt; 调用引用数组的forEach方法</li><li>$$(‘<em>‘) =&gt; document.querySelectorAll(‘</em>‘)</li><li>~~a =&gt; parseInt(a)</li><li>1&lt;&lt;24 =&gt; 对二进数1小数点右移24位</li><li>(parseInt(Math.random()*(1&lt;&lt;24)).toString(16)) =&gt; 获得了一个位于0-16777216之间的随机整数，也就是随机颜色，再使用toString(16)将它转化为十六进制数。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[].forEach.call(</span><br><span class="line">  <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;*&#x27;</span>),</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    a.style.outline=<span class="string">&quot;1px solid #&quot;</span> + </span><br><span class="line">      (<span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random()*(<span class="number">1</span>&lt;&lt;<span class="number">24</span>)).toString(<span class="number">16</span>))</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="89-在浏览器中输入url到页面显示出来的过程发生了什么"><a href="#89-在浏览器中输入url到页面显示出来的过程发生了什么" class="headerlink" title="89.在浏览器中输入url到页面显示出来的过程发生了什么?"></a>89.在浏览器中输入url到页面显示出来的过程发生了什么?</h3><p>1.浏览器地址栏输入URL并回车<br>2.通过DNS将域名解析成IP地址。在解析过程中，按照浏览器缓存、系统缓存、路由器缓存、ISP(运营商)DNS缓存、根域名服务器、顶级域名服务器、主域名服务器的顺序，逐步读取缓存，直到拿到IP地址。（应用层）<br>3.根据获取IP进行tcp连接（三次握手）（传输层）<br>4.发送http请求<br>5.服务器处理请求，浏览器接收http的响应<br>6.渲染页面，构造dom树<br>7.关闭tcp连接（四次挥手）</p><h3 id="90-写一个获取数组的最大值、最小值的方法？"><a href="#90-写一个获取数组的最大值、最小值的方法？" class="headerlink" title="90.写一个获取数组的最大值、最小值的方法？"></a>90.写一个获取数组的最大值、最小值的方法？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max.apply(<span class="built_in">Array</span>, [<span class="number">12</span>, <span class="number">9</span>,<span class="number">239</span>,<span class="number">12348</span>,<span class="number">83974</span>,<span class="number">1</span>,<span class="number">324</span>,<span class="number">342</span>, -<span class="number">1</span>, -<span class="number">273</span>]) <span class="comment">// 83974</span></span><br><span class="line"><span class="built_in">Math</span>.min.apply(<span class="built_in">Array</span>, [<span class="number">12</span>, <span class="number">9</span>,<span class="number">239</span>,<span class="number">12348</span>,<span class="number">83974</span>,<span class="number">1</span>,<span class="number">324</span>,<span class="number">342</span>, -<span class="number">1</span>, -<span class="number">273</span>]) <span class="comment">// -273</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMax</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">total, current</span>) =&gt;</span> total = total &gt; current ? total : current)</span><br><span class="line">&#125;</span><br><span class="line">getMax([<span class="number">12</span>, <span class="number">9</span>,<span class="number">239</span>,<span class="number">12348</span>,<span class="number">83974</span>,<span class="number">1</span>,<span class="number">324</span>,<span class="number">342</span>, -<span class="number">1</span>, -<span class="number">273</span>]) <span class="comment">// 83974</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMin</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">total, current</span>) =&gt;</span> total = total &lt; current ? total : current)</span><br><span class="line">&#125;</span><br><span class="line">getMin([<span class="number">12</span>, <span class="number">9</span>,<span class="number">239</span>,<span class="number">12348</span>,<span class="number">83974</span>,<span class="number">1</span>,<span class="number">324</span>,<span class="number">342</span>, -<span class="number">1</span>, -<span class="number">273</span>]) <span class="comment">// -273</span></span><br></pre></td></tr></table></figure><h3 id="91-网页上的验证码是为了解决什么问题？说说你了解的验证码种类有哪些"><a href="#91-网页上的验证码是为了解决什么问题？说说你了解的验证码种类有哪些" class="headerlink" title="91.网页上的验证码是为了解决什么问题？说说你了解的验证码种类有哪些"></a>91.网页上的验证码是为了解决什么问题？说说你了解的验证码种类有哪些</h3><p>1.图形验证码<br>2.字符验证码 文字+混淆 如早期的7456这种结果的验证码<br>3.复杂字符验证码 复杂文字+混淆 如加入中文等本土化的增加识别难度<br>4.计算验证码 数字+运算符+混淆 如1+2=? 需要识别表达式增加识别难度<br>5.精确识别 文字+混淆文字 如选出 优贝在线 中的 贝字，或者选出所有的筷子，所有的红绿灯（12306）<br>6.滑动拼图验证 图像+滑块+图像凹槽 如常见的滑动拼图，提供商有易盾之类的<br>7.拼图验证 图像+打乱 需要用户去拼合完成<br>8.手机短信验证码<br>9.手机发送一条短信</p><p>防止机器行为，确定是人为操作，比如登陆、发帖等。<br>保护服务器</p><h3 id="92-描述下你所了解的图片格式及使用场景"><a href="#92-描述下你所了解的图片格式及使用场景" class="headerlink" title="92.描述下你所了解的图片格式及使用场景"></a>92.描述下你所了解的图片格式及使用场景</h3><table><thead><tr><th align="center">格式</th><th align="center">优点</th><th align="center">缺点</th><th align="center">适用场景</th></tr></thead><tbody><tr><td align="center">gif</td><td align="center">文件小，支持动画、透明，无兼容性问题</td><td align="center">只支持256种颜色</td><td align="center">色彩简单的logo、icon、动图</td></tr><tr><td align="center">jpg</td><td align="center">色彩丰富，文件小</td><td align="center">有损压缩，反复保存图片质量下降明显</td><td align="center">色彩丰富的图片/渐变图像</td></tr><tr><td align="center">png</td><td align="center">无损压缩，支持透明，简单图片尺寸小</td><td align="center">不支持动画，色彩丰富的图片尺寸大</td><td align="center">logo/icon/透明图</td></tr><tr><td align="center">webp</td><td align="center">文件小，支持有损和无损压缩，支持动画、透明</td><td align="center">浏览器兼容性不好</td><td align="center">支持webp格式的app和webview</td></tr></tbody></table><h3 id="93-写一个方法判断字符串是否为回文字符串"><a href="#93-写一个方法判断字符串是否为回文字符串" class="headerlink" title="93.写一个方法判断字符串是否为回文字符串"></a>93.写一个方法判断字符串是否为回文字符串</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用for循环进行遍历</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(str.length === <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  str = str.replace(<span class="regexp">/[^a-zA-Z0-9]/g</span>, <span class="string">&#x27;&#x27;</span>).toLowerCase();</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(str[i] !== str[str.length - <span class="number">1</span> - i])&#123;</span><br><span class="line">      flag = fasle</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过数组反转字符，然后再和原字符串进行比较</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(str.length === <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  str = str.replace(<span class="regexp">/[^a-zA-Z0-9]/g</span>, <span class="string">&#x27;&#x27;</span>).toLowerCase();</span><br><span class="line">  <span class="keyword">let</span> newStr = str.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> str === newStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双指针遍历，从两边向中间进行遍历。其实和第一种方法中的for循环中if语句的判断条件类似</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(str.length === <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  str = str.replace(<span class="regexp">/[^a-zA-Z0-9]/g</span>, <span class="string">&#x27;&#x27;</span>).toLowerCase();</span><br><span class="line">  <span class="keyword">let</span> lp = <span class="number">0</span>,</span><br><span class="line">  rp = str.length -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(lp &lt;= rp)&#123;</span><br><span class="line">    <span class="keyword">if</span>(str[lp++] !== str[rp--])&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="94-CRLF是什么？"><a href="#94-CRLF是什么？" class="headerlink" title="94.CRLF是什么？"></a>94.CRLF是什么？</h3><p>CRLF的含义 是“carriage return/line feed”，意思是回车换行。CR回车\r，LF换行\n。</p><p>Windows操作系统采用两个字符来进行换行，即 CRLF；”\r\n”<br>Unix/Linux/Mac OS X操作系统采用单个字符 LF 来进行换行.”\n”</p><h3 id="95-DOM和BOM有什么区别？"><a href="#95-DOM和BOM有什么区别？" class="headerlink" title="95.DOM和BOM有什么区别？"></a>95.DOM和BOM有什么区别？</h3><p><strong>BOM:</strong></p><p>BOM是Browser Object Model的缩写，即浏览器对象模型。<br>每个类型的浏览器都有各自的标准<br>最根本对象是window,主要的属性frames、location、history、navigator、screen</p><p><strong>DOM:</strong></p><p>DOM是Document Object Model的缩写，即文档对象模型。<br>DOM是W3C的标准<br>其根本是window.document</p><p><img src="/ZJY.github.io/images/bomdom.jpeg" alt="DOB&amp;DON"></p><h3 id="96-让网页的字体变得清晰，变细用CSS怎么做？"><a href="#96-让网页的字体变得清晰，变细用CSS怎么做？" class="headerlink" title="96.让网页的字体变得清晰，变细用CSS怎么做？"></a>96.让网页的字体变得清晰，变细用CSS怎么做？</h3><p>让文字变细有两个要素：</p><p>1.font-weight + font-family<br>font-weight 来控制粗细还是需要看对应的字体有没有对应的变种字体。因此这就和 font-family 相关。</p><p>2.-webkit-font-smoothing<br>这个属性是 Chrome 的抗锯齿属性。加上后会显得细一些，但是只针对 webkit 内核的浏览器才有效。</p><h3 id="97-写一个方法把0和1互转（0置1，1置0）"><a href="#97-写一个方法把0和1互转（0置1，1置0）" class="headerlink" title="97.写一个方法把0和1互转（0置1，1置0）"></a>97.写一个方法把0和1互转（0置1，1置0）</h3><p>使用异或</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> convert = <span class="function"><span class="params">num</span> =&gt;</span> num^<span class="number">1</span>;</span><br><span class="line">convert(<span class="number">0</span>); <span class="comment">// 1</span></span><br><span class="line">convert(<span class="number">1</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h3 id="98-line-height3种设置方式的区别"><a href="#98-line-height3种设置方式的区别" class="headerlink" title="98.line-height3种设置方式的区别"></a>98.line-height3种设置方式的区别</h3><p>line-height: 1.5;<br>line-height: 1.5em;<br>line-height: 150%;</p><p>对于应用在单个元素上，这几种写法的效果都是一样的（除了 px 需要一些计算）。但由于 line-height 是可以被继承的，因此会影响内部子元素的 line-height。简单的可以总结为：</p><ul><li>带有单位的 line-height 会被计算成 px 后继承。子元素的 line-height = 父元素的 line-height * font-size （如果是 px 了就直接继承）</li><li>而不带单位的 line-height 被继承的是倍数，子元素的 line-height = 子元素的 font-size * 继承的倍数</li></ul><h3 id="99-造成内存泄漏的操作有哪些？"><a href="#99-造成内存泄漏的操作有哪些？" class="headerlink" title="99.造成内存泄漏的操作有哪些？"></a>99.造成内存泄漏的操作有哪些？</h3><p>1、没有使用的全局变量；<br>2、闭包(闭包可以维持函数内部变量);<br>3、循环引用（引用计数不为0)；<br>4、对页面中的一些 副作用没有清除(比如setInterval)</p><h3 id="100-html和html5有什么区别呢？"><a href="#100-html和html5有什么区别呢？" class="headerlink" title="100.html和html5有什么区别呢？"></a>100.html和html5有什么区别呢？</h3><p>1.HTML5简化了很多细微的语法，例如doctype的声明，只需要写<!doctype html>就行了。HTML5与HTML5，XHTML1兼容，但是与SGML不兼容。<br>2.新增与语义化标签【header、footer、section、article等】<br>3.canvas替代Flash<br>4.html5媒体支持：audio vedio,HTML：如果不使用Flash播放器支持，它不支持音频和视频</p><h3 id="102-说说你对this的理解"><a href="#102-说说你对this的理解" class="headerlink" title="102.说说你对this的理解"></a>102.说说你对this的理解</h3><p>this是指当前运行环境的上下文。</p><p>全局this指向window（如果开启严格模式，this将指向undefined)</p><p>如果函数被一个对象调用，this指向该对象。如果fn()调用，指向window</p><p>箭头函数中的this例外，它指向定义时所在的位置，或者可以说箭头函数的this继承自外层作用域，只要确定了外层作用域的this，就知道箭头函数中的this指向谁了。</p><p>构造函数的指向new它的对象</p><p>可以通过apply call bind方法来改变函数的指向，指向就是第一个参数</p><p>定时器、延时器的this指向window</p><h3 id="103-Standards模式和Quirks模式有什么区别？"><a href="#103-Standards模式和Quirks模式有什么区别？" class="headerlink" title="103.Standards模式和Quirks模式有什么区别？"></a>103.Standards模式和Quirks模式有什么区别？</h3><p>mode = document.compatMode表明当前文档的渲染模式是怪异模式/混杂模式还是标准模式。<br>mode是一个枚举值（enumerated value），可能的值有：</p><ul><li>“BackCompat”：文档为怪异模式。</li><li>“CSS1Compat”：文档不是怪异模式，意味着文档处于标准模式或者准标准模式。</li></ul><p>Quirks mode：怪异模式 混杂模式<br>Standards mode: 标准模式</p><!DOCTYPE html><p> 唯一的作用是启用标准模式。<br>quirks主要是为了兼容各个浏览器，远古时期遗留下来的BUG（或者说是当时的标准，对于现在来说的BUG），它并未遵循W3C的标准</p><p>主要的区别在盒模型：<br>Standards盒模型：width = content （box-sizing: content-box;）<br>Quirks盒模型： width = content + border + padding (box-sizing: border-box)</p><h3 id="104-浏览器是怎样判断元素是否和某个CSS选择器匹配？"><a href="#104-浏览器是怎样判断元素是否和某个CSS选择器匹配？" class="headerlink" title="104.浏览器是怎样判断元素是否和某个CSS选择器匹配？"></a>104.浏览器是怎样判断元素是否和某个CSS选择器匹配？</h3><p>先产生一个元素集合，然后从后往前判断；</p><p>  浏览器先产生一个元素集合，这个集合往往由最后一个部分的索引产生（如果没有索引就是所有元素的集合）。然后向上匹配，如果不符合上一个部分，就把元素从集合中删除，直到真个选择器都匹配完，还在集合中的元素就匹配这个选择器了.</p><p>示例：</p><p>有选择器：<br>div.ready #wrapper &gt; .bg-red<br>先把所有元素 class 中有 bg-red 的元素拿出来组成一个集合，然后上一层，对每一个集合中的元素，如果元素的 parent id 不为 #wrapper 则把元素从集合中删去。 再向上，从这个元素的父元素开始向上找，没有找到一个 tagName 为 div 且 class 中有 ready 的元素，就把原来的元素从集合中删去。<br>至此这个选择器匹配结束，所有还在集合中的元素满足。</p><h3 id="105-用一个div模拟textarea的实现"><a href="#105-用一个div模拟textarea的实现" class="headerlink" title="105.用一个div模拟textarea的实现"></a>105.用一个div模拟textarea的实现</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;edit&quot;</span> <span class="attr">contenteditable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">style</span>=<span class="string">&quot;resize: both&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>contenteditable设置可编辑，resize设置右下角可拉伸</p><h3 id="106-使用flex实现三栏布局，两边固定，中间自适应"><a href="#106-使用flex实现三栏布局，两边固定，中间自适应" class="headerlink" title="106.使用flex实现三栏布局，两边固定，中间自适应"></a>106.使用flex实现三栏布局，两边固定，中间自适应</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.container</span> &#123;</span></span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 150px;</span><br><span class="line">  border-top: 1px solid;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex: 1 1 auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.main</span> &#123;</span></span><br><span class="line">  height: 150px;</span><br><span class="line">  background-color: aquamarine;</span><br><span class="line">  width: 100%;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.left</span> &#123;</span></span><br><span class="line">  width: 30px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background-color: darkkhaki;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.right</span> &#123;</span></span><br><span class="line">  width: 60px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  background-color: firebrick;</span><br><span class="line">  flex-shrink: 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">    flex</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="107-请你解释一个为什么10-toFixed-10-会报错？"><a href="#107-请你解释一个为什么10-toFixed-10-会报错？" class="headerlink" title="107.请你解释一个为什么10.toFixed(10)会报错？"></a>107.请你解释一个为什么10.toFixed(10)会报错？</h3><p>.既可以理解为小数点也可以理解为方法调用<br>按照规范，紧跟数字后面就把它判断为一个小数点。可以改为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">10</span>).toFixed(<span class="number">10</span>)</span><br><span class="line"><span class="number">10</span> .toFixed(<span class="number">10</span>)</span><br><span class="line"><span class="number">10.</span>.toFixed(<span class="number">10</span>)</span><br><span class="line"><span class="number">10.0</span>.toFixed(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h3 id="108-谈一谈你知道的前端性能优化方案有哪些？"><a href="#108-谈一谈你知道的前端性能优化方案有哪些？" class="headerlink" title="108.谈一谈你知道的前端性能优化方案有哪些？"></a>108.谈一谈你知道的前端性能优化方案有哪些？</h3><p>代码层面：避免使用css表达式，避免使用高级选择器，通配选择器。减少重绘重拍<br>缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等<br>请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载。<br>请求带宽：压缩文件，开启GZIP<br>优化加载：</p><p>  webpack 开启 tree-shaking 减少代码体积<br>  通过preload prefetch优化加载资源的时间<br>  import(‘’).then()异步加载资源<br>  图片小于30k的图片直接做成base64；<br>  对于首屏的样式可以直接内嵌到html中；</p><p>服务端渲染：SSR对于首页可以直接通过node jade模板引擎输出，其他页面继续使用前端渲染，优化首屏、SEO</p><h3 id="109-HTML和XHTM有什么不同？"><a href="#109-HTML和XHTM有什么不同？" class="headerlink" title="109.HTML和XHTM有什么不同？"></a>109.HTML和XHTM有什么不同？</h3><ol><li>XHTML 元素必须被正确地嵌套。</li><li>XHTML 元素必须被关闭。</li><li>标签名必须用小写字母。</li><li>XHTML 文档必须拥有根元素</li></ol><h3 id="110-写出主流浏览器内核私有属性的css前缀"><a href="#110-写出主流浏览器内核私有属性的css前缀" class="headerlink" title="110.写出主流浏览器内核私有属性的css前缀"></a>110.写出主流浏览器内核私有属性的css前缀</h3><p><strong>CSS 前缀：</strong></p><p>主流浏览器引擎前缀：</p><ul><li>-webkit- （谷歌，Safari，新版 Opera 浏览器，以及几乎所有 iOS 系统中的浏览器（包括 iOS 系统中的火狐浏览器）；基本上所有基于 WebKit 内核的浏览器）</li><li>-moz-：（火狐浏览器）</li><li>-o- （旧版 Opera 浏览器）</li><li>-ms- （IE 浏览器 和 Edge 浏览器）</li></ul><h3 id="111-手写幻灯片效果"><a href="#111-手写幻灯片效果" class="headerlink" title="111.手写幻灯片效果"></a>111.手写幻灯片效果</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.wraper</span> &#123;</span></span><br><span class="line">      width: 500px;</span><br><span class="line">      height: 400px;</span><br><span class="line">      overflow: hidden;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">      width: 1500px;</span><br><span class="line">      height: 400px;</span><br><span class="line">      position: relative;</span><br><span class="line">      animation: move 5s infinite linear forwards;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.swiperItem</span> &#123;</span></span><br><span class="line">      width: 500px;</span><br><span class="line">      height: 400px;</span><br><span class="line">      font-size: 50px;</span><br><span class="line">      text-align: center;</span><br><span class="line">      line-height: 400px;</span><br><span class="line">      user-select: none;</span><br><span class="line">      float: left;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="keyword">@keyframes</span> move &#123;</span></span><br><span class="line">      0% &#123;</span><br><span class="line"><span class="css">        <span class="comment">/* transform: translateX(0); */</span></span></span><br><span class="line">        margin-left: 0;</span><br><span class="line">      &#125;</span><br><span class="line">      25% &#123;</span><br><span class="line"><span class="css">        <span class="comment">/* transform: translateX(0); */</span></span></span><br><span class="line">        margin-left: 0;</span><br><span class="line">      &#125;</span><br><span class="line">      33.3% &#123;</span><br><span class="line"><span class="css">        <span class="comment">/* transform: translateX(-500px); */</span></span></span><br><span class="line">        margin-left: -500px;</span><br><span class="line">      &#125;</span><br><span class="line">      58% &#123;</span><br><span class="line"><span class="css">        <span class="comment">/* transform: translateX(-500px); */</span></span></span><br><span class="line">        margin-left: -500px;</span><br><span class="line">      &#125;</span><br><span class="line">      66.6% &#123;</span><br><span class="line"><span class="css">        <span class="comment">/* transform: translateX(-1000px); */</span></span></span><br><span class="line">        margin-left: -1000px;</span><br><span class="line">      &#125;</span><br><span class="line">      100% &#123;</span><br><span class="line"><span class="css">        <span class="comment">/* transform: translateX(-1000px); */</span></span></span><br><span class="line">        margin-left: -1000px;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.swiperItem</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</span></span><br><span class="line">      background-color: aquamarine;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.swiperItem</span><span class="selector-pseudo">:nth-child(2)</span> &#123;</span></span><br><span class="line">      background-color: burlywood;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.swiperItem</span><span class="selector-pseudo">:nth-child(3)</span> &#123;</span></span><br><span class="line">      background-color: cornflowerblue;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wraper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;swiperItem&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;swiperItem&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;swiperItem&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="112-对于前端安全，你了解多少？说说你对XSS和CSRF的理解"><a href="#112-对于前端安全，你了解多少？说说你对XSS和CSRF的理解" class="headerlink" title="112.对于前端安全，你了解多少？说说你对XSS和CSRF的理解"></a>112.对于前端安全，你了解多少？说说你对XSS和CSRF的理解</h3><p><strong>内容安全：</strong></p><p>CSP内容安全策略：通过探测和减轻包括跨站脚本攻击 XSS (en-US) 和数据注入攻击的攻击手段，更进一步提升安全性</p><p><strong>连接安全：</strong></p><p>传输层安全TLS：传输层安全协议是在两个互联的应用或设备上稳定且私密地交换信息的标准</p><p>HTTPS：https超文本传输协议安全，使用SSL或TLS协议来对客户的端和服务器之间的所有通信进行加密</p><p>…</p><p><strong>数据安全：</strong></p><p>使用 HTTP Cookies：HTTP cookie（web cookie，浏览器 cookie）是服务器发送给客户端 web 浏览器的一小块数据。浏览器可能会存储它，并在后续对同一服务器的请求中将它发送回服务器</p><p>Local storage：Window 对象的 Window.localStorage 属性是一种服务器在客户端上存储持久性数据的方法，数据可以在不同的会话中持久访问</p><p><strong>信息泄露：</strong></p><p><strong>完整性：</strong></p><p>同源策略：同源策略限制了一个源中加载的文档或脚本与其他源中的资源交互的方式。这是一种用来隔离潜在恶意文档的关键安全机制。</p><p><strong>点击劫持保护：</strong></p><p>点击劫持 (en-US)描述了用户被愚弄，点击了一个产生用户意料之外行为的 UI 元素的现象</p><p><strong>用户信息安全：</strong></p><p>不安全的密码</p><h4 id="Cross-site-scripting-跨站脚本攻击XSS"><a href="#Cross-site-scripting-跨站脚本攻击XSS" class="headerlink" title="Cross-site scripting 跨站脚本攻击XSS"></a>Cross-site scripting 跨站脚本攻击XSS</h4><p>是一种安全漏洞，攻击者可以使用这些漏洞在网站上注入恶意的客户端代码。若受害者运行这些代码，攻击者就可以突破网站的访问限制并冒充受害者。</p><p>在以下 2 种情况下，容易发生 XSS 攻击：</p><p>1.数据从一个不可靠的链接进入一个web应用程序<br>2.没有过滤掉恶意代码的动态内容被发送给web客户</p><p>恶意内容一般包括 JavaScript，但是，有时候也会包括 HTML，FLASH 或是其他浏览器可执行的代码。XSS 攻击的形式千差万别，但他们通常都会：将 cookies 或其他隐私信息发送给攻击者，将受害者重定向到由攻击者控制的网页，或是经由恶意网站在受害者的机器上进行其他恶意操作。</p><p>分类：</p><ol><li>存储型（持久型）</li><li>反射型（非持久型）</li><li>DOM型</li></ol><p><strong><em>存储型XSS</em></strong></p><p>注入型脚本永久存储在目标服务器上。当浏览器请求数据时，脚本从服务器返回并执行。</p><p><strong><em>反射型XSS</em></strong></p><p>当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。Web 服务器将注入脚本，比如一个错误信息，搜索结果等 返回到用户的浏览器上。由于浏览器认为这个响应来自”可信任”的服务器，所以会执行这段脚本。</p><p><strong><em>基于DOM的XSS</em></strong></p><p>通过修改原始的客户端代码，受害者浏览器的 DOM 环境改变，导致有效载荷的执行。也就是说，页面本身并没有变化，但由于 DOM 环境被恶意修改，有客户端代码被包含进了页面，并且意外执行。</p><h4 id="跨站请求伪造CSRF"><a href="#跨站请求伪造CSRF" class="headerlink" title="跨站请求伪造CSRF"></a>跨站请求伪造CSRF</h4><p>跨站请求伪造是一种冒充受信任用户，向服务器发送非预期请求的攻击方法。</p><p>CSRF攻击之所以有效，是因为浏览器请求自动包含所有cookie，包括会话cookie.因此，如果用户对站点进行了身份验证，则站点无法区分合法授权请求和伪造的身份验证请求</p><p>如何防御：</p><p>1.get请求不修改数据<br>2.不让第三方网站访问到cookie，可以对 Cookie 设置 SameSite 属性。该属性表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容<br>3.请求时附带验证信息，比如验证码或者token<br>4.检查Referer字段，http请求头中referer字段表明请求来源于哪个地址，通常来说，Referer字段应和请求的地址位于同一域名下</p><h3 id="113-html5哪些标签可以优化SEO"><a href="#113-html5哪些标签可以优化SEO" class="headerlink" title="113.html5哪些标签可以优化SEO?"></a>113.html5哪些标签可以优化SEO?</h3><p>搜索引擎的排序主要由以下方面共同确定：</p><table><thead><tr><th align="center">网页内容</th><th align="center">权重分数</th></tr></thead><tbody><tr><td align="center">内部链接文字</td><td align="center">10</td></tr><tr><td align="center">标题title</td><td align="center">10</td></tr><tr><td align="center">域名</td><td align="center">7</td></tr><tr><td align="center">H1，H2字号标题</td><td align="center">5</td></tr><tr><td align="center">路径或文件名</td><td align="center">4</td></tr><tr><td align="center">title属性，a标签的title属性</td><td align="center">1</td></tr><tr><td align="center">加粗或斜体</td><td align="center">1</td></tr><tr><td align="center">alt标记</td><td align="center">0.5</td></tr></tbody></table><p>SEO中常见的语义化标签：</p><ul><li>H标签的使用</li><li>strong标签的使用</li><li>title网站seo标题</li><li>meta name=”description” content=”网站描述”</li><li>meta name=”keywords” content=”网站关键词”</li><li>a href=”链接地址” title=”链接说明”</li><li>img src=”图片链接地址” alt=”图片说明”</li><li>div id=”copyright” 版权部分加上网站名称和链接</li><li>nav：可以帮助 UA 迅速获得导航内容，例如读屏器可以省去很多渲染直接跳到导航位置。</li><li>aside ：可以表示与周围内容关系不太密切的内容 (广告)，通常表现为侧边栏内容 (相关背景内容)、引述内容</li><li>header</li><li>article：独立的文档、页面、应用、站点，可以单独发布、重用；可以是一篇帖子、一篇文章、一则用户评论、一个可交互的 widget</li><li>section：按主题将内容分组，通常会有标题 (heading)</li></ul><h3 id="114-不使用border画出1px高的线，在不同浏览器的标准和怪异模式下都能保持效果一样"><a href="#114-不使用border画出1px高的线，在不同浏览器的标准和怪异模式下都能保持效果一样" class="headerlink" title="114.不使用border画出1px高的线，在不同浏览器的标准和怪异模式下都能保持效果一样"></a>114.不使用border画出1px高的线，在不同浏览器的标准和怪异模式下都能保持效果一样</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border</span> &#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">1px</span> <span class="number">0</span> <span class="number">0</span> <span class="number">#333</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.border</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.border</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;hr size=&quot;1&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="115-找到字符串中最长的单词，并返回它的长度"><a href="#115-找到字符串中最长的单词，并返回它的长度" class="headerlink" title="115.找到字符串中最长的单词，并返回它的长度"></a>115.找到字符串中最长的单词，并返回它的长度</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findLongestWord</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!str) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">var</span> strArr = str.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> strArr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, current</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(prev, current.length)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">findLongestWord(<span class="string">&#x27;hello world w3c school education&#x27;</span>) <span class="comment">// 9</span></span><br></pre></td></tr></table></figure><h3 id="116-说说你对cookie和session的理解"><a href="#116-说说你对cookie和session的理解" class="headerlink" title="116.说说你对cookie和session的理解"></a>116.说说你对cookie和session的理解</h3><h4 id="什么是Cookie？"><a href="#什么是Cookie？" class="headerlink" title="什么是Cookie？"></a>什么是Cookie？</h4><ul><li><p>HTTP是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。</p></li><li><p>cookie存储在客户端：cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器发送请求时被携带并发送到服务器上。</p></li><li><p>cookie是不可的：每个cookie都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠domain）</p></li><li><p>cookie重要的属性：</p><ul><li><p>name=value健值对，设置cookie的名称及相应的值，都必须是字符串类型。</p><pre><code>如果值为unicode字符，需要转为字符编码如果值为二进制，需要转为base64编码</code></pre></li><li><p>domain指定cookie所属域名，默认是当前域名，path指定cookie在哪个路径下生效，默认是’/‘。如果设置为/abc，则只有/abc下的路由可以访问到该cookie，如/abc/read。</p></li><li><p>maxAgeCookie：失效的时间，单位秒，如果为整数，则该cookie在maxAge秒后失效。如果为负数，则该cookie为临时cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该cookie。如果为0，表示删除该cookie。默认为-1。比expires好用。一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除。</p></li><li><p>expires：过期时间，在设置的某个时间点后该cookie就会失效。</p></li><li><p>secure：该cookie是否仅被使用安全协议传输。安全协议有HTTPS，SSL等。在网络上传输数据先将数据进行加密。默认是false，当secure为true时，cookie在http中是无效的，在https才有效。</p></li><li><p>httpOnly：如果给某个cookie设置来httpOnly属性，则无法通过js脚本读取到该cookie的信息，但是还是能够通过Application中手动修改cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全</p></li></ul></li></ul><h4 id="什么是Session？"><a href="#什么是Session？" class="headerlink" title="什么是Session？"></a>什么是Session？</h4><ul><li><p>session是另一种记录服务器和客户端会话状态的机制</p></li><li><p>session是基于cookie实现的，session存储在服务端，sessionId会被存储在客户端的cookie中</p></li><li><p>session认证流程：</p><ul><li><p>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的session</p></li><li><p>请求返回将此session的唯一标识sessionId返回给浏览器</p></li><li><p>浏览器接收到服务器返回的sessionId后会将该信息存储到cookie中，同时cookie将记录此sessionId属于哪个域名</p></li><li><p>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在cookie信息，如果存在自动将cookie信息也发送给服务器，服务端会从cookie中获取sessionId，再根据sessionId查找对于session信息，如果没有找到说明用户没有登录或者登录失效，如果找到session证明用户已经登录可执行后续操作。</p></li></ul></li><li><p>sessionId是连接cookie和session的一道桥梁，大部分系统也是根据此原理来验证用户登录状态</p></li></ul><h4 id="cookie和session的区别？"><a href="#cookie和session的区别？" class="headerlink" title="cookie和session的区别？"></a>cookie和session的区别？</h4><ul><li>安全性：session比cookie安全，session是存储在服务端的，cookie是存储在客户端的</li><li>存取值的类型不同： cookie只支持字符串数据，想要设置其他类型的数据，需要将其转换为字符串，session可以存任意数据类型。</li><li>有效期不同：cookie可设置为长时间保持，比如我们经常使用的默认登录功能。session一般失效时间较短，客户端关闭或者session超时都会失效。</li><li>存储大小不同：单个cookie存储数据不能超过4k，session可存储数据远高于cookie，但是当访问量过多，会占用过多的服务器资源。</li></ul><h3 id="117-实现单行文本居中和多行文本左对齐并超出显示”…”"><a href="#117-实现单行文本居中和多行文本左对齐并超出显示”…”" class="headerlink" title="117.实现单行文本居中和多行文本左对齐并超出显示”…”"></a>117.实现单行文本居中和多行文本左对齐并超出显示”…”</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 只webkit内核 */</span></span><br><span class="line"><span class="selector-class">.multi</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">  <span class="attribute">-webkit-line-clamp</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  <span class="attribute">-webkit-box-orient</span>: vertical;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* after伪元素 */</span></span><br><span class="line"><span class="selector-class">.multi2</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2.8em</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.4</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.multi2</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;...&#x27;</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1.4em</span>;</span><br><span class="line">  <span class="attribute">background</span>: white;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="118-说说你对eval的理解"><a href="#118-说说你对eval的理解" class="headerlink" title="118.说说你对eval的理解"></a>118.说说你对eval的理解</h3><p>eval() 函数会将传入的字符串当做 JavaScript 代码进行执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">eval</span>(<span class="string">&#x27;2 + 2&#x27;</span>));</span><br><span class="line"><span class="comment">// expected output: 4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">eval</span>(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;2 + 2&#x27;</span>)));</span><br><span class="line"><span class="comment">// expected output: 2 + 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">eval</span>(<span class="string">&#x27;2 + 2&#x27;</span>) === <span class="built_in">eval</span>(<span class="string">&#x27;4&#x27;</span>));</span><br><span class="line"><span class="comment">// expected output: true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">eval</span>(<span class="string">&#x27;2 + 2&#x27;</span>) === <span class="built_in">eval</span>(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;2 + 2&#x27;</span>)));</span><br><span class="line"><span class="comment">// expected output: false</span></span><br></pre></td></tr></table></figure><p>eval() 是全局对象的一个函数属性。</p><p>eval() 通常比其他替代方法更慢，因为它必须调用 JS 解释器，而许多其他结构则可被现代 JS 引擎进行优化。</p><p>不建议使用eval。eval() 是一个危险的函数，它使用与调用者相同的权限执行代码。如果你用 eval() 运行的字符串代码被恶意方（不怀好意的人）修改，您最终可能会在您的网页/扩展程序的权限下，在用户计算机上运行恶意代码。更重要的是，第三方代码可以看到某一个 eval() 被调用时的作用域，这也有可能导致一些不同方式的攻击</p><h3 id="119-写出你知道的CSS水平和垂直居中的方法"><a href="#119-写出你知道的CSS水平和垂直居中的方法" class="headerlink" title="119.写出你知道的CSS水平和垂直居中的方法"></a>119.写出你知道的CSS水平和垂直居中的方法</h3><p><a href="https://juejin.cn/post/6844903693142196238#comment">如何居中一个元素</a></p><p>一、水平居中</p><p>1.行内元素水平居中</p><p>给块级父元素设置text-align: center;可使行内子元素水平居中，此方法对inlin、inline-block、inline-flex、inline-table、inline-grid水平居中都有效。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.块级元素的水平居中</p><p>(1).将该块级元素左右外边距margin-left和margin-right设置为auto并设置宽度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.block</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2).使用table + margin, 此时元素宽度为内容宽度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.block</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3).absolute+transform</p><p>给父元素设置相对定位，子块元素设置绝对定位，利用left和transform将元素水平居中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.blockClild</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4).使用flex + justify-content</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.block</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(5).使用flex + margin</p><p>给父元素设置flex，子元素设置margin: 0 auto;</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.blockClild</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.多块级元素水平居中</p><p>(1).使用flex布局</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.parent</span> &#123;</span></span><br><span class="line">  display: flex;</span><br><span class="line">  justify-content: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;blockClild&quot;</span>&gt;</span>block<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;blockClild&quot;</span>&gt;</span>block<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(2).使用inline-block</p><p>将要水平排列的块状元素设为display:inline-block，然后在父级元素上设置text-align:center，达到与上面的行内元素的水平居中一样的效果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.blockClild</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、垂直居中</p><p>1.单行内联元素垂直居中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.parent</span> &#123;</span></span><br><span class="line">  height: 120px;</span><br><span class="line">  line-height: 120px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>childchildchildchildchildchildchildchildchildchild<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.多行内联元素垂直居中</p><p>(1). 使用flex布局</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line">    height: 120px;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-direction: column;</span><br><span class="line">    justify-content: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>hello world.<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>hello world.<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>hello world.<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(2).利用table布局</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.parent</span> &#123;</span></span><br><span class="line">  height: 120px;</span><br><span class="line">  display: table;</span><br><span class="line">  background-color: bisque;</span><br><span class="line">&#125;</span><br><span class="line">span &#123;</span><br><span class="line">  background-color: pink;</span><br><span class="line">  display: table-cell;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>hello world.<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>hello world.<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>hello world.<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.块级元素垂直居中</p><p>(1).使用absolute+transform</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.parent</span> &#123;</span></span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.child</span> &#123;</span></span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 50%;</span><br><span class="line">  transform: translateY(-50%);</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>hello world.hello world.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(2).使用flex+align-items</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.parent</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">display</span><span class="selector-pseudo">:flex</span>;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">align-items</span><span class="selector-pseudo">:center</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>hello world.hello world.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(4).使用table-cell+vertical-align</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.parent</span> &#123;</span></span><br><span class="line">  display: table-cell;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>hello world.hello world.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>三、水平垂直居中</p><p>(1).使用absolute+负边距（已知宽高）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.parent</span> &#123;</span></span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.child</span> &#123;</span></span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 50%;</span><br><span class="line">  left: 50%;</span><br><span class="line">  margin: -50px 0 0 -50px;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line"><span class="css">  <span class="selector-tag">background-color</span>: <span class="selector-id">#666</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>center<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(2).绝对定位与margin:auto</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.parent</span> &#123;</span></span><br><span class="line">  position: relative;</span><br><span class="line"><span class="css">  <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>; <span class="comment">/* 必须有个高度 */</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.child</span> &#123;</span></span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  right: 0;</span><br><span class="line">  bottom: 0;</span><br><span class="line">  margin: auto;</span><br><span class="line"><span class="css">  <span class="selector-tag">background-color</span>: <span class="selector-id">#666</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>center<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(3).绝对定位 + transform</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.parent</span> &#123;</span></span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.child</span> &#123;</span></span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 50%;</span><br><span class="line">  left: 50%;</span><br><span class="line">  transform: translate(-50%, -50%);</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>center<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(4).flex布局</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.parent</span> &#123;</span></span><br><span class="line">  display: flex;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  align-items: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>center<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="120-说说你对模块化的理解"><a href="#120-说说你对模块化的理解" class="headerlink" title="120.说说你对模块化的理解"></a>120.说说你对模块化的理解</h3><p>代码抽离重用，模块化开发，多人合作</p><ul><li>AMD: require.js 为代表，依赖前置，一律先加载再使用。</li><li>CMD: sea.js 为代表，异步加载模块，依赖就近原则</li><li>UMD: 兼容AMD和commonJS规范的同时，还兼容全局引用的方式。</li><li>ES6 import/export</li></ul><h3 id="121-公钥加密和私钥加密是什么？"><a href="#121-公钥加密和私钥加密是什么？" class="headerlink" title="121.公钥加密和私钥加密是什么？"></a>121.公钥加密和私钥加密是什么？</h3><p>私钥加密，也称对称加密，使用一个密钥对内容进行加密和解密，加密算法可以是公开的，但密钥必须保密，常见的私钥加密算法有：DES、AES、RC5</p><p>公钥加密，也称非对称加密，使用两个密钥，一个公开密钥用来加密，另一个私有密钥用来解密，基于其特性，可以用作数字签名的功能（如 HTTPS），常见的公钥加密算法有：RSA</p><h3 id="122-html5都有哪些新的特性？移除了哪些元素？"><a href="#122-html5都有哪些新的特性？移除了哪些元素？" class="headerlink" title="122.html5都有哪些新的特性？移除了哪些元素？"></a>122.html5都有哪些新的特性？移除了哪些元素？</h3><p><strong>新增特性:</strong></p><ul><li>canvas</li><li>svg</li><li>video</li><li>drag &amp; drop</li><li>localStorage/sessionStorage</li><li>语义化标签: header/nav/section/article/footer</li><li>input 类型: date/datetime/email/range</li></ul><p><strong>移除元素:</strong></p><ul><li>applet</li><li>big</li><li>font</li><li>frame/frameset</li></ul><h3 id="123-怎么才能让图文不可复制？"><a href="#123-怎么才能让图文不可复制？" class="headerlink" title="123.怎么才能让图文不可复制？"></a>123.怎么才能让图文不可复制？</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-user-select</span>: <span class="selector-tag">none</span>;</span><br><span class="line"><span class="selector-tag">-ms-user-select</span>: <span class="selector-tag">none</span>;</span><br><span class="line"><span class="selector-tag">-moz-user-select</span>: <span class="selector-tag">none</span>;</span><br><span class="line"><span class="selector-tag">-khtml-user-select</span>: <span class="selector-tag">none</span>;</span><br><span class="line"><span class="selector-tag">user-select</span>: <span class="selector-tag">none</span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 禁止右键菜单</span></span><br><span class="line"><span class="built_in">document</span>.body.oncontextmenu = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// e.preventDefault();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 禁止文字选择</span></span><br><span class="line"><span class="built_in">document</span>.body.onselectstart = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// e.preventDefault();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 禁止复制</span></span><br><span class="line"><span class="built_in">document</span>.body.oncopy = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// e.preventDefault();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 禁止粘贴</span></span><br><span class="line"><span class="built_in">document</span>.body.onpaste = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// e.preventDefault();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="124-为什么会有跨域问题？怎么解决跨域？"><a href="#124-为什么会有跨域问题？怎么解决跨域？" class="headerlink" title="124.为什么会有跨域问题？怎么解决跨域？"></a>124.为什么会有跨域问题？怎么解决跨域？</h3><p>查看<a href="/ZJY.github.io/2021/06/08/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/" title="跨域问题总结">跨域问题总结</a></p><h3 id="125-怎么让英文单词的首字母大写？"><a href="#125-怎么让英文单词的首字母大写？" class="headerlink" title="125.怎么让英文单词的首字母大写？"></a>125.怎么让英文单词的首字母大写？</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.demo</span> &#123;</span><br><span class="line">  <span class="attribute">text-transform</span>: capitalize; <span class="comment">/* 单词的首字母转换为大写。*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 或 */</span></span><br><span class="line"><span class="selector-class">.demo</span><span class="selector-pseudo">::first-letter</span> &#123;</span><br><span class="line">  <span class="attribute">text-transform</span>: uppercase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="126-说说你对IIFE的理解"><a href="#126-说说你对IIFE的理解" class="headerlink" title="126.说说你对IIFE的理解"></a>126.说说你对IIFE的理解</h3><p>IIFE（立即调用函数表达式）是一个在定义时就会立即执行的 JavaScript 函数。独立作用域，避免变量冲突问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  statements</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>这是一个被称为 自执行匿名函数 的设计模式，主要包含两部分。第一部分是包围在 圆括号运算符 () 里的一个匿名函数，这个匿名函数拥有独立的词法作用域。这不仅避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域。</p><p>第二部分再一次使用 () 创建了一个立即执行函数表达式，JavaScript 引擎到此将直接执行函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;Barry&quot;</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 无法从外部访问变量 name</span></span><br><span class="line">name <span class="comment">// 抛出错误：&quot;Uncaught ReferenceError: name is not defined&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 IIFE 分配给一个变量，不是存储 IIFE 本身，而是存储 IIFE 执行后返回的结果。</span></span><br><span class="line"><span class="keyword">var</span> result = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;Barry&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// IIFE 执行后返回的结果：</span></span><br><span class="line">result; <span class="comment">// &quot;Barry&quot;</span></span><br></pre></td></tr></table></figure><h3 id="127-window对象和document对象有什么区别？"><a href="#127-window对象和document对象有什么区别？" class="headerlink" title="127.window对象和document对象有什么区别？"></a>127.window对象和document对象有什么区别？</h3><h4 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h4><p>window作为全局变量，代表了脚本正在运行的窗口，暴露给 Javascript 代码。<br>window 对象表示一个包含 DOM 文档的窗口，其 document 属性指向窗口中载入的 DOM 文档。</p><p>在有标签页功能的浏览器中，每个标签都拥有自己的 window 对象；也就是说，同一个窗口的标签页之间不会共享一个 window 对象。</p><p>有一些方法，如 window.resizeTo 和 window.resizeBy 之类的方法会作用于整个窗口而不是 window 对象所属的那个标签。一般而言，如果一样东西无法恰当地作用于标签，那么它就会作用于窗口。</p><h4 id="document对象"><a href="#document对象" class="headerlink" title="document对象"></a>document对象</h4><p>Document 接口表示任何在浏览器中载入的网页，并作为网页内容的入口，也就是 DOM 树。<br>Document 接口描述了任何类型的文档的通用属性与方法。<br>每一个载入浏览器的HTML文档都会成为document对象。document对象使我们可以使用脚本(js)中对HTML页面中的所有元素进行访问。</p><h3 id="128-重置（初始化）css的作用是什么？"><a href="#128-重置（初始化）css的作用是什么？" class="headerlink" title="128.重置（初始化）css的作用是什么？"></a>128.重置（初始化）css的作用是什么？</h3><p>清除不同浏览器默认的样式，让元素的样式统一。</p><h3 id="129-如何让元素固定在页面底部？有哪些比较好的实践？"><a href="#129-如何让元素固定在页面底部？有哪些比较好的实践？" class="headerlink" title="129.如何让元素固定在页面底部？有哪些比较好的实践？"></a>129.如何让元素固定在页面底部？有哪些比较好的实践？</h3><p>所谓 “Sticky Footer”，并不是什么新的前端概念和技术，它指的就是一种网页效果： 如果页面内容不足够长时，页脚固定在浏览器窗口的底部；如果内容足够长时，页脚固定在页面的最底部。 总而言之，就是页脚一直处于最底.</p><p><strong>如何实现？</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>页面主体内容区域 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>需要做到 Sticky Footer 效果的页脚<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>1.使用flex</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">html,body &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">  padding: 0;</span><br><span class="line">  margin: 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.wrapper</span> &#123;</span></span><br><span class="line">  min-height: 100%;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: column;</span><br><span class="line">  margin-bottom: -50px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.content</span> &#123;</span></span><br><span class="line">  flex: 1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.footer</span> &#123;</span></span><br><span class="line">  height: 50px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.使用min-height + margin</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">html,body &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">  padding: 0;</span><br><span class="line">  margin: 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.wrapper</span> &#123;</span></span><br><span class="line">  min-height: 100%;</span><br><span class="line">  margin-bottom: -50px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.footer</span> &#123;</span></span><br><span class="line">  height: 50px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.使用padding-bottom + margin上父间距</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">html,body &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">  padding: 0;</span><br><span class="line">  margin: 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.wrapper</span> &#123;</span></span><br><span class="line">  min-height: 100%;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.content</span> &#123;</span></span><br><span class="line">  padding-bottom: 50px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.footer</span> &#123;</span></span><br><span class="line">  height: 50px;</span><br><span class="line">  margin-top: -50px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.使用calc</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">html,body &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">  padding: 0;</span><br><span class="line">  margin: 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.wrapper</span> &#123;</span></span><br><span class="line">  min-height: calc(100vh - 50px);</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.footer</span> &#123;</span></span><br><span class="line">  height: 50px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4.flex</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">    content</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">html, body &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br><span class="line">body &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: column;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.content</span> &#123;</span></span><br><span class="line">  flex: 1 0 auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.footer</span> &#123;</span></span><br><span class="line">  flex-shrink: 0;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="130-span与span之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"><a href="#130-span与span之间有看不见的空白间隔是什么原因引起的？有什么解决办法？" class="headerlink" title="130.span与span之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"></a>130.span与span之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</h3><p>产生空白的原因：元素被当成行内元素排版的时候，元素之间的空白符（空格、回车换行等）都会被浏览器转化为一个空白字符，字符大小受font-size的影响</p><p>解决方法：</p><p>1.父元素设置font-size为0，子元素单独再设置字体大小。</p><p>2.父元素设置display:flex;</p><p>3.子元素设置同方向float</p><h3 id="131-说说video标签中预加载视频用到的属性是什么？"><a href="#131-说说video标签中预加载视频用到的属性是什么？" class="headerlink" title="131.说说video标签中预加载视频用到的属性是什么？"></a>131.说说video标签中预加载视频用到的属性是什么？</h3><p>preload：<br>该枚举属性旨在提示浏览器，作者认为在播放视频之前，加载哪些内容会达到最佳的用户体验。可能是下列值之一：</p><ul><li>none: 表示不应该预加载视频。</li><li>metadata: 表示仅预先获取视频的元数据（例如长度）。</li><li>auto: 表示可以下载整个视频文件，即使用户不希望使用它。</li><li>空字符串: 和值为 auto 一致。每个浏览器的默认值都不相同，即使规范建议设置为 metadata。</li></ul><h3 id="132-手写一个满屏品字布局的方案"><a href="#132-手写一个满屏品字布局的方案" class="headerlink" title="132.手写一个满屏品字布局的方案"></a>132.手写一个满屏品字布局的方案</h3><p>1.flex</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.box</span> &#123;</span></span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.row</span> &#123;</span></span><br><span class="line">  height: 50%;</span><br><span class="line">  display: flex;</span><br><span class="line">  justify-content: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.item</span> &#123;</span></span><br><span class="line">  flex: 0 0 50%;</span><br><span class="line">  height: 100%;</span><br><span class="line">  border: 1px solid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.标准流</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.box</span> &#123;</span></span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.row</span> &#123;</span></span><br><span class="line">  height: 50%;</span><br><span class="line">  width: 100%;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.item</span> &#123;</span></span><br><span class="line">  width: 50%;</span><br><span class="line">  height: 100%;</span><br><span class="line">  border: 1px solid;</span><br><span class="line">  display: inline-block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.top</span> &#123;</span></span><br><span class="line">  height: 50%;</span><br><span class="line">  width: 50%;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">  border: 1px solid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;top&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.浮动</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.box</span> &#123;</span></span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.row</span> &#123;</span></span><br><span class="line">  height: 50%;</span><br><span class="line">  width: 100%;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.item</span> &#123;</span></span><br><span class="line">  width: 50%;</span><br><span class="line">  height: 100%;</span><br><span class="line">  border: 1px solid;</span><br><span class="line">  float: left</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.top</span> &#123;</span></span><br><span class="line">  height: 50%;</span><br><span class="line">  width: 50%;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">  border: 1px solid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;top&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="133-深度克隆对象的方法有哪些？"><a href="#133-深度克隆对象的方法有哪些？" class="headerlink" title="133.深度克隆对象的方法有哪些？"></a>133.深度克隆对象的方法有哪些？</h3><p>1.es6 扩展运算符(浅拷贝)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es6 扩展运算符</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;xiaoming&#x27;</span>,</span><br><span class="line">    info: &#123;</span><br><span class="line">      age: <span class="number">19</span>,</span><br><span class="line">      obj: &#123;</span><br><span class="line">        sex: <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> deepObj = &#123; ...obj &#125;</span><br><span class="line">  deepObj.info.obj.sex = <span class="number">2</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;obj&#x27;</span>, obj); <span class="comment">// sex:2</span></span><br><span class="line">  <span class="comment">// output: &#123;</span></span><br><span class="line">  <span class="comment">//   name: &#x27;xiaoming&#x27;,</span></span><br><span class="line">  <span class="comment">//   info: &#123;</span></span><br><span class="line">  <span class="comment">//     age: 19,</span></span><br><span class="line">  <span class="comment">//     obj: &#123;</span></span><br><span class="line">  <span class="comment">//       sex: 2</span></span><br><span class="line">  <span class="comment">//     &#125;</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;deepObj&#x27;</span>, deepObj); <span class="comment">// sex:2</span></span><br><span class="line">  <span class="comment">// output: &#123;</span></span><br><span class="line">  <span class="comment">//   name: &#x27;xiaoming&#x27;,</span></span><br><span class="line">  <span class="comment">//   info: &#123;</span></span><br><span class="line">  <span class="comment">//     age: 19,</span></span><br><span class="line">  <span class="comment">//     obj: &#123;</span></span><br><span class="line">  <span class="comment">//       sex: 2</span></span><br><span class="line">  <span class="comment">//     &#125;</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.Object.assign(浅拷贝)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object.assign</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;xiaoming&#x27;</span>,</span><br><span class="line">    info: &#123;</span><br><span class="line">      age: <span class="number">19</span>,</span><br><span class="line">      obj: &#123;</span><br><span class="line">        sex: <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> deepObj = <span class="built_in">Object</span>.assign(&#123;&#125;, obj)</span><br><span class="line">  deepObj.info.obj.sex = <span class="number">2</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;obj&#x27;</span>, obj); <span class="comment">// sex:2</span></span><br><span class="line">  <span class="comment">// output: &#123;</span></span><br><span class="line">  <span class="comment">//   name: &#x27;xiaoming&#x27;,</span></span><br><span class="line">  <span class="comment">//   info: &#123;</span></span><br><span class="line">  <span class="comment">//     age: 19,</span></span><br><span class="line">  <span class="comment">//     obj: &#123;</span></span><br><span class="line">  <span class="comment">//       sex: 2</span></span><br><span class="line">  <span class="comment">//     &#125;</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;deepObj&#x27;</span>, deepObj); <span class="comment">// sex:2</span></span><br><span class="line">  <span class="comment">// output: &#123;</span></span><br><span class="line">  <span class="comment">//   name: &#x27;xiaoming&#x27;,</span></span><br><span class="line">  <span class="comment">//   info: &#123;</span></span><br><span class="line">  <span class="comment">//     age: 19,</span></span><br><span class="line">  <span class="comment">//     obj: &#123;</span></span><br><span class="line">  <span class="comment">//       sex: 2</span></span><br><span class="line">  <span class="comment">//     &#125;</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.JSON.stringify的方式(深拷贝)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSON.stringify的方式</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="built_in">Symbol</span>(<span class="string">&#x27;xiaoming&#x27;</span>),</span><br><span class="line">    info: &#123;</span><br><span class="line">      age: <span class="number">19</span>,</span><br><span class="line">      obj: &#123;</span><br><span class="line">        sex: <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    reg: <span class="regexp">/\d+/g</span>,</span><br><span class="line">    fun: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;fun&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> deepObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line">  deepObj.info.obj.sex = <span class="number">2</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;obj&#x27;</span>, obj);</span><br><span class="line">  <span class="comment">// output: &#123;</span></span><br><span class="line">  <span class="comment">//   name: Symbol(&#x27;xiaoming&#x27;),</span></span><br><span class="line">  <span class="comment">//   info: &#123;</span></span><br><span class="line">  <span class="comment">//     age: 19,</span></span><br><span class="line">  <span class="comment">//     obj: &#123;</span></span><br><span class="line">  <span class="comment">//       sex: 1</span></span><br><span class="line">  <span class="comment">//     &#125;</span></span><br><span class="line">  <span class="comment">//   &#125;,</span></span><br><span class="line">  <span class="comment">//   reg: /\d+/g,</span></span><br><span class="line">  <span class="comment">//   fun: f()</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;deepObj&#x27;</span>, deepObj);</span><br><span class="line">  <span class="comment">// output: &#123;</span></span><br><span class="line">  <span class="comment">//   info: &#123;</span></span><br><span class="line">  <span class="comment">//     age: 19,</span></span><br><span class="line">  <span class="comment">//     obj: &#123;</span></span><br><span class="line">  <span class="comment">//       sex: 1</span></span><br><span class="line">  <span class="comment">//     &#125;</span></span><br><span class="line">  <span class="comment">//   &#125;,</span></span><br><span class="line">  <span class="comment">//   reg: &#123;&#125;, 正则</span></span><br><span class="line">  <span class="comment">//   缺少fun,name</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>es6语法糖和合并对象的方法都只能浅拷贝, 当出现对象中有多层级时只会独立拷贝第一层<br>JSON.stringify的方式虽然能实现深度拷贝, 但是如果对象中有出现方法、正则、Symbol的情况下 方法无法正常进行克隆</p><p>4.实现深拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDataType</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line">  <span class="keyword">var</span> map = &#123;</span><br><span class="line">    <span class="string">&#x27;[object Array]&#x27;</span>: <span class="string">&#x27;array&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;[object Object]&#x27;</span>: <span class="string">&#x27;object&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;[object String]&#x27;</span>: <span class="string">&#x27;string&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;[object Number]&#x27;</span>: <span class="string">&#x27;number&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;[object Null]&#x27;</span>: <span class="string">&#x27;null&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;[object Undefined]&#x27;</span>: <span class="string">&#x27;undefined&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;[object Boolean]&#x27;</span>: <span class="string">&#x27;boolean&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;[object RegExp]&#x27;</span>: <span class="string">&#x27;regExp&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;[object Function]&#x27;</span>: <span class="string">&#x27;function&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;[object Date]&#x27;</span>: <span class="string">&#x27;date&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;[object Symbol]&#x27;</span>: <span class="string">&#x27;symbol&#x27;</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;element&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> map[toString.call(obj)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> type = getDataType(data)</span><br><span class="line">  <span class="keyword">let</span> obj = type === <span class="string">&#x27;array&#x27;</span> ? [] : type === <span class="string">&#x27;object&#x27;</span> ? &#123;&#125; : <span class="literal">false</span></span><br><span class="line">  <span class="keyword">if</span> (!obj) <span class="keyword">return</span> data</span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">&#x27;array&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">      obj.push(deepClone(data[i]))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">      obj[key] = deepClone(data[key])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="built_in">Symbol</span>(<span class="string">&#x27;xiaoming&#x27;</span>),</span><br><span class="line">  info: &#123;</span><br><span class="line">    age: <span class="number">19</span>,</span><br><span class="line">    reg: <span class="regexp">/\d+/g</span>,</span><br><span class="line">    birth: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;1995-02-08&#x27;</span>),</span><br><span class="line">    isSenior: <span class="literal">true</span>,</span><br><span class="line">    obj: &#123;</span><br><span class="line">      sex: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  fun: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;fun&#x27;</span>, <span class="built_in">this</span>.info.obj.sex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;------------&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> target = deepClone(obj)</span><br><span class="line">target.info.obj.sex = <span class="number">2</span></span><br><span class="line">target.info.reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;obj&#x27;</span>, obj, obj.fun());</span><br><span class="line"><span class="comment">// output: fun 1</span></span><br><span class="line"><span class="comment">// obj &#123;</span></span><br><span class="line"><span class="comment">//   name: Symbol(xiaoming),</span></span><br><span class="line"><span class="comment">//   info: &#123;</span></span><br><span class="line"><span class="comment">//     age: 19,</span></span><br><span class="line"><span class="comment">//     birth: &#x27;Wed Feb 08 1995 08:00:00 GMT+0800 (中国标准时间)&#x27;,</span></span><br><span class="line"><span class="comment">//     isSenior: true,</span></span><br><span class="line"><span class="comment">//     reg: /\d+/g,</span></span><br><span class="line"><span class="comment">//     obj: &#123;</span></span><br><span class="line"><span class="comment">//       sex: 1</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//   &#125;,</span></span><br><span class="line"><span class="comment">//   fun: f()</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;target&#x27;</span>, target, target.fun());</span><br><span class="line"><span class="comment">// output: fun 2</span></span><br><span class="line"><span class="comment">// target &#123;</span></span><br><span class="line"><span class="comment">//   name: Symbol(xiaoming),</span></span><br><span class="line"><span class="comment">//   info: &#123;</span></span><br><span class="line"><span class="comment">//     age: 19,</span></span><br><span class="line"><span class="comment">//     birth: &#x27;Wed Feb 08 1995 08:00:00 GMT+0800 (中国标准时间)&#x27;,</span></span><br><span class="line"><span class="comment">//     isSenior: true,</span></span><br><span class="line"><span class="comment">//     reg: /(?:)/g,</span></span><br><span class="line"><span class="comment">//     obj: &#123;</span></span><br><span class="line"><span class="comment">//       sex: 2</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//   &#125;,</span></span><br><span class="line"><span class="comment">//   fun: f()</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><h3 id="134-使用js库的download来下载资源"><a href="#134-使用js库的download来下载资源" class="headerlink" title="134.使用js库的download来下载资源"></a>134.使用js库的download来下载资源</h3><p>html5的a标签的download属性可以下载资源，但是需要同源，如果浏览器可以解析也会之间打开。<br>可以使用第三方库download来实现更完整的下载功能。</p><p>download.js 相关资源：</p><ul><li>Github 地址：<a href="https://github.com/rndme/download">https://github.com/rndme/download</a></li><li>菜鸟：<a href="https://static.runoob.com/download/download-master.zip">https://static.runoob.com/download/download-master.zip</a></li><li>CDN 库：<a href="https://cdn.staticfile.org/downloadjs/1.4.8/download.min.js">https://cdn.staticfile.org/downloadjs/1.4.8/download.min.js</a></li><li>NPM 安装：npm install downloadjs</li></ul><p><strong>使用：</strong></p><p>download.js 库提供了 download() 函数用于下载文件。</p><p>下载内容可以是 URL、字符串、Blob 或类型化的数据数组，或者通过将文件数据表示为 base64 或 url 编码字符串的 dataURL。</p><p>无论输入格式如何，download() 都使用指定的文件名和 mime 信息以与使用 Content-Disposition HTTP 标头的服务器相同的方式保存文件。</p><p>语法：download(data, strFileName, strMimeType);</p><ul><li>data - 下载的数据内容，可以是 Blob、File、String 或 dataURL。</li><li>strFileName - 要创建的文件的名称。</li><li>strMimeType - 要下载的文件的 MIME 内容类型</li></ul><p><strong>文本下载：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line">download(<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;dlText.txt&quot;</span>, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// dataURL</span></span><br><span class="line">download(<span class="string">&quot;data:text/plain,hello%20world&quot;</span>, <span class="string">&quot;dlDataUrlText.txt&quot;</span>, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// blob</span></span><br><span class="line">download(<span class="keyword">new</span> Blob([<span class="string">&quot;hello world&quot;</span>]), <span class="string">&quot;dlTextBlob.txt&quot;</span>, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// url</span></span><br><span class="line">download(<span class="string">&quot;/robots.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// unit8文本数组</span></span><br><span class="line"><span class="keyword">var</span> str= <span class="string">&quot;hello world&quot;</span>,    arr= <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(str.length);</span><br><span class="line">str.split(<span class="string">&quot;&quot;</span>).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  arr[b]=a.charCodeAt();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">download(arr, <span class="string">&quot;textUInt8Array.txt&quot;</span>, <span class="string">&quot;text/plain&quot;</span> );</span><br></pre></td></tr></table></figure><p><strong>html下载:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// html 字符串实例：</span></span><br><span class="line">download(<span class="built_in">document</span>.documentElement.outerHTML, <span class="string">&quot;dlHTML.html&quot;</span>, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// html Blob 实例：</span></span><br><span class="line">download(<span class="keyword">new</span> Blob([<span class="string">&quot;hello world&quot;</span>.bold()]), <span class="string">&quot;dlHtmlBlob.html&quot;</span>, <span class="string">&quot;text/html&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ajax 回调实例：</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  url: <span class="string">&quot;/download.html&quot;</span>,</span><br><span class="line">  success: download.bind(<span class="literal">true</span>, <span class="string">&quot;text/html&quot;</span>, <span class="string">&quot;dlAjaxCallback.html&quot;</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>二进制文件:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图片 URL</span></span><br><span class="line">download(<span class="string">&quot;https://img1.baidu.com/it/u=3155988012,1977937542&amp;fm=253&amp;app=138&amp;size=w931&amp;n=0&amp;f=JPG&amp;fmt=auto?sec=1670432400&amp;t=43e5ed572796b21d99c7fd46b71bbf51&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步下载图片：</span></span><br><span class="line"><span class="keyword">var</span> x=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">x.open( <span class="string">&quot;GET&quot;</span>, <span class="string">&quot;https://img1.baidu.com/it/u=3155988012,1977937542&amp;fm=253&amp;app=138&amp;size=w931&amp;n=0&amp;f=JPG&amp;fmt=auto?sec=1670432400&amp;t=43e5ed572796b21d99c7fd46b71bbf51&quot;</span> , <span class="literal">true</span>);</span><br><span class="line">x.responseType=<span class="string">&quot;blob&quot;</span>;</span><br><span class="line">x.onload= <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  download(e.target.response, <span class="string">&quot;awesomesauce.png&quot;</span>, <span class="string">&quot;image/png&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">x.send();</span><br></pre></td></tr></table></figure><h3 id="135-JavaScript-实现复制功能"><a href="#135-JavaScript-实现复制功能" class="headerlink" title="135.JavaScript 实现复制功能"></a>135.JavaScript 实现复制功能</h3><p>一、使用js代码<br>clipboard API的writeText()或write()方法来指定数据覆盖剪贴板内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>单击按钮以复制输入框中的文本，然后尝试将文本（例如 ctrl+v）粘贴到不同的窗口中，以查看效果。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;你复制的内容&quot;</span> <span class="attr">id</span>=<span class="string">&quot;myInput&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;copyF()&quot;</span>&gt;</span>复制<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>可以尝试粘贴到以下输入框：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">copyF</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">/* 获取文本内容 */</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> copyText = <span class="built_in">document</span>.getElementById(<span class="string">&quot;myInput&quot;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">/* 选择复制内容 */</span></span></span><br><span class="line">    copyText.select();</span><br><span class="line"><span class="javascript">    copyText.setSelectionRange(<span class="number">0</span>, <span class="number">99999</span>); <span class="comment">/* 为移动设备设置 */</span></span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">// 给定 API 的用户权限状态</span></span></span><br><span class="line"><span class="javascript">    navigator.permissions.query(&#123;<span class="attr">name</span>: <span class="string">&#x27;clipboard-write&#x27;</span>&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// document.hasFocus()方法返回一个 Boolean，表明当前文档或者当前文档内的节点是否获得了焦点</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// &#x27;granted&#x27;, &#x27;denied&#x27;, or &#x27;prompt&#x27; 同意、拒绝、提示</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="built_in">document</span>.hasFocus() &amp;&amp; [<span class="string">&#x27;granted&#x27;</span>, <span class="string">&#x27;prompt&#x27;</span>].includes(res.state)) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">/* 复制内容到文本域 */</span></span></span><br><span class="line">          navigator.clipboard.writeText(copyText.value);</span><br><span class="line"><span class="javascript">          <span class="comment">/* 弹出已复制的内容 */</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">&quot;复制的文本为: &quot;</span> + copyText.value);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">    &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;fail&#x27;</span>,err)</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注：必须使当前文档获取焦点，否则复制无效并报错Document is not focused</p><p>二、使用第三方库 clipboard.js（推荐，兼容性强）</p><ul><li><p>clipboard.js 官网：<a href="https://clipboardjs.com/">https://clipboardjs.com/</a></p></li><li><p>clipboard.js Github：<a href="https://github.com/zenorocha/clipboard.js">https://github.com/zenorocha/clipboard.js</a></p></li></ul><p>直接使用国内 CDN 库：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;单击按钮以复制输入框中的文本，然后尝试将文本（例如 ctrl+v）粘贴到不同的窗口中，以查看效果。&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> value=<span class="string">&quot;你复制的内容&quot;</span> id=<span class="string">&quot;myInput&quot;</span>&gt;</span><br><span class="line">&lt;button id=<span class="string">&quot;copyInput&quot;</span> onclick=<span class="string">&quot;copyF()&quot;</span>&gt;复制&lt;/button&gt;</span><br><span class="line">&lt;p&gt;可以尝试粘贴到以下输入框：&lt;/p&gt;</span><br><span class="line">&lt;textarea&gt;&lt;/textarea&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=<span class="string">&quot;https://cdn.staticfile.org/clipboard.js/2.0.4/clipboard.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">copyF</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> ClipboardJS(<span class="string">&#x27;#copyInput&#x27;</span>, &#123;</span><br><span class="line">      text: <span class="function"><span class="keyword">function</span>(<span class="params">trigger</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">document</span>.getElementById(<span class="string">&quot;myInput&quot;</span>).value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).on(<span class="string">&#x27;success&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;复制成功！！！&quot;</span>);</span><br><span class="line">      e.clearSelection();</span><br><span class="line">    &#125;).on(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Error!&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="136-http-https-http2的了解"><a href="#136-http-https-http2的了解" class="headerlink" title="136.http,https,http2的了解"></a>136.http,https,http2的了解</h3><p><strong>1.http:</strong></p><p>http是超文本传输协议，也就是HyperText Transfer Protocaol。<br>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。<br>HTTP 是无状态协议，这意味着服务器不会在两个请求之间保留任何数据（状态）。<br>尽管通常基于 TCP/IP 层，但它可以在任何可靠的传输层上使用<br>HTTP 遵循经典的客户端 - 服务端模型，客户端打开一个连接以发出请求，然后等待直到收到服务器端响应，请求-应答的通信模式。<br>信息是明文传输，存在安全隐患。</p><p><strong>2.https:</strong></p><p>HTTPS（超文本传输安全协议）是 HTTP 协议的加密版本.<br>它使用 SSL 或 TLS 协议来加密客户端和服务器之间所有的通信.<br>HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换资料的隐私与完整性。</p><p><strong><em>与HTTP的差异:</em></strong></p><ul><li><p>HTTP的URL是由”http://“起始与默认使用端口80，而HTTPS的URL则是由”https://“起始与默认使用端口443。</p></li><li><p>HTTP不是安全的，而且攻击者可以通过监听和中间人攻击等手段，获取网站帐户和敏感信息等。HTTPS的设计可以防止前述攻击，在正确配置时是安全的。</p></li><li><p>HTTPS连接需要证书：由证书颁发机构签发的证书有免费的，也有每年收费数美元到数千美元不等的。<br>一个组织也可能有自己的证书颁发机构，尤其是当设置浏览器来访问他们自己的网站时（如，运行在公司或学校局域网内的网站）。他们可以容易地将自己的证书加入浏览器中。</p></li><li><p>HTTP协议和HTTPS安全协议同属于应用层，具体来讲，安全协议工作在HTTP之下，传输层之上：安全协议向运行HTTP的进程提供一个类似于TCP的套接字，供进程向其中注入报文，安全协议将报文加密并注入运输层套接字；或是从运输层获取加密报文，解密后交给对应的进程。严格地讲，HTTPS并不是一个单独的协议，而是对工作在一加密连接（TLS或SSL）上的常规HTTP协议的称呼。</p></li></ul><p><strong>3.http/2:</strong></p><p>HTTP/2（超文本传输协议第2版，最初命名为HTTP 2.0）,HTTP/2主要基于SPDY协议.<br>通过以下举措，减少网络延迟，提高浏览器的页面加载速度：</p><ul><li>对HTTP头字段进行数据压缩（即HPACK算法）；</li><li>HTTP/2服务端推送（Server Push）；</li><li>请求流水线；</li><li>修复HTTP/1.0版本以来未修复的队头阻塞问题；</li><li>对数据传输采用多路复用，让多个请求合并在同一TCP连接内。</li><li>支持现有的HTTP应用场景，包括桌面和移动设备浏览器、网络API、不同规格的网络服务器和正向代理、反向代理服务器软件、防火墙和CDN等。</li></ul><p><strong><em>HTTP/2与HTTP/1.1比较:</em></strong></p><p>HTTP/2相比HTTP/1.1的修改并不会破坏现有程序的工作，但是新的程序可以借由新特性得到更好的速度。新增的性能改进不仅包括HTTP/1.1中已有的多路复用，修复队头阻塞问题，允许设置设定请求优先级，还包含了一个头部压缩算法（HPACK）。此外， HTTP/2采用了二进制而非明文来打包、传输客户端和服务器之间的数据。</p><p>HTTP/2保留了HTTP/1.1的大部分语义，例如请求方法、状态码乃至URI和绝大多数HTTP头字段一致。而HTTP/2采用了新的方法来编码、传输客户端和服务器之间的数据。</p><p>HTTP/2引入了服务器推送，即服务端向客户端发送比客户端请求更多的数据。这允许服务器直接提供浏览器渲染页面所需资源，而无须浏览器在收到、解析页面后再提起一轮请求，节约了加载时间。</p><p><strong><em>HTTP/1.1与SPDY的区别:</em></strong></p><p>SPDY（发音同“speedy”）是一个由Google主导的HTTP替代协议。SPDY一开始主要关注降低延迟，采用了TCP通道，但是使用了不同的协议来达到此目的。其与HTTP/1.1相比，主要的改变有：</p><ul><li>实现无需先入先出的多路复用</li><li>为简化客户端和服务器开发的消息—帧机制</li><li>强制性压缩（包括HTTP头部）</li><li>优先级排序</li><li>双向通讯</li></ul><h3 id="137-xml和html有什么区别？"><a href="#137-xml和html有什么区别？" class="headerlink" title="137.xml和html有什么区别？"></a>137.xml和html有什么区别？</h3><p>XML可扩展标记语言是w3c指定的一种标记语言。允许用户定义自己的标签更加灵活。<br>XML是数据描述性语言，HTML时陈述性语言。<br>规则：</p><ol><li>必须有声明语句，XML声明是XML文档的第一句<?xml version="1.0" encoding="utf-8"?></li><li>区分大小写</li><li>XML文档有且只有一个根元素，就是紧接着声明后面建立的第一个元素</li><li>属性值使用引号（在HTML代码里面，属性值可以加引号，也可以不加。但是XML规定，所有属性值必须加引号（可以是单引号，也可以是双引号，建议使用双引号），否则将被视为错误）</li><li>所有的标记必须有相应的结束标记，在HTML中，标记可以不成对出现</li><li>所有的空标记也必须被关闭</li></ol><p>HTML（超文本标记语言——HyperText Markup Language），HTML 标签里的元素名不区分大小写。</p><p><strong><em>XML与HTML区别：</em></strong></p><p>(1)可扩展性方面：HTML不允许用户自行定义他们自己的标识或属性，而在XML中，用户能够根据需要自行定义新的标识及属性名，以便更好地从语义上修饰数据。</p><p>(2)结构性方面：HTML不支持深层的结构描述，XML的文件结构嵌套可以复杂到任意程度，能表示面向对象的等级层次。</p><p>(3)可校验性方面：HTML没有提供规范文件以支持应用软件对HTML文件进行结构校验，而XML文件可以包括一个语法描述，使应用程序可以对此文件进行结构校验。</p><h3 id="138-写出几种创建对象的方式，并说说他们的区别是什么？"><a href="#138-写出几种创建对象的方式，并说说他们的区别是什么？" class="headerlink" title="138.写出几种创建对象的方式，并说说他们的区别是什么？"></a>138.写出几种创建对象的方式，并说说他们的区别是什么？</h3><p>第一种：字面量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;<span class="attr">name</span>: <span class="string">&quot;o1&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>第二种：new实例化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;<span class="attr">name</span>: <span class="string">&quot;o2&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><p>第三种：通过构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> M = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;<span class="built_in">this</span>.name = name&#125;</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="keyword">new</span> M(<span class="string">&quot;o3&quot;</span>)</span><br></pre></td></tr></table></figure><p>第四种：Object.create()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;<span class="attr">name</span>: <span class="string">&quot;p&quot;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> o4 = <span class="built_in">Object</span>.create(p)</span><br></pre></td></tr></table></figure><p>查看<a href="/ZJY.github.io/2021/03/01/javascript%E7%9A%84Object-create%E6%96%B9%E6%B3%95/" title="javascript的Object.create方法">javascript的Object.create方法</a></p><h3 id="139-页面中怎么嵌入Flash？有哪些方法？写出来"><a href="#139-页面中怎么嵌入Flash？有哪些方法？写出来" class="headerlink" title="139.页面中怎么嵌入Flash？有哪些方法？写出来"></a>139.页面中怎么嵌入Flash？有哪些方法？写出来</h3><p>1.embed标签,标签的作用是在 HTML 页面中嵌入多媒体元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">&quot;intro.swf&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>embed元素没有关闭标签。 不能使用替代文本。<br>HTML4 无法识别embed标签。您的页面无法通过验证。<br>如果浏览器不支持 Flash，那么视频将无法播放.<br>iPad 和 iPhone 不能显示 Flash 视频。<br>如果您将视频转换为其他格式，那么它仍然不能在所有浏览器中播放。</p><p>2.object标签,用于包含对象，比如图像、音频、视频、Java applets、ActiveX、PDF 以及 Flash。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">data</span>=<span class="string">&quot;intro.swf&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果浏览器不支持 Flash，那么视频将无法播放.<br>iPad 和 iPhone 不能显示 Flash 视频。<br>如果您将视频转换为其他格式，那么它仍然不能在所有浏览器中播放。</p><h3 id="140-说说你对媒体查询的理解"><a href="#140-说说你对媒体查询的理解" class="headerlink" title="140.说说你对媒体查询的理解"></a>140.说说你对媒体查询的理解</h3><p>媒体查询（Media queries）非常实用，尤其是当你想要根据设备的大致类型（如打印设备与带屏幕的设备）或者特定的特征和设备参数（例如屏幕分辨率和浏览器视窗宽度）来修改网站或应用程序时.<br>媒体查询通常用于一下目的：</p><ul><li>有条件的通过@media和@import rules用css装饰样式</li><li>用media= 属性为<code>&lt;style&gt;</code>,<code>&lt;link&gt;</code>, <code>&lt;source&gt;</code>和其他HTML元素指定特定的媒体类型。如：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">src</span>=<span class="string">&quot;styles.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">src</span>=<span class="string">&quot;styles.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;print&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li>使用Window.matchMedia() 和MediaQueryList.addListener() 方法来测试和监控媒体状态。</li></ul><h3 id="141-写一个使两个整数进行交换的方法（不能使用临时变量）"><a href="#141-写一个使两个整数进行交换的方法（不能使用临时变量）" class="headerlink" title="141.写一个使两个整数进行交换的方法（不能使用临时变量）"></a>141.写一个使两个整数进行交换的方法（不能使用临时变量）</h3><p>1.利用运算符优先级和0*</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b = a + <span class="number">0</span> * (a = b);</span><br></pre></td></tr></table></figure><p>2.利用执行顺序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a + b;</span><br><span class="line">b = a - b;</span><br><span class="line">a = a - b;</span><br></pre></td></tr></table></figure><p>3.异或取值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a ^= b;</span><br><span class="line">b ^= a;</span><br><span class="line">a ^= b;</span><br></pre></td></tr></table></figure><p>4.es6解构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>, b= <span class="number">2</span></span><br><span class="line">[a, b] = [b, a]</span><br></pre></td></tr></table></figure><h3 id="142-HTML5如何使用音频和视频？"><a href="#142-HTML5如何使用音频和视频？" class="headerlink" title="142.HTML5如何使用音频和视频？"></a>142.HTML5如何使用音频和视频？</h3><p><strong>video视频：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> <span class="attr">width</span>=<span class="string">&quot;250&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;/media/cc0-videos/flower.webm&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">type</span>=<span class="string">&quot;video/webm&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;/media/cc0-videos/flower.mp4&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  Download the</span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/media/cc0-videos/flower.webm&quot;</span>&gt;</span>WEBM<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  or</span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/media/cc0-videos/flower.mp4&quot;</span>&gt;</span>MP4<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  video.</span><br><span class="line">  <span class="comment">&lt;!-- 在不支持 video 元素的浏览器中，&lt;video&gt;&lt;/video&gt; 标签中间的内容会显示，</span></span><br><span class="line"><span class="comment">  作为降级处理。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong><em>属性：</em></strong></p><ul><li>autoplay: 布尔属性；声明该属性后，视频会尽快自动开始播放，不会停下来等待数据全部加载完成。</li><li>controls: 加上这个属性，浏览器会在视频底部提供一个控制面板，允许用户控制视频的播放，包括音量，跨帧，暂停/恢复播放。</li><li>crossorigin: 该枚举属性指明是否使用 CORS（跨域资源共享）来获取相关视频.取值如下：<ul><li>anonymous： 在发送跨域请求时不携带凭证（credential）信息</li><li>use-credentials： 在发送跨域请求时携带凭证（credential）信息</li></ul></li><li>height: 视频显示区域的高度，单位是 CSS 像素（仅限绝对值；不支持百分比）。</li><li>width: 视频显示区域的宽度，单位是 CSS 像素（仅限绝对值；不支持百分比）.</li><li>loop: 布尔属性；指定后，会在视频播放结束的时候，自动返回视频开始的地方，继续播放。</li><li>muted: 布尔属性，指明在视频中音频的默认设置。设置后，音频会初始化为静音。默认值是 false, 意味着视频播放的时候音频也会播放(不静音)。</li><li>poster：海报帧图片 URL，用于在视频处于下载中的状态时显示。如果未指定该属性，则在视频第一帧可用之前不会显示任何内容，然后将视频的第一帧会作为海报（poster）帧来显示。</li><li>preload：该枚举属性旨在提示浏览器，作者认为在播放视频之前，加载哪些内容会达到最佳的用户体验。可能是下列值之一：<ul><li>none: 表示不应该预加载视频。</li><li>metadata: 表示仅预先获取视频的元数据（例如长度）。</li><li>auto: 表示可以下载整个视频文件，即使用户不希望使用它。</li><li>空字符串: 和值为 auto 一致。每个浏览器的默认值都不相同，即使规范建议设置为 metadata。</li></ul></li><li>src: 要嵌到页面的视频的 URL。可选；你也可以使用 video 块内的 <code>&lt;source&gt;</code> 元素来指定需要嵌到页面的视频。</li></ul><p><strong>audio音频：</strong></p><p><code>&lt;audio&gt;</code> 元素可以包含一个或多个音频资源，这些音频资源可以使用 src 属性或者<code>&lt;source&gt;</code> 元素来进行描述：浏览器将会选择最合适的一个来使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;audio</span><br><span class="line">  controls</span><br><span class="line">  src=&quot;/media/cc0-audio/t-rex-roar.mp3&quot;&gt;</span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/media/cc0-audio/t-rex-roar.mp3&quot;</span>&gt;</span></span><br><span class="line">      Download audio</span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 在浏览器不支持该元素时，会显示 &lt;audio&gt;&lt;/audio&gt; 标签之间的内容作为回退。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong><em>属性：</em></strong></p><ul><li>autoplay: 布尔属性；声明该属性后，音频会尽快自动开始播放，不会停下来等待数据全部加载完成。</li><li>controls: 如果声明了该属性，浏览器将提供一个包含声音，播放进度，播放暂停的控制面板，让用户可以控制音频的播放。</li><li>crossorigin: 该枚举属性指明是否使用 CORS（跨域资源共享）来获取相关音频.取值如下：<ul><li>anonymous： 在发送跨域请求时不携带凭证（credential）信息</li><li>use-credentials： 在发送跨域请求时携带凭证（credential）信息</li></ul></li><li>currentTime：读取 currentTime 属性将返回一个双精度浮点值，用以标明以秒为单位的当前音频的播放位置</li><li>loop: 布尔属性；如果声明该属性，将循环播放音频。</li><li>muted: 表示是否静音的布尔值。默认值为 false，表示有声音。</li><li>preload：枚举属性，让开发者自行思考来示意浏览器使用何种加载方式以达到最好的用户体验。可以是以下属性之一：<ul><li>none: 示意用户可能不会播放该音频，或者服务器希望节省带宽；换句话说，该音频不会被缓存；</li><li>metadata: 示意即使用户可能不会播放该音频，但获取元数据 (例如音频长度) 还是有必要的。</li><li>auto: 示意用户可能会播放音频；换句话说，如果有必要，整个音频都将被加载，即使用户不期望使用。</li><li>空字符串 : 等效于auto属性。不同浏览器会有自己的默认值，规范建议的默认值为 metadata。</li></ul></li><li>src: 要嵌到页面的音频的 URL。可选；你也可以使用 audio 块内的 <code>&lt;source&gt;</code> 元素来指定需要嵌到页面的音频。</li></ul><h3 id="143-请说说你对事件冒泡机制的理解？"><a href="#143-请说说你对事件冒泡机制的理解？" class="headerlink" title="143.请说说你对事件冒泡机制的理解？"></a>143.请说说你对事件冒泡机制的理解？</h3><p>DOM事件模型分为捕获和冒泡。一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段</p><p>1.捕获阶段：事件从window对象自上而下向目标节点传播的阶段<br>2.目标阶段：真正的目标节点正在处理事件的阶段<br>3.冒泡阶段：事件从目标节点自下而上向window对象传播的阶段</p><p>事件委托：冒泡还允许我们利用事件委托——这个概念依赖于这样一个事实，如果你想要在大量子元素中单击任何一个都可以运行一段代码，您可以将事件监听器设置在其父节点上，并让子节点上发生的事件冒泡到父节点上，而不是每个子节点单独设置事件监听器。</p><p>event.preventDefault();阻止默认事件的发生，比如链接跳转，表单提交<br>event.stopPropagation();阻止事件流在dom结构中传播，取消后续的事件捕获或冒泡。<br>event.stopImmediatePropagation();用于取消后续事件捕获或事件冒泡，并阻止调用任何后续事件处理程序。</p><h3 id="144-说说你对WEB标准和W3C的理解与认识？"><a href="#144-说说你对WEB标准和W3C的理解与认识？" class="headerlink" title="144.说说你对WEB标准和W3C的理解与认识？"></a>144.说说你对WEB标准和W3C的理解与认识？</h3><p>个人理解：</p><ul><li>html - 表示人的光身体 —结构</li><li>css - 表示给人穿的衣服 —表现</li><li>js - 表示人的行为，走路等 —行为</li></ul><p>web简单来说可以分为结构、表现和行为。</p><ul><li>其中结构主要是由HTML标签组成。</li><li>表现是指css样式表，可用通过css使页面标签更具美感。</li><li>行为是指用户和页面有一定的交互，同时结构和表现也会发生变化，主要由js组成</li></ul><p>web标准一般是将该三部分独立分开，使其更具有模块化。但一般产生行为时，就会有结构或者表现的变化，也使这三者的界限并不那么清晰。</p><p>W3C对web标准提出了规范化的要求，也就是在实际编程中的一些代码规范：</p><ul><li><p>对于结构要求（标签规范可以提高搜索引擎对页面的抓取率，对seo很有帮助）：<br>标签要小写<br>标签要闭合<br>标签不能随意嵌套</p></li><li><p>对于css和js来说：<br>使用外链css和js，使结构、表现、行为三者分离。<br>提高页面渲染速度，提高用户体验<br>尽量少使用行内样式，使结构和表现分离，标签的id和class要见文知意，标签越少，加载越快，用户体验越高<br>不需要变动页面内容，便可提供打印版本而不需要复制内容，提高网站易用性。</p></li></ul><h3 id="145-你知道全屏滚动的原理是什么吗？它用到了CSS的哪些属性？"><a href="#145-你知道全屏滚动的原理是什么吗？它用到了CSS的哪些属性？" class="headerlink" title="145.你知道全屏滚动的原理是什么吗？它用到了CSS的哪些属性？"></a>145.你知道全屏滚动的原理是什么吗？它用到了CSS的哪些属性？</h3><p>css的overflow:hidden，配合transition : all 1s ease;</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="comment">/* html, body设置 overflow 为 hidden, 让视图中只包括一个分页;设置滑动分页的长宽都是 100%; 外部容器设置 transition 过渡效果, 并设置为相对定位, 滚动是修改外部容器的 Top 值, 实现滚动效果. */</span></span></span><br><span class="line">      html,</span><br><span class="line">      body &#123;</span><br><span class="line">        padding: 0;</span><br><span class="line">        margin: 0;</span><br><span class="line">        overflow: hidden;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.page-container</span> &#123;</span></span><br><span class="line">        position: relative;</span><br><span class="line">        top: 0;</span><br><span class="line">        transition: all 1000ms ease;</span><br><span class="line">        touch-action: none;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.page-item</span> &#123;</span></span><br><span class="line">        display: flex;</span><br><span class="line">        justify-content: center;</span><br><span class="line">        align-items: center;</span><br><span class="line">        width: 100%;</span><br><span class="line">        height: 100%;</span><br><span class="line"><span class="css">        <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#ddd</span>;</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 初始三个分页 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;page-container&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;page-item&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;page-item&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;page-item&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> container = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.page-container&#x27;</span>)</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 获取根元素高度, 页面可视高度</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> viewHeight = <span class="built_in">document</span>.documentElement.clientHeight</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 获取滚动的页数</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> pageNum = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;.page-item&#x27;</span>).length</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 初始化当前位置, 距离原始顶部距离</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> currentPosition = <span class="number">0</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 设置页面高度 容器高度设置为窗口高度</span></span></span><br><span class="line"><span class="javascript">      container.style.height = viewHeight + <span class="string">&#x27;px&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// 初始化滚动事件:向下滚动时, 当 currentPosition 比 -整体分页高度 大的时候(绝对值相比小的时候), 向下滚动;向上滚动时, 当 currentPosition 大于 0 的时候, 向上滚动.</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 向下滚动页面</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">goDown</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (currentPosition &gt; - viewHeight * (pageNum - <span class="number">1</span>)) &#123;</span></span><br><span class="line">          currentPosition = currentPosition - viewHeight</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">&#x27;down&#x27;</span>, currentPosition)</span></span><br><span class="line"><span class="javascript">          container.style.top = currentPosition + <span class="string">&#x27;px&#x27;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// 向上滚动页面</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">goUp</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (currentPosition &lt; <span class="number">0</span>) &#123;</span></span><br><span class="line">          currentPosition = currentPosition + viewHeight</span><br><span class="line"><span class="javascript">          container.style.top = currentPosition + <span class="string">&#x27;px&#x27;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      <span class="comment">// 节流函数:即在规定时间内只会触发一次指定方法, 用于滚动时防止多次触发</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">throttle</span> (<span class="params">fn, delay</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> baseTime = <span class="number">0</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">const</span> currentTime = <span class="built_in">Date</span>.now()</span></span><br><span class="line"><span class="javascript">          <span class="keyword">if</span> (baseTime + delay &lt; currentTime) &#123;</span></span><br><span class="line"><span class="javascript">            fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span></span><br><span class="line">            baseTime = currentTime</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      <span class="comment">// 监听鼠标滚动:滚动事件firefox与其他浏览器的事件不同, 所以需要进行判断. deltaY大于0的时候, 向下滚动; 反之, 向上滚动.</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> handlerWheel = throttle(scrollMove, <span class="number">1000</span>)</span></span><br><span class="line"><span class="javascript">      <span class="comment">// https://developer.mozilla.org/en-US/docs/Web/API/Element/mousewheel_event#The_detail_property</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// firefox的页面滚动事件其他浏览器不一样</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (navigator.userAgent.toLowerCase().indexOf(<span class="string">&#x27;firefox&#x27;</span>) === -<span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;mousewheel&#x27;</span>, handlerWheel)</span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;DOMMouseScroll&#x27;</span>, handlerWheel)</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">scrollMove</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(e.deltaY)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (e.deltaY &gt; <span class="number">0</span>) &#123;</span></span><br><span class="line">          goDown()</span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line">          goUp()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// 监听移动端touch操作：当 touch 的最终位置大于起始位置时, 则页面向上滚动; 反之, 向下滚动.</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> touchStartY = <span class="number">0</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;touchstart&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span></span><br><span class="line">        touchStartY = event.touches[0].pageY</span><br><span class="line">      &#125;)</span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> handleTouchEnd = throttle(touchEnd, <span class="number">500</span>)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;touchend&#x27;</span>, handleTouchEnd)</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">touchEnd</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> touchEndY = e.changedTouches[<span class="number">0</span>].pageY</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (touchEndY - touchStartY &lt; <span class="number">0</span>) &#123; <span class="comment">// 向上滑动, 页面向下滚动</span></span></span><br><span class="line">          goDown()</span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line">          goUp()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="146-你对事件循环有了解吗？说说看"><a href="#146-你对事件循环有了解吗？说说看" class="headerlink" title="146.你对事件循环有了解吗？说说看"></a>146.你对事件循环有了解吗？说说看</h3><ul><li><p>同步任务：在主线程上执行的任务，只有前一个任务执行完，才能执行下一个任务</p></li><li><p>异步任务：不进入主线程而进入“任务队列”的任务，只有任务队列通知主线程，某个任务可以执行了，该任务才会进入主线程执行。</p><p>  异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）：<br>  1）所以同步任务都在主线程执行，形成一个执行栈<br>  2）主线程之外，还有一个任务队列，只要异步任务有了执行结果，就在任务队列放置一个事件<br>  3）一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列，看看有哪些事件，对应的事件就结束等待状态，进入执行栈进行执行<br>  4）主线程不断重复第三步</p></li></ul><p>主线程从“任务队列”中读取事件，这个事件是循环不断的，又称为事件循环（Event loop）</p><p>js是单线程非阻塞的脚本语言，意味着代码在js执行的任何时候只有一个主线程来处理所有任务。而非阻塞是指当代码需要异步处理的时候，主线程会挂起这个任务，当异步任务处理完毕后，主线程再根据一定规则去执行相应的回调。</p><p>当任务处理完毕，js会将这个事件加入一个队列，这个队列叫做事件队列。被放入事件队列中的事件不会立刻执行其回调，而是等待执行栈中所有任务都执行完毕后，主线程会查询事件队列中是否有任务。</p><p>异步任务分为：宏任务和微任务，不同类型的任务会被分配到不同的任务队列中。</p><p>当执行栈中所有任务都执行完毕后，会去检查微任务队列是否有事件存在，如果存在，会依次执行任务队列对应的回调，直到为空。然后去宏任务队列中取出一个事件，把对应的回调加入到当前执行战，当执行栈中所有任务都执行完毕后，检查为任务队列是否有事件存在。无限重复此过程，就形成了循环，这个循环就叫做事件循环。</p><p>微任务包括但不限于以下几种：</p><ul><li>Promise.then</li><li>MutationObserver</li><li>Object.observe</li><li>process.nextTick</li></ul><p>宏任务包括但不限于以下几种：</p><ul><li>setTimeout</li><li>setInterval</li><li>setImmediate</li><li>MessageChannel</li><li>requestAnimationFrame</li><li>I/O</li><li>UI交互事件</li></ul><h3 id="147-说说你对target-”-blank”的理解？有啥安全性问题？如何防范？"><a href="#147-说说你对target-”-blank”的理解？有啥安全性问题？如何防范？" class="headerlink" title="147.说说你对target=”_blank”的理解？有啥安全性问题？如何防范？"></a>147.说说你对target=”_blank”的理解？有啥安全性问题？如何防范？</h3><p>如果此文档可以安全地显示，则需要一个新的未命名窗口或标签来显示链接的内容。如果用户代理不支持多个窗口/选项卡，则结果与_top 相同。</p><p><strong>问题：</strong><br>在调用window下的open方法创建一个新窗口的同时，可以获得一个创建窗口的opener句柄，通过target=”_blank”点开的窗口或者标签页，子窗口也能捕获opener句柄，通过这个句柄，子窗口可以访问到父窗口的一些属性，虽然很有限，但是却可以修改父窗口的页面地址，让父窗口显示指定的页面。</p><p><strong>防范：</strong><br>如果需要限制window.opener的访问行为，我们只需要在原始页面每个使用了target=”_blank”的链接中加上一个rel=”noopener”属性。<br>但是，火狐并不支持这个属性值，火狐浏览器里需要写成rel=”noreferrer”，所以我们可以将两个属性值合并写成rel=”noopener noreferrer”来完整覆盖。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;noopener noreferrer nofollow&quot;</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>nofollow 是HTML页面中a标签的属性值。这个标签的意义是告诉搜索引擎”不要追踪此网页上的链接或不要追踪此特定链接”。</p><h3 id="148-写个还剩下多少天过年的倒计时"><a href="#148-写个还剩下多少天过年的倒计时" class="headerlink" title="148.写个还剩下多少天过年的倒计时"></a>148.写个还剩下多少天过年的倒计时</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.floor((<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() + <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>) - <span class="built_in">Date</span>.now()) / (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>)) - <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="149-列举CSS优化、提高性能的方法"><a href="#149-列举CSS优化、提高性能的方法" class="headerlink" title="149.列举CSS优化、提高性能的方法"></a>149.列举CSS优化、提高性能的方法</h3><p><strong>加载性能.</strong></p><p>压缩CSS<br>通过link方式加载，而不是@import<br>复合属性其实分开写，执行效率更高，因为CSS最终也还是要去解析如 margin-left: left;</p><p><strong>选择器性能</strong><br>尽量少的使用嵌套，可以采用BEM的方式来解决命名冲突<br>尽量少甚至是不使用标签选择器，这个性能实在是差，同样的还有*选择器<br>利用继承，减少代码量</p><p><strong>渲染性能</strong><br>慎重使用高性能属性：浮动、定位；<br>尽量减少页面重排、重绘；<br>css雪碧图<br>自定义web字体，尽量少用<br>尽量减少使用昂贵属性，如box-shadow/border-radius/filter/透明度/:nth-child等<br>使用transform来变换而不是宽高等会造成重绘的属性</p><h3 id="150-请写出一个函数求出N的阶乘（即N-）"><a href="#150-请写出一个函数求出N的阶乘（即N-）" class="headerlink" title="150.请写出一个函数求出N的阶乘（即N!）"></a>150.请写出一个函数求出N的阶乘（即N!）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">1</span>)  <span class="keyword">return</span> n*factorial(n-<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="151-如何实现换肤功能？"><a href="#151-如何实现换肤功能？" class="headerlink" title="151.如何实现换肤功能？"></a>151.如何实现换肤功能？</h3><p>一、使用link引入不同主题css，利用js设置link disabled加载不同样式表<br><img src="/ZJY.github.io/images/linkSkin.gif" alt="image"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>换肤<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;alternate stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;red.css&quot;</span> <span class="attr">title</span>=<span class="string">&quot;红色&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;alternate stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;green.css&quot;</span> <span class="attr">title</span>=<span class="string">&quot;绿色&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;default.css&quot;</span> <span class="attr">title</span>=<span class="string">&quot;默认&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    html, body &#123;</span><br><span class="line">      margin: 0;</span><br><span class="line">      padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    换肤：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;default&quot;</span> <span class="attr">name</span>=<span class="string">&quot;skin&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;default.css&quot;</span> <span class="attr">checked</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;default&quot;</span>&gt;</span>默认<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;red&quot;</span> <span class="attr">name</span>=<span class="string">&quot;skin&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;red.css&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;red&quot;</span>&gt;</span>红色<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;green&quot;</span> <span class="attr">name</span>=<span class="string">&quot;skin&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;green.css&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;green&quot;</span>&gt;</span>绿色<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。</span><br><span class="line">    Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。</span><br><span class="line">    Web Worker 有以下几个使用注意点。</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> $ = <span class="built_in">document</span>.querySelectorAll.bind(<span class="built_in">document</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> links = $(<span class="string">&#x27;link[title]&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> radios = $(<span class="string">&#x27;input[type=radio]&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    [].slice.call(radios).forEach(<span class="function"><span class="params">radio</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      radio.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> value = <span class="built_in">this</span>.value;</span></span><br><span class="line"><span class="javascript">        [].slice.call(links).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">link</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          link.disabled = <span class="literal">true</span> <span class="comment">// 必须先设置为true</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">if</span> (link.getAttribute(<span class="string">&#x27;href&#x27;</span>) == value) &#123;</span></span><br><span class="line"><span class="javascript">            link.disabled = <span class="literal">false</span></span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>二、使用全局变量 var<br><img src="/ZJY.github.io/images/varSkin.gif" alt="换肤"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    body &#123;</span><br><span class="line">      --textColor: blue;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">      color: var(--textColor);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    换肤：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;default&quot;</span> <span class="attr">name</span>=<span class="string">&quot;skin&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;blue&quot;</span> <span class="attr">checked</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;default&quot;</span>&gt;</span>默认<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;red&quot;</span> <span class="attr">name</span>=<span class="string">&quot;skin&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;red&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;red&quot;</span>&gt;</span>红色<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;green&quot;</span> <span class="attr">name</span>=<span class="string">&quot;skin&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;green&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;green&quot;</span>&gt;</span>绿色<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。</span><br><span class="line">    Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。</span><br><span class="line">    Web Worker 有以下几个使用注意点。</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> $ = <span class="built_in">document</span>.querySelectorAll.bind(<span class="built_in">document</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> radios = $(<span class="string">&#x27;input[type=radio]&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    [].slice.call(radios).forEach(<span class="function"><span class="params">radio</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      radio.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> value = <span class="built_in">this</span>.value;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.body.style.setProperty(<span class="string">&#x27;--textColor&#x27;</span>, value)</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 或者 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">data-theme</span>=<span class="string">&quot;default&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>换肤<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-pseudo">:root</span> &#123;</span></span><br><span class="line">      --textColor: blue;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-attr">[data-theme=<span class="string">&quot;red&quot;</span>]</span> &#123;</span></span><br><span class="line">      --textColor: red;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-attr">[data-theme=<span class="string">&quot;green&quot;</span>]</span> &#123;</span></span><br><span class="line">      --textColor: green;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">      color: var(--textColor);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    换肤：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;default&quot;</span> <span class="attr">name</span>=<span class="string">&quot;skin&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;default&quot;</span> <span class="attr">checked</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;default&quot;</span>&gt;</span>默认<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;red&quot;</span> <span class="attr">name</span>=<span class="string">&quot;skin&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;red&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;red&quot;</span>&gt;</span>红色<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;green&quot;</span> <span class="attr">name</span>=<span class="string">&quot;skin&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;green&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;green&quot;</span>&gt;</span>绿色<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。</span><br><span class="line">    Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。</span><br><span class="line">    Web Worker 有以下几个使用注意点。</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> $ = <span class="built_in">document</span>.querySelectorAll.bind(<span class="built_in">document</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> html = $(<span class="string">&#x27;html&#x27;</span>)[<span class="number">0</span>]</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> radios = $(<span class="string">&#x27;input[type=radio]&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    [].slice.call(radios).forEach(<span class="function"><span class="params">radio</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      radio.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> value = <span class="built_in">this</span>.value;</span></span><br><span class="line"><span class="javascript">        html.setAttribute(<span class="string">&#x27;data-theme&#x27;</span>, value)</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>三、使用css命名空间<br><img src="/ZJY.github.io/images/namespaceSkin.gif" alt="images"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.red-theme</span> <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">      color: red;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.green-theme</span> <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">      color: green;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">      color: blue;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    换肤：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;default&quot;</span> <span class="attr">name</span>=<span class="string">&quot;skin&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">checked</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;default&quot;</span>&gt;</span>默认<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;red&quot;</span> <span class="attr">name</span>=<span class="string">&quot;skin&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;red&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;red&quot;</span>&gt;</span>红色<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;green&quot;</span> <span class="attr">name</span>=<span class="string">&quot;skin&quot;</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">value</span>=<span class="string">&quot;green&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;green&quot;</span>&gt;</span>绿色<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。</span><br><span class="line">    Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。</span><br><span class="line">    Web Worker 有以下几个使用注意点。</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> $ = <span class="built_in">document</span>.querySelectorAll.bind(<span class="built_in">document</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> radios = $(<span class="string">&#x27;input[type=radio]&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    [].slice.call(radios).forEach(<span class="function"><span class="params">radio</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      radio.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> value = <span class="built_in">this</span>.value;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.body.className = value ? value + <span class="string">&#x27;-theme&#x27;</span> : <span class="string">&#x27;&#x27;</span></span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="152-如何取消promise"><a href="#152-如何取消promise" class="headerlink" title="152.如何取消promise"></a>152.如何取消promise</h3><h3 id="153-如何捕获-setTimeout-异常"><a href="#153-如何捕获-setTimeout-异常" class="headerlink" title="153.如何捕获 setTimeout 异常"></a>153.如何捕获 setTimeout 异常</h3><p>try catch 是捕获同步异常的。这里可以用 promise 来捕获，异步错误会触发 reject 函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;异常捕获&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="154-fetch-和-ajax-区别"><a href="#154-fetch-和-ajax-区别" class="headerlink" title="154.fetch 和 ajax 区别"></a>154.fetch 和 ajax 区别</h3><p><strong>fetch:</strong></p><p>全局的 fetch() 方法用于发起获取资源的请求。它返回一个 promise，这个 promise 会在请求响应后被 resolve，并传回 Response 对象。</p><p>当遇到网络错误时，fetch() 返回的 promise 会被 reject，并传回 TypeError，虽然这也可能因为权限或其它问题导致。成功的 fetch() 检查不仅要包括 promise 被 resolve，还要包括 Response.ok 属性为 true。HTTP 404 状态并不被认为是网络错误。</p><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>&lt;Response&gt; fetch(input[, init]);</span><br></pre></td></tr></table></figure><p>input: 定义要获取的资源，可能是url或Request对象<br>init: 可选，一个配置项对象，包括所有对请求的设置，method,headers,mode, credentials,cache,redirect,referrer,referrerPolicy,integrity</p><p>返回值：一个 Promise，resolve 时回传 Response 对象。</p><p><strong>ajax:</strong></p><p>AJAX 是异步的 JavaScript 和 XML（Asynchronous JavaScript And XML）。简单点说，就是使用 XMLHttpRequest 对象与服务器通信.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=<span class="string">&quot;ajaxButton&quot;</span> type=<span class="string">&quot;button&quot;</span>&gt;Make a request&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> httpRequest;</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;ajaxButton&quot;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, makeRequest);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    httpRequest = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!httpRequest) &#123;</span><br><span class="line">      alert(<span class="string">&#x27;Giving up :( Cannot create an XMLHTTP instance&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    httpRequest.onreadystatechange = alertContents;</span><br><span class="line">    httpRequest.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;test.html&#x27;</span>);</span><br><span class="line">    httpRequest.send();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">alertContents</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (httpRequest.readyState === XMLHttpRequest.DONE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (httpRequest.status === <span class="number">200</span>) &#123;</span><br><span class="line">          alert(httpRequest.responseText);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          alert(<span class="string">&#x27;There was a problem with the request.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>( e ) &#123;</span><br><span class="line">      alert(<span class="string">&#x27;Caught Exception: &#x27;</span> + e.description);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>fetch和ajax区别：</strong></p><ul><li>当接收代表错误的状态码，从fetch返回的promise不会被标记为reject，即使响应http状态码为404或500.相反，它会将 Promise 状态标记为 resolve（如果响应的 HTTP 状态码不在 200 - 299 的范围内，则设置 resolve 返回值的 ok 属性为 false），仅当网络故障时或请求被阻止时，才会标记为 reject。</li><li>fetch 不会发送跨域 cookie，除非你使用了 credentials 的初始化选项。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fetch(url, &#123;</span><br><span class="line">  credentials: <span class="string">&#x27;same-origin&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>一个简单的fetch请求：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&quot;http://pmcp-gateway.dev.hxss.com.cn/gateway/client&quot;</span>)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">.then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data))</span><br></pre></td></tr></table></figure><h3 id="155-form表单是怎么上传文件的？你了解它的原理吗？"><a href="#155-form表单是怎么上传文件的？你了解它的原理吗？" class="headerlink" title="155.form表单是怎么上传文件的？你了解它的原理吗？"></a>155.form表单是怎么上传文件的？你了解它的原理吗？</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;file&quot;</span>&gt;</span>选择要上传的文件<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">id</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> <span class="attr">multiple</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>文件input的value属性包含了一个字符串，表示已选择文件的路径。如果用户没有选择任何文件，则该值为空字符串（””）。如果用户选择了多个文件，则 value 表示他们选择的文件列表中的第一个文件。</p><p>注：为了阻止恶意软件猜测文件路径，该值的字符串表示总是以 C:\fakepath\ 为前缀的文件名，而并不是文件的真实路径。</p><p>accept：是一个字符串，它定义了文件 input 应该接受的文件类型。这个字符串是一个以逗号为分隔的唯一文件类型说明符列表。</p><p>capture 属性是一个字符串，如果 accept (en-US) 属性指出了 input 是图片或者视频类型，则它指定了使用哪个摄像头去获取这些数据。值 user 表示应该使用前置摄像头和（或）麦克风。值 environment 表示应该使用后置摄像头和（或）麦克风。</p><p>multiple：当指定布尔类型属性 multiple时，文件 input 允许用户选择多个文件。</p><p>文件上传form表单：method必须为post，enctype=”multipart/form-data”(二进制字节流)<br>http请求包含两部分header+body， 一部分是Request Payload，另一部分是Requst Header，文件上传header的Content-Type=”multipart/form-data；boundary=ed67c97e-2000-47de-9033-77aeb8df43d9”，boundary它标志着一段数据（当有多个上传内容时）的开始和结束.</p><h3 id="156-字符串相连有哪些方式？哪种最好？为什么？"><a href="#156-字符串相连有哪些方式？哪种最好？为什么？" class="headerlink" title="156.字符串相连有哪些方式？哪种最好？为什么？"></a>156.字符串相连有哪些方式？哪种最好？为什么？</h3><p>ES6: ${var} 模版字符串<br>简单，方便，但是不兼容低版本浏览器<br>ES5：””+”” ‘’+’’<br>兼容性好，但是比较麻烦考验心智，如果拼接的有””‘’时需要\转义</p><h3 id="157-说说你对CDN的理解，使用过程中有没有遇到过问题？"><a href="#157-说说你对CDN的理解，使用过程中有没有遇到过问题？" class="headerlink" title="157.说说你对CDN的理解，使用过程中有没有遇到过问题？"></a>157.说说你对CDN的理解，使用过程中有没有遇到过问题？</h3><p>一、概述<br>CDN (内容分发网络) 指的是一组分布在各个地区的服务器。这些服务器存储着数据的副本，因此服务器可以根据哪些服务器与用户距离最近，来满足数据的请求。CDN提供快速服务，较少受高流量影响。</p><p>CDN被广泛用于传输 stylesheets 和 JavaScript 等静态资源，像 Bootstrap，Jquery 等。对这些库文件使用 CDN 技术，有以下几点好处：</p><ul><li>通过CDN向用户分发相关静态资源文件，可以降低自身服务器的压力</li><li>大多数 CDN 在全球都有服务器，所以 CDN 上的服务器在地理位置上可能比你自己的服务器更接近你的用户。地理距离会按比例影响延迟。</li><li>CDN已经配置了恰当的缓存设置。使用 CDN 节省了在你的服务器中对静态资源文件的配置。</li></ul><p>有点不好就是：</p><p>大部分CDN是单独收费的。<br>CDN更新资源麻烦，可能需要手动来刷新CDN来刷新资源的缓存。<br>如果CDN出了故障，需要联系CDN提供商来解决，中间增加了沟通耗时。<br>可能对SEO有影响，CDN ip的多样性，部分ip可能对爬虫并不友好。</p><h3 id="158-web-workers有用过吗？能帮我们解决哪些问题？"><a href="#158-web-workers有用过吗？能帮我们解决哪些问题？" class="headerlink" title="158.web workers有用过吗？能帮我们解决哪些问题？"></a>158.web workers有用过吗？能帮我们解决哪些问题？</h3><p>JavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事.<br>Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行.<br>在主线程运行的同时，Worker 线程在后台运行，两者互不干扰</p><p>Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭.</p><p>Web Worker 有以下几个使用注意点。</p><ul><li>1.同源限制<br>Worker线程运行的脚本文件，必须和运行主线程的脚本文件同源</li><li>DOM限制<br>Worker线程所在的全局环境和主线程不一致，所以不能使用document,window,parent等，但能使用navigator,location</li><li>通信限制<br>Worker线程和主线程不在同一个上下文环境，无法直接通信，只能通过消息</li><li>脚本限制<br>Woker线程不能执行alert方法和confirm方法，但可以使用ajax</li><li>文件限制<br>Worker 线程无法读取本地文件，即不能打开本机的文件系统（file://），它所加载的脚本，必须来自网络。</li></ul><p>二、使用</p><p>主线程采用new命令，调用Worker()构造函数，新建一个 Worker 线程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> Woker(<span class="string">&#x27;work.js&#x27;</span>) <span class="comment">// 必须是网络脚本</span></span><br></pre></td></tr></table></figure><p>然后，主线程调用worker.postMessage()方法，向 Worker 发消息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">worker.postMessage(<span class="string">&#x27;hello world&#x27;</span>); <span class="comment">//参数，就是主线程传给 Worker 的数据。它可以是各种数据类型，包括二进制数据。</span></span><br><span class="line">worker.postMessage(&#123;<span class="attr">method</span>: <span class="string">&#x27;echo&#x27;</span>, <span class="attr">args</span>: [<span class="string">&#x27;Work&#x27;</span>]&#125;);</span><br></pre></td></tr></table></figure><p>主线程通过worker.onmessage指定监听函数，接收子线程发回来的消息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">worker.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;received message &#x27;</span>, event.data);</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Worker 完成任务以后，主线程就可以把它关掉。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker.terminate()</span><br></pre></td></tr></table></figure><p>Worker 线程内部需要有一个监听函数，监听message事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.postMessage(<span class="string">&#x27;You said: &#x27;</span> + e.data);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>worker 线程关闭</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.close()</span><br></pre></td></tr></table></figure><h3 id="159-怎么使用自定义字体？有什么注意事项？"><a href="#159-怎么使用自定义字体？有什么注意事项？" class="headerlink" title="159.怎么使用自定义字体？有什么注意事项？"></a>159.怎么使用自定义字体？有什么注意事项？</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;myFont&#x27;</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;字体文件名.eot&#x27;</span>); <span class="comment">/* IE9 Compat Modes */</span></span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;字体文件名.eot?#iefix&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;embedded-opentype&#x27;</span>), <span class="comment">/* IE6-IE8 */</span></span><br><span class="line">  <span class="built_in">url</span>(<span class="string">&#x27;字体文件名.woff&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff&#x27;</span>), <span class="comment">/* Modern Browsers */</span></span><br><span class="line">  <span class="built_in">url</span>(<span class="string">&#x27;字体文件名.ttf&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;truetype&#x27;</span>), <span class="comment">/* Safari, Android, iOS */</span></span><br><span class="line">  <span class="built_in">url</span>(<span class="string">&#x27;字体文件名.svg#字体文件名&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;svg&#x27;</span>); <span class="comment">/* Legacy iOS */</span></span><br><span class="line">  <span class="attribute">font-style</span>: normal;</span><br><span class="line">  <span class="attribute">font-weight</span>: normal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 使用 */</span></span><br><span class="line"><span class="selector-class">.demo</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;myFont&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意版权，以及字体文件大，加载慢</p><h3 id="160-window的load-和ready有什么区别？"><a href="#160-window的load-和ready有什么区别？" class="headerlink" title="160.window的load 和ready有什么区别？"></a>160.window的load 和ready有什么区别？</h3><p><strong>window的load:</strong></p><p>load 事件在整个页面及所有依赖资源如样式表和图片都已完成加载时触发。它与 DOMContentLoaded 不同，后者只要页面 DOM 加载完成就触发，无需等待依赖资源的加载。</p><p>该事件不可取消，也不会冒泡。</p><p>所有以 load 命名的事件都不会传递到 Window 上，即使 bubbles 初始化为 true。要在 window 上捕获 load 事件，相关的 load 事件必须直接绑定到 window 上。只能绑定一次load事件</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;page is fully loaded&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;page is fully loaded&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>$(document).ready jQuery等待加载：</strong></p><!-- $(document).ready(function () {}); //jQuery等待加载 --><p>只需要等DOM结构加载完毕，就能执行包裹的代码，可以绑定多次ready事件，并且不会被覆盖</p><h3 id="161-你有了解HTML5的地理定位吗？怎么使用？"><a href="#161-你有了解HTML5的地理定位吗？怎么使用？" class="headerlink" title="161.你有了解HTML5的地理定位吗？怎么使用？"></a>161.你有了解HTML5的地理定位吗？怎么使用？</h3><p><strong>Geolocation.</strong></p><p>用于获得用户的地理位置。</p><p>使用 getCurrentPosition() 方法来获得用户的位置。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (navigator.geolocation) &#123;</span><br><span class="line">  navigator.geolocation.getCurrentPosition(showPosition);</span><br><span class="line">&#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">  x.innerHTML=<span class="string">&quot;该浏览器不支持获取地理位置。&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showPosition</span>(<span class="params">position</span>) </span>&#123;</span><br><span class="line">  x.innerHTML=<span class="string">&quot;纬度: &quot;</span> + position.coords.latitude + </span><br><span class="line">  <span class="string">&quot;&lt;br&gt;经度: &quot;</span> + position.coords.longitude; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="162-css3的-nth-child和-nth-of-type的区别是什么？"><a href="#162-css3的-nth-child和-nth-of-type的区别是什么？" class="headerlink" title="162.css3的:nth-child和:nth-of-type的区别是什么？"></a>162.css3的:nth-child和:nth-of-type的区别是什么？</h3><p>:nth-child(n) 选择器匹配父元素中的第 n 个子元素，元素类型没有限制。</p><p>:nth-of-type(n)选择器匹配同类型中的第n个同级兄弟元素。</p><h3 id="163-写一个函数找出给定数组中的最大差值"><a href="#163-写一个函数找出给定数组中的最大差值" class="headerlink" title="163.写一个函数找出给定数组中的最大差值"></a>163.写一个函数找出给定数组中的最大差值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMaxDiff</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(...arr) - <span class="built_in">Math</span>.min(...arr)</span><br><span class="line">&#125;</span><br><span class="line">getMaxDiff([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h3 id="164-HTML5中新添加的表单属性有哪些？"><a href="#164-HTML5中新添加的表单属性有哪些？" class="headerlink" title="164.HTML5中新添加的表单属性有哪些？"></a>164.HTML5中新添加的表单属性有哪些？</h3><p><a href="https://www.php.cn/website-design-ask-489307.html%3E">查看HTML5中新添加的表单属性</a></p><h3 id="165-写出4个使用this的典型例子"><a href="#165-写出4个使用this的典型例子" class="headerlink" title="165.写出4个使用this的典型例子"></a>165.写出4个使用this的典型例子</h3><p>全局 this 是 window<br>函数 this 是调用者<br>构造函数的 this 是 new 之后的新对象<br>call ，apply ，bind 的 this 是第一个参数</p><h3 id="166-网站被劫持植入广告该怎么办？如何防止？"><a href="#166-网站被劫持植入广告该怎么办？如何防止？" class="headerlink" title="166.网站被劫持植入广告该怎么办？如何防止？"></a>166.网站被劫持植入广告该怎么办？如何防止？</h3><p>这是因为你的网页没有加密，一些运行商通过HTTP劫持来植入广告.HTTPS能够加密网页传输内容，不仅可以防止强插广告，还可以防盗号</p><h3 id="167-渐进式渲染是什么？"><a href="#167-渐进式渲染是什么？" class="headerlink" title="167.渐进式渲染是什么？"></a>167.渐进式渲染是什么？</h3><p>渐进式渲染是用于提高网页性能（尤其是提高用户感知的加载速度），以尽快呈现页面的技术</p><p>比如：<br>1.图片懒加载——页面上的图片不会一次性全部加载。当用户滚动页面到图片部分时，JavaScript 将加载并显示图像。<br>2.确定显示内容的优先级-为了尽快将页面呈现给用户，页面只包含基本的最少量的 CSS、脚本和内容，然后可以使用延迟加载脚本或监听DOMContentLoaded/load事件加载其他资源和内容。<br>3.异步加载 HTML 片段——当页面通过后台渲染时，把 HTML 拆分，通过异步请求，分块发送给浏览器。</p><h3 id="168-JSONP的原理是什么？解决什么问题？"><a href="#168-JSONP的原理是什么？解决什么问题？" class="headerlink" title="168.JSONP的原理是什么？解决什么问题？"></a>168.JSONP的原理是什么？解决什么问题？</h3><p>原理：</p><p>动态插入script标签，执行callback回调函数，将回调函数中的参数输出</p><p>解决：</p><p>解决跨越问题</p><p>JS 动态插入 script 并将 src 指向后端 API，后台返回 json 并使用协定的 callback 函数把 json 包起来。浏览器以 JS 内容解析执行返回的内容，回调函数得以被调用并传入了返回的 json 对象。</p><h3 id="169-说说你对域名收敛和域名发散的理解？分别在什么场景下使用？"><a href="#169-说说你对域名收敛和域名发散的理解？分别在什么场景下使用？" class="headerlink" title="169.说说你对域名收敛和域名发散的理解？分别在什么场景下使用？"></a>169.说说你对域名收敛和域名发散的理解？分别在什么场景下使用？</h3><p>域名发散：是将静态资源放在多个子域名下，就可以多线程下载，提高并行度，使客户端加载静态资源更加迅速。域名发散是pc端为了利用浏览器的多线程并行下载能力。</p><p>域名收敛：就是将静态资源放在一个域名下。减少DNS解析的开销。域名收敛多用与移动端，提高性能，因为dns解析是是从后向前迭代解析，如果域名过多性能会下降，增加DNS的解析开销。</p><h3 id="170-有使用过vue吗？说说你对vue的理解"><a href="#170-有使用过vue吗？说说你对vue的理解" class="headerlink" title="170.有使用过vue吗？说说你对vue的理解"></a>170.有使用过vue吗？说说你对vue的理解</h3><p>1.vue是渐变式框架，根据自己的需求添加功能<br>2.vue数据驱动采用mvvm模式，m是数据层，v是视图层，vm是调度者<br>3.组件化，复用性强<br>4.SPA单页面应用，只有一个页面，加载速率快<br>5.vue操作的是虚拟DOM，采用diff算法更新DOM，比传统的DOM操作更加的高效。</p><p>Model：模型层，负责处理业务逻辑以及和服务器端进行交互<br>View：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面<br>ViewModel：视图模型层，监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步 View 和 Model 的对象，连接 Model 和 View之间的桥梁，绑定数据到viewmodel层并自动更新渲染到页面上，视图变化通知到viewmodel层去更新数据</p><h3 id="171-什么是双向绑定？原理是什么？"><a href="#171-什么是双向绑定？原理是什么？" class="headerlink" title="171.什么是双向绑定？原理是什么？"></a>171.什么是双向绑定？原理是什么？</h3><p>vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p><h3 id="172-什么是虚拟DOM？"><a href="#172-什么是虚拟DOM？" class="headerlink" title="172.什么是虚拟DOM？"></a>172.什么是虚拟DOM？</h3><p>用js对象描述dom结构，虚拟dom属性和真实的dom属性一一对应。<br>diff是发生在虚拟dom上的，新的虚拟dom和旧的虚拟dom进行diff，算出最小量更新，最后反映在真实dom上</p><p>数据更新-&gt;虚拟dom计算变更-&gt;操作真实的dom-&gt;视图更新</p><p>虚拟DOM 表现为一个 Object对象。并且最少包含标签名 (tag)、属性 (attrs) 和子元素对象 (children) 三个属性</p><h3 id="173-vue组件之间的通信都有哪些？"><a href="#173-vue组件之间的通信都有哪些？" class="headerlink" title="173.vue组件之间的通信都有哪些？"></a>173.vue组件之间的通信都有哪些？</h3><ul><li>父子间通信： 父-&gt;子： props       子-&gt;父：$emit/$on<br>获取父子组件实例 ：$parent/$children ref获取实例的方式调用组件的属性或方法</li><li>兄弟组件通信： Event Bus/vuex</li><li>跨级组件通信：1.vuex 2.Event Bus 3.($attrs/$listeners) 4.(Provide/inject)</li></ul><p><strong>透传 attribute：</strong></p><p>vue2: 包含了父作用域中不作为 prop 被识别 (且获取) 的 attribute 绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=”$attrs” 传入内部组件——在创建高级别的组件时非常有用。</p><p>vue3:<br>“透传 attribute”指的是传递给一个组件，却没有被该组件声明为 props 或 emits 的 attribute 或者 v-on 事件监听器。最常见的例子就是 class、style 和 id。</p><p>当一个组件以单个元素为根作渲染时，透传的 attribute 会自动被添加到根元素上。如果一个子组件的根元素已经有了 class 或 style attribute，它会和从父组件上继承的值合并。<br>同样的规则也适用于 v-on 事件监听器，如子父自己都绑定事件，则两个监听器都会被触发。</p><p>禁用 Attributes 继承：在子组件设置inheritAttrs: false。<br>最常见的需要禁用 attribute 继承的场景就是 attribute 需要应用在根节点以外的其他元素上。通过设置 inheritAttrs 选项为 false，你可以完全控制透传进来的 attribute 被如何使用。</p><p>透传进来的 attribute 可以在模板的表达式中直接用 $attrs 访问到。</p><p>$attrs: 对象包含了除组件所声明的 props 和 emits 之外的所有其他 attribute，例如 class，style，v-on 监听器等等</p><p><strong><em>有几点需要注意：</em></strong></p><p>  和 props 有所不同，透传 attributes 在 JavaScript 中保留了它们原始的大小写，所以像 foo-bar 这样的一个 attribute 需要通过 $attrs[‘foo-bar’] 来访问。</p><p>  像 @click 这样的一个 v-on 事件监听器将在此对象下被暴露为一个函数 $attrs.onClick。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;btn-wrapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们想要所有像 class 和 v-on 监听器这样的透传 attribute 都应用在内部的 button 上而不是外层的 div 上。我们可以通过设定 inheritAttrs: false 和使用 v-bind=”$attrs” 来实现.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;btn-wrapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">v-bind</span>=<span class="string">&quot;$attrs&quot;</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>tips:没有参数的 v-bind 会将一个对象的所有属性都作为 attribute 应用到目标元素上.</p><p>和单根节点组件有所不同，有着多个根节点的组件没有自动 attribute 透传行为。如果 $attrs 没有被显式绑定，将会抛出一个运行时警告。<br>如果 $attrs 被显式绑定，则不会有警告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;header&gt;...&lt;&#x2F;header&gt;</span><br><span class="line">&lt;main v-bind&#x3D;&quot;$attrs&quot;&gt;...&lt;&#x2F;main&gt;</span><br><span class="line">&lt;footer&gt;...&lt;&#x2F;footer&gt;</span><br></pre></td></tr></table></figure><p>可以通过 $attrs 这个实例属性来访问组件的所有透传 attribute：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$attrs)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>$listeners:</strong></p><p>包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件——在创建更高层次的组件时非常有用.</p><p>vue3 可从透传$attrs获取事件监听器。</p><p><strong>Provide:</strong></p><p>provide和inject: 一个父组件相对于其所有的后代组件，会作为依赖提供者。任何后代的组件树，无论层级有多深，都可以注入由父组件提供给整条链路的依赖。</p><p>为组件后代提供数据，需要用到provide选项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  provide: &#123;</span><br><span class="line">    message: <span class="string">&#x27;hello!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们需要提供依赖当前组件实例的状态 (比如那些由 data() 定义的数据属性)，那么可以以函数形式使用 provide：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">&#x27;hello!&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">provide</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用函数的形式，可以访问到 `this`</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="built_in">this</span>.message</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>除了在一个组件中提供依赖，还可以在整个应用层面提供依赖：</em></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = createApp(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">app.provide(<span class="comment">/* 注入名 */</span> <span class="string">&#x27;message&#x27;</span>, <span class="comment">/* 值 */</span> <span class="string">&#x27;hello!&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在应用级别提供的数据在该应用内的所有组件中都可以注入。这在你编写插件时会特别有用，因为插件一般都不会使用组件形式来提供值。</p><p><strong>Inject(注入):</strong></p><p>要注入上层组件提供的数据，需使用 inject 选项来声明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  inject: [<span class="string">&#x27;message&#x27;</span>],</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.message) <span class="comment">// injected value</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入会在组件自身的状态之前被解析，因此你可以在 data() 中访问到注入的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  inject: [<span class="string">&#x27;message&#x27;</span>],</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 基于注入值的初始数据</span></span><br><span class="line">      fullMessage: <span class="built_in">this</span>.message</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为保证注入方和供给方之间的响应性链接，我们需要使用 computed() 函数提供一个计算属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">&#x27;hello!&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">provide</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 显式提供一个计算属性</span></span><br><span class="line">      message: computed(<span class="function">() =&gt;</span> <span class="built_in">this</span>.message)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="174-请描述下vue的生命周期是什么？"><a href="#174-请描述下vue的生命周期是什么？" class="headerlink" title="174.请描述下vue的生命周期是什么？"></a>174.请描述下vue的生命周期是什么？</h3><ul><li><p>beforeCreate：在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用，props,methods,data还不能访问</p></li><li><p>created：在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，property 和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el property 目前尚不可用。一般creadted钩子函数主要是用来初始化数据。</p></li><li><p>beforeMount：在挂载开始之前被调用：相关的 render 函数首次被调用。</p></li><li><p>mounted： 实例被挂载后调用，这时 el 被新创建的 vm.$el 替换了。如果根实例挂载到了一个文档内的元素上，当 mounted 被调用时 vm.$el 也在文档内。注意 mounted 不会保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 mounted 内部使用 vm.$nextTick。该钩子函数是在挂在完成以后也就是模板渲染完成以后才会被调用</p></li><li><p>beforeUpdate： 数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</p></li><li><p>updated:由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。</p></li><li><p>activated：被 keep-alive 缓存的组件激活时调用。</p></li><li><p>deactivated：被 keep-alive 缓存的组件停用时调用</p></li><li><p>beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用</p></li><li><p>destroyed： 实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁</p></li><li><p>errorCaptured：当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。</p></li></ul><h3 id="175-说下你对指令的理解？"><a href="#175-说下你对指令的理解？" class="headerlink" title="175.说下你对指令的理解？"></a>175.说下你对指令的理解？</h3><p>指令 (Directives) 是带有 v- 前缀的特殊 attribute。指令 attribute 的值预期是单个 JavaScript 表达式。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM.</p><p>指令：绑定元素，直接操作dom，可以简化dom操作</p><p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p><ul><li>bind： 只调用一次，指令第一次绑定到元素时调用。</li><li>inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</li><li>update：所在组件的 VNode 更新时调用，</li><li>componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</li><li>unbind：只调用一次，指令与元素解绑时调用。</li></ul><h3 id="176-v-show和v-if有什么区别？使用场景分别是什么？"><a href="#176-v-show和v-if有什么区别？使用场景分别是什么？" class="headerlink" title="176.v-show和v-if有什么区别？使用场景分别是什么？"></a>176.v-show和v-if有什么区别？使用场景分别是什么？</h3><p>v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。<br>v-show：带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS property display。display:none;不占据空间。<br>v-show 不支持 <code>&lt;template&gt;</code> 元素，也不支持 v-else。</p><p><strong>v-if vs v-show:</strong></p><p>v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。<br>v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p>相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p><p>一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</p><p>css：visibility: hidden; 不同于v-show看不见仍占据位置，发生重绘。<br>v-if和v-show都会造成回流，只要页面渲染发生变化都会导致生命周期钩子beforeUpdate和updated执行，也即v-show、v-if、visibility都会触发生命周期钩子。</p><h3 id="177-说说你对MVC、MVP、MVVM模式的理解"><a href="#177-说说你对MVC、MVP、MVVM模式的理解" class="headerlink" title="177.说说你对MVC、MVP、MVVM模式的理解"></a>177.说说你对MVC、MVP、MVVM模式的理解</h3><p>查看<a href="/ZJY.github.io/2021/04/07/MVC-MVP-MVVM%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8C%BA%E5%88%AB/" title="MVC&#x2F;MVP&#x2F;MVVM模式的概念和区别">MVC&#x2F;MVP&#x2F;MVVM模式的概念和区别</a></p><h3 id="178-inline、block、inline-block这三个属性值有什么区别？"><a href="#178-inline、block、inline-block这三个属性值有什么区别？" class="headerlink" title="178.inline、block、inline-block这三个属性值有什么区别？"></a>178.inline、block、inline-block这三个属性值有什么区别？</h3><p>CSS display 属性设置元素是否被视为块或者内联元素以及用于子元素的布局.</p><p>形式上，display 属性设置元素的内部和外部的显示类型.外部类型设置元素参与流式布局；内部类型设置子元素的布局。</p><p><strong><em>CSS 流式布局</em></strong></p><p>“文档流”或”流式布局”是在对布局进行任何更改之前，在页面上显示”块”和”内联”元素的方式。这个”流”本质上是一系列的事物，它们都在你的布局中一起工作，并且互相了解。一旦某部分脱离了”流”，它就会独立地工作。</p><p>在文档流中，内联元素按内联方向显示，即词语在依据文件写作模式的句子中表示的方向。块元素则一个接一个地显示，就像该文档的写作模式中的段落一样。因此在英语中，内联元素从左边开始一个接一个地显示，块元素从顶部开始向下显示并移动页面。</p><p>block</p><p>该元素生成一个块级元素盒，在正常的流中，该元素之前和之后产生换行。</p><p>inline</p><p>该元素生成一个或多个内联元素盒，它们之前或者之后并不会产生换行。在正常的流中，如果有空间，下一个元素将会在同一行上。</p><p>inline-block</p><p>该元素生成块级元素盒，如果它是一个单独的内联盒，它将盒周围的内容一起流动（行为类似于替换元素）。</p><p>它等同于 inline flow-root</p><p>flow-root: 该元素生成一个块级元素盒，其会建立一个新的块级格式化上下文，定义格式化上下文的根元素。</p><ul><li><p>行内元素（display: inline）:</p><ul><li>设置宽高无效，宽度和高度由内容决定</li><li>设置margin左右有效，上下无效，padding都有效</li><li>不会自动换行</li><li>有span,img,input,a,b,sub,sup,i</li></ul></li><li><p>块级元素(display:block):</p><ul><li>可以设置宽高</li><li>margin和padding都有效</li><li>自动换行</li><li>多个块元素写一起，排列从上到下</li><li>由div,p,nav,h,footer,main,header等</li></ul></li><li><p>行内块元素（display:inline-block）</p><ul><li>能够设置宽高</li><li>margin/padding都有效</li><li>不会自动换行</li><li>默认排列方式从左到右</li></ul></li></ul><h3 id="179-写一个方法，使得sum-x-y-和sum-x-y-返回的结果相同"><a href="#179-写一个方法，使得sum-x-y-和sum-x-y-返回的结果相同" class="headerlink" title="179.写一个方法，使得sum(x)(y)和sum(x,y)返回的结果相同"></a>179.写一个方法，使得sum(x)(y)和sum(x,y)返回的结果相同</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数柯理化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum1</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">arguments</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = []</span><br><span class="line">    arr.push(...args, ...arguments)</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">total, item</span>) =&gt;</span> total += item, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum1(<span class="number">6</span>, <span class="number">9</span>, <span class="number">14</span>)) <span class="comment">//29</span></span><br><span class="line"><span class="built_in">console</span>.log(sum2(<span class="number">6</span>)(<span class="number">9</span>, <span class="number">14</span>)) <span class="comment">//29</span></span><br></pre></td></tr></table></figure><h3 id="180-说你对浏览器的关键渲染路径（CRP）的理解"><a href="#180-说你对浏览器的关键渲染路径（CRP）的理解" class="headerlink" title="180.说你对浏览器的关键渲染路径（CRP）的理解"></a>180.说你对浏览器的关键渲染路径（CRP）的理解</h3><p>关键渲染路径是浏览器把html、css、js转换为屏幕上的像素所经历的步骤序列，优化关键渲染路径可提高渲染性能。关键渲染路径包含了文档对象模型DOM、css对象模型CSSOM、渲染树和布局</p><p>web性能包含了服务器请求和响应、加载、执行脚本、渲染、布局和绘制每个像素到屏幕上。</p><p>CRP：</p><p>网页请求从 HTML 文件请求开始。</p><p>服务器返回 HTML – 响应头和数据。</p><p>然后浏览器开始解析 HTML，转换收到的数据为 DOM 树。</p><p>浏览器每次发现外部资源就初始化请求，无论是样式、脚本或者嵌入的图片引用。</p><p>有时请求会阻塞，这意味着解析剩下的 HTML 会被终止直到重要的资源被处理。</p><p>浏览器接着解析 HTML，发请求和构造 DOM 直到文件结尾，这时开始构造 CSS 对象模型。</p><p>等到 DOM 和 CSSOM 完成之后，浏览器构造渲染树，计算所有可见内容的样式。</p><p>一旦渲染树完成布局开始，定义所有渲染树元素的位置和大小。</p><p>完成之后，页面被渲染完成，或者说是绘制到屏幕上。</p><p><strong><em>文档对象模型DOM：</em></strong></p><p>DOM 构建是增量的。HTML 响应变成令牌（token），令牌变成节点，而节点又变成 DOM 树。节点数量越多，关键渲染路径中的后续事件将花费的时间就越长</p><p><strong><em>CSS 对象模型：</em></strong></p><p>DOM 包含页面所有的内容。CSSOM 包含了页面所有的样式，也就是如何展示 DOM 的信息。<br>DOM 构造是增量的，CSSOM 却不是。CSS 是渲染阻塞的：浏览器会阻塞页面渲染直到它接收和执行了所有的 CSS。CSS 是渲染阻塞是因为规则可以被覆盖，所以内容不能被渲染直到 CSSOM 的完成。</p><p>从选择器性能的角度，更少的特定选择器是比更多的要快。</p><p><strong><em>渲染树：</em></strong></p><p>渲染树包括了内容和样式：DOM 和 CSSOM 树结合为渲染树。为了构造渲染树，浏览器检查每个节点，从 DOM 树的根节点开始，并且决定哪些 CSS 规则被添加。</p><p>渲染树只包含了可见内容。头部（通常）不包含任何可见信息，因此不会被包含在渲染树种。如果有元素上有 display: none;，它本身和其后代都不会出现在渲染树中。</p><p><strong><em>布局：</em></strong></p><p>一旦渲染树被构建，布局变成了可能。布局取决于屏幕的尺寸。布局这个步骤决定了在哪里和如何在页面上放置元素，决定了每个元素的宽和高，以及他们之间的相关性。</p><p>布局性能受 DOM 影响 – 节点数越多，布局就需要更长的时间。</p><p>为了减小布局事件的频率和时长，批量更新或者避免改动盒模型属性。</p><p><strong><em>绘制：</em></strong></p><p>最后一步是将像素绘制在屏幕上。一旦渲染树创建并且布局完成，像素就可以被绘制在屏幕上。加载时，整个屏幕被绘制出来。之后，只有受影响的屏幕区域会被重绘，浏览器被优化为只重绘需要绘制的最小区域。</p><p><strong><em>优化CRP：</em></strong></p><p>提升页面加载速度需要通过被加载资源的优先级、控制它们加载的顺序和减小这些资源的体积。</p><p>性能提升包含：</p><ol><li>通过异步、延迟加载或者消除非关键资源来减少关键资源的请求数量</li><li>优化必须的请求数量和每个请求的文件体积</li><li>通过区分关键资源的优先级来优化被加载关键资源的顺序，来缩短关键路径长度。</li></ol><h3 id="181-box-sizing常用的属性有哪些？分别有什么作用？"><a href="#181-box-sizing常用的属性有哪些？分别有什么作用？" class="headerlink" title="181.box-sizing常用的属性有哪些？分别有什么作用？"></a>181.box-sizing常用的属性有哪些？分别有什么作用？</h3><p>CSS 中的 box-sizing 属性定义了 user agent 应该如何计算一个元素的总宽度和总高度。</p><p>box-sizing属性值：</p><p>content-box:</p><p>  默认值，标准盒子模型。width和height只包含内容的宽和高，不包含边框、内边距、外边距。<br>  尺寸计算公式：<br>    width = 内容的宽度<br>    height = 内容的高度</p><p>border-box:</p><p>  width和height包含内容、边框、内边距，但不包含外边距。文档处于Quirks模式时ie使用的盒模型。<br>  尺寸计算公式：<br>    width = border + padding + 内容的宽度<br>    height = border + padding + 内容的高度</p><h3 id="182-请说下你对-proto-和prototype的理解"><a href="#182-请说下你对-proto-和prototype的理解" class="headerlink" title="182.请说下你对__proto__和prototype的理解"></a>182.请说下你对__proto__和prototype的理解</h3><p><strong>prototype属性：</strong></p><p>原型属性，是函数独有的，每个函数都有一个prototype属性，是一个指针，指向一个对象即原型对象，这个对象包含了所有实例共享的属性和方法。</p><p><strong><code>__proto__</code>:</strong></p><p>实例对象都有的属性，它指向该实例对象所对应的原型对象。</p><p>prototype和__proto__都指向原型对象，任意一个函数包括构造函数都有一个prototype属性，指向该函数的原型对象；<br>任何一个构造函数的实例化对象，都有一个__proto__对象，它指向构造函数的原型对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Student()</span><br><span class="line"></span><br><span class="line">s.__proto__ === Student.prototype <span class="comment">// true</span></span><br><span class="line">Student.prototype.constructor === Student <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>两者区别：</p><ul><li>1.prototype是函数独有的，而__proto__是每一个对象都有的包括函数。</li><li>2.prototype的作用是保存所有实例共享的属性和方法；__proto__的作用当访问一个对象的属性或方法时，如果内部没有该属性或方法，就去__proto__属性所指的原型对象去找，如果没有就去原型对象的原型去找，直到null，即原型链。</li><li><ol start="3"><li><code>s.__proto__ === Student.prototype</code>; prototype还有一个constructor属性，指向该对象的构造函数本身。</li></ol></li></ul><h3 id="183-写一个格式化金额的方法"><a href="#183-写一个格式化金额的方法" class="headerlink" title="183.写一个格式化金额的方法"></a>183.写一个格式化金额的方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// * @param &#123;*&#125; num 要格式化的数字</span></span><br><span class="line"><span class="comment">// * @param &#123;*&#125; decimals 保留几位小数</span></span><br><span class="line"><span class="comment">// * @param &#123;*&#125; thousandsSep 千分位符号</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">numberFormat</span>(<span class="params">num, decimals, thousandsSep</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isNaN</span>(num)) &#123;</span><br><span class="line">        num = <span class="string">&#x27;0.00&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> prec = !<span class="built_in">isFinite</span>(+decimals) ? <span class="number">0</span>: <span class="built_in">Math</span>.abs(decimals)</span><br><span class="line">    <span class="keyword">let</span> sep = !thousandsSep ? <span class="string">&#x27;,&#x27;</span> : thousandsSep</span><br><span class="line">    <span class="keyword">let</span> s = num.toString().replace(<span class="regexp">/,/g</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> p = <span class="built_in">parseFloat</span>(s)</span><br><span class="line">    <span class="keyword">let</span> n = <span class="built_in">isNaN</span>(p) ? <span class="number">1</span> : p</span><br><span class="line">    <span class="keyword">let</span> formatNum = n.toFixed(prec).toString().replace(<span class="regexp">/(\d)(?=(\d&#123;3&#125;)+\.)/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$<span class="number">0</span>,$<span class="number">1</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> $<span class="number">1</span> + <span class="string">&#x27;,&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> num ? formatNum : <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">numberFormat(<span class="string">&#x27;1234567.123&#x27;</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// &#x27;1,234,567.12&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="184-src、href、link的区别是什么？"><a href="#184-src、href、link的区别是什么？" class="headerlink" title="184.src、href、link的区别是什么？"></a>184.src、href、link的区别是什么？</h3><p>href：Hypertext Reference的缩写，超文本引用，它指向一些网络资源，建立和当前元素或者说是本文档的链接关系。在加载它的时候，不会停止对当前文档的处理，浏览器会继续往下走。常用在a、link等标签。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;index.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>src：source的缩写，表示的是对资源的引用，它指向的内容会嵌入到当前标签所在的位置.由于src的内容是页面必不可少的一部分，因此浏览器在解析src时会停下对后续文档的处理，直到src的内容加载完毕.</p><p>href用于建立当前页面与引用资源之间的关系（链接），而src则会替换当前标签。<br>遇到href，页面会并行加载后续内容；而src则不同，浏览器需要加载完毕src的内容才会继续往下走。</p><h3 id="185-请实现一个flattenDeep函数，把多维数组扁平化"><a href="#185-请实现一个flattenDeep函数，把多维数组扁平化" class="headerlink" title="185.请实现一个flattenDeep函数，把多维数组扁平化"></a>185.请实现一个flattenDeep函数，把多维数组扁平化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatArr</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> result = []</span><br><span class="line"> <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) <span class="keyword">return</span> result</span><br><span class="line"> arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(item)) &#123;</span><br><span class="line">    result.push(...flatArr(item))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result.push(item)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;)</span><br><span class="line"> <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">flatArr([<span class="number">1</span>,<span class="number">2</span>,[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,[<span class="number">1</span>,<span class="number">2</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]]]) <span class="comment">// [1, 2, 1, 2, 1, 1, 2, 1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,[<span class="number">1</span>,<span class="number">2</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]]].flat(<span class="literal">Infinity</span>) <span class="comment">// [1, 2, 1, 2, 1, 1, 2, 1, 2, 3]</span></span><br></pre></td></tr></table></figure><h3 id="186-写一个方法获取图片的原始宽高"><a href="#186-写一个方法获取图片的原始宽高" class="headerlink" title="186.写一个方法获取图片的原始宽高"></a>186.写一个方法获取图片的原始宽高</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getImageSize</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">        img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve(&#123;</span><br><span class="line">                width: img.width,</span><br><span class="line">                height: img.height</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        img.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">          reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">        img.src = url</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">getImageSize(<span class="string">&#x27;https://img1.baidu.com/it/u=3155988012,1977937542&amp;fm=253&amp;app=138&amp;size=w931&amp;n=0&amp;f=JPG&amp;fmt=auto?sec=1671123600&amp;t=cc0cc30d2d7bca64d5bff71d1b7bd1e7&#x27;</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res) <span class="comment">// &#123; width: 600, height: 343 &#125;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;myImg&#x27;</span>).naturalWidth <span class="comment">// 600</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;myImg&#x27;</span>).naturalHeght <span class="comment">// 343</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImageAsync</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">        image.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> obj = &#123;</span><br><span class="line">                width: image.naturalWidth,</span><br><span class="line">                height: image.naturalHeight</span><br><span class="line">            &#125;</span><br><span class="line">            resolve(obj);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        image.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Could not load image at &#x27;</span> + url));</span><br><span class="line">        &#125;;</span><br><span class="line">        image.src = url;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="187-知道IPV6是什么吗？说说它和IPV4的区别是什么？"><a href="#187-知道IPV6是什么吗？说说它和IPV4的区别是什么？" class="headerlink" title="187.知道IPV6是什么吗？说说它和IPV4的区别是什么？"></a>187.知道IPV6是什么吗？说说它和IPV4的区别是什么？</h3><p>IPv6 是当前版本的互联网（Internet）通信协议（protocol）。IPv6 正在慢慢地取代 IPv4 (en-US)，因为 IPv6 允许使用更多不同的 IP 地址。</p><p>ipv4提供的2的32次方的地址根本不够无数的家用设备使用。而2的128次方的地址可为飞速增加的物联网设备提供足够的地址。</p><h3 id="188-怎么使css样式只在当前组件中生效？"><a href="#188-怎么使css样式只在当前组件中生效？" class="headerlink" title="188.怎么使css样式只在当前组件中生效？"></a>188.怎么使css样式只在当前组件中生效？</h3><p>1.style scoped<br>2.css module</p><p>  在webpack中，作为处理css的css-loader，它实现了css module的思想，要启用css module，需要将css-loader的配置modules设置为true。</p><p>  原理极其简单，开启了css module后，css-loader会将样式中的类名进行转换，转换为一个唯一的hash值。</p><p>  由于hash值是根据模块路径和类名生成的，因此，不同的css模块，哪怕具有相同的类名，转换后的hash值也不一样</p><h3 id="189-keep-alive"><a href="#189-keep-alive" class="headerlink" title="189.keep-alive"></a>189.keep-alive</h3><p><code>&lt;KeepAlive&gt;</code> 是一个内置组件，它的功能是在多个组件间动态切换时缓存被移除的组件实例.<br><code>&lt;KeepAlive&gt;</code> 包裹动态组件时，会缓存不活跃的组件实例，而不是销毁它们。</p><p>任何时候都只能有一个活跃组件实例作为 <code>&lt;KeepAlive&gt;</code> 的直接子节点。</p><p>当一个组件在 <code>&lt;KeepAlive&gt;</code> 中被切换时，它的 activated 和 deactivated 生命周期钩子将被调用，用来替代 mounted 和 unmounted。这适用于 <code>&lt;KeepAlive&gt;</code> 的直接子节点及其所有子孙节点。</p><h3 id="190-v-for循环中key有什么作用？"><a href="#190-v-for循环中key有什么作用？" class="headerlink" title="190.v-for循环中key有什么作用？"></a>190.v-for循环中key有什么作用？</h3><p>key 这个特殊的 attribute 主要作为 Vue 的虚拟 DOM 算法提示，在比较新旧节点列表时用于识别 vnode。</p><h3 id="191-vue如何监听键盘事件？"><a href="#191-vue如何监听键盘事件？" class="headerlink" title="191.vue如何监听键盘事件？"></a>191.vue如何监听键盘事件？</h3><p>1.keyup</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&quot;myInput&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hello world&quot;</span> <span class="attr">autofocus</span> @<span class="attr">keyup.enter</span>=<span class="string">&quot;handleKey&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">handleKey</span>(<span class="params">e</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(e)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.addEventListener</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      document.addEventListener(&#39;keyup&#39;, this.handleKey)</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeDestroy() &#123;</span><br><span class="line">      document.removeEventListener(&#39;keyup&#39;, this.handleKey)</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleKey(e) &#123;</span><br><span class="line">        console.log(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="192-watch和computed有什么区别？"><a href="#192-watch和computed有什么区别？" class="headerlink" title="192.watch和computed有什么区别？"></a>192.watch和computed有什么区别？</h3><p><strong>watch:</strong></p><ol><li>watch 是观察的作用，类似于某些数据的监听回调</li><li>无缓存性，页面重新渲染时，即使值没有改变也执行</li><li>能调用异步函数。</li></ol><p><strong>computed：</strong></p><ol><li>计算属性，用于计算值等场景</li><li>computed的值具有缓存性，computed的值在getter执行后是会缓存的，只有它依赖的属性值改变后，下一次获取computed的值才会重新调用getter来计算。</li><li>computed适用于计算比较消耗性能的计算场景</li><li>不能调用异步函数。</li></ol><h3 id="193-watch监听"><a href="#193-watch监听" class="headerlink" title="193.watch监听"></a>193.watch监听</h3><p>1.深度监听对象,deep: true<br>2.监听开始后立即被调用，immediate: true</p><h3 id="194-为什么data属性必须声明为返回一个初始数据对应的函数呢？"><a href="#194-为什么data属性必须声明为返回一个初始数据对应的函数呢？" class="headerlink" title="194.为什么data属性必须声明为返回一个初始数据对应的函数呢？"></a>194.为什么data属性必须声明为返回一个初始数据对应的函数呢？</h3><p>对象为引用类型，当重用组件时，由于数据对象都指向同一个data对象，当在一个组件中修改data时，其他重用的组件中的data会同时被修改；而使用返回对象的函数，由于每次返回的都是一个新对象（Object的实例），引用地址不同，则不会出现这个问题.</p><h3 id="195-nextTick有什么作用？"><a href="#195-nextTick有什么作用？" class="headerlink" title="195.$nextTick有什么作用？"></a>195.$nextTick有什么作用？</h3><p>vue响应式的改变一个值以后，此时的dom并不会立即更新，如果需要在数据改变以后立即通过dom做一些操作，可以使用$nextTick获得更新后的dom。</p><h3 id="196-分别说说vue能监听到数组或对象变化的场景，还有哪些场景是监听不到的？无法监听时有什么解决方案？"><a href="#196-分别说说vue能监听到数组或对象变化的场景，还有哪些场景是监听不到的？无法监听时有什么解决方案？" class="headerlink" title="196.分别说说vue能监听到数组或对象变化的场景，还有哪些场景是监听不到的？无法监听时有什么解决方案？"></a>196.分别说说vue能监听到数组或对象变化的场景，还有哪些场景是监听不到的？无法监听时有什么解决方案？</h3><p>vue如何追踪变化：</p><p>当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。在 property 被访问和修改时通知变更。</p><p>每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。</p><p>由于 JavaScript 的限制,Vue 不能检测数组和对象的变化</p><p><strong><em>对于对象：</em></strong></p><p>vue无法检测property的添加或移除。<br>由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以property 必须在 data 对象上存在才能让 Vue 将它转换为响应式的</p><p>对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式 property</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.set(vm.someObj, <span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 您还可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名：</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.$set(vm.someObj, <span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有时你可能需要为已有对象赋值多个新 property，比如使用 Object.assign() 或 _.extend()。但是，这样添加到对象上的新 property 不会触发更新。在这种情况下，你应该用原对象与要混合进去的对象的 property 一起创建一个新的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 代替 `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`</span></span><br><span class="line"><span class="built_in">this</span>.someObject = <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="built_in">this</span>.someObject, &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;)</span><br></pre></td></tr></table></figure><p><strong><em>对于数组：</em></strong></p><p>Vue 不能检测以下数组的变动：</p><ul><li>1.当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue</li><li>2.当你修改数组的长度时，例如：vm.items.length = newLength</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.items[<span class="number">1</span>] = <span class="string">&#x27;x&#x27;</span> <span class="comment">// 不是响应性的</span></span><br><span class="line">vm.items.length = <span class="number">2</span> <span class="comment">// 不是响应性的</span></span><br></pre></td></tr></table></figure><p>解决第一类问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line">Vue.set(vm.items, indexOfItem, newValue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="comment">// Array.prototype.splice</span></span><br><span class="line">vm.items.splice(indexOfItem, <span class="number">1</span>, newValue)</span><br></pre></td></tr></table></figure><p>为了解决第二类问题，你可以使用 splice：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure><h3 id="197-v-if和v-for的优先级是什么？如果这两个同时出现时，那应该怎么优化才能得到更好的性能？"><a href="#197-v-if和v-for的优先级是什么？如果这两个同时出现时，那应该怎么优化才能得到更好的性能？" class="headerlink" title="197.v-if和v-for的优先级是什么？如果这两个同时出现时，那应该怎么优化才能得到更好的性能？"></a>197.v-if和v-for的优先级是什么？如果这两个同时出现时，那应该怎么优化才能得到更好的性能？</h3><p>v-if和v-for同时使用，v-for的优先级高。</p><p>一般我们在两种常见的情况下会倾向于这样做：</p><ul><li><p>为了过滤一个列表中的项目 (比如 v-for=”user in users” v-if=”user.isActive”)。在这种情形下，请将 users 替换为一个计算属性 (比如 activeUsers)，让其返回过滤后的列表。</p></li><li><p>为了避免渲染本应该被隐藏的列表 (比如 v-for=”user in users” v-if=”shouldShowUsers”)。这种情形下，请将 v-if 移动至容器元素上 (比如 ul、ol)。</p></li></ul><h3 id="198-vue实例挂载的过程是什么？"><a href="#198-vue实例挂载的过程是什么？" class="headerlink" title="198.vue实例挂载的过程是什么？"></a>198.vue实例挂载的过程是什么？</h3><p>1、实例化阶段</p><p>new Vue(el)创建实例化对象，初始化实例的配置，如el, data, methods等</p><p>2、初始化阶段</p><p>初始化实例的数据响应式系统，按照props、methods、data顺序来初始化相关数据，包括对data中的属性进行依赖收集并进行劫持，数据发生变化时可以自动更新视图。</p><p>3、模板编译阶段</p><p>如果vue实例选项中有render函数直接渲染dom，如果没有，但是实例中配置了template则对其进行预编译成render函数，如果没有template则将el所在的dom内容作为模版进行编译</p><p>将template解析成ast tree抽象语法树<br>将ast tree转换成render语法字符串<br>生成render函数</p><p>4、挂载阶段</p><p>调用render函数生成vnode树，再调用patch生成真实dom，最后将实例挂载到el所在dom元素上，并开始渲染视图。</p><p>注意：挂载方法是调用vm.$mount，调用 $mount 方法后，Vue 会通过模板编译器把模板转换成渲染函数</p><h3 id="199-说说你对选项el-template-render的理解"><a href="#199-说说你对选项el-template-render的理解" class="headerlink" title="199.说说你对选项el,template,render的理解"></a>199.说说你对选项el,template,render的理解</h3><p><strong>el:</strong></p><p>提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。</p><p>注意：</p><ul><li>如果 render 函数和 template property 都不存在，挂载 DOM 元素的 HTML 会被提取出来用作模板，此时，必须使用 Runtime + Compiler 构建的 Vue 库。</li></ul><p><strong>template：</strong></p><p>一个字符串模板作为 Vue 实例的标识使用。模板将会替换挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发插槽。</p><p>注意：</p><ul><li>如果 Vue 选项中包含渲染函数，该模板将被忽略。</li></ul><p><strong>render:</strong></p><p>字符串模板的代替方案，允许你发挥 JavaScript 最大的编程能力。该渲染函数接收一个 createElement 方法作为第一个参数用来创建 VNode.</p><p>注意：</p><ul><li>Vue 选项中的 render 函数若存在，则 Vue 构造函数不会从 template 选项或通过 el 选项指定的挂载元素中提取出的 HTML 模板编译渲染函数。</li></ul><p>el，template，render属性优先性：</p><p>当Vue选项对象中有render渲染函数时，Vue构造函数将直接使用渲染函数渲染DOM树，当选项对象中没有render渲染函数时，Vue构造函数首先通过将template模板编译生成渲染函数，然后再渲染DOM树，而当Vue选项对象中既没有render渲染函数，也没有template模板时，会通过el属性获取挂载元素的outerHTML来作为模板，并编译生成渲染函数。<br>换言之，在进行DOM树的渲染时，render渲染函数的优先级最高，template次之且需编译成渲染函数，而挂载点el属性对应的元素若存在，则在前两者均不存在时，其outerHTML才会用于编译与渲染。</p><p>对不同构建版本的解释：<br>完整版：同时包含编译器和运行时的版本。<br>编译器：用来将模板字符串编译成为 JavaScript 渲染函数的代码。<br>用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。</p><h3 id="200-说说你对同构和SSR的理解"><a href="#200-说说你对同构和SSR的理解" class="headerlink" title="200.说说你对同构和SSR的理解"></a>200.说说你对同构和SSR的理解</h3><p>Isomorphism, 同构，指一套代码既可以在server端工作，也可以在web 客户端运行，可以无缝在server端和client端渲染两种模式间切换。这个概念由airbnb的Rendr发扬光大。<br>所以一楼说的其实指的并不是同构JS，而是Universal Javascript.</p><p>在PWA 大行其道的环境下，因为爬虫需要和框架初始化容易白屏等等问题，服务端渲染的呼声又物论沸腾。SSR其实就是在server端把需要的页面和数据组装起来发给客户端而已。</p><p>SSR的好处</p><ul><li>SEO友好</li><li>首页加载更快</li><li>减少请求</li></ul><h3 id="201-什么是html的字符实体？版权符号代码怎么写？"><a href="#201-什么是html的字符实体？版权符号代码怎么写？" class="headerlink" title="201.什么是html的字符实体？版权符号代码怎么写？"></a>201.什么是html的字符实体？版权符号代码怎么写？</h3><p>HTML 中的预留字符必须被替换为字符实体。</p><p>一些在键盘上找不到的字符也可以使用字符实体来替换。</p><p>在 HTML 中，某些字符是预留的。</p><p>在 HTML 中不能使用小于号（&lt;）和大于号（&gt;），这是因为浏览器会误认为它们是标签。</p><p>如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体。</p><table><thead><tr><th align="center">显示结果</th><th align="center">描述</th><th align="center">实体名称</th><th align="center">实体编号</th></tr></thead><tbody><tr><td align="center">空格</td><td align="center"><code>&amp;nbsp;</code></td><td align="center"><code>&amp;nbsp;</code></td><td align="center"><code>&amp;#160;</code></td></tr><tr><td align="center">&lt;</td><td align="center">小于号</td><td align="center"><code>&amp;lt;</code></td><td align="center"><code>&amp;#60;</code></td></tr><tr><td align="center">&gt;</td><td align="center">大于号</td><td align="center"><code>&amp;gt;</code></td><td align="center"><code>&amp;#62;</code></td></tr><tr><td align="center">&amp;</td><td align="center">和号</td><td align="center"><code>&amp;amp;</code></td><td align="center"><code>&amp;#38;</code></td></tr><tr><td align="center">“</td><td align="center">引号</td><td align="center"><code>&amp;quot;</code></td><td align="center"><code>&amp;#34;</code></td></tr><tr><td align="center">‘</td><td align="center">撇号</td><td align="center"><code>&amp;apos;</code></td><td align="center">(IE不支持) <code>&amp;#39;</code></td></tr><tr><td align="center">￠</td><td align="center">分</td><td align="center"><code>&amp;cent;</code></td><td align="center"><code>&amp;#162;</code></td></tr><tr><td align="center">£</td><td align="center">镑</td><td align="center"><code>&amp;pound;</code></td><td align="center"><code>&amp;#163;</code></td></tr><tr><td align="center">¥</td><td align="center">人民币/日元</td><td align="center"><code>&amp;yen;</code></td><td align="center"><code>&amp;#165;</code></td></tr><tr><td align="center">€</td><td align="center">欧元</td><td align="center"><code>&amp;euro;</code></td><td align="center"><code>&amp;#8364;</code></td></tr><tr><td align="center">§</td><td align="center">小节</td><td align="center"><code>&amp;sect;</code></td><td align="center"><code>&amp;#167;</code></td></tr><tr><td align="center">©</td><td align="center">版权</td><td align="center"><code>&amp;copy;</code></td><td align="center"><code>&amp;#169;</code></td></tr><tr><td align="center">®</td><td align="center">注册商标</td><td align="center"><code>&amp;reg;</code></td><td align="center"><code>&amp;#174;</code></td></tr><tr><td align="center">™</td><td align="center">商标</td><td align="center"><code>&amp;trade;</code></td><td align="center"><code>&amp;#8482;</code></td></tr><tr><td align="center">×</td><td align="center">乘号</td><td align="center"><code>&amp;times;</code></td><td align="center"><code>&amp;#215;</code></td></tr><tr><td align="center">÷</td><td align="center">除号</td><td align="center"><code>&amp;divide;</code></td><td align="center"><code>&amp;#247;</code></td></tr></tbody></table><h3 id="202-说说position的absolute和fixed共同与不同点分别是什么？"><a href="#202-说说position的absolute和fixed共同与不同点分别是什么？" class="headerlink" title="202.说说position的absolute和fixed共同与不同点分别是什么？"></a>202.说说position的absolute和fixed共同与不同点分别是什么？</h3><p>absolute<br>元素会被移出正常文档流，并不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。</p><p>fixed<br>元素会被移出正常文档流，并不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 transform, perspective 或 filter 属性非 none 时，容器由视口改为该祖先。</p><h3 id="203-举例子说明javascript的变量声明提升和函数声明提升"><a href="#203-举例子说明javascript的变量声明提升和函数声明提升" class="headerlink" title="203.举例子说明javascript的变量声明提升和函数声明提升"></a>203.举例子说明javascript的变量声明提升和函数声明提升</h3><p><strong>变量声明:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">// undefinde</span></span><br><span class="line"><span class="keyword">var</span> a= <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//  &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure><p><strong>函数声明:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello world&#x27;</span>);<span class="comment">// &quot;hello world&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>变量声明只提升声明 不提升赋值操作，函数声明 函数体整体被提升。</em></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getName();</span><br><span class="line"><span class="keyword">var</span>  getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;大明&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">getName();</span><br></pre></td></tr></table></figure><p>提升之后变成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getName;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;大明&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">getName();<span class="comment">//”大明“</span></span><br><span class="line">getName= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">getName();<span class="comment">//&quot;小明&quot;</span></span><br></pre></td></tr></table></figure><h3 id="204-组件与插件的区别"><a href="#204-组件与插件的区别" class="headerlink" title="204.组件与插件的区别"></a>204.组件与插件的区别</h3><p>Vue组件（component）用来构成你的App的业务模块，它的目标是App.vue。<br>Vue插件(plugin) 用来增强你的技术栈的功能模块， 它的目标是Vue本身。（插件是对Vue的功能的增强和补充）</p><h3 id="205-动态给vue的data添加一个新的属性时会发生什么？怎样解决？"><a href="#205-动态给vue的data添加一个新的属性时会发生什么？怎样解决？" class="headerlink" title="205.动态给vue的data添加一个新的属性时会发生什么？怎样解决？"></a>205.动态给vue的data添加一个新的属性时会发生什么？怎样解决？</h3><p>如果在实例创建之后添加新的属性到实例上，它不会触发视图更新。<br>Vue 无法检测 property 的添加或移除。由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 data 对象上存在才能让 Vue 将它转换为响应式的.</p><p>对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式 property.</p><h3 id="206-删除数组用delete和Vue-delete有什么区别？"><a href="#206-删除数组用delete和Vue-delete有什么区别？" class="headerlink" title="206.删除数组用delete和Vue.delete有什么区别？"></a>206.删除数组用delete和Vue.delete有什么区别？</h3><p>delete：只是被删除数组成员变为 empty / undefined，其他元素键值不变,不能触发视图更新<br>Vue.delete：直接删了数组成员，并改变了数组的键值（如果对象是响应式的，确保删除能触发更新视图，这个方法主要用于避开 Vue 不能检测到属性被删除的限制）</p><h3 id="207-说说你对vue的mixin的理解，有什么应用场景？"><a href="#207-说说你对vue的mixin的理解，有什么应用场景？" class="headerlink" title="207.说说你对vue的mixin的理解，有什么应用场景？"></a>207.说说你对vue的mixin的理解，有什么应用场景？</h3><p>混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。</p><p>选项合并：</p><ul><li>数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先。</li><li>同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。</li><li>值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。</li></ul><h3 id="208-v-model是什么？有什么用呢？"><a href="#208-v-model是什么？有什么用呢？" class="headerlink" title="208.v-model是什么？有什么用呢？"></a>208.v-model是什么？有什么用呢？</h3><p>在表单输入元素或组件上创建双向绑定。</p><p>限制：</p><ul><li><code>&lt;input&gt;</code></li><li><code>&lt;select&gt;</code></li><li><code>&lt;textarea&gt;</code></li><li>components</li></ul><p>修饰符：</p><ul><li>lazy - 取代 input 监听 change 事件</li><li>number - 输入字符串转为有效的数字</li><li>trim - 输入首尾空格过滤</li></ul><p>v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据.v-model 会忽略所有表单元素的 value、checked、selected attribute 的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值。</p><p>v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：</p><ul><li>text 和 textarea 元素使用 value property 和 input 事件；</li><li>checkbox 和 radio 使用 checked property 和 change 事件；</li><li>select 字段将 value 作为 prop 并将 change 作为事件。</li></ul><h3 id="209-vue常用的修饰符有哪些？列举并说明"><a href="#209-vue常用的修饰符有哪些？列举并说明" class="headerlink" title="209.vue常用的修饰符有哪些？列举并说明"></a>209.vue常用的修饰符有哪些？列举并说明</h3><p>.stop - 调用 event.stopPropagation()。<br>.prevent - 调用 event.preventDefault()。<br>.capture - 添加事件侦听器时使用 capture 模式。<br>.self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。<br>.{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。<br>.native - 监听组件根元素的原生事件。<br>.once - 只触发一次回调。<br>.left - (2.2.0) 只当点击鼠标左键时触发。<br>.right - (2.2.0) 只当点击鼠标右键时触发。<br>.middle - (2.2.0) 只当点击鼠标中键时触发。<br>.passive - (2.3.0) 以 { passive: true } 模式添加侦听器<br>.lazy - 取代 input 监听 change 事件<br>.number - 输入字符串转为有效的数字<br>.trim - 输入首尾空格过滤</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.once</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 键修饰符，键别名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.enter</span>=<span class="string">&quot;onEnter&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 键修饰符，键代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.13</span>=<span class="string">&quot;onEnter&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 而不会等待 `onScroll` 完成  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">&quot;onScroll&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 对象语法 (2.4.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on</span>=<span class="string">&quot;&#123; mousedown: doThis, mouseup: doThat &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="210-v-on可以绑定多个方法吗？"><a href="#210-v-on可以绑定多个方法吗？" class="headerlink" title="210.v-on可以绑定多个方法吗？"></a>210.v-on可以绑定多个方法吗？</h3><p>可以</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-on=<span class="string">&quot;&#123; mousedown: doThis, mouseup: doThat &#125;&quot;</span>&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure><h3 id="211-说说你对vue的template编译的理解？"><a href="#211-说说你对vue的template编译的理解？" class="headerlink" title="211.说说你对vue的template编译的理解？"></a>211.说说你对vue的template编译的理解？</h3><p><img src="/ZJY.github.io/images/templateCompile.jpg" alt="image"></p><p>将模版编译成渲染函数可以分为两个步骤，先将模版解析成AST抽象语法树，再使用AST生成渲染函数。<br>但是由于静态节点不需要总是重新渲染，所以在生成AST之后，生成渲染函数之前这个阶段，需要做一个操作，那就是遍历AST，给所有静态节点做一个标记，这样在虚拟DOM更新节点时，如果发现节点有这个标记，就不会重新渲染它。</p><p>模版编译分为三个部分内容：</p><ul><li>将模版解析为AST</li><li>遍历AST标记静态节点</li><li>使用AST生成渲染函数</li></ul><p>这三部分内容在模版编译中分别抽象出三个模块来实现各自的功能，分别是：</p><ul><li>解析器（将模版解析为AST）</li><li>优化器（遍历AST标记静态节点）</li><li>代码生成器（使用AST生成渲染函数）</li></ul><p><img src="/ZJY.github.io/images/template.jpg" alt="image"></p><h3 id="212-写出html提供的几种空格实体（5种以上）"><a href="#212-写出html提供的几种空格实体（5种以上）" class="headerlink" title="212.写出html提供的几种空格实体（5种以上）"></a>212.写出html提供的几种空格实体（5种以上）</h3><p><code>&amp;nbsp;</code></p><p>它叫不换行空格，全称No-Break Space，它是最常见和我们使用最多的空格，大多数的人可能只接触了 ，它是按下space键产生的空格。在HTML中，如果你用空格键产生此空格，空格是不会累加的（只算1个）。要使用html实体表示才可累加，该空格占据宽度受字体影响明显而强烈。</p><p><code>&amp;ensp;</code></p><p>它叫“半角空格”，全称是En Space，en是字体排印学的计量单位，为em宽度的一半。根据定义，它等同于字体度的一半（如16px字体中就是8px）。名义上是小写字母n的宽度。此空格传承空格家族一贯的特性：透明的，此空格有个相当稳健的特性，就是其占据的宽度正好是1/2个中文宽度，而且基本上不受字体影响。</p><p><code>&amp;emsp;</code></p><p>它叫“全角空格”，全称是Em Space，em是字体排印学的计量单位，相当于当前指定的点数。例如，1 em在16px的字体中就是16px。此空格也传承空格家族一贯的特性：透明的，此空格也有个相当稳健的特性，就是其占据的宽度正好是1个中文宽度，而且基本上不受字体影响。</p><p><code>&amp;thinsp;</code></p><p>它叫窄空格，全称是Thin Space。我们不妨称之为“瘦弱空格”，就是该空格长得比较瘦弱，身体单薄，占据的宽度比较小。它是em之六分之一宽。</p><p><code>&amp;zwnj;</code></p><p>它叫零宽不连字，全称是Zero Width Non Joiner，简称“ZWNJ”，是一个不打印字符，放在电子文本的两个字符之间，抑制本来会发生的连字，而是以这两个字符原本的字形来绘制。Unicode中的零宽不连字字符映射为“”（zero width non-joiner，U+200C），HTML字符值引用为： &#8204;</p><p><code>&amp;zwj;</code></p><p>它叫零宽连字，全称是Zero Width Joiner，简称“ZWJ”，是一个不打印字符，放在某些需要复杂排版语言（如阿拉伯语、印地语）的两个字符之间，使得这两个本不会发生连字的字符产生了连字效果。零宽连字符的Unicode码位是U+200D (HTML: &#8205; &zwj;）。</p><p>此外，浏览器还会把以下字符当作空白进行解析：空格（&#x0020;）、制表位（&#x0009;）、换行（&#x000A;）和回车（&#x000D;）还有（&#12288;）等等。</p><h3 id="213-举例说明css中颜色的表示方法有几种"><a href="#213-举例说明css中颜色的表示方法有几种" class="headerlink" title="213.举例说明css中颜色的表示方法有几种"></a>213.举例说明css中颜色的表示方法有几种</h3><ul><li>颜色单词: blue / lightblue / skyblue / transparent(透明)</li><li>rgb(0-255, 0-255, 0-255) / rgba(0-255, 0-255, 0-255, 0-1)</li><li>hsl色相: hsl(色调，饱和度，明度) hsla( 色调，饱和度，亮度，不透明度 ) (兼容性)</li><li>十六进制: #000000- #FFFFFF ( #000 - #fff ) ( 0-9 a-f | [A-F] )</li></ul><h3 id="214-如何让-a-1-amp-amp-a-2-amp-amp-a-3-的值为true，把”-”换成”-”后还能为true吗？"><a href="#214-如何让-a-1-amp-amp-a-2-amp-amp-a-3-的值为true，把”-”换成”-”后还能为true吗？" class="headerlink" title="214.如何让(a==1 &amp;&amp; a==2 &amp;&amp; a==3)的值为true，把”==”换成”===”后还能为true吗？"></a>214.如何让(a==1 &amp;&amp; a==2 &amp;&amp; a==3)的值为true，把”==”换成”===”后还能为true吗？</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">(a === <span class="number">1</span> &amp;&amp; a === <span class="number">2</span> &amp;&amp; a === <span class="number">3</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>=== 严格相等，会比较两个值的类型和值<br>== 抽象相等，比较时，会先进行类型转换，然后再比较值</p><p>“==” 转化规则：<br>首先通过valueOf 转换，即 obj.valueOf()方法的返回值<br>如果 obj.valueOf()方法的返回值是原始类型，那么直接返回<br>如果不是，再通过 obj.toString()方法转换<br>如果obj.toString()返回的是原始类型，直接返回该值<br>如果还不是原始类型，抛出不能转换异常。</p><h3 id="215"><a href="#215" class="headerlink" title="215"></a>215</h3><h3 id="216"><a href="#216" class="headerlink" title="216"></a>216</h3><h3 id="217"><a href="#217" class="headerlink" title="217"></a>217</h3><h3 id="218"><a href="#218" class="headerlink" title="218"></a>218</h3><h3 id="219"><a href="#219" class="headerlink" title="219"></a>219</h3><h3 id="220"><a href="#220" class="headerlink" title="220"></a>220</h3><h3 id="221"><a href="#221" class="headerlink" title="221"></a>221</h3><h3 id="222"><a href="#222" class="headerlink" title="222"></a>222</h3><h3 id="223"><a href="#223" class="headerlink" title="223"></a>223</h3><h3 id="224"><a href="#224" class="headerlink" title="224"></a>224</h3><h3 id="225"><a href="#225" class="headerlink" title="225"></a>225</h3><h3 id="226"><a href="#226" class="headerlink" title="226"></a>226</h3><h3 id="227"><a href="#227" class="headerlink" title="227"></a>227</h3><h3 id="228"><a href="#228" class="headerlink" title="228"></a>228</h3><h3 id="229"><a href="#229" class="headerlink" title="229"></a>229</h3><h3 id="230"><a href="#230" class="headerlink" title="230"></a>230</h3><h3 id="231"><a href="#231" class="headerlink" title="231"></a>231</h3><h3 id="232"><a href="#232" class="headerlink" title="232"></a>232</h3>]]></content>
      
      
      <categories>
          
          <category> 问题&amp;总结 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记nuxt服务端请求接口无法通过store获取token</title>
      <link href="/ZJY.github.io/2021/12/31/%E8%AE%B0nuxt%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%B7%E6%B1%82%E6%8E%A5%E5%8F%A3%E6%97%A0%E6%B3%95%E9%80%9A%E8%BF%87store%E8%8E%B7%E5%8F%96token/"/>
      <url>/ZJY.github.io/2021/12/31/%E8%AE%B0nuxt%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%B7%E6%B1%82%E6%8E%A5%E5%8F%A3%E6%97%A0%E6%B3%95%E9%80%9A%E8%BF%87store%E8%8E%B7%E5%8F%96token/</url>
      
        <content type="html"><![CDATA[<p>1.问题</p><p>使用nuxt框架,接口在fetch或者asyncData中调用时,导致无法获取登录凭证token</p><p>2.原因</p><p>页面正常跳转进入或第一次加载时,asyncData和fetch方法都是在客户端执行,页面手动刷新时asyncData和fetch是在服务端执行,因此获取不到存储在客户端数据</p><p>3.解决</p><p>在store状态树中指定nuxtServerInit 方法, Nuxt.js 调用它的时候会将页面的上下文对象作为第2个参数传给它（服务端调用时才会）.可以将数据存储在服务端在nuxtServerInit中将数据传到客户端.</p><p>假设登录后将登录凭证token存在cookie中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">login(params).then(res &#x3D;&gt; &#123;</span><br><span class="line">  this.$store.commit(&#39;setToken&#39;, token)</span><br><span class="line">  this.$cookies.set(&#39;token&#39;, token)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在store中actions中添加nuxtServerInit</span><br><span class="line">nuxtServerInit(&#123; commit &#125;, &#123; app, req, store &#125;) &#123;</span><br><span class="line">  console.log(</span><br><span class="line">    &#39;打印nuxtServerInit3&#39;,</span><br><span class="line">    req.headers.cookie,</span><br><span class="line">    app.$cookies.getAll()</span><br><span class="line">  )</span><br><span class="line">  store.commit(&#39;setToken&#39;, app.$cookies.get(&#39;token&#39;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在axios请求拦截中设置authroization</span><br><span class="line">$axios.onRequest((config) &#x3D;&gt; &#123;</span><br><span class="line">  config.headers[&#39;authroization&#39;] &#x3D; store.state.token</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>4.nuxt 使用cookie持久化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.安装</span></span><br><span class="line">yarn add cookie-universal-nuxt</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.config.nuxt.js</span></span><br><span class="line">modules: [</span><br><span class="line">  <span class="string">&#x27;cookie-universal-nuxt&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 问题&amp;总结 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令</title>
      <link href="/ZJY.github.io/2021/12/17/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/ZJY.github.io/2021/12/17/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>1.克隆项目 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone url</span><br></pre></td></tr></table></figure><p>2.创建分支</p><p>创建dev分支对应远程dev分支,并切换到dev分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev origin&#x2F;dev</span><br></pre></td></tr></table></figure><p>创建本地分支并切换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b dev</span><br></pre></td></tr></table></figure><p>提交本地分支到远程仓库,创建远程分支dev</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin dev</span><br></pre></td></tr></table></figure><p>3.切换分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev</span><br></pre></td></tr></table></figure><p>4.提交代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;暂存代码</span><br><span class="line">git add .</span><br><span class="line">&#x2F;&#x2F;提交暂存代码到本地仓库</span><br><span class="line">git commit -m &quot;commit info&quot;</span><br><span class="line">&#x2F;&#x2F;将本地仓库代码推送到远程仓库</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>5.删除分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 首先要切换到别的分支</span><br><span class="line">git branch -d dev</span><br><span class="line">git branch -D dev &#x2F;&#x2F; 强制删除</span><br><span class="line">git push origin --delete dev &#x2F;&#x2F; 删除远程分支</span><br></pre></td></tr></table></figure><p>6.打标签</p><p>列出标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure><p>创建轻量标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0</span><br></pre></td></tr></table></figure><p>后期打标签,可以对过去的提交打标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 先查看提交历史</span><br><span class="line">git log --pretty</span><br><span class="line"></span><br><span class="line">7d58683af833a44637800f89f2ee5fbacec436d8 (HEAD -&gt; develop, origin&#x2F;develop) 🐞 fix(input): 修复input-confirm-type:search时出现搜索图标</span><br><span class="line">aa3b910be51a9e682e5646f108f340d1248d6233 (tag: v1.0.0, origin&#x2F;build, build) 🐞 fix(招标公告详情): 公告进度样式处理16f0d68366724fcbc7b9121522d71724bdc70251 ✨ feat(注册): 1.新增注册功能 2.我的名称兼容</span><br><span class="line">648e1ef9701ec3bd8f48ec9f9dd9c97468dba3cc ✨ feat(app): 1.去掉耳机页面下拉刷新 2.去掉调试工具</span><br><span class="line">c2a3a051ef35e3babe39ef5127db78d337cc4f4e ✨ feat(设置): 去掉手机号</span><br><span class="line">7acae11b4aab2276efcec9ca54a4e7b100e8cd37 🐞 fix(tabbar页面): 1.修复tabbar页面接口执行2次</span><br><span class="line">b9975fca9ee199dd59b48457d37fd782e9be7721 🐞 fix(工作台): 招标列表详情取招标名称</span><br><span class="line">e3686c0c9892d205a44e1e9379ea546d50f38cb6 🐞 fix(时间格式化): 修复时间戳转换</span><br><span class="line">da2e37df1aabf25af302160db7596b55370bc58f 🐞 fix(资质认证): 认证状态处理</span><br><span class="line">281b56bc78d79782fcd1eb42ae98721cea2ac49c ✨ feat(tabar页面): 添加下拉刷新功能</span><br></pre></td></tr></table></figure><p>给最新一次提交打上v1.2标签,也就是7d58683af833a44637800f89f2ee5fbacec436d8,需要再命令的末尾指定提交的校验和(或部分校验和):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.2 7d58683af833</span><br></pre></td></tr></table></figure><p>可以看到打上标签了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br><span class="line">v1.1</span><br><span class="line">v1.2</span><br></pre></td></tr></table></figure><p>默认情况下,git push不会传送标签到远程仓库,创建完标签后必须显示推送到服务器上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin v1.2</span><br></pre></td></tr></table></figure><p>如果想要一次性推送很多标签，也可以使用带有 –tags 选项的 git push 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure><p>7.删除标签</p><p>删除本地仓库的标签,用git tag -d <tagname></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d v1.2</span><br></pre></td></tr></table></figure><p>上述命令不会从远程仓库删除这个标签,需用git push <remote> :refs/tags/<tagname>来更新远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :refs&#x2F;tags&#x2F;v1.2</span><br></pre></td></tr></table></figure><p>或者用以下命令删除远程标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete &lt;tagname&gt;</span><br></pre></td></tr></table></figure><p>8.回退已经提交(git push)到远程仓库的代码</p><p>git log找到commit id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br><span class="line">commit 7d58683af833a44637800f89f2ee5fbacec436d8 (HEAD -&gt; develop, origin&#x2F;develop)</span><br><span class="line">Author: zhaojunyan &lt;zhao.junyan@hxss.com.cn&gt;</span><br><span class="line">Date:   Fri Dec 3 09:40:22 2021 +0800</span><br><span class="line">...</span><br><span class="line">commit aa3b910be51a9e682e5646f108f340d1248d6233 (tag: v1.0.0, origin&#x2F;build, build)</span><br><span class="line">Author: zhaojunyan &lt;zhao.junyan@hxss.com.cn&gt;</span><br><span class="line">Date:   Wed Dec 1 15:35:20 2021 +0800</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>将代码回退到aa3b910be51a9e682e5646f108f340d1248d6233</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard aa3b910be51a9e682e5646f108f340d1248d6233 &#x2F;&#x2F; 回退本地提交</span><br><span class="line">git push --force &#x2F;&#x2F; 本地修改强制推送到远程仓库</span><br></pre></td></tr></table></figure><p>9.撤销git commit</p><p>1.git reset –soft 版本号<commit></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD^  &#x2F;&#x2F;回到上一个版本</span><br></pre></td></tr></table></figure><p>不删除工作区改动的代码，撤销commit，不撤销git add .</p><p>2.git reset –mixed 版本号 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --mixed HEAD^  &#x2F;&#x2F;回到上一个版本</span><br></pre></td></tr></table></figure><p>不删除工作区改动的代码，撤销commit，撤销git add .</p><p>3.git reset –hard 版本号 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^  &#x2F;&#x2F;回到上一个版本</span><br></pre></td></tr></table></figure><p>删除工作区的代码，撤销commit，撤销git add . 回到上一次commit的状态</p><p>10.仓库b 分支a同步 仓库a 分支a 的代码</p><p>1.仓库b添加仓库a连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add 仓库a的项目名 仓库a的git地址</span><br></pre></td></tr></table></figure><p>2.仓库b 拉取仓库a分支a 的最新代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull 仓库a的项目名 branch-a</span><br></pre></td></tr></table></figure><p>3.仓库b根据仓库a的分支a创建分支a</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b branch-a 仓库a的项目名&#x2F;branch-a</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add storeA storeA.git</span><br><span class="line">git pull storeA branch-a</span><br><span class="line">git checkout -b branch-a storeA&#x2F;branch-a</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记git have diverged</title>
      <link href="/ZJY.github.io/2021/12/17/%E8%AE%B0git-have-diverged/"/>
      <url>/ZJY.github.io/2021/12/17/%E8%AE%B0git-have-diverged/</url>
      
        <content type="html"><![CDATA[<h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h3><p>git出现Your branch and ‘origin/branch’ have diverged</p><p>如果不需要保留本地的修改:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin</span><br><span class="line">git reset --hard origin&#x2F;branch</span><br></pre></td></tr></table></figure><p>如果需要保留本地的修改:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git rebase origin&#x2F;branch</span><br><span class="line">git pull --rebase</span><br><span class="line">解决冲突</span><br><span class="line">git rebase --continue</span><br><span class="line">git push origin branch</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 问题&amp;总结 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记Clipboard.js触发多次复制成功问题</title>
      <link href="/ZJY.github.io/2021/12/17/%E8%AE%B0Clipboard.js%E8%A7%A6%E5%8F%91%E5%A4%9A%E6%AC%A1%E5%A4%8D%E5%88%B6%E6%88%90%E5%8A%9F%E9%97%AE%E9%A2%98/"/>
      <url>/ZJY.github.io/2021/12/17/%E8%AE%B0Clipboard.js%E8%A7%A6%E5%8F%91%E5%A4%9A%E6%AC%A1%E5%A4%8D%E5%88%B6%E6%88%90%E5%8A%9F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h3><p>复制文字到剪切板,触发多次成功事件,导致多次提示复制成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const that &#x3D; this</span><br><span class="line">clipboard &#x3D; new Clipboard(&#39;#copyBtn&#39;)</span><br><span class="line">clipboard.on(&#39;success&#39;, function(e) &#123;</span><br><span class="line">  console.log(&#39;success&#39;, e.text)</span><br><span class="line">  that.$message.success(&#39;复制成功&#39;)</span><br><span class="line">  e.clearSelection()</span><br><span class="line">&#125;)</span><br><span class="line">clipboard.on(&#39;error&#39;, function(e) &#123;</span><br><span class="line">  that.$message.error(&#39;复制失败&#39;)</span><br><span class="line">  e.clearSelection()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-原因"><a href="#2-原因" class="headerlink" title="2.原因"></a>2.原因</h3><p>因项目是单页应用,没有及时清理事件及创建的对象.</p><h3 id="3-解决"><a href="#3-解决" class="headerlink" title="3.解决"></a>3.解决</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">beforeDestroy() &#123;</span><br><span class="line">  console.log(&#39;打印&#39;, &#39;destory&#39;)</span><br><span class="line">  clipboard.destroy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-clipboard简单使用"><a href="#4-clipboard简单使用" class="headerlink" title="4.clipboard简单使用"></a>4.clipboard简单使用</h3><p><a href="https://www.kancloud.cn/luponu/clipboardjs_zh/988266">clipboard.js中文文档</a></p>]]></content>
      
      
      <categories>
          
          <category> 问题&amp;总结 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记element table组件固定高度滑动底部数据渲染问题</title>
      <link href="/ZJY.github.io/2021/12/17/%E8%AE%B0element-table%E7%BB%84%E4%BB%B6%E5%9B%BA%E5%AE%9A%E9%AB%98%E5%BA%A6%E6%BB%91%E5%8A%A8%E5%BA%95%E9%83%A8%E6%95%B0%E6%8D%AE%E6%B8%B2%E6%9F%93%E9%97%AE%E9%A2%98/"/>
      <url>/ZJY.github.io/2021/12/17/%E8%AE%B0element-table%E7%BB%84%E4%BB%B6%E5%9B%BA%E5%AE%9A%E9%AB%98%E5%BA%A6%E6%BB%91%E5%8A%A8%E5%BA%95%E9%83%A8%E6%95%B0%E6%8D%AE%E6%B8%B2%E6%9F%93%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h3><p>element中table组件,设置固定高度height后,数据渲染超出设置高度后,鼠标向下滑动,此时包裹table元素<code>&lt;div class=&quot;el-table__body-wrapper is-scrolling-left/right/middle/none&quot;&gt;</code>scrollTop值为滚动距离,若此时切换到第二页,数据渲染未超出设置height,再切换到第一页,数据渲染超出设置高度后,此时table应有滚动条,但是table组件只渲染部分数据,没有出现滚动条,固定高度区域仍有空白.</p><h3 id="2-原因"><a href="#2-原因" class="headerlink" title="2.原因"></a>2.原因</h3><p>该元素<code>&lt;div class=&quot;el-table__body-wrapper is-scrolling-left/right/middle/none&quot;&gt;</code>scrollTop值仍为上一次滚动距离,没有重新归0,导致table只渲染部分数据,表格固定高度区域有空白,需要鼠标向下滚动才会重新渲染剩余数据</p><h3 id="3-解决"><a href="#3-解决" class="headerlink" title="3.解决"></a>3.解决</h3><p>每次数据改变时,判断该元素<code>&lt;div class=&quot;el-table__body-wrapper is-scrolling-left/right/middle/none&quot;&gt;</code>scrollTop值不为0时,强制归0.</p><p>给<code>&lt;el-table ref=&quot;baseTable&quot; /&gt;</code>组件设置ref属性值<br>打印$refs.baseTable组件,其$refs下有bodyWrapper组件,处理该组件scrollTop值即可<br>this.$refs.baseTable.$refs.bodyWrapper.scrollTop = 0</p>]]></content>
      
      
      <categories>
          
          <category> 问题&amp;总结 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nodejs 基础</title>
      <link href="/ZJY.github.io/2021/11/09/Nodejs-%E5%9F%BA%E7%A1%80/"/>
      <url>/ZJY.github.io/2021/11/09/Nodejs-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM操作性能提升</title>
      <link href="/ZJY.github.io/2021/06/09/DOM%E6%93%8D%E4%BD%9C%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/"/>
      <url>/ZJY.github.io/2021/06/09/DOM%E6%93%8D%E4%BD%9C%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/</url>
      
        <content type="html"><![CDATA[<p>在浏览器中DOM和Javascript通常是独立实现的，因此通过Javascript操作DOM会产生很大的性能消耗，因此需要尽可能地减少DOM操作</p><p>主要有以下几种方式：</p><h3 id="1-使用innerHTML代替DOM方法"><a href="#1-使用innerHTML代替DOM方法" class="headerlink" title="1.使用innerHTML代替DOM方法"></a>1.使用innerHTML代替DOM方法</h3><p>将多次DOM操作转换为字符串拼接，并一次性插入页面</p><h3 id="2-节点克隆"><a href="#2-节点克隆" class="headerlink" title="2.节点克隆"></a>2.节点克隆</h3><p>对于一些相同的节点，使用节点克隆(element.cloneNode)而不是节点创建(element.createElement)来创建</p><h3 id="3-尽可能少地使用HTML集合"><a href="#3-尽可能少地使用HTML集合" class="headerlink" title="3.尽可能少地使用HTML集合"></a>3.尽可能少地使用HTML集合</h3><p>以下方法返回的就是一个集合：</p><ul><li>document.getElementsByName()</li><li>document.getElementsByClassName()</li><li>document.getElementsByTagName()</li><li>document.images</li><li>document.links</li><li>document.forms</li><li>document.forms[0].elements</li></ul><p>HTML集以一种”假定实时态”实时存在，当底层文档对象更新时，它也会自动更新</p><p>一种可行的方法是将集的属性存入缓存变量中，或者将HTML集拷贝到普通数组</p><h3 id="4-减少渲染树的排队和刷新"><a href="#4-减少渲染树的排队和刷新" class="headerlink" title="4.减少渲染树的排队和刷新"></a>4.减少渲染树的排队和刷新</h3><p>获取页面布局信息的操作会导致队列刷新，如以下方法：</p><ul><li>offsetTop，offsetLeft，offsetWidth，offsetHeight</li><li>scrollTop，scrollLeft，scrollWith，scrollHeight</li><li>clientTop，clientLeft，clientWidth，clientHeight</li><li>getComputedStyle()</li></ul><p>尽量避免使用以上的方法</p><p>即使需要获取布局信息，也要将它保存在局部变量中，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 低效的</span></span><br><span class="line">element.style.left = <span class="number">1</span> + element.offsetLeft + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">element.style.top = <span class="number">1</span> + element.offsetTop + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (element.offsetLeft &gt;= <span class="number">500</span>) &#123;</span><br><span class="line">  <span class="comment">// dosomething();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高效的</span></span><br><span class="line"><span class="keyword">let</span> currentLeft = element.offsetLeft,</span><br><span class="line">    currentTop = element.offsetTop;</span><br><span class="line">currentLeft ++;</span><br><span class="line">currentTop ++;</span><br><span class="line">element.style.left = current + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">element.style.top = current + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (currentLeft &gt;= <span class="number">500</span>) &#123;</span><br><span class="line">  <span class="comment">// dosomething();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-批量修改dom"><a href="#5-批量修改dom" class="headerlink" title="5.批量修改dom"></a>5.批量修改dom</h3><p>提升方式：</p><ul><li>使元素脱离文档流</li><li>对其应用多重改变</li><li>把元素带回文档中</li></ul><p>使DOM脱离文档的方式：</p><ul><li>隐藏元素，应用修改，重新显示</li><li>使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档</li><li>将原始元素拷贝到一个脱离文档的节点中，修改副本，完成后再替换元素</li></ul><p>推荐尽可能地使用第二种方式，因为所产生的DOM遍历和重排次数最少</p><h3 id="6-事件委托"><a href="#6-事件委托" class="headerlink" title="6.事件委托"></a>6.事件委托</h3><p>当页面中有大量元素需要绑定事件处理器，尽可能使用事件委托。它基于这样一个事实：事件逐层冒泡并能被父级元素捕获。使用事件代理，只需给外层元素绑定一个处理器，就可以处理在其子元素上触发的所有事件。</p><p>每个事件经历的阶段：</p><p>1.捕获阶段：事件从window对象自上而下向目标节点传播的阶段<br>2.目标阶段：真正的目标节点正在处理事件的阶段<br>3.冒泡阶段：事件从目标节点自下而上向window对象传播的阶段</p><p>事件委托又叫事件代理。基于冒泡，将事件监听器添加到父元素上，而不是每个子元素上。</p><p>事件委托的优点：</p><ul><li>节省内存占用，减少事件注册</li><li>新增子对象时无需再次对其绑定事件</li></ul><h3 id="7-使用CSS3动画代替JS动画"><a href="#7-使用CSS3动画代替JS动画" class="headerlink" title="7.使用CSS3动画代替JS动画"></a>7.使用CSS3动画代替JS动画</h3><p>CSS3动画的性能优于JS动画</p><h3 id="8-使用hashchange事件代替轮询"><a href="#8-使用hashchange事件代替轮询" class="headerlink" title="8.使用hashchange事件代替轮询"></a>8.使用hashchange事件代替轮询</h3><p>使用hashchange事件代替轮询，可以避免页面跳转，提高用户体验</p><h3 id="9-使用requestAnimationFrame"><a href="#9-使用requestAnimationFrame" class="headerlink" title="9.使用requestAnimationFrame"></a>9.使用requestAnimationFrame</h3><p>requestAnimationFrame是浏览器提供的一个API，可以让开发者以一种更有效率的方式来执行动画。它会在浏览器下一次重绘之前，请求浏览器调用指定的函数更新动画。</p><p>使用requestAnimationFrame的优点：</p><ul><li>节省CPU资源</li><li>动画效果更加平滑</li><li>兼容性好</li></ul><p>使用requestAnimationFrame的缺点：</p><ul><li>兼容性不好</li><li>无法直接控制动画的暂停和恢复</li></ul>]]></content>
      
      
      <categories>
          
          <category> 问题&amp;总结 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>监听页面关闭</title>
      <link href="/ZJY.github.io/2021/06/09/%E7%9B%91%E5%90%AC%E9%A1%B5%E9%9D%A2%E5%85%B3%E9%97%AD/"/>
      <url>/ZJY.github.io/2021/06/09/%E7%9B%91%E5%90%AC%E9%A1%B5%E9%9D%A2%E5%85%B3%E9%97%AD/</url>
      
        <content type="html"><![CDATA[<h3 id="1-beforeunload"><a href="#1-beforeunload" class="headerlink" title="1.beforeunload"></a>1.beforeunload</h3><p>当浏览器窗口刷新或关闭时，会触发beforeunload事件。当前页面可见，不会直接关闭，可以点击确定按钮关闭或刷新页面，也可以取消刷新和关闭。</p><p>事件使网页能够触发一个确认对话框，询问用户是否真的要离开该页面。如果用户确认，浏览器将导航到新页面，否则导航将会取消。</p><p>根据规范，要显示确认对话框，事件处理程序需要在事件上调用preventDefault()。</p><p>HTML规范指出应该使用 Event.preventDefault() 而非 Event.returnValue，然而，不是所有浏览器都支持这么做。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;beforeunload&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Cancel the event as stated by the standard.</span></span><br><span class="line">  event.preventDefault();</span><br><span class="line">  <span class="comment">// Chrome requires returnValue to be set.</span></span><br><span class="line">  event.returnValue = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-unload事件"><a href="#2-unload事件" class="headerlink" title="2.unload事件"></a>2.unload事件</h3><p>当文档或一个子资源正在被卸载时, 触发 unload事件</p><p>它在下面两个事件后被触发:<br>1.beforeunload (可取消默认行为的事件)<br>2.pagehide</p><p>文档处于以下状态：</p><ul><li>所有资源仍存在（图片，iframe等）</li><li>对于用户所有资源均不可见</li><li>界面交互无效（window.open,alert,confirm等）</li><li>错误不会停止卸载文档的过程</li></ul><h3 id="3-上报请求"><a href="#3-上报请求" class="headerlink" title="3.上报请求"></a>3.上报请求</h3><p>如果我们在监听事件中发送ajax来上报数据，请求会被浏览器abort。因为在页面卸载的时候，浏览器并不能保证异步的请求能够成功<br>对于这个行为，我们可以使用下面的方式：<br>1.发送同步ajax</p><p>此种方式用户需要等待请求结束才可以关闭页面，会影响用户体验</p><p>2.发送异步ajax，但在服务端忽略ajax的abort</p><p>此种方式需要后台进行改造，成本太大</p><p>3.使用navigator.sendBeacon发送异步请求</p><p>使用：navigator.sendBeason(url [,data]);<br>其中data可以是 ArrayBufferView、Blob、DOMString、FormData等类型</p>]]></content>
      
      
      <categories>
          
          <category> 问题&amp;总结 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DomContentLoaded事件解析</title>
      <link href="/ZJY.github.io/2021/06/09/DomContentLoaded%E4%BA%8B%E4%BB%B6%E8%A7%A3%E6%9E%90/"/>
      <url>/ZJY.github.io/2021/06/09/DomContentLoaded%E4%BA%8B%E4%BB%B6%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="1-DOMContentLoaded事件"><a href="#1-DOMContentLoaded事件" class="headerlink" title="1.DOMContentLoaded事件"></a>1.DOMContentLoaded事件</h3><p>当初始的HTML文档被完全加载和解析完成之后，DOMContentLoaded事件被触发，而无需等待样式表、图像和子框架的完全加载。</p><h3 id="2-load事件"><a href="#2-load事件" class="headerlink" title="2.load事件"></a>2.load事件</h3><p>当整个页面及所有依赖资源如样式表和图片都已完成加载时，将触发load事件</p><p><strong>DOMContentLoaded事件和load事件区别：</strong><br>DOMContentLoaded在HTML文档被解析完成之后触发，而load是在HTML所有相关资源被加载完成后触发</p><h3 id="3-HTML解析过程与DOMContentLoaded触发时机"><a href="#3-HTML解析过程与DOMContentLoaded触发时机" class="headerlink" title="3.HTML解析过程与DOMContentLoaded触发时机"></a>3.HTML解析过程与DOMContentLoaded触发时机</h3><h4 id="1-在既没有css也没有js情况下，HTML文档的解析过程为："><a href="#1-在既没有css也没有js情况下，HTML文档的解析过程为：" class="headerlink" title="1.在既没有css也没有js情况下，HTML文档的解析过程为："></a>1.在既没有css也没有js情况下，HTML文档的解析过程为：</h4><p><img src="/ZJY.github.io/images/domcontentload/domcontentload1.jpg" alt="image"></p><p>DOMContentLoaded事件的触发时机为:HTML解析为DOM之后</p><h4 id="2-有css无js情况下，HTML文档的解析过程为："><a href="#2-有css无js情况下，HTML文档的解析过程为：" class="headerlink" title="2.有css无js情况下，HTML文档的解析过程为："></a>2.有css无js情况下，HTML文档的解析过程为：</h4><p><img src="/ZJY.github.io/images/domcontentload/domcontent2.jpg" alt="image"></p><p>渲染树的生成是基于DOM和CSSOM的。但是触发DOMContentLoaded的时间依然是在HTML解析为DOM后，无论此时CSS解析为CSSOM的过程是否完成</p><h4 id="3-当有js和css时，HTML文档的解析过程为："><a href="#3-当有js和css时，HTML文档的解析过程为：" class="headerlink" title="3.当有js和css时，HTML文档的解析过程为："></a>3.当有js和css时，HTML文档的解析过程为：</h4><p><img src="/ZJY.github.io/images/domcontentload/domcontent3.jpg" alt="image"></p><p>网页从空白到出现内容所花费的时间，就是html文档加载和解析的时间，也就是DOMContentLoaded事件触发之前所经历的时间。<br>所以对于首屏时间而言，js放在html文档的开头和结尾效果是一样的。而js放在结尾的目的并不是为了减少首屏时间，而是由于js经常需要操作dom，放在后面才更能保证找到dom节点。</p><h4 id="4-同步-异步脚本"><a href="#4-同步-异步脚本" class="headerlink" title="4.同步/异步脚本"></a>4.同步/异步脚本</h4><p>同步脚本：<br>html文档解析时如果遇见同步脚本，则停止解析，先加载脚本再执行，执行结束后继续解析HTML文档。HTML文档解析完毕后触发DOMContentLoaded事件</p><p>异步脚本：</p><ul><li>defer</li></ul><p>当 HTML 文档被解析时如果遇见 defer 脚本，则在后台加载脚本，文档解析过程不中断，而等文档解析结束之后，defer 脚本执行。另外，defer 脚本的执行顺序与定义时的位置有关。在前面的script会先执行</p><ul><li>async</li></ul><p>当 HTML 文档被解析时如果遇见 async 脚本，则在后台加载脚本，文档解析过程不中断。脚本加载完成后，文档停止解析，脚本执行，执行结束后文档继续解析</p><p>带async的脚本一定会在load事件之前执行，可能会在DOMContentLoaded之前或之后执行。</p><p>1.当HTML还没有被解析完的时候，async脚本已经加载完了，那么HTML停止解析，去执行脚本，脚本执行完后继续解析HTML文档，然后触发DOMContentLoaded事件</p><p><img src="/ZJY.github.io/images/domcontentload/domcontent4.jpg" alt="image"></p><p>2.HTML 解析完了之后，async脚本才加载完，然后再执行脚本，那么在HTML解析完毕、async脚本还没加载完的时候就触发DOMContentLoaded事件。如下图所示：</p><p><img src="/ZJY.github.io/images/domcontentload/domcontent5.jpg" alt="image"></p><p>总之， DomContentLoaded 事件只关注 HTML 是否被解析完，而不关注 async 脚本。</p><p>defer<br>如果script标签含有defer，那么这一块脚本将不会影响 HTML 文档的解析，而是等到 HTML 解析完成后才会执行。而 DOMContentLoaded 只有在 defer 脚本执行结束后才会被触发。</p><p>defer脚本同样包含两种情况：</p><p>1.HTML还没解析完成时，defer脚本已经加载完毕，那么defer脚本将等待HTML解析完成后再执行。defer脚本执行完毕后触发DOMContentLoaded事件。如下图所示</p><p><img src="/ZJY.github.io/images/domcontentload/domcontent6.png" alt="image"></p><p>2.HTML解析完成时，defer脚本还没加载完毕，那么defer脚本继续加载，加载完成后直接执行，执行完毕后触发DOMContentLoaded事件。如下图所示:</p><p><img src="/ZJY.github.io/images/domcontentload/domcontent7.png" alt="image"></p><p><b>defer与DOMContentLoaded</b></p><p>如果 script 标签中包含 defer，那么这一块脚本将不会影响 HTML 文档的解析，而是等到 HTML 解析完成后才会执行。而 DOMContentLoaded 只有在 defer 脚本执行结束后才会被触发。 所以这意味着什么呢？HTML 文档解析不受影响，等 DOM 构建完成之后 defer 脚本执行，但脚本执行之前需要等待 CSSOM 构建完成。在 DOM、CSSOM 构建完毕，defer 脚本执行完成之后，DOMContentLoaded 事件触发。</p><p><b>async与DOMContentLoaded</b><br> DomContentLoaded 事件只关注 HTML 是否被解析完，而不关注 async 脚本。</p>]]></content>
      
      
      <categories>
          
          <category> 问题&amp;总结 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域问题总结</title>
      <link href="/ZJY.github.io/2021/06/08/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/ZJY.github.io/2021/06/08/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="1-浏览器的同源策略"><a href="#1-浏览器的同源策略" class="headerlink" title="1.浏览器的同源策略"></a>1.浏览器的同源策略</h3><p>浏览器的同源策略，它用于限制一个源的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。</p><h3 id="2-同源的定义"><a href="#2-同源的定义" class="headerlink" title="2.同源的定义"></a>2.同源的定义</h3><p>如果两个url的协议/端口/主机都相同的话，则这两个url是同源，这个方案也被称为“协议/主机/端口元组”，或者直接是“元组”</p><p>下表给出与url：”<a href="http://store.company.com/dir/page.html&quot;">http://store.company.com/dir/page.html&quot;</a> 的源进行对比示例：</p><table><thead><tr><th align="center">URL</th><th align="center">结果</th><th align="center">原因</th></tr></thead><tbody><tr><td align="center"><a href="http://store.company.com/dir2/other.html">http://store.company.com/dir2/other.html</a></td><td align="center">同源</td><td align="center">只有路径不同</td></tr><tr><td align="center"><a href="http://store.company.com/dir/inner/another.html">http://store.company.com/dir/inner/another.html</a></td><td align="center">同源</td><td align="center">只有路径不同</td></tr><tr><td align="center"><a href="https://store.company.com/secure.html">https://store.company.com/secure.html</a></td><td align="center">失败</td><td align="center">协议不同</td></tr><tr><td align="center"><a href="http://store.company.com:81/dir/etc.html">http://store.company.com:81/dir/etc.html</a></td><td align="center">失败</td><td align="center">端口不同 ( http:// 默认端口是80)</td></tr><tr><td align="center"><a href="http://news.company.com/dir/other.html">http://news.company.com/dir/other.html</a></td><td align="center">失败</td><td align="center">主机不同</td></tr></tbody></table><p>一下是可能嵌入跨域资源的示例：</p><ul><li><code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code>标签嵌入跨域脚本</li><li><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;&quot;&gt;</code>标签嵌入css</li><li>通过<code>&lt;img&gt;</code>展示的图片</li><li>通过<code>&lt;video&gt;</code>和<code>&lt;audio&gt;</code>播放的多媒体资源</li><li>通过<code>&lt;object&gt;</code> <code>&lt;embed&gt;</code> <code>&lt;applet&gt;</code>嵌入的插入就</li><li>通过<code>@font-face</code> 引入的字体。一些浏览器允许跨域字体，一些需要同源字体</li><li>通过<code>&lt;iframe&gt;</code>载入的任何资源。站点可以使用 X-Frame-Options 消息头来阻止这种形式的跨域交互。</li></ul><h3 id="3-跨域解决方案"><a href="#3-跨域解决方案" class="headerlink" title="3.跨域解决方案"></a>3.跨域解决方案</h3><p>1.jsonp<br>2.ajax<br>3.CORS<br>4.document.domain + iframe<br>5.window.postMessage()<br>6.window.name + iframe<br>7.nginx代理</p><p>1.jsonp跨域<br>原理：动态生成一个script标签，插入head中，浏览器会执行script标签中的代码，但是只能使用get请求</p><p>具体实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">  script.type = <span class="string">&#x27;text/javascript&#x27;</span></span><br><span class="line"></span><br><span class="line">  script.src = <span class="string">&#x27;http://www.example.com?name=michael&amp;callback=onCallback&#x27;</span></span><br><span class="line">  <span class="built_in">document</span>.head.appendChild(script)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onCallback</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(res))</span><br><span class="line">    <span class="comment">// 处理数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>服务器返回后执行onCallback 函数</p><p>2.Ajax请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url: <span class="string">&#x27;http://www.example.com&#x27;</span>,</span><br><span class="line">  type: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">  dataType: <span class="string">&#x27;jsonp&#x27;</span>,</span><br><span class="line">  jsonpCallback: <span class="string">&#x27;onCallback&#x27;</span>,</span><br><span class="line">  data: &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3.CORS方式</p><p>Cross-Origin Resource Sharing可以使用cors来允许跨域访问。cors是http的一部分，它允许服务端来指定哪些主机可以从这个服务端加载资源。</p><p>前端配置withCredentials:true,设置提供凭据信息(cookie、HTTP认证及客户端SSL证明等)，当前请求为跨域类型时是否在请求中协带cookie。</p><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）<br>只要同时满足以下两大条件，就属于简单请求。<br>（1) 请求方法是以下三种方法之一：</p><ul><li>HEAD</li><li>GET</li><li>POST</li></ul><p>（2）HTTP的头信息不超出以下几种字段：</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain<br>凡是不同时满足上面两个条件，就属于非简单请求。</li></ul><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。origin字段用来说明本次请求用哪个源（协议，端口，域名），服务器根据这个值判断是否接受这次请求。<br>Access-Control-Allow-Origin：它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求<br>Access-Control-Allow-Credentials：它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器</p><p>withCredentials 属性：<br>CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。Access-Control-Allow-Credentials: true。另一方面，开发者必须在AJAX请求中打开withCredentials属性，xhr.withCredentials = true;<br>需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。</p><p>非简单请求：非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。</p><p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。<br>“预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。除了Origin字段，”预检”请求的头信息包括两个特殊字段。Access-Control-Request-Method用来列出浏览器的CORS请求会用到哪些HTTP方法</p><p>CORS与JSONP的使用目的相同，但是比JSONP更强大。</p><p>JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据</p><p>4.Document.domain + iframe</p><p>条件：<br>页面 <a href="http://www.example.com/a.html">http://www.example.com/a.html</a></p><p>页面中有一个iframe <a href="http://iframe.com/b.html">http://iframe.com/b.html</a></p><p>方式：<br>将两个页面的document.domain 设置成相同的域名，就可以在页面中拿到iframe中的数据</p><p>限制：<br>只能把document.domain设置成自身或更高一级的父域</p><p>实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.html</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">&#x27;example.com&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line">iframe.src = <span class="string">&#x27;http://iframe.com/b.html&#x27;</span>;</span><br><span class="line">iframe.style.display = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line">iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> doc = iframe.contentDocument || iframe.contentWindow.document;</span><br><span class="line">    <span class="built_in">console</span>.log(doc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//b.html</span></span><br><span class="line"><span class="built_in">document</span>.domain = <span class="string">&#x27;example.com&#x27;</span>;</span><br></pre></td></tr></table></figure><p>5.window.postMessage()<br>HTML5的新特性，允许来自不同源的脚本采用异步方式进行通信，实现跨域传递消息</p><p>使用方法：</p><p>postMessage(data, origin)</p><p>data: html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化</p><p>origin: 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“</p><p>实现:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://www.example.com/a.html</span></span><br><span class="line">&lt;iframe src=<span class="string">&quot;http://www.example2.com/b.html&quot;</span> style=<span class="string">&quot;display: none;&quot;</span> id=<span class="string">&quot;ifr&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"> <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;ifr&#x27;</span>);</span><br><span class="line"> iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> data = &#123;&#125;;</span><br><span class="line">        iframe.contentWindow.postMessage(<span class="built_in">JSON</span>.stringify(data), <span class="string">&#x27;http://www.example2.com&#x27;</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 接受传输的数据</span></span><br><span class="line"> <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(e.data);</span><br><span class="line"> &#125;, <span class="literal">false</span>);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://www.example2.com/b.html</span></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(e.data);</span><br><span class="line"> &#125;)    </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>6.window.name + iframe<br>原理：window.name 在不同的页面加载后依然存在，最大为2M</p>]]></content>
      
      
      <categories>
          
          <category> 问题&amp;总结 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6</title>
      <link href="/ZJY.github.io/2021/05/08/ES6/"/>
      <url>/ZJY.github.io/2021/05/08/ES6/</url>
      
        <content type="html"><![CDATA[<h3 id="1-let和const命令"><a href="#1-let和const命令" class="headerlink" title="1.let和const命令"></a>1.let和const命令</h3><p>1.let命令</p><p><strong>基本用法</strong><br>let用来声明变量，和var语法类似，但声明的变量只在let命令所在代码块中有效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line"><span class="comment">//ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure><p><strong>不存在变量提升</strong><br>var声明的变量会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。<br>为了纠正这种现象，let命令改变了语法行为。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 输出undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// 报错ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><strong>暂时性死区:</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码块中，使用let命令声明变量之前，该变量是不可用的，在语法上称为“暂时性死区”（TDZ）。</p><p>ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// TDZ开始</span></span><br><span class="line">  tmp = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> tmp; <span class="comment">// TDZ结束</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">123</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在let命令声明tmp变量之前，都属于变量tmp的死区。</p><p>“暂时性死区”意味着typeof不再是一个安全的操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> x; <span class="comment">// ReferenceError:x is not defined</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br></pre></td></tr></table></figure><p>如果一个变量没有被声明，使用typeof反而不会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> undeclared_variable <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">var</span> x = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> x = x; <span class="comment">// 使用let声明变量时，只要变量声明没有完成之前使用就会报错，在变量x声明语句还没有执行完成前就去取x的值，导致报错</span></span><br><span class="line"><span class="comment">// ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure><p>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p><p><strong>不允许重复声明</strong><br>let不允许在同一个作用域，重复声明已被var和let声明过的变量</p><p><strong>块级作用域</strong><br>ES5 只有全局作用域和函数作用域，没有块级作用域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(n); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>块级作用域与函数声明</strong><br>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错</p><p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am outside!&#x27;</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am inside!&#x27;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>在ES5中会得到’I am inside!’，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am outside!&#x27;</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am inside!&#x27;</span>); &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><p>ES6规定浏览器的实现可以不遵守上面的规定：</p><ul><li>允许在块级作用域内声明函数。</li><li>函数声明类似于var，即会提升到全局作用域或函数作用域的头部。</li><li>同时，函数声明还会提升到所在的块级作用域的头部</li></ul><p>上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。<br>根据这三条规则，在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器的 ES6 环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am outside!&#x27;</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am inside!&#x27;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure><p>上面代码在符合es6的浏览器中都会报错，实际运行下面代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器的 ES6 环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am outside!&#x27;</span>); &#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am inside!&#x27;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure><p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明语句</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">&#x27;secret&#x27;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">&#x27;secret&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>2.const命令<br><strong>基本用法</strong><br>const声明一个只读的常量。一旦声明，常量的值就不能改变。<br>const声明的常量，也与let一样不可重复声明。</p><p><strong>本质</strong><br>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了</p><p><strong>顶层对象的属性</strong><br>顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.a = <span class="number">1</span>;</span><br><span class="line">a <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性</p><h3 id="2-变量的解构赋值"><a href="#2-变量的解构赋值" class="headerlink" title="2.变量的解构赋值"></a>2.变量的解构赋值</h3><p><strong>数组的解构赋值</strong><br>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a <span class="comment">//1</span></span><br><span class="line">b <span class="comment">//2</span></span><br><span class="line">c <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line">foo <span class="comment">// 1</span></span><br><span class="line">bar <span class="comment">// 2</span></span><br><span class="line">baz <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>];</span><br><span class="line">third <span class="comment">// &quot;baz&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">head <span class="comment">// 1</span></span><br><span class="line">tail <span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">x <span class="comment">// &quot;a&quot;</span></span><br><span class="line">y <span class="comment">// undefined</span></span><br><span class="line">z <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>如果解构不成功，变量的值就等于undefined.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo] = []; <span class="comment">//foo:undefined</span></span><br><span class="line"><span class="keyword">let</span> [bar, foo] = [<span class="number">1</span>]; <span class="comment">//foo:undefined</span></span><br></pre></td></tr></table></figure><p>等号左边的模式，只匹配一部分的等号右边的数组，叫不完全解构，也可以解构成功</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br><span class="line">d <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构），那么将会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>对于 Set 结构，也可以使用数组的解构赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y, z] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]);</span><br><span class="line">x <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure><p><strong>默认值</strong><br>解构赋值允许指定默认值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="literal">undefined</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br></pre></td></tr></table></figure><p>ES6内部采用严格相等运算符===，判断一个位置是否有值，所以一个数组成员不严格等于undefined，默认值不会生效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [];     <span class="comment">// x=1; y=1</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">2</span>];    <span class="comment">// x=2; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// x=1; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = [];     <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><p><strong>对象的解构赋值</strong><br>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;aaa&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;bbb&quot;</span> &#125;;</span><br><span class="line">foo <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">bar <span class="comment">// &quot;bbb&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;aaa&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;bbb&quot;</span> &#125;;</span><br><span class="line">baz <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>如果变量名和属性名不一致，必须写出下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">baz <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">&#x27;hello&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;world&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">first</span>: f, <span class="attr">last</span>: l &#125; = obj;</span><br><span class="line">f <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line">l <span class="comment">// &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure><p>对象的解构赋值是下面形式的简写:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: foo, <span class="attr">bar</span>: bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;aaa&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;bbb&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><p>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;aaa&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;bbb&quot;</span> &#125;;</span><br><span class="line">baz <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">foo <span class="comment">// error: foo is not defined</span></span><br></pre></td></tr></table></figure><p>对象的解构赋值也可以指定默认值。默认值生效的条件是，对象的属性值严格等于undefined。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">x <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">null</span>&#125;;</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p><strong>字符串的解构赋值</strong><br>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">a <span class="comment">// &quot;h&quot;</span></span><br><span class="line">b <span class="comment">// &quot;e&quot;</span></span><br><span class="line">c <span class="comment">// &quot;l&quot;</span></span><br><span class="line">d <span class="comment">// &quot;l&quot;</span></span><br><span class="line">e <span class="comment">// &quot;o&quot;</span></span><br></pre></td></tr></table></figure><p>类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">len <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p><strong>数值和布尔值的解构赋值</strong><br>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mock基本使用</title>
      <link href="/ZJY.github.io/2021/05/07/mock%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/ZJY.github.io/2021/05/07/mock%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Mock：生成随机数据，拦截-Ajax-请求"><a href="#Mock：生成随机数据，拦截-Ajax-请求" class="headerlink" title="Mock：生成随机数据，拦截 Ajax 请求"></a>Mock：生成随机数据，拦截 Ajax 请求</h2><h3 id="1-安装使用"><a href="#1-安装使用" class="headerlink" title="1.安装使用"></a>1.安装使用</h3><p>Bower</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g bower</span><br><span class="line">bower install --save mockjs</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;./bower_components/mockjs/dist/mock.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="2-基础使用"><a href="#2-基础使用" class="headerlink" title="2.基础使用"></a>2.基础使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String</span></span><br><span class="line"><span class="keyword">var</span> data = Mock.mock(&#123;</span><br><span class="line">  <span class="string">&quot;String|1-10&quot;</span>: <span class="string">&quot;*&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line"><span class="comment">// &#123;String:&#x27;***&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = Mock.mock(&#123;</span><br><span class="line">  <span class="string">&#x27;string|3&#x27;</span>: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line"><span class="comment">// &#123;string: &quot;aaa&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Number</span></span><br><span class="line"><span class="keyword">var</span> data = Mock.mock(&#123;</span><br><span class="line">  <span class="string">&quot;number|1-100&quot;</span>: <span class="number">202</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line"><span class="comment">// &#123;number:57&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = Mock.mock(&#123;</span><br><span class="line">  <span class="string">&quot;number|1-100.1-10&quot;</span>: <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line"><span class="comment">// &#123;number: 22.772934&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Boolean</span></span><br><span class="line"><span class="keyword">var</span> data = Mock.mock(&#123;</span><br><span class="line">  <span class="string">&quot;boolean|1&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line"><span class="comment">// &#123;boolean:true&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object</span></span><br><span class="line"><span class="keyword">var</span> data = Mock.mock(&#123;</span><br><span class="line">  <span class="string">&quot;object|2&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;310000&quot;</span>: <span class="string">&quot;上海市&quot;</span>,</span><br><span class="line">    <span class="string">&quot;320000&quot;</span>: <span class="string">&quot;江苏省&quot;</span>,</span><br><span class="line">    <span class="string">&quot;330000&quot;</span>: <span class="string">&quot;浙江省&quot;</span>,</span><br><span class="line">    <span class="string">&quot;340000&quot;</span>: <span class="string">&quot;安徽省&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   &quot;object&quot;: &#123;</span></span><br><span class="line"><span class="comment">//     &quot;330000&quot;: &quot;浙江省&quot;,</span></span><br><span class="line"><span class="comment">//     &quot;340000&quot;: &quot;安徽省&quot;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = Mock.mock(&#123;</span><br><span class="line">  <span class="string">&quot;object|2-4&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;110000&quot;</span>: <span class="string">&quot;北京市&quot;</span>,</span><br><span class="line">    <span class="string">&quot;120000&quot;</span>: <span class="string">&quot;天津市&quot;</span>,</span><br><span class="line">    <span class="string">&quot;130000&quot;</span>: <span class="string">&quot;河北省&quot;</span>,</span><br><span class="line">    <span class="string">&quot;140000&quot;</span>: <span class="string">&quot;山西省&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   &quot;object&quot;: &#123;</span></span><br><span class="line"><span class="comment">//     &quot;110000&quot;: &quot;北京市&quot;,</span></span><br><span class="line"><span class="comment">//     &quot;120000&quot;: &quot;天津市&quot;,</span></span><br><span class="line"><span class="comment">//     &quot;140000&quot;: &quot;山西省&quot;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array</span></span><br><span class="line"><span class="keyword">var</span> data = Mock.mock(&#123;</span><br><span class="line">  <span class="string">&quot;array|2&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;AMD&quot;</span>,</span><br><span class="line">    <span class="string">&quot;CMD&quot;</span>,</span><br><span class="line">    <span class="string">&quot;UMD&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line"><span class="comment">// 随机产生一个元素</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   &quot;array&quot;: &quot;AMD&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = Mock.mock(&#123;</span><br><span class="line">  <span class="string">&quot;array|1-10&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;Mock.js&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line"><span class="comment">// 随机产生1-10个数组元素</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   &quot;array&quot;: [</span></span><br><span class="line"><span class="comment">//     &quot;Mock.js&quot;,</span></span><br><span class="line"><span class="comment">//     &quot;Mock.js&quot;</span></span><br><span class="line"><span class="comment">//   ]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// RegExp</span></span><br><span class="line"><span class="keyword">var</span> data = Mock.mock(&#123;</span><br><span class="line">  <span class="string">&#x27;regexp&#x27;</span>: <span class="regexp">/[a-z][A-Z][0-9]/</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line"><span class="comment">// &#123;regexp: &quot;jS2&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = Mock.mock(&#123;</span><br><span class="line">  <span class="string">&#x27;regexp&#x27;</span>: <span class="regexp">/\d&#123;5,10&#125;/</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line"><span class="comment">// &#123;regexp: &quot;78998&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = Mock.mock(&#123;</span><br><span class="line">  <span class="string">&#x27;regexp|3&#x27;</span>: <span class="regexp">/\d&#123;5,10&#125;\-/</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   &quot;regexp&quot;: &quot;28739-1401541809-15613-&quot;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据占位符定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机布尔值</span></span><br><span class="line">Random.boolean()</span><br><span class="line">Mock.mock(<span class="string">&#x27;@boolean&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@boolean()&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机自然数</span></span><br><span class="line">Random.natural()</span><br><span class="line">Mock.mock(<span class="string">&#x27;@natural&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@natural()&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Random.integer()</span><br><span class="line">Mock.mock(<span class="string">&#x27;@integer&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@integer()&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Random.float()</span><br><span class="line">Mock.mock(<span class="string">&#x27;@float&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@float()&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Random.character()</span><br><span class="line">Mock.mock(<span class="string">&#x27;@character&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@character()&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Random.string()</span><br><span class="line">Mock.mock(<span class="string">&#x27;@string&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@string()&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Random.range(<span class="number">10</span>) <span class="comment">//[0,1,2,3,4,5,6,7,8,9]</span></span><br><span class="line">Mock.mock(<span class="string">&#x27;@range(10)&#x27;</span>) <span class="comment">//[0,1,2,3,4,5,6,7,8,9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Date</span></span><br><span class="line">Random.date()</span><br><span class="line">Mock.mock(<span class="string">&#x27;@date&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@date()&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Random.date( format )</span></span><br><span class="line">Random.date(<span class="string">&#x27;yyyy-MM-dd&#x27;</span>)</span><br><span class="line">Random.date(<span class="string">&#x27;yy-MM-dd&#x27;</span>)</span><br><span class="line">Random.date(<span class="string">&#x27;y-MM-dd&#x27;</span>)</span><br><span class="line">Random.date(<span class="string">&#x27;y-M-d&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Mock.mock(<span class="string">&#x27;@date(&quot;yyyy-MM-dd&quot;)&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@date(&quot;yy-MM-dd&quot;)&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@date(&quot;y-MM-dd&quot;)&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@date(&quot;y-M-d&quot;)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Mock.mock(<span class="string">&#x27;@date(&quot;yyyy yy y MM M dd d&quot;)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Random.time()</span><br><span class="line">Mock.mock(<span class="string">&#x27;@time&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@time()&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Random.time( format )</span></span><br><span class="line">Random.time(<span class="string">&#x27;A HH:mm:ss&#x27;</span>)</span><br><span class="line">Random.time(<span class="string">&#x27;a HH:mm:ss&#x27;</span>)</span><br><span class="line">Random.time(<span class="string">&#x27;HH:mm:ss&#x27;</span>)</span><br><span class="line">Random.time(<span class="string">&#x27;H:m:s&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Mock.mock(<span class="string">&#x27;@time(&quot;A HH:mm:ss&quot;)&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@time(&quot;a HH:mm:ss&quot;)&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@time(&quot;HH:mm:ss&quot;)&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@time(&quot;H:m:s&quot;)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Mock.mock(<span class="string">&#x27;@datetime(&quot;HH H hh h mm m ss s SS S A a T&quot;)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Random.datetime()</span><br><span class="line">Mock.mock(<span class="string">&#x27;@datetime&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@datetime()&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Random.now()</span><br><span class="line">Mock.mock(<span class="string">&#x27;@now&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@now()&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图片</span></span><br><span class="line"><span class="comment">// Random.image( size?, background?, foreground?, format?, text? )</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Random.color()</span><br><span class="line">Mock.mock(<span class="string">&#x27;@color&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@color()&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Random.rgb()</span><br><span class="line">Random.hex()</span><br><span class="line">Random.rgba()</span><br><span class="line">Random.hsl()</span><br><span class="line"></span><br><span class="line">Random.paragraph() <span class="comment">// &quot;Oksf fvugvxa oujindgp kmqyw iashota cdmukan tglfyxsfi kxbughdzn jvwt vepovtdog phnnjp nftibvwbw uqau. Xebwbu vpvrsff nxk cagcub fmglp svbpmajru dddi kvtuoggxm qpj ovheukv httjfkfir fpnhofukk. Lgtwosm riquhht ympctsdx yytczkwe tojuedety sdiysovrx wlutvml emmmjtmf yumoe jyiloiq cefuxpt mgefihrjbn wipsrenplw sskutcs mvfnjg mxdfv vsmcn cwneh. Mhcxlol hfhxcrvnm lzunjwn zeuvck nygd augt nfdafqsob awxrl bttybubefn rnricwwob xmqmng vxygxs qbfcv. Tnrugszs wjis qirkpf xiwrza hhmff wkmzpm xnswqsup jrhoyv ifc ufnsasp fagcgtcl vtmqoqunb ggeeftc qktbmf flritae wbq tudrsrb xoxqvqlb.&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Web</span></span><br><span class="line">Random.url()</span><br><span class="line">Mock.mock(<span class="string">&#x27;@url&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@url()&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;wais://gelm.gf/tqkuz&quot;</span></span><br><span class="line"><span class="comment">// &quot;news://lkvi.so/nacax&quot;</span></span><br><span class="line"><span class="comment">// &quot;tn3270://zbxqguresa.fk/qguefcsa&quot;</span></span><br><span class="line"></span><br><span class="line">Random.domain()</span><br><span class="line">Random.protocol()</span><br><span class="line">Random.tld()</span><br><span class="line">Random.email()</span><br><span class="line">Random.ip()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Address</span></span><br><span class="line">Random.region() <span class="comment">//&quot;东北&quot;</span></span><br><span class="line">Random.province()</span><br><span class="line"><span class="comment">// Random.city( prefix? )</span></span><br><span class="line">Random.city()</span><br><span class="line">Mock.mock(<span class="string">&#x27;@city&#x27;</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@city()&#x27;</span>)</span><br><span class="line"><span class="comment">// Random.city( prefix )</span></span><br><span class="line">Random.city(<span class="literal">true</span>)</span><br><span class="line">Mock.mock(<span class="string">&#x27;@city(true)&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;桃园县&quot;</span></span><br><span class="line"><span class="comment">// &quot;南昌市&quot;</span></span><br><span class="line"><span class="comment">// &quot;枣庄市&quot;</span></span><br><span class="line"><span class="comment">// // Random.city( prefix )</span></span><br><span class="line"><span class="comment">// &quot;广西壮族自治区 来宾市&quot;</span></span><br><span class="line"><span class="comment">// &quot;北京 北京市&quot;</span></span><br><span class="line">Random.county([prefix])</span><br><span class="line"></span><br><span class="line">Random.zip() <span class="comment">// &quot;216873&quot;</span></span><br><span class="line"></span><br><span class="line">Random.guid() <span class="comment">//&quot;5D36E3Fb-dcF1-6CC3-d5A3-9feD7b2f4f52&quot;</span></span><br><span class="line">Random.id() <span class="comment">// &quot;500000200806155373&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = Mock.mock(&#123;</span><br><span class="line">  <span class="string">&#x27;array|1-10&#x27;</span>:[&#123;</span><br><span class="line">      <span class="string">&#x27;name&#x27;</span>: Mock.mock(<span class="string">&#x27;@name&#x27;</span>),</span><br><span class="line">      <span class="string">&#x27;age|18-69&#x27;</span>:<span class="number">1</span>,</span><br><span class="line">      <span class="string">&#x27;imageUrl&#x27;</span>: Mock.Random.image(<span class="string">&#x27;200x100&#x27;</span>, <span class="string">&#x27;#894FC4&#x27;</span>, <span class="string">&#x27;#FFF&#x27;</span>, <span class="string">&#x27;png&#x27;</span>, <span class="string">&#x27;!&#x27;</span>)</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line"><span class="comment">// Array:6</span></span><br><span class="line"><span class="comment">// 0: &#123;name: &quot;Mark Hall&quot;, age: 28, imageUrl: &quot;http://dummyimage.com/200x100/894FC4/FFF.png&amp;text=!&quot;&#125;</span></span><br><span class="line"><span class="comment">// 1: &#123;name: &quot;Mark Hall&quot;, age: 24, imageUrl: &quot;http://dummyimage.com/200x100/894FC4/FFF.png&amp;text=!&quot;&#125;</span></span><br><span class="line"><span class="comment">// 2: &#123;name: &quot;Mark Hall&quot;, age: 37, imageUrl: &quot;http://dummyimage.com/200x100/894FC4/FFF.png&amp;text=!&quot;&#125;</span></span><br><span class="line"><span class="comment">// 3: &#123;name: &quot;Mark Hall&quot;, age: 31, imageUrl: &quot;http://dummyimage.com/200x100/894FC4/FFF.png&amp;text=!&quot;&#125;</span></span><br><span class="line"><span class="comment">// 4: &#123;name: &quot;Mark Hall&quot;, age: 48, imageUrl: &quot;http://dummyimage.com/200x100/894FC4/FFF.png&amp;text=!&quot;&#125;</span></span><br><span class="line"><span class="comment">// 5: &#123;name: &quot;Mark Hall&quot;, age: 34, imageUrl: &quot;http://dummyimage.com/200x100/894FC4/FFF.png&amp;text=!&quot;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>https和ssl证书概要</title>
      <link href="/ZJY.github.io/2021/04/30/https%E5%92%8Cssl%E8%AF%81%E4%B9%A6%E6%A6%82%E8%A6%81/"/>
      <url>/ZJY.github.io/2021/04/30/https%E5%92%8Cssl%E8%AF%81%E4%B9%A6%E6%A6%82%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<h3 id="1-HTTPS简介"><a href="#1-HTTPS简介" class="headerlink" title="1.HTTPS简介"></a>1.HTTPS简介</h3><p>超文本传输安全协议是一种网络安全传输协议。<br>http协议传输的数据都是未加密的，明文传输。<br>http使用80端口通讯，https占用443端口通讯。<br>https经由http进行通信，用ssl/tls加密数据包。<br>https主要用于提供网络服务器的身份认证，保护数据的隐私和完整性。</p><h3 id="2-https工作原理"><a href="#2-https工作原理" class="headerlink" title="2.https工作原理"></a>2.https工作原理</h3><p>工作流程：<br>1、TCP 三次同步握手<br>2、客户端验证服务器数字证书<br>3、DH 算法协商对称加密算法的密钥、hash 算法的密钥<br>4、SSL 安全加密隧道协商完成<br>5、网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。</p><p>1、客户端发起 HTTPS 请求</p><p>这个没什么好说的，就是用户在浏览器里输入一个 https 网址，然后连接到 server 的 443 端口。</p><p>2、服务端的配置</p><p>采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl 就是个不错的选择，有 1 年的免费服务)。</p><p>这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</p><p>3、传送证书</p><p>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间，网站地址，加密公钥等等。</p><p>4、客户端解析证书</p><p>这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。</p><p>如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</p><p>5、传送加密信息</p><p>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p><p>6、服务端解密信息</p><p>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</p><p>7、传输加密后的信息</p><p>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。</p><p>8、客户端解密信息</p><p>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。</p><h3 id="3-HTTP-与-HTTPS-区别"><a href="#3-HTTP-与-HTTPS-区别" class="headerlink" title="3.HTTP 与 HTTPS 区别"></a>3.HTTP 与 HTTPS 区别</h3><p>HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。<br>使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。<br>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。<br>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。<br>HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源</p><h3 id="4-TCP三次握手"><a href="#4-TCP三次握手" class="headerlink" title="4.TCP三次握手"></a>4.TCP三次握手</h3><p>第一次握手：客户端尝试连接服务器，向服务器发送 syn 包（同步序列编号Synchronize Sequence Numbers），syn=j，客户端进入 SYN_SEND 状态等待服务器确认<br>第二次握手：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个 SYN包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态<br>第三次握手：第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器缓存机制</title>
      <link href="/ZJY.github.io/2021/04/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
      <url>/ZJY.github.io/2021/04/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="1-缓存"><a href="#1-缓存" class="headerlink" title="1.缓存"></a>1.缓存</h3><p>好的缓存策略可以缩短网页请求资源的距离，减少延迟，并且缓存文件可以重复利用，可以减少带宽，降低网络负荷。</p><p>一个数据请求，可以分为发起网络请求、后端处理、浏览器响应三个步骤。缓存可以帮我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但存储的数据和前端一致，那么就没有必要再将数据回传回来，减少响应。</p><h3 id="2-缓存位置"><a href="#2-缓存位置" class="headerlink" title="2.缓存位置"></a>2.缓存位置</h3><p>缓存位置上分4种，并各有优先级，当一次查找都没有命中的时候才去请求网络。</p><ul><li>Service Worker</li><li>Memory Cache</li><li>Disk Cache</li><li>Push Cache</li></ul><h4 id="1-Service-Worker"><a href="#1-Service-Worker" class="headerlink" title="1.Service Worker"></a>1.Service Worker</h4><p>运行在浏览器的独立线程，可以实现缓存功能。<br>使用Service Worker，传输协议必须为HTTPS。<br>Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。</p><h4 id="2-Memory-Cache"><a href="#2-Memory-Cache" class="headerlink" title="2.Memory Cache"></a>2.Memory Cache</h4><p>内存中的缓存，主要包含当前页面中已经抓取的资源，例如页面上已经下载的样式，脚本，图片等。读取内存中的数据肯定比磁盘块，内存缓存虽然读取高效，但是可持续性短，会随着进程的释放而释放。一旦我们关闭tab页面，内存中的缓存就被释放了。</p><h4 id="3-Disk-Cache"><a href="#3-Disk-Cache" class="headerlink" title="3.Disk Cache"></a>3.Disk Cache</h4><p>存储在硬盘中的缓存，虽然读取慢，但什么都能存储，比Memory Cache胜在存储的容量和存储时效上。</p><p>在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。</p><h4 id="4-Push-Cache"><a href="#4-Push-Cache" class="headerlink" title="4.Push Cache"></a>4.Push Cache</h4><p>推送缓存是http/2中的内容，当以上3中缓存都没有命中时，才会使用。它只在会话（session）中存在，一旦会话结束就被释放，并且缓存时间很短。</p><p>如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。</p><p>通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。</p><h3 id="3-强缓存"><a href="#3-强缓存" class="headerlink" title="3.强缓存"></a>3.强缓存</h3><p>强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。</p><h4 id="1-Expires"><a href="#1-Expires" class="headerlink" title="1.Expires"></a>1.Expires</h4><p>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</p><p>Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。Expires: Wed, 22 Oct 2018 08:41:00 GMT表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求.</p><h4 id="2-Cache-Control"><a href="#2-Cache-Control" class="headerlink" title="2.Cache-Control"></a>2.Cache-Control</h4><ul><li>public:所有内容都将被缓存（客户端和代理服务器都可缓存），中间的代理服务器proxy也可以缓存资源</li><li>private：所有内容只有客户端可以缓存，cache-control的默认取值</li><li>no-cache：客户端缓存内容，是否使用缓存需要经过协商缓存来验证决定。</li><li>no-store：不使用缓存，既不使用强制缓存也不使用协商缓存</li><li>max-age：max-age=3000，单位秒，缓存内容将在3000秒后失效</li><li>s-maxage：同max-age一样，但只在代理服务器中生效（比如cdn缓存）。比如当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。s-maxage的优先级高于max-age。如果存在s-maxage，则会覆盖掉max-age和Expires header。</li><li>max-stale：能容忍的最大的过期时间，max-stale指令标示了客户端愿意接收一个已经过期了的响应。如果指定了max-stale的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何age的响应</li><li>min-fresh:指定客户端需要的响应是最新的指定的秒数的缓存数据。例如 Cache-Control:min-fresh=60，这就要求缓存服务器发送60秒内的数据</li><li>immutable：客户端在xxx秒的有效期内，如果有请求该资源的需求的话就直接读取缓存,statu code:200 ，即使用户做了刷新操作，也不向服务器发起http请求</li></ul><h3 id="4-协商缓存"><a href="#4-协商缓存" class="headerlink" title="4.协商缓存"></a>4.协商缓存</h3><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</p><ul><li>协商缓存生效，返回304和Not Modified</li><li>协商缓存失效，返回200和请求结果</li></ul><p>协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag</p><h4 id="1-Last-modified和If-modified-Since"><a href="#1-Last-modified和If-modified-Since" class="headerlink" title="1.Last-modified和If-modified-Since"></a>1.Last-modified和If-modified-Since</h4><p>浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header；</p><p>浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200</p><p>但是 Last-Modified 存在一些弊端：<br>如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源<br>因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源.</p><h4 id="2-ETag和If-None-Match"><a href="#2-ETag和If-None-Match" class="headerlink" title="2.ETag和If-None-Match"></a>2.ETag和If-None-Match</h4><p>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。<br>如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。</p><h4 id="3-Etag和Last-modified对比"><a href="#3-Etag和Last-modified对比" class="headerlink" title="3.Etag和Last-modified对比"></a>3.Etag和Last-modified对比</h4><ul><li><p>首先在精确度上，Etag要优于Last-Modified。<br>Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。</p></li><li><p>第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。</p></li><li><p>第三在优先级上，服务器校验优先考虑Etag</p></li></ul><h3 id="5-场景应用"><a href="#5-场景应用" class="headerlink" title="5.场景应用"></a>5.场景应用</h3><ul><li>1.频繁变动的资源<br>Cache-Control: no-cache</li></ul><p>对于频繁变动的资源，首先需要使用Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。</p><ul><li>2.不常变化的资源<br>Cache-Control: max-age=31536000</li></ul><p>通常在处理这类资源时，给它们的 Cache-Control 配置一个很大的 max-age=31536000 (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效 (其实并未立即失效，只是不再使用了而已）。</p><p>触发缓存策略：</p><ul><li>打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。</li><li>普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。</li><li>强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache(为了兼容，还带了 Pragma: no-cache),服务器直接返回 200 和最新内容。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 问题&amp;总结 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript作用域</title>
      <link href="/ZJY.github.io/2021/04/24/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84javascript-1/"/>
      <url>/ZJY.github.io/2021/04/24/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84javascript-1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-作用域是什么"><a href="#1-作用域是什么" class="headerlink" title="1.作用域是什么"></a>1.作用域是什么</h2><h3 id="1-编译原理"><a href="#1-编译原理" class="headerlink" title="1. 编译原理"></a>1. 编译原理</h3><p>尽管将JavaScript归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。</p><p>JavaScript引擎进行编译的步骤和传统的编译语言非常相似，但它不是提前编译的，编译结果也不能在分布式系统中移植。</p><p>传统编译语言，程序中的一段源代码在执行之前会经过三个步骤，统称为“编译”。</p><ul><li><p>分词/词法分析（Tokenizing/Lexing）<br>这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（ token ）。例如，考虑程序 var a = 2; 。这段程序通常会被分解成为下面这些词法单元： var 、 a 、 = 、 2 、 ; 。空格是否会被当作词法单元，取决于空格在这门语言中是否具有意义。</p></li><li><p>解析/语法分析(Parsing)<br>这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（ Abstract Syntax Tree ， AST ）。 var a = 2; 的抽象语法树中可能会有一个叫作 VariableDeclaration 的顶级节点，接下来是一个叫作 Identifier （它的值是 a ）的子节点，以及一个叫作 AssignmentExpression 的子节点。 AssignmentExpression 节点有一个叫作 NumericLiteral （它的值是 2 ）的子节点。 •</p></li><li><p>代码生成<br>将 AST 转换为可执行代码的过程称被称为代码生成。这个过程与语言、目标平台等息息相关。抛开具体细节，简单来说就是有某种方法可以将 var a = 2; 的 AST 转化为一组机器指令，用来创建一个叫作 a 的变量（包括分配内存等），并将一个值储存在 a 中。</p></li></ul><p>简单地说，任何 JavaScript 代码片段在执行前都要进行编译（通常就在执行前）。因此， JavaScript 编译器首先会对 var a = 2; 这段程序进行编译，然后做好执行它的准备，并且通常马上就会执行它。</p><h3 id="2-理解作用域"><a href="#2-理解作用域" class="headerlink" title="2.理解作用域"></a>2.理解作用域</h3><ul><li><p>引擎<br>负责整个JavaScript程序的编译和执行过程。</p></li><li><p>编译器<br>引擎的好朋友之一，负责语法分析和代码生成等。</p></li><li><p>作用域<br>引擎的另一位好朋友，负责收集并维护所有声明的标识符组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。</p></li></ul><p>当你看到var a = 2;这段程序时，认为这是一句声明。但引擎确不是这样处理。</p><p>编译器首先会将这段程序拆分为词法单元，然后将词法单元解析成一个树结构。但是当编译器开始进行代码生成时，对这段程序的处理会和预期有所不同。</p><p>可以用伪代码概括：“为一个变量分配内存，将其命名为a，然后将值2保存进这个变量。”然而并不完全正确。</p><p>事实上编译器会进行如下处理：</p><p>1.遇到var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，命名为a。</p><p>2.接下来编译器会为引擎生成运行时所需代码，这段代码被用来处理a = 2这个赋值操作。引擎运行时会先询问作用域，在当前作用域集合中是否存在一个叫做a的变量。如果是引擎就使用这个变量；如果不是引擎继续查找该变量。如果引擎最终找到了该变量，就将2赋值给它，否则就抛出一个异常。</p><p><b>总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时会在该作用域中查找该变量，如果能找到就对它赋值。</b></p><h3 id="3-引擎查询"><a href="#3-引擎查询" class="headerlink" title="3.引擎查询"></a>3.引擎查询</h3><p>编译器生成代码后，引擎执行它时，会通过查找变量a来判断它是否已声明过。引擎查询分为LHS查询和RHS查询。“L”和“R”表示赋值操作的左侧和右侧。</p><p>当变量出现在赋值操作的左侧时进行LHS查询，出现在右侧时进行RHS查询。</p><p>console.log(a);其中对a的引用是RHS引用，这里a并没有赋予任何值。要查找并取得a的值并将值传递给console.log()<br>a=2;对a的引用是LHS引用，并不关心当前值是什么，只是想要为=2这个赋值操作找到一个目标。</p><p>LHS 和 RHS 的含义是“赋值操作的左侧或右侧”并不一定意味着就是“=赋值操作符的左侧或右侧”。赋值操作还有其他几种形式，因此在概念上最好将其理解为“赋值操作的目标是谁（ LHS ）”以及“谁是赋值操作的源头（ RHS ）”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> b = a; <span class="keyword">return</span> a + b; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> c = foo( <span class="number">2</span> ); </span><br></pre></td></tr></table></figure><ol><li>找出所有的 LHS 查询（这里有 3 处！）<br> c = ..; 、 a = 2 （隐式变量分配）、 b = .. </li><li>找出所有的 RHS 查询（这里有 4 处！） foo(2..) 、 = a; 、 a .. 、 .. b</li></ol><h3 id="4-作用域嵌套"><a href="#4-作用域嵌套" class="headerlink" title="4.作用域嵌套"></a>4.作用域嵌套</h3><p>作用域是根据名称查找变量的一套规则。<br>当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（也就是全局作用域）为止。</p><p>遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。</p><h3 id="5-异常"><a href="#5-异常" class="headerlink" title="5.异常"></a>5.异常</h3><p>区分LHS和RHS很重要，因为变量在还没有声明的情况下这两种查询行为是不一样的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log( a + b ); </span><br><span class="line">  b = a; </span><br><span class="line">&#125; </span><br><span class="line">foo( <span class="number">2</span> ); </span><br></pre></td></tr></table></figure><p>第一次对 b 进行 RHS 查询时是无法找到该变量的。也就是说，这是一个“未声明”的变量，因为在任何相关的作用域中都无法找到它。<br>如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError 异常。值得注意的是， ReferenceError 是非常重要的异常类型。相较之下，当引擎执行 LHS 查询时，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非“严格模式”下。</p><p>接下来，如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作TypeError 。 </p><p>ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。</p><h3 id="6-小结"><a href="#6-小结" class="headerlink" title="6.小结"></a>6.小结</h3><p>作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。赋值操作符会导致 LHS 查询。＝操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。 </p><p>JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 var a = 2 这样的声明会被分解成两个独立的步骤：</p><ol><li>首先， var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。 </li><li>接下来， a = 2 会查询（ LHS 查询）变量 a 并对其进行赋值。 </li></ol><p>LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。</p><p>不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛出 ReferenceError 异常（严格模式下）。</p><h2 id="2-词法作用域"><a href="#2-词法作用域" class="headerlink" title="2.词法作用域"></a>2.词法作用域</h2><h3 id="1-词法阶段"><a href="#1-词法阶段" class="headerlink" title="1.词法阶段"></a>1.词法阶段</h3><p>大部分标准语言编译器的第一个工作阶段叫作词法化（也叫单词化）。</p><p>简单地说，词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下）。</p><p>作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。</p><p>全局变量会自动成为全局对象（比如浏览器中的 window 对象）的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引用来对其进行访问。<br>window.a 通过这种技术可以访问那些被同名变量所遮蔽的全局变量。但非全局的变量如果被遮蔽了，无论如何都无法被访问到。<br>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。</p><h3 id="2-欺骗词法"><a href="#2-欺骗词法" class="headerlink" title="2.欺骗词法"></a>2.欺骗词法</h3><p>如果词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来“修改”（也可以说欺骗）词法作用域呢？ JavaScript 中有两种机制来实现这个目的。</p><h4 id="2-1-eval"><a href="#2-1-eval" class="headerlink" title="2.1 eval"></a>2.1 eval</h4><p>JavaScript 中的 eval(..) 函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。换句话说，可以在你写的代码中用程序生成代码并运行，就好像代码是写在那个位置的一样。<br>在执行 eval(..) 之后的代码时，引擎并不“知道”或“在意”前面的代码是以动态形式插入进来，并对词法作用域的环境进行修改的。引擎只会如往常地进行词法作用域查找。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str, a</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">eval</span>( str ); <span class="comment">// 欺骗！ </span></span><br><span class="line">  <span class="built_in">console</span>.log( a, b ); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>; </span><br><span class="line">foo( <span class="string">&quot;var b = 3;&quot;</span>, <span class="number">1</span> ); <span class="comment">// 1, 3</span></span><br></pre></td></tr></table></figure><p>eval(..) 调用中的 “var b = 3;” 这段代码会被当作本来就在那里一样来处理。由于那段代码声明了一个新的变量 b ，因此它对已经存在的 foo(..) 的词法作用域进行了修改。事实上，和前面提到的原理一样，这段代码实际上在 foo(..) 内部创建了一个变量 b ，并遮蔽了外部（全局）作用域中的同名变量。<br>当 console.log(..) 被执行时，会在 foo(..) 的内部同时找到 a 和 b ，但是永远也无法找到外部的 b 。因此会输出“1, 3” 而不是正常情况下会输出的“1, 2” 。</p><p>在这个例子中，为了展示的方便和简洁，我们传递进去的“代码”字符串是固定不变的。而在实际情况中，可以非常容易地根据程序逻辑动态地将字符拼接在一起之后再传递进去。 eval(..) 通常被用来执行动态创建的代码，因为像例子中这样动态地执行一段固定字符所组成的代码，并没有比直接将代码写在那里更有好处。</p><h4 id="2-2-with"><a href="#2-2-with" class="headerlink" title="2.2 with"></a>2.2 with</h4><p>JavaScript 中另一个难以掌握（并且现在也不推荐使用）的用来欺骗词法作用域的功能是 with 关键字。可以有很多方法来解释 with ，在这里我选择从这个角度来解释它：它如何同被它所影响的词法作用域进行交互。<br>with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。<br>比如： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;; </span><br><span class="line"><span class="comment">// 单调乏味的重复 &quot;obj&quot; </span></span><br><span class="line">obj.a = <span class="number">2</span>; </span><br><span class="line">obj.b = <span class="number">3</span>; </span><br><span class="line">obj.c = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单的快捷方式 </span></span><br><span class="line"><span class="keyword">with</span> (obj) &#123; </span><br><span class="line">  a = <span class="number">3</span>; </span><br><span class="line">  b = <span class="number">4</span>; </span><br><span class="line">  c = <span class="number">5</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//但实际上这不仅仅是为了方便地访问对象属性。</span></span><br><span class="line"><span class="comment">//考虑如下代码： </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">obj</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">with</span> (obj) &#123; </span><br><span class="line">    a = <span class="number">2</span>; </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">a</span>: <span class="number">3</span> &#125;; </span><br><span class="line"><span class="keyword">var</span> o2 = &#123; <span class="attr">b</span>: <span class="number">3</span> &#125;; </span><br><span class="line">foo( o1 ); </span><br><span class="line"><span class="built_in">console</span>.log( o1.a ); <span class="comment">// 2 </span></span><br><span class="line">foo( o2 );</span><br><span class="line"> <span class="built_in">console</span>.log( o2.a ); <span class="comment">// undefined </span></span><br><span class="line"> <span class="built_in">console</span>.log( a ); <span class="comment">// 2—— 不好， a 被泄漏到全局作用域上了！</span></span><br></pre></td></tr></table></figure><p>这个例子中创建了 o1 和 o2 两个对象。其中一个具有 a 属性，另外一个没有。<br>foo(..) 函数接受一个 obj 参数，该参数是一个对象引用，并对这个对象引用执行了 with(obj) {..} 。在 with 块内部，我们写的代码看起来只是对变量 a 进行简单的词法引用，实际上就是一个 LHS 引用并将 2 赋值给它。当我们将 o1 传递进去， a ＝ 2 赋值操作找到了 o1.a 并将 2 赋值给它，这在后面的 console. log(o1.a) 中可以体现。而当 o2 传递进去， o2 并没有 a 属性，因此不会创建这个属性， o2.a 保持 undefined 。但是可以注意到一个奇怪的副作用，实际上 a = 2 赋值操作创建了一个全局变量a。</p><p>尽管 with 块可以将一个对象处理为词法作用域，但是这个块内部正常的 var 声明并不会被限制在这个块的作用域中，而是被添加到 with 所处的函数作用域中。</p><h3 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h3><p>词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。</p><p>JavaScript 中有两个机制可以“欺骗”词法作用域： eval(..) 和 with 。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。</p><p>这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-4.变化侦测相关api实现原理</title>
      <link href="/ZJY.github.io/2021/04/20/vue-4-%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B%E7%9B%B8%E5%85%B3api%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/ZJY.github.io/2021/04/20/vue-4-%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B%E7%9B%B8%E5%85%B3api%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="vue-4-变化侦测相关api实现原理"><a href="#vue-4-变化侦测相关api实现原理" class="headerlink" title="vue-4.变化侦测相关api实现原理"></a>vue-4.变化侦测相关api实现原理</h2><h3 id="4-1-vm-watch"><a href="#4-1-vm-watch" class="headerlink" title="4.1 vm.$watch"></a>4.1 vm.$watch</h3><h4 id="4-1-1-用法"><a href="#4-1-1-用法" class="headerlink" title="4.1.1 用法"></a>4.1.1 用法</h4><p>vm.$watch(expOrFn, callback, [options]);<br>参数：</p><ul><li><p>{string | Function} expOrFn</p></li><li><p>{Function | Object } callback</p></li><li><p>{object} [options]</p><ul><li>{boolean} deep</li><li>{boolean} immediate</li></ul></li><li><p>返回值：{Function} unwatch</p></li><li><p>用法：用于观察一个表达式或computed函数在vue.js实例上的变化。回调函数调用时会得到新数据和旧数据。表达式只接受以点分隔的路径，例如a.b.c,如果是一个比较负责的表达式，可以用函数代替表达式。</p></li></ul><p>例如：<br>vm.$watch(‘a.b.c’, function(newVal,oldVal){});</p><p>返回一个取消观察函数，用来停止触发回调：<br>var unwatch = vm.$watch(‘a.b.c’, function(newVal,oldVal){});<br>//取消观察<br>unwatch();</p><p>deep:true,发现对象内部值的变化<br>immediate:true,立即以表达式的当前值触发回调</p><h4 id="4-1-2-watch的内部原理"><a href="#4-1-2-watch的内部原理" class="headerlink" title="4.1.2 watch的内部原理"></a>4.1.2 watch的内部原理</h4><p>vm.$watch其实是对Watcher的一种封装，加上参数deep和immediate</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$watch = <span class="function"><span class="keyword">function</span> (<span class="params">expOrFn, cb, options</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="built_in">this</span>;</span><br><span class="line">  options = options || &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> watcher = <span class="keyword">new</span> Watcher(vm,expOrFn, cb, options);</span><br><span class="line">  <span class="keyword">if</span>(options.immediate)&#123;</span><br><span class="line">    cb.call(vm,watcher.value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unwatch</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    watcher.teardown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先执行new Watcher实现vm.$watch的基本功能。<br>expOrFn是支持函数的，需要对Watcher进行简单的修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> calss Watcher&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">vm, expOrFn, cb</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.vm = vm;</span><br><span class="line">    <span class="comment">//expOrFn函数处理</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> expOrFn === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = expOrFn;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = parsePath(expOrFn)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.cb = cb;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.get();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增判断expOrFn类型：如果是函数则直接赋值给getter；如果不是函数，使用parsePath函数来读取keypath中数据。keypath指的是属性路径，例如a.b.c,从vm.a.b.c读取数据。</p><p>当expOrFn是函数时，它不只可以动态返回数据，其中读取的所有数据都会被Watcher观察。当expOrFn只是keypath时，Watcher只会读取keypath所指向的数据并观察这个数据的变化。</p><p>执行new Watcher后判断是否使用immediate参数，如果使用立即执行一次cb</p><p>最后返回一个函数unwatch，取消观察数据。实际上执行watcher.teardown()来取消数据，实质上把watcher实例从正在观察的状态的依赖列表中移除。</p><p>首先需要在watcher中记录自己都订阅来谁，也就是watcher实例被收集进来哪些dep，然后当watcher不想继续订阅dep时，循环自己记录的订阅列表来通知他们Dep将自己从他们的依赖列表中移除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> calss Watcher&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">vm, expOrFn, cb</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.vm = vm;</span><br><span class="line">    <span class="built_in">this</span>.deps = [];<span class="comment">//新增</span></span><br><span class="line">    <span class="built_in">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">//新增</span></span><br><span class="line">    <span class="comment">//expOrFn函数处理</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> expOrFn === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = expOrFn;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = parsePath(expOrFn)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.cb = cb;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.get();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 新增：记录watcher中记录自己都订阅过哪些Dep</span></span><br><span class="line">  <span class="function"><span class="title">addDep</span>(<span class="params">dep</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> id = dep.id;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.depIds.has(id))&#123;</span><br><span class="line">      <span class="built_in">this</span>.depIds.add(id);</span><br><span class="line">      <span class="built_in">this</span>.deps.push(dep);</span><br><span class="line">      dep.addSub(<span class="built_in">this</span>); <span class="comment">//将自己订阅到Dep</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有第一次触发getter时候才会收集依赖。</p><p>在Watcher中新增addDep方法后，Dep中收集依赖的逻辑也需要改变：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    thid.id = uid++; <span class="comment">//新增</span></span><br><span class="line">    <span class="built_in">this</span>.subs = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">depend</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.target)&#123;</span><br><span class="line">      <span class="comment">// this.addSub(window.target); //废弃</span></span><br><span class="line">      <span class="built_in">window</span>.target.addDep(<span class="built_in">this</span>); <span class="comment">//新增</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，Dep会记录数据发送变化时，需要通知哪些Watcher，而Watcher中也同样记录了自己会被哪些Dep通知。他们是多对多的关系。</p><p>在watcher中新增teardown方法来通知订阅的Dep把自己从依赖列表中移除：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">teardown</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="built_in">this</span>.deps.length;</span><br><span class="line">  <span class="keyword">while</span>(i--)&#123;</span><br><span class="line">    <span class="built_in">this</span>.deps[i].removeSub(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行Dep的removeSub方法将watcher从依赖列表中移除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="title">removeSub</span>(<span class="params">sub</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> index = <span class="built_in">this</span>.subs.indexOf(sub);</span><br><span class="line">    <span class="keyword">if</span>(index &gt; -<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.subs.splice(index,<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-3-deep参数的实现原理"><a href="#4-1-3-deep参数的实现原理" class="headerlink" title="4.1.3 deep参数的实现原理"></a>4.1.3 deep参数的实现原理</h4><p>deep就是除了要触发当前这个被监听数据的收集依赖逻辑以外还要把当前监听的这个值内的所以子值都触发一遍收集依赖逻辑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> calss Watcher&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">vm, expOrFn, cb</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.vm = vm;</span><br><span class="line">    <span class="comment">//新增</span></span><br><span class="line">    <span class="keyword">if</span>(options)&#123;</span><br><span class="line">      <span class="built_in">this</span>.deep = !!options.deep</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.deep = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.deps = [];</span><br><span class="line">    <span class="built_in">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>(); </span><br><span class="line">    <span class="comment">//expOrFn函数处理</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> expOrFn === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = expOrFn;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = parsePath(expOrFn)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.cb = cb;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.get();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.target = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="built_in">this</span>.getter.call(vm,vm);</span><br><span class="line">    <span class="comment">//新增 </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.deep)&#123;</span><br><span class="line">      traverse(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.target = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用deep参数在window.target = undefined之前调用traverse来处理deep逻辑。</p><p>递归value的所有子值来触发他们的收集依赖功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> seenObjects = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">traverse</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">  _traverse_(val,seenObjects);</span><br><span class="line">  seenObjects.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_traverse_</span>(<span class="params">val,seen</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i,keys;</span><br><span class="line">  <span class="keyword">const</span> isA = <span class="built_in">Array</span>.isArray(val);</span><br><span class="line">  <span class="keyword">if</span>((!isA &amp;&amp; !isObject(val)) || <span class="built_in">Object</span>.isFrozen(val))&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(val.__ob__)&#123;</span><br><span class="line">    <span class="keyword">const</span> depId = val.__ob__.dep.id;</span><br><span class="line">    <span class="keyword">if</span>(seen.has(depId))&#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    seen.add(depId)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(isA)&#123;</span><br><span class="line">    i = val.length;</span><br><span class="line">    <span class="keyword">while</span>(i--) _traverse(val[i], seen)</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    keys = <span class="built_in">Object</span>.keys(val);</span><br><span class="line">    i = keys.length</span><br><span class="line">    <span class="keyword">while</span>(i--) _traverse(val[keys[i]], seen)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们先判断val的类型,如果它不是Array和 Object,或者已经被冻结,那么直接返回,什么都不干。</p><p>然后拿到val的dep.id,用这个id来保证不会重复收集依赖<br>如果是数组,则循环数组,将数组中的每一项递归调用 _traverse。<br>最后,重点来了,如果是 Object类型的数据,则循环 Object中的所有key,然后执行一次读取操作,再递归子值<br>while (i–) _traverse(val[keys[il], seen)<br>其中val[keys[i]]会触发 getter,也就是说会触发收集依赖的操作,这时 window.target还没有被清空,会将当前的 Watcher收集进去。<br>而 _traverse函数其实是一个递归操作,所以这个 value的子值也会触发同样的逻辑,这<br>羊就可以实现通过deep参数来监听所有子值的变化。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-3.Array的变化侦测</title>
      <link href="/ZJY.github.io/2021/04/20/vue-3-Array%E7%9A%84%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/"/>
      <url>/ZJY.github.io/2021/04/20/vue-3-Array%E7%9A%84%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="vue-3-Array的变化侦测"><a href="#vue-3-Array的变化侦测" class="headerlink" title="vue-3.Array的变化侦测"></a>vue-3.Array的变化侦测</h2><h3 id="3-1-如何追踪变化？"><a href="#3-1-如何追踪变化？" class="headerlink" title="3.1 如何追踪变化？"></a>3.1 如何追踪变化？</h3><p>使用自定义的方法覆盖原生的原型方法。<br>我们可以用一个拦截器覆盖Array.prototype.之后每当使用Array原型上的方法操作数组时，其实执行的都是拦截器中提供的方法，比如push方法。然后在拦截器中使用原生Array的原型方法去操作数组。</p><h3 id="3-2-拦截器"><a href="#3-2-拦截器" class="headerlink" title="3.2 拦截器"></a>3.2 拦截器</h3><p>拦截器其实就是一个和Array.prototype一样的object，里面包含的属性一摸一样，只不过这个object中某些可以改变数组自身内容的方法是我们处理过的。</p><p>Array原型中可以改变数组自身内容的方法有7个，分别是push,pop,unshift,shift,splice,sort,reverse.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto);</span><br><span class="line">[</span><br><span class="line"><span class="string">&#x27;push&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> original = arrayProto[method]; <span class="comment">//缓存原始方法</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(arrayMethods, method, &#123;</span><br><span class="line">  value: <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> original.apply(<span class="built_in">this</span>, args);</span><br><span class="line">  &#125;,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>变量arrayMethods继承自Array.prototype，具备其所有功能，在arrayMethods上使用Object.defineProperty方法将那些可以改变数组自身内容的方法进行封装。<br>所以当使用push方法，实际上使用的是arrayMethods.push，也就是函数mutator。因此我们就可以在mutator函数作一些其他的事，比如发送变化通知。</p><h3 id="3-3-使用拦截器覆盖Array原型"><a href="#3-3-使用拦截器覆盖Array原型" class="headerlink" title="3.3 使用拦截器覆盖Array原型"></a>3.3 使用拦截器覆盖Array原型</h3><p>有了拦截器之后，想要使他生效，需要去覆盖Array.prototype，但是又不能直接去覆盖，因为这样会污染全局Array。我们只希望拦截那些响应式数组的原型。将数据转换为响应式的，需要通过Observer，所以只需要在Observer中使用拦截器覆盖那些即将被转换成响应式Array类型的数据的原型就好了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(value))&#123;</span><br><span class="line">      value.__proto__ = arrayMethods;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.walk(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-将拦截器方法挂载到数组的属性上"><a href="#3-4-将拦截器方法挂载到数组的属性上" class="headerlink" title="3.4 将拦截器方法挂载到数组的属性上"></a>3.4 将拦截器方法挂载到数组的属性上</h3><p>因为不是所以浏览器都支持__proto__属性，因此，如果不能使用__proto__属性，就直接将arrayMethods身上的这些方法设置到被侦测的数组上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; arrayMethods &#125; <span class="keyword">from</span> <span class="string">&#x27;./array&#x27;</span></span><br><span class="line"><span class="comment">//__proto__是否可用</span></span><br><span class="line"><span class="keyword">const</span> hasProto = <span class="string">&#x27;__proto__&#x27;</span> <span class="keyword">in</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> arrayKeys = <span class="built_in">Object</span>.getOwnPropertyNames(arrayMethods);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.value = value;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(value))&#123;</span><br><span class="line">    <span class="comment">//修改</span></span><br><span class="line">    <span class="keyword">const</span> augment = hasProto ? protoAugment : copyAugment;</span><br><span class="line">    augment(value, arrayMethods, arrayKeys );</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.walk(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">protoAugment</span>(<span class="params">target, src, keys</span>)</span>&#123;</span><br><span class="line">  target.__proto__ = src</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyAugment</span>(<span class="params">target, src, keys</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>,l=keys.length; i&lt;l; i++)&#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i];</span><br><span class="line">    def(target, key, src[key])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用hasProto判断浏览器是否支持__proto__：如果支持，则使用protoAugment函数来覆盖原型；如果不支持，则调用copyAugment函数将拦截器中的方法挂载到value上。</p><h3 id="3-5-如何收集依赖？"><a href="#3-5-如何收集依赖？" class="headerlink" title="3.5 如何收集依赖？"></a>3.5 如何收集依赖？</h3><p>list:[1,2,3,4,5]<br>不管value是什么，想要获取一个object某个属性的数据，要通过key来读取value，因此在读取list的时候，会触发这个名字叫做list的属性的getter，比如：this.list<br>Array的依赖和Object一样，也在defineReactive中收集：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, val</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">new</span> Observer(val)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">  <span class="built_in">Object</span>.definedProperty(data, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      dep.depend();</span><br><span class="line">      <span class="comment">//这里收集Array的依赖</span></span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(val === newVal)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal;</span><br><span class="line">      dep.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，Array在getter中收集依赖，在拦截器中触发依赖</p><h3 id="3-6-依赖列表存在哪儿？"><a href="#3-6-依赖列表存在哪儿？" class="headerlink" title="3.6 依赖列表存在哪儿？"></a>3.6 依赖列表存在哪儿？</h3><p>vue.js把Array的依赖存放在Observer中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep(); <span class="comment">//新增dep</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(value))&#123;</span><br><span class="line">      <span class="keyword">const</span> augment = hasProto ? protoAugment : copyAugment;</span><br><span class="line">      augment(value, arrayMethods, arrayKeys );</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.walk(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组在getter中收集依赖，在拦截器中触发依赖，所以这个依赖保存位置很关键，必须在getter和拦截器中都可以访问到。<br>之所以将依赖保存在Observer，是因为在getter中可以访问到Observer实例，在Array拦截中可以访问到Observer实例。</p><h3 id="3-7-收集依赖"><a href="#3-7-收集依赖" class="headerlink" title="3.7 收集依赖"></a>3.7 收集依赖</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, val</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> childOb = observe(val); <span class="comment">//修改</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">  <span class="built_in">Object</span>.definedProperty(data, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      dep.depend();</span><br><span class="line">      <span class="comment">//这里收集Array的依赖</span></span><br><span class="line">      <span class="keyword">if</span>(childOb)&#123;</span><br><span class="line">        childOb.dep.depend();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(val === newVal)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal;</span><br><span class="line">      dep.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//尝试为value创建一个Observer实例</span></span><br><span class="line">  <span class="comment">//如果创建成功直接然后新创建的实例</span></span><br><span class="line">  <span class="comment">//如果value已经存在一个observer实例则直接返回它</span></span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">value, asRootData</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!isObject(value)) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> ob;</span><br><span class="line">    <span class="keyword">if</span>(hasOwn(value, <span class="string">&#x27;__ob__&#x27;</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer)&#123;</span><br><span class="line">      ob = value.__ob__;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      ob = <span class="keyword">new</span> Observer(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ob</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="3-8-在拦截器中获取Observer实例"><a href="#3-8-在拦截器中获取Observer实例" class="headerlink" title="3.8 在拦截器中获取Observer实例"></a>3.8 在拦截器中获取Observer实例</h3><p>因为Array拦截器是对原型的一种封装，所以可以在拦截器中访问到this。而dep保存在Observer中，所以需要在this上读到Observer的实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">def</span>(<span class="params">obj, key, val, enumerable</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    value: val,</span><br><span class="line">    enumerable: !!enumerable,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep();</span><br><span class="line">    def(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="built_in">this</span>);<span class="comment">//新增</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(value))&#123;</span><br><span class="line">      <span class="keyword">const</span> augment = hasProto ? protoAugment : copyAugment;</span><br><span class="line">      augment(value, arrayMethods, arrayKeys);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.walk(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>def函数在value上新增一个不可枚举的属性__ob__，这个属性就是当前Observer实例。这个属性既可以用来在拦截器中访问Observer实例，还可用来标记是否已被Observer转换成响应式数据。<br>当value被标记来__ob__后可以通过value.__ob__来访问observer实例，如果是Array拦截器，拦截器是原型方法，可以通过this.__ob__来访问Observer实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line"><span class="string">&#x27;push&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> original = arrayProto[method]; <span class="comment">//缓存原始方法</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(arrayMethods, method, &#123;</span><br><span class="line">  value: <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="built_in">this</span>.__ob__; <span class="comment">//新增</span></span><br><span class="line">    <span class="keyword">return</span> original.apply(<span class="built_in">this</span>, args);</span><br><span class="line">  &#125;,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在mutator函数中可以通过this.__ob__来获取Observer实例。</p><h3 id="3-9-向数组的依赖发送通知"><a href="#3-9-向数组的依赖发送通知" class="headerlink" title="3.9 向数组的依赖发送通知"></a>3.9 向数组的依赖发送通知</h3><p>当侦测到数组变化时，需要向依赖发送通知，首先要能访问到依赖。前面已可以在拦截器中访问Observer实例，只需要在Observer实例中拿到dep属性就可以发送通知了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line"><span class="string">&#x27;push&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> original = arrayProto[method]; <span class="comment">//缓存原始方法</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(arrayMethods, method, &#123;</span><br><span class="line">  value: <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = original.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="built_in">this</span>.__ob__; </span><br><span class="line">    ob.dep.notify();<span class="comment">//向依赖发送消息</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="3-10-侦测数组元素的变化"><a href="#3-10-侦测数组元素的变化" class="headerlink" title="3.10 侦测数组元素的变化"></a>3.10 侦测数组元素的变化</h3><p>前面说侦测数组的变化指的是数组自身的变化，比如是否新增一个元素，是否删除一个元素，其实数组中object上某个属性发送变化也需要发送通知。比如使用push新增一个元素，这个元素的变化也需要侦测。</p><p>在observer新增一些处理，让它可以将array也转换响应式的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    def(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新增</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(value))&#123;</span><br><span class="line">      <span class="built_in">this</span>.observerArray(value);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.walk(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 侦测Array中的每一项</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observerArray</span>(<span class="params">items</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++)&#123;</span><br><span class="line">    observe(items[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>observerArray方法作用是循环Array中的每一项，执行observe函数来侦测变化。<br>observe函数就是将数组的每个元素都执行一遍new Observer，是一个递归过程。</p><h3 id="3-11-侦测新增元素的变化"><a href="#3-11-侦测新增元素的变化" class="headerlink" title="3.11 侦测新增元素的变化"></a>3.11 侦测新增元素的变化</h3><p>数组中一些方法比如push可以新增内容，新增的内容也需要转换成响应式的来侦测变化，否则出现修改数组无法触发消息等问题。</p><p>只需要获取新增元素并使用Observer来侦测他们就行。</p><h4 id="3-11-1-获取新增元素"><a href="#3-11-1-获取新增元素" class="headerlink" title="3.11.1 获取新增元素"></a>3.11.1 获取新增元素</h4><p>获取新增元素需要在拦截器中数组方法的类型进行判断。如果数组方法是push，unshift,splice（可以新增数组元素的方法），则把参数中新增的元素拿过来，用Observer侦测：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line"><span class="string">&#x27;push&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> original = arrayProto[method]; <span class="comment">//缓存原始方法</span></span><br><span class="line"></span><br><span class="line">def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = original.apply(<span class="built_in">this</span>,args);</span><br><span class="line">  <span class="keyword">const</span> ob = <span class="built_in">this</span>.__ob__;</span><br><span class="line">  <span class="keyword">let</span> inserted;</span><br><span class="line">  <span class="keyword">switch</span>(method)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line">      inserted = args;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">      inserted = args.slice(<span class="number">2</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ob.dep.notify();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过swtich对method进行判断，将新增元素取处理，暂存在inserted中</p><h4 id="3-11-2-使用observer侦测新增元素"><a href="#3-11-2-使用observer侦测新增元素" class="headerlink" title="3.11.2 使用observer侦测新增元素"></a>3.11.2 使用observer侦测新增元素</h4><p>Observer会将自身实例附加到value的<strong>ob__属性上，所以被侦测了变化的数据都有一个__ob__属性，数组元素也不例外。<br>因此可以在拦截器中访问到this.__ob</strong>,然后调用__ob__上的observeArray方法就可以了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line"><span class="string">&#x27;push&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> original = arrayProto[method]; <span class="comment">//缓存原始方法</span></span><br><span class="line"></span><br><span class="line">def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = original.apply(<span class="built_in">this</span>,args);</span><br><span class="line">  <span class="keyword">const</span> ob = <span class="built_in">this</span>.__ob__;</span><br><span class="line">  <span class="keyword">let</span> inserted;</span><br><span class="line">  <span class="keyword">switch</span>(method)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line">      inserted = args;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">      inserted = args.slice(<span class="number">2</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(inserted) ob.observeArray(inserted); <span class="comment">//新增</span></span><br><span class="line">  ob.dep.notify();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="3-12-关于Array的问题"><a href="#3-12-关于Array的问题" class="headerlink" title="3.12 关于Array的问题"></a>3.12 关于Array的问题</h3><p>Array的变化侦测是通过拦截原型的方式实现的。所以：<br>this.list[0] = 2;<br>this.list.length = 0;<br>以上2中修改数组不会触发重新渲染和watch。<br>vue.js的实现方法决定了无法对以上2中作拦截也就没办法响应。但可以通过:<br>this.list.splice(0,0,item);<br>vm.$set(list,0,item);<br>实现数据响应</p><h3 id="3-13-总结"><a href="#3-13-总结" class="headerlink" title="3.13 总结"></a>3.13 总结</h3><p>Array追踪变化的方式和Object不一样，他是通过创建拦截器去覆盖数组原型的方式来追踪变化。</p><p>为了不污染全局Array.prototype，在Observer中只针对需要侦测数据变化的数组使用__proto__来覆盖原型方法。但__proto__不是所有浏览器都支持它，针对不支持它的浏览，直接循环拦截器，把拦截器中方法设置到数组身上来拦截Array.prototype上的原生方法。</p><p>Array收集依赖方式和Object一样，都在getter中收集。但是因为数组要在拦截器中向依赖发送消息，所以把依赖保存在来Observer实例上。</p><p>在Observer中对每个侦测数据变化的数据加上__ob__标记，并把this保存在__ob__上，一方面为了标记数据已被侦测（防止重复侦测），另一方面可以通过__ob__拿到Observer实例，从而获取实例上的依赖，以便在拦截器中发送通知向依赖。</p><p>除了数组自身变化外，使用observeArray方法将数组每个元素都转换为响应式的并侦测变化。</p><p>除了侦测已有数据外，当新增元素时也需要进行变化侦测，根据数组方法提取新增元素，然后使用observeArray方法对新增元素进行变化侦测。</p><p>根据下标修改数组元素或者使用length清空数组操作无法拦截。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-2.Object的变化侦测</title>
      <link href="/ZJY.github.io/2021/04/20/vue-2-Object%E7%9A%84%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/"/>
      <url>/ZJY.github.io/2021/04/20/vue-2-Object%E7%9A%84%E5%8F%98%E5%8C%96%E4%BE%A6%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="vue-2-Object的变化侦测"><a href="#vue-2-Object的变化侦测" class="headerlink" title="vue-2.Object的变化侦测"></a>vue-2.Object的变化侦测</h2><h3 id="2-1-什么是变化侦测？"><a href="#2-1-什么是变化侦测？" class="headerlink" title="2.1 什么是变化侦测？"></a>2.1 什么是变化侦测？</h3><p>从状态生成dom，再输出到用户界面显示的一整套流程叫渲染，应用在运行时会不停的进行重新渲染。<br>响应式系统的核心是变化侦测，侦测数据的变化，数据变化时，会通知视图进行响应的更新。</p><p>vue.js会自动通过状态生成dom，并将其输出到页面显示出来，这个过程叫做渲染。vue<br>.js的渲染是声明式的，通过模版来描述状态与dom之间的映射关系。<br>变化侦测分为两种类型：一种是“推”（push），一种是“拉”（pull）。</p><p>Angular和React中的变化都属于“拉”，这就是说当状态发生变化时，他不知道哪个状态变来，只知道状态可能变了，然后发送一个信号告诉框架，框架内部接收到信号后，会进行一个暴力对比来找出哪些dom节点需要重新渲染。在Angular中是脏检查的流程，在React中使用的是虚拟dom。</p><p>而Vue.js的变化侦测属于“推”。当状态变化时，vue.js就立刻知道了，且在一定程序上知道哪些状态变了。因此它知道的信息更多，就可以进行更细粒度的更新。</p><p>更细粒度的更新：如果一个状态绑定着好多个依赖，每个依赖表示一个具体的dom节点，那么当这个状态发送变化时，向这个状态的所有依赖发送通知，让他们进行dom更新操作。相比较而言，“拉”的粒度是最粗的。</p><p>但是有一定的代价，粒度越细，绑定的依赖就越多，依赖追踪在内存上的开销就越大。因此，从vue.js2.0开始它引入了虚拟dom，将粒度调整为中等粒度，即一个状态所绑定的依赖不再是dom节点，而是一个组件，这样状态变化后，会通知到组件，组件内部在使用虚拟dom进行对比。这可以大大降低依赖数量，从而降低依赖追踪所消耗的内存。</p><h3 id="2-2如何追踪变化"><a href="#2-2如何追踪变化" class="headerlink" title="2.2如何追踪变化"></a>2.2如何追踪变化</h3><p>如何侦测一个对象的变化？<br>使用Object.definedProperty和es6的Proxy</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, val</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">    eumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(val === newVal)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      val = newVal;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当从data中key读取数据时，get函数被触发；当往data的key中设置数据时，set函数被触发。</p><h3 id="2-3-如何收集依赖？"><a href="#2-3-如何收集依赖？" class="headerlink" title="2.3 如何收集依赖？"></a>2.3 如何收集依赖？</h3><p>在getter中收集依赖，在setter中触发依赖。</p><h3 id="2-4-依赖收集到哪里？"><a href="#2-4-依赖收集到哪里？" class="headerlink" title="2.4 依赖收集到哪里？"></a>2.4 依赖收集到哪里？</h3><p>每个key都有一个数组，用来存储当前key的依赖。假设依赖是一个函数，保存在window.target上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dep = []; <span class="comment">//新增</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">        eumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            dep.push(<span class="built_in">window</span>.target); <span class="comment">//新增</span></span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (val === newVal) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//新增</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dep.length; i++) &#123;</span><br><span class="line">                dep[i](newVal, val);</span><br><span class="line">            &#125;</span><br><span class="line">            val = newVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增数组dep，用来存储被收集的依赖，然后在set被触发时，循环dep以触发收集到的依赖。</p><p>将收集依赖的代码封装到一个Dep类，专门用来帮助我们管理依赖。使用这个类。可以收集依赖、删除依赖、通知依赖等。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subs = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">addSub</span>(<span class="params">sub</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.subs.push(sub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">removeSub</span>(<span class="params">sub</span>)</span> &#123;</span><br><span class="line">        remove(<span class="built_in">this</span>.subs, sub);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">depend</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">window</span>.target) &#123;</span><br><span class="line">            <span class="built_in">this</span>.addSub(<span class="built_in">window</span>.target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">notify</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> subs = <span class="built_in">this</span>.subs.slice();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">            subs[i].update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length) &#123;</span><br><span class="line">            <span class="keyword">let</span> index = arr.indexOf(item);</span><br><span class="line">            <span class="keyword">if</span> (index &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> arr.splice(index, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再改造下definedReactive：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep(); <span class="comment">//修改</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">        eumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            dep.depend(); <span class="comment">//修改</span></span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (val === newVal) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            val = newVal;</span><br><span class="line">            dep.notify(); <span class="comment">//新增</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将依赖收集到Dep中。</p><h3 id="2-5-依赖是谁？"><a href="#2-5-依赖是谁？" class="headerlink" title="2.5 依赖是谁？"></a>2.5 依赖是谁？</h3><p>在上面代码中，我们收集的依赖是window.target，那么它到底是谁呢？<br>当属性发送变化时，通知谁，就是收集的依赖。</p><p>我们要通知到用到数据的地方，这个用到数据的地方很多，而且类型还不一样，有可能是模版，也有可能是用户写的一个watch，这时需要抽象出一个集中处理这些情况的类。然后在收集依赖阶段只收集这个封装好的类的实例进来，通知也只通知它一个，接着，它负责通知其他地方。这个类就是Watcher,收集的就是watcher。</p><h3 id="2-6-什么是Watcher？"><a href="#2-6-什么是Watcher？" class="headerlink" title="2.6 什么是Watcher？"></a>2.6 什么是Watcher？</h3><p>Watcher是一个中介角色，当数据变化时通知它，它再通知其他地方。<br>关于Watcher，看一个经典的使用方式：<br>vm.$watch(‘data.b.c’, function (newVal, oldVal){});<br>当data.b.c属性发生变化时，触发第二个参数中的函数。<br>把这个watcher实例添加到data.b.c的属性依赖Dep中，当data.b.c的值发生变化时，通知watcher，接着，watcher再执行回调函数。<br>代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">vm, expOrFn, cb</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.vm = vm;</span><br><span class="line">    <span class="comment">//执行this.getter()可以读取data.b.c的内容</span></span><br><span class="line">    <span class="built_in">this</span>.getter = parsePath(expOrFn);</span><br><span class="line">    <span class="built_in">this</span>.cb = cb;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.get();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.target = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="built_in">this</span>.getter.call(<span class="built_in">this</span>.vm, <span class="built_in">this</span>.vm);</span><br><span class="line">    <span class="built_in">window</span>.target = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">update</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> oldValue = <span class="built_in">this</span>.value;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.get();</span><br><span class="line">    <span class="built_in">this</span>.cb.call(<span class="built_in">this</span>.vm, <span class="built_in">this</span>.value, oldValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在get方法中将this也就是watcher实例添加到window.target，然后读取data.b.c的值，会触发getter，然后触发依赖收集。这就导致将watcher实例赋给window.target然后再读取以下值触发getter就能将this添加到Dep依赖中。</p><p>依赖注入到Dep后，当data.b.c发生变化时，就会让依赖列表中的依赖循环触发update方法，也就是watcher中的update方法，而update方法会执行参数中的回调函数将value和oldValue传到参数中。</p><p>所以不管是用户执行vm.$watch还是模版中的data都是通过watcher来通知自己是否需要发生变化。</p><h3 id="2-7-递归侦测所有的key"><a href="#2-7-递归侦测所有的key" class="headerlink" title="2.7 递归侦测所有的key"></a>2.7 递归侦测所有的key</h3><p>前面介绍代码只能侦测数据中的一个属性，如果希望将数据中的所以属性都侦测到，所以要封装一个Observer类，将数据内的所以属性都转换成getter/setter形式，然后去追踪他们的变化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.walk(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//walk会将每一个属性都转换成getter/setter形式来追踪变化，只有数据类型为object时被调用</span></span><br><span class="line">    <span class="function"><span class="title">walk</span>(<span class="params">obj</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">            defineReactive(obj, keys[i], obj[keys[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">data, key, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> Observer(val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">    <span class="built_in">Object</span>.definedProperty(data, key, &#123;</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            dep.depend();</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        set: <span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (val === newVal) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            val = newVal;</span><br><span class="line">            dep.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Observer类可以将一个object对象转换为可侦测的object（通过walk方法将属性转换getter/setter形式），在defineReactive中用new Observer(val)来递归子属性，这样可以把data中所以属性都转换为getter/setter形式来追踪变化。当data中属性发生变化时，就会通知对于依赖进行更新。</p><h3 id="2-8-关于Object的问题"><a href="#2-8-关于Object的问题" class="headerlink" title="2.8 关于Object的问题"></a>2.8 关于Object的问题</h3><p>vue.js通过Object.definedProperty来将对象的key转换为getter/setter形式来追踪变化，但getter/setter只追踪一个数据是否被修改，无法追踪属性的新增和删除。为来解决这个问题，vue.js提供来2个api：vm.$set和vm.$delete。</p><h3 id="2-9-总结"><a href="#2-9-总结" class="headerlink" title="2.9 总结"></a>2.9 总结</h3><p>Object可以通过Object.definedProperty将属性转换成getter/setter的形式来追踪变化。读取数据时会触发getter，修改数据时会触发setter。</p><p>我们需要在getter中收集有哪些依赖发生了变化。当setter触发时，去通知getter中收集的依赖数据发生了变化。</p><p>收集依赖需要为依赖找一个存储的地方，即Dep，它用来收集依赖、删除依赖、通知依赖更新等。</p><p>所谓的依赖，可能vue实例，组件的一个属性、模版中的表达式或者watch监听，把它抽象为Watcher类，只有watcher触发的getter才会被收集，哪个watcher触发了getter，就把它收集到Dep中，当数据发生变化，就循环依赖列表通知所有watcher。</p><p>Watcher的原理是先把自己设置到全局唯一指定的地方（window.target），然后读取数据，触发getter，接着，getter中就会从全局唯一指定的地方去获取当前正在读取数据的watcher，并把这个watcher收集到Dep中，通过这样方式，Watcher可以主动去订阅任意一个数据的变化。</p><p>此外，Observer类把一个object中给的所有数据包括子数据都转换成响应式的。但是在对象上新增或删除属性都无法被追踪到。</p><p>如下图，Data、Observer、Dep、Watcher之间关系。</p><p><img src="/ZJY.github.io/images/vue-data.png" alt="image"></p><p>vue双向数据绑定的原理：</p><p>通过数据劫持和发布订阅模式实现。对数据的各个属性的读取和修改进行拦截，并在数据发生变化时发布消息给相关订阅者进行更新。</p><p>1、实现一个Observer（观察者）类，用来劫持并监听所有属性，如果数据变动，触发setter，通知相关依赖中的watcher进行更新。</p><p>2、实现一个解析器Compile，解析指令，将模版中的变量替换成数据，然后初始化渲染页面视图；并将每个指令对应的节点绑定对应的更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。</p><p>3、实现一个Watcher订阅者，作为compile和Observer之间通信的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图。</p><p>4、Dep依赖收集器，每个属性都有一个Dep实例，内部维护了一个数组，用来存储所有订阅了该属性的Watcher。</p><p>Data通过Observer转换成getter/setter形式来追踪变化。<br>当外界通过Watcher读取数据时，会触发getter从而将watcher添加到依赖中。<br>当数据发生变化，会触发setter，从而向Dep中的依赖（Watcher）发送通知。<br>Watcher接收到通知后，会向外界发送通知，变化通知到外界可能会触发视图更新，也有可能触发用户某个回调函数。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css中position属性</title>
      <link href="/ZJY.github.io/2021/04/14/css%E4%B8%ADposition%E5%B1%9E%E6%80%A7/"/>
      <url>/ZJY.github.io/2021/04/14/css%E4%B8%ADposition%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="position"><a href="#position" class="headerlink" title="position"></a>position</h2><p>position属性用于指定一个元素在文档中定位方式。top,left,right,bottom属性则决定了元素的最终位置。</p><h3 id="1-定位类型"><a href="#1-定位类型" class="headerlink" title="1.定位类型"></a>1.定位类型</h3><p>定位元素是定位为relative,absolute,fixed,sticky的一个元素，也就是除static外的定位元素。</p><p>相对定位：relative<br>绝对定位：absolute/fixed<br>粘性定位：sticky</p><p>如果top和bottom都指定了，top优先<br>如果left和right都指定了，当direction设置为ltr时，left优先，当directin设置rtl时，right优先。</p><h3 id="2-取值"><a href="#2-取值" class="headerlink" title="2.取值"></a>2.取值</h3><p><b>static</b><br>该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。</p><p><b>relative</b><br>该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。position:relative 对 table-*-group, table-row, table-column, table-cell, table-caption 元素无效。</p><p>相对定位的元素是在文档中的正常位置偏移给定的值，但是不影响其他元素的偏移。</p><p><b>absolute</b><br>元素会被移出正常文档流，并不为元素预留空间，通过指定元素相对于最近的非static定位的父元素进行偏移，来确定元素的位置。绝对定位元素可以设置margin外边距且不会与其他边距合并。</p><p>相对定位的元素并未脱离文档流，而绝对定位的元素则脱离了文档流。在布置文档流中其它元素时，绝对定位元素不占据空间。绝对定位元素相对于最近的非 static 祖先元素定位。当这样的祖先元素不存在时，则相对于ICB（inital container block, 初始包含块）</p><p><b>fixed</b><br>元素会被移出正常文档流，并不为元素预留空间。通过指定元素相对于视窗来进行定位，元素的位置在页面滚动时不会改变。打印时，元素出现在每页的固定位置。fixed会创建新的层叠上下文，当元素祖先的transform,perspective或filter属性不为none时，容器定位由视窗变为该祖先。</p><p>固定定位与绝对定位相似，但元素的包含块为 viewport 视口</p><p><b>sticky</b><br>元素根据正常文档流进行定位，然后相对它的最近滚动祖先和最近块级祖先，包括table-related元素，基于top, right, bottom, 和 left的值进行偏移。偏移值不会影响任何其他元素的位置。该值总是创建一个新的层叠上下文（stacking context）</p><p>粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。</p><p>#one { position: sticky; top: 10px; }</p><p>在 viewport 视口滚动到元素 top 距离小于 10px 之前，元素为相对定位。之后，元素将固定在与顶部距离 10px 的位置，直到 viewport 视口回滚到阈值以下</p><p>粘性定位常用于定位字母列表的头部元素。标示 B 部分开始的头部元素在滚动 A 部分时，始终处于 A 的下方。而在开始滚动 B 部分时，B 的头部会固定在屏幕顶部，直到所有 B 的项均完成滚动后，才被 C 的头部替代。</p><p>须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css中的z-index属性</title>
      <link href="/ZJY.github.io/2021/04/11/css%E4%B8%AD%E7%9A%84z-index%E5%B1%9E%E6%80%A7/"/>
      <url>/ZJY.github.io/2021/04/11/css%E4%B8%AD%E7%9A%84z-index%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="1-z-index基础概念"><a href="#1-z-index基础概念" class="headerlink" title="1.z-index基础概念"></a>1.z-index基础概念</h3><p>通过设置定位及 top，left，bottom 和 right 的值，你可以在二维空间中对元素进行定位，但 CSS 同时也允许你使用 z-index 属性把它放置在三维空间中。</p><p>x 轴代表水平方向，y 轴代表垂直方向，z 轴则代表我们的目光向页面（屏幕）看进去的时候，各元素的布局情况</p><p>为了决定某个元素在 z 轴方向上的位置，CSS 允许我们为 z-index 属性设置三种值：</p><ul><li>auto默认值</li><li>整数</li><li>inherit</li></ul><p>看整数值：它可以是正整数、负整数或者 0，值越大，元素就离我们“越近”，值越小，元素自然也就离我们“越远”</p><h3 id="2-层叠上下文"><a href="#2-层叠上下文" class="headerlink" title="2.层叠上下文"></a>2.层叠上下文</h3><p>每个网页都会默认创建一个层叠上下文，这个上下文的根部就是html元素，html元素的所有子元素都会默认在上下文中的某个层叠等级。</p><p>当你给某个元素设置z-index值非auto时，就会创建一个新的层叠上下文。它和它所包含的层叠等级都是独立于其他层叠上下文和层叠等级的。</p><p>在一个层叠上下文中，一共可能出现七个层叠等级，从低到高排序依次是：</p><ul><li>1.背景和边框：形成层叠上下文的元素的背景和边框，它是整个上下文中层叠等级最低的。</li><li>2.z-index为负数：设置了 z-index 为负数的子元素以及由它所产生的层叠上下文</li><li>3.块级盒模型：位于正常文档流中的、块级的、非定位的子元素</li><li>4.浮动盒模型：浮动的、非定位的子元素</li><li>5.内联盒模型：位于正常文档流中的、内联的、非定位的子元素</li><li>6.z-index为0：设置了 z-index 为 0 的、定位的子元素以及由它所产生的层叠上下文</li><li>7.z-index为正数:设置了 z-index 为正数的、定位的子元素以及由它所产生的层叠上下文，它是整个上下文中层叠等级最高的</li></ul><p>大部分元素的层级都要低于 z-index:0。</p><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;one&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;two&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;three&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;four&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.one</span>, <span class="selector-class">.two</span>, <span class="selector-class">.three</span>, <span class="selector-class">.four</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f00</span>;</span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">5px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="selector-class">.two</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#0f0</span>;</span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">5px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">75px</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.three</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#0ff</span>;</span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">5px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">125px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">25px</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">150</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="selector-class">.four</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#00f</span>;</span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">5px</span> solid <span class="number">#ff0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">350px</span>;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">50</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管 div.two 有更高的 z-index（100），但在页面上，它的层级实际上比 div.four （z-index 为50）要低<br>由于 div.two  位于 div.one 中，所以它的 z-index 是和 div.one 的层叠上下文相关的，也就是说，实际表现出来的 z-index 是下面这样的：</p><ul><li>.one —— z-index = 10</li><li>.two —— z-index = 10.100</li><li>.three —— z-index = 10.150</li><li>.four —— z-index = 50</li></ul><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><p>定位元素可以创建新的层叠上下文，在这个上下文中的所有层叠等级，都会高于或者低于另一个层叠上下文的所有层叠等级</p><h3 id="4-补充"><a href="#4-补充" class="headerlink" title="4.补充"></a>4.补充</h3><p>fixed 属性会创建新的层叠上下文。当元素祖先的 transform, perspective 或 filter 属性非 none 时，容器由视口改为该祖先，相对于该祖先进行定位。</p><h3 id="5-堆叠上下文"><a href="#5-堆叠上下文" class="headerlink" title="5.堆叠上下文"></a>5.堆叠上下文</h3><p>以下情况可形成堆叠上下文：</p><ul><li>文档的根元素(hmtl)</li><li>position为absolute/relative且z-index不为auto的元素</li><li>position为fixed或sticky的元素</li><li>flex容器的子元素且z-index不为auto</li><li>grid容器的子元素且z-index不为auto</li><li>opacity属性值小于 1 的元素</li><li>mix-blend-mode 属性值不为 normal 的元素；</li><li>以下任意属性值不为 none 的元素：<ul><li>transform</li><li>filter</li><li>perspective</li><li>clip-path</li><li>mask / mask-image / mask-border</li></ul></li><li>isolation 属性值为 isolate 的元素；</li><li>-webkit-overflow-scrolling 属性值为 touch 的元素；</li><li>will-change 值设定了任一属性而该属性在 non-initial 值时会创建层叠上下文的元素；</li><li>contain 属性值为 layout、paint 或包含它们其中之一的合成值（比如 contain: strict、contain: content）的元素。</li></ul><p>总结:</p><p>层叠上下文可以包含在其他层叠上下文中，并且一起创建一个层叠上下文的层级。<br>每个层叠上下文都完全独立于它的兄弟元素：当处理层叠时只考虑子元素。<br>每个层叠上下文都是自包含的：当一个元素的内容发生层叠后，该元素将被作为整体在父级层叠上下文中按顺序进行层叠。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css中的文档流/浮动/定位</title>
      <link href="/ZJY.github.io/2021/04/11/css%E4%B8%AD%E7%9A%84%E6%96%87%E6%A1%A3%E6%B5%81-%E6%B5%AE%E5%8A%A8-%E5%AE%9A%E4%BD%8D/"/>
      <url>/ZJY.github.io/2021/04/11/css%E4%B8%AD%E7%9A%84%E6%96%87%E6%A1%A3%E6%B5%81-%E6%B5%AE%E5%8A%A8-%E5%AE%9A%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="1-标准流"><a href="#1-标准流" class="headerlink" title="1.标准流"></a>1.标准流</h3><p>在标准流中有两种排版方式, 一种是垂直排版, 一种是水平排版<br>（1）垂直排版, 如果元素是块级元素, 那么就会垂直排版<br>（2）水平排版, 如果元素是行内元素/行内块级元素, 那么就会水平排版</p><h3 id="2-浮动流"><a href="#2-浮动流" class="headerlink" title="2.浮动流"></a>2.浮动流</h3><p>浮动流只有一种排版方式, 就是水平排版. 它只能设置某个元素左对齐或者右对齐<br>浮动元素碰到包含它的边框或者浮动元素的边框停留。<br>注意：如果浮动元素的父元素设置了padding值，那么浮动元素不会占用父元素的padding区域</p><p>float属于半脱离文档流，float和position:absolute/fixed一样会脱离文档流，但浮动脱离文档流仍然占据位置，其后的文本内容会按照顺序排列。</p><h3 id="3-定位"><a href="#3-定位" class="headerlink" title="3.定位"></a>3.定位</h3><ul><li>postision：static;始终处于文档流给予的位置。看起来好像没有用，但它可以快速取消定位，让 top，right，bottom，left 的值失效。在切换的时候可以尝试这个方法。</li><li>postision:relative;相对于自身位置定位，仍处于文档流中，元素的宽高不变，设置偏移量也不会影响其他元素的位置，如果最外层设置relative，在没有设置宽度情况，元素宽度是整个浏览器的宽度</li><li>postision:absolute;相对于离自己最近的设置了相对或绝对定位的父元素定位，如果没有父元素设置相对和绝对定位，则相对于跟元素html定位，设置了绝对定位的元素脱离了文档流，如果没有设置宽高由元素内容决定，脱离后元素位置是空的下面的元素会占据.</li><li>postision:fixed：相对于浏览器窗口定位,如果没有设置宽高由元素内容决定。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>script标签的加载和执行</title>
      <link href="/ZJY.github.io/2021/04/11/script%E6%A0%87%E7%AD%BE%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/"/>
      <url>/ZJY.github.io/2021/04/11/script%E6%A0%87%E7%AD%BE%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="1-script标签是如何加载的？"><a href="#1-script标签是如何加载的？" class="headerlink" title="1.script标签是如何加载的？"></a>1.script标签是如何加载的？</h3><ul><li>当浏览器遇到一个script标签时，会暂停页面渲染，运行javascript代码，然后再继续解析渲染页面；</li><li>当遇到外部javascript脚本时，浏览器首先下载外部js代码，会占用一部分时间，然后运行js代码，此过程中，页面解析渲染和用户交互是阻塞的。</li></ul><h3 id="2-script标签应放在何处？"><a href="#2-script标签应放在何处？" class="headerlink" title="2.script标签应放在何处？"></a>2.script标签应放在何处？</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;file1.js&quot;</span> /&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;file2.js&quot;</span> /&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;file3.js&quot;</span> /&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span></span><br></pre></td></tr></table></figure><p>可以看出，在head中引入3个外部js文件，首先第一个js文件开始下载，占用一部分时间，并阻塞其他js文件的下载。file1.js文件下载完成后，又消耗一部分时间用来完全执行此js代码。然后才是file2.js文件下载，执行，file3.js文件下载，执行。每个文件都需要等到前一个js文件下载完成并执行完毕才能开始自己的下载过程。这些文件下载时，用户屏幕会出现空白，有明显的延迟。且浏览器遇到body标签之前不会渲染页面任何部分。将外部js放在head会导致一个明显的延迟，打开页面首先会出现空白，用户既不能阅读也不能与之交互，体验非常不好。</p><p>随着浏览器的发展，浏览器允许并行下载js文件。当一个script标签正在下载资源时，不必阻塞别的script标签。<br>但是script标签的下载仍要阻塞其他资源的下载，如图片，样式表。即使脚本下载过程不互相阻塞，页面仍需等到所有js资源下载并执行完毕才能继续。所以，当浏览器通过允许并行下载提高性能之后，该问题并没有完全解决。脚本阻塞仍旧是一个问题。</p><p>脚本阻塞其他资源的下载过程，推荐将script标签放在body结束标签的前面。</p><h3 id="3-非阻塞脚本"><a href="#3-非阻塞脚本" class="headerlink" title="3.非阻塞脚本"></a>3.非阻塞脚本</h3><p>非阻塞脚本就是等页面加载完成之后，再加载js。</p><p>1.defer属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;file1.js&quot;</span> <span class="attr">defer</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>此script标签可以放在页面任何位置，解析到script标签时会立即下载此js文件，但会等到页面加载完成后再执行此js文件<br>只对外部js脚本有效，HTML5规范要求脚本按照它们出现的先后顺序执行。<br>延迟脚本会按他们在文档里的出现顺序执行</p><p>2.async属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;file1.js&quot;</span> <span class="attr">async</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>不让页面等到脚本的下载和执行，从而异步加载页面其他内容。<br>下载完立即执行。不保证按照指定的先后顺序执行。只对外部js脚本有效<br>异步脚本在它们载入后执行，但是不能保证执行顺序。</p><p>图片说明script，defer，async：<br><img src="/ZJY.github.io/images/script.jpg" alt="image"></p><p>3.动态创建script标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">downloadJSAtOnload</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> element = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  element.src = <span class="string">&#x27;test.js&#x27;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.body.appendChild(element);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="javascript"><span class="keyword">if</span>(<span class="built_in">window</span>.addEventListener)&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.addEventListener(<span class="string">&quot;load&quot;</span>,downloadJSAtOnload, <span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">window</span>.attachEvent)&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.attachEvent(<span class="string">&quot;onload&quot;</span>,downloadJSAtOnload);  </span></span><br><span class="line"><span class="javascript">&#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onload =downloadJSAtOnload; </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建script，插入到DOM中，加载完毕后callBack</p><h3 id="4-为什么需要顺序加载和执行？"><a href="#4-为什么需要顺序加载和执行？" class="headerlink" title="4.为什么需要顺序加载和执行？"></a>4.为什么需要顺序加载和执行？</h3><p>因为js有可能修改dom，如果不阻塞后续资源下载，dom的操作顺序不可控</p><h3 id="5-外部样式表会不会阻塞文档解析？"><a href="#5-外部样式表会不会阻塞文档解析？" class="headerlink" title="5.外部样式表会不会阻塞文档解析？"></a>5.外部样式表会不会阻塞文档解析？</h3><p>不会<br>style-sheets 不会修改 DOM 树，没有理由为了解析 style-sheets 而阻塞文档解析（即 style-sheets 不会阻塞文档解析）。但如果在解析文档过程中有脚本需要访问样式信息时，为了保证访问样式信息的正确性。Firefox 会阻塞所有脚本直到 style-sheets 下载解析完为止。而 WebKit 只在访问的样式属性没有被加载解析时，才会阻塞脚本。</p><p>即 style-sheet 不会直接阻塞文档解析，它只阻塞 script 的解析执行，才导致 style-sheet 间接阻塞文档解析</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端安全防范</title>
      <link href="/ZJY.github.io/2021/04/10/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E9%98%B2%E8%8C%83/"/>
      <url>/ZJY.github.io/2021/04/10/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E9%98%B2%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h2 id="1-XSS"><a href="#1-XSS" class="headerlink" title="1.XSS"></a>1.XSS</h2><h3 id="1-1-什么是XSS"><a href="#1-1-什么是XSS" class="headerlink" title="1.1 什么是XSS"></a>1.1 什么是XSS</h3><p>xss就是攻击者想尽一切办法将代码注入到网页中。</p><h3 id="1-2-类型？"><a href="#1-2-类型？" class="headerlink" title="1.2 类型？"></a>1.2 类型？</h3><p>XSS 可以分为多种类型，但是总体上我认为分为两类：持久型和非持久型。</p><p>持久型：<br>攻击的代码被服务器写入数据库中，这种攻击危害性很大，网站访问量很大的情况导致大量访问正常页面的用户都受到攻击。</p><p>比如在评论功能里输入：<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>,这段评论就会被存储到数据库中，这样每个打开该页面的用户都会被攻击到。</p><p>非持久型：<br>非持久型危害没有持久型危害大，一般通过修改url参数的方式加入攻击代码，诱导用户访问连接从而进行攻击。</p><p>比如如果页面需要从 URL 中获取某些参数作为内容的话，不经过过滤就会导致攻击代码被执行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- http://www.domain.com?name=&lt;script&gt;alert(1)&lt;/script&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>对于这种方式，使用chrome会自动帮助用户防御攻击。</p><h3 id="1-3防御对策"><a href="#1-3防御对策" class="headerlink" title="1.3防御对策"></a>1.3防御对策</h3><p>对于xss攻击，可通过转义字符和CSP2种方式进行防御</p><p>1.转义字符<br>转义输入输出的内容，对于引号、尖括号、斜杠进行转义<br>但是对于富文本，这样会把需要的格式也过滤掉。<br>对于这种情况，通常采用白名单过滤的办法，就是把这段代码解析成具体的html树, 对树进行分析哪些可以保留, 最后变成html字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> xss = <span class="built_in">require</span>(<span class="string">&#x27;xss&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> html = xss(<span class="string">&#x27;&lt;h1 id=&quot;title&quot;&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert(&quot;XSS&quot;);&lt;/script&gt;&#x27;</span>);</span><br><span class="line"><span class="comment">// -&gt;&lt;h1&gt;XSS Demo&lt;/h1&gt;$lt;script&amp;gt;alert(&quot;XSS&quot;);&amp;lt;/script&amp;gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(html);</span><br></pre></td></tr></table></figure><p>2.CSP<br>CSP本质上就是建立白名单，开发者告诉浏览器哪些资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器实现的。</p><p>可通过2种方式开启CSP：<br>设置http种header中的:Content-Security-Policy<br>设置meta标签的方法<code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot; /&gt;</code></p><p>设置http header：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只允许加载本站资源：</span></span><br><span class="line">Content-Security-Policy: <span class="keyword">default</span>-src <span class="string">&#x27;self&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只允许加载https资源：</span></span><br><span class="line">Content-Security-Policy: img-src https:<span class="comment">//*</span></span><br></pre></td></tr></table></figure><h2 id="2-CSRF"><a href="#2-CSRF" class="headerlink" title="2.CSRF"></a>2.CSRF</h2><h3 id="2-1-什么是CSRF？"><a href="#2-1-什么是CSRF？" class="headerlink" title="2.1 什么是CSRF？"></a>2.1 什么是CSRF？</h3><p>CSRF跨站请求伪造，是一种挟制用户在已登录web应用程序上执行非本意操作的攻击方法。<br>Cookie 往往用来存储用户的身份信息，恶意网站可以设法伪造带有正确 Cookie 的 HTTP 请求，这就是 CSRF 攻击。<br>浏览器在访问服务器的时候会带上cookie，而第三方网站通过图片或表单提交方式也带上cookie，带上后利用用户身份进行攻击，而用户不知情。<br><code>&lt;img src=&quot;http://www.domain.com/xxx?comment=&#39;attack&#39;&quot;/&gt;</code></p><h3 id="2-2-如何防御？"><a href="#2-2-如何防御？" class="headerlink" title="2.2 如何防御？"></a>2.2 如何防御？</h3><p>1.get请求不修改数据<br>2.不让第三方网站访问到cookie，可以对 Cookie 设置 SameSite 属性。该属性表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容<br>3.请求时附带验证信息，比如验证码或者token<br>4.检查Referer字段，http请求头中referer字段表明请求来源于哪个地址，通常来说，Referer字段应和请求的地址位于同一域名下</p><h2 id="3-DDOS"><a href="#3-DDOS" class="headerlink" title="3. DDOS"></a>3. DDOS</h2><h3 id="3-1-什么是DDOS？"><a href="#3-1-什么是DDOS？" class="headerlink" title="3.1 什么是DDOS？"></a>3.1 什么是DDOS？</h3><p>短时间内发起大量请求，耗尽服务器资源，导致无法响应正常的访问，造成网站下线。</p><p>DDOS 里面的 DOS 是 denial of service（停止服务）的缩写，表示这种攻击的目的，就是使得服务中断。最前面的那个 D 是 distributed （分布式），表示攻击不是来自一个地方，而是来自四面八方，因此更难防</p><p>DDOS 不是一种攻击，而是一大类攻击的总称<br>比较常见的一种攻击是 cc 攻击。它就是简单粗暴地送来大量正常的请求，超出服务器的最大承受量，导致宕机</p><h2 id="4-SQL注入"><a href="#4-SQL注入" class="headerlink" title="4.SQL注入"></a>4.SQL注入</h2><p>SQL注入是一种代码注入的技术，攻击者可以将恶意SQL语句插入到输入字段中执行。</p><h2 id="5-加密传输"><a href="#5-加密传输" class="headerlink" title="5.加密传输"></a>5.加密传输</h2><p>加密主要有两种方式：对称加密和非对称加密。</p><ol><li>对称加密：在加密和解密时使用的是同一个秘钥。<br>对称加密的模式是：</li></ol><p>甲方选择某一种加密规则，对信息进行加密<br>乙方使用同一种规则，对信息进行解密</p><p>2.非对称加密：需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。<br>非对称加密的模式则是：</p><p>乙方生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的<br>甲方获取乙方的公钥，然后用它对信息加密<br>乙方得到加密后的信息，用私钥解密。</p><p>最经典的非对称加密算法是RSA算法。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>window.sessionStorage的理解</title>
      <link href="/ZJY.github.io/2021/04/10/window-sessionStorage%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/ZJY.github.io/2021/04/10/window-sessionStorage%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>sessionStorage 属性允许你访问一个，对应当前源的 session Storage 对象。它与 localStorage 相似，不同之处在于 localStorage 里面存储的数据没有过期时间设置，而存储在 sessionStorage 里面的数据在页面会话结束时会被清除</p><ul><li>页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话。</li><li>在新标签或窗口打开一个页面时会复制顶级浏览会话的上下文作为新会话的上下文，这点和 session cookies 的运行方式不同。<br>使用target=”_blank”的A标签，window.open打开同源的新窗口时，会把旧窗口的sessionStorage数据带过去，但新旧窗口sessionStorage数据不同步</li><li>打开多个相同的URL的Tabs页面，会创建各自的sessionStorage。</li><li>关闭对应浏览器窗口（Window）/ tab，会清除对应的sessionStorage</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue虚拟dom和diff算法</title>
      <link href="/ZJY.github.io/2021/04/10/vue%E8%99%9A%E6%8B%9Fdom%E5%92%8Cdiff%E7%AE%97%E6%B3%95/"/>
      <url>/ZJY.github.io/2021/04/10/vue%E8%99%9A%E6%8B%9Fdom%E5%92%8Cdiff%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>1.虚拟dom<br>用js对象描述dom的层级结构。虚拟dom属性和真实dom的属性一一对应。<br>vue虚拟dom参考snabbdom库实现的</p><p>diff是发生在虚拟dom上的<br>新的虚拟dom和旧的虚拟dom进行diff，算出如何最小量更新，最后反映在真正的dom上。</p><p>数据更新-&gt;虚拟dom计算变更-&gt;操作真实的dom-&gt;视图更新</p><p>一个虚拟节点有哪些属性？</p><p>{<br>  tag:’div’,<br>  props:{<br>    id:’app’,<br>    className:’’<br>  },<br>  children:[]<br>}</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  children: <span class="literal">undefined</span> , <span class="comment">//子元素</span></span><br><span class="line">  data: &#123;&#125;, <span class="comment">//属性，样式等</span></span><br><span class="line">  elm: <span class="literal">undefined</span>, <span class="comment">//真实的dom节点</span></span><br><span class="line">  key: <span class="literal">undefined</span>, <span class="comment">//唯一标识</span></span><br><span class="line">  sel: <span class="string">&quot;div&quot;</span>, <span class="comment">//选择器</span></span><br><span class="line">  text: <span class="string">&#x27;文本&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    init,</span><br><span class="line">    classModule,</span><br><span class="line">    propsModule,</span><br><span class="line">    styleModule,</span><br><span class="line">    eventListenersModule,</span><br><span class="line">    h,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;snabbdom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建出patch函数</span></span><br><span class="line"><span class="keyword">const</span> patch = init([</span><br><span class="line">    <span class="comment">// Init patch function with chosen modules</span></span><br><span class="line">    classModule, <span class="comment">// makes it easy to toggle classes</span></span><br><span class="line">    propsModule, <span class="comment">// for setting properties on DOM elements</span></span><br><span class="line">    styleModule, <span class="comment">// handles styling on elements with support for animations</span></span><br><span class="line">    eventListenersModule, <span class="comment">// attaches event listeners</span></span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;container&quot;</span>);</span><br><span class="line"><span class="comment">// 创建虚拟节点 h函数</span></span><br><span class="line"><span class="keyword">const</span> vnode = h(<span class="string">&quot;div#container.two.classes&quot;</span>, &#123; <span class="attr">on</span>: &#123; <span class="attr">click</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; &#125; &#125;, [</span><br><span class="line">    h(<span class="string">&quot;span&quot;</span>, &#123; <span class="attr">style</span>: &#123; <span class="attr">fontWeight</span>: <span class="string">&quot;bold&quot;</span> &#125; &#125;, <span class="string">&quot;This is bold&quot;</span>),</span><br><span class="line">    <span class="string">&quot; and this is just normal text&quot;</span>,</span><br><span class="line">    h(<span class="string">&quot;a&quot;</span>, &#123; <span class="attr">props</span>: &#123; <span class="attr">href</span>: <span class="string">&quot;/foo&quot;</span> &#125; &#125;, <span class="string">&quot;I&#x27;ll take you places!&quot;</span>),</span><br><span class="line">]);</span><br><span class="line"><span class="comment">// console.log(vnode)</span></span><br><span class="line"><span class="comment">// Patch into empty DOM element – this modifies the DOM as a side effect</span></span><br><span class="line"><span class="comment">// 让虚拟节点上树</span></span><br><span class="line">patch(container, vnode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newVnode = h(</span><br><span class="line">    <span class="string">&quot;div#container.two.classes&quot;</span>,</span><br><span class="line">    &#123; <span class="attr">on</span>: &#123; <span class="attr">click</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; &#125; &#125;,</span><br><span class="line">    [</span><br><span class="line">        h(</span><br><span class="line">            <span class="string">&quot;span&quot;</span>,</span><br><span class="line">            &#123; <span class="attr">style</span>: &#123; <span class="attr">fontWeight</span>: <span class="string">&quot;normal&quot;</span>, <span class="attr">fontStyle</span>: <span class="string">&quot;italic&quot;</span> &#125; &#125;,</span><br><span class="line">            <span class="string">&quot;This is now italic type&quot;</span></span><br><span class="line">        ),</span><br><span class="line">        <span class="string">&quot; and this is still just normal text&quot;</span>,</span><br><span class="line">        h(<span class="string">&quot;a&quot;</span>, &#123; <span class="attr">props</span>: &#123; <span class="attr">href</span>: <span class="string">&quot;/bar&quot;</span> &#125; &#125;, <span class="string">&quot;I&#x27;ll take you places!&quot;</span>),</span><br><span class="line">    ]</span><br><span class="line">);</span><br><span class="line"><span class="comment">// Second `patch` invocation</span></span><br><span class="line">patch(vnode, newVnode); <span class="comment">// Snabbdom efficiently updates the old view to the new state</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vnode3 = h(</span><br><span class="line">    <span class="string">&#x27;ul&#x27;</span>,[</span><br><span class="line">        h(<span class="string">&#x27;li&#x27;</span>,<span class="string">&#x27;one&#x27;</span>),</span><br><span class="line">        h(<span class="string">&#x27;li&#x27;</span>,<span class="string">&quot;two&quot;</span>)</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(vnode3);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   children:[</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//       sel:&#x27;li&#x27;,</span></span><br><span class="line"><span class="comment">//       data:&#123;&#125;,</span></span><br><span class="line"><span class="comment">//       text: &#x27;one&#x27;,</span></span><br><span class="line"><span class="comment">//       elm: li,</span></span><br><span class="line"><span class="comment">//       key: undefined,</span></span><br><span class="line"><span class="comment">//       children: undefined</span></span><br><span class="line"><span class="comment">//     &#125;,</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//       sel:&#x27;li&#x27;,</span></span><br><span class="line"><span class="comment">//       data:&#123;&#125;,</span></span><br><span class="line"><span class="comment">//       text: &#x27;two&#x27;,</span></span><br><span class="line"><span class="comment">//       elm: li,</span></span><br><span class="line"><span class="comment">//       key: undefined,</span></span><br><span class="line"><span class="comment">//       children: undefined</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//   ],</span></span><br><span class="line"><span class="comment">//   sel:&#x27;ul&#x27;,</span></span><br><span class="line"><span class="comment">//   elm: ul,</span></span><br><span class="line"><span class="comment">//   data:&#123;&#125;,</span></span><br><span class="line"><span class="comment">//   key: undefined,</span></span><br><span class="line"><span class="comment">//   text: undefined</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">patch(vnode,vnode3)</span><br></pre></td></tr></table></figure><ul><li>key是节点的唯一标识，告诉diff算法，在更改前后他们是同一个dom节点</li><li>只比较同一层级，不跨级作比较</li><li>只有是同一个虚拟节点才进行精细比较，否则就是暴力删除旧的，插入新的。</li></ul><p>diff算法：</p><ul><li>patch函数，首先判断oldvnode是不是虚拟节点，如果不是，转换为虚拟节点</li><li>接着判断是不是同一个虚拟节点（选择器相同且key相同），如果不是，则创建新的节点并插入并删除旧的节点</li><li>如果是同一个虚拟节点则进行精细比较，调用patchVnode函数，首先判断新虚拟节点vnode和旧虚拟节点oldVnode是否指向同一个对象，如果是直接返回</li><li>如果他们都有文本节点并且不相等，那么将vnode的文本节点设置为真实dom的文本节点</li><li>如果oldVnode有子节点而vnode没有子节点，则删除对应真实dom的子节点</li><li>如果oldVnode没有子节点而vnode有子节点，将vnode的子节点真实化后添加到真实dom</li><li>如果oldVnode和vnode都有子节点则执行updateChildren函数比较子节点</li></ul><p>diff算法对比同级节点：<br>为了保证dom顺序和新节点保持一致使用while循环和首尾节点进行对比，对新旧虚拟节点数组的开始和结束节点设置索引，遍历的过程向中间移动索引，这样既能实现排序也减小了时间复杂度。两节点比较，有四种比对方式：</p><ul><li>旧开始节点  和  新结束节点  比较</li><li>旧结束节点  和  新开始节点  比较</li><li>旧开始节点  和  新开始节点  比较</li><li>旧结束节点  和  新结束节点  比较</li></ul><p>旧节点：oldStartIndex—-&gt;oldEndIndex<br>新节点：newStartIndex—-&gt;newEndIndex</p><p>比如：如果oldStartIndex和newEndIndex匹配上了，那么真实dom的第一个节点会移动到最右；如果newStartIndex和oldEndIndex匹配上了，那么真实dom的最后一个元素会移动到最左，匹配上的两个指针向中间移动，直到while循环结束</p><p>如果四种匹配都没有成功：</p><ul><li>那么遍历新节点，用新节点的key去老节点数组中查找相同节点</li><li>如果没有找到，说明当前节点是新节点，创建对应dom元素并插入到真实dom</li><li>如果找到了，比对新旧节点的sel是否相同<ul><li>如果相同，说明是同一个节点，移动到dom元素的最左边</li><li>如果不相同，说明修改了节点，创建对应的dom元素并插入到真实dom树中</li></ul></li></ul><p>循环结束：</p><ul><li>如果老节点的子节点先遍历完，那么说明新节点有新增节点，将新增节点批量加入</li><li>如果新节点的子节点先遍历完，那么说明老节点有剩余，将剩余节点批量删除</li></ul><p>例子：</p><p><img src="/ZJY.github.io/images/domdiff.jpeg" alt="image"></p><ul><li>先对首尾进行4种比较:b和a,b和e,a和e,e和e. 得出e节点匹配在真实DOM最右侧中得出第1步. 索引向中间移动,剩下old: b a d f 剩下new: a b</li><li>对剩余的同样进行收尾比较,匹配出b匹配在真实DOM的最左侧.剩下old: a d f 剩下new: a</li><li>同上,匹配出a匹配在真实DOM的最左侧.剩下old:d f 剩下new: 空</li><li>最后old长度大于new的长度,把真实dom中对应的删除</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>querySelector和getElement的区别</title>
      <link href="/ZJY.github.io/2021/04/09/querySelector%E5%92%8CgetElement%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/ZJY.github.io/2021/04/09/querySelector%E5%92%8CgetElement%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>querySelector()和querySelectorAll()是原生的选择符</p><ul><li>querySelector 属于 W3C 中的 Selectors API 规范 。而 getElementsBy 系列则属于 W3C 的 DOM 规范”</li><li>getElementBy系列方法获取的是动态集合，而querySelector获取的是静态集合。<br>简单来说就是，动态集合选出的元素会随文档改变而改变，但是静态的不会，静态集合在取出来以后元素与文档的改变无关。</li><li>getElementBy系列方法性能优于querySelector</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;query&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line"><span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;query&#x27;</span>);</span><br><span class="line"><span class="comment">// query: 77.35107421875 ms</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;getElement&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;getElement&#x27;</span>);</span><br><span class="line"><span class="comment">// getElement: 0.22900390625 ms</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MVC/MVP/MVVM模式的概念和区别</title>
      <link href="/ZJY.github.io/2021/04/07/MVC-MVP-MVVM%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
      <url>/ZJY.github.io/2021/04/07/MVC-MVP-MVVM%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>1.MVC模式</p><p>一种使用MVC（模型-视图-控制器 model-view-controller）设计的web应用程序的模式：</p><p>Model：模型，表示应用程序核心（数据库）<br>View：视图，显示效果（html页面）<br>controller：控制器，处理用户输入（业务逻辑）</p><p>MVC 模式同时提供了对 HTML、CSS 和 JavaScript 的完全控制<br>最典型的MVC就是JSP + servlet + javabean的模式</p><p>视图是用户看到并与之交互的界面<br>模型表示企业数据和业务规则<br>控制器接受用户的输入并调用模型和视图去完成用户的需求</p><p>MVC是单向通信。也就是View跟Model，必须通过Controller来承上启下</p><p><img src="/ZJY.github.io/images/mvc.png" alt="image"></p><p>2.MVP模式</p><p>Model-View-Presenter ；MVP 是从经典的模式MVC演变而来，它们的基本思想有相通的地方Controller/Presenter负责逻辑的处理，Model提供数据，View负责显示。</p><p><img src="/ZJY.github.io/images/mvp.png" alt="image"></p><p>MVP与MVC有着一个重大的区别：在MVP中View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部，而在MVC中View会直接从Model中读取数据而不是通过 Controller</p><p>在MVC模型里，Model不依赖于View，但是View是依赖于Model的</p><p>3.MVVM模式</p><p>M - Model，Model 代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑</p><p>V - View，View 代表 UI 组件，它负责将数据模型转化为 UI 展现出来</p><p>VM - ViewModel，ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步 View 和 Model 的对象，连接 Model 和 View之间的桥梁，绑定数据到viewmodel层并自动更新渲染到页面上，视图变化通知到viewmodel层去更新数据</p><p><img src="/ZJY.github.io/images/mvvm.png" alt="image"></p><p>MVVM模式和MVC模式一样，主要目的是分离视图（View）和模型（Model）</p><p>mvvm模式将Presener改名为View Model，基本上与MVP模式完全一致，唯一的区别是，它采用双向绑定(data-binding): View的 变动，自动反映在View Model，反之亦然。这样开发者就不用处理接收事件和View更新的工作</p><p>这些模式是依次进化而形成MVC/MVP—&gt;MVVM。在以前传统的开发模式当中即MVC模式，前端人员只负责Model（数据库） View（视图） Controller /Presenter/ViewModel（控制器） 当中的View（视图）部分，写好页面交由后端创建渲染模板并提供数据，随着MVVM模式的出现前端已经可以自己写业务逻辑以及渲染模板，后端只负责提供数据即可。</p><p>4.观察者模式：<br>在观察者模式中，观察者直接订阅目标事件，在目标发出内容改变的事件后，直接接收事件并作出响应</p><p>5.发布订阅者模式<br>在发布订阅模式中，发布者和订阅者之间多了一个发布通道；一方面从发布者接收事件，另一方面向订阅者发布事件；订阅者需要从事件通道订阅事件</p><p>观察者模式： 观察者（Observer）直接订阅（Subscribe）主题（Subject），而当主题被激活的时候，会触发（Fire Event）观察者里的事件。</p><p>发布订阅模式： 订阅者（Subscriber）把自己想订阅的事件注册（Subscribe）到调度中心（Topic），当发布者（Publisher）发布该事件（Publish topic）到调度中心，也就是该事件触发时，由调度中心统一调度（Fire Event）订阅者注册到调度中心的处理代码。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css中伪类和伪元素</title>
      <link href="/ZJY.github.io/2021/03/28/css%E4%B8%AD%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0/"/>
      <url>/ZJY.github.io/2021/03/28/css%E4%B8%AD%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h2><p>css引入伪类和伪元素是为了格式化文档树以外的信息。也就是说伪类和伪元素是为了修饰不在文档树中的部分。比如一句话中第一个字母或者列表的第一个元素。</p><h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3><p>伪类用于当已有元素处于某个状态时，为其添加的样式，这个状态是根据用户行为而动态变化的。比如用户鼠标悬停:hover</p><h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><p>伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如添加::before伪元素在一个元素前增加一些文本。并为这些文本添加样式。虽然这些文本用户可以看到，但并不存在文档树中。</p><p>伪类的操作对象是文档树中已有的元素，而伪元素则创建了一个文档树之外的元素。<br>因此，伪类与伪元素的区别在于：有没有创建一个文档树之外的元素。</p><h3 id="伪元素是使用单冒号还是双冒号"><a href="#伪元素是使用单冒号还是双冒号" class="headerlink" title="伪元素是使用单冒号还是双冒号"></a>伪元素是使用单冒号还是双冒号</h3><p>虽然CSS3标准要求伪元素使用双冒号的写法，但也依然支持单冒号的写法。为了向后兼容，我们建议你在目前还是使用单冒号的写法。</p><h3 id="伪类和伪元素的具体用法"><a href="#伪类和伪元素的具体用法" class="headerlink" title="伪类和伪元素的具体用法"></a>伪类和伪元素的具体用法</h3><p>伪类：</p><ul><li>状态：:link :visited :hover :actived :focus</li><li>语言相关：:lang :dir</li><li>其他：:root  :fullscreen</li><li>表单相关：:checked :disabled :empty :enabled :valid :invalid :required :read-only :scope</li><li>结构化：:not :first-child :last-child :first-of-type :last-of-type :nth-child :nth-of-child :only-child :only-of-type :target</li></ul><p>伪元素：</p><ul><li>单双冒号：::before/:before   ::after/:after  ::first-letter/:first-letter  ::first-line/:first-line</li><li>双冒号：::selection  ::placeholder  ::backdrop</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP的请求头标签 If-Modified-Since与Last-Modified</title>
      <link href="/ZJY.github.io/2021/03/28/HTTP%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%B4%E6%A0%87%E7%AD%BE-If-Modified-Since%E4%B8%8ELast-Modified/"/>
      <url>/ZJY.github.io/2021/03/28/HTTP%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%B4%E6%A0%87%E7%AD%BE-If-Modified-Since%E4%B8%8ELast-Modified/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP的请求头标签-If-Modified-Since与Last-Modified"><a href="#HTTP的请求头标签-If-Modified-Since与Last-Modified" class="headerlink" title="HTTP的请求头标签 If-Modified-Since与Last-Modified"></a>HTTP的请求头标签 If-Modified-Since与Last-Modified</h2><h3 id="1-基本定义"><a href="#1-基本定义" class="headerlink" title="1.基本定义"></a>1.基本定义</h3><p>If-Modified-since和last-modified都是http请求头中标签，用于记录页面的最后修改时间</p><h3 id="2-发送方向"><a href="#2-发送方向" class="headerlink" title="2.发送方向"></a>2.发送方向</h3><p>Last-Modified是服务器向客户端发送的http请求头标签<br>if-modified-since是由客户端向服务器发送的http请求他标签</p><h3 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3.应用场景"></a>3.应用场景</h3><p>（1）last-modified:当浏览器第一次请求某个url时，服务端返回状态200，内容是请求的资源，同时有一个last-modifined属性标记此文件在服务端最后被修改的时间，格式：<br>Last-Modified: Fri, 12 May 2006 18:53:33 GMT<br>（2）if-modified-since: 客户端第二次请求此url时，根据http协议的规定，浏览器会向服务器发送一个if-modified-since报头，询问此文件是否被修改过，格式：<br>If-Modified-Since: Fri, 12 May 2006 18:53:33 GMT<br>后面时间是本地浏览器存储文件修改的时间</p><p>如果服务端的资源没有发生变化，则时间一致，自动返回状态码304，客户端接收到后就将本地文件显示到浏览器，这样就节省来传输流量</p><p>如果服务器资源发生改变或者重启服务器，时间不一致，就返回http状态码200和新的文件内容，客户端接收到后就丢弃旧的文件，把新文件缓存起来，并显示到浏览器中。</p><p>以上操作可以保证不向客户端发送重复资源，服务端资源发生变化时，客户端能得到最新的资源</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack的插件plugin</title>
      <link href="/ZJY.github.io/2021/03/26/webpack%E7%9A%84%E6%8F%92%E4%BB%B6plugin/"/>
      <url>/ZJY.github.io/2021/03/26/webpack%E7%9A%84%E6%8F%92%E4%BB%B6plugin/</url>
      
        <content type="html"><![CDATA[<h3 id="插件-plugin"><a href="#插件-plugin" class="headerlink" title="插件(plugin)"></a>插件(plugin)</h3><p>loader用来转换文件，插件用来执行更广泛的任务。包括：打包优化、资源管理，注入环境变量。<br>使用一个插件，只需要require()它，添加到plugins数组中，多数插件可以通过option选项自定义。<br>你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建一个插件实例</p><p>webpack插件是一个具有apply方法的js对象，apply 方法会被 webpack compiler 调用，并且在__整个__编译生命周期都可以访问 compiler 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>); <span class="comment">// 通过 npm 安装</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins:[</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span> &#125;);</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HtmlWebpackPlugin插件为应用程序生成一个html文件，并自动注入所以生成的bundle</p><p>clean-webpack-plugin:打包之前删除 dist。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line">plugins:[</span><br><span class="line">  <span class="keyword">new</span> CleanWebpackPlugin();</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>CommonsChunkPlugin:提取chunks间共享的通用模块</p><p>MiniCssExtractPlugin：为每个引入css的js文件创建一个css文件</p><p>HotModuleReplacementPlugin：启用模块热更替</p><p>uglifyjs-webpack-plugin：压缩js文件的体积</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题</title>
      <link href="/ZJY.github.io/2021/03/25/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/ZJY.github.io/2021/03/25/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-网络中使用图片格式有哪些？"><a href="#1-网络中使用图片格式有哪些？" class="headerlink" title="1.网络中使用图片格式有哪些？"></a>1.网络中使用图片格式有哪些？</h3><p>jpeg：目前网络上最流行的图片格式，可以把文件压缩到最小的格式。在ps中以jpeg格式保存可以提供13级压缩级别。（有损压缩）<br>svg：可缩放矢量图形，基于xml。<br>png：支持高级别无损耗压缩，支持alpha 通道透明度，较旧的浏览器和程序可能不支持 PNG 文件。<br>gif：有损压缩，不支持Alpha透明通道。可做动画</p><h3 id="2-简述盒子模型"><a href="#2-简述盒子模型" class="headerlink" title="2.简述盒子模型"></a>2.简述盒子模型</h3><p>一个盒子由：margin + padding + border + content<br>默认情况下，盒子宽高只是content的宽和高<br>box-sizing:content-box; 元素宽高等于content宽高<br>box-sizing:border-box; 元素宽高等于content宽高+padding+border</p><h3 id="3-音视频标签的使用"><a href="#3-音视频标签的使用" class="headerlink" title="3.音视频标签的使用"></a>3.音视频标签的使用</h3><p>视频：video</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">width</span>=<span class="string">&quot;320&quot;</span> <span class="attr">height</span>=<span class="string">&quot;240&quot;</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;movie.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;movie.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/ogg&quot;</span>&gt;</span></span><br><span class="line">    您的浏览器不支持 video 标签。</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>video 元素支持三种视频格式：MP4、WebM、Ogg。<br>可选属性：</p><ul><li>autoplay:是否自动播放</li><li>src：要播放的视频的 URL。</li><li>controls：向用户显示控件，比如播放按钮</li><li>width/height：设置播放器的宽高</li><li>muted：是否静音</li><li>preload：如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。</li><li>poster：规定视频正在下载时显示的图像，直到用户点击播放按钮。</li><li>loop:是否循环播放</li></ul><p>音频：audio</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;horse.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/ogg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;horse.mp3&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/mpeg&quot;</span>&gt;</span></span><br><span class="line">  您的浏览器不支持 audio 元素。</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><p>支持的3种文件格式：MP3、Wav、Ogg</p><p>可选属性：</p><ul><li>autoplay:是否自动播放</li><li>src：要播放的音频的 URL。</li><li>controls：向用户显示控件，比如播放按钮</li><li>muted：是否静音</li><li>preload：规定当网页加载时，音频是否默认被加载以及如何被加载。</li><li>loop:是否循环播放</li></ul><h3 id="4-html5新增的内容有哪些？"><a href="#4-html5新增的内容有哪些？" class="headerlink" title="4.html5新增的内容有哪些？"></a>4.html5新增的内容有哪些？</h3><p>新增语义化标签<br>新增表单类型<br>表单元素/事件/属性<br>多媒体标签</p><h3 id="5-html5新增的语义化标签"><a href="#5-html5新增的语义化标签" class="headerlink" title="5.html5新增的语义化标签"></a>5.html5新增的语义化标签</h3><p>main,nav,section,article,header,footer,embed,video,audio,mark,figure,aside</p><h3 id="6-清除浮动的方式？"><a href="#6-清除浮动的方式？" class="headerlink" title="6.清除浮动的方式？"></a>6.清除浮动的方式？</h3><p>1.高度塌陷<br>所有子元素浮动，父元素没有设置高度时，这时父元素产生高度塌陷</p><p>解决1：给父元素单独设置高度<br>优点：快速简单，代码少； 缺点：无法进行响应式布局<br>解决2:给父元素设置overflow:hidden;zoom:1;(针对ie6的兼容)<br>优点：快速简单、代码少，兼容性高； 缺点：超出部分被隐藏，布局时要注意<br>解决3:给浮动元素后面添加空标签，设置clear:both;height:0;overflow:hidden;<br>优点：快速简单、代码少，兼容性高； 缺点：增加空标签，不利于页面优化；<br>解决4:给父元素设置overflow:auto;<br>优点：快速简单、代码少，兼容性高； 缺点：若父元素设置了高度，子元素超出父元素宽高会出现滚动条<br>解决5:给塌陷的元素设置伪元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.fater</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">overflow</span>:hidden;</span><br><span class="line">  <span class="attribute">visibility</span>:hidden;</span><br><span class="line">  <span class="attribute">clear</span>:both;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">display</span>:block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：写法固定兼容性高； 缺点：代码多</p><h3 id="7-给元素设置水平垂直居中"><a href="#7-给元素设置水平垂直居中" class="headerlink" title="7.给元素设置水平垂直居中"></a>7.给元素设置水平垂直居中</h3><p>一.水平居中<br>1.行内元素：只需要把行内元素包裹在一个属性 display 为 block 的父层元素中，并且把父层元素添加如下属性即可</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">  <span class="attribute">text-align</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.块状元素：给该元素设置：margin:0 auto;</p><p>3.多个块状元素，给元素设置display:inline-block,并把父元素的text-align:center</p><p>4.多个块状元素，给父元素设置display:flex;justify-content:center;</p><p>二、垂直居中<br>1.单行行内元素：设置height和line-height属性和父元素高度一样</p><p>2.多行行内元素：设置父元素属性：display:table-cell; vertical-align:middle;</p><p>3.已知高度的块状元素：给该元素设置属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">position</span><span class="selector-pseudo">:relative</span>;</span><br><span class="line"><span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span><br><span class="line"><span class="selector-tag">top</span><span class="selector-pseudo">:50</span>%;</span><br><span class="line"><span class="selector-tag">margin-top</span><span class="selector-pseudo">:-50px</span>;</span><br></pre></td></tr></table></figure><p>三、水平垂直居中<br>1.已知宽度和高度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">width</span><span class="selector-pseudo">:200px</span>;</span><br><span class="line"><span class="selector-tag">height</span><span class="selector-pseudo">:200px</span>;</span><br><span class="line"><span class="selector-tag">position</span><span class="selector-pseudo">:relative</span>;</span><br><span class="line"><span class="selector-tag">top</span><span class="selector-pseudo">:50</span>%;</span><br><span class="line"><span class="selector-tag">left</span><span class="selector-pseudo">:50</span>%;</span><br><span class="line"><span class="selector-tag">margin-top</span><span class="selector-pseudo">:-100px</span>;</span><br><span class="line"><span class="selector-tag">margin-left</span><span class="selector-pseudo">:-100px</span>;</span><br></pre></td></tr></table></figure><p>2.未知高度和宽度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">position</span><span class="selector-pseudo">:relative</span>;</span><br><span class="line"><span class="selector-tag">top</span><span class="selector-pseudo">:50</span>%;</span><br><span class="line"><span class="selector-tag">left</span><span class="selector-pseudo">:50</span>%;</span><br><span class="line"><span class="selector-tag">transform</span><span class="selector-pseudo">:translate(-50</span>%,<span class="selector-tag">-50</span>%);</span><br></pre></td></tr></table></figure><p>3.使用flex布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">display</span><span class="selector-pseudo">:flex</span>;</span><br><span class="line"><span class="selector-tag">align-items</span><span class="selector-pseudo">:center</span>;</span><br><span class="line"><span class="selector-tag">justify-content</span><span class="selector-pseudo">:center</span>;</span><br></pre></td></tr></table></figure><h3 id="8-display-inline-block元素间默认间距"><a href="#8-display-inline-block元素间默认间距" class="headerlink" title="8.display:inline-block元素间默认间距"></a>8.display:inline-block元素间默认间距</h3><p>1.给行内块元素设置浮动（需要清除浮动带来的影响）<br>2.给行内元素的父元素设置font-size:0;<br>3.给父元素添加词间距属性word-spacing,属性值为负数根据情况给出</p><h3 id="9-html5拖拽api"><a href="#9-html5拖拽api" class="headerlink" title="9.html5拖拽api"></a>9.html5拖拽api</h3><p>dragstart:事件主体是被拖拽元素，拖拽开始时触发<br>drag：事件主体是被拖拽元素，拖拽时触发<br>dragenter：事件主体是目标元素，被拖拽元素进入目标元素时触发<br>dragover：事件主体是目标元素，被拖拽元素在目标元素移动时触发<br>dragleave：事件主体是目标元素，被拖拽元素离开目标元素时触发<br>drog：事件主体是目标元素，在目标元素完全接受被拖拽元素时触发<br>dragend：事件主体是目标元素，在拖拽完成时触发</p><h3 id="10-双边距重叠问题"><a href="#10-双边距重叠问题" class="headerlink" title="10.双边距重叠问题"></a>10.双边距重叠问题</h3><p>多个相邻普通流中块元素垂直方向margin会发生重叠：</p><ul><li>两个相邻的外边距都是正数时，重叠结果是2者中较大值</li><li>两个相邻的外边距都是负数时，重叠结果是2者绝对值的较大值</li><li>两个相邻的外边距一正一负时，重叠结果是2者之和</li></ul><h3 id="11-什么是面向对象？"><a href="#11-什么是面向对象？" class="headerlink" title="11.什么是面向对象？"></a>11.什么是面向对象？</h3><p>面向对象是一种思想，是对面向过程而言的。面向对象就是把功能通过对象来实现，把功能封装到对象中，让对象去实现具体的细节。这种思想将数据放在第一位，是对数据的一种优化，使操作更加简单，方便简化了过程。</p><p>js本身没有class类型，但每个函数都有一个prototype属性，prototype指向一个对象，当函数作为构造函数使用时，prototype就起到类似于class的作用</p><p>面向对象的三个特点：封装、继承和多态。</p><h3 id="12-普通函数和构造函数的区别？"><a href="#12-普通函数和构造函数的区别？" class="headerlink" title="12.普通函数和构造函数的区别？"></a>12.普通函数和构造函数的区别？</h3><p>1.构造函数也是普通函数，创建方式和普通函数一样，但是构造函数名首字母大写<br>2.构造函数内部会创建一个对象，即实例，普通函数内部不会创建新对象<br>3.普通函数之间调用，构造函数通过new调用<br>4.构造函数内部this指向新创建的对象，而普通函数this指向函数的调用者<br>5.构造函数默认的返回值是创建的对象（实例），而普通函数返回值是return的值<br>6.构造函数的函数名和类名相同</p><h3 id="13-原型和原型链"><a href="#13-原型和原型链" class="headerlink" title="13.原型和原型链"></a>13.原型和原型链</h3><p>(1)原型<br>1.所有引用类型都有一个<strong>proto</strong>(隐式原型)属性，属性值是一个普通的对象<br>2.所有函数都有一个prototype（原型）属性，属性值是一个普通的对象<br>3.所有引用类型的__proto__都指向它构造函数的prototype</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.__proto__ === <span class="built_in">Array</span>.prototype; <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>(2)原型链<br>当访问对象的一个属性或方法时，会先在这个对象的属性和方法中查找，如果没有找到就去它的__proto__隐式原型中查找，即它的构造函数的prototype，如果还没有找到就去构造函数的prototype.__proto__中查找，这样一层一层的向上查找形成的链式结构叫原型链。</p><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Parent(<span class="string">&#x27;child&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(child.name); <span class="comment">//&#x27;child&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(child.age); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>在child中查找某属性时：<br>1.在child中查找属性，本身有该属性时，返回值，没有去child.<strong>proto__，即Parent.prototype中查找<br>2.如果child.__proto__，即Parent.prototype有该属性，返回值，没有则去Parent.prototype.__proto__，即Object.prototype中查找<br>3.如果Parent.prototype.__proto__，即Object.prototype中有该属性，则返回值，没有则去Object.prototype.__proto</strong>,即null中查找<br>4.Object.prototype.<strong>proto</strong> === null,返回undefined</p><p>一直往上层查找，直到null还没有找到，返回undefined<br>Object.prototype.<strong>proto</strong> === null<br>所有从原型或更高级原型中的得到、执行的方法，其中的this在执行时，指向当前这个触发事件执行的对象</p><h3 id="14-clientHeight-offsetHeight-scrollHeight的区别？clientTop-offsetTop-scrollTop的区别？"><a href="#14-clientHeight-offsetHeight-scrollHeight的区别？clientTop-offsetTop-scrollTop的区别？" class="headerlink" title="14.clientHeight,offsetHeight,scrollHeight的区别？clientTop,offsetTop,scrollTop的区别？"></a>14.clientHeight,offsetHeight,scrollHeight的区别？clientTop,offsetTop,scrollTop的区别？</h3><p>clientHeight:表示可视区域的高度，不包含border和滚动条（包含padding）<br>offsetHeight:表示可视区域的高度，包含border和滚动条（包含padding）<br>scrollHeight:表示所有区域的高度，包含被隐藏的部分</p><p>clientTop:表示边框border的厚度，未指定情况一般为0<br>offsetTop:获取元素顶部距离相对于已定位的父元素或body顶部距离的高度<br>scrollTop：滚动后被隐藏的高度</p><h3 id="15-html5的拖拽"><a href="#15-html5的拖拽" class="headerlink" title="15.html5的拖拽"></a>15.html5的拖拽</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">allowDrop</span>(<span class="params">ev</span>)</span></span></span><br><span class="line">  &#123;</span><br><span class="line">    ev.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">drag</span>(<span class="params">ev</span>)</span></span></span><br><span class="line">  &#123;</span><br><span class="line"><span class="javascript">    ev.dataTransfer.setData(<span class="string">&quot;Text&quot;</span>,ev.target.id);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">drop</span>(<span class="params">ev</span>)</span></span></span><br><span class="line">  &#123;</span><br><span class="line">    ev.preventDefault();</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> data=ev.dataTransfer.getData(<span class="string">&quot;Text&quot;</span>);</span></span><br><span class="line"><span class="javascript">    ev.target.appendChild(<span class="built_in">document</span>.getElementById(data));</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span> <span class="attr">ondrop</span>=<span class="string">&quot;drop(event)&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">ondragover</span>=<span class="string">&quot;allowDrop(event)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;drag1&quot;</span> <span class="attr">src</span>=<span class="string">&quot;img_logo.gif&quot;</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">ondragstart</span>=<span class="string">&quot;drag(event)&quot;</span> <span class="attr">width</span>=<span class="string">&quot;336&quot;</span> <span class="attr">height</span>=<span class="string">&quot;69&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="16-js中垃圾回收机制"><a href="#16-js中垃圾回收机制" class="headerlink" title="16.js中垃圾回收机制"></a>16.js中垃圾回收机制</h3><p>为什么需要垃圾回收？</p><p>由于字符串、对象、数组没有固定的大小，所以当他们已知大小时才能进行动态的存储分配。js程序每次创建字符串、对象和数组时，解释器都必须分配内存来存储那个实体。只要像这样动态的分配了内存，最终都要释放内存以便他们能够被再用，否则，js的解释器会消耗完系统中所以可用的内存，造成系统崩溃。</p><p>js解释器可以检测到何时程序不再使用一个对象了，就可以把它占用的内存释放掉。</p><p>垃圾回收的方法：</p><p>1.标记清除：当变量就去环境时，就标记这个变量为“进入环境”，当离开环境时，就标记为离开环境。永远不能释放进入环境的变量所占用的内存。<br>垃圾回收器在运行时会给存储在内存中的变量都加上标记，然后去除环境变量中的变量，以及被环境变量中的变量所引用的变量，删除所有被标记的变量，然后垃圾回收器完成内存的清除工作，并回收他们占用的内存。</p><p>2.引用计数法：计算每个引用类型的变量的引用次数，当引用次数为0时就说明没有方法访问这个值了，垃圾回收器再次运行的时候就会释放引用次数为0的值。</p><h3 id="17-http"><a href="#17-http" class="headerlink" title="17.http"></a>17.http</h3><p>http1.1：<br>1.长连接<br>2.管道传输：在同一个TCP连接里，可发起多个请求，只要第一个请求发出去了，不必等其回来，就可发第二个请求出去，可以减少整体的响应时间。但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求<br>3.队头阻塞：因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，会导致后面的请求也被阻塞，客户端一直请求不到数据，这也就是对头阻塞。</p><p>http2:<br>http2基于https的，所以安全有保障<br>1.头部压缩：会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的分<br>2.HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了二进制格式，头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧和数据帧<br>3.多路复用：可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。<br>4.服务器推送：在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息</p><p>http2有哪些缺陷？<br>多个http请求在复用同一个tcp连接时，下层的tcp协议是不知道有多少个http请求的<br>所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。<br>这都是基于 TCP 传输层的问题，所以 HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP</p><h3 id="18-map和set的区别？"><a href="#18-map和set的区别？" class="headerlink" title="18.map和set的区别？"></a>18.map和set的区别？</h3><p>map：map对象保存健值对，并且能够记住原始插入顺序。<br>描述：map对象在迭代时会根据原始插入顺序来进行for…of遍历，返回一个[key,value]的数组</p><p>属性</p><p>Map.prototype.constructor<br>返回一个函数，它创建了实例的原型。默认是Map函数。</p><p>Map.prototype.size<br>返回Map对象的键/值对的数量。</p><p>方法</p><p>Map.prototype.clear()<br>移除Map对象的所有键/值对 。</p><p>Map.prototype.delete(key)<br>如果 Map 对象中存在该元素，则移除它并返回 true；否则如果该元素不存在则返回 false。随后调用 Map.<br>prototype.has(key) 将返回 false 。</p><p>Map.prototype.entries()<br>返回一个新的 Iterator 对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。</p><p>Map.prototype.forEach(callbackFn[, thisArg])<br>按插入顺序，为 Map对象里的每一键值对调用一次callbackFn函数。如果为forEach提供了thisArg，它将在每次回调中作为this值。</p><p>Map.prototype.get(key)<br>返回键对应的值，如果不存在，则返回undefined。</p><p>Map.prototype.has(key)<br>返回一个布尔值，表示Map实例是否包含键对应的值。</p><p>Map.prototype.keys()<br>返回一个新的 Iterator对象， 它按插入顺序包含了Map对象中每个元素的键 。</p><p>Map.prototype.set(key, value)<br>设置Map对象中键的值。返回该Map对象。</p><p>Map.prototype.values()<br>返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的值 。</p><p>set：允许存储任何类型的唯一值，无论是原始值或者是对象引用。<br>描述：Set对象是值的集合，你可以按照插入的顺序迭代它的元素。 Set中的元素只会出现一次，即 Set 中的元素是唯一的。</p><p>实例属性</p><p>Set.prototype.size<br>返回 Set 对象中的值的个数</p><p>实例方法</p><p>Set.prototype.add(value)<br>在Set对象尾部添加一个元素。返回该Set对象。</p><p>Set.prototype.clear()<br>移除Set对象内的所有元素。</p><p>Set.prototype.delete(value)<br>移除Set中与这个值相等的元素，返回Set.prototype.has(value)在这个操作前会返回的值（即如果该元素存在，返回true，否则返回false）。Set.prototype.has(value)在此后会返回false。</p><p>Set.prototype.entries()<br>返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值的[value, value]数组。为了使这个方法和Map对象保持相似， 每个值的键和值相等。</p><p>Set.prototype.forEach(callbackFn[, thisArg])<br>按照插入顺序，为Set对象中的每一个值调用一次callBackFn。如果提供了thisArg参数，回调中的this会是这个参数。</p><p>Set.prototype.has(value)<br>返回一个布尔值，表示该值在Set中存在与否。</p><p>Set.prototype.keys() (en-US)<br>与values()方法相同，返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。</p><p>Set.prototype.values()<br>返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端渲染方式</title>
      <link href="/ZJY.github.io/2021/03/24/%E5%89%8D%E7%AB%AF%E6%B8%B2%E6%9F%93%E6%96%B9%E5%BC%8F/"/>
      <url>/ZJY.github.io/2021/03/24/%E5%89%8D%E7%AB%AF%E6%B8%B2%E6%9F%93%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="单页面应用"><a href="#单页面应用" class="headerlink" title="单页面应用"></a>单页面应用</h3><p>只要一个web页面的应用，单页面跳转仅刷新局部资源，公共资源（css、js）仅需加载一次。<br>如图：</p><p><img src="/ZJY.github.io/images/sing.png" alt="image"></p><h3 id="多页面应用"><a href="#多页面应用" class="headerlink" title="多页面应用"></a>多页面应用</h3><p>多页面应用跳转需刷新所有资源，每个公共资源需选择性重新加载。</p><p><img src="/ZJY.github.io/images/mutli.png" alt="image"></p><p>具体分析对比：</p><table><thead><tr><th align="center"></th><th align="center">单页面应用</th><th align="center">多页面应用</th></tr></thead><tbody><tr><td align="center">组成</td><td align="center">一个外壳页面和多个页面片段组成</td><td align="center">多个完整页面组成</td></tr><tr><td align="center">资源共用（css、js）</td><td align="center">资源共用，只需在外壳页面加载</td><td align="center">不共用，每个页面都需要加载</td></tr><tr><td align="center">刷新方式</td><td align="center">页面局部刷新或更改</td><td align="center">整页刷新</td></tr><tr><td align="center">url模式</td><td align="center">a.com/#/pageone<br>a.com/#/pagetwo</td><td align="center">a.com/pageone.html <br> a.com/pagetwo.html</td></tr><tr><td align="center">用户体验</td><td align="center">页面切换速度快，用户体验好</td><td align="center">页面切换加载缓慢，流畅度不够，用户体验比较差</td></tr></tbody></table><p>单页面应用就是只有一个主页面的应用，浏览器需要一开始就加载所有必须的html，css，js。所有的页面内容都包含在这个主页面中，但在写的时候还是分开写页面片段，然后在交互的时候由路由动态载入，单页面的页面跳转，仅刷新局部资源。</p><p>多页面（MPA），就是指一个应用中有多个页面，页面跳转时是整页刷新</p><h3 id="客户端渲染"><a href="#客户端渲染" class="headerlink" title="客户端渲染"></a>客户端渲染</h3><p>用户访问url，请求html文件，前端根据路由动态渲染页面内容，关键链路较长，有一定的白屏时间</p><h3 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h3><p>用户访问url，服务端根据访问路径请求所需数据，拼接成html字符串，返回给前端，前端接收到html已有部分内容</p><h3 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h3><p>构建阶段生成匹配预渲染路径的html文件（每个需要预渲染的路由都有一个对应的 html），构建处理的html已有部分内容</p><p>服务端渲染：发送请求-服务器请求数据渲染html-包含首屏的html<br>预渲染：发送请求-包含首屏的html<br>客户端渲染：发送请求-html-js加载并动态渲染</p><p>prerender-spa-plugin ：一个 webpack 插件用于在单页应用中预渲染静态 html 内容</p><p>安装插件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install prerender-spa-plugin --save-dev</span><br></pre></td></tr></table></figure><p>配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> PrerenderSpaPlugin = <span class="built_in">require</span>(<span class="string">&#x27;prerender-spa-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">new</span> PrerenderSpaPlugin(</span><br><span class="line">      <span class="comment">// 输出目录的绝对路径</span></span><br><span class="line">      path.join(__dirname, <span class="string">&#x27;../dist&#x27;</span>),</span><br><span class="line">      <span class="comment">// 预渲染的路由</span></span><br><span class="line">      [ <span class="string">&#x27;/new&#x27;</span>, <span class="string">&#x27;/hot&#x27;</span> ]</span><br><span class="line">    )</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化 PrerenderSpaPlugin 需要至少两个参数，第一个参数是单页应用的输出目录，第二个参数指定预渲染的路由，这里执行了两个路由 /new 和 /hot</p><p>npm run build构建后：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dist</span><br><span class="line">│  index.html</span><br><span class="line">│  </span><br><span class="line">├─hot</span><br><span class="line">│      index.html</span><br><span class="line">│      </span><br><span class="line">├─<span class="keyword">new</span></span><br><span class="line">│      index.html</span><br><span class="line">│      </span><br><span class="line">└─<span class="keyword">static</span></span><br></pre></td></tr></table></figure><p>预渲染的目录多了两个文件 new/index.html, hot/index.html</p><p>prerender-spa-plugin 原理:</p><p>在 webpack 构建阶段的最后，在本地启动一个 phantomjs，访问配置了预渲染的路由，再将 phantomjs 中渲染的页面输出到 html 文件中，并建立路由对应的目录。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>animation和transition的区别</title>
      <link href="/ZJY.github.io/2021/03/23/animation%E5%92%8Ctransition%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/ZJY.github.io/2021/03/23/animation%E5%92%8Ctransition%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="animation和transition的区别"><a href="#animation和transition的区别" class="headerlink" title="animation和transition的区别"></a>animation和transition的区别</h2><h3 id="css3动画和js动画的区别"><a href="#css3动画和js动画的区别" class="headerlink" title="css3动画和js动画的区别"></a>css3动画和js动画的区别</h3><p>js实现的是帧动画，css3实现的是补间动画<br>帧动画：使用定时器，每隔一段时间就更改元素<br>js动画逐帧绘制内容，可操作性高，可以很好的控制动画开始，暂停，回放，取帧等；但复杂度高于css动画，资源占有比较大<br>补间动画：状态发生变化产生动画<br>只需要确定第一帧和最后一帧的位置，2个关键帧之间内容由composite线程自动生成，不需要人为处理。对动画控制比较弱。</p><h3 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h3><p>transition属性设置过度属性，四个简写属性为：</p><ul><li>transition-property:指定css属性的name，默认是all</li><li>transition-duration：transition效果需要指定多少秒或毫秒才能完成，默认为0</li><li>transition-timing-function:指定transition效果的转速曲线,默认值ease<ul><li>linear：规定以相同的速度开始至结束的过度效果</li><li>ease：规定慢速开始，然后变快，然后慢速结束的过渡效果</li><li>ease-in：规定以慢速开始的过渡效果</li><li>ease-in-out:规定以慢速开始和结束的过渡效果</li></ul></li><li>transition-delay:定义transition效果延迟多久开始</li></ul><p>transition需要事件触发（比如hover类），不能在加载网页时自动开始<br>一次性，不能重复触发<br>只有2个状态，开始和结束<br>一个transition属性只能定义一个属性</p><h3 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h3><p>animation属性用来创建动画</p><p>@keyframes规则用于创建动画</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> myFirst&#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@keyframes创建动画后，需要将它绑定到某个选择器，需要一下2个css属性，才能将动画绑定到选择器：<br>1.规定动画的名称<br>2.规定动画的时长</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">animation</span>: myFirst <span class="number">5s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可用0%到100%代替from和to</p><ul><li>@keyframes：创建动画</li><li>animation：动画的简写，默认值none 0 ease 0 1 normal</li><li>animation-name: 规定@keyframes动画的名称</li><li>animation-duration: 规定动画的一个周期所需时长，默认是0</li><li>animation-timing-function: 规定动画的曲线，默认是ease</li><li>animation-delay: 规定动画何时开始，默认是0</li><li>animation-iteration-count: 规定动画播放次数，默认是1，值可取n/infinate(无限播放)</li><li>animation-direction: 规定动画是否在下一周期逆向播放，默认是normal,取值normal/alternate</li><li>animation-play-state: 规定动画是正在运行还是暂停，默认值是running，取值running/paused</li><li>animation-fill-mode: 定对象动画时间之外的状态</li></ul><p>总结：</p><table><thead><tr><th align="center">区别</th><th align="center">transition</th><th align="center">animation</th></tr></thead><tbody><tr><td align="center">能否自动执行</td><td align="center">不能，需要事件触发，比如hover</td><td align="center">能</td></tr><tr><td align="center">能否重复发生</td><td align="center">不能，除非重复触发</td><td align="center">能</td></tr><tr><td align="center">是否有多个状态</td><td align="center">2个，开始和结束状态</td><td align="center">能，比如从0% 到100%，任意指定过渡状态</td></tr><tr><td align="center">能否暂停</td><td align="center">不能</td><td align="center">能</td></tr><tr><td align="center">能否定义速度曲线</td><td align="center">能</td><td align="center">能</td></tr><tr><td align="center">能否定义某个属性值过渡</td><td align="center">能</td><td align="center">能</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-1.vue.js的简介</title>
      <link href="/ZJY.github.io/2021/03/18/vue-1.vue.js%E7%9A%84%E7%AE%80%E4%BB%8B/"/>
      <url>/ZJY.github.io/2021/03/18/vue-1.vue.js%E7%9A%84%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-vue-js的简介"><a href="#1-vue-js的简介" class="headerlink" title="1.vue.js的简介"></a>1.vue.js的简介</h2><p>jquery：命令式操作dom<br>vue：声明式操作dom<br>通过描述状态和dom之间的映射关系，就可以将状态渲染成dom呈现在用户界面，也就是渲染到网页中。</p><p>渐进式框架，就是框架分层。<br>最核心的部分是视图渲染，然后往外是组件机制，在这个基础上加上路由机制，再加上状态管理，最外层是构建工具。<br>视图渲染-组件机制-路由机制-状态管理-构建工具<br>分层指既可以使用核心的视图渲染功能来快速开发一些需求，也可以使用全家桶来开发大型应用。vue.js有足够的灵活性可以适应不同的需求，你可以根据自己的需求来选择不同的层级</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES5的继承和ES6继承的区别</title>
      <link href="/ZJY.github.io/2021/03/08/ES5%E7%9A%84%E7%BB%A7%E6%89%BF%E5%92%8CES6%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/ZJY.github.io/2021/03/08/ES5%E7%9A%84%E7%BB%A7%E6%89%BF%E5%92%8CES6%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="ES5的继承和ES6继承的区别"><a href="#ES5的继承和ES6继承的区别" class="headerlink" title="ES5的继承和ES6继承的区别"></a>ES5的继承和ES6继承的区别</h2><h3 id="ES5继承："><a href="#ES5继承：" class="headerlink" title="ES5继承："></a>ES5继承：</h3><p>基本思想：利用原型链让一个引用类型的原型去继承另一个引用类型的属性和方法（通过prototype和构造函数实现）<br>本质：将父类添加到子类的原型上去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GrandParent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;GrandParent&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.a = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype = <span class="keyword">new</span> GrandParent();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;Parent&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;Child&#x27;</span>;</span><br><span class="line">    <span class="built_in">this</span>.c = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="built_in">console</span>.log(child); <span class="comment">//&#123;name:&#x27;child&#x27;,c:1&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(child.a); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(child.b); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(child.c); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><h3 id="ES6继承："><a href="#ES6继承：" class="headerlink" title="ES6继承："></a>ES6继承：</h3><p>基本思想：通过extends实现继承，子类可以继承父类的所以方法和属性。子类必须在constructor()方法中调用super()方法，因为新建的子类没有this对象，而是继承了父类的this对象。<br>本质：通过extends实现继承，子类继承了父类的所有方法和属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.a = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Person constructor&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;eat&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">play</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Play&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.b = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">study</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;study&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> stu = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="built_in">console</span>.log(stu.a, stu.b);</span><br><span class="line">stu.eat();</span><br><span class="line">stu.study();</span><br><span class="line">Student.play();</span><br></pre></td></tr></table></figure><h3 id="ES5-的继承和-ES6-的继承有什么区别-？"><a href="#ES5-的继承和-ES6-的继承有什么区别-？" class="headerlink" title="ES5 的继承和 ES6 的继承有什么区别 ？"></a>ES5 的继承和 ES6 的继承有什么区别 ？</h3><p>ES5 的继承时通过 prototype 或构造函数机制来实现。</p><ul><li>ES5 的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到 this 上（Parent.apply(this)）。</li><li>ES6 的继承机制完全不同，实质上是先创建父类的实例对象 this（所以必须先调用父类的 super()方法），然后再用子类的构造函数修改 this。</li></ul><p>具体的：ES6 通过 class 关键字定义类，里面有构造方法，类之间通过 extends 关键字实现继承。子类必须在 constructor 方法中调用 super 方法，否则新建实例报错。因为子类没有自己的 this 对象，而是继承了父类的 this 对象，然后对其进行加工。如果不调用 super 方法，子类得不到 this 对象。</p><p>ps：super 关键字指代父类的实例，即父类的 this 对象。在子类构造函数中，调用 super 后，才可使用 this 关键字，否则报错。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>setTimeout中的this指向</title>
      <link href="/ZJY.github.io/2021/03/01/settimeout%E4%B8%AD%E7%9A%84this%E6%8C%87%E5%90%91/"/>
      <url>/ZJY.github.io/2021/03/01/settimeout%E4%B8%AD%E7%9A%84this%E6%8C%87%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h2 id="setTimeout中的this指向"><a href="#setTimeout中的this指向" class="headerlink" title="setTimeout中的this指向"></a>setTimeout中的this指向</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    x:<span class="number">2</span>,</span><br><span class="line">    fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(obj)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.fn(); </span><br><span class="line"><span class="comment">//output:</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     x:2,</span></span><br><span class="line"><span class="comment">//     fn:f()</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     x:2,</span></span><br><span class="line"><span class="comment">//     fn:f()</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(obj.fn, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//window全局对象</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     x:2,</span></span><br><span class="line"><span class="comment">//     fn:f()</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//等同于：setTimeout是window下的方法</span></span><br><span class="line"><span class="built_in">window</span>.setTimeout(obj.fn, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// obj.fn相当于把fn函数给拿出来调用</span></span><br><span class="line"><span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);<span class="comment">//this是全局对象</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//全局</span></span><br><span class="line">        <span class="built_in">console</span>.log(obj);<span class="comment">//obj</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript的Object.create方法</title>
      <link href="/ZJY.github.io/2021/03/01/javascript%E7%9A%84Object-create%E6%96%B9%E6%B3%95/"/>
      <url>/ZJY.github.io/2021/03/01/javascript%E7%9A%84Object-create%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h2><p>Object.create()方法创建一个新的对象,使用现有的对象来提供新创建对象的<strong>proto</strong>.</p><p>语法:</p><p>  Object.create(proto, [propertiesObject])</p><p>参数:</p><p>  proto:新创建对象的原型对象,<br>  propertiesObject:可选,需要传入一个对象.该对象的属性类型,参照Object.defineProperties()的</p><p>第二个参数.如果该参数被指定且不为undefined,该传入对象的自有可枚举属性(即其自身定义的属性,而不是其原型链上的枚举属性)将为新创建的对象添加指定的属性值和对应的属性描述符.</p><p>返回值:一个新对象,带着指定的原型对象和属性</p><p>例外:如果propertiesObject参数是null或非原始包装对象,则抛出一个typeerror异常</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  isHuman: <span class="literal">false</span>,</span><br><span class="line">  printIntroduction: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>. Am I human? <span class="subst">$&#123;<span class="built_in">this</span>.isHuman&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> me = <span class="built_in">Object</span>.create(person);</span><br><span class="line"><span class="built_in">console</span>.log(me);</span><br><span class="line"><span class="comment">// me&#123;</span></span><br><span class="line"><span class="comment">//     __proto__:&#123;</span></span><br><span class="line"><span class="comment">//         isHuman: false,</span></span><br><span class="line"><span class="comment">//         printIntroduction:function()</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">me.name = <span class="string">&#x27;zjy&#x27;</span>;</span><br><span class="line">me.isHuman = <span class="literal">true</span>;</span><br><span class="line">me.printIntroduction();</span><br><span class="line"><span class="built_in">console</span>.log(me);</span><br><span class="line"><span class="comment">// me&#123;</span></span><br><span class="line"><span class="comment">//     isHuman: true,</span></span><br><span class="line"><span class="comment">//     name:&#x27;zjy&#x27;,</span></span><br><span class="line"><span class="comment">//     __proto__:&#123;</span></span><br><span class="line"><span class="comment">//         isHuman: false,</span></span><br><span class="line"><span class="comment">//         printIntroduction:function()</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xxx = <span class="built_in">Object</span>.create(&#123;</span><br><span class="line">    a:<span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;,&#123;</span><br><span class="line">    <span class="string">&#x27;str&#x27;</span>:&#123;</span><br><span class="line">        value:<span class="string">&#x27;zjy&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>:&#123;</span><br><span class="line">        value:<span class="string">&#x27;ha&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(xxx);</span><br><span class="line"><span class="comment">// xxx&#123;</span></span><br><span class="line"><span class="comment">//     name:&#x27;ha&#x27;,</span></span><br><span class="line"><span class="comment">//     str:&#x27;zjy&#x27;,</span></span><br><span class="line"><span class="comment">//     __proto__:&#123;</span></span><br><span class="line"><span class="comment">//         a:&#x27;a&#x27;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aObj = &#123;</span><br><span class="line">    a:<span class="string">&#x27;zjy&#x27;</span>,</span><br><span class="line">    b:<span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">    c:<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;n:&#x27;</span>+n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> _aObj = <span class="built_in">Object</span>.create(aObj,&#123;</span><br><span class="line">    txt:&#123;</span><br><span class="line">        value:<span class="string">&#x27;Object.create()方法的继承&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(_aObj);</span><br><span class="line"><span class="comment">// _aObj&#123;</span></span><br><span class="line"><span class="comment">//     txt:&#x27;Object.create()方法的继承&#x27;,</span></span><br><span class="line"><span class="comment">//     __proto__:&#123;</span></span><br><span class="line"><span class="comment">//         a:&#x27;zjy&#x27;,</span></span><br><span class="line"><span class="comment">//         b:&#x27;name&#x27;,</span></span><br><span class="line"><span class="comment">//         c:funtion()</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">_aObj.c(<span class="string">&#x27;haha&#x27;</span>); <span class="comment">// n:haha</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript的Object.entries方法</title>
      <link href="/ZJY.github.io/2021/03/01/javascript%E7%9A%84Object-entries%E6%96%B9%E6%B3%95/"/>
      <url>/ZJY.github.io/2021/03/01/javascript%E7%9A%84Object-entries%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="Object-entries方法"><a href="#Object-entries方法" class="headerlink" title="Object.entries方法"></a>Object.entries方法</h2><p>Object.entries()方法会返回指定对象自身可枚举属性，并返回其健值对数组，其排列与使用与for…in遍历该对象时返回一致，只不过for…in还会枚举其原型链中属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;</span><br><span class="line">    a: <span class="string">&#x27;somestring&#x27;</span>,</span><br><span class="line">    b: <span class="number">42</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(object1));</span><br><span class="line"><span class="comment">// Array：[[&#x27;a&#x27;,&#x27;somestring&#x27;],[&quot;b&quot;,42]]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(object1)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a: somestring</span></span><br><span class="line"><span class="comment">// b: 42</span></span><br></pre></td></tr></table></figure><p>语法：Object.entries(obj)<br>参数：<br>obj: 可以返回枚举健值对的对象<br>返回值：返回指定对象可枚举属性的健值对数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">  baz: <span class="number">42</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(obj)); <span class="comment">// [ [&#x27;foo&#x27;, &#x27;bar&#x27;], [&#x27;baz&#x27;, 42] ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// array like object</span></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">&#x27;c&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(obj1)); <span class="comment">// [ [&#x27;0&#x27;, &#x27;a&#x27;], [&#x27;1&#x27;, &#x27;b&#x27;], [&#x27;2&#x27;, &#x27;c&#x27;] ]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// array like object with random key ordering</span></span><br><span class="line"><span class="keyword">const</span> anObj = &#123;</span><br><span class="line">    <span class="number">100</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="number">7</span>: <span class="string">&#x27;c&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(anObj)); <span class="comment">// [ [&#x27;2&#x27;, &#x27;b&#x27;], [&#x27;7&#x27;, &#x27;c&#x27;], [&#x27;100&#x27;, &#x27;a&#x27;] ]</span></span><br><span class="line"><span class="keyword">for</span> (k <span class="keyword">in</span> anObj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(k); <span class="comment">//2   7   10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// getFoo is property which isn&#x27;t enumerable</span></span><br><span class="line"><span class="comment">// create和defineProperty方法创建对象属性,enumerable默认值为false</span></span><br><span class="line"><span class="keyword">const</span> myObj = <span class="built_in">Object</span>.create(&#123;&#125;, &#123;</span><br><span class="line">  getFoo: &#123;</span><br><span class="line">      <span class="function"><span class="title">value</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">this</span>.foo;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(myObj); <span class="comment">//&#123; getFoo:()&#125;</span></span><br><span class="line">myObj.foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myObj); <span class="comment">//&#123;foo:&quot;bar&quot;,getFoo:()&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(myObj)); <span class="comment">// [ [&#x27;foo&#x27;, &#x27;bar&#x27;] ]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// non-object argument will be coerced to an object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// [ [&#x27;0&#x27;, &#x27;f&#x27;], [&#x27;1&#x27;, &#x27;o&#x27;], [&#x27;2&#x27;, &#x27;o&#x27;] ]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// iterate through key-value gracefully</span></span><br><span class="line"><span class="keyword">const</span> objs = &#123;</span><br><span class="line">    a: <span class="number">5</span>,</span><br><span class="line">    b: <span class="number">7</span>,</span><br><span class="line">    c: <span class="number">9</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(objs)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> <span class="subst">$&#123;value&#125;</span>`</span>); <span class="comment">// &quot;a 5&quot;, &quot;b 7&quot;, &quot;c 9&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Or, using array extras</span></span><br><span class="line"><span class="built_in">Object</span>.entries(objs).forEach(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> <span class="subst">$&#123;value&#125;</span>`</span>); <span class="comment">// &quot;a 5&quot;, &quot;b 7&quot;, &quot;c 9&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Object转换为Map:</span></span><br><span class="line"><span class="comment">// new Map() 构造函数接受一个可迭代的entries。借助Object.entries方法你可以</span></span><br><span class="line"><span class="comment">// 很容易的将Object转换为Map:</span></span><br><span class="line"><span class="keyword">var</span> obj3 = &#123; <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;; </span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(obj3));</span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// Map &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript的Object.assign方法</title>
      <link href="/ZJY.github.io/2021/03/01/javascript%E7%9A%84Object-assign%E6%96%B9%E6%B3%95/"/>
      <url>/ZJY.github.io/2021/03/01/javascript%E7%9A%84Object-assign%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Object.assign方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象，并返回目标对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> resourceObject = &#123;</span><br><span class="line">    b: <span class="number">4</span>,</span><br><span class="line">    c: <span class="number">5</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> resourceObject1 = &#123;</span><br><span class="line">    d: <span class="number">6</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> returnObject = <span class="built_in">Object</span>.assign(target, resourceObject, resourceObject1);</span><br><span class="line"><span class="built_in">console</span>.log(target);</span><br><span class="line"><span class="built_in">console</span>.log(returnObject);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   a:1,</span></span><br><span class="line"><span class="comment">//   b:4,</span></span><br><span class="line"><span class="comment">//   c:5,</span></span><br><span class="line"><span class="comment">//   d:6</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>语法：Object.assign(target,…resource);<br>参数：</p><ul><li>target：目标对象</li><li>resource：源对象<br>返回值：目标对象<br>描述：如果目标对象和源对象有相同属性，则目标对象属性值会被源对象覆盖，相应的后面的源对象的属性会覆盖前面源对象的属性</li></ul><p>Object.assign只会拷贝源对象自身的并且可枚举属性到目标对象上。该方法使用源对象的getter方法和目标对象的setter方法。因此他分配属性不仅仅是复制或定义新的属性。<br>如果合并源包含getter，可能不适合将新属性合并到原型上，为了将属性定义复制到原型，应使用Object.defineProperty和Object.getOwnPropertyDescriptor()</p><p>注意，Object.assign不会在源对象属性值为null或undefined时抛出错误</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">    test:<span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">    foo:<span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(a,b)</span><br><span class="line"><span class="comment">// &#123;test:null, foo:undefined&#125;</span></span><br></pre></td></tr></table></figure><p>String和Symbol类型的属性都会被拷贝.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">    c: <span class="built_in">Symbol</span>.for(<span class="number">1</span>),</span><br><span class="line">    d: <span class="built_in">String</span>(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(b, <span class="string">&#x27;b&#x27;</span>, &#123;</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="number">4</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> c = <span class="built_in">Object</span>.assign(a, b);</span><br><span class="line"><span class="built_in">console</span>.log(c);</span><br><span class="line"><span class="comment">// object&#123;</span></span><br><span class="line"><span class="comment">//     a:1,</span></span><br><span class="line"><span class="comment">//     b:2,</span></span><br><span class="line"><span class="comment">//     c:Symbol(1),</span></span><br><span class="line"><span class="comment">//     d:&#x27;aaa&#x27;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getter获取a.b属性的值，对目标对象b.b属性进行覆盖，调用b的setter方法，但b.b不可修改，报错</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="built_in">Object</span>.assign(b,a);<span class="comment">//typeerror:cannot assign to read only property &#x27;b&#x27; </span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> aa = &#123;</span><br><span class="line">    a: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> bb = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(bb, <span class="string">&#x27;b&#x27;</span>, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;i am b&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> cc = <span class="built_in">Object</span>.assign(aa, bb);</span><br><span class="line"><span class="built_in">console</span>.log(cc);</span><br><span class="line"><span class="comment">// object&#123;</span></span><br><span class="line"><span class="comment">//     a:&#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#125;//不能将含有getter的属性合并到原型中</span></span><br></pre></td></tr></table></figure><h3 id="深拷贝问题"><a href="#深拷贝问题" class="headerlink" title="深拷贝问题:"></a>深拷贝问题:</h3><p>针对深拷贝，需要使用其他办法，因为 Object.assign()拷贝的是（可枚举）属性值。<br>假如源值是一个对象的引用，它仅仅会复制其引用值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> log = <span class="built_in">console</span>.log;</span><br><span class="line"><span class="keyword">const</span> stringify = <span class="built_in">JSON</span>.stringify</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    &#x27;use strict&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">        a: <span class="number">0</span>,</span><br><span class="line">        b: &#123;</span><br><span class="line">            c: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1);</span><br><span class="line">    log(stringify(obj2)); <span class="comment">//&#123;&quot;a&quot;:0,&quot;b&quot;:&#123;&quot;c&quot;:0&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    obj1.a = <span class="number">1</span>;</span><br><span class="line">    log(stringify(obj1)); <span class="comment">//&#123;&quot;a&quot;:1,&quot;b&quot;:&#123;&quot;c&quot;:0&#125;&#125;</span></span><br><span class="line">    log(stringify(obj2)); <span class="comment">//&#123;&quot;a&quot;:0,&quot;b&quot;:&#123;&quot;c&quot;:0&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    obj2.a = <span class="number">2</span>;</span><br><span class="line">    log(stringify(obj1)); <span class="comment">//&#123;&quot;a&quot;:1,&quot;b&quot;:&#123;&quot;c&quot;:0&#125;&#125;</span></span><br><span class="line">    log(stringify(obj2)); <span class="comment">//&#123;&quot;a&quot;:2,&quot;b&quot;:&#123;&quot;c&quot;:0&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    obj2.b.c = <span class="number">3</span>;</span><br><span class="line">    log(stringify(obj1)); <span class="comment">//&#123;&quot;a&quot;:1,&quot;b&quot;:&#123;&quot;c&quot;:3&#125;&#125;</span></span><br><span class="line">    log(stringify(obj2)); <span class="comment">//&#123;&quot;a&quot;:1,&quot;b&quot;:&#123;&quot;c&quot;:3&#125;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//deep clone</span></span><br><span class="line">    obj1 = &#123;</span><br><span class="line">        a: <span class="number">0</span>,</span><br><span class="line">        b: &#123;</span><br><span class="line">            c: <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> obj3 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj1));</span><br><span class="line">    obj1.a = <span class="number">4</span>;</span><br><span class="line">    obj1.b.c = <span class="number">4</span>;</span><br><span class="line">    log(stringify(obj3)); <span class="comment">//&#123;&quot;a&quot;:0,&quot;b&quot;:&#123;&quot;c&quot;:0&#125;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>合并对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 = &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> o2 = &#123;</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> o3 = &#123;</span><br><span class="line">    c: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj4 = <span class="built_in">Object</span>.assign(o1, o2, o3);</span><br><span class="line"><span class="built_in">console</span>.log(obj4); <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(o1); <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;, 注意目标对象自身也会改变</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>合并具有相同属性的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oo1 = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">1</span>,</span><br><span class="line">  c: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> oo2 = &#123;</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> oo3 = &#123;</span><br><span class="line">  c: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj5 = <span class="built_in">Object</span>.assign(&#123;&#125;, oo1, oo2, oo3);</span><br><span class="line"><span class="built_in">console</span>.log(obj5); <span class="comment">// &#123; a: 1, b: 2, c: 3 &#125;</span></span><br></pre></td></tr></table></figure><p>拷贝 symbol 类型的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> v1 = &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> v2 = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)]: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj6 = <span class="built_in">Object</span>.assign(&#123;&#125;, v1, v2);</span><br><span class="line"><span class="built_in">console</span>.log(obj6); <span class="comment">// &#123; a : 1, Symbol(&quot;foo&quot;): 2 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(obj6)); <span class="comment">// [Symbol(foo)]</span></span><br></pre></td></tr></table></figure><p>继承属性和不可枚举属性是不能拷贝的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj7 = <span class="built_in">Object</span>.create(&#123;</span><br><span class="line">    foo: <span class="number">1</span></span><br><span class="line">&#125;, &#123; <span class="comment">// foo 是个继承属性。</span></span><br><span class="line">    bar: &#123;</span><br><span class="line">        value: <span class="number">2</span> <span class="comment">// bar 是个不可枚举属性。</span></span><br><span class="line">    &#125;,</span><br><span class="line">    baz: &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        enumerable: <span class="literal">true</span> <span class="comment">// baz 是个自身可枚举属性。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> copy = <span class="built_in">Object</span>.assign(&#123;&#125;, obj7);</span><br><span class="line"><span class="built_in">console</span>.log(copy); <span class="comment">// &#123; baz: 3 &#125;</span></span><br></pre></td></tr></table></figure><p>原始类型会被包装为对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m1 = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> m2 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> m3 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> m4 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> res = <span class="built_in">Object</span>.assign(&#123;&#125;, m1, <span class="literal">null</span>, m2, <span class="literal">undefined</span>, m3, m4);</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//     0:&#x27;a&#x27;,</span></span><br><span class="line"><span class="comment">//     1:&#x27;b&#x27;,</span></span><br><span class="line"><span class="comment">//     2:&#x27;c&#x27;,</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> res) <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(res <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res1 = <span class="built_in">Object</span>.assign(<span class="literal">true</span>, <span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res1);</span><br><span class="line"><span class="comment">// Boolean&#123;</span></span><br><span class="line"><span class="comment">//     true,</span></span><br><span class="line"><span class="comment">//     0:&#x27;a&#x27;,</span></span><br><span class="line"><span class="comment">//     1:&#x27;b&#x27;,</span></span><br><span class="line"><span class="comment">//     2:&#x27;c&#x27;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> res1); <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(res1 <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res2 = <span class="built_in">Object</span>.assign(<span class="string">&#x27;abc&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res2);</span><br><span class="line"><span class="comment">// String&#123;</span></span><br><span class="line"><span class="comment">//     0:&#x27;a&#x27;,</span></span><br><span class="line"><span class="comment">//     1:&#x27;b&#x27;,</span></span><br><span class="line"><span class="comment">//     2:&#x27;c&#x27;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> res2); <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(res2 <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res3 = <span class="built_in">Object</span>.assign(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(res3);</span><br><span class="line"><span class="comment">// Number&#123;10,0:&#x27;a&#x27;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> res3); <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(res3 <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>异常会打断后续拷贝任务</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> targetObj = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">&quot;foo&quot;</span>, &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">  writable: <span class="literal">false</span></span><br><span class="line">&#125;); <span class="comment">// targetObj 的 foo 属性是个只读属性。</span></span><br><span class="line"><span class="built_in">Object</span>.assign(targetObj, &#123;<span class="attr">bar</span>: <span class="number">2</span>&#125;, &#123;<span class="attr">foo2</span>: <span class="number">3</span>, <span class="attr">foo</span>: <span class="number">3</span>, <span class="attr">foo3</span>: <span class="number">3</span>&#125;, &#123;<span class="attr">baz</span>: <span class="number">4</span>&#125;);<span class="comment">// TypeError: &quot;foo&quot; is read-only</span></span><br></pre></td></tr></table></figure><p>注意这个异常是在拷贝第二个源对象的第二个属性时发生的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// console.log(targetObj);//&#123;bar:2,foo2:3,foo:1&#125;</span></span><br><span class="line"><span class="comment">// console.log(targetObj.bar);  // 2，说明第一个源对象拷贝成功了。</span></span><br><span class="line"><span class="comment">// console.log(targetObj.foo2); // 3，说明第二个源对象的第一个属性也拷贝成功了。</span></span><br><span class="line"><span class="comment">// console.log(targetObj.foo);  // 1，只读属性不能被覆盖，所以第二个源对象的第二个属性拷贝失败了。</span></span><br><span class="line"><span class="comment">// console.log(targetObj.foo3); // undefined，异常之后 assign 方法就退出了，第三个属性是不会被拷贝到的。</span></span><br><span class="line"><span class="comment">// console.log(targetObj.baz);  // undefined，第三个源对象更是不会被拷贝到的。</span></span><br></pre></td></tr></table></figure><p>拷贝访问器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  foo: <span class="number">1</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">bar</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)]: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> copy1 = <span class="built_in">Object</span>.assign(&#123;&#125;, o);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;assign&#x27;</span>,copy1); <span class="comment">//copy.bar的值来自obj.bar的getter函数的返回值 &#123;foo:1,bar:2&#125;</span></span><br><span class="line"><span class="comment">// assign&#123;</span></span><br><span class="line"><span class="comment">//     bar:2,</span></span><br><span class="line"><span class="comment">//     foo:1,</span></span><br><span class="line"><span class="comment">//     Symbol(foo):1</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript的reduce方法</title>
      <link href="/ZJY.github.io/2021/03/01/javascript%E7%9A%84reduce%E6%96%B9%E6%B3%95/"/>
      <url>/ZJY.github.io/2021/03/01/javascript%E7%9A%84reduce%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>reduce()方法接收一个函数作为累加器，数组中的每个值从左向右缩减，最终计算为一个值<br>reduce()作为空数组不会执行回调函数的。</p><p>语法:<br>reduce(function(total,currentValue,currentIndex,arr),initalValue);<br>参数：</p><ul><li>function(total,currentValue,currentIndex,arr)：必须，用于执行每个数组元素的函数<ul><li>total:必须，初始值或者用于计算后返回的函数值</li><li>currentValue:必须，当前值</li><li>currentIndex：可选，当前元素索引</li><li>arr: 可选，当前元素所属的数组对象</li></ul></li><li>initalValue:可选，传递给函数的初始值</li></ul><p>返回值：计算结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">total,num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> total + num</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//6</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript中this的指向</title>
      <link href="/ZJY.github.io/2021/03/01/javascript%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91/"/>
      <url>/ZJY.github.io/2021/03/01/javascript%E4%B8%ADthis%E7%9A%84%E6%8C%87%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h2 id="javascript中this的指向"><a href="#javascript中this的指向" class="headerlink" title="javascript中this的指向"></a>javascript中this的指向</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xx</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">//window</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span> === <span class="built_in">window</span>); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line">xx();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> yy = &#123;</span><br><span class="line">  a:<span class="string">&#x27;zjy&#x27;</span>,</span><br><span class="line">  b:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//yy</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span> === yy);<span class="comment">//true</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">bb</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//window</span></span><br><span class="line">      &#125;</span><br><span class="line">      bb();<span class="comment">//bb只是在yy的属性b中执行，并不是b的属性，属于window</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">yy.b();</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    s:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = o.s;</span><br><span class="line">f();<span class="comment">//this指向window,js中函数是按引用传递的</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xx3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.x = <span class="number">333</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">//xx3:&#123;x: 333&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.__proto__==xx3.prototype);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> xx3();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dom事件级别</title>
      <link href="/ZJY.github.io/2021/03/01/dom%E4%BA%8B%E4%BB%B6%E7%BA%A7%E5%88%AB/"/>
      <url>/ZJY.github.io/2021/03/01/dom%E4%BA%8B%E4%BB%B6%E7%BA%A7%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="DOM事件级别"><a href="#DOM事件级别" class="headerlink" title="DOM事件级别"></a>DOM事件级别</h2><p>DOM级别一共可以分为四个级别：DOM0级、DOM1级、DOM2级和DOM3级。而DOM事件分为3个级别：DOM 0级事件处理，DOM 2级事件处理和DOM 3级事件处理。由于DOM 1级中没有事件的相关内容，所以没有DOM 1级事件</p><h2 id="dom0级事件"><a href="#dom0级事件" class="headerlink" title="dom0级事件"></a>dom0级事件</h2><p>使用DOM0方式为事件程序赋值时，所赋函数被视为元素的方法。因此，事件处理程序会在元素的作用域运行，即this等于元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;btn1&quot;</span>  /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn1&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.id)l <span class="comment">//&quot;btn1&quot;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;click me: dom0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn1&#x27;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;click me: dom0-111&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击btn1时，输出’click me: dom0-111’，dom0只支持给一个事件添加一个处理程序.dom0级事件处理程序在元素的作用域运行。通过设置btn.onclick = null;可移除事件处理程序。</p><h2 id="dom2级事件"><a href="#dom2级事件" class="headerlink" title="dom2级事件"></a>dom2级事件</h2><p>el.addEventListener(event-name, callback, useCapture);<br>事件名，事件处理函数，布尔值（false默认值，冒泡阶段调用事件处理函数，true：捕获阶段调用事件处理函数）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn1&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;click me: addEventListener111&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn1&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;click me: addEventListener222&#x27;</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>点击btn1，依次输出：<br>click me: addEventListener111<br>click me: addEventListener222</p><p>用addEventListener函数添加的事件必须用removeEventListener()函数移除，且传参数一致。这意味着使用addEventListener添加的匿名函数无法移除，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn1&#x27;</span>);</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;click me: addEventListener111&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//没有效果</span></span><br><span class="line">btn.removeEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;click me: addEventListener111&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>传给removeEventListener()的事件处理函数必须与传给addEventListener()的是同一个，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn1&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);</span><br><span class="line">&#125;</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>,handler,<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//没有效果</span></span><br><span class="line">btn.removeEventListener(<span class="string">&#x27;click&#x27;</span>,handler,<span class="literal">false</span>);<span class="comment">//有效果</span></span><br></pre></td></tr></table></figure><p><strong>IE事件处理程序：</strong><br>attachEvent()和detachEvent()接收同样的参数：事件处理程序的名字和事件处理函数。因为IE8及更早版本只支持冒泡，所以使用attachEvent添加的事件处理程序只会添加到冒泡阶段。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn1&#x27;</span>);</span><br><span class="line">btn.attachEvent(<span class="string">&quot;onclick&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;clicked&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">btn.attachEvent(<span class="string">&quot;onclick&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>attachEvent()的第一个参数是”onclick”而不是“click”</p><p>事件触发是反向触发，先打印“hello world“再打印”clicked”.</p><p>使用detachEvent()来移除事件处理程序，只要提供和attachEvent相同的参数。</p><p>作为事件处理程序添加的匿名函数也无法移除。</p><p>且attachEvent()添加事件处理程序是在全局作用域运行的。因此this === window</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.attachEvent(<span class="string">&quot;onclick&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span> === <span class="built_in">window</span>); <span class="comment">//true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="dom3级事件：在dom2级事件基础上添加了更多的事件类型"><a href="#dom3级事件：在dom2级事件基础上添加了更多的事件类型" class="headerlink" title="dom3级事件：在dom2级事件基础上添加了更多的事件类型"></a>dom3级事件：在dom2级事件基础上添加了更多的事件类型</h2><p>UI事件:当用户与页面上元素交互时触发,比如:load,scroll,<br>焦点事件:当元素获得或失去焦点时触发,比如:blur,focus,<br>鼠标事件:当用户通过鼠标在页面执行操作时触发如：dblclick、mouseup,<br>滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel<br>文本事件，当在文档中输入文本时触发，如：textInput<br>键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress<br>合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart<br>变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified<br>同时DOM3级事件也允许使用者自定义一些事件</p><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>event对象是传递给事件处理程序的唯一参数，不管以那种方式指定事件处理程序。</p><p>event.type:执行事件的类型<br>event.eventPhase:用于确定事件流当前所处的阶段。1:捕获阶段被调用  2:目标阶段被调用  3:冒泡阶段被调用。</p><p>在IE中，dom事件对象如果是使用dom0方式指定的，event对象只是window对象的一个属性:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn1&#x27;</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> event = <span class="built_in">window</span>.event;</span><br><span class="line">  <span class="built_in">console</span>.log(event.type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是attachEvent指定的事件处理程序，event对象仍然是window对新的属性，但是出于方便也将其作为参数传入。</p><h2 id="DOM事件模型和事件流"><a href="#DOM事件模型和事件流" class="headerlink" title="DOM事件模型和事件流"></a>DOM事件模型和事件流</h2><p>DOM事件模型分为捕获和冒泡。一个事件发生后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段</p><p>1.捕获阶段：事件从window对象自上而下向目标节点传播的阶段<br>2.目标阶段：真正的目标节点正在处理事件的阶段<br>3.冒泡阶段：事件从目标节点自下而上向window对象传播的阶段</p><h2 id="事件代理（事件委托）"><a href="#事件代理（事件委托）" class="headerlink" title="事件代理（事件委托）"></a>事件代理（事件委托）</h2><p>由于事件会在冒泡阶段传播到父元素上，由父元素监听函数同时处理多个子节点的事件，称为事件代理。<br>优点：减少内存的消耗提高性能</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;list&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 兼容性处理</span></span><br><span class="line">  <span class="keyword">var</span> event = e || <span class="built_in">window</span>.event;</span><br><span class="line">  <span class="keyword">var</span> target = event.target || event.srcElement;</span><br><span class="line">  <span class="comment">// 判断是否匹配目标元素</span></span><br><span class="line">  <span class="keyword">if</span> (target.nodeName.toLocaleLowerCase() === <span class="string">&#x27;li&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;the content is: &#x27;</span>, target.innerHTML);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Event对象常见的应用"><a href="#Event对象常见的应用" class="headerlink" title="Event对象常见的应用"></a>Event对象常见的应用</h2><p>event.preventDefault();阻止默认事件的发生，比如链接跳转，表单提交<br>event.stopPropagation();阻止事件流在dom结构中传播，取消后续的事件捕获或冒泡。<br>event.stopImmediatePropagation();用于取消后续事件捕获或事件冒泡，并阻止调用任何后续事件处理程序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#btn1&#x27;</span>);</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;btn click 1&#x27;</span>);</span><br><span class="line">  event.stopImmediatePropagation();</span><br><span class="line">&#125;);</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;btn click 2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;body click&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>点击btn，输出’btn click 1’</p><h2 id="event-amp-currentTarget"><a href="#event-amp-currentTarget" class="headerlink" title="event &amp; currentTarget"></a>event &amp; currentTarget</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;a&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;b&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;c&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;d&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;a&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;target: &#x27;</span>+ e.target.id+<span class="string">&#x27; &amp;curretTarget: &#x27;</span>+e.currentTarget.id)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;b&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;target: &#x27;</span>+ e.target.id+<span class="string">&#x27; &amp;curretTarget: &#x27;</span>+e.currentTarget.id)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;c&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;target: &#x27;</span>+ e.target.id+<span class="string">&#x27; &amp;curretTarget: &#x27;</span>+e.currentTarget.id)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;d&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;target: &#x27;</span>+ e.target.id+<span class="string">&#x27; &amp;curretTarget: &#x27;</span>+e.currentTarget.id)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>点击d元素，依次输出：<br>target: d &amp;curretTarget: d<br>target: d &amp;curretTarget: c<br>target: d &amp;curretTarget: b<br>target: d &amp;curretTarget: a</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript的双向绑定</title>
      <link href="/ZJY.github.io/2021/02/28/javascript%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"/>
      <url>/ZJY.github.io/2021/02/28/javascript%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<p>实现双向绑定方式：</p><ul><li>1.javascript的get、set方法</li><li>2.Object.defineProperty</li><li>3.es6的proxy</li></ul><h2 id="JavaScript的get-set方法"><a href="#JavaScript的get-set方法" class="headerlink" title="JavaScript的get,set方法"></a>JavaScript的get,set方法</h2><p>在创建新对象初始化时定义一个getter<br>get语法将对象属性绑定到查询该属性时将调用的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  _t:<span class="string">&#x27;zjy&#x27;</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">fn</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._t;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title">fn</span>(<span class="params">_x</span>)&#123;</span><br><span class="line">    <span class="built_in">this</span>._t = _x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.fn); <span class="comment">//zjy</span></span><br><span class="line"><span class="built_in">console</span>.log(obj._t); <span class="comment">//zjy</span></span><br><span class="line">obj.fn = <span class="string">&#x27;hahaha&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.fn); <span class="comment">//hahaha</span></span><br><span class="line"><span class="built_in">console</span>.log(obj._t); <span class="comment">//hahaha</span></span><br></pre></td></tr></table></figure><p>使用delete操作符删除getter</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> obj.fn; <span class="comment">//true</span></span><br><span class="line">obj.fn; <span class="comment">//undefined</span></span><br><span class="line">obj._t; <span class="comment">//hahaha</span></span><br></pre></td></tr></table></figure><h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h2><p>使用defineProperty在现有对象上定义getter<br>要随时在现有对象上添加getter，使用Object.defineProperty</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;b&#x27;</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.a + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj.a); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.b); <span class="comment">//2</span></span><br><span class="line">obj.a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.a); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.b); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">obj.b = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj.b); <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>使用计算出的属性名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expr = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  get [expr]() &#123; <span class="keyword">return</span> <span class="string">&#x27;bar&#x27;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.foo); <span class="comment">//bar</span></span><br></pre></td></tr></table></figure><h3 id="get-vs-defineProperty"><a href="#get-vs-defineProperty" class="headerlink" title="get vs. defineProperty"></a>get vs. defineProperty</h3><p>1.当使用 get 关键字时，它和Object.defineProperty() 有类似的效果，在classes中使用时，二者有细微的差别。</p><p>2.当使用 get 关键字时，属性将被定义在实例的原型上，当使用Object.defineProperty()时，属性将被定义在实例自身上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">hello</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> exa = <span class="keyword">new</span> Example();</span><br><span class="line"><span class="built_in">console</span>.log(exa.hello);<span class="comment">//world</span></span><br></pre></td></tr></table></figure><p>Object.getOwnPropertyDescriptor(obj,property)方法返回指定对象上一个自有属性对应的属性描述符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(exa,<span class="string">&#x27;hello&#x27;</span>); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(getPropertyOf(exa),<span class="string">&#x27;hello&#x27;</span>); <span class="comment">//&#123; configurable: true, enumerable: false, get:funciton, set:undefined&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="string">&#x27;aaa&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">//&#123; configurable: true, enumerable: true, value: &quot;aaa&quot;, writable: true&#125;</span></span><br></pre></td></tr></table></figure><p>语法：Object.getOwnPropertyDescriptor(obj,prop)<br>参数：</p><ul><li>1.obj:需要查找的对象</li><li>2.prop:目标对象内属性名称</li><li>3.返回值：如果指定的属性存在对象上，则返回其属性描述符对象。否则返回undefined</li><li>4.描述：该方法允许对一个属性的描述进行检索。属性描述符由以下组成：<ul><li>value：该属性的值（仅针对数据属性描述符有效）</li><li>writable：当且仅当该属性值可修改时为true（仅数据描述符有效）</li><li>get: 获取该属性的访问器函数，如果没有访问器，则该值为undefined（仅针对包含访问器或设置器的属性描述符有效）</li><li>set: 获取该属性的设置器函数，如果没有设置器，则该值为undefined（仅针对包含访问器或设置器的属性描述符有效）</li><li>configurable: 当且仅当对象属性描述可以被改变或者该属性可以被删除时，该值为true</li><li>enumerble: 当且仅当属性可枚举时，该值为true</li></ul></li></ul><p>访问器属性描述符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">foo</span>()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">17</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj,<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line"><span class="comment">//&#123; enumerable: true, configurable: true, get:f foo(), set:undefined&#125;</span></span><br></pre></td></tr></table></figure><p>数据属性描述符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo:<span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(obj,<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line"><span class="comment">//&#123; writable: true, value:&#x27;bar&#x27;, configurable: true, enumerable:true&#125;</span></span><br></pre></td></tr></table></figure><p>使用Object.defineProperty(obj,prop)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;foo&#x27;</span>,&#123;</span><br><span class="line">    value: <span class="number">12</span>,</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    enumerable:<span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(o,<span class="string">&#x27;foo&#x27;</span>));</span><br><span class="line"><span class="comment">// &#123;value: 12, writable: false, enumerable: false, configurable: false&#125;</span></span><br></pre></td></tr></table></figure><p>Object.defineProperty()方法会直接在一个对象上定义一个新的属性，或者修改一个对象的现有属性，并返回此对象。<br>备注：应当直接在 Object 构造器对象上调用此方法，而不是在任意一个 Object 类型的实例上调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj1,<span class="string">&#x27;property1&#x27;</span>,&#123;</span><br><span class="line">    value:<span class="number">44</span>,</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line">obj1.property1 = <span class="number">77</span>;<span class="comment">//// throws an error in strict mode</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.property1); <span class="comment">//44</span></span><br></pre></td></tr></table></figure><p>语法：Object.defineProperty(obj,prop,desc)<br>参数：</p><ul><li>obj: 要定义属性的对象</li><li>prop: 要定义或要修改的属性名称或Symbol</li><li>desc：要定义或要修改的属性描述符</li></ul><p>返回值：被传递给函数的对象<br>描述：该方法允许精确的添加或修改对象的属性。通过赋值操作添加的普通属性都是可枚举的（例：var obj = {a:’a’}）.可通过for…in或Object.keys枚举到。可以修改这些属性的值，也可以删除属性。</p><p>默认情况下，通过Object.defineProperty方法添加的属性是不可修改的。<br>对象里目前存在2种类型的描述符：</p><ul><li>数据描述符：具有值的属性，该值可被修改也可以不能被修改</li><li>存取描述符：由getter或者setter函数所描述的属性</li></ul><p>一个描述符只能是2种描述符的一种，不能同时存在。他们共享以下可选健值（默认值是指在使用Object.defineProperty()定义属性时的默认值）：</p><ul><li>configurable: 当且仅当该值为true时，该属性的值可修改，属性也可以被删除</li><li>enumerable：当且仅当该值为true时，该属性可以被枚举</li></ul><p>数据描述符还具有以下可选健值：</p><ul><li>value：该属性对应的值，可以是任何任何js值，默认为undefined</li><li>writable: 当且仅当该值为true时，value的值才可被赋值运算修改，默认为false</li></ul><p>存取描述符还具有以下可选健值：</p><ul><li>get：属性的getter函数，如果没有，则为undefined，当访问该属性时，会调用该函数，执行时不传入任何参数，但是会默认传入this对象，由于继承关系，this不一定是该属性所属对象，该函数的返回值被用作属性的值默认为undefined</li><li>set：属性的setter函数，如果没有，则为undefined，当属性值被修改时，会调用该函数，该方法接受一个参数。默认把赋值时的this对象传入，默认值为undefined</li></ul><p>描述符汇总：<br>拥有布尔值的属性：writable,configurable,enumerable,默认值false<br>属性值和函数的键：value,get,set，默认值undefined</p><p>描述符可以拥有的健值：</p><table><thead><tr><th></th><th>enumerable</th><th>configurable</th><th>writable</th><th>value</th><th>get</th><th>set</th></tr></thead><tbody><tr><td>数据描述符</td><td>可以</td><td>可以</td><td>可以</td><td>可以</td><td>不可以</td><td>不可以</td></tr><tr><td>存取描述符</td><td>可以</td><td>可以</td><td>不可以</td><td>不可以</td><td>可以</td><td>可以</td></tr></tbody></table><p>如果一个描述符不具有value,writable，get，set中任意一个键,那么它将会被认为是一个数据描述符.</p><p>如果一个描述符同时拥有value或writable和get或set值,则会产生异常.</p><p>这些选项不一定是自身属性,也要考虑继承来的属性.</p><h3 id="创建属性："><a href="#创建属性：" class="headerlink" title="创建属性："></a>创建属性：</h3><p>如果对象中不存在指定的值,Object.defineProperty()会创建这个属性.当描述符中省略某些字段时,这些字段会使用默认值.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;<span class="comment">//创建一个新对象</span></span><br><span class="line"><span class="comment">//在对象中添加一个属性与属性描述符的示例</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&quot;a&quot;</span>,&#123;</span><br><span class="line">  value: <span class="number">37</span>,</span><br><span class="line">  writable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configuarable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o.a);</span><br><span class="line"><span class="comment">// 对象 o 拥有了属性 a，值为 37</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在对象中添加一个设置了存取描述符属性的示例</span></span><br><span class="line"><span class="keyword">var</span> bValue = <span class="number">38</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&quot;b&quot;</span>,&#123;</span><br><span class="line">  <span class="comment">//使用了方法名称缩写（ES2015特性）</span></span><br><span class="line">  <span class="comment">//下面两个缩写等价于：</span></span><br><span class="line">  <span class="comment">//get:function() &#123; return bValue&#125;,</span></span><br><span class="line">  <span class="comment">//set:function() &#123; return bValue;&#125;,</span></span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;<span class="keyword">return</span> bValue;&#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123; bValue = newValue&#125;,</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configuarable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line">o.b; <span class="comment">//38</span></span><br><span class="line"><span class="built_in">console</span>.log(o.b);</span><br><span class="line"><span class="comment">// 对象 o 拥有了属性 b，值为 38</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据描述符和存取描述符不能混合使用</span></span><br><span class="line"><span class="comment">// Object.defineProperty(o,&quot;conflict&quot;, &#123;</span></span><br><span class="line"><span class="comment">//   value: 0x9f91102,</span></span><br><span class="line"><span class="comment">//   get() &#123; return 0xdeadbeef&#125;</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br></pre></td></tr></table></figure><h3 id="修改属性："><a href="#修改属性：" class="headerlink" title="修改属性："></a>修改属性：</h3><p>如果属性已经存在，Object.defineProperty将尝试根据描述符中的值以及对象当前配置来修改这个属性。<br>如果旧属性将configurable值设置false，则该属性不可被配置，其他属性不可修改（除来单向将writable设置为false）<br>当试图改变不可配置属性的值时,除了value和writable属性之外,会抛出typeerror,除非当前值和新值相同.</p><h3 id="writable属性："><a href="#writable属性：" class="headerlink" title="writable属性："></a>writable属性：</h3><p>当writable属性设置为false时,该属性不可写,不能重新被赋值.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">    value: <span class="number">37</span>,</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">//37</span></span><br><span class="line">o.a = <span class="number">25</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">//37</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;b&#x27;</span>,&#123;</span><br><span class="line">      value: <span class="number">2</span>,</span><br><span class="line">      writable: <span class="literal">false</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// o.b = 3; //throws typeerror: &quot;b&quot; is read-only</span></span><br><span class="line">  <span class="keyword">return</span> o.b;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><h3 id="enumerable属性"><a href="#enumerable属性" class="headerlink" title="enumerable属性"></a>enumerable属性</h3><p>enumerable属性定义了对象的属性是否可以被for…in或Object.keys所枚举</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">&quot;a&quot;</span>, &#123; <span class="attr">value</span> : <span class="number">1</span>, <span class="attr">enumerable</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">&quot;b&quot;</span>, &#123; <span class="attr">value</span> : <span class="number">2</span>, <span class="attr">enumerable</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">&quot;c&quot;</span>, &#123; <span class="attr">value</span> : <span class="number">3</span> &#125;); <span class="comment">// enumerable 默认为 false</span></span><br><span class="line">o.d = <span class="number">4</span>; <span class="comment">// 如果使用直接赋值的方式创建对象的属性，则 enumerable 为 true</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="built_in">Symbol</span>.for(<span class="string">&#x27;e&#x27;</span>), &#123;</span><br><span class="line">  value: <span class="number">5</span>,</span><br><span class="line">  enumerable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="built_in">Symbol</span>.for(<span class="string">&#x27;f&#x27;</span>), &#123;</span><br><span class="line">  value: <span class="number">6</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> o)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);<span class="comment">// a,d</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Object</span>.keys(o)); <span class="comment">//[&quot;a&quot;,&quot;d&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(o.propertyIsEnumerable(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(o.propertyIsEnumerable(<span class="string">&#x27;b&#x27;</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(o.propertyIsEnumerable(<span class="string">&#x27;c&#x27;</span>));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(o.propertyIsEnumerable(<span class="string">&#x27;d&#x27;</span>));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(o.propertyIsEnumerable(<span class="built_in">Symbol</span>.for(<span class="string">&#x27;e&#x27;</span>)));<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(o.propertyIsEnumerable(<span class="built_in">Symbol</span>.for(<span class="string">&#x27;f&#x27;</span>)));<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(o);</span><br><span class="line"><span class="keyword">var</span> p = &#123; ...o&#125;</span><br><span class="line"><span class="built_in">console</span>.log(p.a);<span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(p.b);<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(p.c);<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(p.d);<span class="comment">//4</span></span><br><span class="line"><span class="built_in">console</span>.log(p[<span class="built_in">Symbol</span>.for(<span class="string">&#x27;e&#x27;</span>)]);<span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(p[<span class="built_in">Symbol</span>.for(<span class="string">&#x27;f&#x27;</span>)]);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><h3 id="configurable属性"><a href="#configurable属性" class="headerlink" title="configurable属性"></a>configurable属性</h3><p>configurable属性定义了该属性是否可被删除，以及除value和writable属性外属性是否可以被修改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">   <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> <span class="number">1</span>;&#125;,</span><br><span class="line">   configuarable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">    configuarable: <span class="literal">true</span></span><br><span class="line">&#125;);<span class="comment">//typeerror:Cannot redefine property &#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">&#125;);<span class="comment">//typeerror:Cannot redefine property &#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;);<span class="comment">//typeerror:Cannot redefine property &#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">&#125;);<span class="comment">//typeerror:Cannot redefine property &#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">    value: <span class="number">12</span></span><br><span class="line">&#125;);<span class="comment">//typeerror:Cannot redefine property &#x27;a&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">//1</span></span><br><span class="line"><span class="keyword">delete</span> o.a;<span class="comment">//false Nothing happens</span></span><br><span class="line"><span class="built_in">console</span>.log(o.a);<span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>如果 o.a 的 configurable 属性为 true，则不会抛出任何错误，并且，最后，该属性会被删除</p><p>添加多个属性和默认值：<br>考虑特性被赋予的默认特性值非常重要,通常,使用点运算符和Object.defineProperty()为对象的属性赋值时,<br>数据描述符中的属性默认值是不同的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">o.a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(o,<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line"><span class="comment">// a &#123;</span></span><br><span class="line"><span class="comment">//     configurable: true</span></span><br><span class="line"><span class="comment">//     enumerable: true</span></span><br><span class="line"><span class="comment">//     value: 1</span></span><br><span class="line"><span class="comment">//     writable: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 等同于:</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">   value:<span class="number">1</span>,</span><br><span class="line">   writable: <span class="literal">true</span>,</span><br><span class="line">   configurable: <span class="literal">true</span>,</span><br><span class="line">   enumerable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//另一方面：</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;b&#x27;</span>,&#123;<span class="attr">value</span>:<span class="number">1</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(o,<span class="string">&#x27;b&#x27;</span>));</span><br><span class="line"><span class="comment">// b&#123;</span></span><br><span class="line"><span class="comment">//     configurable: false</span></span><br><span class="line"><span class="comment">//     enumerable: false</span></span><br><span class="line"><span class="comment">//     value: 1</span></span><br><span class="line"><span class="comment">//     writable: false</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 等同于:</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o,<span class="string">&#x27;b&#x27;</span>, &#123;</span><br><span class="line">   value:<span class="number">1</span>,</span><br><span class="line">   configurable:<span class="literal">false</span>,</span><br><span class="line">   enumerable: <span class="literal">false</span>,</span><br><span class="line">   writable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="自定义setters和getters："><a href="#自定义setters和getters：" class="headerlink" title="自定义setters和getters："></a>自定义setters和getters：</h3><p>下面的例子展示了如何实现一个自存档对象。当设置temperature 属性时，archive 数组会收到日志条目</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Archiver</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> temperature = <span class="literal">null</span>;</span><br><span class="line"> <span class="keyword">var</span> archive = [];</span><br><span class="line"></span><br><span class="line"> <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>, <span class="string">&#x27;temperature&#x27;</span>, &#123;</span><br><span class="line">   get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;get!&#x27;</span>);</span><br><span class="line">     <span class="keyword">return</span> temperature;</span><br><span class="line">   &#125;,</span><br><span class="line">   set: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">     temperature = value;</span><br><span class="line">     archive.push(&#123; <span class="attr">val</span>: temperature &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">this</span>.getArchive = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> archive; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arc = <span class="keyword">new</span> Archiver();</span><br><span class="line">arc.temperature; <span class="comment">// &#x27;get!&#x27;</span></span><br><span class="line">arc.temperature = <span class="number">11</span>;</span><br><span class="line">arc.temperature = <span class="number">13</span>;</span><br><span class="line">arc.getArchive(); <span class="comment">// [&#123; val: 11 &#125;, &#123; val: 13 &#125;]</span></span><br></pre></td></tr></table></figure><p>下面这个例子中，getter 总是会返回一个相同的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = &#123;</span><br><span class="line"> get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&#x27;I alway return this string,whatever you have assigned&#x27;</span>;</span><br><span class="line"> &#125;,</span><br><span class="line"> set: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">this</span>.myname = <span class="string">&#x27;this is my name string&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TestDefineSetAndGet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="built_in">Object</span>.defineProperty(<span class="built_in">this</span>, <span class="string">&#x27;myproperty&#x27;</span>, pattern);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> TestDefineSetAndGet();</span><br><span class="line">instance.myproperty = <span class="string">&#x27;test&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#x27;I alway return this string,whatever you have assigned&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.myproperty);</span><br><span class="line"><span class="comment">// &#x27;this is my name string&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.myname);</span><br></pre></td></tr></table></figure><h3 id="继承属性"><a href="#继承属性" class="headerlink" title="继承属性"></a>继承属性</h3><p>如果访问者的属性是被继承的，它的 get 和 set 方法会在子对象的属性被访问或者修改时被调用。<br>如果这些方法用一个变量存值，该值会被所有对象共享。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myclass</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> value ;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myclass.prototype,<span class="string">&quot;x&quot;</span>,&#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">x</span>)</span> &#123;</span><br><span class="line">        value = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> myclass();</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> myclass();</span><br><span class="line">a.x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b.x);<span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>这可以通过将值存储在另一个属性中解决。在 get 和 set 方法中，this 指向某个被访问和修改属性的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myclass</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myclass.prototype,<span class="string">&quot;x&quot;</span>,&#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.stored_x;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">x</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stored_x = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> myclass();</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> myclass();</span><br><span class="line">a.x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.x);<span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(b.x);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>不像访问者属性，值属性始终在对象自身上设置，而不是一个原型。然而，如果一个不可写的属性被继承，它仍然可以防止修改对象的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myclass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myclass.prototype.x = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(myclass.prototype, <span class="string">&quot;y&quot;</span>, &#123;</span><br><span class="line"> writable: <span class="literal">false</span>,</span><br><span class="line"> value: <span class="number">1</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> myclass();</span><br><span class="line">a.x = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.x); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(myclass.prototype.x); <span class="comment">// 1</span></span><br><span class="line">a.y = <span class="number">2</span>; <span class="comment">// Ignored, throws in strict mode </span></span><br><span class="line"><span class="built_in">console</span>.log(a.y); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(myclass.prototype.y); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS3新特性</title>
      <link href="/ZJY.github.io/2021/02/22/CSS3%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/ZJY.github.io/2021/02/22/CSS3%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="边框属性"><a href="#边框属性" class="headerlink" title="边框属性"></a>边框属性</h2><h3 id="1-border-image边框图片属性"><a href="#1-border-image边框图片属性" class="headerlink" title="1.border-image边框图片属性"></a>1.border-image边框图片属性</h3><p>border-image:none 100% 1 0 stretch; 默认值<br>border-image是一个简写，用于设置以下属性：</p><ul><li>border-image-source: 边框图片路径</li><li>border-image-slice: 图片边框向内偏移</li><li>border-image-width: 图片边框的宽度</li><li>border-image-outset: 边框图像区域超出边框的量</li><li>border-image-repeat: 图片边框是否平铺（repeated）,铺满（rounded）或拉伸（stretched）</li></ul><h3 id="2-border-radius边框圆角属性"><a href="#2-border-radius边框圆角属性" class="headerlink" title="2.border-radius边框圆角属性"></a>2.border-radius边框圆角属性</h3><p>border-radius: 0; 默认值<br>border-radius是一个简写，用于设置以下属性：</p><ul><li>border-top-left-radius: 左上角圆角属性</li><li>border-top-right-radius: 右上角圆角属性，若省略则取top-left的值</li><li>border-bottom-left-radius: 左下角圆角属性，若省略则取top-right的值</li><li>border-bottom-right-radius: 右下角圆角属性，若省略则取top-left的值</li></ul><p>以上属性值可取2种值：</p><ul><li>length: 具体的值,比如2px,2em等</li><li>%: 百分比</li></ul><h3 id="3-box-shadow边框阴影属性"><a href="#3-box-shadow边框阴影属性" class="headerlink" title="3.box-shadow边框阴影属性"></a>3.box-shadow边框阴影属性</h3><p>box-shadow属性向边框添加一个或多个阴影，是由逗号分隔的阴影列表，每个阴影由2-4个长度值、可选的颜色以及可选的inset关键词来规定。省略长度的值是0.</p><p>box-shadow属性值：</p><ul><li>h-shadow: 必需，水平阴影的位置，允许负值</li><li>v-shadow：必需，垂直阴影的位置，允许负值</li><li>blur： 可选，模糊距离</li><li>spread：可选，阴影的尺寸</li><li>color：可选，阴影的颜色</li><li>inset：可选，将外部阴影设置为内部阴影</li></ul><h2 id="背景属性"><a href="#背景属性" class="headerlink" title="背景属性"></a>背景属性</h2><h3 id="1-background-image多背景图片属性"><a href="#1-background-image多背景图片属性" class="headerlink" title="1.background-image多背景图片属性"></a>1.background-image多背景图片属性</h3><p>background-image:url(bg_flower.gif),url(bg_flower_2.gif);</p><h3 id="2-background-clip背景的绘制区域"><a href="#2-background-clip背景的绘制区域" class="headerlink" title="2.background-clip背景的绘制区域"></a>2.background-clip背景的绘制区域</h3><p>background-clip 属性规定背景的绘制区域</p><p>background-clip属性可选值：</p><ul><li>border-box：默认值，图片被剪裁到边框盒</li><li>padding-box: 图片被剪裁到内边距框</li><li>content-box: 图片被剪裁到内容框</li></ul><h3 id="3-background-origin规定背景图片的定位区域"><a href="#3-background-origin规定背景图片的定位区域" class="headerlink" title="3.background-origin规定背景图片的定位区域"></a>3.background-origin规定背景图片的定位区域</h3><p>background-origin属性规定background-position属性相对于什么位置来定位。<br>如果background-attachment属性设置为“fixed”，该属性无效。</p><p>background-origin属性值：</p><ul><li>padding-box: 默认值，背景图片相对于内边距框来定位</li><li>border-box: 背景图片相对于边框盒来定位</li><li>content-box: 背景图片相对于内容框来定位</li></ul><h3 id="background-size规定背景图片的尺寸"><a href="#background-size规定背景图片的尺寸" class="headerlink" title="background-size规定背景图片的尺寸"></a>background-size规定背景图片的尺寸</h3><p>background-size 属性规定背景图像的尺寸</p><p>background-size: auto;默认值</p><p>background-size取值四种方式：</p><ul><li>length：设置宽度和高度，第一个设置宽度，第二个值设置高度，如果只设置一个值，第二个值会被设置为”auto”.</li><li>%:百分比设置宽度和高度，相对于父元素的宽高设置，第一个设置宽度，第二个值设置高度，如果只设置一个值，第二个值会被设置为”auto”.</li><li>cover：把背景图片扩展至足够大，以使背景图像完全覆盖背景区域</li><li>contain：把背景图片扩展至最大尺寸，以使其宽高完全适应内容区域</li></ul><h2 id="文本效果"><a href="#文本效果" class="headerlink" title="文本效果"></a>文本效果</h2><h3 id="1-text-shadow文本阴影"><a href="#1-text-shadow文本阴影" class="headerlink" title="1.text-shadow文本阴影"></a>1.text-shadow文本阴影</h3><p>text-shadow 属性向文本设置阴影。<br>text-shadow: none;默认值</p><p>text-shadow属性包含下列值：</p><ul><li>h-shadow: 必需，水平阴影的位置，允许负值</li><li>v-shadow: 必需，垂直阴影的位置，允许负值</li><li>blur: 可选，模糊的距离</li><li>color: 可选，阴影的颜色</li></ul><h3 id="2-word-wrap属性"><a href="#2-word-wrap属性" class="headerlink" title="2.word-wrap属性"></a>2.word-wrap属性</h3><p>word-wrap属性允许长单词或 URL 地址换行到下一行。</p><p>word-wrap:normal;默认值</p><ul><li>break-word：允许长单词或url地址换到下一行</li><li>normal: 只在允许的断字点换行（浏览器保持默认处理）</li></ul><h3 id="3-word-break属性规定自动换行的处理方法"><a href="#3-word-break属性规定自动换行的处理方法" class="headerlink" title="3.word-break属性规定自动换行的处理方法"></a>3.word-break属性规定自动换行的处理方法</h3><p>word-break: noraml默认值</p><ul><li>noraml:浏览器默认换行规则</li><li>break-all: 允许在单词内换行</li><li>keep-all： 只允许在半角空格或连字符处换行</li></ul><h2 id="transform属性"><a href="#transform属性" class="headerlink" title="transform属性"></a>transform属性</h2><p>transform属性向元素应用2D或3D属性。该属性允许元素进行旋转、缩放、倾斜、移动</p><p>transform:none/transform-function,none为默认值</p><p>transform值可以是以下方法：</p><ul><li>none：不进行任何转换</li><li>matrix(n,n,n,n,n,n):定义2D转换，使用六个值的矩阵</li><li>matrix3d(n,…n):定义3D转换，使用16个值的矩阵</li><li>translate(x,y):定义2D转换</li><li>translate3d(x,y,z): 定义3D转换</li><li>translateX(x): 定义转换，只是用 X 轴的值。</li><li>translateY(y): 定义转换，只是用 Y 轴的值。</li><li>translateZ(z): 定义转换，只是用 Z 轴的值。</li><li>scale(x,y): 定义2D缩放转换</li><li>scale3d(x,y,z): 定义3D缩放转换</li><li>scaleX(x): 通过设置 X 轴的值来定义缩放转换。</li><li>scaleY(y): 通过设置 Y 轴的值来定义缩放转换。</li><li>scaleZ(z): 通过设置 Z 轴的值来定义缩放转换。</li><li>rotate(angle): 定义 2D 旋转，在参数中规定角度</li><li>rotate(x,y,angle): 定义3D旋转</li><li>rotateX(angle): 定义沿着 X 轴的 3D 旋转</li><li>rotatezY(angle): 定义沿着 Y 轴的 3D 旋转</li><li>rotateZ(angle): 定义沿着 Z 轴的 3D 旋转</li><li>skew(x-angle,y-angle): 定义沿着x轴和y轴倾斜转换</li><li>skewX(angle): 定义沿着X轴的2D倾斜转换</li><li>skewY(angle):定义沿着y轴的2D倾斜转换</li></ul><h2 id="transition过渡属性"><a href="#transition过渡属性" class="headerlink" title="transition过渡属性"></a>transition过渡属性</h2><p>transition过渡是元素从一种样式逐渐改变为另一种效果，需要规定2项内容：</p><ul><li>规定希望效果作用到元素哪个属性上</li><li>规定效果的时长</li></ul><p>transition是简写属性，包含以下转换属性：</p><ul><li>transition-property:规定应用过渡的css属性名称，取值：none/property/all</li><li>transition-duration:规定应用过渡时长，默认值0，以秒或毫秒计</li><li>transition-timing-function: 规定过渡效果的曲线，默认值是ease</li><li>transition-delay: 规定效果从何时开始，默认值是0</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attribute">transition</span>: width <span class="number">2s</span>;</span><br><span class="line">  <span class="attribute">-moz-transition</span>: width <span class="number">2s</span>;<span class="comment">/* Firefox 4 */</span></span><br><span class="line">  <span class="attribute">-webkit-transition</span>: width <span class="number">2s</span>;<span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line">  <span class="attribute">-o-transition</span>: width <span class="number">2s</span>;<span class="comment">/* Opera */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="animation动画"><a href="#animation动画" class="headerlink" title="animation动画"></a>animation动画</h2><p>@keyframes规则用于创建动画</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> myFirst&#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在@keyframes创建动画后，需要将它绑定到某个选择器，需要以下2项css3动画属性，即可将动画绑定到选择器：</p><ul><li>规定动画的名称</li><li>规定动画的时长</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">animation</span>: myFirst <span class="number">5s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可用0%和100%代替from和to。</p><ul><li>@keyframes：创建动画</li><li>animation：动画属性简写</li><li>animation-name: 规定@keyframes动画的名称</li><li>animation-duration: 规定动画的一个周期所需时长，默认是0</li><li>animation-timing-function: 规定动画的曲线，默认是ease</li><li>animation-delay: 规定动画何时开始，默认是0</li><li>animation-iteration-count: 规定动画播放次数，默认是1，值可取n/infinate(无限播放)</li><li>animation-direction: 规定动画是否在下一周期逆向播放，默认是normal,取值normal/alternate</li><li>animation-play-state: 规定动画是正在运行还是暂停，默认值是running，取值running/paused</li><li>animation-fill-mode: 定对象动画时间之外的状态</li></ul><h2 id="弹性盒子flexbox"><a href="#弹性盒子flexbox" class="headerlink" title="弹性盒子flexbox"></a>弹性盒子flexbox</h2><h2 id="多媒体查询-media"><a href="#多媒体查询-media" class="headerlink" title="多媒体查询@media"></a>多媒体查询@media</h2>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端开发常见面试问题及答案整理</title>
      <link href="/ZJY.github.io/2021/02/21/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%95%B4%E7%90%86/"/>
      <url>/ZJY.github.io/2021/02/21/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前端开发常见面试问题及答案整理"><a href="#前端开发常见面试问题及答案整理" class="headerlink" title="前端开发常见面试问题及答案整理"></a>前端开发常见面试问题及答案整理</h2><h2 id="闭包的理解"><a href="#闭包的理解" class="headerlink" title="闭包的理解"></a>闭包的理解</h2><p>闭包是为了设计私有方法和变量。<br>优点：避免全局变量的污染<br>缺点：闭包常驻内存，加大内存使用，使用不当容易造成内存泄漏</p><p>闭包的三大特性：</p><ul><li>函数嵌套函数</li><li>函数内部可以引用外部的参数和变量</li><li>参数和变量不会被垃圾回收机制回收</li></ul><h2 id="cookie的弊端"><a href="#cookie的弊端" class="headerlink" title="cookie的弊端"></a>cookie的弊端</h2><p>1.每个特定的域名下最多生成20个cookie，每个cookie长度不能超过4KB，否则会被截掉。<br>2.安全性问题。如果cookie被拦截，那就可以取到所有session信息，即使加密也于事无补，，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。</p><h2 id="浏览器本地存储"><a href="#浏览器本地存储" class="headerlink" title="浏览器本地存储"></a>浏览器本地存储</h2><p>html5中web storage包括了2种存储方式：sessionStorage和localStorage</p><ul><li>sessionStorage:用于存储本地的一个会话的数据，这些数据只能在同一个会话中的页面才能访问并且当会话结束后会随之销毁。所以sessionStorage不是一个持久化的的本地存储，仅仅是会话级别的存储。</li><li>localStorage：是持久化的本地存储，除非主动删除数据，否则永远不用过期。</li></ul><h3 id="web-storage和cookie的区别"><a href="#web-storage和cookie的区别" class="headerlink" title="web storage和cookie的区别"></a>web storage和cookie的区别</h3><p>web storage和cookie类似，区别是web storage是为了更大容量设计的。<br>cookie大小受限制；且每次打开新的页面，cookie都会被发送过去，无形中浪费带宽；且cookie不能跨域</p><p>web storage拥有setItem,getItem,removeItem,clear等方法，而cookie需要自己封装setCookie,getCookie</p><p>但cookie是不可或缺的：cookie的作用是与服务器进行交互，作为http的规范而存在，web storage仅仅是为了本地存储</p><p>localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem</p><h3 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h3><ul><li>cookie存放在客户端浏览器，session存放在服务器</li><li>cookie最大4kb，且每个站点最多20个cookie</li><li>cookie不是很安全，别人可以获取cookie进行cookie欺骗</li><li>session会在一定时间内存储在服务器，当访问量增大时，占用服务器的性能</li></ul><h2 id="css相关问题"><a href="#css相关问题" class="headerlink" title="css相关问题"></a>css相关问题</h2><h3 id="display-none-和-visibility-hidden"><a href="#display-none-和-visibility-hidden" class="headerlink" title="display:none 和 visibility:hidden"></a>display:none 和 visibility:hidden</h3><ul><li>display:none隐藏对应的元素,文档布局中不再分配空间，周边元素会当他不存在</li><li>visibility:hidden 隐藏元素，保留布局，占用空间。</li></ul><h3 id="css中link和-import的区别"><a href="#css中link和-import的区别" class="headerlink" title="css中link和@import的区别"></a>css中link和@import的区别</h3><ul><li>link是html标签，@import是css提供的</li><li>link是html标签无兼容问题，@import需ie5以上才兼容</li><li>页面加载时，link会被一起加载，而@import需要页面加载完后再加载</li><li>link引入样式权重高于@import权重</li></ul><h3 id="position-absolute和float的异同"><a href="#position-absolute和float的异同" class="headerlink" title="position:absolute和float的异同"></a>position:absolute和float的异同</h3><ul><li>相同点：对内联元素设置position:absolute和float都会使其脱离文档流，并可设置宽和高</li><li>不同点：设置position:absolute的元素会覆盖文档流中的其他元素，而float仍然占据位置。</li></ul><h3 id="box-sizing属性"><a href="#box-sizing属性" class="headerlink" title="box-sizing属性"></a>box-sizing属性</h3><p>box-sizing属性用来控制元素的盒模型解析模式，默认是content-box</p><ul><li>content-box: w3c标准盒模型，元素的宽高由padding+border+content决定，设置元素的width/height属性是指content的宽/高</li><li>border-box: IE怪异盒模型，设置元素的width/height属性是指content+padding+border</li></ul><p>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。</p><h3 id="CSS-选择符有哪些？"><a href="#CSS-选择符有哪些？" class="headerlink" title="CSS 选择符有哪些？"></a>CSS 选择符有哪些？</h3><ul><li>id选择器(#con)</li><li>class选择器(.con)</li><li>标签选择器(div/p)</li><li>相邻选择器(div + p)</li><li>子选择器(div &gt; p)</li><li>后代选择器(div p)</li><li>通配符选择器(*)</li><li>属性选择器（a[rel = “external”]）</li><li>伪类选择器(a:hover)</li></ul><h3 id="css哪些属性可以继承？"><a href="#css哪些属性可以继承？" class="headerlink" title="css哪些属性可以继承？"></a>css哪些属性可以继承？</h3><ul><li>可以继承属性：font-size, font-family,color,text-indent</li><li>不可以继承属性：width,height,border,padding,margin</li></ul><p>所有元素可继承：visibility/cursor<br>块元素可继承:text-align/text-indent<br>列表元素可继承：list-style,list-style-image,list-style-type<br>行内元素可继承：font,font-size,font-family,color,line-height,letter-spacing,word-spacing</p><h3 id="css优先级算法？"><a href="#css优先级算法？" class="headerlink" title="css优先级算法？"></a>css优先级算法？</h3><ul><li>优先级就近原则，同权重情况下样式定义最近者为准</li><li>载入样式以最后载入为准</li><li>!important &gt; 内联 &gt; id &gt; class &gt; tag，important 比 内联优先级高,但内联比 id 要高</li></ul><h3 id="css3新增伪类有哪些？"><a href="#css3新增伪类有哪些？" class="headerlink" title="css3新增伪类有哪些？"></a>css3新增伪类有哪些？</h3><ul><li>p:first-of-type 选择属于其父元素的首个 <code>&lt;p&gt;</code>元素的每个<code>&lt;p&gt;</code> 元素。</li><li>p:last-of-type 选择属于其父元素的最后 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。</li><li>p:only-of-type 选择属于其父元素唯一的 <code>&lt;p&gt;</code> 元素的每个 <code>&lt;p&gt;</code> 元素。</li><li>p:nth-child(2) 选择属于其父元素的第二个子元素的每个 <code>&lt;p&gt;</code> 元素。</li><li>p:only-child 选择属于其父元素的唯一子元素的每个 <code>&lt;p&gt;</code> 元素。</li><li>:enabled :disabled 控制表单控件的禁用状态。</li><li>:checked 单选框或复选框被选中。</li></ul><h3 id="position的值，分别相对于谁定位？"><a href="#position的值，分别相对于谁定位？" class="headerlink" title="position的值，分别相对于谁定位？"></a>position的值，分别相对于谁定位？</h3><ul><li>static： 默认值，没有定位，元素出现在正常文档流中。</li><li>relative：相对定位，相对于其在正常文档流中位置定位。</li><li>absolute： 绝对定位，相对于最近一级的定位不是staic的元素定位。</li><li>fixed： 绝对定位，相对于浏览器视窗定位。</li></ul><h3 id="css3有哪些新特性？"><a href="#css3有哪些新特性？" class="headerlink" title="css3有哪些新特性？"></a>css3有哪些新特性？</h3><ul><li>border-radius:圆角</li><li>border-image: 边框图片</li><li>box-shadow: 边框阴影</li><li>background-image: 多背景</li><li>background-clip: 背景图片绘制区域</li><li>background-origin: 背景图片的定位区域</li><li>text-shadow: 文本阴影</li><li>word-wrap:允许长单词或url换行到下一行</li><li>word-break: 设置自动换行的处理方法</li><li>transform: 旋转、缩放、移动、倾斜，2D或3D转换</li><li>animation: 使用@keyframes创建动画</li><li>transition: 设置元素过渡效果</li><li>column-count/gap/rule: 多列设置</li><li>::selection: 新增伪元素，设置选中高亮</li></ul><h3 id="XML和JSON的区别？"><a href="#XML和JSON的区别？" class="headerlink" title="XML和JSON的区别？"></a>XML和JSON的区别？</h3><ul><li>数据体积方面：JSON相对XML来说，数据体积小，传输速度更快</li><li>数据交互方面：JSON于js的交互更方便，更容易解析处理</li><li>数据描述方面：XML对数据的描述比JSON好</li><li>传输速度方面：JSON的传输速度要快于XML</li></ul><h3 id="对BFC的理解？"><a href="#对BFC的理解？" class="headerlink" title="对BFC的理解？"></a>对BFC的理解？</h3><p>BFC块级格式化上下文，是一个独立的渲染区域，内部元素不会影响外部元素定位，使内外元素相隔离</p><p>BFC布局规则：</p><ul><li>BFC是一个独立的区域，内外元素不互相影响</li><li>内部的box会在垂直方向，一个一个排列</li><li>box垂直方向的距离由margin决定，相邻的2个box间的margin会发生重叠</li><li>每个元素的margin box的左边与border box的左边相接触，即使浮动也如此</li><li>BFC区域不和浮动盒子相重叠</li><li>计算BFC高度时，float box也参与计算</li></ul><p>什么情况会形成BFC？</p><ul><li>根元素</li><li>position为absolute或fixed</li><li>浮动元素</li><li>display值为flex、inline-flex、、table-cell</li><li>overflow不为visible的元素</li></ul><h3 id="css-sprites-如何在网站使用？"><a href="#css-sprites-如何在网站使用？" class="headerlink" title="css sprites,如何在网站使用？"></a>css sprites,如何在网站使用？</h3><p>css sprites就是把网页中一些背景图片整合到一张图片中，利用”background-image”,”background-repeat”,”background-position”属性组合进行背景定位。”background-position”可以精准定位背景图片的位置。有效减少图片请求开销。</p><h2 id="html部分"><a href="#html部分" class="headerlink" title="html部分"></a>html部分</h2><h3 id="对语义化的理解？"><a href="#对语义化的理解？" class="headerlink" title="对语义化的理解？"></a>对语义化的理解？</h3><ul><li>样式丢失也能呈现出清晰的结构</li><li>有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓去更多信息</li><li>方便其他设备解析（屏幕阅读器、盲人阅读器）</li><li>便于团队开发和维护，语义化更具有可读性</li></ul><h3 id="Doctype的作用？严格模式和混杂模式区别？有何意义？"><a href="#Doctype的作用？严格模式和混杂模式区别？有何意义？" class="headerlink" title="Doctype的作用？严格模式和混杂模式区别？有何意义？"></a>Doctype的作用？严格模式和混杂模式区别？有何意义？</h3><ul><li><!DOCTYPE>声明位于文档最前面，告知浏览器以何种模式渲染文档</li><li>严格模式的排版和js运作模式是以浏览器支持的最高标准运行。</li><li>在混杂模式中以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。</li><li>DOCTYPE不存在或不正确会使浏览器以混杂模式呈现。</li></ul><h3 id="浮动工作原理？清除浮动的技巧？"><a href="#浮动工作原理？清除浮动的技巧？" class="headerlink" title="浮动工作原理？清除浮动的技巧？"></a>浮动工作原理？清除浮动的技巧？</h3><p>浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或浮动元素的边框停留。</p><p>清除浮动方式：</p><ul><li>使用空标签清除浮动：浮动标签后面添加一个空标签，定义css clear:both.弊端就是增加了无意义的标签</li><li>使用overflow：给包含浮动元素的父元素添加overflow:auto;zoom:1;zoom:1;兼容ie6</li><li>使用after伪对象清除浮动：只适用于非IE浏览器，该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素</li></ul><h3 id="浮动元素引起的问题和解决方案？"><a href="#浮动元素引起的问题和解决方案？" class="headerlink" title="浮动元素引起的问题和解决方案？"></a>浮动元素引起的问题和解决方案？</h3><ul><li>1.父元素的高度无法被撑开，影响与父元素同级的元素</li><li>2.与浮动元素同级的非浮动元素（内联元素）会跟随其后</li><li>3.若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面结构</li></ul><p>解决方法：<br>对于第二个第三个问题可用clear:both清除元素的浮动，对于第一个问题，给父元素添加clearfix样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">clear</span>:both;</span><br><span class="line">  <span class="attribute">visibility</span>:hidden;</span><br><span class="line">  <span class="attribute">display</span>:block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:; <span class="comment">/* for IE/Mac */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清除浮动的几种方式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1，额外标签法，&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;（缺点：不过这个办法会增加额外的标签使HTML结构看起来不够简洁。）</span><br><span class="line">2，使用<span class="selector-tag">after</span>伪类</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#parent</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">&quot;.&quot;</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">visibility</span>:hidden;</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">clear</span>:both;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">3,浮动外部元素</span><br><span class="line">4,设置`<span class="selector-tag">overflow</span>`为`<span class="selector-tag">hidden</span>`或者<span class="selector-tag">auto</span></span><br></pre></td></tr></table></figure><h3 id="DOM操作——怎样添加、移除、移动、复制、创建和查找节点"><a href="#DOM操作——怎样添加、移除、移动、复制、创建和查找节点" class="headerlink" title="DOM操作——怎样添加、移除、移动、复制、创建和查找节点"></a>DOM操作——怎样添加、移除、移动、复制、创建和查找节点</h3><ul><li><p>创建</p><ul><li>createDocumentFragment() 创建一个Dom片段</li><li>createElement() 创建一个元素</li><li>createTextNode() 创建文本节点</li></ul></li><li><p>添加、移除、移动、复制</p><ul><li>appendChild()</li><li>removeChild()</li><li>replaceChild()</li><li>insertBefore()</li></ul></li><li><p>查找</p><ul><li>getElementsByTagName()</li><li>getElementById()</li><li>getElementsByClassName()</li></ul></li></ul><h3 id="html5有哪些新特性？"><a href="#html5有哪些新特性？" class="headerlink" title="html5有哪些新特性？"></a>html5有哪些新特性？</h3><ul><li>拖拽API</li><li>语义化更好的标签（header,section,article,footer,nav,aside）</li><li>音视频（audio/video）</li><li>canvas画布/svg</li><li>地理位置Geolocation</li><li>本地缓存：localStorage持久化缓存，sessionStorage会话级缓存</li><li>新的表单控件：calendar,date,time,url,search,email</li></ul><h3 id="常见浏览器兼容问题"><a href="#常见浏览器兼容问题" class="headerlink" title="常见浏览器兼容问题"></a>常见浏览器兼容问题</h3><ul><li>浏览器默认margin,padding值不同，需要添加全局*{margin:0;padding:0}</li><li>chrome浏览器设置字体小于12px，会默认为12px，解决方法：-webkit-text-size-adjust:none;</li><li>a标签超链接访问过后hover样式就不出现了，被访问过的链接不再具有hover和active，解决方法改变css属性的顺序：<br>L-V-H-A: a:link{} a:visited: a:hover a:active</li><li>怪异模式问题：漏写DTD声明时，火狐仍然按照标准模式来解析网页，但在IE中会触发怪异模式。</li></ul><h3 id="如何实现浏览器多个标签页之间通信？"><a href="#如何实现浏览器多个标签页之间通信？" class="headerlink" title="如何实现浏览器多个标签页之间通信？"></a>如何实现浏览器多个标签页之间通信？</h3><p>使用localStorage,cookies等本地存储方式</p><h3 id="进程和线程之间关系和区别？"><a href="#进程和线程之间关系和区别？" class="headerlink" title="进程和线程之间关系和区别？"></a>进程和线程之间关系和区别？</h3><ul><li><p>1.定义</p><ul><li>进程：是系统进行资源分配和调度的独立单位。</li><li>线程：线程是进程的一个实体，是cpu调度和分派的基本单位，是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，但是和进程内的其他线程共享进程拥有的全部资源。</li></ul></li><li><p>2.关系</p><ul><li>一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。</li><li>相对进程而言，线程更接近于执行体的概念，它可以与进程内的其他线程共享资源，但拥有自己的栈空间，拥有独立的执行序列</li></ul></li><li><p>3.区别<br>进程和线程的主要差别是他们是不同的操作系统资源的管理方式。进程拥有独立的地址空间，一个进程崩溃后，基于系统的保护程序，并不会影响其他进程，而线程只是进程中的不同执行路径。<br>线程拥有自己的堆栈和局部变量，但线程间没有单独的地址空间，一个线程死掉就相当于整个进程死掉，所以多进程的程序比多线程的程序更健壮，但在进程切换时，耗费资源较大，效率低一些。</p><ul><li>一个程序至少有一个进程，一个进程中至少有一个线程</li><li>线程的划分尺度低于进程，使得多线程的程序并发性高</li><li>进程在执行过程拥有独立的内存单元，而多个线程共享内存，从而极大的提高程序的运行效率</li><li>线程在执行过程中和进程还是有区别的。每个线程都有程序运行入口，顺序执行序列和程序的出口，但线程不能独立执行，必须依存于应用程序，由应用程序提供多个线程执行控制</li><li>从逻辑角度来看，多线程的意义在于应用程序中，有多个执行部分可以同时执行，但是操作系统并没有将多个线程看出多个独立的应用，来实现线程的调度和管理以及资源分配。这就是进程和线程的重要区别</li></ul></li><li><p>4.优缺点</p><ul><li>线程执行开销小，但不利于资源的管理和保护；而进程相反</li><li>线程适合于在SMP机器上运行，而进程则可以跨机器迁移。</li></ul></li></ul><h3 id="什么是FOUC？怎么解决？"><a href="#什么是FOUC？怎么解决？" class="headerlink" title="什么是FOUC？怎么解决？"></a>什么是FOUC？怎么解决？</h3><p>Flash Of Unstyled Content 文档式闪烁</p><ul><li>什么是FOUC(文档样式短暂失效)?<ul><li>如果使用import方法对CSS进行导入,会导致某些页面在Windows 下的Internet Explorer出现一些奇怪的现象:以无样式显示页面内容的瞬间闪烁,这种现象称之为文档样式短暂失效(Flash of Unstyled Content),简称为FOUC。</li></ul></li><li>造成原因：<ul><li>使用import引入css</li><li>将样式表放在页面底部</li><li>多个样式表放在html结构的不同位置<br>当样式表晚于页面html加载，当加载到此样式表时，页面将停止之前的渲染，等待文件的下载解析后将重新渲染页面，也就出现短暂页面闪烁</li></ul></li><li>解决方法：<ul><li>使用link标签将样式表放置与head中</li></ul></li></ul><h3 id="null和undefined的区别？"><a href="#null和undefined的区别？" class="headerlink" title="null和undefined的区别？"></a>null和undefined的区别？</h3><p>null是表示“无”的对象，转为数值为0，undefined是表示“无”的原始值，转为数值为NaN。</p><p>当声明的变量未初始化时，值为undefined。<br>null用来表示尚未存在的对象，常用来表示函数企图返回不存在的对象。</p><p>undefined:<br>1.变量被声明了，但没有赋值，该变量值为undefined<br>2.调用函数时，应该提供的参数没有提供，该参数值为undefined<br>3.未给对象的属性赋值时，该属性的值为undefined<br>4.函数没有返回值时，默认返回undefined</p><p>null：<br>1.作为函数的参数，表明该函数的参数不是对象<br>2.作为对象原型链的终点</p><h3 id="new-操作符具体做了什么？"><a href="#new-操作符具体做了什么？" class="headerlink" title="new 操作符具体做了什么？"></a>new 操作符具体做了什么？</h3><ul><li>1.创建新的空对象，并且this变量引用该对象，同时还继承了该函数的原型</li><li>2.属性和方法被加入到this引用的对象上</li><li>3.新创建的对象由this所引用，并隐式返回this</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.__proto__ = Base.prototype;</span><br><span class="line">Base.call(obj);</span><br></pre></td></tr></table></figure><h3 id="js延迟加载的几种方式？"><a href="#js延迟加载的几种方式？" class="headerlink" title="js延迟加载的几种方式？"></a>js延迟加载的几种方式？</h3><p>js延迟加载就是等页面加载完成后再加载js文件<br>js延迟加载有助于提高页面加载速度。<br>一般有以下几种方式：</p><ul><li><p>1.defer属性<br>html4为script标签添加了defer属性，表明脚本在执行时不会影响页面构造，也就是说脚本会延迟到整个页面都加载解析完毕再执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;script src=<span class="string">&quot;test.js&quot;</span> defer=<span class="string">&quot;defer&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><p>defer属性告诉浏览器立即下载，但延迟执行。虽然<code>&lt;script&gt;</code> 元素放在了<code>&lt;head&gt;</code>元素中，但包含的脚本会延迟到浏览器遇到<code>&lt;/html&gt;</code>标签后再执行。</p></li></ul><p>HTML5规范要求脚本按照它们出现的先后顺序执行</p><p>defer属性只适用于外部脚本文件</p><ul><li><p>2.async属性<br>html5为script标签定义了async属性，与defer属性类似。只适用于外部脚本。<br>目的：不让页面等待脚本下载和执行，从而异步加载页面其他内容<br>异步脚本一定会在onload事件前执行<br>不能保证脚本按照顺序执行</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;test1.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>async和defer一样，不会阻塞其他资源下载，不会影响页面加载<br>缺点：不能控制脚本加载顺序</p></li><li><p>3.动态创建DOM方式</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这些代码应被放置在&lt;/body&gt;标签前(接近HTML文件底部)</span></span><br><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">downloadJSAtOnload</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">      varelement = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);  </span><br><span class="line">      element.src = <span class="string">&quot;defer.js&quot;</span>;  </span><br><span class="line">      <span class="built_in">document</span>.body.appendChild(element);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener)  </span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">&quot;load&quot;</span>,downloadJSAtOnload, <span class="literal">false</span>);  </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.attachEvent)  </span><br><span class="line">      <span class="built_in">window</span>.attachEvent(<span class="string">&quot;onload&quot;</span>,downloadJSAtOnload);  </span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">      <span class="built_in">window</span>.onload =downloadJSAtOnload;  </span><br><span class="line">&lt;/script&gt;  </span><br></pre></td></tr></table></figure><p>创建script，插入到DOM中，加载完毕后callBack</p><ul><li>4.使用setTimeout延迟</li><li>5.按需异步加载</li></ul><h3 id="document-write和innerHTML的区别"><a href="#document-write和innerHTML的区别" class="headerlink" title="document.write和innerHTML的区别"></a>document.write和innerHTML的区别</h3><p>document.write重绘整个页面<br>innerHTML重绘页面一部分</p><h3 id="哪些操作会造成内存泄漏？"><a href="#哪些操作会造成内存泄漏？" class="headerlink" title="哪些操作会造成内存泄漏？"></a>哪些操作会造成内存泄漏？</h3><p>内存泄漏是指任何对象在您不再拥有或需要时仍然存在<br>垃圾回收器会定时扫描对象，并计算应用了每个对象的其他对象的数量，当引用该对象数量为0，或对该对象的惟一引用是循环的，那么该对象的内存就会被回收。</p><p>setTimeout函数的第一个参数如果是字符串，闭包、控制台日志，循环（两个对象彼此存在且彼此引用时，会行程一个循环）会引发内存泄漏。</p><h3 id="如何判断当前脚本运行在浏览器还是node环境中？"><a href="#如何判断当前脚本运行在浏览器还是node环境中？" class="headerlink" title="如何判断当前脚本运行在浏览器还是node环境中？"></a>如何判断当前脚本运行在浏览器还是node环境中？</h3><p>通过判断Global对象是否等于window，如果不是则在node中</p><p>this == window</p><h3 id="ajax过程"><a href="#ajax过程" class="headerlink" title="ajax过程"></a>ajax过程</h3><ul><li>1.创建一个XMLHttpRequest对象，也就是异步调用对象</li><li>2.创建一个新的http请求，设置请求的方式、URL以及验证信息</li><li>3.设置响应http请求状态变化的函数</li><li>4.发送http请求</li><li>5.获取异步调用返回的结果</li><li>6.使用js和dom实现局部刷新</li></ul><h3 id="ie各版本和chrome可以并行下载多少个资源"><a href="#ie各版本和chrome可以并行下载多少个资源" class="headerlink" title="ie各版本和chrome可以并行下载多少个资源"></a>ie各版本和chrome可以并行下载多少个资源</h3><p>IE6 两个并发，iE7升级之后的6个并发，之后版本也是6个</p><p>Firefox，chrome也是6个</p><h3 id="javascript的同源策略"><a href="#javascript的同源策略" class="headerlink" title="javascript的同源策略"></a>javascript的同源策略</h3><p>同源：协议、域名、端口相同，同源策略是一种协议，指脚本只能读取来自同一源的窗口和文档属性。</p><h3 id="哪些地方会出现css阻塞，哪些地方会出现js阻塞？"><a href="#哪些地方会出现css阻塞，哪些地方会出现js阻塞？" class="headerlink" title="哪些地方会出现css阻塞，哪些地方会出现js阻塞？"></a>哪些地方会出现css阻塞，哪些地方会出现js阻塞？</h3><p>所有浏览器在下载js的时候，都会阻塞其他资源的下载，页面的呈现等。直到js下载、解析、执行完毕后才能继续并行下载其他资源并呈现内容。新一代浏览器都支持并行下载js，但仍然会阻塞其他资源（css，图片）的下载。<br>由于浏览器为了防止出现js修改dom树，造成重新构造dom树的情况，需要阻塞其他资源的下载和呈现<br>嵌入js会阻塞所有内容的呈现，外部js只会阻塞其后内容的显示，2种方式都会阻塞资源的下载。</p><p>css本来是可以并行下载的，在什么情况下会阻塞加载？<br>css后面跟着嵌入js的时候，会阻塞后面资源的下载，而把嵌入js放置在css前面就不会阻塞资源加载了。</p><p>原因：<br>因为浏览器会维持html中css和js的顺序，样式表必须在嵌入js前先加载、解析完。而嵌入js又会阻塞后面的资源加载，所以就会出现css阻塞下载的情况</p><p>嵌入js应该放在什么位置？<br>1.放置在底部，虽然放在底部会阻塞所有呈现，但不会阻塞资源下载<br>2.放在head，放在css前面<br>3.使用defer<br>4.嵌入js中不要调用运行时间较长的函数，如果要调用，可以使用setTimeout来调用</p><h3 id="js无阻塞加载方式？"><a href="#js无阻塞加载方式？" class="headerlink" title="js无阻塞加载方式？"></a>js无阻塞加载方式？</h3><ul><li>将脚本放在底部：script标签放在<code>&lt;/body&gt;</code>前</li><li>非阻塞脚本：等页面加载完后，再加载js。也就是在onload事件下载js<ul><li>1.defer属性/async属性</li><li>2.动态创建dom方式（创建script，插入文档，onload事件回调触发）</li></ul></li></ul><h3 id="eval是做什么的？"><a href="#eval是做什么的？" class="headerlink" title="eval是做什么的？"></a>eval是做什么的？</h3><p>功能是将对应的字符串解析成js代码并执行。</p><p>应该避免使用eval，不安全，耗性能（2次，一次解析成js代码，一次执行）</p><h3 id="事件冒泡和事件捕获？"><a href="#事件冒泡和事件捕获？" class="headerlink" title="事件冒泡和事件捕获？"></a>事件冒泡和事件捕获？</h3><p>事件流描述的是从页面接收事件的顺序。<br>IE是冒泡事件流<br>Firefox是捕获事件流</p><ul><li>事件冒泡：即事件从具体的元素到不具体的元素，从内向外传递事件</li><li>事件捕获：即事件从不具体的元素到具体的元素</li></ul><p>事件冒泡和事件捕获是两个相反的过程</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>event<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;obj1&quot;</span>&gt;</span></span><br><span class="line">        welcome</span><br><span class="line">        <span class="tag">&lt;<span class="name">h5</span> <span class="attr">id</span>=<span class="string">&quot;obj2&quot;</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h5</span> <span class="attr">id</span>=<span class="string">&quot;obj3&quot;</span>&gt;</span>world<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> obj1=<span class="built_in">document</span>.getElementById(<span class="string">&#x27;obj1&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> obj2=<span class="built_in">document</span>.getElementById(<span class="string">&#x27;obj2&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        obj1.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&#x27;hello&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;,<span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript">        obj2.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&#x27;world&#x27;</span>);</span></span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>文档结构：document &gt; html &gt; body &gt; div &gt; h5<br>addEventListener的第三个参数为false,所以页面是在冒泡阶段处理绑定事件</p><p>1.点击文字welcome，触发obj1的点击事件，弹出hello<br>2.点击文字hello，触发obj2的点击事件，弹出world &gt; hello<br>3.点击world时，触发obj1的点击事件，弹出hello</p><ul><li>事件代理机制：</li></ul><p>我们想要在点击每个h5标签时，弹出对应的innerHTML 。常规做法是遍历每个h5,然后在每个h5上绑定一个点击事件，这种做法在h5较少的时候可以使用，但如果有一万个h5，那就会导致性能降低。这时就需要事件代理出场了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj1.addEventListener(&#x27;click&#x27;,function(e)&#123;</span><br><span class="line">    var e=e||window.event;</span><br><span class="line">    if(e.target.nodeName.toLowerCase()==&#x27;h5&#x27;)&#123;</span><br><span class="line">        alert(e.target.innerHTML);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;,false);</span><br></pre></td></tr></table></figure><p>由于事件冒泡机制，点击了h5后会冒泡到div,此时就会触发绑定在div上的点击事件，再利用target找到事件实际发生的元素，就可以达到预期的效果</p><p>采用事件代理，为页面所有a标签绑定click事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEvenetListenser(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(e.target.nodeName == <span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>问题：若a标签里面仍有span、img等其他元素，上述代码中，单击span、img等其他元素不能触发click事件。</p><p>原因：单击span、img等其他元素时，e.target指向的是触发click事件的元素（span、img等其他元素），而不是a标签</p><p>解决方法：从触发click事件的元素开始，逐级向上查找，直到找到a标签为止。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> node = e.target;</span><br><span class="line">  <span class="keyword">while</span>(node.parentNode.nodeName != <span class="string">&#x27;BODY&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node.nodeName == <span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node = node.parentNode</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>阻止事件冒泡：e.stopPropagation(),ie旧方法e.cancelBubble = true</p><h3 id="如何获取UA"><a href="#如何获取UA" class="headerlink" title="如何获取UA"></a>如何获取UA</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt; </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">whatBrowser</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        <span class="built_in">document</span>.Browser.Name.value=navigator.appName;  </span><br><span class="line">        <span class="built_in">document</span>.Browser.Version.value=navigator.appVersion;  </span><br><span class="line">        <span class="built_in">document</span>.Browser.Code.value=navigator.appCodeName;  </span><br><span class="line">        <span class="built_in">document</span>.Browser.Agent.value=navigator.userAgent;  </span><br><span class="line">    &#125;  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="js操作和设置cookie"><a href="#js操作和设置cookie" class="headerlink" title="js操作和设置cookie"></a>js操作和设置cookie</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建cookie</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, expires, path, domain, secure</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cookieText = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">&#x27;=&#x27;</span> + <span class="built_in">encodeURIComponent</span>(value);</span><br><span class="line">    <span class="keyword">if</span> (expires <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">        cookieText += <span class="string">&#x27;; expires=&#x27;</span> + expires;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (path) &#123;</span><br><span class="line">        cookieText += <span class="string">&#x27;; expires=&#x27;</span> + expires;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (domain) &#123;</span><br><span class="line">        cookieText += <span class="string">&#x27;; domain=&#x27;</span> + domain;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (secure) &#123;</span><br><span class="line">        cookieText += <span class="string">&#x27;; secure&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.cookie = cookieText;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取cookie</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cookieName = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> cookieStart = <span class="built_in">document</span>.cookie.indexOf(cookieName);</span><br><span class="line">    <span class="keyword">var</span> cookieValue = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (cookieStart &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> cookieEnd = <span class="built_in">document</span>.cookie.indexOf(<span class="string">&#x27;;&#x27;</span>, cookieStart);</span><br><span class="line">        <span class="keyword">if</span> (cookieEnd == -<span class="number">1</span>) &#123;</span><br><span class="line">            cookieEnd = <span class="built_in">document</span>.cookie.length;</span><br><span class="line">        &#125;</span><br><span class="line">        cookieValue = <span class="built_in">decodeURIComponent</span>(<span class="built_in">document</span>.cookie.substring(cookieStart + cookieName.length, cookieEnd));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cookieValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除cookie</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unsetCookie</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.cookie = name + <span class="string">&quot;= ; expires=&quot;</span> + <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tcp三次握手"><a href="#tcp三次握手" class="headerlink" title="tcp三次握手"></a>tcp三次握手</h3><p>为了准确无误将数据送达目标处，TCP协议采取了三次握手协议。<br>用tcp协议将数据包送出去后，tcp不会对发送后的情况置之不理，它一定向对方确认是否收到。</p><ul><li>1.发送端首先发送带SYN标志的数据给对方。</li><li>2.接收方收到后回传一个SYN/ACK标志的数据包以示传达确认信息。</li><li>3.最后，发送端再回传一个带ACK标志的字段，代表握手结束</li></ul><p>若在握手过程中某个阶段被打断，TCP会再次以相同的顺序发送数据包。</p><h3 id="对promise的理解"><a href="#对promise的理解" class="headerlink" title="对promise的理解"></a>对promise的理解</h3><p>promise有四种状态：</p><ul><li>1.pending:初始状态，非fullfilled或rejected</li><li>2.fullfilled: 成功的状态</li><li>3.rejected: 失败的状态</li><li>4:settled：promise已被fullfilled或rejected，且不是pending</li></ul><p>另外，fullfilled和rejected合称settled</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (...) &#123;  <span class="comment">// succeed</span></span><br><span class="line">        resolve(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;   <span class="comment">// fails</span></span><br><span class="line">        reject(<span class="built_in">Error</span>(errMessage));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Promise 实例拥有 then 方法（具有 then 方法的对象，通常被称为 thenable）。它的使用方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure><p>接收两个函数作为参数，一个在 fulfilled 的时候被调用，一个在 rejected 的时候被调用，接收参数就是 future，onFulfilled 对应 resolve, onRejected 对应 reject</p><h3 id="谈谈性能优化问题"><a href="#谈谈性能优化问题" class="headerlink" title="谈谈性能优化问题"></a>谈谈性能优化问题</h3><p>代码层面：避免使用css表达式，避免使用高级选择器，通配选择器。<br>缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等<br>请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载。<br>请求带宽：压缩文件，开启GZIP</p><h3 id="什么是Etag？"><a href="#什么是Etag？" class="headerlink" title="什么是Etag？"></a>什么是Etag？</h3><p>浏览器下载组件的时候，会将它们存储到浏览器缓存中。如果需要再次获取相同的组件，浏览器将检查组件的缓存时间，假如已经过期，那么浏览器将发送一个条件GET请求到服务器，服务器判断缓存还有效，则发送一个304响应<br>告诉浏览器可以重用缓存组件</p><p>那么服务器是根据什么判断缓存是否还有效呢?答案有两种方式，一种是前面提到的ETag，另一种是根据Last-Modified</p><h3 id="栈和队列的区别"><a href="#栈和队列的区别" class="headerlink" title="栈和队列的区别?"></a>栈和队列的区别?</h3><p>栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。<br>队列先进先出，栈先进后出。</p><p>栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除</p><h3 id="栈和堆的区别？"><a href="#栈和堆的区别？" class="headerlink" title="栈和堆的区别？"></a>栈和堆的区别？</h3><p>栈区（stack）—   由编译器自动分配释放   ，存放函数的参数值，局部变量的值等。<br>堆区（heap）   —   一般由程序员分配释放，   若程序员不释放，程序结束时可能由OS回收。<br>堆（数据结构）：堆可以被看成是一棵树，如：堆排序；<br>栈（数据结构）：一种先进后出的数据结构。</p><h3 id="关于Http-2-0-你知道多少？"><a href="#关于Http-2-0-你知道多少？" class="headerlink" title="关于Http 2.0 你知道多少？"></a>关于Http 2.0 你知道多少？</h3><p>HTTP/2引入了“服务端推（serverpush）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。<br>HTTP/2提供更多的加密支持<br>HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。<br>它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typescript</title>
      <link href="/ZJY.github.io/2021/02/21/typescript/"/>
      <url>/ZJY.github.io/2021/02/21/typescript/</url>
      
        <content type="html"><![CDATA[<h2 id="TS（typescript）是什么？"><a href="#TS（typescript）是什么？" class="headerlink" title="TS（typescript）是什么？"></a>TS（typescript）是什么？</h2><p>TS是以JavaScript为基础构建的语言，是JavaScript的一个超集<br>TS扩展了JavaScript，并添加了类型。可以在任何支持JavaScript的平台执行。<br>TS不能被js解释器直接执行，需要将ts编译成js</p><h2 id="TS增加了什么？"><a href="#TS增加了什么？" class="headerlink" title="TS增加了什么？"></a>TS增加了什么？</h2><p>类型<br>支持ES的新特性<br>添加ES不具有的新特性<br>丰富的配置选项（编译为ES3，ES6等）<br>强大的开发工具</p><h2 id="TS安装"><a href="#TS安装" class="headerlink" title="TS安装"></a>TS安装</h2><p>1.安装node<br>2.安装npm<br>3.npm install -g typescript<br>4.tsc -v  查看tsc安装版本</p><h2 id="TS编译"><a href="#TS编译" class="headerlink" title="TS编译"></a>TS编译</h2><p>tsc ts.ts<br>编译成功生成同名js文件</p><h2 id="类型声明："><a href="#类型声明：" class="headerlink" title="类型声明："></a>类型声明：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a:number = <span class="number">10</span>;或者<span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a:number, b:number</span>):<span class="title">number</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>联合类型（Union Types）可以通过管道(|)将变量设置多种类型，赋值时可以根据设置的类型来赋值。</p><p>注意：只能赋值指定的类型，如果赋值其它类型就会报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> d: <span class="string">&#x27;male&#x27;</span> | <span class="string">&#x27;female&#x27;</span>;</span><br><span class="line">d = <span class="string">&#x27;male&#x27;</span>;</span><br><span class="line">d = <span class="string">&#x27;female&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> e: boolean | string;</span><br><span class="line">e = <span class="literal">false</span>;</span><br><span class="line">e = <span class="string">&#x27;123&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="TypeScript基础类型"><a href="#TypeScript基础类型" class="headerlink" title="TypeScript基础类型"></a>TypeScript基础类型</h2><table><thead><tr><th>数据类型</th><th>关键字</th><th>描述</th></tr></thead><tbody><tr><td>任意类型</td><td>any</td><td>声明为 any 的变量可以赋予任意类型的值</td></tr><tr><td>数字类型</td><td>number</td><td>双精度 64 位浮点值。它可以用来表示整数和分数。<br>let binaryLiteral: number = 0b1010; // 二进制 <br>let octalLiteral: number = 0o744;    // 八进制 <br>let decLiteral: number = 6;    // 十进制 <br>let hexLiteral: number = 0xf00d;    // 十六进制</td></tr><tr><td>字符串类型</td><td>string</td><td>一个字符系列，使用单引号（’）或双引号（”）来表示字符串类型。反引号（``）来定义多行文本和内嵌表达式。<br>let name: string = “Runoob”;<br>let years: number = 5;<br>let words: string = <code>您好，今年是 $&#123; name &#125; 发布 $&#123; years + 1&#125; 周年</code>;</td></tr><tr><td>布尔类型</td><td>boolean</td><td>表示逻辑值：true 和 false。<br>let flag: boolean = true;</td></tr><tr><td>数组类型</td><td>无</td><td>声明变量为数组。<br>// 在元素类型后面加上[]<br>let arr: number[] = [1, 2];<br>// 或者使用数组泛型<br>let arr: Array<number> = [1, 2];</td></tr><tr><td>元组</td><td>无</td><td>元组类型用来表示已知元素数量和类型的数组，各元素的类型不必相同，对应位置的类型需要相同。<br>let x: [string, number];<br>x = [‘Runoob’, 1];    // 运行正常<br>x = [1, ‘Runoob’];    // 报错<br>console.log(x[0]);    // 输出 Runoob</td></tr><tr><td>枚举</td><td>enum</td><td>用于定义数值集合 <br>enum Color {Red, Green, Blue};<br>let c: Color = Color.Blue;<br>console.log(c);    // 输出 2</td></tr><tr><td>void</td><td>void</td><td>用于标识方法返回值的类型，表示该方法没有返回值<br>function hello(): void {<br>alert(“Hello Runoob”);<br>或者return; /return null; /return undefined}</td></tr><tr><td>null</td><td>null</td><td>表示对象值缺失</td></tr><tr><td>undefined</td><td>undefined</td><td>用于初始化变量为一个未定义的值</td></tr><tr><td>never</td><td>never</td><td>never 是其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值</td></tr></tbody></table><h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line">a = <span class="number">123</span>;</span><br><span class="line">a = <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line">a = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s:string;</span><br><span class="line">s = a; <span class="comment">//正常</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c: unknown; <span class="comment">//未知类型的值</span></span><br><span class="line">c = <span class="number">123</span>;</span><br><span class="line">c = <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line">c = <span class="literal">true</span>;</span><br><span class="line">c = <span class="string">&#x27;str&#x27;</span>;</span><br><span class="line"></span><br><span class="line">s = c; <span class="comment">//错误：Type &#x27;unknown&#x27; is not assignable to type &#x27;string&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// unknown实际上是一个类型安全的any</span></span><br><span class="line"><span class="comment">// unknown类型的变量不可以直接赋值给其他变量，需要类型检测，any类型的可以直接赋值。</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> c === <span class="string">&#x27;string&#x27;</span>)&#123;</span><br><span class="line">    s = c; <span class="comment">//正常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者：</span></span><br><span class="line">s = h <span class="keyword">as</span> string; <span class="comment">//类型断言</span></span><br><span class="line">s = &lt;string&gt;e; <span class="comment">//类型断言</span></span><br></pre></td></tr></table></figure><h2 id="类型断言-Type-Assertion"><a href="#类型断言-Type-Assertion" class="headerlink" title="类型断言(Type Assertion)"></a>类型断言(Type Assertion)</h2><p>类型断言可以用来手动指定一个值的类型，即允许变量从一种值的类型转换为另一种类型。<br>语法：</p><ul><li>&lt;类型&gt;值</li><li>值 as 类型</li></ul><h2 id="never-不可能出现的值"><a href="#never-不可能出现的值" class="headerlink" title="never 不可能出现的值"></a>never 不可能出现的值</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示不会有返回值的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>): <span class="title">never</span></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值为 never 的函数可以是无法被执行到的终止点的情况</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n:never;</span><br><span class="line"><span class="keyword">let</span> m: string;</span><br><span class="line"><span class="comment">// n = 1; // 运行错误，数字类型不能转为 never 类型</span></span><br><span class="line"><span class="comment">// &lt;!-- 运行正确，never 类型可以赋值给 never类型 --&gt;</span></span><br><span class="line">n = (<span class="function">()=&gt;</span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>)&#125;)();</span><br><span class="line"></span><br><span class="line">m = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="comment">// &lt;!-- 运行正确，never 类型可以赋值给 字符串类型 --&gt;</span></span><br><span class="line">m = (<span class="function">()=&gt;</span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error&#x27;</span>)&#125;)();</span><br></pre></td></tr></table></figure><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>{}可以指定对象中有哪些属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj: &#123;<span class="attr">name</span>: string,age?:number&#125;;</span><br><span class="line">obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;zjy&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p>age?:number,?表示可选</p><p>多个属性可选：[propName: string]:any</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj: &#123;<span class="attr">name</span>: string,[propName:string]:any&#125;;</span><br><span class="line">obj = &#123;<span class="attr">name</span>:<span class="string">&#x27;zjy&#x27;</span>,<span class="attr">age</span>:<span class="number">13</span>,<span class="attr">sex</span>:<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><p>函数结构的类型声明：<br>语法：(属性：类型,…)=&gt;返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fun :<span class="function">(<span class="params">a:number,b:number</span>)=&gt;</span>number;</span><br><span class="line">fun = <span class="function"><span class="keyword">function</span>(<span class="params">n1:number,n2:number</span>):<span class="title">number</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n1 + n2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="amp-表示同时满足2个条件"><a href="#amp-表示同时满足2个条件" class="headerlink" title="&amp;:表示同时满足2个条件"></a>&amp;:表示同时满足2个条件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj2: &#123;<span class="attr">name</span>:string&#125; &amp; &#123;<span class="attr">age</span>:number&#125;;</span><br><span class="line">    obj2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;zjy&#x27;</span>, <span class="attr">age</span>:<span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="类型的别名"><a href="#类型的别名" class="headerlink" title="类型的别名"></a>类型的别名</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型的别名</span></span><br><span class="line">type typename = <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> k: typename;</span><br><span class="line">k = <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="自动编译选项：tsc-xxx-ts-w"><a href="#自动编译选项：tsc-xxx-ts-w" class="headerlink" title="自动编译选项：tsc xxx.ts -w"></a>自动编译选项：tsc xxx.ts -w</h2><h2 id="添加tsconfig-json文件可编译目录下所有文件"><a href="#添加tsconfig-json文件可编译目录下所有文件" class="headerlink" title="添加tsconfig.json文件可编译目录下所有文件"></a>添加tsconfig.json文件可编译目录下所有文件</h2><p>tsc -init 生成tsconfig.json文件</p><h2 id="tsconfig-json编译选项"><a href="#tsconfig-json编译选项" class="headerlink" title="tsconfig.json编译选项"></a>tsconfig.json编译选项</h2><ul><li><p>include: [] 用于指定哪些文件需要被编译</p><ul><li>**: 任意目录</li><li>*: 任意文件</li></ul></li><li><p>exclude :[] 不需要被编译文件的目录</p><ul><li>“exclude”默认情况下会排除node_modules，bower_components，jspm_packages和<code>&lt;outDir&gt;</code>目录</li></ul></li><li><p>extends： 可以利用extends属性从另一个配置文件里继承配置</p></li><li><p>files: [] 指定一个包含相对或绝对文件路径的列表</p><ul><li>使用”include”引入的文件可以使用”exclude”属性过滤。 然而，通过 “files”属性明确指定的文件却总是会被包含在内，不管”exclude”如何设置</li></ul></li><li><p>compilerOptions:编译器选项配置</p><ul><li>target：指定ECMAScript目标版本，默认ES3，”ES5”， “ES6”/ “ES2015”， “ES2016”， “ES2017”或 “ESNext”。</li><li>module: 指定生成哪个模块系统代码： “None”， “CommonJS”， “AMD”， “System”， “UMD”， “ES6”或 “ES2015”。</li><li>lib:[]  编译过程中需要引入的库文件的列表,例如ES5，ES6 ，DOM等</li><li>outDir: 用来指定编译后文件所在目录</li><li>outFile: 将输出文件合并为一个文件,只有 “AMD”和 “System”能和 –outFile一起使用。</li><li>allowJs: 默认是false，允许编译javascript文件。</li><li>checkJs: 默认是false，是否检测js语法，与allowJs配合使用</li><li>removeComments: 默认是false，删除所有注释，除了以 /!*开头的版权信息。</li><li>noEmit: 默认是false,不输出编译文件</li><li>noEmitOnError: 默认是false 报错时不生成输出文件</li><li>alwaysStrict: 默认是false 以严格模式解析并为每个源文件生成 “use strict”语句,当文件使用模块化时自动采用严格模式，不会生成文件头部’use strict’</li><li>noImplicitAny: 默认是false 在表达式和声明上有隐含的 any类型时报错。<ul><li>例如：function add(a,b){<br>return a + b;<br>}</li></ul></li><li>noImplicitThis: 默认是false 当 this表达式的值为 any类型的时候，生成一个错误</li><li>strictNullChecks: 默认是false 严格检查空值</li><li>strict: 默认是false 启用所有严格类型检查选项。启用 –strict相当于启用 –noImplicitAny, –noImplicitThis, –alwaysStrict， –strictNullChecks和 –strictFunctionTypes和–strictPropertyInitialization</li></ul></li></ul><p>tsconfig.json文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">/* Visit https://aka.ms/tsconfig.json to read more about this file */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Basic Options */</span></span><br><span class="line">    <span class="comment">// &quot;incremental&quot;: true,                   /* Enable incremental compilation */</span></span><br><span class="line">    <span class="string">&quot;target&quot;</span>: <span class="string">&quot;es6&quot;</span>,                          <span class="comment">/* Specify ECMAScript target version: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, &#x27;ES2018&#x27;, &#x27;ES2019&#x27;, &#x27;ES2020&#x27;, or &#x27;ESNEXT&#x27;. */</span></span><br><span class="line">    <span class="string">&quot;module&quot;</span>: <span class="string">&quot;es6&quot;</span>,                     <span class="comment">/* Specify module code generation: &#x27;none&#x27;, &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27;, &#x27;es2015&#x27;, &#x27;es2020&#x27;, or &#x27;ESNext&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;lib&quot;: [],                             /* Specify library files to be included in the compilation. */</span></span><br><span class="line">    <span class="string">&quot;allowJs&quot;</span>: <span class="literal">true</span>,                       <span class="comment">/* Allow javascript files to be compiled. */</span></span><br><span class="line">    <span class="string">&quot;checkJs&quot;</span>: <span class="literal">true</span>,                       <span class="comment">/* Report errors in .js files. */</span></span><br><span class="line">    <span class="comment">// &quot;jsx&quot;: &quot;preserve&quot;,                     /* Specify JSX code generation: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;declaration&quot;: true,                   /* Generates corresponding &#x27;.d.ts&#x27; file. */</span></span><br><span class="line">    <span class="comment">// &quot;declarationMap&quot;: true,                /* Generates a sourcemap for each corresponding &#x27;.d.ts&#x27; file. */</span></span><br><span class="line">    <span class="comment">// &quot;sourceMap&quot;: true,                     /* Generates corresponding &#x27;.map&#x27; file. */</span></span><br><span class="line">    <span class="comment">// &quot;outFile&quot;: &quot;dist/app.js&quot;,                       /* Concatenate and emit output to single file. */</span></span><br><span class="line">    <span class="string">&quot;outDir&quot;</span>: <span class="string">&quot;dist/&quot;</span>,                        <span class="comment">/* Redirect output structure to the directory. */</span></span><br><span class="line">    <span class="comment">// &quot;rootDir&quot;: &quot;./&quot;,                       /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */</span></span><br><span class="line">    <span class="comment">// &quot;composite&quot;: true,                     /* Enable project compilation */</span></span><br><span class="line">    <span class="comment">// &quot;tsBuildInfoFile&quot;: &quot;./&quot;,               /* Specify file to store incremental compilation information */</span></span><br><span class="line">    <span class="string">&quot;removeComments&quot;</span>: <span class="literal">true</span>,                <span class="comment">/* Do not emit comments to output. */</span></span><br><span class="line">    <span class="string">&quot;noEmit&quot;</span>: <span class="literal">false</span>,                        <span class="comment">/* Do not emit outputs. */</span></span><br><span class="line">    <span class="string">&quot;noEmitOnError&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// &quot;importHelpers&quot;: true,                 /* Import emit helpers from &#x27;tslib&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;downlevelIteration&quot;: true,            /* Provide full support for iterables in &#x27;for-of&#x27;, spread, and destructuring when targeting &#x27;ES5&#x27; or &#x27;ES3&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;isolatedModules&quot;: true,               /* Transpile each file as a separate module (similar to &#x27;ts.transpileModule&#x27;). */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Strict Type-Checking Options */</span></span><br><span class="line">    <span class="string">&quot;strict&quot;</span>: <span class="literal">true</span>,                           <span class="comment">/* Enable all strict type-checking options. */</span></span><br><span class="line">    <span class="string">&quot;noImplicitAny&quot;</span>: <span class="literal">true</span>,                 <span class="comment">/* Raise error on expressions and declarations with an implied &#x27;any&#x27; type. */</span></span><br><span class="line">    <span class="comment">// &quot;strictNullChecks&quot;: true,              /* Enable strict null checks. */</span></span><br><span class="line">    <span class="comment">// &quot;strictFunctionTypes&quot;: true,           /* Enable strict checking of function types. */</span></span><br><span class="line">    <span class="comment">// &quot;strictBindCallApply&quot;: true,           /* Enable strict &#x27;bind&#x27;, &#x27;call&#x27;, and &#x27;apply&#x27; methods on functions. */</span></span><br><span class="line">    <span class="comment">// &quot;strictPropertyInitialization&quot;: true,  /* Enable strict checking of property initialization in classes. */</span></span><br><span class="line">    <span class="comment">// &quot;noImplicitThis&quot;: true,                /* Raise error on &#x27;this&#x27; expressions with an implied &#x27;any&#x27; type. */</span></span><br><span class="line">    <span class="comment">// &quot;alwaysStrict&quot;: true,                  /* Parse in strict mode and emit &quot;use strict&quot; for each source file. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Additional Checks */</span></span><br><span class="line">    <span class="comment">// &quot;noUnusedLocals&quot;: true,                /* Report errors on unused locals. */</span></span><br><span class="line">    <span class="comment">// &quot;noUnusedParameters&quot;: true,            /* Report errors on unused parameters. */</span></span><br><span class="line">    <span class="comment">// &quot;noImplicitReturns&quot;: true,             /* Report error when not all code paths in function return a value. */</span></span><br><span class="line">    <span class="comment">// &quot;noFallthroughCasesInSwitch&quot;: true,    /* Report errors for fallthrough cases in switch statement. */</span></span><br><span class="line">    <span class="comment">// &quot;noUncheckedIndexedAccess&quot;: true,      /* Include &#x27;undefined&#x27; in index signature results */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Module Resolution Options */</span></span><br><span class="line">    <span class="comment">// &quot;moduleResolution&quot;: &quot;node&quot;,            /* Specify module resolution strategy: &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6). */</span></span><br><span class="line">    <span class="comment">// &quot;baseUrl&quot;: &quot;./&quot;,                       /* Base directory to resolve non-absolute module names. */</span></span><br><span class="line">    <span class="comment">// &quot;paths&quot;: &#123;&#125;,                           /* A series of entries which re-map imports to lookup locations relative to the &#x27;baseUrl&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;rootDirs&quot;: [],                        /* List of root folders whose combined content represents the structure of the project at runtime. */</span></span><br><span class="line">    <span class="comment">// &quot;typeRoots&quot;: [],                       /* List of folders to include type definitions from. */</span></span><br><span class="line">    <span class="comment">// &quot;types&quot;: [],                           /* Type declaration files to be included in compilation. */</span></span><br><span class="line">    <span class="comment">// &quot;allowSyntheticDefaultImports&quot;: true,  /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */</span></span><br><span class="line">    <span class="string">&quot;esModuleInterop&quot;</span>: <span class="literal">true</span>,                  <span class="comment">/* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies &#x27;allowSyntheticDefaultImports&#x27;. */</span></span><br><span class="line">    <span class="comment">// &quot;preserveSymlinks&quot;: true,              /* Do not resolve the real path of symlinks. */</span></span><br><span class="line">    <span class="comment">// &quot;allowUmdGlobalAccess&quot;: true,          /* Allow accessing UMD globals from modules. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Source Map Options */</span></span><br><span class="line">    <span class="comment">// &quot;sourceRoot&quot;: &quot;&quot;,                      /* Specify the location where debugger should locate TypeScript files instead of source locations. */</span></span><br><span class="line">    <span class="comment">// &quot;mapRoot&quot;: &quot;&quot;,                         /* Specify the location where debugger should locate map files instead of generated locations. */</span></span><br><span class="line">    <span class="comment">// &quot;inlineSourceMap&quot;: true,               /* Emit a single file with source maps instead of having a separate file. */</span></span><br><span class="line">    <span class="comment">// &quot;inlineSources&quot;: true,                 /* Emit the source alongside the sourcemaps within a single file; requires &#x27;--inlineSourceMap&#x27; or &#x27;--sourceMap&#x27; to be set. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Experimental Options */</span></span><br><span class="line">    <span class="comment">// &quot;experimentalDecorators&quot;: true,        /* Enables experimental support for ES7 decorators. */</span></span><br><span class="line">    <span class="comment">// &quot;emitDecoratorMetadata&quot;: true,         /* Enables experimental support for emitting type metadata for decorators. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Advanced Options */</span></span><br><span class="line">    <span class="string">&quot;skipLibCheck&quot;</span>: <span class="literal">true</span>,                     <span class="comment">/* Skip type checking of declaration files. */</span></span><br><span class="line">    <span class="string">&quot;forceConsistentCasingInFileNames&quot;</span>: <span class="literal">true</span>  <span class="comment">/* Disallow inconsistently-cased references to the same file. */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;include&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;src/**/*&quot;</span></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue框架基础</title>
      <link href="/ZJY.github.io/2021/02/20/vue%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80/"/>
      <url>/ZJY.github.io/2021/02/20/vue%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue-js优点"><a href="#Vue-js优点" class="headerlink" title="Vue.js优点"></a>Vue.js优点</h2><p>1.体积小</p><p>压缩后33k</p><p>2.更高的运行效率</p><p>基于虚拟dom，一种可以预先通过JavaScript进行各种计算，把最终的dom操作计算出来并优化的技术，由于这个dom操作属于预处理操作，并没有真实的操作dom，所以叫虚拟dom。</p><p>3.双向数据绑定</p><p>让开发者不再去操作dom对象，更多的精力投入到业务逻辑上</p><p>4.生态丰富、学习成本低</p><p>市场上拥有大量成熟、稳定的基于vue.js的ui框架、常用组件，实现快速开发。对初学者友好、入门容易、学习资料多。</p><h2 id="vue的安装与部署"><a href="#vue的安装与部署" class="headerlink" title="vue的安装与部署"></a>vue的安装与部署</h2><p>安装：</p><ul><li>1.通过script直接引入</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line">&lt;script src=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="comment">// &lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;</span></span><br><span class="line">&lt;script src=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>2.NPM</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue</span><br></pre></td></tr></table></figure><ul><li>3.命令行工具（CLI）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br><span class="line"><span class="comment">// OR</span></span><br><span class="line">yarn <span class="built_in">global</span> add @vue/cli</span><br></pre></td></tr></table></figure><h2 id="数据与方法"><a href="#数据与方法" class="headerlink" title="数据与方法"></a>数据与方法</h2><p>当一个 Vue 实例被创建时，它将 data 对象中的所有的 property 加入到 Vue 的响应式系统中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们的数据对象</span></span><br><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该对象被加入到一个 Vue 实例中</span></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得这个实例上的 property</span></span><br><span class="line"><span class="comment">// 返回源数据中对应的字段</span></span><br><span class="line">vm.a == data.a <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 property 也会影响到原始数据</span></span><br><span class="line">vm.a = <span class="number">2</span></span><br><span class="line">data.a <span class="comment">// =&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ……反之亦然</span></span><br><span class="line">data.a = <span class="number">3</span></span><br><span class="line">vm.a <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure><p>当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时就已经存在于 data 中的 property 才是响应式的。也就是说如果你添加一个新的 property，比如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.b = <span class="string">&#x27;hi&#x27;</span></span><br></pre></td></tr></table></figure><p>那么对 b 的改动将不会触发任何视图的更新。如果你知道你会在晚些时候需要一个 property，但是一开始它为空或不存在，那么你仅需要设置一些初始值。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  newTodoText: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  visitCount: <span class="number">0</span>,</span><br><span class="line">  hideCompletedTodos: <span class="literal">false</span>,</span><br><span class="line">  todos: [],</span><br><span class="line">  error: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里唯一的例外是使用 Object.freeze()，这会阻止修改现有的 property，也意味着响应系统无法再追踪变化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.freeze(obj)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: obj</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; foo &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 这里的 `foo` 不会更新！ --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;foo = &#x27;baz&#x27;&quot;</span>&gt;</span>Change it<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>除了数据 property，Vue 实例还暴露了一些有用的实例 property 与方法。它们都有前缀 $，以便与用户定义的 property 区分开来。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.$data === data <span class="comment">// =&gt; true</span></span><br><span class="line">vm.$el === <span class="built_in">document</span>.getElementById(<span class="string">&#x27;example&#x27;</span>) <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $watch 是一个实例方法</span></span><br><span class="line">vm.$watch(<span class="string">&#x27;a&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">newValue, oldValue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个回调将在 `vm.a` 改变后调用</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</span></span><br><span class="line">beforeCreate:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;beforeCreate&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">/* 在实例创建完成后被立即调用。</span></span><br><span class="line"><span class="comment">在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。</span></span><br><span class="line"><span class="comment">然而，挂载阶段还没开始，$el 属性目前不可见。 */</span></span><br><span class="line">created:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;created&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//在挂载开始之前被调用：相关的渲染函数首次被调用</span></span><br><span class="line">beforeMount : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;beforeMount&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//el 被新创建的 vm.$el 替换, 挂载成功</span></span><br><span class="line"><span class="comment">// 注意 mounted 不会保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 mounted 内部使用 vm.$nextTick</span></span><br><span class="line">mounted : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;mounted&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//数据更新时调用</span></span><br><span class="line">beforeUpdate : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;beforeUpdate&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//组件 DOM 已经更新, 组件更新完毕 </span></span><br><span class="line">updated : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;updated&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例销毁之前调用。在这一步，实例仍然完全可用</span></span><br><span class="line">beforeDestory: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;beforeDestory&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。</span></span><br><span class="line">destroyed: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;destroyed&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 被 keep-alive 缓存的组件激活时调用。</span></span><br><span class="line">activated: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;activated&#x27;</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 被 keep-alive 缓存的组件停用时调用</span></span><br><span class="line">deactivated: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;deactivated&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模版语法"><a href="#模版语法" class="headerlink" title="模版语法"></a>模版语法</h2><p>Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML，所以能被遵循规范的浏览器和 HTML 解析器解析。</p><p>在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。</p><p>1.文本<br>数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-once</span>&gt;</span>这个将不会改变: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.原始HTML<br>双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 v-html 指令：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using mustaches: &#123;&#123; rawHtml &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using v-html directive: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&quot;rawHtml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.Attribute<br>Mustache 语法不能作用在 HTML attribute 上，遇到这种情况应该使用 v-bind 指令：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;dynamicId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4.使用javascript表达式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; number + 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;&#x27;list-&#x27; + id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>指令 (Directives) 是带有 v- 前缀的特殊 attribute。指令 attribute 的值预期是单个 JavaScript 表达式 (v-for 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</p><p>1.参数<br>一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，v-bind 指令可以用于响应式地更新 HTML attribute：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另一个例子是 v-on 指令，它用于监听 DOM 事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.动态参数<br>从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[<span class="attr">attributeName</span>]=<span class="string">&quot;url&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同样地，你可以使用动态参数为一个动态的事件名绑定处理函数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:</span>[<span class="attr">eventName</span>]=<span class="string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对动态参数的值的约束:<br>  动态参数预期会求出一个字符串，异常情况下值为 null。这个特殊的 null 值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。<br>对动态参数表达式的约束:<br>  动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML attribute 名里是无效的。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这会触发一个编译警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[&#x27;<span class="attr">foo</span>&#x27; + <span class="attr">bar</span>]=<span class="string">&quot;value&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>变通的办法是使用没有空格或引号的表达式，或用计算属性替代这种复杂表达式。</p><p>在 DOM 中使用模板时 (直接在一个 HTML 文件里撰写模板)，还需要避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">在 DOM 中使用模板时这段代码会被转换为 `v-bind:[someattr]`。</span></span><br><span class="line"><span class="comment">除非在实例中有一个名为“someattr”的 property，否则代码不会工作。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[<span class="attr">someAttr</span>]=<span class="string">&quot;value&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.修饰符</p><p>修饰符 (modifier) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4.缩写</p><p>v-bind缩写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">&quot;url&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:</span>[<span class="attr">key</span>]=<span class="string">&quot;url&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>v-on缩写</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @[<span class="attr">event</span>]=<span class="string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="class和style绑定"><a href="#class和style绑定" class="headerlink" title="class和style绑定"></a>class和style绑定</h2><ul><li>绑定html class</li></ul><p>1.对象语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;&#123; active: isActive &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;div</span><br><span class="line">  class=&quot;static&quot;</span><br><span class="line">  v-bind:class=&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们也可以在这里绑定一个返回对象的计算属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;classObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  error: <span class="literal">null</span></span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  classObject: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      active: <span class="built_in">this</span>.isActive &amp;&amp; !<span class="built_in">this</span>.error,</span><br><span class="line">      <span class="string">&#x27;text-danger&#x27;</span>: <span class="built_in">this</span>.error &amp;&amp; <span class="built_in">this</span>.error.type === <span class="string">&#x27;fatal&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.数组语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;[activeClass, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;[&#123; active: isActive &#125;, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.用在组件上</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;&#123; active: isActive &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>绑定内联样式</li></ul><p>1.对象语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;styleObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  styleObject: &#123;</span><br><span class="line">    color: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">    fontSize: <span class="string">&#x27;13px&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.数组语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;[baseStyles, overridingStyles]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><ul><li><p>v-if<br>v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。</p></li><li><p>v-else<br>你可以使用 v-else 指令来表示 v-if 的“else 块”：</p></li><li><p>v-else-if<br>v-else-if，顾名思义，充当 v-if 的“else-if 块”，可以连续使用：</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;type === &#x27;A&#x27;&quot;</span>&gt;</span></span><br><span class="line">  A</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;B&#x27;&quot;</span>&gt;</span></span><br><span class="line">  B</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;C&#x27;&quot;</span>&gt;</span></span><br><span class="line">  C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  Not A/B/C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>用 key 管理可复用的元素<br>Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染.如果两个元素是完全独立的，不要复用它们，只需添加一个具有唯一值的key属性即可</p></li><li><p>v-show<br>另一个用于根据条件展示元素的选项是 v-show 指令。用法大致一样：</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">&quot;ok&quot;</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS property display。v-show 不支持 <code>&lt;template&gt; </code>元素，也不支持 v-else</p><ul><li>v-if vs v-show</li></ul><p>v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p><p>v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p>相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p><p>一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好</p><ul><li>v-if与v-for一起使用</li></ul><p>当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级</p><h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><ul><li>用 v-for 把一个数组对应为一组元素</li></ul><p>我们可以用 v-for 指令基于一个数组来渲染一个列表。v-for 指令需要使用 item in items 形式的特殊语法，其中 items 是源数据数组，而 item 则是被迭代的数组元素的别名。</p><p>你也可以用 of 替代 in 作为分隔符，因为它更接近 JavaScript 迭代器的语法：</p><ul><li>在 v-for 里使用对象</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;v-for-object&quot;</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;value in object&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; value &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#v-for-object&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    object: &#123;</span><br><span class="line">      title: <span class="string">&#x27;How to do lists in Vue&#x27;</span>,</span><br><span class="line">      author: <span class="string">&#x27;Jane Doe&#x27;</span>,</span><br><span class="line">      publishedAt: <span class="string">&#x27;2016-04-10&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以提供第二个的参数为 property 名称 (也就是键名)：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, name) in object&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还可以用第三个参数作为索引：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, name, index) in object&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在遍历对象时，会按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下都一致</p><ul><li>维护状态</li></ul><p>当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染</p><p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key attribute</p><p>建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</p><p>不要使用对象或数组之类的非基本类型值作为 v-for 的 key。请用字符串或数值类型的值。</p><ul><li>数组更新检查</li></ul><p>变更方法：Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：<br>push()<br>pop()<br>shift()<br>unshift()<br>splice()<br>sort()<br>reverse()</p><p>替换数组：变更方法，顾名思义，会变更调用了这些方法的原始数组。相比之下，也有非变更方法，例如 filter()、concat() 和 slice()。它们不会变更原始数组，而总是返回一个新数组。当使用非变更方法时，可以用新数组替换旧数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">example1.items = example1.items.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item.message.match(<span class="regexp">/Foo/</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>你可能认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表。幸运的是，事实并非如此。Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的启发式方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作</p><p>由于 JavaScript 的限制，Vue 不能检测数组和对象的变化</p><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>可以用 v-on 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example-1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;counter += 1&quot;</span>&gt;</span>Add 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>The button above has been clicked &#123;&#123; counter &#125;&#125; times.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然而许多事件处理逻辑会更为复杂，所以直接把 JavaScript 代码写在 v-on 指令中是不可行的。因此 v-on 还可以接收一个需要调用的方法名称。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example-2&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- `greet` 是在下面定义的方法名 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;greet&quot;</span>&gt;</span>Greet<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>除了直接绑定到一个方法，也可以在内联 JavaScript 语句中调用方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example-3&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;say(&#x27;hi&#x27;)&quot;</span>&gt;</span>Say hi<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;say(&#x27;what&#x27;)&quot;</span>&gt;</span>Say what<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;warn(&#x27;Form cannot be submitted yet.&#x27;, $event)&quot;</span>&gt;</span></span><br><span class="line">  Submit</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p>.stop<br>.prevent<br>.capture<br>.self<br>.once<br>.passive</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.once</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 而不会等待 `onScroll` 完成  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">&quot;onScroll&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击</p><h3 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 你可以直接将 KeyboardEvent.key 暴露的任意有效按键名转换为 kebab-case 来作为修饰符。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.page-down</span>=<span class="string">&quot;onPageDown&quot;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h2><p>你可以用 v-model 指令在表单<code> &lt;input&gt;</code>、<code>&lt;textarea&gt; </code>及 <code>&lt;select&gt;</code> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理</p><p>v-model 会忽略所有表单元素的 value、checked、selected attribute 的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值</p><p>v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：<br>text 和 textarea 元素使用 value property 和 input 事件；<br>checkbox 和 radio 使用 checked property 和 change 事件；<br>select 字段将 value 作为 prop 并将 change 作为事件</p><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul><li>.lazy</li></ul><p>在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 lazy 修饰符，从而转为在 change 事件_之后_进行同步：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在“change”时而非“input”时更新 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.lazy</span>=<span class="string">&quot;msg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>.number</li></ul><p>如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.number</span>=<span class="string">&quot;age&quot;</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这通常很有用，因为即使在 type=”number” 时，HTML 输入元素的值也总会返回字符串。如果这个值无法被 parseFloat() 解析，则会返回原始的值</p><ul><li>.trim</li></ul><p>如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.trim</span>=<span class="string">&quot;msg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个名为 button-counter 的新组件</span><br><span class="line">Vue.component(&#x27;button-counter&#x27;, &#123;</span><br><span class="line">  data: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: &#x27;<span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;count++&quot;</span>&gt;</span>You clicked me &#123;&#123; count &#125;&#125; times.<span class="tag">&lt;/<span class="name">button</span>&gt;</span>&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>因为组件是可复用的 Vue 实例，所以它们与 new Vue 接收相同的选项，例如 data、computed、watch、methods 以及生命周期钩子等。仅有的例外是像 el 这样根实例特有的选项。</p><h3 id="组件的复用"><a href="#组件的复用" class="headerlink" title="组件的复用"></a>组件的复用</h3><p>你可以将组件进行任意次数的复用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;components-demo&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意当点击按钮时，每个组件都会各自独立维护它的 count。因为你每用一次组件，就会有一个它的新实例被创建。</p><p><b>data 必须是一个函数</b><br>当我们定义这个 <code>&lt;button-counter&gt;</code> 组件时，你可能会发现它的 data 并不是像这样直接提供一个对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  count: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取而代之的是，一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 Vue 没有这条规则，点击一个按钮就可能会影响到其它所有实例</p><h3 id="通过prop向自组件传递数据"><a href="#通过prop向自组件传递数据" class="headerlink" title="通过prop向自组件传递数据"></a>通过prop向自组件传递数据</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;blog-post&#x27;</span>, &#123;</span><br><span class="line">  props: [<span class="string">&#x27;title&#x27;</span>],</span><br><span class="line">  template: <span class="string">&#x27;&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="监听子组件事件"><a href="#监听子组件事件" class="headerlink" title="监听子组件事件"></a>监听子组件事件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;blog-post</span><br><span class="line">  ...</span><br><span class="line">  v-on:enlarge-text=&quot;postFontSize += 0.1&quot;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 同时子组件可以通过调用内建的 $emit 方法并传入事件名称来触发一个事件：</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;$emit(&#x27;enlarge-text&#x27;)&quot;</span>&gt;</span></span><br><span class="line">  Enlarge text</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用事件抛出一个值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;$emit(&#x27;enlarge-text&#x27;, 0.1)&quot;</span>&gt;</span></span><br><span class="line">  Enlarge text</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在组件上使用v-model"><a href="#在组件上使用v-model" class="headerlink" title="在组件上使用v-model"></a>在组件上使用v-model</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;searchText&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等价于 --&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;input</span><br><span class="line">  v-bind:value=&quot;searchText&quot;</span><br><span class="line">  v-on:input=&quot;searchText = $event.target.value&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>当用在组件上时，v-model 则会这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;custom-input</span><br><span class="line">  v-bind:value=&quot;searchText&quot;</span><br><span class="line">  v-on:input=&quot;searchText = $event&quot;</span><br><span class="line">&gt;<span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了让它正常工作，这个组件内的 <input> 必须：<br>将其 value attribute 绑定到一个名叫 value 的 prop 上<br>在其 input 事件被触发时，将新的值通过自定义的 input 事件抛出</p><p>写成代码之后是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;custom-input&#x27;</span>, &#123;</span><br><span class="line">  props: [<span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      v-bind:value=&quot;value&quot;</span></span><br><span class="line"><span class="string">      v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在 v-model 就应该可以在这个组件上完美地工作起来了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">custom-input</span> <span class="attr">v-model</span>=<span class="string">&quot;searchText&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="通过插槽分发内容"><a href="#通过插槽分发内容" class="headerlink" title="通过插槽分发内容"></a>通过插槽分发内容</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;alert-box&#x27;, &#123;</span><br><span class="line">  template: `</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo-alert-box&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">strong</span>&gt;</span>Error!<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><p>有的时候，在不同组件之间进行动态切换是非常有用的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">&quot;currentTabComponent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h2><p>定义组件名的方式：</p><ul><li>使用kebab-case:以短横线分隔命名，你也必须在引用这个自定义元素时使用 kebab-case，例如 <code>&lt;my-component-name&gt;</code>。</li><li>使用 PascalCase:首字母大写命名定义组件，你在引用这个自定义元素时两种命名法都可以使用。也就是说 <code>&lt;my-component-name&gt;</code> 和 <code>&lt;MyComponentName&gt; </code>都是可接受的</li></ul><h3 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;my-component-name&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// ... 选项 ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">&#x27;component-a&#x27;</span>: ComponentA,</span><br><span class="line">    <span class="string">&#x27;component-b&#x27;</span>: ComponentB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Css单位px,rem,em,vw,vh的区别</title>
      <link href="/ZJY.github.io/2021/02/19/Css%E5%8D%95%E4%BD%8Dpx-rem-em-vw-vh%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/ZJY.github.io/2021/02/19/Css%E5%8D%95%E4%BD%8Dpx-rem-em-vw-vh%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="px"><a href="#px" class="headerlink" title="px"></a>px</h2><p>px就是pixel像素的缩写，相对长度单位，网页设计常用的基本单位。像素px是相对于显示器屏幕分辨率而言的</p><h2 id="em"><a href="#em" class="headerlink" title="em"></a>em</h2><p>em是相对长度单位。相对于当前对象内文本的字体尺寸（参考物是父元素的font-size）</p><p>如当前父元素的字体尺寸未设置，则相对于浏览器的默认字体尺寸</p><h2 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h2><p>rem是CSS3新增的一个相对单位，rem是相对于HTML根元素的字体大小（font-size）来计算的长度单位</p><p>如果你没有设置html的字体大小，就会以浏览器默认字体大小，一般是16px<br>html{font-size: 62.5%}  /* 10 ÷ 16 × 100% = 62.5% */</p><p>em与rem的区别：</p><p>　　rem是相对于根元素（html）的字体大小，而em是相对于其父元素的字体大小</p><p>两者使用规则：</p><p>  如果这个属性根据它的font-size进行测量，则使用em<br>  其他的一切事物属性均使用rem</p><h2 id="vw、vh"><a href="#vw、vh" class="headerlink" title="vw、vh"></a>vw、vh</h2><p>vw、vh、vmax、vmin这四个单位都是基于视口<br>vw是相对视口（viewport）的宽度而定的，长度等于视口宽度的1/100</p><p>假如浏览器的宽度为200px，那么1vw就等于2px（200px/100）</p><p>vh是相对视口（viewport）的高度而定的，长度等于视口高度的1/100</p><p>假如浏览器的高度为500px，那么1vh就等于5px（500px/100）</p><p>vmin和vmax是相对于视口的高度和宽度两者之间的最小值或最大值</p><p>如果浏览器的高为300px、宽为500px，那么1vmin就是3px，1vmax就是5px；如果浏览器的高为800px，宽为1080px，那么1vmin也是8px，1vmax也是10.8px</p><h2 id="（百分比）"><a href="#（百分比）" class="headerlink" title="%（百分比）"></a>%（百分比）</h2><p>一般来说就是相对于父元素</p><p>1、对于普通定位元素就是我们理解的父元素</p><p>2、对于position: absolute;的元素是相对于已定位的父元素</p><p>3、对于position: fixed;的元素是相对于ViewPort（可视窗口）</p><h2 id="vm"><a href="#vm" class="headerlink" title="vm"></a>vm</h2><p>css3新单位，相对于视口的宽度或高度中较小的那个</p><p>其中最小的那个被均分为100单位的vm</p><p>比如：浏览器高度900px，宽度1200px，取最小的浏览器高度，1 vm = 900px/100 = 9 px</p><p>缺点：兼容性差</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML5基础</title>
      <link href="/ZJY.github.io/2021/02/19/HTML5/"/>
      <url>/ZJY.github.io/2021/02/19/HTML5/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><h3 id="开始学习HTML5"><a href="#开始学习HTML5" class="headerlink" title="开始学习HTML5"></a>开始学习HTML5</h3><h4 id="HTML5-简介"><a href="#HTML5-简介" class="headerlink" title="HTML5 简介"></a>HTML5 简介</h4><ul><li>HTML5是HTML最新的修订版本，2014年10月由万维网联盟（W3C）完成标准制定。</li><li>HTML5的设计目的是为了在移动设备上支持多媒体。</li></ul><h4 id="什么是-HTML5"><a href="#什么是-HTML5" class="headerlink" title="什么是 HTML5?"></a>什么是 HTML5?</h4><ul><li>HTML5 是下一代 HTML 标准。</li><li>HTML , HTML 4.01的上一个版本诞生于 1999 年。自从那以后，Web 世界已经经历了巨变。</li><li>HTML5 仍处于完善之中。然而，大部分现代浏览器已经具备了某些 HTML5 支持。</li><li>HTML5 受包括Firefox（火狐浏览器），IE9及其更高版本，Chrome（谷歌浏览器），Safari，Opera等国外主流浏览器的支持；国内的傲游浏览器（Maxthon）， 360浏览器、搜狗浏览器、QQ浏览器、猎豹浏览器等同样具备支持HTML5的能力。</li></ul><h4 id="HTML5-lt-DOCTYPE-gt"><a href="#HTML5-lt-DOCTYPE-gt" class="headerlink" title="HTML5 &lt;!DOCTYPE&gt;"></a>HTML5 &lt;!DOCTYPE&gt;</h4><!doctype><p> 声明必须位于 HTML5 文档中的第一行,使用非常简单:<code>&lt;!doctype html&gt;</code></p><h4 id="最小的HTML5文档"><a href="#最小的HTML5文档" class="headerlink" title="最小的HTML5文档"></a>最小的HTML5文档</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="HTML5的改进"><a href="#HTML5的改进" class="headerlink" title="HTML5的改进"></a>HTML5的改进</h4><ul><li>新元素</li><li>新属性</li><li>完全支持 CSS3</li><li>Video 和 Audio</li><li>2D/3D 制图</li><li>本地存储</li><li>本地 SQL 数据</li><li>Web 应用</li></ul><h4 id="HTML5多媒体"><a href="#HTML5多媒体" class="headerlink" title="HTML5多媒体"></a>HTML5多媒体</h4><p>使用 HTML5 你可以简单的在网页中播放 视频(video)与音频 (audio) 。</p><ul><li>html5 <code>&lt;video/&gt;</code></li><li>html5 <code>&lt;audio/&gt;</code></li></ul><h4 id="HTML5-图形"><a href="#HTML5-图形" class="headerlink" title="HTML5 图形"></a>HTML5 图形</h4><p>使用 HTML5 你可以简单的绘制图形:</p><ul><li>使用 <code>&lt;canvas&gt;</code> 元素</li><li>使用内联 SVG</li><li>使用 CSS3 2D/CSS 3D</li></ul><h4 id="HTML5-使用-CSS3"><a href="#HTML5-使用-CSS3" class="headerlink" title="HTML5 使用 CSS3"></a>HTML5 使用 CSS3</h4><ul><li>新选择器</li><li>新属性</li><li>动画</li><li>2D/3D 转换</li><li>圆角</li><li>阴影效果</li><li>可下载的字体</li></ul><h4 id="语义要素"><a href="#语义要素" class="headerlink" title="语义要素"></a>语义要素</h4><p>HTML5 添加了很多语义元素如下所示：</p><ul><li>article: 定义页面独立的内容区域。</li><li>aside:定义页面的侧边栏内容</li><li>bdi:允许您设置一段文本，使其脱离其父元素的文本方向设置。</li><li>command:定义命令按钮，比如单选按钮、复选框或按钮</li><li>details:用于描述文档或文档某个部分的细节</li><li>dialog:定义对话框，比如提示框</li><li>summary: 标签包含 details 元素的标题</li><li>figure:规定独立的流内容（图像、图表、照片、代码等等）</li><li>figcaption:定义 <code>&lt;figure&gt; </code>元素的标题</li><li>footer:定义 section 或 document 的页脚。</li><li>header:定义了文档的头部区域</li><li>mark:定义带有记号的文本。</li><li>meter:定义度量衡。仅用于已知最大和最小值的度量</li><li>nav:定义导航链接的部分。</li><li>progress:定义任何类型的任务的进度</li><li>ruby:定义 ruby 注释（中文注音或字符）</li><li>rt:定义字符（中文注音或字符）的解释或发音。</li><li>rp:在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容</li><li>section:定义文档中的节（section、区段）</li><li>time:定义日期或时间。</li><li>wbr:规定在文本中的何处适合添加换行符</li></ul><h4 id="HTML5-新特性"><a href="#HTML5-新特性" class="headerlink" title="HTML5 - 新特性"></a>HTML5 - 新特性</h4><ul><li>用于绘画的 canvas 元素</li><li>用于媒介回放的 video 和 audio 元素</li><li>对本地离线存储的更好的支持</li><li>新的特殊内容元素，比如 article、footer、header、nav、section</li><li>新的表单控件，比如 calendar、date、time、email、url、search</li></ul><h3 id="HTML5-浏览器支持"><a href="#HTML5-浏览器支持" class="headerlink" title="HTML5 浏览器支持"></a>HTML5 浏览器支持</h3><ul><li>HTML5 浏览器支持<br>  现代的浏览器都支持 HTML5。<br>  此外，所有浏览器，包括旧的和最新的，对无法识别的元素会作为内联元素自动处理。<br>  正因为如此，你可以 “教会” 浏览器处理 “未知” 的 HTML 元素。</li><li>将 HTML5 元素定义为块元素<br>  HTML5 定了 8 个新的 HTML 语义（semantic）  元素。所有这些元素都是块级 元素。<br>  为了能让旧版本的浏览器正确显示这些元素，你可以设置 CSS 的 display 属性值为 block:<br>  header, section, footer, aside, nav, main, article, figure {display: block;}</li><li>为 HTML 添加新元素</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> newEle = <span class="built_in">document</span>.createElement(<span class="string">&#x27;myHero&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> content = <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;myHero&#x27;</span>);</span></span><br><span class="line">        newEle.appendChild(content)</span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.body.appendChild(newEle);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    myHero&#123;</span><br><span class="line"><span class="css">        <span class="selector-tag">background-color</span><span class="selector-pseudo">:red</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">padding</span><span class="selector-pseudo">:30px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Internet Explorer 浏览器问题<ul><li>你可以使用以上的方法来为 IE 浏览器添加 HTML5 元素，但是Internet Explorer 8 及更早 IE 版本的浏览器不支持以上的方式.针对IE浏览器html5shiv 是比较好的解决方案。html5shiv主要解决HTML5提出的新的元素不被IE6-8识别，这些新元素不能作为父节点包裹子元素，并且不能应用CSS样式。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- [<span class="keyword">if</span> It IE <span class="number">9</span>] --&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;/html5shiv.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;!-- [endif] --&gt;</span><br></pre></td></tr></table></figure><ul><li>完美的 Shiv 解决方案<ul><li>html5shiv.js 引用代码必须放在  <code>&lt;head&gt;</code> 元素中，因为 IE 浏览器在解析 HTML5 新元素时需要先加载该文件。</li></ul></li></ul><h3 id="HTML5-新元素"><a href="#HTML5-新元素" class="headerlink" title="HTML5 新元素"></a>HTML5 新元素</h3><h4 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h4><p>什么是canvas？<br>  标签定义图形，比如图表和其他图像。该标签基于javascript的绘图API。<br>创建画布<br>  画布在网页中是一个矩形框，通过<code>&lt;canvas&gt;</code>元素来绘制</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;myCanvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>使用 JavaScript 来绘制图像<br>  canvas本身没有绘图能力，所以绘图工作必须在js内完成：</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = c.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">ctx.fillStyle=<span class="string">&quot;#ffffff&quot;</span>;</span><br><span class="line">ctx.fillRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">150</span>,<span class="number">75</span>);</span><br></pre></td></tr></table></figure><p>canvas-坐标<br>  canvas是一个二维网络，左上角坐标为（0，0）<br>  ctx.fillRect(0,0,150,75);在画布上绘制150*75的矩形，从左上角开始</p><p>canvas-路径<br>  moveTo(x,y) 定义线条开始坐标<br>  lineTo(x,y) 定义线条结束坐标</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx.moveTo(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">ctx.lineTo(<span class="number">200</span>,<span class="number">100</span>);</span><br><span class="line">ctx.stroke();<span class="comment">//绘制线条</span></span><br></pre></td></tr></table></figure><p>  绘制圆形：arc(x,y,r,start,stop)</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx.begainPath();</span><br><span class="line">ctx.arc(<span class="number">0</span>,<span class="number">0</span>,<span class="number">40</span>,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI);</span><br><span class="line">ctx.stroke();</span><br></pre></td></tr></table></figure><p>canvas-文本<br>  fillText(text,x,y,[maxWidth]);</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx.font = <span class="string">&#x27;30px arial&#x27;</span>;</span><br><span class="line">ctx.fillText(<span class="string">&#x27;hello,world&quot;,10,50)</span></span><br></pre></td></tr></table></figure><p>canvas-渐变</p><p>  渐变可以填充在矩形，圆形，线条，文本等，可以定义不同的颜色<br>  createLinearGradient(x,y,x1,y1);//线条渐变<br>  createRadialGradient(x,y,r,x1,y1,r1);//径向/圆渐变<br>  当我们使用渐变对象，必须使用两种或两种以上的停止颜色<br>  addColorStop()方法指定颜色停止，参数使用坐标来描述，可以是0至1.<br>  设置fillStyle或strokeStyle的值为渐变，然后绘制形状，如矩形，文本，或一条线。<br>  使用createLinearGradient：创建一个线性渐变，使用渐变填充矩形</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//create gradient</span></span><br><span class="line"><span class="keyword">var</span> grd = ctx.createLinearGradient(<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">0</span>);</span><br><span class="line">grd.addColorStop(<span class="number">0</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line">grd.addColorStop(<span class="number">1</span>,<span class="string">&#x27;white&#x27;</span>);</span><br><span class="line"><span class="comment">//fill width gradient</span></span><br><span class="line">ctx.fillStyle = grd;</span><br><span class="line">ctx.fillRect(<span class="number">10</span>,<span class="number">10</span>,<span class="number">150</span>,<span class="number">80</span>);</span><br></pre></td></tr></table></figure><p>  使用createRadialGradient：创建一个径向/圆渐变，使用渐变填充矩形</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> grd = ctx.createRadialGradient(<span class="number">75</span>,<span class="number">50</span>,<span class="number">5</span>,<span class="number">90</span>,<span class="number">60</span>,<span class="number">100</span>);</span><br><span class="line">grd.addColorStop(<span class="number">0</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line">grd.addColorStop(<span class="number">1</span>,<span class="string">&#x27;white&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.fillStyle= grd;</span><br><span class="line">ctx.fillRect(<span class="number">10</span>,<span class="number">10</span>,<span class="number">150</span>,<span class="number">80</span>);</span><br></pre></td></tr></table></figure><p>  createRadialGradient(x , y , r , x1 , y1 , r1) 括号内的参数有如下的含义:<br>  x：表示渐变的开始圆的 x 坐标<br>  y：表示渐变的开始圆的 y 坐标<br>  r：表示开始圆的半径<br>  x1：表示渐变的结束圆的 x 坐标<br>  y1：表示渐变的结束圆的 y 坐标<br>  r1：表示结束圆的半径</p><p>canvas-图像<br>  drawImage(image,x,y)</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.getElementById(<span class="string">&quot;img&quot;</span>);</span><br><span class="line">ctx.drawImage(img,<span class="number">10</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h4 id="新多媒体元素"><a href="#新多媒体元素" class="headerlink" title="新多媒体元素"></a>新多媒体元素</h4><ul><li>audio音频</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;audio.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;aduio/ogg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;audio.mp3&quot;</span> <span class="attr">type</span>=<span class="string">&quot;aduio/mpeg&quot;</span>&gt;</span></span><br><span class="line">  您的浏览器不支持audio元素</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><p>control 属性供添加播放、暂停和音量控件<br>在<code>&lt;audio&gt;</code> 与 <code>&lt;/audio&gt;</code> 之间你需要插入浏览器不支持的<code>&lt;audio&gt;</code>元素的提示文本 。<br><code>&lt;audio&gt;</code> 元素允许使用多个 <code>&lt;source&gt;</code> 元素. <code>&lt;source&gt;</code> 元素可以链接不同的音频文件，浏览器将使用第一个支持的音频文件</p><ul><li>video视频</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> <span class="attr">width</span>=<span class="string">&quot;320&quot;</span> <span class="attr">height</span>=<span class="string">&quot;240&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;movie.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/ogg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;movie.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line">  您的浏览器不支持video元素</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;video&gt;</code>元素提供了播放、暂停和音量控件来控制视频。<br>同时<code>&lt;video&gt;</code>元素也提供了 width 和 height 属性控制视频的尺寸.如果设置的高度和宽度，所需的视频空间会在页面加载时保留。。如果没有设置这些属性，浏览器不知道大小的视频，浏览器就不能再加载时保留特定的空间，页面就会根据原始视频的大小而改变。<br>元素支持多个source元素. 元素可以链接不同的视频文件。浏览器将使用第一个可识别的格式<br>元素支持三种视频格式： MP4, WebM, 和 Ogg:</p><ul><li><p>source<br><code>&lt;source&gt;</code> 标签可以为<code>&lt;picture&gt;</code>、<code>&lt;audio&gt;</code>或<code>&lt;video&gt;</code>元素指定一个或者多个的媒体资源</p></li><li><p>embed<br>定义嵌入的内容，比如插件，定义了一个容器，用来嵌入外部应用或者互动程序（插件）<br>属性：<br>height：规定嵌入内容的高度<br>src: 规定嵌入内容的url<br>type: 规定嵌入内容的MIME类型<br>width: 规定嵌入内容的宽带</p></li><li><p>track<br>为诸如 <code>&lt;video&gt;</code> 和 <code>&lt;audio&gt;</code> 元素之类的媒介规定外部文本轨道<br><code>&lt;track&gt;</code> 标签用作 <code>&lt;audio&gt;</code> 元素和 <code>&lt;video&gt; </code>元素的子级，它允许您指定定时文本轨道（或基于时间的数据），采用 WebVTT 格式（.vtt 文件）</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> <span class="attr">width</span>=<span class="string">&quot;320&quot;</span> <span class="attr">height</span>=<span class="string">&quot;240&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;movie.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/ogg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;movie.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">track</span> <span class="attr">src</span>=<span class="string">&quot;subtitle_en.vtt&quot;</span> <span class="attr">kind</span>=<span class="string">&quot;subtitles&quot;</span> <span class="attr">srclang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">label</span>=<span class="string">&quot;English&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">track</span> <span class="attr">src</span>=<span class="string">&quot;subtitle_zh.vtt&quot;</span> <span class="attr">kind</span>=<span class="string">&quot;subtitles&quot;</span> <span class="attr">srclang</span>=<span class="string">&quot;zh&quot;</span> <span class="attr">label</span>=<span class="string">&quot;Zh&quot;</span>&gt;</span></span><br><span class="line">  您的浏览器不支持video元素</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个元素用于规定字幕文件或其他包含文本的文件，当媒体播放时，这些文件是可见的。</p><h4 id="新表单元素"><a href="#新表单元素" class="headerlink" title="新表单元素"></a>新表单元素</h4><ul><li>datalist<br>定义选项列表。请与 input 元素配合使用该元素，来定义 input 可能的值<ul><li><code>&lt;datalist&gt;</code> 标签规定了 <code>&lt;input&gt;</code> 元素可能的选项列表。</li><li><code>&lt;datalist&gt;</code> 标签被用来在为 <code>&lt;input&gt;</code> 元素提供”自动完成”的特性。用户能看到一个下拉列表，里边的选项是预先定义好的，将作为用户的输入数据。</li><li>请使用 <code>&lt;input&gt;</code> 元素的 list 属性来绑定 <code>&lt;datalist&gt;</code> 元素。</li><li>提示：不能控制 datalist 的位置，并且不能将其与服务器的数据进行绑定。</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">list</span>=<span class="string">&quot;browser&quot;</span> <span class="attr">name</span>=<span class="string">&quot;browser&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">&quot;browser&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;IE&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Firefox&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;chrome&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Opera&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;safari&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>keygen</p><ul><li>规定用于表单的密钥对生成器字段</li><li>当提交表单时，私钥存储在本地，公钥发送到服务器。</li></ul></li><li><p>output</p><ul><li>定义不同类型的输出，比如脚本的输出</li></ul></li></ul><h4 id="新的语义和结构元素"><a href="#新的语义和结构元素" class="headerlink" title="新的语义和结构元素"></a>新的语义和结构元素</h4><ul><li><p>article：定义页面独立的内容区域，主要是布局文章、内容方面的内容</p></li><li><p>aside：定义页面的侧边栏内容。<code>&lt;aside&gt;</code> 标签定义 <code>&lt;article&gt;</code> 标签外的内容</p></li><li><p>bdi:标签允许您设置一段文本，使其脱离其父元素的文本方向设置</p></li><li><p>figure: 标签规定独立的流内容（图像、图表、照片、代码等等）,figure 元素的内容应该与主内容相关，但如果被删除，则不应对文档流产生影响</p></li><li><p>footer:标签定义文档document或节section的页脚。页脚通常包含文档的作者、版权信息、使用条款链接、联系信息等等。您可以在一个文档中使用多个 <code>&lt;footer&gt; </code>元素。</p></li><li><p>header:定义了文档的头部区域,表示介绍性的内容，可以让您了解页面涉及的内容，具有导航性.在一个文档中，您可以定义多个 <code>&lt;header&gt;</code> 元素。注释：<code>&lt;header&gt;</code> 标签不能被放在 <code>&lt;footer&gt;</code>、<code>&lt;address&gt;</code> 或者另一个 <code>&lt;header&gt;</code> 元素内部。</p></li><li><p>mark:带有记号的文本，请在需要突出显示文本时使用 <code>&lt;mark&gt; </code>标签。</p></li><li><p>meter：定义度量衡。仅用于已知最大和最小值的度量<code>&lt;meter min=&quot;0&quot; max=&quot;10&quot; value=&quot;5&quot;&gt;5 out of 10&lt;/meter&gt;</code></p></li><li><p>nav:标签定义导航链接的部分,如果文档中有“前后”按钮，则应该把它放到 <code>&lt;nav&gt; </code>元素中。</p></li><li><p>progress:标签标示任务的进度</p></li><li><p>ruby:标签定义 ruby 注释（中文注音或字符）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ruby</span>&gt;</span></span><br><span class="line">    王 <span class="tag">&lt;<span class="name">rp</span>&gt;</span>(<span class="tag">&lt;/<span class="name">rp</span>&gt;</span><span class="tag">&lt;<span class="name">rt</span>&gt;</span> wang <span class="tag">&lt;/<span class="name">rt</span>&gt;</span><span class="tag">&lt;<span class="name">rp</span>&gt;</span>)<span class="tag">&lt;/<span class="name">rp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ruby</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将 <code>&lt;ruby&gt;</code> 标签与 <code>&lt;rt&gt;</code> 和 <code>&lt;rp&gt; </code>标签一起使用<br>rt:定义字符（中文注音或字符）的解释或发音<br>rp:在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容</p></li><li><p>section:定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。</p></li><li><p>time:用来表示HTML网页中出现的日期和时间，目的是让搜索引擎等其它程序更容易的提取这些信息。<code>&lt;time&gt;</code> 标签不会在任何浏览器中呈现任何特殊效果，只是用来给机器识别的。</p></li><li><p>wbr:可以用来定义HTML文档中需要进行换行的位置，与<code>&lt;br&gt;</code>标签不同，如果浏览器窗口的宽度足够，则不换行；反之，则在添加了 <code>&lt;wbr&gt;</code> 标签的位置进行换行</p></li></ul><h3 id="HTML5-内联-SVG"><a href="#HTML5-内联-SVG" class="headerlink" title="HTML5 内联 SVG"></a>HTML5 内联 SVG</h3><p>SVG表示可缩放矢量图形，是基于可扩展标记语言（标准通用标记语言的子集），用于描述二维矢量图形的一种图形格式，它在2003年1月14日成为W3C推荐标准。<br>什么是SVG?</p><ul><li>SVG 指可伸缩矢量图形 (Scalable Vector Graphics)</li><li>SVG 用于定义用于网络的基于矢量的图形</li><li>SVG 使用 XML 格式定义图形</li><li>SVG 图像在放大或改变尺寸的情况下其图形质量不会有损失</li><li>SVG 是万维网联盟的标准</li><li>SVG 与 DOM 和 XSL 之类的 W3C 标准是一个整体</li></ul><p>与其他图像格式相比（比如 JPEG 和 GIF），使用 SVG 的优势在于：</p><ul><li>SVG 图像可通过文本编辑器来创建和修改</li><li>SVG 图像可被搜索、索引、脚本化或压缩</li><li>SVG 是可伸缩的</li><li>SVG 图像可在任何的分辨率下被高质量地打印</li><li>SVG 可在图像质量不下降的情况下被放大</li></ul><p>SVG 与 Canvas两者间的区别:</p><ul><li>SVG 是一种使用 XML 描述 2D 图形的语言。</li><li>Canvas 通过 JavaScript 来绘制 2D 图形</li><li>SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器</li><li>在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形</li><li>Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。</li></ul><p>Canvas与SVG的比较<br>canvas：</p><ul><li>依赖分辨率</li><li>不支持事件处理器</li><li>弱的文本渲染能力</li><li>能够以png或jpg格式保存结果图像</li><li>最适合图像密集型游戏，其中的许多对象会被频繁重绘</li></ul><p>svg：</p><ul><li>不依赖分辨率</li><li>支持事件处理器</li><li>最适合带有大型渲染区域的应用程序（比如地图）</li><li>复杂度稿会减慢渲染速度（任何过度使用DOM的应用都不快）</li><li>不适合游戏应用</li></ul><h3 id="HTML5-拖放"><a href="#HTML5-拖放" class="headerlink" title="HTML5 拖放"></a>HTML5 拖放</h3><ul><li>HTML5 拖放（Drag 和 Drop）<ul><li>拖放的目的是可以让你将某个对象放置到你想要放置的位置。</li><li>拖放（Drag 和 drop）是 HTML5 标准的组成部分。</li><li>拖放是一种常见的特性，即抓取对象以后拖到另一个位置。</li><li>在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">allowDrop</span>(<span class="params">ev</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ev.preventDefault();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drag</span>(<span class="params">ev</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ev.dataTransfer.setData(<span class="string">&quot;Text&quot;</span>,ev.target.id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drop</span>(<span class="params">ev</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ev.preventDefault();</span><br><span class="line"><span class="keyword">var</span> data=ev.dataTransfer.getData(<span class="string">&quot;Text&quot;</span>);</span><br><span class="line">ev.target.appendChild(<span class="built_in">document</span>.getElementById(data));</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;p&gt;请把 W3School 的图片拖放到矩形中：&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">&quot;div1&quot;</span> ondrop=<span class="string">&quot;drop(event)&quot;</span> ondragover=<span class="string">&quot;allowDrop(event)&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">&lt;img id=<span class="string">&quot;drag1&quot;</span> src=<span class="string">&quot;/i/eg_dragdrop_w3school.gif&quot;</span> draggable=<span class="string">&quot;true&quot;</span> ondragstart=<span class="string">&quot;drag(event)&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p>设置元素为可拖放:<code>&lt;img draggable=&quot;true&quot;&gt;</code><br>拖动什么 - ondragstart 和 setData()<br>放到何处 - ondragover,ondragover 事件规定在何处放置被拖动的数据。<br>默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。<br>这要通过调用 ondragover 事件的 event.preventDefault() 方法<br>进行放置 - ondrop</p><h3 id="HTML5-地理定位"><a href="#HTML5-地理定位" class="headerlink" title="HTML5 地理定位"></a>HTML5 地理定位</h3><p>HTML5 Geolocation（地理定位）用于定位用户的位置<br>Geolocation 通过请求一个位置信息，用户同意后，浏览器会返回一个包含经度和维度的位置信息</p><p>定位用户的位置:<br>  HTML5 Geolocation API 用于获得用户的地理位置<br>  鉴于该特性可能侵犯用户的隐私，除非用户同意，否则用户位置信息是不可用的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;p id=<span class="string">&quot;demo&quot;</span>&gt;点击按钮获取您当前坐标：&lt;/p&gt;</span><br><span class="line">&lt;button onclick=<span class="string">&quot;getLocation()&quot;</span>&gt;click me&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;demo&#x27;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getLocation</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(navigator.geolocation)&#123;</span><br><span class="line">            navigator.geolocation.getCurrentPosition(showPosition);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            x.innerHTML =<span class="string">&#x27;该浏览器不支持获取地理位置&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">showPosition</span>(<span class="params">position</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(position)</span><br><span class="line">        x.innerHTML = <span class="string">&#x27;纬度：&#x27;</span>+ position.coords.latitude+<span class="string">&#x27;&lt;br&gt;经度：&#x27;</span>+position.coords.longitude</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> HTML5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http常见面试题</title>
      <link href="/ZJY.github.io/2021/02/05/http%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/ZJY.github.io/2021/02/05/http%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="1-HTTP基本概念"><a href="#1-HTTP基本概念" class="headerlink" title="1.HTTP基本概念"></a>1.HTTP基本概念</h2><h3 id="1-1-http是什么？"><a href="#1-1-http是什么？" class="headerlink" title="1.1 http是什么？"></a>1.1 http是什么？</h3><p>http是超文本传输协议，也就是HyperText Transfer Protocaol。</p><ul><li>协议<ul><li>http是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式</li></ul></li><li>传输<ul><li>http协议是一个双向协议</li><li>http是一个在计算机世界里专门用来在两点之间传输数据的约定和规范<pre><code>我们在上网冲浪时，浏览器是请求方 A ，百度网站就是应答方 B。双方约定用 HTTP 协议来通信，于是浏览器把请求数据发送给网站，网站再把一些数据返回给浏览器，最后由浏览器渲染在屏幕，就可以看到图片、视频了。数据虽然是在 A 和 B 之间传输，但允许中间有中转或接力。就好像第一排的同学想穿递纸条给最后一排的同学，那么传递的过程中就需要经过好多个同学（中间人），这样的传输方式就从「A &lt; --- &gt; B」，变成了「A &lt;-&gt; N &lt;-&gt; M &lt;-&gt; B」。而在 HTTP 里，需要中间人遵从 HTTP 协议，只要不打扰基本的数据传输，就可以添加任意额外的东西。</code></pre></li></ul></li><li>超文本<ul><li>http传输的内容是超文本</li><li>我们先来理解「文本」，在互联网早期的时候只是简单的字符文字，但现在「文本」的涵义已经可以扩展为图片、视频、压缩包等，在 HTTP 眼里这些都算做「文本」</li><li>再来理解「超文本」，它就是超越了普通文本的文本，它是文字、图片、视频等的混合体最关键有超链接，能从一个超文本跳转到另外一个超文本</li><li>HTML 就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，在经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了</li></ul></li></ul><p><strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p><h3 id="1-2-「HTTP-是用于从互联网服务器传输超文本到本地浏览器的协议HTTP」-这种说法正确吗？"><a href="#1-2-「HTTP-是用于从互联网服务器传输超文本到本地浏览器的协议HTTP」-这种说法正确吗？" class="headerlink" title="1.2 「HTTP 是用于从互联网服务器传输超文本到本地浏览器的协议HTTP」,这种说法正确吗？"></a>1.2 「HTTP 是用于从互联网服务器传输超文本到本地浏览器的协议HTTP」,这种说法正确吗？</h3><p>这种说法是不正确的。因为也可以是「服务器&lt; – &gt;服务器」，所以采用两点之间的描述会更准确</p><h3 id="1-3-http常见的状态吗有哪些？"><a href="#1-3-http常见的状态吗有哪些？" class="headerlink" title="1.3 http常见的状态吗有哪些？"></a>1.3 http常见的状态吗有哪些？</h3><ul><li>1xx<ul><li>1xx类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少</li></ul></li><li>2xx<ul><li>2xx类状态码表示服务器成功处理了客户端的请求。</li><li>200 ok是最常见的成功状态码，表示一切正常。如果是非HEAD请求，服务器返回的相应头都会有body数据。</li><li>204 no content也是常见的成功状态码，与200基本相同，但响应头没有body数据。</li><li>206 partial content是应用于http分块下载或断电续传。表示响应返回的body数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li></ul></li><li>3xx<ul><li>3xx类状态码表示客户端请求的资源发生了变动，需要客户端用新的URL重新发送请求获取资源，也就是重定向。</li><li>301 Moved Permanently 表示永久重定向，说明请求的资源已经不在了，需要用另一个url再次访问</li><li>302 临时重定向，说明请求的资源还在，但暂时需要用另一个url来访问</li><li>301和302都会在响应头里使用字段location，指明后续要跳转的url，浏览器会自动重定向新的url。</li><li>304 not modified不具有跳转的含义，表示资源未被修改，重定向已存在的缓冲文件，也称为缓存重定向，用于缓存控制。</li></ul></li><li>4xx<ul><li>4xx类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。</li><li>400 bad request表示客户端请求的报文有误，但只是个笼统的错误</li><li>401 用户没有访问权限,需要进行身份认证</li><li>403 forbidden表示服务器禁止访问资源，并不是客户端的请求出错</li><li>404 not found表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul></li><li>5xx<ul><li>5xx类状态码表示客户端请求报文正确，但服务器处理时内部发生了错误，属于服务端的错误码。</li><li>500 internal server error，与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li><li>501 not implemented 表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li><li>502 bad gateway，通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误</li><li>503 service unavailable表示服务器当前很忙，暂时无法响应服务器。</li></ul></li></ul><h3 id="1-4-http常见字段有哪些？"><a href="#1-4-http常见字段有哪些？" class="headerlink" title="1.4 http常见字段有哪些？"></a>1.4 http常见字段有哪些？</h3><ul><li>Host<ul><li>客户端发送请求时，用来指定服务器的域名</li><li>host:http:<a href="http://www.a.com/">www.a.com</a></li><li>有了host字段，就可以将请求发往同一台服务器的不同网站</li></ul></li><li>Content-Length<ul><li>服务器在返回数据时，会有content-length字段，表明本次回应的数据长度</li></ul></li><li>Connection字段<ul><li>Connection字段最常用于客户端要求服务器使用TCP持久连接，以便其他请求复用。Connection: keep-alive</li></ul></li><li>Content-Type字段<ul><li>Content-Type字段用于服务器返回时，告诉客户端本次数据返回什么格式。</li><li>Content-Type: text/html; charset=utf-8</li><li>上面的类型表明，发送的是网页，而且编码是UTF-8</li><li>客户端请求的时候，可以使用 Accept 字段声明自己可以接受哪些数据格式</li><li>Accept: <em>/</em></li><li>上面代码中，客户端声明自己可以接受任何格式的数据。</li></ul></li><li>Content-Encoding字段<ul><li>Content-Encoding 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</li><li>Content-Encoding: gzip</li><li>上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。</li><li>客户端在请求时，用 Accept-Encoding 字段说明自己可以接受哪些压缩方法</li><li>Accept-Encoding: gzip, deflate</li></ul></li></ul><h2 id="2-GET和POST"><a href="#2-GET和POST" class="headerlink" title="2.GET和POST"></a>2.GET和POST</h2><h3 id="2-1get和post的区别？"><a href="#2-1get和post的区别？" class="headerlink" title="2.1get和post的区别？"></a>2.1get和post的区别？</h3><ul><li>get方法含义是请求从服务器获取资源，这个资源可以是静态的文本、页面、图片视频等。比如打开一篇文章，浏览器会发送get请求给服务器，服务器就会返回文章所有资源。</li><li>post方法向url指定的资源提交数据，数据就放在报文的body里。比如在一篇文章底部，提交留言板，浏览器就会执行一次post请求，把你的留言文字放进报文body里然后拼接好post请求，通过tcp协议发送给服务器。</li></ul><h3 id="2-2-get和post-方法都是安全和幂等的吗？"><a href="#2-2-get和post-方法都是安全和幂等的吗？" class="headerlink" title="2.2 get和post 方法都是安全和幂等的吗？"></a>2.2 get和post 方法都是安全和幂等的吗？</h3><ul><li>安全：在http协议里，所谓的安全是指请求方法不会破坏服务器上的资源。</li><li>幂等：多次执行相同的操作，结果都是相同的。</li><li>get方法就是安全且幂等的，因为它是只读操作，无论操作多少次，服务器上的数据是安全的，且每次的结果都是相同的。</li><li>post是新增或提交数据的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。</li></ul><h2 id="3-http的特性"><a href="#3-http的特性" class="headerlink" title="3.http的特性"></a>3.http的特性</h2><h3 id="3-1-你知道的-HTTP（1-1）-的优点有哪些，怎么体现的？"><a href="#3-1-你知道的-HTTP（1-1）-的优点有哪些，怎么体现的？" class="headerlink" title="3.1 你知道的 HTTP（1.1） 的优点有哪些，怎么体现的？"></a>3.1 你知道的 HTTP（1.1） 的优点有哪些，怎么体现的？</h3><p>http最凸出的优点是简单、灵活和易于扩展、应用广泛和跨平台。</p><ul><li>简单：http最基本的报文格式是header+body，头部信息也是key-value简单文本的形式。易于理解降低学习和使用门槛。</li><li>灵活和易于扩展：<ul><li>http协议里的各类请求方法、URL/URI、状态码、头字段等每个组成要求都没被固定死，都允许开发人员自定义和扩展。</li><li>http工作在应用层，则它下层可以随意变化</li><li>HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP3 甚至把 TCPP 层换成了基于 UDP 的 QUIC。</li></ul></li><li>应用广泛和跨平台</li></ul><h3 id="3-2-http的缺点？"><a href="#3-2-http的缺点？" class="headerlink" title="3.2 http的缺点？"></a>3.2 http的缺点？</h3><p>http协议里有优缺点一体的双刃剑，分别是无状态、明文传输，同时还有一大缺点不安全。</p><ul><li>无状态双刃剑<ul><li>无状态的好处，因为服务器不会去记忆http的状态，所以不需要额外的资源来记录状态信息，这可以减轻服务器的压力，能够把更多的cpu和内存用于对外提供服务</li><li>无状态的坏处，既然服务器没有记忆能力，在完成关联性的操作时会非常麻烦。例如登录-&gt;添加购物车-&gt;下单-&gt;结算-&gt;支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息</li></ul></li><li>明文传输双刃剑<ul><li>明文传输是在传输信息过程中，是可方便阅读的，在浏览器控制台和抓包可以直接肉眼查看，为开发者调试工作带来了便利。</li><li>但是就是因为这样，信息都暴露出来，容易泄漏，很容易被窃取。</li></ul></li><li>不安全<ul><li>通信使用明文，不加密，信息很容易被窃取。</li><li>不验证通信方的身份，很可能遭遇伪装，比如访问假的淘宝，京东</li><li>无法证明报文的完整性，所以有可能已遭篡改，比如网页植入广告</li><li>HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL/TLS 层，使得在安全上达到了极致。</li></ul></li></ul><h3 id="3-3-http1-1的性能？"><a href="#3-3-http1-1的性能？" class="headerlink" title="3.3 http1.1的性能？"></a>3.3 http1.1的性能？</h3><p>http协议是基于TCP/IPP，并且使用了请求-应答的通信模式，所以性能的关键就在这2点里。</p><ul><li>长连接<ul><li>早期http1.0性能上很大一个问题就是每发起一个请求，都要重新建立一次TCP连接（三次握手），而且是串行请求，做了无谓的TCP连接建立和断开，增加了通信的开销</li><li>为了解决上述的TCP连接问题，http1.1提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器的负载。</li><li>持久连接的特点是，只要任意一端没有明确说明断开连接则保持TCP连接状态。</li></ul></li><li>管道网络传输<ul><li>HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。</li><li>即在同一个TCP连接里，可发起多个请求，只要第一个请求发出去了，不必等其回来，就可发第二个请求出去，可以减少整体的响应时间。</li><li>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求</li><li>但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。要是 前面的回应特别慢，后面就会有许多请求排队等着。这称为「队头堵塞」。</li></ul></li><li>队头堵塞<ul><li>请求 - 应答的模式，加剧了http的性能问题。</li><li>因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，会导致后面的请求也被阻塞，客户端一直请求不到数据，这也就是对头阻塞。</li><li>总之 HTTP/1.1 的性能一般般，后续的 HTTP/2 和 HTTP/3 就是在优化 HTTP 的性能</li></ul></li></ul><h2 id="4-http和https"><a href="#4-http和https" class="headerlink" title="4.http和https"></a>4.http和https</h2><h3 id="4-1-HTTP-与-HTTPS-有哪些区别？"><a href="#4-1-HTTP-与-HTTPS-有哪些区别？" class="headerlink" title="4.1 HTTP 与 HTTPS 有哪些区别？"></a>4.1 HTTP 与 HTTPS 有哪些区别？</h3><ul><li>http是超文本传输协议，信息是明文传输，存在安全隐患。https则解决了http不安全的问题，在TCP和HTTP网络层之间加入了SSL/TLS安全协议，使得报文能够加密传输。</li><li>http连接建立相对简单，TCP三次握手后就可进行http报文传输。而https在TCP三次握手之后，还需要进行SSL/TLS的握手过程，才可进入报文加密传输。</li><li>http的端口是80，https的端口是443</li><li>https需要向CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li></ul><h3 id="4-2-HTTPS解决了http的哪些问题？"><a href="#4-2-HTTPS解决了http的哪些问题？" class="headerlink" title="4.2 HTTPS解决了http的哪些问题？"></a>4.2 HTTPS解决了http的哪些问题？</h3><ul><li>HTTP 由于是明文传输，所以安全上存在以下三个风险：<ul><li>窃听风险，比如通信链路上可以获取通信内容，用户号容易没。</li><li>篡改风险，比如强制入垃圾广告，视觉污染，用户眼容易瞎。</li><li>冒充风险，比如冒充淘宝网站，用户钱容易没。</li></ul></li><li>HTTPS 在 HTTP 与 TCP 层之间加入了 SSL/TLS 协议。<ul><li>HTTP TCP IP MAC</li><li>HTTP SSL/TLS TCP IP MAC</li></ul></li><li>HTTP 与 HTTPS可以很好的解决了上述的风险：<ul><li>信息加密：交互信息无法被窃取</li><li>校验机制：无法篡改通信内容，篡改了就不能正常显示</li><li>身份证书：证明淘宝是真的淘宝网</li></ul></li><li>HTTPS 是如何解决上面的三个风险的？<ul><li>混合加密的方式实现信息的机密性，解决了窃听的风险</li><li>摘要算法的方式来实现完整性，它能够为数据生成独一无二的指纹，用于校验数据的完整性，解决来篡改的风险</li><li>将服务器公钥放进数字证书里，解决里冒充的风险。</li></ul></li></ul><h2 id="5-HTTP-1-1、HTTP-2、HTTP-3-演变"><a href="#5-HTTP-1-1、HTTP-2、HTTP-3-演变" class="headerlink" title="5.HTTP/1.1、HTTP/2、HTTP/3 演变"></a>5.HTTP/1.1、HTTP/2、HTTP/3 演变</h2><h3 id="5-1-HTTP-1-1-相比-HTTP-1-0-提高了什么性能？"><a href="#5-1-HTTP-1-1-相比-HTTP-1-0-提高了什么性能？" class="headerlink" title="5.1 HTTP/1.1 相比 HTTP/1.0 提高了什么性能？"></a>5.1 HTTP/1.1 相比 HTTP/1.0 提高了什么性能？</h3><ul><li>HTTP/1.1 相比 HTTP/1.0 性能上的改进：<ul><li>使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。</li><li>支持 管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间</li></ul></li><li>但 HTTP/1.1 还是有性能瓶颈：<ul><li>请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分</li><li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多</li><li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</li><li>没有请求优先级控制；</li><li>请求只能从客户端开始，服务器只能被动响应</li></ul></li></ul><h3 id="5-2-基于上面的-HTTP-1-1-的性能瓶颈，HTTP-2-做了什么优化？"><a href="#5-2-基于上面的-HTTP-1-1-的性能瓶颈，HTTP-2-做了什么优化？" class="headerlink" title="5.2 基于上面的 HTTP/1.1 的性能瓶颈，HTTP/2 做了什么优化？"></a>5.2 基于上面的 HTTP/1.1 的性能瓶颈，HTTP/2 做了什么优化？</h3><ul><li>那 HTTP/2 相比 HTTP/1.1 性能上的改进：<ul><li>头部压缩<ul><li>HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的分。</li><li>这就是所谓的 HPACK 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</li></ul></li><li>二进制格式<ul><li>HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了二进制格式。</li><li>头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧和数据帧</li><li>这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这增加了数据传输的效率。</li></ul></li><li>数据流<ul><li>HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</li><li>每个请求或回应的所有数据包，称为一个数据流（Stream）。</li><li>每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数</li><li>客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求</li></ul></li><li>多路复用<ul><li>HTTP/2 是可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。</li><li>移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，大幅度提高了连接的利用率。</li><li>举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。</li></ul></li><li>服务器推送<ul><li>HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。</li><li>举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）。</li></ul></li></ul></li></ul><h3 id="5-3-HTTP-2-有哪些缺陷？HTTP-3-做了哪些优化？"><a href="#5-3-HTTP-2-有哪些缺陷？HTTP-3-做了哪些优化？" class="headerlink" title="5.3 HTTP/2 有哪些缺陷？HTTP/3 做了哪些优化？"></a>5.3 HTTP/2 有哪些缺陷？HTTP/3 做了哪些优化？</h3><ul><li>HTTP/2 主要的问题在于：多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。</li><li>所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。<ul><li>HTTP/1.1 中的管道（ pipeline）传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了</li><li>HTTP/2 多请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。</li></ul></li><li>这都是基于 TCP 传输层的问题，所以 HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！<br><img src="/ZJY.github.io/images/http.jpg" alt="image"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookie、Session、Token、JWT的区别</title>
      <link href="/ZJY.github.io/2021/02/04/Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/ZJY.github.io/2021/02/04/Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="Cookie、Session、Token、JWT"><a href="#Cookie、Session、Token、JWT" class="headerlink" title="Cookie、Session、Token、JWT"></a>Cookie、Session、Token、JWT</h2><h3 id="什么是认证（Authentication）"><a href="#什么是认证（Authentication）" class="headerlink" title="什么是认证（Authentication）?"></a>什么是认证（Authentication）?</h3><p>认证就是验证当前用户的身份，证明你是你自己。<br>认证方式：</p><ul><li>用户名密码登录</li><li>手机号发送验证码</li><li>邮箱发送链接，点击验证登录</li></ul><h3 id="什么是授权（Authorization）"><a href="#什么是授权（Authorization）" class="headerlink" title="什么是授权（Authorization）?"></a>什么是授权（Authorization）?</h3><p>用户授予第三方应用访问用户某些资源的权限</p><ul><li>安装app时，app询问是否允许授予权限（位置，存储等）</li><li>访问微信小程序，授权登录，询问是否允许授予权限（昵称，头像，地区等信息）</li></ul><p>实现授权的方式：cookie、session、token、OAuth</p><h3 id="什么是凭证（Credentials）"><a href="#什么是凭证（Credentials）" class="headerlink" title="什么是凭证（Credentials）?"></a>什么是凭证（Credentials）?</h3><ul><li>实现认证和授权的前提</li><li>需要一种媒介（证书）来标记访问者的身份</li><li>比如居民身份证</li><li>比如bilibili，有游客模式和登录模式，游客模式可以正常浏览观看，但是若要点赞，收藏，则需要用户登录。用户登录后服务器会给该用户使用的浏览器一个令牌token，这个令牌来表明你的身份，每次浏览器发送请求时都会带上这个令牌。</li></ul><h3 id="什么是Cookie？"><a href="#什么是Cookie？" class="headerlink" title="什么是Cookie？"></a>什么是Cookie？</h3><ul><li><p>HTTP是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。</p></li><li><p>cookie存储在客户端：cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器发送请求时被携带并发送到服务器上。</p></li><li><p>cookie是不可跨域的：每个cookie都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠domain）</p></li><li><p>cookie重要的属性：</p><ul><li><p>name=value健值对，设置cookie的名称及相应的值，都必须是字符串类型。</p><pre><code>如果值为unicode字符，需要转为字符编码如果值为二进制，需要转为base64编码</code></pre></li><li><p>domain指定cookie所属域名，默认是当前域名，path指定cookie在哪个路径下生效，默认是’/‘。如果设置为/abc，则只有/abc下的路由可以访问到该cookie，如/abc/read。</p></li><li><p>maxAgeCookie：失效的时间，单位秒，如果为整数，则该cookie在maxAge秒后失效。如果为负数，则该cookie为临时cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该cookie。如果为0，表示删除该cookie。默认为-1。比expires好用。一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除。</p></li><li><p>expires：过期时间，在设置的某个时间点后该cookie就会失效。</p></li><li><p>secure：该cookie是否仅被使用安全协议传输。安全协议有HTTPS，SSL等。在网络上传输数据先将数据进行加密。默认是false，当secure为true时，cookie在http中是无效的，在https才有效。</p></li><li><p>httpOnly：如果给某个cookie设置来httpOnly属性，则无法通过js脚本读取到该cookie的信息，但是还是能够通过Application中手动修改cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全</p></li></ul></li></ul><h3 id="什么是Session？"><a href="#什么是Session？" class="headerlink" title="什么是Session？"></a>什么是Session？</h3><ul><li><p>session是另一种记录服务器和客户端会话状态的机制</p></li><li><p>session是基于cookie实现的，session存储在服务端，sessionId会被存储在客户端的cookie中</p></li><li><p>session认证流程：</p><ul><li><p>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的session</p></li><li><p>请求返回将此session的唯一标识sessionId返回给浏览器</p></li><li><p>浏览器接收到服务器返回的sessionId后会将该信息存储到cookie中，同时cookie将记录此sessionId属于哪个域名</p></li><li><p>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在cookie信息，如果存在自动将cookie信息也发送给服务器，服务端会从cookie中获取sessionId，再根据sessionId查找对于session信息，如果没有找到说明用户没有登录或者登录失效，如果找到session证明用户已经登录可执行后续操作。</p></li></ul></li><li><p>sessionId是连接cookie和session的一道桥梁，大部分系统也是根据此原理来验证用户登录状态</p></li></ul><h3 id="cookie和session的区别？"><a href="#cookie和session的区别？" class="headerlink" title="cookie和session的区别？"></a>cookie和session的区别？</h3><ul><li>安全性：session比cookie安全，session是存储在服务端的，cookie是存储在客户端的</li><li>存取值的类型不同： cookie只支持字符串数据，想要设置其他类型的数据，需要将其转换为字符串，session可以存任意数据类型。</li><li>有效期不同：cookie可设置为长时间保持，比如我们经常使用的默认登录功能。session一般失效时间较短，客户端关闭或者session超时都会失效。</li><li>存储大小不同：单个cookie存储数据不能超过4k，session可存储数据远高于cookie，但是当访问量过多，会占用过多的服务器资源。</li></ul><h3 id="什么是token（令牌）？"><a href="#什么是token（令牌）？" class="headerlink" title="什么是token（令牌）？"></a>什么是token（令牌）？</h3><ul><li><p>Access Token</p><ul><li><p>访问资源接口（API）时所需要的资源凭证</p></li><li><p>简单token的组成： uid(用户唯一身份标识)、time(当前时间戳)、sign（签名，token的前几位以哈希算法压缩为一定长度的十六进制字符串）</p></li><li><p>特点： 服务端无状态化、可扩展行好、支持移动端设备、安全、支持跨程序调用</p></li><li><p>token的身份验证流程：</p><ul><li>浏览器发送用户名密码等信息给服务器，服务器将登录凭证做成数字签名，加密之后得到字符串作为token</li><li>服务器将token返回给浏览器，拿到token后，将token保存到本地</li><li>请求时携带token给服务端</li><li>服务器拿到token串，做解密和签名认证，判断其有效性，将数据返回给浏览器</li></ul></li><li><p>每一次请求都需要携带token，需要把token放到http的header里</p></li><li><p>基于token的用户认证是一种服务端无状态的方式，服务端不用存放token数据。用解析token的计算时间来换取session的存储空间，从而减轻服务器的压力。</p></li><li><p>token完全由应用管理，所以它可以避开同源策略</p></li></ul></li><li><p>Refresh Token</p><ul><li>refresh token是一种专用于刷新access token的token。如果没有refresh token也可以刷新access token，但每次刷新都需要用户输入登录名和密码，会很麻烦。有了refresh token可以减少这个麻烦。客户端直接用 refresh token 去更新 access token，无需用户进行额外的操作。</li><li>Access Token 的有效期比较短，当 Acesss Token 由于过期而失效时，使用 Refresh Token 就可以获取到新的 Token，如果 Refresh Token 也失效了，用户就只能重新登录了。</li><li>Refresh Token 及过期时间是存储在服务器的数据库中，只有在申请新的 Acesss Token 时才会验证，不会对业务接口响应时间造成影响，也不需要向 Session 一样一直保持在内存中以应对大量的请求。</li></ul></li></ul><h3 id="token和session的区别？"><a href="#token和session的区别？" class="headerlink" title="token和session的区别？"></a>token和session的区别？</h3><ul><li><p>session是一种记录客户端和服务器会话状态的机制，使服务端有状态化，可以记录会话信息。而token是令牌，访问资源接口（API）时所需要的资源凭证。token使服务端无状态化，不会存储会话信息。</p></li><li><p>session和token并不矛盾，作为身份认证token安全性比session好，因为每一个请求都有签名还能防止监听以及重放攻击，而session就必须依赖链路层来保障通讯安全了。如果你需要实现现有状态的会话，仍然可以增加session来在服务端保存一些状态。</p></li><li><p>所谓session认证只是简单的把user信息存储到session里，因为sessionId的不可预测性，暂且认为是安全的。而token，如果指的是OAuth token或类似机制的话，提供的是认证和授权。认证是真的用户，授权是针对app。</p></li></ul><h3 id="什么是JWT？"><a href="#什么是JWT？" class="headerlink" title="什么是JWT？"></a>什么是JWT？</h3><ul><li><p>JSON Web Token（简称JWT）是目前最流行的跨域认证解决方案。</p></li><li><p>是一种认证授权机制</p></li><li><p>JWT是为了在网络应用环境间传递声明而执行的一种基于JSON的开发标准。jwt的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。</p></li><li><p>可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。</p></li></ul><h3 id="JWT的原理"><a href="#JWT的原理" class="headerlink" title="JWT的原理"></a>JWT的原理</h3><ul><li>JWT认证流程：<ul><li>用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个JWT</li><li>客户端将token保存到本地（通常使用localStorage，也可以使用cookie）</li><li>当用户希望访问一个受保护的路由或者资源的时候，需要请求头的Authorization字段中使用bearer模式添加JWT，<pre><code>Authorization: bearer `&lt;token&gt;`</code></pre></li><li>服务端的保护路由将会检查请求头Authorization中的JWT信息，如果合法，则允许用户的行为。</li><li>因为JWT是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要。</li><li>因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</li><li>因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制</li></ul></li></ul><h3 id="JWT的使用方式"><a href="#JWT的使用方式" class="headerlink" title="JWT的使用方式"></a>JWT的使用方式</h3><p>客户端收到服务端返回的jwt，可以存储到cookie里面，也可以储存到localStorage里面。</p><ul><li>方式一<ul><li>当用户希望访问一个受保护的路由或者资源的时候，可以把它放在cookie里面自动发送，但是这样不能跨域，所以更好的做法是放在http请求头信息的Authorization字段里，使用bearer模式添加jwt。<pre><code>get: /user/pagehost: &lt;http://api.example.com&gt;Authorization: Bearer`&lt;token&gt;`</code></pre></li><li>用户的状态不会保存在服务端，这是一种无状态的认证机制。</li><li>服务端的保护路由会检查请求头Authorization中的JWT信息，如果合法，则允许用户的行为</li><li>由于JWT是自包含的，因此减少了需要查询数据库的需要</li><li>JWT 的这些特性使得我们可以完全依赖其无状态的特性提供数据 API 服务，甚至是创建一个下载流服务</li><li>因为JWT并不使用cookie，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</li></ul></li><li>方式二<ul><li>跨域的时候，可以把 JWT 放在 POST 请求的数据体里。</li></ul></li><li>方式三<ul><li>通过 URL 传输：<a href="http://www.example.com/user?token=xxx">http://www.example.com/user?token=xxx</a></li></ul></li></ul><h3 id="token和JWT的区别？"><a href="#token和JWT的区别？" class="headerlink" title="token和JWT的区别？"></a>token和JWT的区别？</h3><ul><li>相同：<ul><li>都是访问资源的令牌</li><li>都可以记录用户的信息</li><li>都是使服务端无状态化</li><li>都是只有验证成功后，客户端才能访问服务端上受保护的资源</li></ul></li><li>区别：<ul><li>token：服务端验证客户端发送过来的token时，还需要查询数据库获取用户信息，然后验证token是否有效</li><li>JWT：将token和payload加密后存储于客户端，服务端只需要使用密钥进行校验（校验也是JWT自己实现的）即可，不需要查询或者减少查询数据库，因为JWT自包含了用户信息和加密的数据。</li></ul></li></ul><h3 id="常见的前后的鉴权方式"><a href="#常见的前后的鉴权方式" class="headerlink" title="常见的前后的鉴权方式"></a>常见的前后的鉴权方式</h3><ul><li>session/cookie</li><li>token验证（包括JWT，SSO）</li><li>OAuth2.0（开发授权）</li></ul><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li><p>使用cookie时需要考虑的问题</p><ul><li>存储在客户端容易被客户端篡改，使用前需要验证合法性</li><li>不能存户敏感数据</li><li>使用httpOnly在一定程度上可以提高安全性</li><li>尽量减少cookie的体积，能存储的数据不能超过4k</li><li>设置正确的domain和path，减少数据传输</li><li>cookie无法跨域</li><li>一个浏览器针对一个网站最多存20个cookie，浏览器一般只允许存放300个cookie</li><li>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token</li></ul></li><li><p>使用session时需要考虑的问题</p><ul><li>将 session 存储在服务器里面，当用户同时在线量比较多时，这些 session 会占据较多的内存，需要在服务端定期的去清理过期的 session</li><li>当网站采用集群部署的时候，会遇到多台 web 服务器之间如何做 session 共享的问题。因为 session 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 session 的服务器，那么该服务器就无法拿到之前已经放入到 session 中的登录凭证之类的信息了</li><li>当多个应用要共享 session 时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好 cookie 跨域的处理。</li><li>sessionId 是存储在 cookie 中的，假如浏览器禁止 cookie 或不支持 cookie 怎么办？ 一般会把 sessionId 跟在 url 参数后面即重写 url，所以 session 不一定非得需要靠 cookie 实现</li></ul></li><li><p>使用 token 时需要考虑的问题</p><ul><li>如果你认为用数据库来存储 token 会导致查询时间太长，可以选择放在内存当中。比如 redis 很适合你对 token 查询的需求</li><li>token 完全由应用管理，所以它可以避开同源策略</li><li>token 可以避免 CSRF 攻击(因为不需要 cookie 了)</li></ul></li><li><p>使用 JWT 时需要考虑的问题</p><ul><li>因为 JWT 并不依赖 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</li><li>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</li><li>JWT 不加密的情况下，不能将秘密数据写入 JWT。</li><li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</li><li>JWT 最大的优势是服务器不再需要存储 Session，使得服务器认证鉴权业务可以方便扩展。但这也是 JWT 最大的缺点：由于服务器不需要存储 Session 状态，因此使用过程中无法废弃某个 Token 或者更改 Token 的权限。也就是说一旦 JWT 签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。</li><li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证</li><li>JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态</li><li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输</li></ul></li></ul><h3 id="只要关闭浏览器-，session-真的就消失了？"><a href="#只要关闭浏览器-，session-真的就消失了？" class="headerlink" title="只要关闭浏览器 ，session 真的就消失了？"></a>只要关闭浏览器 ，session 真的就消失了？</h3><p>不对。对 session 来说，除非程序通知服务器删除一个 session，否则服务器会一直保留，程序一般都是在用户做 log off 的时候发个指令去删除 session。然而浏览器从来不会主动在关闭之前通知服务器它将要关闭，因此服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分 session 机制都使用会话 cookie 来保存 session id，而关闭浏览器后这个 session id 就消失了，再次连接服务器时也就无法找到原来的 session。如果服务器设置的 cookie 被保存在硬盘上，或者使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 session id 发送给服务器，则再次打开浏览器仍然能够打开原来的 session。恰恰是由于关闭浏览器不会导致 session 被删除，迫使服务器为 session 设置了一个失效时间，当距离客户端上一次使用 session 的时间超过这个失效时间时，服务器就认为客户端已经停止了活动，才会把 session 删除以节省存储空间。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器是如何运作的</title>
      <link href="/ZJY.github.io/2021/01/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84/"/>
      <url>/ZJY.github.io/2021/01/27/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器是如何运作的"><a href="#浏览器是如何运作的" class="headerlink" title="浏览器是如何运作的"></a>浏览器是如何运作的</h2><h3 id="1-浏览器发展史"><a href="#1-浏览器发展史" class="headerlink" title="1.浏览器发展史"></a>1.浏览器发展史</h3><ul><li>1991年Berners Lee建立了第一代网络浏览器WorldWideWeb,只支持显示文本图片</li><li>1993年Mosaic问世，同时支持显示文本和图像</li><li>1994年网景浏览器发布 ，只能显示简单的静态html，没有js，css。同年出现Opera。</li><li>1995年微软发布IE1.0，IE2.0，自此第一次浏览器大战正式打响</li><li>1996年微软发布的IE3.0和window系统集成一起，网景份额此时占86%</li><li>1998年网景开源了firefox火狐来迎击IE</li><li>1999年IE市场份额占据99%</li><li>2003年苹果发布safari浏览器，被包含在所有苹果操作系统中</li><li>2004年网景发布来firefox1.0版本，拉开第二次浏览器大战</li><li>2005年苹果开源了safari浏览器内核webkit</li><li>2008年谷歌以苹果开源项目webkit 创建了新的项目chromium， 在该项目的基础上谷歌发布了自己的浏览器产品Chrome，</li><li>2015年微软放弃了IE，推出了以webkit内核的Edge浏览器</li><li>2020年chrome已占据60%多的市场份额</li></ul><h3 id="2-浏览器结构图"><a href="#2-浏览器结构图" class="headerlink" title="2.浏览器结构图"></a>2.浏览器结构图</h3><ul><li>用户界面-用户界面用来展示除标签页窗口以外的其他用户界面内容</li><li>浏览器引擎-</li><li>渲染引擎-渲染引擎负责渲染用户请求的页面内容</li></ul><p>浏览器是运行在操作系统上的一个应用程序 ，每个应用程序必须至少启动一个进程来执行其功能，每个程序往往需要运行很多任务，进程就会创建很多线程去帮助它执行一些小的任务。</p><p>当我们启动一个应用程序时，就会创建一个进程来执行任务代码，同时为该进程分配内存空间。该应用程序的状态都保存在内存空间里，当应用关闭时，该内存就会被回收。<br>进程可以启动更多的进程来执行任务，由于每个进程分配的内存空间是独立的，如果两个进程间需要传递数据，则需要通过进程间通信管道IPC来传递。很多引用程序都是多进程的结构，避免某一个进程卡死，由于进程间相互独立，这样不会影响整个应用程序。<br>进程可以将任务分为更多个细小的任务，然后通过创建多个线程并行执行不同的任务，同一进程下的线程之间是可以通信共享数据的。</p><h3 id="3-浏览器是一个多进程的结构"><a href="#3-浏览器是一个多进程的结构" class="headerlink" title="3.浏览器是一个多进程的结构"></a>3.浏览器是一个多进程的结构</h3><ul><li>浏览器进程<br>  浏览器进程负责控制除标签页外的用户界面，包括地址栏，书签，前进，后退按钮以及负责与浏览器其他进程协调工作</li><li>缓存进程</li><li>网络进程<br>  负责发起接受网络请求</li><li>GPU进程<br>  负责整个浏览器界面的渲染</li><li>插件进程<br>  负责网站使用的所有插件，例如flash,插件并不是指插件安装的扩展</li><li>渲染器进程<br>  用来控制显示tab标签内的所有内容<br>  浏览器默认情况下会为每个标签页都创建一个进程（和启动浏览器选择的进程模型有关）</li></ul><h3 id="4-当你在浏览器输入地址时，浏览器内部会发生什么？"><a href="#4-当你在浏览器输入地址时，浏览器内部会发生什么？" class="headerlink" title="4.当你在浏览器输入地址时，浏览器内部会发生什么？"></a>4.当你在浏览器输入地址时，浏览器内部会发生什么？</h3><p>当你在浏览器输入内容时，浏览器进程的UI进程会捕捉你的输入内容，如果访问的是网址，则UI进程会启动一个网络线程来请求DNS进行域名解析，接着开始连接服务器来获取数据。如果输入的不是网址，而是关键词，浏览器就会使用默认配置的搜索引擎来查询。</p><p>当网络线程获取到数据后会通过SafeBrowsing来检查站点是否是恶意站点，如果是，会提示个警告页面阻止你继续访问，也可以强行继续访问。SafeBrowsing是谷歌内部的一套站点安全系统，通过检测该站点的数据判断是否安全。</p><p>当返回数据并安全校验通过时，网络线程就会通知UI线程（浏览器进程）准备好了，然后UI线程就会创建一个渲染器进程来渲染页面，浏览器进程就会通过进程通信管道IPC来把数据传递给渲染器进程，正式进入渲染流程。渲染器接受到的数据也就是html，渲染器的核心任务就是把html,js,css,image等资源渲染成用户可以交互的web页面。</p><p>渲染器进程的主线程将html进行解析，构造DOM数据结构。<br>html首先经过tokeniser标记化，通过词法分析将输入的html内容解析成多个标记，根据识别后的标记进行DOM树构造,在DOM树构造偶成中会创建document对象，然后以document为根节点的DOM树不断进行修改向其中添加各种元素。</p><pre><code>html-&gt;tokeniser-&gt;tree construction-&gt;DOMdocument-&gt;body-&gt;p-&gt;text</code></pre><p>html的代码中往往会引入一些额外的资源，比如图片、css、js脚本等，图片和css资源需要经过网络下载或者从缓存中加载，这些资源不回阻塞html的解析，因为它们不会影响dom的生成。但是html解析遇到script标签，就会停止html的解析流程，转而去加载解析并且执行js，可以使用async或defer来异步加载执行js。在html解析完成后会获得一个DOM 树，但是还不知道dom树上每个节点长什么样子。</p><p>主线程需要解析css来确定每个dom节点的计算样式。</p><p>在知道DOM节点和每个节点的样式后，接下来需要直到每个节点放置的位置，也就是节点的坐标以及该节点需要占据的区域，这个阶段称为layout布局。</p><p>主线程通过遍历dom和计算好的样式来生成layout tree，layout tree上的每个节点都记录来x,y坐标以及边框尺寸。layout tree是和最后显示的节点一一对应的。</p><p>现在知道节点的形状大小，还需要知道以什么样的顺序来绘制，z-index属性会影响节点绘制的层级关系。按照dom层级顺序绘制节点是不对的，为了在屏幕上展示正确的层级，主线程遍历Layout tree 创建了一个绘制记录表（paint record）,该表记录了绘制的顺序，这个阶段被称为绘制（paint）。</p><p>现在知道了节点绘制的顺序，到了把这些信息转化称像素点显示在屏幕上的时候了。这种行为被称为栅格化。<br>chrome早期栅格化只栅格用户可视区域界面，随着滚动再继续栅格，会带来延迟。现在使用另一种更复杂的栅格化，叫做合成（Composting）,合成是一种将页面的各个部分分为多个图层，分别对其栅格化，并在合成器线程中单独进行合成页面的技术。<br>简单来说就是页面所有元素按照某种规则进行分图层，然后把图层都栅格化好了，然后只需把可视区域的内容组合成一帧展示给用户即可。</p><p>主线程遍历layout tree生成layer tree(图层),当layer tree生成完毕和绘制顺序确定后，主线程将这些信息传递给合成器线程，<br>合成器线程将每个图层栅格化，由于一层可能像页面的整个长度一样大，因此合成器线程将他们切分为许多图块，然后将每个图块发送给栅格化线程（Raster thread）。</p><p>栅格化线程栅格每个图块，并将它们存储在GPU内存中，当栅格化完成后，合成器线程将收集称为“draw quads”的图块信息，这些信息记录了图块在内存中的位置和在页面的哪个位置绘制图块的信息。根据这些信息合成器线程合成生成了一个合成器帧（Compositor Frame）,然后这个合成器帧通过进程间通信管道IPC传递给浏览器进程，接着浏览器进程将合成器帧传送到GPU，然后GPU渲染展示到屏幕上。</p><p>页面上终于可以看到内容，当页面发生变化，比如滚动页面，则会生成一个新的合成器帧，新的帧再传送到GPU，再渲染到屏幕上。</p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h3><ul><li>浏览器进程中的网络线程请求获取到html数据后，通过IPC将数据传给渲染器进程的主线程</li><li>主线程将html解析构造DOM树</li><li>然后进行样式计算</li><li>根据DOM树和生成好的样式成功layout tree</li><li>通过遍历layout tree生成绘制顺序表paint</li><li>接着遍历layout tree生成layer tree(图层)</li><li>然后主线程将layer tree和绘制顺序信息一起传递给合成器线程</li><li>合成器线程按照规则进行分图层，并把更小的tiles（图块）传递给栅格化线程进程栅格化</li><li>栅格化完成后，合成器线程将收到栅格化线程传递过来的“draw quads”的图块信息</li><li>根据这些信息合成器线程合成生成了一个合成器帧（Compositor Frame）</li><li>然后这个合成器帧通过进程间通信管道IPC传递给浏览器进程</li><li>浏览器进程再传送到GPU渲染，然后就展示到屏幕上了。</li></ul><p>主线程-&gt;DOM-&gt;style-&gt;layout tree-&gt;paint-&gt;layer（这些在主线程执行）<br>-&gt;合成器线程-&gt;tiles（图块）<br>-&gt;栅格化线程-&gt;“draw quads”的图块信息-&gt;传递给合成器线程-&gt;合成器帧-&gt;浏览器进程-&gt;GPU-&gt;渲染屏幕</p><p>当我们改变元素的尺寸位置时，会重新计算样式,layout,paint以及后面所有流程，这种行为称为重排reflow</p><p>当我们改变元素颜色属性时，不会出发layout layer 布局，但会触发样式计算，这种行为称为重绘repaint</p><p>重排和重绘都会占用主线程，js也在主线程运行，如果他们都在主线程运行，就会出现抢占执行时间的问题，如果写了一个不断导致重排重绘的动画，浏览器则需要在每一帧都运行样式计算布局和绘制的操作，页面以每秒60帧频率刷新时才不会让用户感觉到页面卡顿，绘制动画时，如果js运行时间过长，没有及时归还主线程，就会导致页面绘制卡顿。</p><p>可以通过requestAnimationFrame()和transform解决这个问题。<br>合成器线程和栅格化线程不运行在主线程，不会受到主线程中js执行的影响，css中transform动画不需要样式计算布局绘制，不运行在主线程。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>互联网是如何运行的</title>
      <link href="/ZJY.github.io/2021/01/26/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84/"/>
      <url>/ZJY.github.io/2021/01/26/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h2 id="互联网是如何运行的"><a href="#互联网是如何运行的" class="headerlink" title="互联网是如何运行的"></a>互联网是如何运行的</h2><p>当你的电脑联入互联网之后，会得到一个编号地址，这个地址称为Internet Protocal Address,也就是IP地址。<br>bilibili的服务器也接入互联网，它也将分配一个IP地址，常说的访问某某网站，就是访问这个网站的服务器。<br>如果你的电脑想通过访问index.html来获取b站首页内容， 此时称电脑为客户端，bilibili为服务端，这种形式就是客户端服务端模型。</p><p>客户端更贴近用户 ，是面向用户的应用程序，例如web浏览器，电子邮件客户端，手机app。<br>服务端是在远程计算机上运行的引用程序，客户端可以在需要时，通过互联网与服务端进行通信。</p><p>你的电脑发送给bilibili服务器消息，要获取index.html的内容，消息将会被转化为电子信号，通过电缆发送给bilibili服务器，在服务器端又将电子信号转换为计算机可以使用的文本数据。<br>以上通过Tcp/Ip协议族来实现。</p><p>协议：协议是一组规则，用于指定计算机应如何通过网络来互相通信。</p><h3 id="1-Tcp-Ip协议族共分为4层："><a href="#1-Tcp-Ip协议族共分为4层：" class="headerlink" title="1.Tcp/Ip协议族共分为4层："></a>1.Tcp/Ip协议族共分为4层：</h3><ul><li>应用层：提供特定于应用程序的协议（HTTP，FTP，IMAP）</li><li>Tcp传输控制层：发送数据包到计算机上使用特定端口号的应用程序</li><li>IP网络层：使用IP地址将数据包发送到特定的计算机</li><li>链路层：将二进制数据包与网络信号相互转换</li></ul><p>网络协议通过分层来明确每一层的职责，通过定义明确的接口来协同工作</p><p>1.在当前的例子中，使用应用层的HTTP协议请求获取html文本，这时需要发送一个请求消息，消息在发送前会被分解为许多片段，称为数据包。</p><p>2.通过应用层进入传输控制层后，每个数据包都会被分配一个端口号，端口号用来确定计算机的哪一个应用程序要接受并使用该数据包。<br>进入IP网络层后，每个数据包将会赋予目标计算机的IP地址。</p><p>3.有了IP地址和端口号之后，链路层会将数据包的文本数据转换为电子信号。然后通过电缆传输，在电缆中的另一端的路由器检查每个数据包中的地址，并确定发送到何处，最终数据包到达服务器。数据包到达服务器后，从Tcp/Ip协议族的底部数据链路层开始向上运行， 当数据包向上通过协议族时，客户端添加的所有路由数据，例如Ip地址和端口号都将从数据包剥离出来。当数据到达栈顶时，数据包已恢复成最初始的形式。</p><p>4.通过端口号可以将数据传递给当前服务器监听该端口的应用程序。应用程序根据当前请求数据作出反应。<br>比如现在想获取index.html，服务器会将路径index.html的数据通过刚才方式返回给你的电脑。也就是客户端，这样就可以看到b站首页内容。 这里完成了客户端与服务器在互联网的一次数据交互。</p><ul><li>应用层： 数据包</li><li>传输控制层： 数据  源端口  目标端口</li><li>网络层： 数据  源端口  目标端口  源IP 目标IP</li><li>数据链路层： 数据  源端口  目标端口  源IP 目标IP</li></ul><h3 id="Tcp是一种面向连接的可靠字节流服务。"><a href="#Tcp是一种面向连接的可靠字节流服务。" class="headerlink" title="Tcp是一种面向连接的可靠字节流服务。"></a>Tcp是一种面向连接的可靠字节流服务。</h3><p>Tcp必须经过3次握手建立连接后才可以交换数据，每个收到的数据包都会向发送方发送ack确认，以保证发送成功</p><h3 id="IP是-不可靠的无连接协议"><a href="#IP是-不可靠的无连接协议" class="headerlink" title="IP是 不可靠的无连接协议"></a>IP是 不可靠的无连接协议</h3><p>它并不关心数据包是否到达目的地，也不关心连接和端口号，它的工作是发送数据包并将其路由到目标计算机，其中每个数据包都是独立的不相互依赖的，所以有可能乱序到达目的地。</p><p>如何保证数据包到达和顺序正确？交给TCP。<br>当数据包过大时，在IP网络层会进行分包，由于每个数据包在物理链路层走的物理链路不同，传输速度不同，导致数据包没有按顺序到达目的地。但是TCP会根据数据包携带的序列号来进行排序重组，并且发送方在特定时间内没有接收到接收方发来的ack确认时，则发送方会重新发送该数据包。</p><p>IP是一种网络协议，IP地址是一串数字。</p><h3 id="IP有两种协议："><a href="#IP有两种协议：" class="headerlink" title="IP有两种协议："></a>IP有两种协议：</h3><ul><li>IPv4 Internet Protocol version4<br>  采用32位地址，即4字节，因此地址空间只有2<sup>32</sup>个，约40亿个，专用网络1800万个，多播地址2.7亿个， </li><li>IPv6 Internat Protocol version6<br>  采用128位地址，2<sup>128</sup>个</li></ul><h3 id="调制解调器（也叫猫）和路由器的区别："><a href="#调制解调器（也叫猫）和路由器的区别：" class="headerlink" title="调制解调器（也叫猫）和路由器的区别："></a>调制解调器（也叫猫）和路由器的区别：</h3><ul><li>猫用于网络间不同介质网络信号转接，比如把ADSL，光纤，有线通等的网络信号转成标准的电脑网络信号。</li><li>路由器用于网络信号的再分配，简单地说就是让一根网线可以连接更多的电脑。</li><li>家里有宽带就必须有猫，有多台电脑上网就必须有路由器，假如电脑很多，超过路由器的接口就需要交换机扩展接口。</li></ul><p>1.电脑通过调制解调器modem，也就是常说的“猫”，将计算机的数字信号翻译成可沿普通电话线传输的模拟信号后，在公共电话网络进行传输，公共电话网络通过连接Internet Service Provider，互联网服务提供商ISP，来接入互联网。生活中常见的电信，移动，联通都是ISP。</p><p>2.数据包经过电话网络和ISP后，它们将路由到ISP的主干网络。互联网骨干网由许多相互连接的大型网络组成，这些大型网络被称为网络服务提供商，简称NSP。NSP是为ISP提供网络主干服务的公司。ISP可以从NSP那里批量购入带宽，为客户提供网络接入服务。<br>NSP网络通过网络访问点NAP相连，来交换数据包流量，每个NSP都必须连接到至少三个网络访问点NAP。</p><p>3.计算机有个特殊的计算器-路由器，路由器中有个路由表，记录来其子网络的所有IP地址。当数据包到达路由器，路由器检查路由表上是否有目的地的IP地址，如果有则直接发送给那个网络。否则就向上层发送数据，在更高的层级去寻找拥有该iP的路由器。如果依然没有找到，继续向上路由，直到到达NSP主干网为止，连接到NSP主干网的路由器拥有最大的路由表，通过这张表可以将数据包路由到正确的骨干网。然后开始向下传播，直到找到目的地为止。你的电脑就是这样访问bilibili服务器的。</p><p>4.通过IP地址来访问bilibili服务器，ip地址可能会改变，通过域名来访问可以解决Ip地址改变问题。<br>浏览器通过DNS来知道哪个域名访问哪个IP地址。</p><p>Domian names service,简称DNS，是一个分布式数据库，记录来域名和其IP地址的对应关系。<br>在浏览器输入网址时，浏览器首先连接DNS服务器，获取到该域名的IP地址后，浏览器在连接访问该IP的服务器。<br>有了DNS后，之后IP有了变化，重新绑定下域名和新IP地址就可以了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试基础</title>
      <link href="/ZJY.github.io/2021/01/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
      <url>/ZJY.github.io/2021/01/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="一-HTML"><a href="#一-HTML" class="headerlink" title="一.HTML"></a>一.HTML</h2><h3 id="1-html语义化"><a href="#1-html语义化" class="headerlink" title="1.html语义化"></a>1.html语义化</h3><ul><li><p>使页面内容结构化，即使丢失样式也能使页面呈现清晰的结构</p></li><li><p>有利于SEO，搜索引擎根据标签确定上下文和关键字的权重有利于开发和维护</p></li><li><p>语义化更具有可读性，代码更好维护</p></li><li><p>方便其他设备解析，如配合盲人阅读器渲染页面易于用户阅读，<br>如：</p><p>  header  定义头部内容<br>  nav 定义导航区域<br>  main 定义主要文档内 容<br>  article 表示文章、博客等内容<br>  aside   侧边内容<br>  footer  尾部</p></li></ul><p>div、article、section</p><p>div、article、section是语义从无到有，逐渐增强的。<br>div无任何语义，仅仅用作样式化或脚本的标签。<br>对于一段主题性的内容，则适用于section元素。<br>对于可脱离上下文，作为一段完整独立内容的，适用于article。</p><ul><li><p>article元素代表文档、页面或应用程序中独立的、完整的、可以独自被外部引用的内容。它可以是一篇博客或报刊中的文章、一篇论坛帖子、一段用户评论或独立的插件，或其他任何独立的内容。除了内容部分，一个article元素通常有它自己的标题（一般放在一个header元素里面），有时还有自己的脚注</p></li><li><p>section元素的作用是对页面上的内容进行分块，或者说对文章进行分段；一个section元素通常由内容及其标题组成，通常不推荐为那些没有标题的内容使用section元素</p></li></ul><h3 id="2-HTML5新标签"><a href="#2-HTML5新标签" class="headerlink" title="2.HTML5新标签"></a>2.HTML5新标签</h3><pre><code>&lt;header&gt; &lt;footer&gt; &lt;nav&gt; &lt;aside&gt; &lt;aduio&gt; &lt;video&gt; &lt;canvas&gt;</code></pre><h3 id="3-html5语义化"><a href="#3-html5语义化" class="headerlink" title="3.html5语义化"></a>3.html5语义化</h3><p>表示选择合适的标签（语义化标签）便于开发者阅读和写出更优雅的代码</p><h3 id="4-html5新特性"><a href="#4-html5新特性" class="headerlink" title="4.html5新特性"></a>4.html5新特性</h3><p>HTML5新特性有哪些？</p><pre><code>语义化标签音视频处理canvas / webGLhistory APIrequestAnimationFrame地理位置webSocket</code></pre><h3 id="5-对WEB标准和W3C的理解认识"><a href="#5-对WEB标准和W3C的理解认识" class="headerlink" title="5.对WEB标准和W3C的理解认识"></a>5.对WEB标准和W3C的理解认识</h3><p>个人理解：</p><pre><code>html - 表示人的光身体 ---结构css - 表示给人穿的衣服 ---表现js - 表示人的行为，走路等 ---行为</code></pre><p>web简单来说可以分为结构、表现和行为。</p><ul><li>其中结构主要是由HTML标签组成。</li><li>表现是指css样式表，可用通过css使页面标签更具美感。</li><li>行为是指用户和页面有一定的交互，同时结构和表现也会发生变化，主要由js组成</li></ul><p>web标准一般是将该三部分独立分开，使其更具有模块化。但一般产生行为时，就会有结构或者表现的变化，也使这三者的界限并不那么清晰。</p><p>W3C对web标准提出了规范化的要求，也就是在实际编程中的<br>一些代码规范：</p><pre><code>1.对于结构要求（标签规范可以提高搜索引擎对页面的抓取率，对seo很有帮助）：    标签要小写    标签要闭合    标签不能随意嵌套2.对于css和js来说：    使用外链css和js，使结构、表现、行为三者分离。    提高页面渲染速度，提高用户体验    尽量少使用行内样式，使结构和表现分离，标签的id和class要见文知意，标签越少，加载越快，用户体验越高    不需要变动页面内容，便可提供打印版本而不需要复制内容，提高网站易用性。</code></pre><h3 id="6-什么是DOCTYPE及作用"><a href="#6-什么是DOCTYPE及作用" class="headerlink" title="6.什么是DOCTYPE及作用"></a>6.什么是DOCTYPE及作用</h3><p>DTD（document type definition，文档类型定义）是一系列的语法规则，用来定义XML或（X）HTML的文件类型。浏览器会使用它来判断文档类型，决定使用何种协议来解析以及切换浏览器模式。（DTD告诉浏览器我是什么文档类型，浏览器会根据这个来判断用什么引擎来解析和渲染他们）</p><p>DOCTYPE是用来声明文档类型和DTD规范的，一个主要的用途便是文件的合法性验证。如果文件代码不合法，那么浏览器解析时会出一些错误。（DOCTYPE告诉浏览器当前是哪个文档类型）</p><!DOCTYPE html><p>作用：<br>告诉浏览器用哪种HTML版本的规范来解析HTML文档</p><h2 id="二-CSS"><a href="#二-CSS" class="headerlink" title="二.CSS"></a>二.CSS</h2><h3 id="1-盒模型"><a href="#1-盒模型" class="headerlink" title="1.盒模型"></a>1.盒模型</h3><ul><li>组成：border+padding+content+margin</li><li>标准盒模型：width: content  box-sizing: content-box</li><li>怪异盒模型/IE：width: content+padding+border  box-sizing:border-box</li></ul><h3 id="2-rem和em的区别"><a href="#2-rem和em的区别" class="headerlink" title="2.rem和em的区别"></a>2.rem和em的区别</h3><p>rem是根据根元素的font-size变化，em是根据父元素的font-size变化</p><ul><li>rem：相对于根元素html的font-size，假如html为font-size：12px，那么，在其当中的div设置为font-size：2rem,就是当中的div为24px</li><li>em：相对于当前对象内文本的字体大小计算，假如某个p元素为font-size:12px,在它内部有个span标签继承p元素字体大小，设置font-size：2em,那么，这时候的span字体大小为：12*2=24px</li></ul><h3 id="3-常见单位"><a href="#3-常见单位" class="headerlink" title="3.常见单位"></a>3.常见单位</h3><ol><li>px：绝对单位，页面按精确像素展示</li><li>em：相对单位，基准点为当前对象内文本的字体大小，整个页面内1em不是一个固定的值</li><li>rem：相对单位，可理解为”root em”, 相对根节点html的字体大小来计算，CSS3新加属性，chrome/firefox/IE9+支持</li><li>vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%</li><li>vh：viewpoint height，视窗高度，1vh等于视窗高度的1%</li><li>vmin：vw和vh中较小的那个</li><li>vmax：vw和vh中较大的那个</li><li>%:百分比</li></ol><h3 id="4-移动端视口配置"><a href="#4-移动端视口配置" class="headerlink" title="4.移动端视口配置"></a>4.移动端视口配置</h3><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot;&gt;initial-scale：初始的缩放比例minimum-scale：允许用户缩放到的最小比例maximum-scale：允许用户缩放到的最大比例user-scalable：用户是否可以手动缩放</code></pre><h3 id="5-渐进增强与优雅降级的理解及区别"><a href="#5-渐进增强与优雅降级的理解及区别" class="headerlink" title="5.渐进增强与优雅降级的理解及区别"></a>5.渐进增强与优雅降级的理解及区别</h3><ul><li><p>渐进增强（Progressive Enhancement）：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。</p></li><li><p>优雅降级（Graceful Degradation）：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行hack 使其可以在低版本浏览器上正常浏览。</p></li></ul><p>两者区别？</p><p>1、广义：<br>其实要定义一个基准线，在此之上的增强叫做渐进增强，在此之下的兼容叫优雅降级<br>2、狭义：<br>渐进增强一般说的是使用CSS3技术，在不影响老浏览器的正常显示与使用情形下来增强体验，而优雅降级则是体现html标签的语义，以便在js/css的加载失败/被禁用时，也不影响用户的相应功能</p><h3 id="6-cookie、sessionStorage、localStorage区别"><a href="#6-cookie、sessionStorage、localStorage区别" class="headerlink" title="6.cookie、sessionStorage、localStorage区别"></a>6.cookie、sessionStorage、localStorage区别</h3><p>相同点：</p><ul><li>都是保存在浏览器端、且同源的</li></ul><p>不同点：</p><ul><li><p>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下</p></li><li><p>存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M+</p></li><li><p>cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除</p></li><li><p>cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地</p></li><li><p>作用域不同，sessionStorage在不同的浏览器窗口中不共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的</p></li></ul><h3 id="7-css选择器"><a href="#7-css选择器" class="headerlink" title="7.css选择器"></a>7.css选择器</h3><ul><li><p>常用css选择器</p><p>  id选择器   #header<br>  类选择器   .header<br>  元素选择器  div<br>  通配符     *<br>  后代选择器  div p, p a<br>  儿子选择器  div &gt; span<br>  兄弟选择器  div + p, h2 ~ h3<br>  伪类选择器  a:hover<br>  属性选择器  input[type=”text”]<br>  伪元素选择器  p::before  p::first-line</p></li><li><p>css选择器权重</p><p>  !important &gt; id &gt; class &gt; 元素和伪元素 &gt; * &gt; 继承 &gt;默认</p></li></ul><h3 id="8-css3新特性"><a href="#8-css3新特性" class="headerlink" title="8.css3新特性"></a>8.css3新特性</h3><ul><li>transition 过渡</li><li>transform   旋转 倾斜 移动 缩放</li><li>animation   动画</li><li>shadow  阴影</li><li>grdient 渐变</li><li>border-radius   圆角</li></ul><h3 id="9-行内元素和块级元素"><a href="#9-行内元素和块级元素" class="headerlink" title="9.行内元素和块级元素"></a>9.行内元素和块级元素</h3><ul><li><p>行内元素（display: inline）:</p><ul><li>设置宽高无效，宽度和高度由内容决定</li><li>设置margin左右有效，上下无效，padding都有效</li><li>不会自动换行</li><li>有span,img,input,a,b,sub,sup,i</li></ul></li><li><p>块级元素(display:block):</p><ul><li>可以设置宽高</li><li>margin和padding都有效</li><li>自动换行</li><li>多个块元素写一起，排列从上到下</li><li>由div,p,nav,h,footer,main,header等</li></ul></li><li><p>行内块元素（display:inline-block）</p><ul><li>能够设置宽高</li><li>margin/padding都有效</li><li>不会自动换行</li><li>默认排列方式从左到右</li></ul></li></ul><h3 id="10-css的position的定位"><a href="#10-css的position的定位" class="headerlink" title="10.css的position的定位"></a>10.css的position的定位</h3><p>relative  absolute  fixed  static</p><ul><li>绝对定位： absolute和fiexed统称为绝对定位</li><li>相对定位： relative</li><li>默认值：static<br>相对定位和绝对定位的区别：</li><li>relative：<br>相对于自身位置定位，仍处于文档流中，元素的宽高不变，设置偏移量也不会影响其他元素的位置，如果最外层设置relative，在没有设置宽度情况，元素宽度是整个浏览器的宽度</li><li>absolute：<br>相对于离自己最近的设置了相对或绝对定位的父元素定位，如果没有父元素设置相对和绝对定位，则相对于跟元素html定位，设置了绝对定位的元素脱离了文档流，如果没有设置宽高由元素内容决定，脱离后元素位置是空的下面的元素会占据</li><li>fixed：<br>相对于浏览器窗口定位,如果没有设置宽高由元素内容决定。</li></ul><h3 id="11-Flex布局"><a href="#11-Flex布局" class="headerlink" title="11.Flex布局"></a>11.Flex布局</h3><p>Flexbox为Flexible box缩写，“弹性布局”，任何一个元素都能设置弹性布局包含两部分，一个为容器，一个为项目<br>水平的主轴（main axis）和垂直的交叉轴（cross axis）<br>主轴的排列方式：从左到右；交叉轴的排列方式：从上到下;</p><p>容器的属性：</p><ul><li>flex-direction:主轴的方向-row/row-reverse/column/column-reverse</li><li>flex-wrap:项目排列方式是否换行–nowrap/wrap/wrap-reverse</li><li>flex-flow:direction和wrap的缩写</li><li>justify-content:项目在主轴排列方式–flex-start/flex-end/center/space-between/space-around</li><li>align-items:项目在交叉轴的如何对齐-flex-start/flex-end/center/baseline/stretch</li></ul><p>项目属性：</p><ul><li>order：number （数值越小越靠前，默认为0）项目排列顺序</li><li>flex-grow ：number（默认0，如果有剩余空间也不放大，值为1放大，2是1的双倍大小，此类推）定义项目放大比例</li><li>flex-shrink ：number （默认为1，如果空间不足则会缩小，值为0不能缩小）项目缩小比例</li><li>flex-basis ：number/auto （默认auto，可设置固定的值50px/50%）定义项目自身的大小</li><li>flex：属性是flex-grow，flex-shrink ,flex-basis的简写，默认值为0、1、auto</li><li>align-self ：auto | flex-start | flex-end | center | baseline | stretch项目自身对齐</li></ul><h3 id="12-display有哪些值？说明他们的作用"><a href="#12-display有哪些值？说明他们的作用" class="headerlink" title="12.display有哪些值？说明他们的作用?"></a>12.display有哪些值？说明他们的作用?</h3><ul><li>inline（默认）–内联</li><li>none–隐藏</li><li>block–块显示</li><li>table–表格显示</li><li>list-item–项目列表</li><li>inline-block-内联块</li></ul><h3 id="13-BFC"><a href="#13-BFC" class="headerlink" title="13.BFC"></a>13.BFC</h3><p>BFC块格式化上下文，是Web页面的可视CSS渲染的一部分.是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p><p>下列方式会创建块格式化上下文</p><pre><code>    根元素html    浮动元素（元素的float不是none）    绝对定位元素（元素的display为absolute或fixed）    行内块元素（display：inline-block）    表格单元格（display：table-cell）    表格标题（display：table-caption）    匿名表格单元格元素（display：table/table-row/table-row-group/table-header-group/table-footer-group或inline-table）    overflow计算值不为visible的块元素    display值为flow-root的元素    contain值为layout/content/paint的元素    弹性元素（display为flex或inline-flex 元素的直接子元素）    网格元素（display为grid或inline-grid 元素的直接子元素）    多列容器（元素的column-count或column-width部位auto）    column-span为all的元素始终会创建一个新的BFC，即使该元素没有包裹一个多列容器中。</code></pre><p>BFC布局规则：</p><pre><code>    内部的box会在垂直方向，一个一个排列    Box垂直方向的距离由margin决定，同一个BFC内相邻的两个box的margin值会重叠    每个元素的margin box的左边与border box的左边相接触，即使浮动也如此    BFC区域不和float box区域重叠    BFC是页面上一个独立的容器，内部子元素不回对外部元素产生影响    计算BFC高度时，浮动元素也参与计算</code></pre><p>BFC的使用场景？</p><pre><code>去除边距重叠现象清除浮动（让父元素的高度包含子浮动元素）避免某元素被浮动元素覆盖避免多列布局由于宽度计算四舍五入而自动换行</code></pre><h3 id="14-水平垂直居中"><a href="#14-水平垂直居中" class="headerlink" title="14.水平垂直居中"></a>14.水平垂直居中</h3><pre><code>水平居中： margin:0 auto;text-align:center;flex:justify-content垂直居中：line-height;flex:align-items水平垂直居中：flex;absolute+margin负；absolute+translate负</code></pre><h3 id="15-Sass、Less、Stylus区别"><a href="#15-Sass、Less、Stylus区别" class="headerlink" title="15.Sass、Less、Stylus区别"></a>15.Sass、Less、Stylus区别</h3><p>什么是CSS预处理器?<br>CSS预处理器是一种语言用来为CSS增加一些编程的特性，无需考虑浏览器兼容问题，例如你可以在CSS中使用变量，简单的程序逻辑、函数等在编程语言中的一些基本技巧，可以让CSS更加简洁，适应性更强，代码更直观等诸多好处</p><ul><li><p>基本语法区别<br>  Sass是以.sass为扩展名，Less是以.less为扩展名，Stylus是以.styl为扩展名</p></li><li><p>变量的区别<br>  Sass 变量必须是以$开头的，然后变量和值之间使用冒号（：）隔开，和css属性是一样的。<br>  Less 变量是以@开头的，其余sass都是一样的。<br>  Stylus 对变量是没有任何设定的，可以是以$开头或者任意字符，而且变量之间可以冒号，空格隔开，但是在stylus中不能用@开头</p></li></ul><p>三种预处理器都有：嵌套、运算符、颜色函数、导入、继承、混入。Stylus还有一些高级特性。例如循环、判断等</p><h3 id="16-display-none与visibility-hidden的区别"><a href="#16-display-none与visibility-hidden的区别" class="headerlink" title="16.display: none与visibility: hidden的区别"></a>16.display: none与visibility: hidden的区别</h3><pre><code>display：none 不显示对应的元素，在文档布局中不再分配空间（回流+重绘）visibility：hidden 隐藏对应元素，在文档布局中仍保留原来的空间（重绘）</code></pre><h3 id="17-重绘-amp-回流"><a href="#17-重绘-amp-回流" class="headerlink" title="17.重绘 &amp; 回流"></a>17.重绘 &amp; 回流</h3><p>浏览器渲染过程如下：</p><ul><li>解析HTML，生成DOM树，解析CSS，生成CSSOM树</li><li>将DOM树和CSSOM树结合，生成渲染树(Render Tree)</li><li>Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）</li><li>Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</li><li>Display:将像素发送给GPU，展示在页面上</li></ul><p>通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流</p><p>我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。</p><p>何时发生回流重绘</p><ul><li>添加或删除可见的DOM元素</li><li>元素的位置发生变化</li><li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li><li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。</li><li>页面一开始渲染的时候（这肯定避免不了）</li><li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</li></ul><p>注意：回流一定会触发重绘，而重绘不一定会回流根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。</p><p>当你获取布局信息的操作的时候，会强制队列刷新</p><p>最小化重绘和重排：</p><p>  批量修改DOM：<br>  使元素脱离文档流<br>  对其进行多次修改<br>  将元素带回到文档中。</p><p>有三种方式可以让DOM脱离文档流：</p><p>  隐藏元素，应用修改，重新显示<br>  使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。<br>  将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。</p><h3 id="18-防抖（debounce）"><a href="#18-防抖（debounce）" class="headerlink" title="18.防抖（debounce）"></a>18.防抖（debounce）</h3><p>防抖就是在触发事件n秒内函数只执行一次，如果在n秒内又触发了事件，就重新计时<br>如下，鼠标移动时，计数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height:150px;line-height:150px;text-align:center; color: #fff;background-color:#ccc;font-size:80px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> num = <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> content = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;content&#x27;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">  content.innerHTML = num++;</span><br><span class="line">&#125;;</span><br><span class="line">content.onmousemove = count;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>防抖函数分为非立即执行版和立即执行版</p><p>非立即执行版：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func,wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(timeout)&#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        &#125;</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            func.apply(context,args)</span><br><span class="line">        &#125;,wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在触发事件后函数 1 秒后才执行，而如果我在触发事件后的 1秒内又触发了事件，则会重新计算函数执行时间<br>content.onmousemove = debounce(count,1000);</p><p>let context = this;<br>let args = arguments;<br>防抖函数的代码使用这两行代码来获取 this 和参数，是为了让 debounce 函数最终返回的函数 this指向不变以及依旧能接受到 e 参数</p><p>立即执行版：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func,wait</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(timeout)&#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> callNow = !timeout;</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      timeout = <span class="literal">null</span></span><br><span class="line">    &#125;,wait)</span><br><span class="line">    <span class="keyword">if</span> (callNow) func.apply(context, args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。</p><h3 id="19-节流（throttle）"><a href="#19-节流（throttle）" class="headerlink" title="19.节流（throttle）"></a>19.节流（throttle）</h3><p>连续触发函数在n秒内只执行一次，稀释了函数的执行频率<br>时间戳版：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func,wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span>(now-previous &gt; wait)&#123;</span><br><span class="line">            func.apply(context,args);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">content.onmousemove = throttle(count,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>在持续触发事件的过程中，函数会立即执行，并且每 1s 执行一次</p><p>定时器版：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func,wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = argments;</span><br><span class="line">        <span class="keyword">if</span>(!timeout)&#123;</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            timeout = <span class="literal">null</span>;</span><br><span class="line">            func.apply(context, args)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在持续触发事件的过程中，函数不会立即执行，并且每1s 执行一次，在停止触发事件后，函数还会再执行一次。</p><p>时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候。</p><h3 id="20-获取盒子宽高的几种方式及区别"><a href="#20-获取盒子宽高的几种方式及区别" class="headerlink" title="20.获取盒子宽高的几种方式及区别"></a>20.获取盒子宽高的几种方式及区别</h3><ul><li><p>dom.style.width/height<br>这种方式只能取到dom元素内联样式所设置的宽高，也就是说如果该节点的样式是在style标签中或外联的CSS文件中设置的话，通过这种方法是获取不到dom的宽高的</p></li><li><p>dom.currentStyle.width/height<br>获取渲染后的宽高。但是仅IE支持</p></li><li><p>window.getComputedStyle(dom).width/height<br>与2原理相似，但是兼容性，通用性更好一些</p></li><li><p>dom.getBoundingClientRect().width/height<br>计算元素绝对位置，获取到四个元素left,top,width,height</p></li></ul><p>扩展：获取浏览器高度和宽度的兼容性写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  w = <span class="built_in">window</span>.innerWidth || <span class="built_in">document</span>.documentElement.clientWidth || <span class="built_in">document</span>.body.clientWidth</span><br><span class="line"><span class="keyword">var</span>  h = <span class="built_in">window</span>.innerHeight || <span class="built_in">document</span>.documentElement.clientHeight || <span class="built_in">document</span>.body.clientHeight</span><br></pre></td></tr></table></figure><h3 id="21-link和import区别"><a href="#21-link和import区别" class="headerlink" title="21.link和import区别"></a>21.link和import区别</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line"><span class="keyword">@import</span> url(CSS文件路径地址);</span><br><span class="line">&lt;/<span class="selector-tag">style</span>&gt;</span><br><span class="line">&lt;link href=&quot;CSSurl路径&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;</span><br></pre></td></tr></table></figure><ul><li>import是css提供的语法规则，只有导入样式表的作用，link是html的标签，不仅可以加载样式还可以设置rel type等属性</li><li>import是css2才引入等，只支持ie5+，而link没有兼容问题</li><li>import在页面加载完毕才引入，link在加载页面时引入</li><li>link可用dom操作引入link加载样式</li></ul><h3 id="22-多行元素省略号"><a href="#22-多行元素省略号" class="headerlink" title="22.多行元素省略号"></a>22.多行元素省略号</h3><pre><code>overflow : hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 3;-webkit-box-orient: vertical</code></pre><h2 id="三-JS"><a href="#三-JS" class="headerlink" title="三.JS"></a>三.JS</h2><h3 id="1-JS的基本数据类型"><a href="#1-JS的基本数据类型" class="headerlink" title="1.JS的基本数据类型"></a>1.JS的基本数据类型</h3><p><code>Number</code>  <code>String</code>  <code>Boolean</code>  <code>Null</code>  <code>undefined</code> 新增<code>Symbol</code></p><h3 id="2-几种判断数据类型的优缺点"><a href="#2-几种判断数据类型的优缺点" class="headerlink" title="2.几种判断数据类型的优缺点"></a>2.几种判断数据类型的优缺点</h3><p>一、typeof</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">1</span>);               <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);            <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">&#x27;mc&#x27;</span>);           <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);    <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []);              <span class="comment">// object </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;);              <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);            <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>);       <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>优点：能够快速区分基本数据类型 缺点：不能将Object、Array和Null区分，都返回object</p><p>二、instanceof</p><p>instanceof用来检测构造函数的prototype属性是否存在某实例对象的原型链上</p><p>语法：object instanceof constructor<br>参数：<br>object:某个实例对象<br>constructor:某个构造函数<br>描述：二、instanceof用来检测constructor.prototype属性是否存在在object的原型链上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>);                    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);                <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>);                <span class="comment">// false  </span></span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>);                    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Function</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>);                   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>优点：能够区分Array、Object和Function，适合用于判断自定义的类实例对象 缺点：Number，Boolean，String基本数据类型不能判断</p><p>三、Object.prototype.toString.call()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="number">1</span>));                      <span class="comment">//[object Number]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="literal">true</span>));                   <span class="comment">//[object Boolean]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="string">&#x27;mc&#x27;</span>));                  <span class="comment">//[object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call([]));                     <span class="comment">//[object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(&#123;&#125;));                     <span class="comment">//[object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;));           <span class="comment">//[object Function]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="literal">undefined</span>));              <span class="comment">//[object Undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="literal">null</span>));                   <span class="comment">//[object Null]</span></span><br></pre></td></tr></table></figure><p>优点：精准判断数据类型 缺点：写法繁琐不容易记，推荐进行封装后使用</p><h3 id="3-null和undefined的区别"><a href="#3-null和undefined的区别" class="headerlink" title="3.null和undefined的区别"></a>3.null和undefined的区别</h3><pre><code>undefined是访问一个未初始化的变量时返回的值，而null是访问一个尚未存在的对象时所返回的值。undefined看作是空的变量，而null看作是空的对象</code></pre><h3 id="4-对象深浅拷贝"><a href="#4-对象深浅拷贝" class="headerlink" title="4.对象深浅拷贝"></a>4.对象深浅拷贝</h3><p>一、深拷贝</p><ul><li>1.1 最简单的方法就是JSON.parse(JSON.stringify())<br>但是这种拷贝方法不可以拷贝一些特殊的属性（例如正则表达式，undefine，function）</li><li>1.2 用递归去复制所有层级属性</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopyTwo</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> objClone = <span class="built_in">Array</span>.isArray(obj) ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (obj &amp;&amp; <span class="keyword">typeof</span> obj == <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">          <span class="comment">//判断obj子元素是否为对象，如果是，递归复制</span></span><br><span class="line">          <span class="keyword">if</span> (obj[key] &amp;&amp; <span class="keyword">typeof</span> obj[key] === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">              objClone[key] = deepCopyTwo(obj[key]);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//如果不是，简单复制</span></span><br><span class="line">              objClone[key] = obj[key];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> objClone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、浅拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(target, ...sources)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        result[i] = obj[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-数组基本方法"><a href="#5-数组基本方法" class="headerlink" title="5.数组基本方法"></a>5.数组基本方法</h3><ul><li><p>push()：将参数逐个添加到数组尾部，返回修改后的数组长度</p></li><li><p>unshift()：将参数逐个添加到数组前端，返回修改后的数组长度</p></li><li><p>pop()：移除数组中的最后一项，返回移除的项</p></li><li><p>shift()：移除数组中的第一项，返回移除的项</p></li></ul><p>push pop shift unshift 都会直接改变原数组</p><ul><li><p>map: 遍历数组，返回回调返回值组成的新数组</p></li><li><p>forEach: 无法break，可以用try/catch中throw new Error来停止</p></li><li><p>filter: 过滤</p></li><li><p>some: 有一项返回true，则整体为true</p></li><li><p>every: 有一项返回false，则整体为false</p></li><li><p>join: 通过指定连接符生成字符串</p></li><li><p>concat: 连接数组，不影响原数组， 浅拷贝</p></li><li><p>slice(start, end): 返回截断后的新数组，不改变原数组</p></li><li><p>splice(start, number, value…):返回删除元素组成的数组，value 为插入项，改变原数组</p></li><li><p>indexOf / lastIndexOf(value, fromIndex): 查找数组项，返回对应的下标</p></li><li><p>reduce / reduceRight(fn(prev, cur)， defaultPrev): 两两执行，prev 为上次化简函数的return值,cur 为当前值(从第二项开始)</p></li></ul><p>map和forEach的区别：</p><p>1.都用来遍历数组，map速度比forEach快<br>2.map返回回调返回值组成的新数组，不会对原数组产生影响，forEach没有返回值，不能return或者break<br>3.map返回数组，所以可以链式调用</p><h3 id="6-js有那些内置对象"><a href="#6-js有那些内置对象" class="headerlink" title="6.js有那些内置对象"></a>6.js有那些内置对象</h3><p>Object是JavaScript中所有对象的父对象</p><p>数据封装对象：Object、Array、Boolean、Number和String<br>其他对象：Function、Arguments、Math、Date、RegExp、Error</p><h3 id="7-get请求传参长度的误区"><a href="#7-get请求传参长度的误区" class="headerlink" title="7.get请求传参长度的误区"></a>7.get请求传参长度的误区</h3><ul><li>HTTP 协议 未规定 GET 和POST的长度限制</li><li>GET的最大长度显示是因为 浏览器和 web服务器限制了 URI的长度</li><li>不同的浏览器和WEB服务器，限制的最大长度不一样</li><li>要支持IE，则最大长度为2083byte，若只支持Chrome，则最大长度 8182byte</li></ul><p>补充get和post请求在缓存方面的区别</p><ul><li>get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存</li><li>post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。</li></ul><h3 id="8-同步任务和异步任务"><a href="#8-同步任务和异步任务" class="headerlink" title="8.同步任务和异步任务"></a>8.同步任务和异步任务</h3><ul><li><p>同步任务：在主线程上执行的任务，只有前一个任务执行完，才能执行下一个任务</p></li><li><p>异步任务：不进入主线程而进入“任务队列”的任务，只有任务队列通知主线程，某个任务可以执行了，该任务才会进入主线程执行。</p><p>  异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）：<br>  1）所以同步任务都在主线程执行，形成一个执行栈<br>  2）主线程之外，还有一个任务队列，只要异步任务有了执行结果，就在任务队列放置一个事件<br>  3）一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列，看看有哪些事件，对应的事件就结束等待状态，进入执行栈进行执行<br>  4）主线程不断重复第三步</p><p>  主线程从“任务队列”中读取事件，这个事件是循环不断的，又称为事件循环（Event loop）</p></li></ul><h3 id="9-事件和回调函数"><a href="#9-事件和回调函数" class="headerlink" title="9.事件和回调函数"></a>9.事件和回调函数</h3><p>“任务队列”就是一个事件的队列，当IO设备完成一项任务，就在“任务队列”中添加一个事件，表示相关的异步任务可以进入执行栈了，主线程读取“任务队列”，就是读取有哪些事件</p><p>“回调函数”（callback）就是被主线程挂起来的代码。异步任务必须指定回调函数，主线程执行异步任务就是执行对应的回调函数。</p><h3 id="10-定时器"><a href="#10-定时器" class="headerlink" title="10.定时器"></a>10.定时器</h3><p>定时器功能主要由setTimeout()和setInterval()这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者则为反复执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">2</span>);&#125;,<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>上面代码的执行结果是1，3，2，因为setTimeout()将第二行推迟到1000毫秒之后执行。</p><p>如果将setTimeout()的第二个参数设为0，就表示当前代码执行完（执行栈清空）以后，立即执行（0毫秒间隔）指定的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>);&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>上面代码的执行结果总是2，1，因为只有在执行完第二行以后，系统才会去执行”任务队列”中的回调函数。</p><p>setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行</p><p>HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加.需要注意的是，setTimeout()只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行</p><p>除了setTimeout和setInterval这两个方法，Node.js还提供了另外两个与”任务队列”有关的方法：process.nextTick和setImmediate。</p><ul><li><p>process.nextTick方法可以在当前”执行栈”的尾部—-下一次Event Loop（主线程读取”任务队列”）之前—-触发回调函数。也就是说，它指定的任务总是发生在所有异步任务之前。setImmediate方法则是在当前”任务队列”的尾部添加事件，也就是说，它指定的任务总是在下一次EventLoop时执行，这与setTimeout(fn, 0)很像</p></li><li><p>process.nextTick和setImmediate的一个重要区别：多个process.nextTick语句总是在当前”执行栈”一次执行完，多个setImmediate可能则需要多次loop才能执行完</p></li></ul><p>另外，由于process.nextTick指定的回调函数是在本次”事件循环”触发，而setImmediate指定的是在下次”事件循环”触发，所以很显然，前者总是比后者发生得早，而且执行效率也高（因为不用检查”任务队列”）。</p><h3 id="11-进程和线程"><a href="#11-进程和线程" class="headerlink" title="11.进程和线程"></a>11.进程和线程</h3><p>进程和线程是操作系统的基本概念</p><p>单个cpu一次只能运行一个任务，任一时刻，CPU总是运行一个进程，其他进程处于非运行状态</p><ul><li>一个进程可用包含多个线程</li><li>一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。</li><li>一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。”互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。</li></ul><p>某些内存区域，只能供给固定数目的线程使用。”信号量”（Semaphore），用来保证多个线程不会互相冲突</p><p>操作系统的设计，因此可以归结为三点：</p><pre><code>（1）以多进程形式，允许多个任务同时运行；（2）以多线程形式，允许单个任务分成不同的部分运行；（3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源</code></pre><h3 id="12-axios在vue-js中应用和特点"><a href="#12-axios在vue-js中应用和特点" class="headerlink" title="12.axios在vue.js中应用和特点"></a>12.axios在vue.js中应用和特点</h3><p>axios是基于promise的http请求客户端，可用在浏览器和node。js中使用</p><p>使用场景：结合vue.js发送请求，拦截请求</p><p>特点：<br>    1.基于promise<br>    2.拦截请求和响应<br>    3.转换请求和响应的数据<br>    4.可在node.js中使用</p><p>安装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save axios</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> ‘axios’</span><br></pre></td></tr></table></figure><p>结合Vue.js的请求响应拦截器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求拦截</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (config.url.indexOf(<span class="string">&#x27;/oauth/token?grant_type=password&#x27;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">    config.headers[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="string">&#x27;Basic Y2xpOnNlYw==&#x27;</span></span><br><span class="line">    <span class="comment">// config.headers[&#x27;Content-Type&#x27;] = &#x27;application/json;charset-UTF-8&#x27;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getToken()) &#123;</span><br><span class="line">    config.headers[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="string">&#x27;Bearer &#x27;</span> + getToken() + <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Do something with request error</span></span><br><span class="line">  <span class="built_in">console</span>.log(error) <span class="comment">// for debug</span></span><br><span class="line">  <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截</span></span><br><span class="line">axios.interceptors.response.use(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.data.code !== <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (res.data.code) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;401&#x27;</span>:</span><br><span class="line">        <span class="built_in">window</span>.location.href = <span class="string">&#x27;/login&#x27;</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;403&#x27;</span>:</span><br><span class="line">        Notification.error(&#123;</span><br><span class="line">          title: <span class="string">&#x27;错误：403&#x27;</span>,</span><br><span class="line">          message: <span class="string">&#x27;访问拒绝&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;404&#x27;</span>:</span><br><span class="line">        Notification.error(&#123;</span><br><span class="line">          title: <span class="string">&#x27;错误：404&#x27;</span>,</span><br><span class="line">          message: <span class="string">&#x27;找不到网络资源&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;500&#x27;</span>:</span><br><span class="line">        Notification.error(&#123;</span><br><span class="line">          title: <span class="string">&#x27;错误：500&#x27;</span>,</span><br><span class="line">          message: res.data.error.errorMsg</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.data</span><br><span class="line">&#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err.response) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (err.response.status) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;401&#x27;</span>:</span><br><span class="line">        <span class="built_in">window</span>.location.href = <span class="string">&#x27;/login&#x27;</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;403&#x27;</span>:</span><br><span class="line">        Notification.error(&#123;</span><br><span class="line">          title: <span class="string">&#x27;错误：403&#x27;</span>,</span><br><span class="line">          message: <span class="string">&#x27;访问拒绝&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;404&#x27;</span>:</span><br><span class="line">        Notification.error(&#123;</span><br><span class="line">          title: <span class="string">&#x27;错误：404&#x27;</span>,</span><br><span class="line">          message: <span class="string">&#x27;找不到网络资源&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;500&#x27;</span>:</span><br><span class="line">        Notification.error(&#123;</span><br><span class="line">          title: <span class="string">&#x27;错误：500&#x27;</span>,</span><br><span class="line">          message: <span class="string">&#x27;服务器出错&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求封装</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">_axios</span> (<span class="params">method, url, params</span>) </span>&#123;</span><br><span class="line">  method = method.toUpperCase()</span><br><span class="line">  <span class="keyword">var</span> options = &#123;</span><br><span class="line">    method: method,</span><br><span class="line">    url: url,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json;charset=UTF-8&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (method === <span class="string">&#x27;POST&#x27;</span> || method === <span class="string">&#x27;PATCH&#x27;</span> || method === <span class="string">&#x27;PUT&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (params) &#123;</span><br><span class="line">      options.data = params</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> axios(options)</span><br><span class="line">      .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">      &#125;, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> error</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (method === <span class="string">&#x27;GET&#x27;</span> || method === <span class="string">&#x27;DELETE&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (params) &#123;</span><br><span class="line">      options.params = params</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> axios(options)</span><br><span class="line">      .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">      &#125;, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> error</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-HTTP中定义请求方式"><a href="#13-HTTP中定义请求方式" class="headerlink" title="13.HTTP中定义请求方式"></a>13.HTTP中定义请求方式</h3><ul><li><p>get</p></li><li><p>post</p></li><li><p>put</p></li><li><p>delete</p></li><li><p>trace</p></li><li><p>options</p></li><li><p>head</p></li></ul><p>1.get</p><p>get请求只是查询数据，不对数据库进行删改操作；请求会把参数放在url后面；http协议对url长度没有限制，有限制的是浏览器和服务器</p><p>2.post</p><p>post请求一般是对服务器的数据做改变，比如数据的提交，新增操作，请求参数放在请求体中</p><p>3.put</p><p>put和post一样都是对服务器数据对修改，但是put侧重于对数据的修改，而post是对数据的新增</p><p>4.delete</p><p>用来请求删除服务器的资源，但有可能删除不成功（取消delete请求）</p><p>5.options</p><p>options请求属于浏览器的预检请求，查看服务器是否接受请求，预检通过后，浏览器才会去发get，post，put，delete等，响应报文包含一个 Allow 首部字段，该字段的值表明了服务器支持的所有 HTTP 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Allow: OPTIONS, GET, HEAD, POST</span><br><span class="line">Cache-Control: max-age=<span class="number">604800</span></span><br><span class="line"><span class="built_in">Date</span>: Thu, <span class="number">13</span> Oct <span class="number">2016</span> <span class="number">11</span>:<span class="number">45</span>:<span class="number">00</span> GMT</span><br><span class="line">Expires: Thu, <span class="number">20</span> Oct <span class="number">2016</span> <span class="number">11</span>:<span class="number">45</span>:<span class="number">00</span> GMT</span><br><span class="line">Server: EOS (lax004/<span class="number">2813</span>)</span><br><span class="line">x-ec-custom-error: <span class="number">1</span></span><br><span class="line">Content-Length: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>在 CORS 中，可以使用 OPTIONS 方法发起一个预检请求，以检测实际请求是否可以被服务器所接受。预检请求报文中的 Access-Control-Request-Method首部字段告知服务器实际请求所使用的 HTTP方法；Access-Control-Request-Headers首部字段告知服务器实际请求所携带的自定义首部字段。服务器基于从预检请求获得的信息来判断，是否接受接下来的实际请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS /resources/post-here/ HTTP/<span class="number">1.1</span> </span><br><span class="line">Host: bar.other </span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;</span><br><span class="line">Accept-Language: en-us,en;q=<span class="number">0.5</span> </span><br><span class="line">Accept-Encoding: gzip,deflate </span><br><span class="line">Accept-Charset: ISO-<span class="number">8859</span>-<span class="number">1</span>,utf-<span class="number">8</span>;</span><br><span class="line">Connection: keep-alive </span><br><span class="line">Origin: http:<span class="comment">//foo.example </span></span><br><span class="line">Access-Control-Request-Method: POST </span><br><span class="line">Access-Control-Request-Headers: X-PINGOTHER, Content-Type</span><br></pre></td></tr></table></figure><p>服务器所返回的 Access-Control-Allow-Methods 首部字段将所有允许的请求方法告知客户端。该首部字段与 Allow 类似，但只能用于涉及到 CORS 的场景中。</p><pre><code>    Access-Control-Allow-Methods: POST, GET, OPTIONS     Access-Control-Allow-Headers: X-PINGOTHER, Content-Type </code></pre><p>6.head</p><p>与GET方法的行为很类似，但服务器在响应中只返回实体的主体部分</p><p>7.trace</p><p>会在目的服务器端发起一个“回环”诊断。这样客户端就可以查看HTTP请求报文在发送的途中，是否被修改过了</p><h3 id="14-get和post区别"><a href="#14-get和post区别" class="headerlink" title="14.get和post区别"></a>14.get和post区别</h3><ul><li><p>GET参数通过URL传递，POST放在Request body中。</p></li><li><p>GET请求会被浏览器主动cache，而POST不会，除非手动设置</p></li><li><p>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留</p></li><li><p>Get 请求中有非 ASCII 字符，会在请求之前进行转码，POST不用，因为POST在Request body中，通过 MIME，也就可以传输非 ASCII 字符</p></li><li><p>一般我们在浏览器输入一个网址访问网站都是GET请求,HTTP的底层是TCP/IP。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。但是请求的数据量太大对浏览器和服务器都是很大负担。所以业界有了不成文规定，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。</p></li><li><p>GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）</p></li><li><p>在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。但并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次</p></li></ul><h3 id="15-http中content-type"><a href="#15-http中content-type" class="headerlink" title="15.http中content-type"></a>15.http中content-type</h3><p>MediaType，即是Internet Media Type，互联网媒体类型；也叫做MIME类型，在Http协议消息头中，使用Content-Type来表示具体请求中的媒体类型信息</p><p>常见的媒体格式类型如下：</p><ul><li>text/html ： HTML格式</li><li>text/plain ：纯文本格式</li><li>text/xml ：  XML格式</li><li>image/gif ：gif图片格式</li><li>image/jpeg ：jpg图片格式</li><li>image/png：png图片格式</li></ul><p>以application开头的媒体格式类型：</p><ul><li>application/xhtml+xml ：XHTML格式</li><li>application/xml     ： XML数据格式</li><li>application/atom+xml  ：Atom XML聚合格式</li><li>application/json    ： JSON数据格式</li><li>application/pdf       ：pdf格式  </li><li>application/msword  ： Word文档格式</li><li>application/octet-stream ： 二进制流数据（如常见的文件下载）</li><li>application/x-www-form-urlencoded ： <form encType=””>中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）</li></ul><p>另外一种常见的媒体格式是上传文件之时使用的：</p><ul><li>multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式</li></ul><h3 id="16-import和require区别"><a href="#16-import和require区别" class="headerlink" title="16.import和require区别"></a>16.import和require区别</h3><ul><li><p>加载方式<br>require：运行时加载，所以require理论上可以运用在代码的任何地方<br>import：编译时加载，import是编译时调用，所以必须放在文件开头</p></li><li><p>遵循规范<br>require 是 AMD规范引入方式<br>import是es6的一个语法标准，如果要兼容浏览器的话必须转化成es5的语法</p></li><li><p>本质<br>require是赋值过程，其实require的结果就是对象、数字、字符串、函数等，再把require的结果赋值给某个变量import是解构过程，但是目前所有的引擎都还没有实现import，我们在node中使用babel支持ES6，也仅仅是将ES6转码为ES5再执行，import语法会被转码为require</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="built_in">exports</span>.fs = fs</span><br><span class="line"><span class="built_in">module</span>.exports = fs</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> fs&#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;readFile&#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;readFile <span class="keyword">as</span> read&#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> fs, &#123;readFile&#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> fs</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fs</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">readFile</span></span></span><br><span class="line"><span class="function"><span class="title">export</span> </span>&#123;readFile, read&#125;</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="17-ajax"><a href="#17-ajax" class="headerlink" title="17.ajax"></a>17.ajax</h3><p>ajax是异步javascript和xml；<br>Ajax是一种用于创建快速动态网页的技术。</p><p>ajax的使用及实现步骤：<br>1.创建XMLHttpRequest对象,也就是创建一个异步调用对象.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlHttp;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;  <span class="comment">//针对除IE6以外的浏览器</span></span><br><span class="line">    xmlHttp=<span class="keyword">new</span> XMLHttpRequest(); <span class="comment">//实例化一个XMLHttpRequest</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   xmlHttp=<span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);   <span class="comment">//针对IE5,IE6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(method,url,<span class="keyword">async</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure><p>3.设置响应HTTP请求状态变化的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xmlHttp.onreadystatechange()=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(xmlHttp.readyState === <span class="number">4</span> &amp;&amp; xmlHttp.status === <span class="number">200</span>)&#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>).innerHTML=xmlhttp.responseText;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//服务器响应<br>responseText:获得字符串形式的响应数据。<br>responseXML:获得 XML 形式的响应数据。<br>readyState:存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。</p><pre><code>0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪</code></pre><p>status:</p><pre><code>200: &quot;OK&quot;404: 未找到页面</code></pre><p>当 readyState 等于 4 且状态为 200 时，表示响应已就绪：<br>ajax步骤：</p><pre><code>创建XMLHttpRequest对象。设置请求方式。调用回调函数。发送请求。</code></pre><h3 id="18-闭包"><a href="#18-闭包" class="headerlink" title="18.闭包"></a>18.闭包</h3><p>函数A 里面包含了 函数B，而 函数B 里面使用了 函数A 的变量，那么 函数B 被称为闭包。</p><p>又或者：闭包就是能够读取其他函数内部变量的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特征：</p><ul><li>函数内再嵌套函数</li><li>内部函数可以引用外层的参数和变量</li><li>参数和变量不会被垃圾回收制回收  </li></ul><p>闭包的理解：使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。</p><p>在js中，函数即闭包，只有函数才会产生作用域的概念</p><p>闭包 的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中</p><ul><li>好处：能够实现封装和缓存等</li><li>坏处：消耗内存，使用不当造成内存泄漏；在退出函数之前，将不使用的局部变量全部删除</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：3个3<br>解析：首先，for 循环是同步代码，先执行三遍 for，i变成了 3；然后，再执行异步代码 setTimeout，这时候输出的 i，只能是 3 个 3 了<br>解决方法：<br>1.使用let i=0;每个 let 和代码块结合起来形成块级作用域，当 setTimeout() 打印时，会寻找最近的块级作用域中的 i，所以依次打印出 0 1 2<br>2.立即执行函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19-js作用域和作用域链"><a href="#19-js作用域和作用域链" class="headerlink" title="19.js作用域和作用域链"></a>19.js作用域和作用域链</h3><p>1.作用域</p><p>在JavaScript中，作用域分为 全局作用域 和 函数作用域</p><ul><li>全局作用域：<br>代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域</li><li>函数作用域：<br>在固定的代码片段才能被访问</li></ul><p>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</p><p>变量取值：到创建 这个变量 的函数的作用域中取值</p><p>2.作用域链</p><p>一般情况下，变量取值到 创建 这个变量 的函数的作用域中取值。</p><p>但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链</p><h3 id="20-组件化和模块化"><a href="#20-组件化和模块化" class="headerlink" title="20.组件化和模块化"></a>20.组件化和模块化</h3><p>1.组件化</p><ul><li>为什么要组件化?</li></ul><p>有时候页面代码量太大，逻辑太多或者同一个功能组件在许多页面均有使用，维护起来相当复杂，这个时候，就需要组件化开发来进行功能拆分、组件封装，已达到组件通用性，增强代码可读性，维护成本也能大大降低</p><ul><li>组件化开发的优点</li></ul><p>很大程度上降低系统各个功能的耦合性，并且提高了功能内部的聚合性，降低了开发成本</p><ul><li><p>组件化开发的准则：</p><p>  专一<br>  可配置性<br>  标准<br>  复用性<br>  可维护性</p></li></ul><p>2.模块化</p><ul><li>为什么要模块化?</li></ul><p>早期的javascript版本没有块级作用域、没有类、没有包、也没有模块，这样会带来一些问题，如复用、依赖、冲突、代码组织混乱等，随着前端的膨胀，模块化显得非常迫切</p><ul><li><p>模块化的好处</p><p>  提高代码可复用性<br>  避免变量污染，命名冲突<br>  提高可维护性<br>  方便依赖关系管理</p></li><li><p>模块化的几种方法：</p></li></ul><p>1)函数封装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myModule = &#123;</span><br><span class="line">  var1: <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  var2: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">  fn1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  fn2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：这样避免了变量污染，只要保证模块名唯一即可，同时同一模块内的成员也有了关系</p><p>缺陷：外部可以睡意修改内部成员，这样就会产生意外的安全问题</p><p>2)立即执行函数表达式(IIFE)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myModule = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> var1 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> var2 = <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">      fn1: fn1,</span><br><span class="line">      fn2: fn2</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>总结：这样在模块外部无法修改我们没有暴露出来的变量、函数</p><p>缺点：功能相对较弱，封装过程增加了工作量，仍会导致命名空间污染可能、闭包是有成本的</p><h3 id="21-图片的预加载和懒加载"><a href="#21-图片的预加载和懒加载" class="headerlink" title="21.图片的预加载和懒加载"></a>21.图片的预加载和懒加载</h3><ul><li>预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染</li><li>懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数<br>两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。预加载则会增加服务器前端压力，懒加载对服务器有一定的缓解压力作用。</li></ul><h3 id="22-mouseover和mouseenter的区别"><a href="#22-mouseover和mouseenter的区别" class="headerlink" title="22.mouseover和mouseenter的区别"></a>22.mouseover和mouseenter的区别</h3><ul><li>mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是mouseout</li><li>mouseenter：当鼠标移入元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是mouseleave</li></ul><p>解决异步回调地狱：promise、generator、async/await</p><h3 id="23-对This对象的理解"><a href="#23-对This对象的理解" class="headerlink" title="23.对This对象的理解"></a>23.对This对象的理解</h3><p>this总是指向函数的直接调用者（而非间接调用者）</p><p>如果有new关键字，this指向new出来的那个对象</p><p>在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window</p><p>this表示当前对象，this的指向是根据调用的上下文来决定的，默认指向window对象，指向window对象时可以省略不写</p><p>全局环境： this始终指向的是window对象<br>局部环境： 在全局作用域下直接调用函数，this指向window 对象函数调用，哪个对象调用就指向哪个对象 使用new实例化对象，在构造函数中的this指向实例化对象 使用call或apply改变this的指向<br>总结：this始终指向最后一个调用它的函数的对象</p><h3 id="24-ES6其他常用功能"><a href="#24-ES6其他常用功能" class="headerlink" title="24.ES6其他常用功能"></a>24.ES6其他常用功能</h3><ol><li>let/const</li><li>多行字符串/模板变量</li><li>解构赋值</li><li>块级作用域</li><li>函数默认参数</li><li>箭头函数</li></ol><h3 id="25-bind、call、apply用法及区别"><a href="#25-bind、call、apply用法及区别" class="headerlink" title="25.bind、call、apply用法及区别"></a>25.bind、call、apply用法及区别</h3><p>相同点： 三个函数的作用就是改变this的指向，将函数绑定到上下文中； 不同点： 三个函数的语法不同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun.call(thisArg[, arg1[, arg2[, ...]]])</span><br><span class="line">fun.apply(thisArg, [argsArray])</span><br><span class="line"><span class="keyword">var</span> bindFn = fun.bind(thisArg[, arg1[, arg2[, ...]]])</span><br><span class="line">bindFn()</span><br></pre></td></tr></table></figure><h3 id="26-目前JS解决异步的方案有哪些"><a href="#26-目前JS解决异步的方案有哪些" class="headerlink" title="26.目前JS解决异步的方案有哪些"></a>26.目前JS解决异步的方案有哪些</h3><p>回调函数<br>事件监听<br>发布-订阅<br>Promise<br>Generator<br>Async/Await</p><h3 id="27-创建对象有几种方法"><a href="#27-创建对象有几种方法" class="headerlink" title="27.创建对象有几种方法"></a>27.创建对象有几种方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种：字面量</span></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;<span class="attr">name</span>: <span class="string">&quot;o1&quot;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;<span class="attr">name</span>: <span class="string">&quot;o2&quot;</span>&#125;)</span><br><span class="line"><span class="comment">// 第二种：通过构造函数</span></span><br><span class="line"><span class="keyword">var</span> M = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;<span class="built_in">this</span>.name = name&#125;</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="keyword">new</span> M(<span class="string">&quot;o3&quot;</span>)</span><br><span class="line"><span class="comment">// 第三种：Object.create()</span></span><br><span class="line"><span class="keyword">var</span> p = &#123;<span class="attr">name</span>: <span class="string">&quot;p&quot;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> o4 = <span class="built_in">Object</span>.create(p)</span><br></pre></td></tr></table></figure><h2 id="四-Vue"><a href="#四-Vue" class="headerlink" title="四.Vue"></a>四.Vue</h2><p>vue的生命周期：就是vue实例从创建到销毁的过程，也就是从开始创建，初始化数据，编译模版，挂载Dom，渲染更新，卸载等过程</p><h3 id="1-Vue生命周期的作用是什么？"><a href="#1-Vue生命周期的作用是什么？" class="headerlink" title="1.Vue生命周期的作用是什么？"></a>1.Vue生命周期的作用是什么？</h3><p>它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑</p><h3 id="2-Vue生命周期总共有几个阶段？"><a href="#2-Vue生命周期总共有几个阶段？" class="headerlink" title="2.Vue生命周期总共有几个阶段？"></a>2.Vue生命周期总共有几个阶段？</h3><p>它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后</p><h3 id="3-DOM渲染在哪个周期中就已经完成？"><a href="#3-DOM渲染在哪个周期中就已经完成？" class="headerlink" title="3.DOM渲染在哪个周期中就已经完成？"></a>3.DOM渲染在哪个周期中就已经完成？</h3><p>DOM 渲染在 mounted 中就已经完成了</p><h3 id="4-每个生命周期适合哪些场景？"><a href="#4-每个生命周期适合哪些场景？" class="headerlink" title="4.每个生命周期适合哪些场景？"></a>4.每个生命周期适合哪些场景？</h3><p>生命周期钩子的一些使用方法：<br>    beforecreate : 可以在这加个loading事件，在加载实例时触发<br>    created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用<br>    mounted : 挂载元素，获取到DOM节点<br>    updated : 如果对数据统一处理，在这里写上相应函数<br>    beforeDestroy : 销毁实例前做收尾清除工作<br>    nextTick : 更新数据后立即操作dom</p><h3 id="5-关于vue的keep-alive需要条件性缓存的解决"><a href="#5-关于vue的keep-alive需要条件性缓存的解决" class="headerlink" title="5.关于vue的keep-alive需要条件性缓存的解决"></a>5.关于vue的keep-alive需要条件性缓存的解决</h3><p>A&gt;B不缓存，C&gt;B需要缓存<br>在路由里面加上了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: <span class="string">&#x27;/b&#x27;</span>,</span><br><span class="line">  name: <span class="string">&#x27;B&#x27;</span>,</span><br><span class="line">  component: B,</span><br><span class="line">  meta:&#123;</span><br><span class="line">    keepAlive:<span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在app.vue写了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">    &lt;router-view v-if&#x3D;&quot;$route.meta.keepAlive&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">&lt;&#x2F;keep-alive&gt;</span><br><span class="line">&lt;router-view v-if&#x3D;&quot;!$route.meta.keepAlive&quot;&gt;&lt;&#x2F;router-view&gt;</span><br></pre></td></tr></table></figure><p>A页面写了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">beforeRouteLeave</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span><br><span class="line">  to.meta.keepAlive = <span class="literal">false</span>;</span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C页面写了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">beforeRouteLeave</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span><br><span class="line">  to.meta.keepAlive = <span class="literal">true</span>;</span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>meta.keepAlive=true这种方法，解决不了条件缓存问题<br>原因：在keep-alive源码中，include和exclude是被watch的 ，当发生变化时，keep-alive会去校验cache里是否匹配，匹配不上的会被删除。也就是说，官方是为这种情况做了处理的。而meta这种方法，因为没有存在某种类似于watch的方法，导致这种方法天然是和实际cache里面的内容有出入的，所以可定会存在各种奇怪的bug</p><p>利用include,动态添加”B”<br>1、在app.vue下增加keep-alive</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">&quot;catchList&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><p>catchList，是vuex维护的需要缓存的组件名的一个数组</p><p>2、在路由中加入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to,next,<span class="keyword">from</span></span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (to.name === <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">    store.commit(<span class="string">&#x27;keepAlive&#x27;</span>, <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3、在b.vue中加入(A&gt;B不缓存，C&gt;B缓存)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteLeave(<span class="function">(<span class="params">to,next,<span class="keyword">from</span></span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (to.name !== <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">    store.commit(<span class="string">&#x27;noKeepAlive&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在vuex中mutation是</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">keepAlive</span>(<span class="params">state, component</span>)</span> &#123;</span><br><span class="line">  !state.catchList.includes(component) &amp;&amp;</span><br><span class="line">  state.catchList.push(component)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">noKeepAlive</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">state.catchList = []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要是B的组件，都缓存。只有当从A&gt;B的时候，才让B不缓存。</p><h3 id="6-Vue-路由懒加载"><a href="#6-Vue-路由懒加载" class="headerlink" title="6.Vue 路由懒加载"></a>6.Vue 路由懒加载</h3><p>Vue项目中实现路由按需加载（路由懒加载）的3中方式：<br>一、Vue异步组件技术：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">  name: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">  component: <span class="function"><span class="params">resolve</span> =&gt;</span> reqire([<span class="string">&#x27;path路径&#x27;</span>], resolve)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、es6提案的import()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Home = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;path路径&#x27;</span>)</span><br></pre></td></tr></table></figure><p>三、webpack提供的require.ensure()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">  name: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">  component: <span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">require</span>.ensure([],<span class="function">() =&gt;</span>  r(<span class="built_in">require</span>(<span class="string">&#x27;path路径&#x27;</span>)), <span class="string">&#x27;demo&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-Proxy与Object-defineProperty-的对比"><a href="#7-Proxy与Object-defineProperty-的对比" class="headerlink" title="7.Proxy与Object.defineProperty()的对比"></a>7.Proxy与Object.defineProperty()的对比</h3><p>Proxy的优点：<br>      1. 可以直接监听对象而非属性,并返回一个新对象<br>      2. 可以直接监听数组的变化<br>      3. 可以劫持整个对象，并返回一个新对象</p><p>Proxy的缺点：<br>    Proxy是es6提供的新特性，兼容性不好，所以导致Vue3一致没有正式发布让让广大开发者使用，IE9以下不兼容</p><p>Object.defineProperty的优点：<br>    IE8以下的版本不兼容</p><p>Object.defineProperty的缺点：<br>    只能劫持对象的属性，我们需要对每个对象的每个属性进行遍历，无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应</p><p>Proxy代理整个对象，Object.defineProperty只代理对象上的某个属性。<br>如果对象内部要全部递归代理，则Proxy可以只在调用时递归，而Object.defineProperty需要在一开始就全部递归，Proxy性能优于Object.defineProperty。<br>对象上定义新属性时，Proxy可以监听到，Object.defineProperty监听不到。<br>数组新增删除修改时，Proxy可以监听到，Object.defineProperty监听不到。<br>Proxy不兼容IE9以下，Object.defineProperty不兼容IE8及以下。</p><h3 id="8-v-show与v-if区别"><a href="#8-v-show与v-if区别" class="headerlink" title="8.v-show与v-if区别"></a>8.v-show与v-if区别</h3><p>v-show是css切换，v-if是完整的销毁和重新创建</p><p>使用 频繁切换时用v-show，运行时较少改变时用v-if</p><p>v-if=’false’ v-if是条件渲染，当false的时候不会渲染</p><h3 id="9-vue有哪些指令"><a href="#9-vue有哪些指令" class="headerlink" title="9.vue有哪些指令"></a>9.vue有哪些指令</h3><ul><li><p>v-model //在表单控件或者组件上创建双向绑定</p></li><li><p>v-if  //根据表达式的值的 truthiness 来有条件地渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建</p></li><li><p>v-else-if</p></li><li><p>v-else</p></li><li><p>v-text //更新元素的 textContent</p></li><li><p>v-show //根据表达式之真假值，切换元素的 display CSS property。</p></li><li><p>v-html://更新元素的 innerHTML。注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译。如果试图使用 v-html 组合模板，可以重新考虑是否通过使用组件来替代。</p></li><li><p>v-on:绑定事件监听器</p></li><li><p>v-bind //动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。</p></li><li><p>v-for //基于源数据多次渲染元素或模板块</p></li><li><p>v-cloak //这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕</p></li><li><p>v-once //只渲染元素和组件一次</p></li><li><p>v-pre //跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。</p></li><li><p>v-slot //提供具名插槽或需要接收 prop 的插槽</p></li></ul><p>绑定class的数组用法</p><pre><code>对象方法: v-bind:class=&quot;&#123;&#39;orange&#39;: isRipe, &#39;green&#39;: isNotRipe&#125;&quot;数组方法:  v-bind:class=&quot;[class1, class2]&quot;行内: v-bind:style=&quot;&#123;color: color, fontSize: fontSize+&#39;px&#39; &#125;&quot;</code></pre><h3 id="10-组件之间的传值通信"><a href="#10-组件之间的传值通信" class="headerlink" title="10.组件之间的传值通信"></a>10.组件之间的传值通信</h3><ul><li><p>父组件给子组件传值:props</p></li><li><p>子组件向父组件通信:父组件向子组件传递事件方法，子组件通过$emit触发事件，回调给父组件</p></li><li><p>非父子，兄弟组件之间通信:<br>可以通过实例一个vue实例Bus作为媒介，要相互通信的兄弟组件之中，都引入Bus，然后通过分别调用Bus事件触发和监听来实现通信和参数传递</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click&#x3D;&quot;toBus&quot;&gt;子组件传给兄弟组件&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Bus from &#39;..&#x2F;common&#x2F;js&#x2F;bus.js&#39;</span><br><span class="line">export default&#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    toBus () &#123;</span><br><span class="line">        Bus.$emit(&#39;on&#39;, &#39;来自兄弟组件&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>另一个组件也import Bus.js 在钩子函数中监听on事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Bus <span class="keyword">from</span> <span class="string">&#x27;../common/js/bus.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    Bus.$on(<span class="string">&#x27;on&#x27;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.message = msg</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-子组件调用父组件的方法函数"><a href="#11-子组件调用父组件的方法函数" class="headerlink" title="11.子组件调用父组件的方法函数"></a>11.子组件调用父组件的方法函数</h3><ul><li>直接在子组件中通过this.$parent.event来调用父组件的方法</li><li>在子组件里用$emit向父组件触发一个事件，父组件监听这个事件就行了</li><li>父组件把方法传入子组件中，在子组件里直接调用这个方法</li></ul><h3 id="12-路由跳转方式"><a href="#12-路由跳转方式" class="headerlink" title="12.路由跳转方式"></a>12.路由跳转方式</h3><p><code>&lt;router-link to=&#39;home&#39;&gt;</code> router-link标签会渲染为<code>&lt;a&gt;</code>标签</p><p>另一种是编程是导航 也就是通过js跳转 比如 router.push(‘/home’)</p><h3 id="13-mvvm"><a href="#13-mvvm" class="headerlink" title="13.mvvm"></a>13.mvvm</h3><ul><li><p>M - Model，Model 代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑</p></li><li><p>V - View，View 代表 UI 组件，它负责将数据模型转化为 UI 展现出来</p></li><li><p>VM - ViewModel，ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步 View 和 Model 的对象，连接 Model 和 View之间的桥梁，绑定数据到viewmodel层并自动更新渲染到页面上，视图变化通知到viewmodel层去更新数据</p></li></ul><h3 id="14-computed和watch有什么区别"><a href="#14-computed和watch有什么区别" class="headerlink" title="14.computed和watch有什么区别?"></a>14.computed和watch有什么区别?</h3><ul><li><p>computed:</p><ol><li>computed是计算属性,也就是计算值,它更多用于计算值的场景</li><li>computed具有缓存性,computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时才会重新调用对应的getter来计算</li><li>computed适用于计算比较消耗性能的计算场景</li></ol></li><li><p>watch：</p><ol><li>更多的是「观察」的作用,类似于某些数据的监听回调,用于观察props $emit或者本组件的值,当数据变化时来执行回调进行后续操作</li><li>无缓存性，页面重新渲染时值不变化也会执行</li></ol></li><li><p>小结：</p><ol><li>当我们要进行数值计算,而且依赖于其他数据，那么把这个数据设计为computed</li><li>如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化</li></ol></li></ul><h3 id="15-key"><a href="#15-key" class="headerlink" title="15.key"></a>15.key</h3><p>key是为Vue中的vnode标记的唯一id，通过这个key，我们的diff操作可以 更准确、更快速</p><ul><li><p>准确:<br>  如果不加key,那么vue会选择复用节点(Vue的就地更新策略),<br>  导致之前节点的状态被保留下来，会产生一系列的bug</p></li><li><p>快速:<br>  key的唯一性可以被Map数据结构充分利用</p></li></ul><p>预期：number | string</p><p>key 的特殊属性主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key的变化重新排列元素顺序，并且会移除 key 不存在的元素。</p><p>有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误。</p><p>最常见的用例是结合 v-for：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-for&#x3D;&quot;item in items&quot; :key&#x3D;&quot;item.id&quot;&gt;...&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure><p>它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用：</p><ul><li>完整地触发组件的生命周期钩子</li><li>触发过渡</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition&gt;</span><br><span class="line">  &lt;span :key&#x3D;&quot;text&quot;&gt;&#123;&#123; text &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;transition&gt;</span><br></pre></td></tr></table></figure><p>当 text 发生改变时，<code>&lt;span&gt;</code> 总是会被替换而不是被修改，因此会触发过渡</p><h3 id="16-组件中的data为什么是函数？"><a href="#16-组件中的data为什么是函数？" class="headerlink" title="16.组件中的data为什么是函数？"></a>16.组件中的data为什么是函数？</h3><p>组件可以被多次复用，创建多个实例，这些实例本质是同一个构造函数，如果data是对象，对象是引用类型，修改对象会影响所有实例，因此data是一个函数</p><h3 id="17-Class-与-Style-如何动态绑定？"><a href="#17-Class-与-Style-如何动态绑定？" class="headerlink" title="17.Class 与 Style 如何动态绑定？"></a>17.Class 与 Style 如何动态绑定？</h3><p>1)class<br>对象语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;&#123; &#x27;active&#x27;: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    isActive: <span class="literal">true</span>,</span><br><span class="line">    hasError: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>数组语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    activeClass: <span class="string">&#x27;active&#x27;</span>,</span><br><span class="line">    errorClass: <span class="string">&#x27;text-danger&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2)style：</p><p>对象语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=<span class="string">&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    activeColor: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">    fontSize: <span class="number">30</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=<span class="string">&quot;[styleColor, styleSize]&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    styleColor: &#123;</span><br><span class="line">       color: <span class="string">&#x27;red&#x27;</span></span><br><span class="line">     &#125;,</span><br><span class="line">    styleSize:&#123;</span><br><span class="line">       fontSize:<span class="string">&#x27;23px&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18-vue的单向数据流"><a href="#18-vue的单向数据流" class="headerlink" title="18.vue的单向数据流"></a>18.vue的单向数据流</h3><p>所有的 prop都使得其父子prop之间形成了一个单向下行绑定：<br>父级 prop的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解</p><p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。<br>这意味着你不应该在一个子组件内部改变prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。<br>子组件想修改时，只能通过 $emit派发一个自定义事件，父组件接收到后，由父组件修改</p><p>有两种常见的试图改变一个 prop 的情形 :</p><p>1)这个 prop 用来传递一个初始值:<br>这个子组件接下来希望将其作为一个本地的 prop 数据来使用，在这种情况下，最好定义一个本地的 data属性并将这个 prop 用作其初始值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">&#x27;initialCounter&#x27;</span>],</span><br><span class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter: <span class="built_in">this</span>.initialCounter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2)prop 以一种原始的值传入且需要进行转换：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">&#x27;size&#x27;</span>],</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedSize: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19-keep-alive"><a href="#19-keep-alive" class="headerlink" title="19.keep-alive"></a>19.keep-alive</h3><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p><ul><li><p>一般结合路由和动态组件一起使用，用于缓存组件；</p></li><li><p>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include表示只有名称匹配的组件会被缓存，exclude表示任何名称匹配的组件都不会被缓存 ，其中 exclude的优先级比 include 高；</p></li><li><p>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</p></li></ul><h3 id="20-v-model-的原理"><a href="#20-v-model-的原理" class="headerlink" title="20.v-model 的原理"></a>20.v-model 的原理</h3><p>vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p><ul><li>text 和 textarea 元素使用 value 属性和 input 事件；</li><li>checkbox 和 radio 使用 checked 属性和 change 事件；</li><li>select 字段将 value 作为 prop 并将 change 作为事件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model&#x3D;&#39;something&#39;&gt;</span><br><span class="line">&lt;!-- 相当于 --&gt;</span><br><span class="line">&lt;input v-bind:value&#x3D;&quot;something&quot; v-on:input&#x3D;&quot;something &#x3D; $event.target.value&quot;&gt;</span><br></pre></td></tr></table></figure><p>如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件</p><h3 id="21-nextTick"><a href="#21-nextTick" class="headerlink" title="21.nextTick()"></a>21.nextTick()</h3><p>在下次DOM更新循环结束之后执行延迟回调。在修改数据之后，立即使用的这个回调函数，获取更新后的DOM</p><h3 id="22-vue插槽"><a href="#22-vue插槽" class="headerlink" title="22.vue插槽"></a>22.vue插槽</h3><ul><li><p>单个插槽：<br>  当子组件模板只有一个没有属性的插槽时，<br>  父组件传入的整个内容片段将插入到插槽所在的 DOM 位置，<br>  并替换掉插槽标签本身</p></li><li><p>命名插槽：<br>  solt元素可以用一个特殊的特性name来进一步配置如何分发内容。<br>  多个插槽可以有不同的名字。 这样可以将父组件模板中 slot 位置，<br>  和子组件 slot 元素产生关联，便于插槽内容对应传递</p></li><li><p>作用域插槽：<br>  可以访问组件内部数据的可复用插槽(reusable slot)<br>  在父级中，具有特殊特性 slot-scope 的<code>&lt;template&gt;</code> 元素必须存在，<br>  表示它是作用域插槽的模板。slot-scope 的值将被用作一个临时变量名，<br>  此变量接收从子组件传递过来的 prop 对象</p></li></ul><h3 id="23-导航守卫"><a href="#23-导航守卫" class="headerlink" title="23.导航守卫"></a>23.导航守卫</h3><p>vue-router提供的导航守卫主要通过跳转或取消的方式守卫导航<br>参数或查询的改变不会触发进入/离开的导航守卫<br>你可以通过观察 $route 对象来应对这些变化，或使用beforeRouteUpdate 的组件内守卫</p><ul><li>全局前置守卫：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 等待中</p><p>to: Route: 即将要进入的目标 路由对象</p><p>from: Route: 当前导航正要离开的路由</p><p>next: Function: 一定要调用该方法来 resolve这个钩子。执行效果依赖 next 方法的调用参数。<br>确保要调用 next 方法，否则钩子就不会被 resolved</p><ul><li>路由独享的守卫</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">routes: [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/foo&#x27;</span>,</span><br><span class="line">    component: Foo,</span><br><span class="line">    beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>组件内的守卫</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  template: <span class="string">`...`</span>,</span><br><span class="line">  beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在渲染该组件的对应路由被 confirm 前调用</span></span><br><span class="line">    <span class="comment">// 不！能！获取组件实例 `this`</span></span><br><span class="line">    <span class="comment">// 因为当守卫执行前，组件实例还没被创建</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span><br><span class="line">    <span class="comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span><br><span class="line">    <span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 导航离开该组件的对应路由时调用</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vue-router有哪几种导航钩子</p><pre><code>第一种：是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截第二种：组件内的钩子：beforeRouteEnter/beforeRouteUpdate/beforeRouteLeave第三种：单独路由独享组件：beforeEnter</code></pre><h3 id="24-vuex是什么？"><a href="#24-vuex是什么？" class="headerlink" title="24.vuex是什么？"></a>24.vuex是什么？</h3><p>vuex是专门为vuejs应用程序开发的状态管理插件，集中存储管理组件状态，通过显式提交mutation改变组件状态<br>vuex 就是一个仓库，仓库里放了很多对象。其中 state就是数据源存放地，对应于一般 vue 对象里面的 data</p><p>state 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新</p><p>它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性</p><p>Vuex有5种属性: 分别是 state、getter、mutation、action、module;</p><ul><li><p>state<br>  Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据</p></li><li><p>mutations<br>  mutations定义的方法动态修改Vuex 的 store 中的状态或数据</p></li><li><p>getters<br>  类似vue的计算属性，主要用来过滤一些数据</p></li><li><p>actions<br>  actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action</p></li><li><p>modules<br>  由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得复杂时，store对象就变得臃肿。为了解决以上问题，vuex允许将store分隔成模块。每个模块有自己的state/getter/mutation/action,甚至是嵌套子模块。<br>总结<br>vuex 一般用于中大型 web 单页应用中对应用的状态进行管理，对于一些组件间关系较为简单的小型应用，使用 vuex 的必要性不是很大，因为完全可以用组件 prop属性或者事件来完成父子组件之间的通信，vuex 更多地用于解决跨组件通信以及作为数据中心集中式存储数据</p></li></ul><p>vuex解决了什么？<br>    多个组件依赖同一个状态，多层组件间传值<br>    来自不同的组件的行为需要变更同一个状态</p><h3 id="25-优化SPA首屏加载速度"><a href="#25-优化SPA首屏加载速度" class="headerlink" title="25.优化SPA首屏加载速度"></a>25.优化SPA首屏加载速度</h3><ul><li><p>缩小webpack或者其他打包工具生成的包的大小</p><p>  用webpack-bundle-analyzer的分析工具哪个模块占空间大</p></li><li><p>第三方UI组件按需引入</p></li><li><p>使用服务端渲染方式（基于vue的nuxt.js开发）</p></li><li><p>使用预渲染的方式</p><p>  在打包时会预先运行一次js代码，将一部分静态页面直接渲染成html写在生成的index.html中，在加载完index.html后页面就能展示，无需等待加载js缺点是在需要预渲染的页面较多时，build打包的时间会十分漫长</p></li><li><p>使用gzip减小网络传输的流量大小</p><p>  HTTP协议上的gzip编码是一种用来改进web应用程序性能的技术，web服务器和客户端（浏览器）必须共同支持gzip，使用gzip可以将原静态文件压缩到30%，效果很明显，对于优化首屏加载时间非常适合在nginx中配置<br>  http{<br>  gzip on;<br>  }</p></li><li><p>组件懒加载</p></li></ul><h3 id="26-你有对-Vue-项目进行哪些优化？"><a href="#26-你有对-Vue-项目进行哪些优化？" class="headerlink" title="26.你有对 Vue 项目进行哪些优化？"></a>26.你有对 Vue 项目进行哪些优化？</h3><p>1)代码层面的优化</p><ul><li>v-if 和 v-show 区分使用场景</li><li>computed 和 watch  区分使用场景</li><li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li><li>长列表性能优化</li><li>事件的销毁</li><li>图片资源懒加载</li><li>路由懒加载</li><li>第三方插件的按需引入</li><li>优化无限列表性能</li><li>服务端渲染 SSR or 预渲染</li><li>减少data中数据</li><li>SPA采用keep-alive缓存组件</li></ul><p>2)Webpack 层面的优化</p><ul><li>Webpack 对图片进行压缩</li><li>减少 ES6 转为 ES5 的冗余代码</li><li>提取公共代码</li><li>模板预编译</li><li>提取组件的 CSS</li><li>优化 SourceMap</li><li>构建结果输出分析</li><li>Vue 项目的编译优化</li><li>压缩代码</li><li>tree shaking</li><li>cdn加载第三方模块</li><li>sourcemap优化</li></ul><p>3)基础的 Web 技术的优化</p><ul><li>开启 gzip 压缩</li><li>浏览器缓存</li><li>CDN 的使用</li><li>使用 Chrome Performance 查找性能瓶颈</li></ul><h2 id="五-ES6"><a href="#五-ES6" class="headerlink" title="五.ES6"></a>五.ES6</h2><h3 id="1-var-let-const区别"><a href="#1-var-let-const区别" class="headerlink" title="1.var let const区别"></a>1.var let const区别</h3><p>let、const声明的变量仅在块级作用域内有效，var声明变<br>量是全局的，没有块级作用域功能<br>let 、const 不存在变量提升 , var 存在变量提升<br>let 、const不能在同一块级作用域内重复申请</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">test();<span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">test();<span class="comment">//ReferenceError: Cannot access &#x27;name&#x27; before initialization</span></span><br></pre></td></tr></table></figure><p>通过 var 声明的变量有初始值 undefined，而通过 let声明的变量直到定义的代码被执行时才会初始化。在变量初始化前访问变量会导致 ReferenceError</p><h3 id="2-解构赋值"><a href="#2-解构赋值" class="headerlink" title="2.解构赋值"></a>2.解构赋值</h3><p>1)数组解构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]   <span class="comment">//a=1, b=2, c=3</span></span><br><span class="line"><span class="keyword">let</span> [d, [e], f] = [<span class="number">1</span>, [<span class="number">2</span>], <span class="number">3</span>]    <span class="comment">//嵌套数组解构 d=1, e=2, f=3</span></span><br><span class="line"><span class="keyword">let</span> [g, ...h] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]   <span class="comment">//数组拆分 g=1, h=[2, 3]</span></span><br><span class="line"><span class="keyword">let</span> [i,,j] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]   <span class="comment">//不连续解构 i=1, j=3</span></span><br><span class="line"><span class="keyword">let</span> [k,l] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]   <span class="comment">//不完全解构 k=1, l=2</span></span><br></pre></td></tr></table></figure><p>2)对象解构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a, b&#125; = &#123;<span class="attr">a</span>: <span class="string">&#x27;aaaa&#x27;</span>, <span class="attr">b</span>: <span class="string">&#x27;bbbb&#x27;</span>&#125;      <span class="comment">//a=&#x27;aaaa&#x27; b=&#x27;bbbb&#x27;</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">d</span>: <span class="string">&#x27;aaaa&#x27;</span>, <span class="attr">e</span>: &#123;<span class="attr">f</span>: <span class="string">&#x27;bbbb&#x27;</span>&#125;&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;d, <span class="attr">e</span>:&#123;f&#125;&#125; = obj    <span class="comment">//嵌套解构 d=&#x27;aaaa&#x27; f=&#x27;bbbb&#x27;</span></span><br><span class="line"><span class="keyword">let</span> g;</span><br><span class="line">(g = &#123;<span class="attr">g</span>: <span class="string">&#x27;aaaa&#x27;</span>&#125;)   <span class="comment">//以声明变量解构 g=&#x27;aaaa&#x27;</span></span><br><span class="line"><span class="keyword">let</span> [h, i, j, k] = <span class="string">&#x27;nice&#x27;</span>    <span class="comment">//字符串解构 h=&#x27;n&#x27; i=&#x27;i&#x27; j=&#x27;c&#x27; k=&#x27;e&#x27;</span></span><br></pre></td></tr></table></figure><p>函数参数的定义  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">personInfo</span>(<span class="params">name, age, address, gender</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name, age, address, gender)</span><br><span class="line">&#125;</span><br><span class="line">personInfo(<span class="string">&#x27;william&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;changsha&#x27;</span>, <span class="string">&#x27;man&#x27;</span>)</span><br></pre></td></tr></table></figure><p>上面这个例子在对用户信息的时候需要传递四个参数，且需要一一对应，这样就会极易出现参数顺序传错的情况，从而导致bug，接下来来看es6解构赋值是怎么解决这个问题的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">personInfo</span>(<span class="params">&#123;name, age, address, gender&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name, age, address, gender)</span><br><span class="line">&#125;</span><br><span class="line">    personInfo(&#123;<span class="attr">gender</span>: <span class="string">&#x27;man&#x27;</span>, <span class="attr">address</span>: <span class="string">&#x27;changsha&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;william&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;)</span><br></pre></td></tr></table></figure><p>交换变量的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="number">1</span>, b=<span class="number">2</span>;</span><br><span class="line">[b, a] = [a, b]</span><br><span class="line"><span class="built_in">console</span>.log(a, b)</span><br></pre></td></tr></table></figure><p>函数默认参数</p><p>es5：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveInfo</span>(<span class="params">name, age, address, gender</span>) </span>&#123;</span><br><span class="line">  name = name || <span class="string">&#x27;william&#x27;</span></span><br><span class="line">  age = age || <span class="number">18</span></span><br><span class="line">  address = address || <span class="string">&#x27;changsha&#x27;</span></span><br><span class="line">  gender = gender || <span class="string">&#x27;man&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(name, age, address, gender)</span><br><span class="line">&#125;</span><br><span class="line">saveInfo()</span><br></pre></td></tr></table></figure><p>es6:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveInfo</span>(<span class="params">&#123;name= <span class="string">&#x27;william&#x27;</span>, age= <span class="number">18</span>, address= <span class="string">&#x27;changsha&#x27;</span>, gender= <span class="string">&#x27;man&#x27;</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name, age, address, gender)</span><br><span class="line">&#125;</span><br><span class="line">saveInfo()</span><br></pre></td></tr></table></figure><h3 id="3-forEach、for-in、for-of三者区别"><a href="#3-forEach、for-in、for-of三者区别" class="headerlink" title="3.forEach、for in、for of三者区别"></a>3.forEach、for in、for of三者区别</h3><ul><li><p>forEach更多的用来遍历数组，无法return或break</p></li><li><p>for in 一般常用来遍历对象或json，循环遍历的值都是数据结构的键值，也遍历数组</p></li><li><p>for of数组对象都可以遍历，遍历对象需要通过和Object.keys()一起使用<br>它是ES6中新增加的语法，用来循环获取一对键值对中的值<br>一个数据结构只有部署了 Symbol.iterator 属性, 才具有 iterator接口可以使用 for of循环<br>以下数据结构部署了 Symbol.iteratoer属性：</p><ul><li>数组</li><li>Map</li><li>Set</li><li>String</li><li>Nodelist</li><li>arguments对象<br>如果想让对象可以使用 for of循环怎么办?使用 Object.keys() 获取对象的 key值集合后,再使用 for of<br>或者使用内置的Object.values()方法获取对象的value值集合再使用for of</li></ul></li><li><p>for in循环出的是key，for of循环出的是value</p></li></ul><h3 id="4-使用箭头函数应注意什么？"><a href="#4-使用箭头函数应注意什么？" class="headerlink" title="4.使用箭头函数应注意什么？"></a>4.使用箭头函数应注意什么？</h3><ul><li>1、用了箭头函数，this就不是指向window，而是父级（指向是可变的）</li><li>2、不能够使用arguments对象</li><li>3、不能用作构造函数，这就是说不能够使用new命令，否则会抛出一个错误</li><li>4、不可以使用yield命令，因此箭头函数不能用作 Generator 函数</li></ul><h3 id="5-Set、Map的区别"><a href="#5-Set、Map的区别" class="headerlink" title="5.Set、Map的区别"></a>5.Set、Map的区别</h3><p>应用场景Set用于数据重组，Map用于数据储存</p><ul><li>Set：<br>  1，成员不能重复<br>  2，只有键值没有键名，类似数组<br>  3，可以遍历，方法有add, delete,has</li><li>Map:<br>  1，本质上是健值对的集合，类似集合<br>  2，可以遍历，可以跟各种数据格式转换</li></ul><h3 id="6-Ajax"><a href="#6-Ajax" class="headerlink" title="6.Ajax"></a>6.Ajax</h3><p>1.创建一个XmlHttpRequest对象，也就是创建一个异步调用对象<br>2.创建一个发送请求到方法，设置http请求方法，url和验证信息<br>3.设置请求状态变化到方法<br>4.发送请求<br>5.获取异步调用返回的数据<br>6.使用js和dom实现局部刷新</p><h3 id="7-同步和异步的区别"><a href="#7-同步和异步的区别" class="headerlink" title="7.同步和异步的区别"></a>7.同步和异步的区别</h3><ul><li>同步：<br>按照一定的顺序去执行，执行完一个才能执行下一个浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作</li><li>异步：<br>浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容执行顺序是不确定的，由触发条件决定，什么时间执行也是不确定的，即使是定时器（下面做解释），异步处理可以同时执行多个。</li></ul><h3 id="8-ajax的优点和缺点"><a href="#8-ajax的优点和缺点" class="headerlink" title="8.ajax的优点和缺点"></a>8.ajax的优点和缺点</h3><ul><li><p>ajax的优点<br>  1、无刷新更新数据（在不刷新整个页面的情况下维持与服务器通信）<br>  2、异步与服务器通信（使用异步的方式与服务器通信，不打断用户的操作）<br>  3、前端和后端负载均衡（将一些后端的工作交给前端，减少服务器与宽度的负担）<br>  4、界面和应用相分离（ajax将界面和应用分离也就是数据与呈现相分离）</p></li><li><p>ajax的缺点<br>  1、ajax不支持浏览器back按钮<br>  2、安全问题 Aajax暴露了与服务器交互的细节<br>  3、对搜索引擎的支持比较弱<br>  4、破坏了Back与History后退按钮的正常行为等浏览器机制</p></li></ul><h3 id="9-get和post的区别"><a href="#9-get和post的区别" class="headerlink" title="9.get和post的区别"></a>9.get和post的区别</h3><p>1、get和post在HTTP中都代表着请求数据，其中get请求相对来说更简单、快速，效率高些<br>2、get相对post安全性低<br>3、get有缓存，post没有<br>4、get体积小，post可以无限大<br>5、get的url参数可见，post不可见<br>6、get只接受ASCII字符的参数数据类型，post没有限制<br>7、get请求参数会保留历史记录，post中参数不会保留<br>8、get会被浏览器主动catch，post不会，需要手动设置<br>9、get在浏览器回退时无害，post会再次提交请求</p><h3 id="10-什么时候使用post？"><a href="#10-什么时候使用post？" class="headerlink" title="10.什么时候使用post？"></a>10.什么时候使用post？</h3><p>post一般用于修改服务器上的资源，对所发送的信息没有限制。比如<br>    1、无法使用缓存文件（更新服务器上的文件或数据库）<br>    2、向服务器发送大量数据（POST 没有数据量限制）<br>    3、发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</p><h3 id="11-同源策略"><a href="#11-同源策略" class="headerlink" title="11.同源策略"></a>11.同源策略</h3><p>同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能相互读取对方资源</p><p>同源策略限制了一个源的文档和脚本和另一个源的资源进行交互，是一个隔离潜在恶意文件攻击的安全机制</p><p>不受同源策略限制的：</p><p>1.页面中的连接，重定向和表单提交<br>2.第三方js的引入不受限制，但不能js读写加载的内容，script，link，img，iframe</p><h3 id="12-如何解决跨域问题"><a href="#12-如何解决跨域问题" class="headerlink" title="12.如何解决跨域问题?"></a>12.如何解决跨域问题?</h3><p>跨域的概念：协议、域名、端口都相同才同域，否则都是跨域</p><p>解决跨域问题：</p><p>1、 通过jsonp跨域<br>2、 document.domain + iframe跨域<br>3、 location.hash + iframe<br>4、 window.name + iframe跨域<br>5、 postMessage跨域<br>6、 跨域资源共享（CORS）<br>7、 nginx代理跨域<br>8、 nodejs中间件代理跨域<br>9、 WebSocket协议跨域</p><h2 id="六-浏览器"><a href="#六-浏览器" class="headerlink" title="六.浏览器"></a>六.浏览器</h2><h3 id="1-主流浏览器"><a href="#1-主流浏览器" class="headerlink" title="1.主流浏览器"></a>1.主流浏览器</h3><p>IE Google Chrome Firefox Opera Safari</p><h3 id="2-浏览器内核"><a href="#2-浏览器内核" class="headerlink" title="2.浏览器内核"></a>2.浏览器内核</h3><p>渲染引擎和js引擎<br>渲染引擎：用来解释网页语法并渲染到网页上</p><p>浏览器内核决定了如何显示网页内容和格式化的信息<br>Trident：IE、360<br>Gecko：火狐<br>Presto：Opera<br>Blink：Opera，Googlechrome<br>webkit：Safari</p><h3 id="3-浏览器兼容"><a href="#3-浏览器兼容" class="headerlink" title="3.浏览器兼容"></a>3.浏览器兼容</h3><p>1.不同浏览器默认内外边距不同：*{margin:0;padding:0}<br>2.图片默认有间距:img设置float<br>3. IE6双边距bug：块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大。hack：display:inline;将其转化为行内属性。<br>4. 设置较小高度标签（一般小于10px），在IE6，IE7中高度超出自己设置高度。hack：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。<br>5. Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。<br>6. 超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有hover和active了。解决方法是改变CSS属性的排列顺序:L-V-H-A ( love hate ): a:link {} a:visited {} a:hover {} a:active {}</p><h2 id="七-其他"><a href="#七-其他" class="headerlink" title="七.其他"></a>七.其他</h2><h3 id="1-前端组件化和模块化"><a href="#1-前端组件化和模块化" class="headerlink" title="1.前端组件化和模块化"></a>1.前端组件化和模块化</h3><p>组件化：组件化是具体的，按照一些功能的通用性和复用性来抽象组件侧重于UI部分，比如弹窗按钮</p><p>模块化：模块化是抽象的，按照项目业务划分的大块侧重于数据数据的封装</p><p>对于组件来说，其主要是提高代码的复用性，功能单一独立模块是将同一类型的代码整合在一起，例如用户信息，设置等，所以模块等功能相当复杂，但都同属于同一业务（提高内聚降低耦合）</p><h3 id="2-什么是Ajax和JSON，它们的优点和缺点"><a href="#2-什么是Ajax和JSON，它们的优点和缺点" class="headerlink" title="2.什么是Ajax和JSON，它们的优点和缺点"></a>2.什么是Ajax和JSON，它们的优点和缺点</h3><ul><li><p>Ajax：</p><p>  Ajax是异步JavaScript和XML，用于在Web页面中实现异步数据交互<br>  Ajax优点：<br>  异步请求响应快，用户体验好；页面无刷新、数据局部更新；按需取数据，减少了冗余请求和服务器的负担；<br>  Ajax缺点：<br>  异步回调问题、this指向问题、路由跳转back问题；对搜索引擎的支持比较弱，对于一些手机还不是很好的支持</p></li><li><p>JSON：</p><p>  是一种轻量级的数据交换格式，看着像对象，本质是字符串<br>  JSON优点：<br>  轻量级、易于人的阅读和编写，便于js解析，支持复合数据类型<br>  JSON缺点：<br>  没有XML格式这么推广的深入人心和使用广泛, 没有XML那么通用性。</p></li></ul><h3 id="3-Github"><a href="#3-Github" class="headerlink" title="3.Github"></a>3.Github</h3><p>git常用的命令<br>从远程库克隆到本地：git clone 网站上的仓库地址<br>新增文件的命令：git add .<br>提交文件的命令：git commit –m或者git commit –a<br>查看工作区状况：git status –s<br>拉取合并远程分支的操作：git fetch/git merge或者git pull<br>查看提交记录命令：git reflog</p><h3 id="4-webpack"><a href="#4-webpack" class="headerlink" title="4.webpack"></a>4.webpack</h3><p>webpack打包原理：<br>webpack只是一个打包模块的机制，只是把依赖的模块转化成可以代表这些包的静态文件。webpack就是识别你的入口文件。识别你的模块依赖，来打包你的代码。至于你的代码使用的是commonjs还是amd或者es6的import。webpack都会对其进行分析。来获取代码的依赖。webpack做的就是分析代码，转换代码，编译代码，输出代码。webpack本身是一个node的模块，所以webpack.config.js是以commonjs形式书写的(node中的模块化是commonjs规范的)</p><p>webpack 核心概念<br>1.entry<br>入口起点(entry point)指示 webpack 应该使用哪个模块,来作为构建其内部依赖图的开始. 进入入口起点后,webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。 每个依赖项随即被处理,最后输出到称之为 bundles 的文件中。</p><p>2.output<br>output 属性告诉 webpack 在哪里输出它所创建的bundles,以及如何命名这些文件,默认值为 ./dist。 基本上整个应用程序结构,都会被编译到你指定的输出路径的文件夹中。</p><p>3.Module 模块<br>在 Webpack 里一切皆模块,一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块</p><p>4.chunk 代码块<br>一个 Chunk 由多个模块组合而成,用于代码合并与分割。</p><p>5.loader<br>loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。 loader 可以将所有类型的文件转换为 webpack能够处理的有效模块,然后你就可以利用 webpack 的打包能力,对它们进行处理。 本质上,webpack loader将所有类型的文件,转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。</p><p>6.Plugin<br>loader 被用于转换某些类型的模块,而插件则可以用于执行范围更广的任务。 插件的范围包括,从打包优化和压缩,一直到重新定义环境中的变量。插件接口功能极其强大,可以用来处理各种各样的任务。</p><p>模块热更新<br>模块热更新是webpack的一个功能，他可以使代码修改过后不用刷新就可以更新，是高级版的自动刷新浏览器</p><p>devServer中通过hot属性可以控制模块的热替换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> env = process.env.NODE_ENV == <span class="string">&quot;development&quot;</span> ? <span class="string">&quot;development&quot;</span> : <span class="string">&quot;production&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  mode: env,</span><br><span class="line"> devServer: &#123;</span><br><span class="line">     hot:<span class="literal">true</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">  plugins: [</span><br><span class="line">     <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(), <span class="comment">//热加载插件</span></span><br><span class="line">  ],</span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure><p>webpack的优点</p><pre><code>专注于处理模块化的项目，能做到开箱即用，一步到位可通过plugin扩展，完整好用又不失灵活使用场景不局限于web开发社区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展良好的开发体验</code></pre><p>webpack的缺点</p><pre><code>webpack的缺点是只能用于采用模块化开发的项目</code></pre><h3 id="5-微信小程序"><a href="#5-微信小程序" class="headerlink" title="5.微信小程序"></a>5.微信小程序</h3><ul><li>onLoad()：页面加载时触发。</li><li>onReady()：页面初次渲染完成时触发。</li><li>onShow()：页面显示/切入前台时触发。</li><li>onHide()：页面隐藏/切入后台时触发。</li><li>onUnload()：页面卸载时触发。</li></ul><p>小程序运行环境分为渲染层和逻辑层，其中wxml和wxss工作在渲染层，js工作在逻辑层</p><p>小程序的渲染层和逻辑层分别由两个线程来管理：渲染层的界面使用webview来管理，逻辑层使用jscore来运行js脚本，一个小程序存在多个界面，所以渲染层有多个webview，两个线程通过微信客户端做中转，逻辑层请求网络经由客户端转发</p><h3 id="6-微信小程序支付流程"><a href="#6-微信小程序支付流程" class="headerlink" title="6.微信小程序支付流程"></a>6.微信小程序支付流程</h3><ul><li>1.wx.login用code换取openid</li><li>2.生成商户订单</li><li>3.调用支付统一下单api，返回预付单信息prepay_id</li><li>4.将组合数据再次签名，返回5个参数和sign</li><li>5.小程序获取参数后，鉴权调起支付</li><li>6.返回支付结果给小程序，推送支付结果给商户，修改订单状态</li></ul><p><img src="/ZJY.github.io/timages/weappPay.png" alt="image"></p><h3 id="7-微信网页授权流程"><a href="#7-微信网页授权流程" class="headerlink" title="7.微信网页授权流程"></a>7.微信网页授权流程</h3><p>前置条件：<br>        公众平台设置授权回调域名，在域名内页面可进行OAuth2.0鉴权</p><p>关于网页授权的两种scope的区别说明<br>1.以snsapi_base为scope发起的网页授权，是用来获取进入页面的用户的openid的，并且是静默授权跳转到回调页面的<br>2.snsapi_userinfo为scope发起的网页授权，是用来获取用户基本信息的，但是需要用户手动同意，由于用户同意过所以无需关注就可获取用户基本信息<br>3、用户管理类接口中的“获取用户基本信息接口”，是在用户和公众号产生消息交互或关注后事件推送后，才能根据用户OpenID来获取用户基本信息。这个接口，包括其他微信接口，都是需要该用户（即openid）关注了公众号后，才能调用成功的。</p><p>网页授权流程分为四步：<br>        1.引导用户进入授权页面，同意授权，获取code<br>        2.通过code换取网页授权access_token<br>        3.如果需要，刷新access_token<br>        4.通过access_token和opened获取用户基本信息</p><h3 id="8-小程序登录流程"><a href="#8-小程序登录流程" class="headerlink" title="8.小程序登录流程"></a>8.小程序登录流程</h3><p>1.wx.login()获取code，传给开发者服务器<br>2.开发者服务器用appid,appsecret,code调用登录凭证校验<br>（ auth.code2Session ）向微信服务器获取openid和sessionkey<br>3.发者服务器可以根据用户标识来生成自定义登录态，用于后<br>续业务逻辑中前后端交互时识别用户身份。</p><h3 id="9-小程序授权"><a href="#9-小程序授权" class="headerlink" title="9.小程序授权"></a>9.小程序授权</h3><p>如果用户未接受或拒绝过此权限，会弹窗询问用户，用户点击同意后方可调用接口；</p><p>如果用户已授权，可以直接调用接口；</p><p>如果用户已拒绝授权，则不会出现弹窗，而是直接进入接口fail 回调。请开发者兼容用户拒绝授权的场景。（wx.openSetting引导用户进行授权）</p><p>开发者可以使用 wx.getSetting 获取用户当前的授权状态。</p><p>微信小程序分为两个部分：webview 和 appService。其中 webview 主要用来展示 UI，appService 用来处理业务逻辑、数据及接口调用。它们在两个进程中进行，通过系统层 JSBridge 实现通信，实现 UI 的渲染、事件的处理</p><h3 id="10-网络协议"><a href="#10-网络协议" class="headerlink" title="10.网络协议"></a>10.网络协议</h3><p>网络分层<br>目前网络分层可分为两种：OSI 模型和 TCP/IP 模型<br>OSI模型</p><pre><code>应用层（Application）表示层（Presentation）会话层（Session）传输层（Transport）网络层（Network）数据链路层（Data Link）物理层（Physical）</code></pre><p>TCP/IP模型</p><pre><code>应用层（Application）传输层（Host-to-Host Transport）互联网层（Internet）网络接口层（Network Interface）</code></pre><h3 id="11-HTTP-HTTPS"><a href="#11-HTTP-HTTPS" class="headerlink" title="11.HTTP/HTTPS"></a>11.HTTP/HTTPS</h3><p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用<br>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议<br>3、http和https使用的是完全不同的连接方式，用的端口也不一样，默认前者是80，后者是443<br>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><h3 id="12-从输入URL到页面加载到过程？"><a href="#12-从输入URL到页面加载到过程？" class="headerlink" title="12.从输入URL到页面加载到过程？"></a>12.从输入URL到页面加载到过程？</h3><p>1.浏览器地址栏输入URL并回车<br>2.通过DNS将域名解析成IP地址。在解析过程中，按照浏览器缓存、系统缓存、路由器缓存、ISP(运营商)DNS缓存、根域名服务器、顶级域名服务器、主域名服务器的顺序，逐步读取缓存，直到拿到IP地址。（应用层）<br>3.根据获取IP进行tcp连接（三次握手）（传输层）<br>4.发送http请求<br>5.服务器处理请求，浏览器接收http的响应<br>6.渲染页面，构造dom树<br>7.关闭tcp连接（四次挥手）</p><h3 id="13-HTTP状态码"><a href="#13-HTTP状态码" class="headerlink" title="13.HTTP状态码"></a>13.HTTP状态码</h3><p>区分状态码<br>    1××开头  - 临时响应<br>    2××开头  - 请求成功<br>    3××开头  - 请求被重定向<br>    4××开头  - 请求错误<br>    5××开头  - 服务器错误<br>常见状态码<br>    200 - 请求成功，Ajax 接受到信息了<br>    400 - 服务器不理解请求<br>    403 - 服务器拒绝请求<br>    404 - 请求页面错误<br>    500 - 服务器内部错误，无法完成请求</p><h3 id="14-性能优化"><a href="#14-性能优化" class="headerlink" title="14.性能优化"></a>14.性能优化</h3><ul><li><p>HTML优化<br>  1、避免 HTML 中书写 CSS 代码，因为这样难以维护。<br>  2、使用 Viewport 加速页面的渲染。<br>  3、使用语义化标签，减少 CSS 代码，增加可读性和 SEO。<br>  4、减少标签的使用，DOM 解析是一个大量遍历的过程，减少不必要的标签，能降低遍历的次数。<br>  5、避免 src、href 等的值为空，因为即时它们为空，浏览器也会发起 HTTP 请求。</p></li><li><p>CSS优化<br>  1、优化选择器路径：使用 .c {} 而不是 .a .b .c {}。<br>  2、选择器合并：共同的属性内容提起出来，压缩空间和资源开销。<br>  3、精准样式：使用 padding-left: 10px 而不是 padding: 0 0 0 10px。<br>  4、雪碧图：将小的图标合并到一张图中，这样所有的图片只需要请求一次。<br>  5、避免通配符：.a .b <em>{} 这样的选择器，根据从右到左的解析顺序在解析过程中遇到通配符</em> {} 会遍历整个 DOM，性能大大损耗。<br>  6、少用 float：float 在渲染时计算量比较大，可以使用 flex 布局。<br>  7、为 0 值去单位：增加兼容性。<br>  8、压缩文件大小，减少资源下载负担。</p></li><li><p>JavaScript优化<br>  1、尽可能把 <code>&lt;script&gt;</code> 标签放在 body 之后，避免 JS 的执行卡住 DOM 的渲染，最大程度保证页面尽快地展示出来<br>  2、尽可能合并 JS 代码：提取公共方法，进行面向对象设计等……<br>  3、CSS 能做的事情，尽量不用 JS 来做，毕竟 JS 的解析执行比较粗暴，而 CSS 效率更高。<br>  4、尽可能逐条操作 DOM，并预定好 CSs 样式，从而减少 reflow 或者 repaint 的次数。<br>  5、尽可能少地创建 DOM，而是在 HTML 和 CSS 中使用 display: none 来隐藏，按需显示。<br>  6、压缩文件大小，减少资源下载负担。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试</title>
      <link href="/ZJY.github.io/2021/01/20/%E9%9D%A2%E8%AF%95/"/>
      <url>/ZJY.github.io/2021/01/20/%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="1-webpack优化"><a href="#1-webpack优化" class="headerlink" title="1.webpack优化"></a>1.webpack优化</h3><ul><li><p>优化开发体验（提升开发效率）</p><ul><li>优化构建速度 （配置时相关路径尽量写绝对路径，以减少查找，代码中写导入语句时，确定文件时带上文件后缀，以避免查找）</li><li>使用DllPlugin (动态链接库,原因在于包含大量复用模块的动态链接库只需要编译一次，在之后的构建过程中被动态链接库包含的模块将不会在重新编译，而是直接使用动态链接库中的代码)</li><li>使用HappyPack （在整个 Webpack 构建流程中，最耗时的流程可能就是 Loader 对文件的转换操作了，因为要转换的文件数据巨多，而且这些转换操作都只能一个个挨着处理。HappyPack的核心原理就是把这部分任务分解到多个进程去并行处理，从而减少了总的构建时间。）</li><li>使用ParallelUglifyPlugin (ParallelUglifyPlugin 会开启多个子进程，把对多个文件的压缩工作分配给多个子进程去完成，每个子进程其实还是通过 UglifyJS去压缩代码，但是变成了并行执行)</li></ul></li><li><p>优化使用体验</p><ul><li>使用自动刷新（使用 webpack 模块负责监听文件，webpack-dev-server 模块则负责刷新浏览器。）</li><li>使用模块热替换 （hot）</li></ul></li><li><p>优化输出质量</p><ul><li>减少用户能感知到的加载时间，也就是首屏加载<ul><li>区分环境 （开发和线上环境 代码压缩和提示日志）</li><li>压缩代码 （UglifyJsPlugin：通过封装 UglifyJS 实现压缩。ParallelUglifyPlugin：多进程并行处理压缩）</li><li>CDN加速 （CDN 又叫内容分发网络，通过把资源部署到世界各地，用户在访问时按照就近原则从离用户最近的服务器获取资源，从而加速资源的获取速度。要给网站接入 CDN，需要把网页的静态资源上传到 CDN 服务上去，在服务这些静态资源的时候需要通过 CDN 服务提供的 URL 地址去访问）</li><li>使用Tree Shaking (Tree Shaking 可以用来剔除 JavaScript 中用不上的死代码)</li><li>提取公共代码</li><li>按需加载</li></ul></li></ul></li></ul><h3 id="2-webpack如何区分环境？"><a href="#2-webpack如何区分环境？" class="headerlink" title="2.webpack如何区分环境？"></a>2.webpack如何区分环境？</h3><p>具体区分方法很简单，在源码中通过如下方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;你正在线上环境&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;你正在使用开发环境&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其大概原理是借助于环境变量的值去判断执行哪个分支</p><h3 id="3-小程序的生命周期和路由以及setData原理"><a href="#3-小程序的生命周期和路由以及setData原理" class="headerlink" title="3.小程序的生命周期和路由以及setData原理"></a>3.小程序的生命周期和路由以及setData原理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">onLaunch</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onLaunch监听小程序初始化&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">onShow</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onShow监听小程序显示&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">onHide</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onHide监听小程序隐藏&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小程序的生命周期函数的调用顺序为：onLaunch&gt;onShow&gt;onHide</p><p>页面生命周期：<br>页面生命周期函数就是当你每进入/切换到一个新的页面的时候，就会调用的生命周期函数。Page(Object) 函数用来注册一个页面。接受一个Object类型参数，其指定页面的初始数据、生命周期回调、事件处理函数等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">onLoad</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onLoad监听页面加载:首次进入页面加载时触发，可以在 onLoad 的参数中获取打开当前页面路径中的参数。&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">onReady</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onReady监听页面初次渲染完成&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">onShow</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onShow监听页面显示:加载完成后、后台切到前台或重新进入页面时触发&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">onHide</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onHide监听页面隐藏&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">onUnload</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onUnload监听页面卸载&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生命周期函数的调用顺序为：onLoad&gt;onShow&gt;onReady。</p><p>首次进入小程序会先触发应用生命周期中onLaunch方法和onShow方法，其次触发页面生命周期中onLoad、onShow和onReady方法。</p><p>前台切换到后台时，先触发页面生命周期中onHide方法，再触发应用生命周期的onHide方法。</p><p>后台切换到前台时，先触发应用生命周期中onShow方法，再触发页面生命周期的onShow方法。</p><p>setData:setData 函数用于将数据从逻辑层发送到视图层（异步），同时改变对应的 this.data 的值（同步）</p><p>setData工作原理<br>小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。当前，视图层和逻辑层的数据传输，实际上通过两边提供的 evaluateJavascript 所实现。即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。</p><p>而 evaluateJavascript 的执行会受很多方面的影响，数据到达视图层并不是实时的。</p><h3 id="4-哪些css属性可以继承？"><a href="#4-哪些css属性可以继承？" class="headerlink" title="4.哪些css属性可以继承？"></a>4.哪些css属性可以继承？</h3><p>可继承的有： font-size font-family color、<br>不可继承的有：border、padding、margin、width、height<br>与字体相关的样式通常可以继承，与尺寸相关的样式通常不能继承</p><h3 id="5-call-apply-bind都是用来重新定义this对象的"><a href="#5-call-apply-bind都是用来重新定义this对象的" class="headerlink" title="5.call/apply/bind都是用来重新定义this对象的"></a>5.call/apply/bind都是用来重新定义this对象的</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;wang&#x27;</span>,age = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;zhang&#x27;</span>,</span><br><span class="line">    objAag: <span class="built_in">this</span>.age,</span><br><span class="line">    myFun:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;年龄&#x27;</span> + <span class="built_in">this</span>.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.objAag; <span class="comment">//17</span></span><br><span class="line">obj.myFun(); <span class="comment">//zhang年龄undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用call/apply/bind</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db = &#123;</span><br><span class="line">    name:<span class="string">&#x27;dema&#x27;</span>,</span><br><span class="line">    age: <span class="number">99</span></span><br><span class="line">&#125;</span><br><span class="line">obj.myFun.call(db); <span class="comment">// dema年龄99</span></span><br><span class="line">obj.myFun.apply(db); <span class="comment">// dema年龄99</span></span><br><span class="line">obj.myFun.bind(db)(); <span class="comment">// dema年龄99</span></span><br></pre></td></tr></table></figure><p>以上除了bind多了个（）外，结果都一致，由此可知，bind返回的是一个新函数，必须调用它能执行</p><p>call/apply/bind 传参数区别</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;wang&#x27;</span>,age = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;zhang&#x27;</span>,</span><br><span class="line">    objAag: <span class="built_in">this</span>.age,</span><br><span class="line">    myFun:<span class="function"><span class="keyword">function</span>(<span class="params">fm,t</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;年龄&#x27;</span> + <span class="built_in">this</span>.age,<span class="string">&#x27;来自 &#x27;</span>+ fm+<span class="string">&#x27; 去往&#x27;</span>+t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> db = &#123;</span><br><span class="line">    name:<span class="string">&#x27;dema&#x27;</span>,</span><br><span class="line">    age: <span class="number">99</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.myFun.call(db,<span class="string">&#x27;成都&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>); <span class="comment">//dema年龄99 来自 成都 去往上海</span></span><br><span class="line">obj.myFun.apply(db,[<span class="string">&#x27;成都&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>]); <span class="comment">//dema年龄99 来自 成都 去往上海</span></span><br><span class="line">obj.myFun.bind(db,[<span class="string">&#x27;成都&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>])(); <span class="comment">//dema年龄99 来自 成都,上海 去往undefined</span></span><br><span class="line">obj.myFun.bind(db,<span class="string">&#x27;成都&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>)(); <span class="comment">//dema年龄99 来自 成都 去往上海</span></span><br><span class="line">obj.myFun.bind(db)(<span class="string">&#x27;成都&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>); <span class="comment">// dema年龄99 来自 成都 去往上海</span></span><br></pre></td></tr></table></figure><p>call 、bind 、 apply 这三个函数的第一个参数都是 this 的指向对象,第二个参数：<br>call的参数直接放进去，多个参数用逗号分隔<br>apply的第二个参数是数组<br>bind 除了返回是函数以外，它 的参数和 call 一样</p><h3 id="6-z-index属性"><a href="#6-z-index属性" class="headerlink" title="6.z-index属性"></a>6.z-index属性</h3><p>z-index 属性指定一个元素的堆叠顺序。</p><p>拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。</p><p>注释：元素可拥有负的 z-index 属性值。</p><p>注释：Z-index 仅能在定位元素上奏效（例如 position:absolute, position:relative, or position:fixed)</p><p>可能的值：</p><ul><li>auto ：默认。堆叠顺序与父元素相等。</li><li>number ：设置元素的堆叠顺序。</li><li>inherit： 规定应该从父元素继承 z-index 属性的值。</li></ul><p>默认的 z-index 是 0</p><h3 id="7-vue生命周期"><a href="#7-vue生命周期" class="headerlink" title="7.vue生命周期"></a>7.vue生命周期</h3><ul><li>beforeCreate：在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用</li><li>created：在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，property 和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el property 目前尚不可用。一般creadted钩子函数主要是用来初始化数据。</li><li>beforeMount：在挂载开始之前被调用：相关的 render 函数首次被调用。</li><li>mounted： 实例被挂载后调用，这时 el 被新创建的 vm.$el 替换了。如果根实例挂载到了一个文档内的元素上，当 mounted 被调用时 vm.$el 也在文档内。注意 mounted 不会保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 mounted 内部使用 vm.$nextTick。该钩子函数是在挂在完成以后也就是模板渲染完成以后才会被调用</li><li>beforeUpdate： 数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</li><li>updated:由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。</li><li>activated：被 keep-alive 缓存的组件激活时调用。</li><li>deactivated：被 keep-alive 缓存的组件停用时调用</li><li>beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用</li><li>destroyed： 实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁</li><li>errorCaptured：当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。</li></ul><h3 id="8-JavaScript的let和const"><a href="#8-JavaScript的let和const" class="headerlink" title="8.JavaScript的let和const"></a>8.JavaScript的let和const</h3><p>ES2015(ES6) 新增加了两个重要的 JavaScript 关键字: let 和 const。</p><p>let 声明的变量只能let命令所在代码块内有效<br>const声明一个只读的常量，一旦声明了值，该值就不能改变。</p><p>在 ES6 之前，JavaScript 只有两种作用域： 全局变量 与 函数内的局部变量。</p><p>全局变量：</p><p>在函数外声明的变量是全局的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> carName = <span class="string">&quot;Volvo&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这里可以使用 carName 变量</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里也可以使用 carName 变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局变量在js程序的任何地方都可用</p><p>局部变量：<br>在函数内部声明的变量的作用域是局部的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里不能使用 carName 变量</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> carName = <span class="string">&quot;Volvo&quot;</span>;</span><br><span class="line">    <span class="comment">// 这里可以使用 carName 变量</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这里不能使用 carName 变量</span></span><br></pre></td></tr></table></figure><p>函数内使用var声明的变量只能在函数内部可用，没有用var声明的变量全局可用</p><p>javascript的块级作用域：<br>使用var声明的变量不具有块级作用域的特性，在{}外仍然能使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">2</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里可以使用 x 变量</span></span><br></pre></td></tr></table></figure><p>在es6之前没有块级作用域的概念<br>es6可以使用let关键字来实现块级作用域<br>let 声明的变量只在 let 命令所在的代码块 {} 内有效，在 {} 之外不能访问。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里不能使用 x 变量</span></span><br></pre></td></tr></table></figure><p>重新定义变量：</p><p>使用var关键字重新声明变量会带来问题<br>在块中重新声明变量也会重新声明块外的变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 这里输出 x 为 10</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 这里输出 x 为 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里输出 x 为 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>let 关键字就可以解决这个问题，因为它只在 let 命令所在的代码块 {} 内有效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 这里输出 x 为 10</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 这里输出 x 为 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里输出 x 为 10</span></span><br></pre></td></tr></table></figure><p>循环作用域：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一些代码...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里输出 i 为 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一些代码...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里输出 i 为 5</span></span><br></pre></td></tr></table></figure><p>在第一个实例中，使用了 var 关键字，它声明的变量是全局的，包括循环体内与循环体外。</p><p>在第二个实例中，使用 let 关键字， 它声明的变量作用域只在循环体内，循环体外的变量不受影响。</p><p>局部变量：</p><p>在函数体内使用 var 和 let 关键字声明的变量有点类似。</p><p>它们的作用域都是 局部的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 var</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> carName = <span class="string">&quot;Volvo&quot;</span>;   <span class="comment">// 局部作用域</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 let</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> carName = <span class="string">&quot;Volvo&quot;</span>;   <span class="comment">//  局部作用域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局变量<br>在函数体外或代码块外使用 var 和 let 关键字声明的变量也有点类似。</p><p>它们的作用域都是 全局的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 var</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;       <span class="comment">// 全局作用域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 let</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">2</span>;       <span class="comment">// 全局作用域</span></span><br></pre></td></tr></table></figure><p>HTML 代码中使用全局变量:<br>在JavaScript中，全局作用域是针对JavaScript环境<br>在html中，全局作用域是指window对象</p><p>使用var关键字声明的全局作用域变量是属于 window 对象:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> carName = <span class="string">&quot;Volvo&quot;</span>;</span><br><span class="line"><span class="comment">// 可以使用 window.carName 访问变量</span></span><br></pre></td></tr></table></figure><p>使用let声明的全局作用域变量不属于window对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> carName = <span class="string">&quot;Volvo&quot;</span>;</span><br><span class="line"><span class="comment">// 不能使用 window.carName 访问变量</span></span><br></pre></td></tr></table></figure><p>重置变量：</p><p>使用var关键字声明的变量任何地方都可以修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// x 为 2</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 现在 x 为 3</span></span><br></pre></td></tr></table></figure><p>在相同的作用域下，不能使用let来重置var声明的变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;       <span class="comment">// 合法</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">3</span>;       <span class="comment">// 不合法</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">4</span>;   <span class="comment">// 合法</span></span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>   <span class="comment">// 不合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在相同的作用域下，不能使用let重置let声明的变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">2</span>;       <span class="comment">// 合法</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">3</span>;       <span class="comment">// 不合法</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">4</span>;   <span class="comment">// 合法</span></span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;   <span class="comment">// 不合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在相同作用域下，不能使用var关键字来重置let声明的变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">2</span>;       <span class="comment">// 合法</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;       <span class="comment">// 不合法</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">4</span>;   <span class="comment">// 合法</span></span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">5</span>;   <span class="comment">// 不合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>let 关键字在不同作用域，或不同块级作用域中是可以重新声明赋值的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">2</span>;       <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">3</span>;   <span class="comment">// 合法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">4</span>;   <span class="comment">// 合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量提升：</p><p>js中，var声明的变量可以先使用后声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在这里可以使用 carName 变量</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> carName;</span><br></pre></td></tr></table></figure><p>let声明的变量不可以先使用再声明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在这里不可以使用 carName 变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> carName;</span><br></pre></td></tr></table></figure><p>const关键字<br>const用来声明一个或多个常量值，声明时必须进行初始化，且初始化后不可以再修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.141592653589793</span>;</span><br><span class="line">PI = <span class="number">3.14</span>;      <span class="comment">// 报错</span></span><br><span class="line">PI = PI + <span class="number">10</span>;   <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>const和let定义变量的类似：</p><ul><li>二者都是块级作用域</li><li>都不能和所在作用域内其他变量或函数同名</li></ul><p>两者区别：</p><ul><li>const声明变量必须初始化，let可以不用初始化</li><li>const初始化后不可以修改，let初始化后可以修改</li></ul><p>const并非是一个真正的常量<br>const 的本质: const 定义的变量并非常量，并非不可变，它定义了一个常量引用一个值。使用 const 定义的对象或者数组，其实是可变的。下面的代码并不会报错：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建常量对象</span></span><br><span class="line"><span class="keyword">const</span> car = &#123;<span class="attr">type</span>:<span class="string">&quot;Fiat&quot;</span>, <span class="attr">model</span>:<span class="string">&quot;500&quot;</span>, <span class="attr">color</span>:<span class="string">&quot;white&quot;</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 修改属性:</span></span><br><span class="line">car.color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 添加属性</span></span><br><span class="line">car.owner = <span class="string">&quot;Johnson&quot;</span>;</span><br></pre></td></tr></table></figure><p>但不能对常量对象重新赋值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> car = &#123;<span class="attr">type</span>:<span class="string">&quot;Fiat&quot;</span>, <span class="attr">model</span>:<span class="string">&quot;500&quot;</span>, <span class="attr">color</span>:<span class="string">&quot;white&quot;</span>&#125;;</span><br><span class="line">car = &#123;<span class="attr">type</span>:<span class="string">&quot;Volvo&quot;</span>, <span class="attr">model</span>:<span class="string">&quot;EX60&quot;</span>, <span class="attr">color</span>:<span class="string">&quot;red&quot;</span>&#125;;    <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>在相同的作用域或块级作用域中，不能使用 const 关键字来重置 var 和 let关键字声明的变量:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;         <span class="comment">// 合法</span></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">2</span>;       <span class="comment">// 不合法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span>;     <span class="comment">// 合法</span></span><br><span class="line">    <span class="keyword">const</span> x = <span class="number">2</span>;   <span class="comment">// 不合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在相同的作用域或块级作用域中，不能使用 const 关键字来重置 const 关键字声明的变量:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">2</span>;       <span class="comment">// 合法</span></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">3</span>;       <span class="comment">// 不合法</span></span><br><span class="line">x = <span class="number">3</span>;             <span class="comment">// 不合法</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;         <span class="comment">// 不合法</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">3</span>;         <span class="comment">// 不合法</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> x = <span class="number">2</span>;   <span class="comment">// 合法</span></span><br><span class="line">    <span class="keyword">const</span> x = <span class="number">3</span>;   <span class="comment">// 不合法</span></span><br><span class="line">    x = <span class="number">3</span>;         <span class="comment">// 不合法</span></span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">3</span>;     <span class="comment">// 不合法</span></span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">3</span>;     <span class="comment">// 不合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>const 关键字在不同作用域，或不同块级作用域中是可以重新声明赋值的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">2</span>;       <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> x = <span class="number">3</span>;   <span class="comment">// 合法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> x = <span class="number">4</span>;   <span class="comment">// 合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>const 关键字定义的变量则不可以在使用后声明，也就是变量需要先声明再使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">carName = <span class="string">&quot;Volvo&quot;</span>;    <span class="comment">// 在这里不可以使用 carName 变量</span></span><br><span class="line"><span class="keyword">const</span> carName = <span class="string">&quot;Volvo&quot;</span></span><br></pre></td></tr></table></figure><h3 id="9-箭头函数"><a href="#9-箭头函数" class="headerlink" title="9.箭头函数"></a>9.箭头函数</h3><p>ES6 之前，JavaScript 的 this 对象一直很令人头大，回调函数，经常看到 var self = this 这样的代码，为了将外部 this 传递到回调函数中，那么有了箭头函数，就不需要这样做了，直接使用 this 就行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">&#x27;sayHello&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line">Person.sayHello();  <span class="comment">// 20</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> Person1 = &#123;</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">&#x27;sayHello&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line">Person1.sayHello();  <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>当我们需要维护this上下文的时候，使用箭头函数</p><p>箭头函数：<br>箭头函数提供了一种更加简洁的函数书写方式。基本语法是：<br>参数 =&gt; 函数体</p><p>基本用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>);  <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>当箭头函数没有参数或者有多个参数，要用 () 括起来:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">a,b</span>) =&gt;</span> a+b;</span><br><span class="line">f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">//8</span></span><br></pre></td></tr></table></figure><p>当箭头函数函数体有多行语句，用 {} 包裹起来，表示代码块，当只有一行语句，并且需要返回结果时，可以省略 {} , 结果会自动返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">a,b</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">let</span> result = a+b;</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p>当箭头函数要返回对象的时候，为了区分于代码块，要用 () 将对象包裹起来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">id,name</span>) =&gt;</span> &#123;<span class="attr">id</span>: id, <span class="attr">name</span>: name&#125;;</span><br><span class="line">f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">// SyntaxError: Unexpected token :</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">id,name</span>) =&gt;</span> (&#123;<span class="attr">id</span>: id, <span class="attr">name</span>: name&#125;);</span><br><span class="line">f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">// &#123;id: 6, name: 2&#125;</span></span><br></pre></td></tr></table></figure><p>注意点：没有 this、super、arguments 和 new.target 绑定。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 箭头函数里面没有 this 对象，</span></span><br><span class="line">  <span class="comment">// 此时的 this 是外层的 this 对象，即 Window </span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">func(<span class="number">55</span>)  <span class="comment">// Window </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> func = <span class="function">() =&gt;</span> &#123;    </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">func(<span class="number">55</span>);  <span class="comment">// ReferenceError: arguments is not defined</span></span><br></pre></td></tr></table></figure><p>箭头函数体中的 this 对象，是定义函数时的对象，而不是使用函数时的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 定义时，this 绑定的是 fn 中的 this 对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// fn 的 this 对象为 &#123;a: 19&#125;</span></span><br><span class="line">fn.call(&#123;<span class="attr">a</span>: <span class="number">18</span>&#125;);  <span class="comment">// 18</span></span><br></pre></td></tr></table></figure><p>不可以作为构造函数，也就是不能使用 new 命令，否则会报错</p><h3 id="10-vuex页面刷新数据保持不变"><a href="#10-vuex页面刷新数据保持不变" class="headerlink" title="10.vuex页面刷新数据保持不变"></a>10.vuex页面刷新数据保持不变</h3><p>用vuex做全局状态管理的时候，页面刷新，数据会丢失，是因为store中的数据是保存在运行内存中的，页面刷新时就会重新加载vue实例，store会被重新赋值。<br>解决方法：</p><p>方案一：<br>由于state中的数据是响应式的，而数据又是通过mutation来修改的，所以在mutation修改state数据时调用localStorage.setItem()方法来进行数据的存储：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        orderList:[],</span><br><span class="line">        menuList:[]</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        <span class="function"><span class="title">orderList</span>(<span class="params">state,data</span>)</span>&#123;</span><br><span class="line">            state.orderList = data;</span><br><span class="line">            <span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;orderList&#x27;</span>, <span class="built_in">JSON</span>.stringify(data))</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">menuList</span>(<span class="params">state,data</span>)</span>&#123;</span><br><span class="line">            state.menuList = data;</span><br><span class="line">            <span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;menuList&#x27;</span>, <span class="built_in">JSON</span>.stringify(data))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在页面加载的时候再通过localStorage.getItem()方法将值取出放回vuex，可在app.vue的created方法中写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.localStorage.getItem(<span class="string">&#x27;orderList&#x27;</span>))&#123;</span><br><span class="line">        <span class="built_in">this</span>.$store.replaceState(<span class="built_in">Object</span>.assign(&#123;&#125;, <span class="built_in">this</span>.$store.state, <span class="built_in">JSON</span>.parse(<span class="built_in">window</span>.localStorage.getItem(<span class="string">&#x27;orderList&#x27;</span>))))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方案二：<br>方案一能够顺利解决问题，但不断触发localStorage.setItem()方法对性能不是特别友好，而且一直将数据同步到localStorage中似乎就没必要再用vuex做状态管理，直接用localStorage即可，于是对以上解决方法进行了改进，通过监听beforeunload事件来进行数据的localStorage存储，beforeunload事件在页面刷新时进行触发，具体做法是在App.vue的created()周期函数中下如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.localStorage.getItem(<span class="string">&#x27;orderList&#x27;</span>))&#123;</span><br><span class="line">        <span class="built_in">this</span>.$store.replaceState(<span class="built_in">Object</span>.assign(&#123;&#125;, <span class="built_in">this</span>.$store.state, <span class="built_in">JSON</span>.parse(<span class="built_in">window</span>.localStorage.getItem(<span class="string">&#x27;orderList&#x27;</span>))))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;beforeunload&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.localStorage.setItem(<span class="string">&quot;orderList&quot;</span>,<span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>.$store.state.orderList))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-公众号openid和unionid的区别"><a href="#11-公众号openid和unionid的区别" class="headerlink" title="11.公众号openid和unionid的区别"></a>11.公众号openid和unionid的区别</h3><ul><li>微信openid和unionid长度是不一样的：openid=28，unionid=29</li><li>openid同一用户同一应用唯一，unionid同一用户不同应用唯一<ul><li>这里的不同应用是指在同一微信开发平台下的不同应用</li><li>为了识别用户，每个用户针对每个公众号会产生一个安全的openid</li><li>一个用户虽然对多个公众号和应用有多个不同的openid，但他对所有这些同一开放平台账号下的公众号和应用，只有一个unionid</li></ul></li></ul><h3 id="12-axios统一封装"><a href="#12-axios统一封装" class="headerlink" title="12.axios统一封装"></a>12.axios统一封装</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> _axios = axios.create();</span><br><span class="line"></span><br><span class="line">_axios.default.baseURL = <span class="string">&#x27;requesturl&#x27;</span>;</span><br><span class="line">_axios.interceptors.request.use(<span class="function"><span class="keyword">function</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 在发送请求前做些什么</span></span><br><span class="line">    config =&gt; &#123;</span><br><span class="line">        config.withCredentials = <span class="literal">true</span>; <span class="comment">// 允许携带token ,这个是解决跨域产生的相关问题</span></span><br><span class="line">        config.timeout = <span class="number">12000</span>;</span><br><span class="line">        config.headers = &#123;</span><br><span class="line">            <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    config.headers[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="string">`<span class="subst">$&#123;<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;token&#x27;</span>)&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加相应拦截器</span></span><br><span class="line">_axios.interceptors.response.use(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(response.data.code == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> response.data</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(response.data.message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 对相应错误做些什么</span></span><br><span class="line">    <span class="function"><span class="title">swtich</span>(<span class="params">error.response.status</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">401</span>:</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">403</span>:</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">500</span>:</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> _axios;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用axios</span></span><br><span class="line"><span class="keyword">import</span> _axios <span class="keyword">from</span> <span class="string">&#x27;./axios&#x27;</span>;</span><br><span class="line"><span class="comment">// 接口定义</span></span><br><span class="line"><span class="function"><span class="title">getList</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _axios(&#123;</span><br><span class="line">        method: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">        url:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        params:&#123;data&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">postList</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _axios(&#123;</span><br><span class="line">        method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">        url:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        data:&#123;data&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 页面接口调用</span></span><br><span class="line">getList(data).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>12.webpack</p><p>loader和plugin的使用</p><ul><li>loader：下载、使用</li><li>plugin: 下载、引入、使用</li></ul><p>配置文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;resolve&#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">&#x27;./src/index.js&#x27;</span>, <span class="comment">//打包的入口文件</span></span><br><span class="line">    output:&#123;</span><br><span class="line">        <span class="comment">// 输出的文件名，以及文件路径</span></span><br><span class="line">        filename: <span class="string">&#x27;build.js&#x27;</span>, <span class="comment">//输出的文件名</span></span><br><span class="line">        path: resolve(__dirname,<span class="string">&#x27;build&#x27;</span>) <span class="comment">//// 当前路径(__dirname)的build文件夹</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        <span class="comment">// 在此配置loader</span></span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>, <span class="comment">//表示匹配以css结尾的文件</span></span><br><span class="line">                use:[</span><br><span class="line">                    <span class="comment">// 使用以下loader进行编译从下往上</span></span><br><span class="line">                    <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test:<span class="regexp">/\.(png|svg|jpg|gif)&amp;/</span>,</span><br><span class="line">                use:[</span><br><span class="line">                    <span class="string">&#x27;file-loader&#x27;</span> <span class="comment">//在Css中有背景和图标等图片，需要安装file-loader来处理</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="comment">// 在此配置插件，插件的作用比loader要强，如压缩编译转换等</span></span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin(), <span class="comment">//清理 /dist 文件夹</span></span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">           title: <span class="string">&#x27;Output Management&#x27;</span></span><br><span class="line">        &#125;), <span class="comment">//生成html文件</span></span><br><span class="line">    ],</span><br><span class="line">      mode: <span class="string">&quot;development&quot;</span>  <span class="comment">//配置当前打包环境 development-开发环境、production-生产环境 （生产环境会压缩代码）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用loader(按顺序引入)</p><p>处理 css</p><ul><li>style-loader</li><li>css-loader</li></ul><p>处理 less</p><ul><li>style-loader</li><li>css-loader</li><li>less-loader(less-loader依赖less，要一起安装)</li></ul><p>处理css图片资源</p><ul><li>url-loader(依赖file-loader,可一并安装)</li></ul><p>处理html图片资源</p><ul><li>html-loader</li></ul><p>处理其他资源(如：字体文件等)</p><ul><li>file-loader</li></ul><p>常用plugins</p><ul><li>html-webpack-plugin</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hwp = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>)</span><br><span class="line"><span class="keyword">new</span> hwp(&#123;</span><br><span class="line">  template:<span class="string">&quot;./src/index.html&quot;</span>，  <span class="comment">//以该文件为模板进行复制打包</span></span><br><span class="line">  minify:&#123;</span><br><span class="line">    collapseWhitespace:<span class="literal">true</span>, <span class="comment">//压缩空格</span></span><br><span class="line">    removeComments:<span class="literal">true</span> <span class="comment">// 去除注释</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>clean-webpack-plugin</li></ul><h3 id="13-数组的toString方法"><a href="#13-数组的toString方法" class="headerlink" title="13.数组的toString方法"></a>13.数组的toString方法</h3><p>数组的toString方法会将数组的每个元素转换为字符串，有逗号拼接并且没有其他界定符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].toString()</span><br><span class="line"><span class="string">&quot;1,2,3&quot;</span></span><br><span class="line">[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>].toString()</span><br><span class="line"><span class="string">&quot;a,b,c&quot;</span></span><br><span class="line">[<span class="number">1</span>,[<span class="number">2</span>,<span class="string">&quot;c&quot;</span>]].toString()</span><br><span class="line"><span class="string">&quot;1,2,c&quot;</span></span><br></pre></td></tr></table></figure><h3 id="14-对象的toString方法"><a href="#14-对象的toString方法" class="headerlink" title="14.对象的toString方法"></a>14.对象的toString方法</h3><p>对象的toString方法没有任何参数，返回一个字符串，该方法返回的是调用它的对象的类型或值。<br>当使用“+”运算符把一个字符串和一个对象连接一起或把一个对象传递给alert()或document.write()时，会调用toString方法。</p><p>默认的toString方法返回的字符串形式总是[object class],class是对象的内部类型，通常对应的是该对象的构造函数名。例如，Array对象的class值是Array，Function对象的class值是“Function”，Date对象的class值是“Date”，内部Math对象的class值是“Math”，所有Error对象的的class值是“Error”，用户定义的对象（例如Complex）的class值是“Object”。</p><h3 id="15-怎样判断一个对象是不是数组？"><a href="#15-怎样判断一个对象是不是数组？" class="headerlink" title="15.怎样判断一个对象是不是数组？"></a>15.怎样判断一个对象是不是数组？</h3><ul><li>从原型入手，Array.prototype.isPrototypeOf(obj);<br>利用isPrototypeOf()方法判断Array是否在obj的原型链上</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.isPrototypeOf([]); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.isPrototypeOf(&#123;&#125;); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><ul><li>用instanceof, obj instanceof Array<br>instanceof检测构造函数的prototype属性是否存在实例对象的原型链上</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure><ul><li>Object.prototype.toString.call(obj)<br>根据对象的class属性，跨原型链调用toString方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]); <span class="comment">//&quot;[object Array]&quot;</span></span><br></pre></td></tr></table></figure><ul><li>Array.isArray()</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray([]); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="16-js解决苹果移动端300ms延迟的问题"><a href="#16-js解决苹果移动端300ms延迟的问题" class="headerlink" title="16.js解决苹果移动端300ms延迟的问题"></a>16.js解决苹果移动端300ms延迟的问题</h3><p>做移动端页面开发的可能会了解到，ios系统click事件会有卡顿的现象，这个问题的根源是苹果本身自带的safari有双击放大页面的功能，再次双击会返回到原始尺寸，所以在第一次点击的系统会延迟300ms来判断是不是双击操作，为了解决这个问题，网上也给了解决的办法，把click事件绑定到ontouchstart事件上，这样就解决了300ms延迟的问题，这个文件是fastclick.js</p><h3 id="17-tcp三次握手"><a href="#17-tcp三次握手" class="headerlink" title="17.tcp三次握手"></a>17.tcp三次握手</h3><p>为了准确无误将数据送达目标处，TCP协议采取了三次握手协议。<br>用tcp协议将数据包送出去后，tcp不会对发送后的情况置之不理，它一定向对方确认是否收到。</p><ul><li>1.发送端首先发送带SYN标志的数据给对方。</li><li>2.接收方收到后回传一个SYN/ACK标志的数据包以示传达确认信息。</li><li>3.最后，发送端再回传一个带ACK标志的字段，代表握手结束</li></ul><p>若在握手过程中某个阶段被打断，TCP会再次以相同的顺序发送数据包。</p><h3 id="18-四次挥手"><a href="#18-四次挥手" class="headerlink" title="18.四次挥手"></a>18.四次挥手</h3><p>第一次：客户端请求断开FIN,seq=u<br>第二次：服务器确认客户端的断开请求ACK,ack=u+1,seq=v<br>第三次：服务器请求断开FIN,seq=w,ACK,ack=u+1<br>第四次：客户端确认服务器的断开ACK,ack=w+1,seq=u+1</p><h3 id="19-osi模型"><a href="#19-osi模型" class="headerlink" title="19.osi模型"></a>19.osi模型</h3><ul><li>应用层：提供应用程序间通道</li><li>表示层：处理数据格式、数据加密等</li><li>会话层：建立、维护和管理会话</li><li>传输层：建立主机端到端的连接</li><li>网络层：寻址和路由选择</li><li>数据链路层：提供介质访问，链路管理等</li><li>物理层：比特流传输</li></ul><h3 id="20-vue-minxins"><a href="#20-vue-minxins" class="headerlink" title="20.vue minxins"></a>20.vue minxins</h3><p>mixins定义：mixins选项接受一个混入对象的数组，类型：<code>Array&lt;Object&gt;</code></p><p>mixins原理：真正的实现是靠mergeOptions函数实现的。</p><p>这个函数传进去的两个参数分别是this.options 和 mixin，而mergeOptions函数则实现了递归遍历this.options，然后执行mergeField，返回最终合并的this.options<br>mergeField函数：一般我们执行mergeField 里的key基本上就是上面strats的属性了，用的最多的可能就是data、methods、props了，所以如果我们在mixins中用到了data，其本质上就是合并当前vue实例对象里的data和我们传进去的mixin里的data，其他属性也是一样的</p><p>合并策略：<br>1.data<br>mixins中的data会合并到实例中的data中，有冲突的话，实例中data的数据会覆盖mixins中的数据</p><p><img src="/ZJY.github.io/images/minxins1.png" alt="image"></p><p>2.钩子函数<br>mixins中和实例中的钩子函数，都会执行，先执行mixins中的钩子函数</p><p><img src="/ZJY.github.io/images/minxins2.png" alt="image"></p><p>3.methods、components、directives<br>methods、components、directives会执行，当有冲突的时候，实例中的会覆盖mixins中的</p><p><img src="/ZJY.github.io/images/minxins3.png" alt="image"></p><h3 id="21-git常用命令"><a href="#21-git常用命令" class="headerlink" title="21.git常用命令"></a>21.git常用命令</h3><p>创建仓库：<br>git init</p><p>提交代码相关：</p><ul><li>把当工作区文件加到暂存区<ul><li>单个文件加入：git add x.js</li><li>全部文件加入: git add .</li></ul></li><li>把暂存区的内容提交到本地仓库: git commit -m “xxx”</li><li>克隆一下远程仓库到本地:<br>git clone <a href="mailto:&#103;&#x69;&#x74;&#64;&#103;&#105;&#116;&#x68;&#x75;&#x62;&#x2e;&#99;&#111;&#109;">&#103;&#x69;&#x74;&#64;&#103;&#105;&#116;&#x68;&#x75;&#x62;&#x2e;&#99;&#111;&#109;</a>:michaelliao/gitskills.git<br>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。</li><li>添加一个远程仓库:git remote add origin <a href="mailto:&#x67;&#105;&#x74;&#64;&#103;&#x69;&#116;&#x68;&#x75;&#98;&#46;&#99;&#x6f;&#109;">&#x67;&#105;&#x74;&#64;&#103;&#x69;&#116;&#x68;&#x75;&#98;&#46;&#99;&#x6f;&#109;</a>:michaelliao/learngit.git</li><li>本地库的所有内容推送到远程库上:git push -u origin master</li><li>提交日志查看（详细）:git log</li><li>提交查看（简洁版）:git log –pretty=oneline</li><li>指定本地dev分支与远程origin/dev分支的链接:git branch –set-upstream-to=origin/dev dev</li></ul><p>版本回退:</p><ul><li>回到上一个版本:git reset –hard HEAD^</li><li>回到上倒数第3个版本:git reset –hard HEAD^^^</li><li>回到指定版本:git reset –hard 1094a</li></ul><p>撤销更改:<br>丢弃修改，这个文件回到最近一次git commit或git add时的状态。类似svn revert命令。<br>git checkout – readme.txt</p><p>删除本地分支 :git branch -d 本地分支名<br>删除远程分支:<br>git push origin –delete 分支名<br>git branch -r -d origin/branchName<br>git push origin :branchName</p><h3 id="22-vue中的虚拟dom"><a href="#22-vue中的虚拟dom" class="headerlink" title="22.vue中的虚拟dom"></a>22.vue中的虚拟dom</h3><p>1.什么是虚拟DOM<br>虚拟DOM 表现为一个 Object对象。并且最少包含标签名 (tag)、属性 (attrs) 和子元素对象 (children) 三个属性<br>创建虚拟DOM就是为了更好将虚拟的节点渲染到页面视图中，所以虚拟DOM对象的节点与真实DOM的属性一一照应</p><p>2.为什么需要虚拟DOM<br>DOM是很慢的，其元素非常庞大，页面的性能问题，大部分都是由DOM操作引起的</p><p>真实的DOM节点，哪怕一个最简单的div也包含着很多属性<br>操作DOM的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户的体验</p><p>3.Diff原理<br>diff算法就是进行虚拟节点对比，并返回一个patch对象，用来存储两个节点不同的地方，最后用patch记录的消息去局部更新Dom。通俗的讲就是：diff的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的DOM打补丁<br>通过diff算法比较 新 旧 两个VDOM，将不同的地方进行修改，相同的地方就地复用，最后再通过render函数渲染页面</p><h3 id="23-vue双向绑定原理"><a href="#23-vue双向绑定原理" class="headerlink" title="23.vue双向绑定原理"></a>23.vue双向绑定原理</h3><p>vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p><h3 id="24-on-once-emit-off"><a href="#24-on-once-emit-off" class="headerlink" title="24.$on,$once,$emit,$off"></a>24.$on,$once,$emit,$off</h3><p>vm.$on( event, callback ):<br>监听当前实例上的自定义事件。事件可以由 vm.$emit 触发。回调函数会接收所有传入事件触发函数的额外参数</p><p>vm.$once( event, callback ):<br>监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除</p><p>vm.$off( [event, callback] ):<br>移除自定义事件监听器。</p><p>如果没有提供参数，则移除所有的事件监听器；</p><p>如果只提供了事件，则移除该事件所有的监听器；</p><p>如果同时提供了事件与回调，则只移除这个回调的监听器</p><p>vm.$emit( eventName, […args] ):<br>触发当前实例上的事件。附加参数都会传给监听器回调。</p><h3 id="25-vue的响应式原理，数组的变异检测"><a href="#25-vue的响应式原理，数组的变异检测" class="headerlink" title="25.vue的响应式原理，数组的变异检测"></a>25.vue的响应式原理，数组的变异检测</h3><p>当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。</p><p>这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更</p><p>每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。</p><p>检测变化的注意事项<br>由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。尽管如此我们还是有一些办法来回避这些限制并保证它们的响应性。</p><p>对于对象：<br>Vue 无法检测 property 的添加或移除。由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 data 对象上存在才能让 Vue 将它转换为响应式的</p><p>对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式 property</p><p>对于数组：<br>Vue 不能检测以下数组的变动：<br>当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue<br>当你修改数组的长度时，例如：vm.items.length = newLength</p><p>为了解决第一类问题，以下两种方式都可以实现和 vm.items[indexOfItem] = newValue 相同的效果，同时也将在响应式系统内触发状态更新：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line">Vue.set(vm.items, indexOfItem, newValue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.prototype.splice</span></span><br><span class="line">vm.items.splice(indexOfItem, <span class="number">1</span>, newValue)</span><br></pre></td></tr></table></figure><p>为了解决第二类问题，你可以使用 splice:vm.items.splice(indexOfItem, 1, newValue)</p><p>异步更新队列:</p><p>可能你还没有注意到，Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替</p><h3 id="26-vue-loader"><a href="#26-vue-loader" class="headerlink" title="26.vue-loader"></a>26.vue-loader</h3><p>vue-loader作用：<br>解析和转换.vue文件，提取出其中的逻辑代码script，样式代码style，以及html模版template，再分别把他们交给对应的loader去处理</p><p>用途：js可以写es6,style样式可以写scss或less</p><p>css-loader：加载由 vue-loader 提取出的 CSS 代码。<br>vue-template-compiler：把vue-loader提取出的HTML模板编译成可执行的jacascript代码</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-symbol原始数据类型</title>
      <link href="/ZJY.github.io/2021/01/20/javascript-symbol%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/ZJY.github.io/2021/01/20/javascript-symbol%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：</p><p>undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p><p>Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> s</span><br><span class="line"><span class="comment">// &quot;symbol&quot;</span></span><br></pre></td></tr></table></figure><p>注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p><p>Symbol函数可以接受一个字符串作为参数，表示对 Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p><p>注意，Symbol函数的参数只是表示对当前 Symbol值的描述，因此相同参数的Symbol函数的返回值是不相等的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript this 关键字</title>
      <link href="/ZJY.github.io/2021/01/20/javasctipt%E7%9A%84this%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/ZJY.github.io/2021/01/20/javasctipt%E7%9A%84this%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript-this-关键字"><a href="#JavaScript-this-关键字" class="headerlink" title="JavaScript this 关键字"></a>JavaScript this 关键字</h2><p>面向对象语言中this表示对对象的一个引用。</p><p>但在javascript中，this不是固定不变的，它随执行环境的改变而改变。</p><ul><li>在方法中，this表示该方法所属的对象。</li><li>如果单独使用，this代表全局对象</li><li>在函数中，this代表全局对象</li><li>在函数中，严格模式下，this是未定义的undefined</li><li>在事件中，this表示接收事件的元素</li><li>类似call(),apply(),bind()可以将this引用到任何对象</li></ul><p>实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  lastName : <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">  id       : <span class="number">5566</span>,</span><br><span class="line">  fullName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法中的this"><a href="#方法中的this" class="headerlink" title="方法中的this"></a>方法中的this</h3><p>在对象方法中，this指向调用它所在方法的对象。</p><p>上面实例中，this指person对象。<br>fullName 方法所属的对象就是 person。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.fullName(); <span class="comment">// John Doe</span></span><br></pre></td></tr></table></figure><h3 id="单独使用this"><a href="#单独使用this" class="headerlink" title="单独使用this"></a>单独使用this</h3><p>单独使用this，this指全局对象</p><p>在浏览器中，全局对象指window</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span> === <span class="built_in">window</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>严格模式下，单独使用this，也是指全局对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span> === <span class="built_in">window</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="函数中使用this"><a href="#函数中使用this" class="headerlink" title="函数中使用this"></a>函数中使用this</h3><p>在函数中，函数的所属者默认绑定到this<br>在浏览器中，this指全局对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">myFunction(); <span class="comment">//window</span></span><br></pre></td></tr></table></figure><h3 id="严格模式下函数中使用this"><a href="#严格模式下函数中使用this" class="headerlink" title="严格模式下函数中使用this"></a>严格模式下函数中使用this</h3><p>严格模式下，函数是没有绑定到this的，this是undefined</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">myFunction(); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><h3 id="事件中的this"><a href="#事件中的this" class="headerlink" title="事件中的this"></a>事件中的this</h3><p>在html事件柄中，this指向了接收事件的html元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;this.style.display=&#x27;none&#x27;&quot;</span>&gt;</span></span><br><span class="line">点我后我就消失了</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="对象方法中绑定"><a href="#对象方法中绑定" class="headerlink" title="对象方法中绑定"></a>对象方法中绑定</h3><p>下面实例中，this 是 person 对象，person 对象是函数的所有者：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstName  : <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  lastName   : <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">  id         : <span class="number">5566</span>,</span><br><span class="line">  myFunction : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.myFunction(); <span class="comment">//&#123;firstName: &quot;John&quot;, lastName: &quot;Doe&quot;, id: 5566, myFunction: ƒ&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstName: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  lastName : <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">  id       : <span class="number">5566</span>,</span><br><span class="line">  fullName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.fullName(); <span class="comment">//John Doe</span></span><br></pre></td></tr></table></figure><p> this.firstName 表示 this (person) 对象的 firstName 属性。</p><h3 id="显式函数绑定"><a href="#显式函数绑定" class="headerlink" title="显式函数绑定"></a>显式函数绑定</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  fullName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">  firstName:<span class="string">&quot;John&quot;</span>,</span><br><span class="line">  lastName: <span class="string">&quot;Doe&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">person1.fullName.call(person2);  <span class="comment">// 返回 &quot;John Doe&quot;</span></span><br></pre></td></tr></table></figure><p>在 JavaScript 中函数也是对象，对象则有方法，apply 和 call 就是函数对象的方法。这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 this 绑定的对象。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>promise理解</title>
      <link href="/ZJY.github.io/2021/01/20/promise%E7%90%86%E8%A7%A3/"/>
      <url>/ZJY.github.io/2021/01/20/promise%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p>Promise 是异步编程的一种解决方案<br>Promise 是一个对象，从它可以获取异步操作的消息</p><h3 id="Promise特点"><a href="#Promise特点" class="headerlink" title="Promise特点"></a>Promise特点</h3><p>Promise对象有以下两个特点。</p><ul><li><p>对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功<br>）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p></li><li><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p></li></ul><h3 id="Promise的缺点："><a href="#Promise的缺点：" class="headerlink" title="Promise的缺点："></a>Promise的缺点：</h3><ul><li>1.无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li><li>2.如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li><li>3.当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li></ul><p>promise是一个构造函数，用来生成promise实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        resolve(value)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>promise构造函数接收一个函数作为参数，该函数的两个参数为resovle和reject，由js引擎提供，不用自己部署</p><p>resovle函数的作用是，将promise对象的状态从“未完成”变为“成功”（pending变为fullfilled），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。</p><p>reject函数的作用是，将promise对象的状态从“未完成”变为“失败”（pending变为rejected），在异步操作失败时调用，并将异步操作返回的结果作为参数传递出去</p><h3 id="Promise-then方法"><a href="#Promise-then方法" class="headerlink" title="Promise.then方法"></a>Promise.then方法</h3><p>promise生成以后，可用then方法分别指定为resolve和reject状态的回调函数：</p><p>promise.then(function(value){},function(error){})</p><p>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</p><p>promise.then(onFulfilled, onRejected)</p><p>promise简化了对error的处理，上面的代码我们也可以这样写：</p><p>promise.then(onFulfilled).catch(onRejected)</p><h3 id="Promise-all方法"><a href="#Promise-all方法" class="headerlink" title="Promise.all方法"></a>Promise.all方法</h3><p>Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。<br>var p = Promise.all([p1,p2,p3]);</p><p>上面代码中，Promise.all 方法接受一个数组作为参数，p1、p2、p3 都是 Promise 对象的实例。（Promise.all 方法的参数不一定是数组，但是必须具有 iterator 接口，且返回的每个成员都是 Promise 实例。）</p><p>p 的状态由 p1、p2、p3 决定，分成两种情况。</p><p>（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。<br>（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</p><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wake = <span class="function">(<span class="params">time</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;time / <span class="number">1000</span>&#125;</span>秒后醒来`</span>)</span><br><span class="line">      resolve(<span class="string">`<span class="subst">$&#123;time / <span class="number">1000</span>&#125;</span>秒后醒来`</span>)</span><br><span class="line">    &#125;, time)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = wake(<span class="number">3000</span>)</span><br><span class="line"><span class="keyword">let</span> p2 = wake(<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2]).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result)       <span class="comment">//&#x27;2秒后醒来&#x27;,&#x27;3秒后醒来&#x27;  [ &#x27;3秒后醒来&#x27;, &#x27;2秒后醒来&#x27; ]</span></span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>需要特别注意的是，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，即p1的结果在前，即便p1的结果获取的比p2要晚。这带来了一个绝大的好处：在前端开发请求数据的过程中，偶尔会遇到发送多个请求并根据请求顺序获取和使用数据的场景，使用Promise.all毫无疑问可以解决这个问题。</p><h3 id="Promise-race方法"><a href="#Promise-race方法" class="headerlink" title="Promise.race方法"></a>Promise.race方法</h3><p>Promise.race 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例</p><p>var p = Promise.race([p1,p2,p3]);</p><p>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的返回值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    reject(<span class="string">&#x27;failed&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">500</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error)  <span class="comment">// 打开的是 &#x27;failed&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果Promise.all方法和Promise.race方法的参数，不是Promise实例，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。</p><h3 id="Promise-resolve-方法"><a href="#Promise-resolve-方法" class="headerlink" title="Promise.resolve 方法"></a>Promise.resolve 方法</h3><p>有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果 Promise.resolve 方法的参数，不是具有 then 方法的对象（又称 thenable 对象），则返回一个新的 Promise 对象，且它的状态为fulfilled。</p><p>上面代码生成一个新的Promise对象的实例p，它的状态为fulfilled，所以回调函数会立即执行，Promise.resolve方法的参数就是回调函数的参数。</p><p>如果Promise.resolve方法的参数是一个Promise对象的实例，则会被原封不动地返回。</p><h3 id="Promise-reject方法"><a href="#Promise-reject方法" class="headerlink" title="Promise.reject方法"></a>Promise.reject方法</h3><p>Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected。Promise.reject方法的参数reason，会被传递给实例的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">p.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure><p>上面代码生成一个Promise对象的实例，状态为rejected，回调函数会立即执行。</p><p>promise实现ajax：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">URL</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest(); </span><br><span class="line">        req.open(<span class="string">&#x27;GET&#x27;</span>, URL, <span class="literal">true</span>);</span><br><span class="line">        req.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (req.status === <span class="number">200</span>) &#123; </span><br><span class="line">                resolve(req.responseText);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;;</span><br><span class="line">        req.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">        &#125;;</span><br><span class="line">        req.send(); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> URL = <span class="string">&quot;/try/ajax/testpromise.php&quot;</span>; </span><br><span class="line">ajax(URL).then(<span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">&#x27;内容是：&#x27;</span> + value); </span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">&#x27;错误：&#x27;</span> + error); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>async/await的使用</title>
      <link href="/ZJY.github.io/2021/01/20/async-await%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/ZJY.github.io/2021/01/20/async-await%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><p>async 是 ES7 才有的与异步操作有关的关键字，和 Promise ， Generator 有很大关联的</p><p>语法：async function name([param[, param[, … param]]]) { statements }</p><ul><li>name: 函数名称。</li><li>param: 要传递给函数的参数的名称。</li><li>statements: 函数体语句。</li></ul><p>返回值：async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">helloAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;helloAsync&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">console</span>.log(helloAsync())  <span class="comment">// Promise &#123;&lt;resolved&gt;: &quot;helloAsync&quot;&#125;</span></span><br><span class="line"> </span><br><span class="line">helloAsync().then(<span class="function"><span class="params">v</span>=&gt;</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(v);         <span class="comment">// helloAsync</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>async 函数中可能会有 await 表达式，async 函数执行时，如果遇到 await 就会先暂停执行 ，等到触发的异步操作完成后，恢复 async 函数的执行并返回解析值。</p><p>await 关键字仅在 async function 中有效。如果在 async function 函数体外使用 await ，你只会得到一个语法错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testAwait</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">&quot;testAwait&quot;</span>);</span><br><span class="line">          resolve();</span><br><span class="line">       &#125;, <span class="number">1000</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">helloAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">await</span> testAwait();</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;helloAsync&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">helloAsync();</span><br><span class="line"><span class="comment">// testAwait</span></span><br><span class="line"><span class="comment">// helloAsync</span></span><br></pre></td></tr></table></figure><h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>await 操作符用于等待一个 Promise 对象, 它只能在异步函数 async function 内部使用。</p><p>语法:[return_value] = await expression;<br>expression: 一个 Promise 对象或者任何要等待的值</p><p>返回值:</p><p>返回 Promise 对象的处理结果。如果等待的不是 Promise 对象，则返回该值本身。</p><p>如果一个 Promise 被传递给一个 await 操作符，await 将等待 Promise 正常处理完成并返回其处理结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testAwait</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(x);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">helloAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="keyword">await</span> testAwait (<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(x); </span><br><span class="line">&#125;</span><br><span class="line">helloAsync ();</span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><p>正常情况下，await 命令后面是一个 Promise 对象，它也可以跟其他值，如字符串，布尔值，数值以及普通函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testAwait</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;testAwait&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">helloAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">await</span> testAwait();</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;helloAsync&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">helloAsync();</span><br><span class="line"><span class="comment">// testAwait</span></span><br><span class="line"><span class="comment">// helloAsync</span></span><br></pre></td></tr></table></figure><p>await针对所跟不同表达式的处理方式：</p><ul><li>Promise 对象：await 会暂停执行，等待 Promise 对象 resolve，然后恢复 async 函数的执行并返回解析值。</li><li>非 Promise 对象：直接返回对应的值</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序性能优化</title>
      <link href="/ZJY.github.io/2021/01/20/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/"/>
      <url>/ZJY.github.io/2021/01/20/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/</url>
      
        <content type="html"><![CDATA[<p>小程序优化性能从两点出发：</p><p>1.提高加载性能<br>2.提高渲染性能</p><h3 id="1-提高加载性能"><a href="#1-提高加载性能" class="headerlink" title="1.提高加载性能"></a>1.提高加载性能</h3><p>用户点击小程序：<br><img src="/ZJY.github.io/images/webapp.png" alt="image"></p><p>它们分别对应小程序的下面三个状态：</p><ul><li>有三个点的白屏（左侧）： 下载代码包的阶段</li><li>没有三个点的白屏（中间）： 业务代码注入和渲染的阶段</li><li>加载中（右边）： 业务代码中异步请求数据</li></ul><p>1.控制包的大小<br>提升体验最直接的方法是控制小程序包的大小，基本上可以说，1M的代码包，下载耗时1秒左右。</p><ul><li>压缩代码，清理无用的代码</li><li>图片放在cdn</li><li>采用分包策略<ul><li>分包预加载</li><li>独立分包（版本要求有点高）</li></ul></li></ul><p>2.对异步请求的优化</p><ul><li>onLoad 阶段就可以发起请求，不用等ready</li><li>请求结果放在缓存中, 下次接着用</li><li>请求中可以先展示骨架图</li><li>先反馈，再请求。比如说，点赞的按钮，可以先改变按钮的样式，再发起异步请求</li></ul><h3 id="2-提升渲染性能"><a href="#2-提升渲染性能" class="headerlink" title="2.提升渲染性能"></a>2.提升渲染性能</h3><p>setData：每调用一次setData, 都是逻辑层向渲染层的一次通讯，这个通信还不是直接传给webView, 而是通过走了native层，通讯的开销很大。</p><p>渲染层收到通讯后，还需要重新渲染出来，所以，一次setData带来两次开销：通信的开销 + webview更新的开销。</p><ul><li>1.减少setData的数据量<ul><li>如果一个数据不会影响渲染层，则不用放在setData里面</li></ul></li><li>2.合并setData的请求，减少通讯的次数</li><li>3.列表的局部更新</li><li>4.清理定时器等</li><li>5.只在必要时候监听pageScroll，避免在pageScroll中频繁setData，避免在pagescroll中写复杂逻辑</li></ul><h3 id="3-html和小程序页面加载的不同"><a href="#3-html和小程序页面加载的不同" class="headerlink" title="3.html和小程序页面加载的不同"></a>3.html和小程序页面加载的不同</h3><p>传统HTML5在加载的时候受限于网络环境，需要顺序加载HTML、CSS、JS，然后返回数据，最后渲染页面显示在浏览器中。用户经常需要等待很长时间，体验会受到影响。</p><p>相比之下，小程序的两个线程：Appservice Thread和ViewThread会同时进行、并行加载，甚至AppserviceThread会更早执行，当视图线程加载完，通知Appservice，Appservice 会把准备好的数据用setData的方法返回给视图线程。</p><p>小程序的这种优化策略，可以减少用户的等待时间、加快小程序的响应速度。</p><h3 id="4-小程序性能优化"><a href="#4-小程序性能优化" class="headerlink" title="4.小程序性能优化"></a>4.小程序性能优化</h3><ul><li><p>控制包体积的大小，减少包文件个数</p></li><li><p>分包加载</p></li><li><p>图片优化:除icon外图片可以放在cdn，不建议把所有图片放在包内，加大包的体积，影响包的下载速度和解压速度;选择合适的图片格式;适当降低图片质量压缩图片;</p></li><li><p>其他资源文件的优化，压缩json文件</p></li><li><p>请求数据的优化:关键的早请求，不关键的晚请求，可使页面所需数据尽早可能的处于ready状态，不必等到ready状态后才去请求数据</p></li><li><p>setdata的优化:不要过于频繁的调用setdata，应考虑多次合并请求;不在视图层使用的数据不要使用setdata;通过setdata<br>的key值优化</p></li><li><p>清理页面定时器</p></li><li><p>合理使用自定义组件(不需要逻辑功能时可使用模板)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http状态码</title>
      <link href="/ZJY.github.io/2021/01/20/http%E7%8A%B6%E6%80%81%E7%A0%81/"/>
      <url>/ZJY.github.io/2021/01/20/http%E7%8A%B6%E6%80%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h3 id="1xx-（临时响应）"><a href="#1xx-（临时响应）" class="headerlink" title="1xx （临时响应）"></a>1xx （临时响应）</h3><p>表示临时响应并需要请求者继续执行操作的状态代码。</p><ul><li>100 （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。</li><li>101 （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。</li><li>102 由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</li></ul><h3 id="2xx-（成功）"><a href="#2xx-（成功）" class="headerlink" title="2xx （成功）"></a>2xx （成功）</h3><p>表示成功处理了请求的状态代码。</p><ul><li>200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</li><li>201 （已创建） 请求成功并且服务器创建了新的资源。</li><li>202 （已接受） 服务器已接受请求，但尚未处理。</li><li>203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。</li><li>204 （无内容） 服务器成功处理了请求，但没有返回任何内容。</li><li>205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。</li><li>206 （部分内容） 服务器成功处理了部分 GET 请求。</li><li>207 由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</li></ul><h3 id="3xx-（重定向）"><a href="#3xx-（重定向）" class="headerlink" title="3xx （重定向）"></a>3xx （重定向）</h3><p>表示要完成请求，需要进一步操作。通常，这些状态代码用来重定向。</p><ul><li>300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (useragent)选择一项操作，或提供操作列表供请求者选择。</li><li>301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或HEAD请求的响应）时，会自动将请求者转到新位置。</li><li>302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li><li>303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</li><li>304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。</li><li>305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。</li><li>307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li></ul><h3 id="4xx-（请求错误）"><a href="#4xx-（请求错误）" class="headerlink" title="4xx （请求错误）"></a>4xx （请求错误）</h3><p>这些状态代码表示请求可能出错，妨碍了服务器的处理。</p><ul><li>400 （错误请求） 服务器不理解请求的语法。</li><li>401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</li><li>402 该状态码是为了将来可能的需求而预留的。</li><li>403 （禁止） 服务器拒绝请求。</li><li>404 （未找到） 服务器找不到请求的网页。</li><li>405 （方法禁用） 禁用请求中指定的方法。</li><li>406 （不接受） 无法使用请求的内容特性响应请求的网页。</li><li>407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。</li><li>408 （请求超时）服务器等候请求时发生超时。</li><li>409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。</li><li>410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。</li><li>411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。</li><li>412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。</li><li>413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。</li><li>414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。这比较少见，通常的情况包括：本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。</li><li>415 （不支持的媒体类型） 请求的格式不受请求页面的支持。</li><li>416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。</li><li>417 （未满足期望值） 服务器未满足”期望”请求标头字段的要求。</li></ul><h3 id="5xx-（服务器错误）"><a href="#5xx-（服务器错误）" class="headerlink" title="5xx （服务器错误）"></a>5xx （服务器错误）</h3><p>这些状态代码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。</p><ul><li>500 （服务器内部错误） 服务器遇到错误，无法完成请求。</li><li>501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</li><li>502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。</li><li>503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。</li><li>504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。</li><li>505 （HTTP 版本不受支持）服务器不支持请求中所用的 HTTP 协议版本。</li></ul><h3 id="600"><a href="#600" class="headerlink" title="600"></a>600</h3><p>源站没有返回响应头部，只返回实体内容</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript基础题</title>
      <link href="/ZJY.github.io/2021/01/20/javascript%E5%9F%BA%E7%A1%80%E9%A2%98/"/>
      <url>/ZJY.github.io/2021/01/20/javascript%E5%9F%BA%E7%A1%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-js基础"><a href="#1-js基础" class="headerlink" title="1.js基础"></a>1.js基础</h3><ul><li>基本类型：<ul><li>number</li><li>string</li><li>boolean</li><li>null</li><li>undefined</li><li>symbol  </li></ul></li></ul><p>基本类型的比较就是值的比较，访问的是值的本身，没有属性和方法，保存在栈内存中</p><ul><li>引用类型<ul><li>Array</li><li>Function</li><li>Date</li><li>Object</li></ul></li></ul><p>引用类型有属性和方法，同时保存在栈内存和堆内存中；引用类型的比较是内存地址的比较。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> address = &#123;<span class="attr">details</span>:<span class="string">&#x27;a&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">let</span> one = address</span><br><span class="line"><span class="keyword">let</span> tow = address</span><br><span class="line">one === tow <span class="comment">//true</span></span><br><span class="line"><span class="comment">// 虽然one、tow是两枚不同的指针，但它们都同时指向了堆内存里的address的内容，所以它们是相等的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数参数是引用类型（对象）的时候会发生什么</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  person.age = <span class="number">26</span></span><br><span class="line">  person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;aaa&#x27;</span>,</span><br><span class="line">    age: <span class="number">30</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> person</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = &#123;</span><br><span class="line">  name: <span class="string">&#x27;bbb&#x27;</span>,</span><br><span class="line">  age: <span class="number">25</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p2 = test(p1)</span><br><span class="line">p1 <span class="comment">// &#123;age:26,name:&#x27;bbb&#x27;&#125;</span></span><br><span class="line">p2 <span class="comment">// &#123;age:30,name:&#x27;aaa&#x27;&#125;</span></span><br></pre></td></tr></table></figure><p>函数传递参数时，实际上是传递指针的副本。<br>test(p1)实际上传递的就是p1的副本，这时指针仍然指向{name: ‘bbb’,age: 25}<br>person.age = 26 这时修改的还是原来内存位置的内容，所以这时p1的age变成了26<br>当person = {} .. 相当于重新开辟了一块堆内存，赋值{name:’aaa’,age:30},最后返回这个对象，而这个对象的指针就是p2</p><h3 id="2-字符串翻转："><a href="#2-字符串翻转：" class="headerlink" title="2.字符串翻转："></a>2.字符串翻转：</h3><p>console.log(str1.split(‘’).reverse().join(‘’))</p><p>判断字符串出现次数最多元素，并统计次数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str2 = <span class="string">&#x27;asdfasdfasdfasdfjkjkljlkjssss&#x27;</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> num2 = str2.length</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num2; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj[str2.charAt(i)]) &#123;</span><br><span class="line">    obj[str2.charAt(i)] = <span class="built_in">parseInt</span>(obj[str2.charAt(i)]) + <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    obj[str2.charAt(i)] = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"><span class="keyword">let</span> maxNum = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> maxDocument = <span class="literal">null</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j <span class="keyword">in</span> obj) &#123;<span class="comment">//循环对象</span></span><br><span class="line">  <span class="keyword">if</span> (obj[j] &gt; maxNum) &#123;</span><br><span class="line">    maxNum = obj[j]</span><br><span class="line">    maxDocument = j</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-数组去重"><a href="#3-数组去重" class="headerlink" title="3.数组去重"></a>3.数组去重</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;e&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(arr2.indexOf(arr[i])== -<span class="number">1</span>)&#123;</span><br><span class="line">    arr2.push(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr2)</span><br></pre></td></tr></table></figure><h3 id="4-replace字符串替换"><a href="#4-replace字符串替换" class="headerlink" title="4.replace字符串替换"></a>4.replace字符串替换</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;hello china&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> str2 = str.replace(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;hi&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str2,str);<span class="comment">//hi china,hello china</span></span><br></pre></td></tr></table></figure><h3 id="5-toUpperCase-大写-toLocaleUpperCase"><a href="#5-toUpperCase-大写-toLocaleUpperCase" class="headerlink" title="5.toUpperCase()大写/toLocaleUpperCase"></a>5.toUpperCase()大写/toLocaleUpperCase</h3><h3 id="6-toLowerCase-小写-toLocalLowerCase"><a href="#6-toLowerCase-小写-toLocalLowerCase" class="headerlink" title="6.toLowerCase()小写/toLocalLowerCase"></a>6.toLowerCase()小写/toLocalLowerCase</h3><h3 id="7-repeat-count-number-字符串重复次数"><a href="#7-repeat-count-number-字符串重复次数" class="headerlink" title="7.repeat(count:number)字符串重复次数"></a>7.repeat(count:number)字符串重复次数</h3><h3 id="8-Math-ceil-向上舍入-4-1结果5"><a href="#8-Math-ceil-向上舍入-4-1结果5" class="headerlink" title="8.Math.ceil()向上舍入 4.1结果5"></a>8.Math.ceil()向上舍入 4.1结果5</h3><h3 id="9-Math-floor-向下舍入-4-9结果4"><a href="#9-Math-floor-向下舍入-4-9结果4" class="headerlink" title="9.Math.floor()向下舍入  4.9结果4"></a>9.Math.floor()向下舍入  4.9结果4</h3><h3 id="10-Math-round-把数四舍五入为最接近的整数。"><a href="#10-Math-round-把数四舍五入为最接近的整数。" class="headerlink" title="10.Math.round()把数四舍五入为最接近的整数。"></a>10.Math.round()把数四舍五入为最接近的整数。</h3><h3 id="11-数组-和length-0的区别："><a href="#11-数组-和length-0的区别：" class="headerlink" title="11.数组[]和length=0的区别："></a>11.数组[]和length=0的区别：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> bar = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> foo2 = foo;</span><br><span class="line"><span class="keyword">var</span> bar2 = bar;</span><br><span class="line">foo=[];</span><br><span class="line">bar.length = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo,foo2,bar,bar2);<span class="comment">//[]  [1,2,3]  []  []</span></span><br></pre></td></tr></table></figure><p>[]是创建了一个新数组，重新分配了内存空间，任何其他引<br>用不受影响，仍指向其原始数据<br>length=0 修改数组本身。如果通过不同的变量访问它，那<br>么仍然可以获得修改后的数组</p><h3 id="12-typeof"><a href="#12-typeof" class="headerlink" title="12.typeof"></a>12.typeof</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">//&quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span> <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">Infinity</span> <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;  <span class="comment">//&quot;function&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;aaa&quot;</span>) <span class="comment">//&quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">String</span>(<span class="string">&#x27;aaa&#x27;</span>) <span class="comment">//&quot;string&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> object <span class="comment">//false</span></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> 任何类型 <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span>可以用来检查一个没有声明的变量，而不报错:</span><br><span class="line"><span class="keyword">typeof</span> v <span class="comment">//&quot;undefined&quot;</span></span><br></pre></td></tr></table></figure><p>typeof可以判断基本数据类型：String，Boolean,Number,但不能判断Array,Object,Null类型</p><h3 id="13-变量提升"><a href="#13-变量提升" class="headerlink" title="13.变量提升"></a>13.变量提升</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;World!&#x27;</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> name = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Goodbye &#x27;</span> + name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Hello &#x27;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 结果：Goodbye Jack</span></span><br><span class="line"><span class="comment">// 注意js的var hoisting变量声明提升，虽然声明提升，但是初始化并不提升</span></span><br><span class="line"><span class="comment">// 这段代码相当于：</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;World!&#x27;</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">        name = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Goodbye &#x27;</span> + name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Hello &#x27;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="14-splice"><a href="#14-splice" class="headerlink" title="14.splice"></a>14.splice</h3><p>splice(index,number,value)向数组中添加或删除数目，返回被删除的数目<br>    index：必须，要添加或删除的起始位置，为负时，从数组尾部开始<br>    number：必须，要删除的数量，为0时则不删除<br>    value：可选，要添加的数目</p><p>删除：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line"><span class="built_in">console</span>.log(a.splice(<span class="number">0</span>,a.length)); <span class="comment">//[1,2,3]</span></span><br><span class="line"><span class="built_in">console</span>.log(a,b); <span class="comment">//[] []</span></span><br></pre></td></tr></table></figure><p>添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr1 = arr;</span><br><span class="line"><span class="built_in">console</span>.log(arr.splice(<span class="number">1</span>,<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>)); <span class="comment">//[]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr,arr1);<span class="comment">// [1,&#x27;a&#x27;,&#x27;b&#x27;,2,3]   [1,&#x27;a&#x27;,&#x27;b&#x27;,2,3]</span></span><br></pre></td></tr></table></figure><h3 id="15-slice"><a href="#15-slice" class="headerlink" title="15.slice"></a>15.slice</h3><p>slice(start,end)向数组中选出指定数组，返回被截选的子数组<br>（start到end，不包含end），并不改变原数组</p><ul><li>start：必须，规定从何处开始，为负时，从数组尾部算起,-1为尾部第一个元素</li><li>end：可选，规定截取到何处，没有此参数则到数组结尾所有元素，<br>  为负时，从尾部开始算起元素</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> d = c;</span><br><span class="line"><span class="built_in">console</span>.log(c.slice(<span class="number">0</span>,<span class="number">2</span>));<span class="comment">//[1,2]</span></span><br><span class="line"><span class="built_in">console</span>.log(c,d);<span class="comment">//[1,2,3]  [1,2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以截取字符串：不包含end元素</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="string">&#x27;hello,world&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(test.slice(<span class="number">1</span>,<span class="number">5</span>),test);<span class="comment">// ello   hello,world</span></span><br><span class="line"><span class="built_in">console</span>.log(test.slice(-<span class="number">3</span>),test);<span class="comment">// rld  hello,world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// substring:不包含end元素</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="string">&#x27;hello,world&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(test.substring(<span class="number">1</span>,<span class="number">5</span>),test);<span class="comment">// ello   hello,world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// substr:包含end元素</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="string">&#x27;hello,world&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(test.substr(<span class="number">1</span>,<span class="number">5</span>),test);<span class="comment">// ello,   hello,world</span></span><br></pre></td></tr></table></figure><h3 id="16-js判断数据类型"><a href="#16-js判断数据类型" class="headerlink" title="16.js判断数据类型"></a>16.js判断数据类型</h3><p>1.typeof:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;ls&#x27;</span> <span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">123</span> <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// bollean</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// function</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(<span class="number">1</span>) <span class="comment">// symbol</span></span><br></pre></td></tr></table></figure><p>typeof可以判断基本数据类型：String，Boolean,Number,但不能判断Array,Object,Null类型</p><p>2.instanceof</p><p>判断构造函数的prototype属性是否存在某实例对象的原型链上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。其意思就是判断对象是否是某一数据类型（如Array）的实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> A);<span class="comment">//true,因为 Object.getPrototypeOf(a) === A.prototype;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;srr&#x27;</span> intanceof <span class="built_in">String</span>) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>) <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 在这里字面量值，2， true ，&#x27;str&#x27;不是实例，所以判断值为false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">2</span>) <span class="keyword">instanceof</span> <span class="built_in">Number</span>)<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;2&#x27;</span>) <span class="keyword">instanceof</span> <span class="built_in">String</span>)<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>) <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>)<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Function</span>)<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null和undefined</span></span><br><span class="line">conosle.log(<span class="literal">null</span> <span class="keyword">instanceof</span> Null) <span class="comment">// Null is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">undefined</span> <span class="keyword">instanceof</span> Undefined) <span class="comment">//Undefined is not undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="literal">null</span> <span class="keyword">instanceof</span> Null) <span class="comment">// null is not a constructor</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="literal">undefined</span> <span class="keyword">instanceof</span> Undefined) <span class="comment">//undefined is not a constructor</span></span><br><span class="line"><span class="comment">// 浏览器认为null，undefined不是构造器</span></span><br></pre></td></tr></table></figure><p>能判断Array,Object,Null类型，但不能区分基本数据类型，而且它依赖于对象的原型链，若原型链被修改，结果可能并不准确</p><p>3.constructor</p><p>constructor属性返回创建该对象时构造函数的引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="number">2</span>).constructor === <span class="built_in">Number</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">true</span>).constructor === <span class="built_in">Boolean</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="string">&#x27;str&#x27;</span>).constructor === <span class="built_in">String</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(([]).constructor === <span class="built_in">Array</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log((&#123;&#125;).constructor === <span class="built_in">Object</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;).constructor === <span class="built_in">Function</span>);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用costructor来判断类型看起来是完美的，然而，如果</span></span><br><span class="line"><span class="comment">// 我创建一个对象，更改它的原型，这种方式也变得不可</span></span><br><span class="line"><span class="comment">// 靠了</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Fn.prototype = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> Fn();</span><br><span class="line"><span class="built_in">console</span>.log(f.constructor === Fn);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(f.constructor=== <span class="built_in">Array</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>constructor属性可以被修改，因此并不是可靠的类型检查方法</p><p>4.Object.prototype.toString.call</p><p>toString方法返回调用它的对象的类型或值。<br>返回值默认是[object class],class是对象的内部类型，通常对应对象的构造函数名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常用于判断浏览器内置对象,对于所有基本的数据类型都能进行判断，即使是 null 和 undefined</span></span><br><span class="line"><span class="keyword">var</span>  test = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"><span class="built_in">console</span>.log(test.call(<span class="number">1</span>)); <span class="comment">//[object Number]</span></span><br><span class="line"><span class="built_in">console</span>.log(test.call(<span class="literal">true</span>)); <span class="comment">//[object Boolean]</span></span><br><span class="line"><span class="built_in">console</span>.log(test.call(<span class="string">&#x27;123&#x27;</span>)); <span class="comment">//[object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(test.call([])); <span class="comment">//[object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(test.call(&#123;&#125;)); <span class="comment">//[object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(test.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)); <span class="comment">//[object Function]</span></span><br><span class="line"><span class="built_in">console</span>.log(test.call(<span class="literal">null</span>)); <span class="comment">//[object Null]</span></span><br><span class="line"><span class="built_in">console</span>.log(test.call(<span class="literal">undefined</span>)); <span class="comment">//[object Undefined]       </span></span><br></pre></td></tr></table></figure><p>是一个可靠的类型检查方法因为它不依赖于原型链</p><p>5.Array.isArray<br>用来判断一个对象是否是数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray([]))<span class="comment">// true</span></span><br><span class="line">     </span><br><span class="line"> <span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;123&#x27;</span>);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> str); <span class="comment">//object</span></span><br><span class="line"> <span class="built_in">console</span>.log(str <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">//true</span></span><br><span class="line"> <span class="built_in">console</span>.log(str.constructor===<span class="built_in">String</span>); <span class="comment">//true</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(str));[object <span class="built_in">String</span>]</span><br></pre></td></tr></table></figure><h3 id="17-闭包的概念"><a href="#17-闭包的概念" class="headerlink" title="17.闭包的概念"></a>17.闭包的概念</h3><p>闭包就是能访问其他函数内部的变量的函数</p><ul><li>优点：<br>  避免全局变量的污染<br>  变量长期存储在内存中（缓存变量）</li><li>缺点：<br>  常驻内存，加大内存使用<br>  内存泄漏<br>闭包实现了私有变量和参数</li></ul><h3 id="18-深拷贝和浅拷贝"><a href="#18-深拷贝和浅拷贝" class="headerlink" title="18.深拷贝和浅拷贝"></a>18.深拷贝和浅拷贝</h3><ul><li>基础数据类型（number string boolean null undefined）存储在栈内存中</li><li>引用数据类型（Function Array Object）变量名与内存地址存储在栈内存中，值作为对象保存在堆内存中</li><li>基础数据类型的比较是值比较</li><li>引用数据类型的比较是内存地址比较</li></ul><p>浅拷贝：只复制指向某个对象的指针，而不复制对象本身，新旧对象共享同一块内存<br>深拷贝：复制并创建一个一摸一样的对象，不共享内存，修改新对象，旧对象保持不变</p><ul><li>浅拷贝：<pre><code>  Object.assign()  扩展运算符...  Array.prototype.slice()//数组浅拷贝</code></pre></li><li>深拷贝：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify())</span><br><span class="line"><span class="comment">// 递归克隆</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现深拷贝：浅拷贝+递归</span></span><br><span class="line"><span class="comment">// 浅拷贝：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneShallow</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">            target[key] = source[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    name: <span class="string">&quot;muyiy&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;You Don&#x27;t Know JS&quot;</span>,</span><br><span class="line">        price: <span class="string">&quot;45&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    a1: <span class="literal">undefined</span>,</span><br><span class="line">    a2: <span class="literal">null</span>,</span><br><span class="line">    a3: <span class="number">123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = cloneShallow(a);</span><br><span class="line"></span><br><span class="line">a.name = <span class="string">&quot;高级前端进阶&quot;</span>;</span><br><span class="line">a.book.price = <span class="string">&quot;55&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123; </span></span><br><span class="line"><span class="comment">//   name: &#x27;muyiy&#x27;, </span></span><br><span class="line"><span class="comment">//   book: &#123; title: &#x27;You Don\&#x27;t Know JS&#x27;, price: &#x27;55&#x27; &#125;,</span></span><br><span class="line"><span class="comment">//   a1: undefined,</span></span><br><span class="line"><span class="comment">//   a2: null,</span></span><br><span class="line"><span class="comment">//   a3: 123</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 以上只能拷贝一层，只要稍微改动下，加上是否是对象</span></span><br><span class="line"><span class="comment">// 的判断并在相应的位置使用递归就可以实现简单深拷贝。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneDeep1</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source, key)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> source[key] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">                target[key] = cloneDeep1(source[key]); <span class="comment">// 注意这里</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                target[key] = source[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用上面测试用例测试一下</span></span><br><span class="line"><span class="keyword">var</span> b = cloneDeep1(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123; </span></span><br><span class="line"><span class="comment">//   name: &#x27;muyiy&#x27;, </span></span><br><span class="line"><span class="comment">//   book: &#123; title: &#x27;You Don\&#x27;t Know JS&#x27;, price: &#x27;45&#x27; &#125;, </span></span><br><span class="line"><span class="comment">//   a1: undefined,</span></span><br><span class="line"><span class="comment">//   a2: &#123;&#125;,</span></span><br><span class="line"><span class="comment">//   a3: 123</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>一个简单的深拷贝就完成了，但是这个实现还存在很多问题。</p><p>1、没有对传入参数进行校验，传入 null 时应该返回 null 而不是 {}</p><p>2、对于对象的判断逻辑不严谨，因为 typeof null === ‘object’</p><p>3、没有考虑数组的兼容</p><p>判断是否是object</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span> &amp;&amp; obj != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 所以兼容数组的写法如下：</span></span><br><span class="line">functoin <span class="function"><span class="title">cloneDeep2</span>(<span class="params">source</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!isObject(source)) <span class="keyword">return</span> source;<span class="comment">//非对象返回自身</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> target = <span class="built_in">Array</span>.isArray(source) ? []: &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> source)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.hasOwnProperty.call(source,key))&#123;</span><br><span class="line">            <span class="keyword">if</span>(isObject(source[key]))&#123;</span><br><span class="line">                target[key] = cloneDeep2(source[key])</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                target[key] = source[key]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>赋值、浅拷贝、深拷贝区别：</p><ul><li>赋值：赋值就是将某一数值或某一对象赋给某个变量的过程，分为如下两个部分：<pre><code>  基本数据类型：赋值，赋值之后两个变量互不影响  引用数据类型：赋址，两个变量具有相同的引用，指向同一个对象，互相有影响</code></pre></li></ul><p>对基本类型进行赋值操作，两个变量互不影响：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&quot;muyiy&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// muyiy</span></span><br><span class="line"></span><br><span class="line">a = <span class="string">&quot;change&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// change</span></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// muyiy</span></span><br></pre></td></tr></table></figure><p>对引用类型进行赋址操作，两个变量指向同一个对象，改变变量 a 之后会影响变量 b，哪怕改变的只是对象 a中的基本类型数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    name: <span class="string">&quot;muyiy&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;You Don&#x27;t Know JS&quot;</span>,</span><br><span class="line">        price: <span class="string">&quot;45&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;muyiy&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line">a.name = <span class="string">&quot;change&quot;</span>;</span><br><span class="line">a.book.price = <span class="string">&quot;55&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;change&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;change&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br></pre></td></tr></table></figure><ul><li><p>浅拷贝（Shallow Copy）：<br>创建一个对象，这个对象有原始对象属性值的一份精确拷贝。如果属性值是基本数据类型，拷贝的就是基本数据类型的值，如果属性值是引用类型，拷贝的就是内存的地址，所以两个对象会相互影响。浅拷贝只解决了第一层的问题，拷贝第一层的基本类型值，以及第一层的引用类型地址</p><p>  浅拷贝使用场景：</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">Object</span>.assign()方法将所有可枚举属性的值从一个或多个源对象复制到目标对象</span><br><span class="line"><span class="comment">// 木易杨</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    name: <span class="string">&quot;muyiy&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;You Don&#x27;t Know JS&quot;</span>,</span><br><span class="line">        price: <span class="string">&quot;45&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;, a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;muyiy&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line">a.name = <span class="string">&quot;change&quot;</span>;</span><br><span class="line">a.book.price = <span class="string">&quot;55&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;change&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;muyiy&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br></pre></td></tr></table></figure><p>上面代码改变对象 a 之后，对象 b 的基本属性保持不变。但是当改变对象 a 中的对象 book 时，对象 b 相应的位置也发生了变化</p><p>2.展开语法 Spread</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    name: <span class="string">&quot;muyiy&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;You Don&#x27;t Know JS&quot;</span>,</span><br><span class="line">        price: <span class="string">&quot;45&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;...a&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;muyiy&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line">a.name = <span class="string">&quot;change&quot;</span>;</span><br><span class="line">a.book.price = <span class="string">&quot;55&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;change&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;muyiy&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br></pre></td></tr></table></figure><p>通过代码可以看出实际效果和 Object.assign() 是一样的。</p><p>3.Array.prototype.slice()</p><p>slice() 方法返回一个新的数组对象，这一对象是一个由 begin和 end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">0</span>, <span class="string">&quot;1&quot;</span>, [<span class="number">2</span>, <span class="number">3</span>]];</span><br><span class="line"><span class="keyword">let</span> b = a.slice(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// [&quot;1&quot;, [2, 3]]</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">1</span>] = <span class="string">&quot;99&quot;</span>;</span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// [0, &quot;99&quot;, [4, 3]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">//  [&quot;1&quot;, [4, 3]]</span></span><br></pre></td></tr></table></figure><p>深拷贝（Deep Copy）</p><p>复制并创建一个一摸一样的对象，不共享内存，修改新对象，旧对象保持不变;</p><p>深拷贝使用场景：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>。<span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(object))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    name: <span class="string">&quot;muyiy&quot;</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">&quot;You Don&#x27;t Know JS&quot;</span>,</span><br><span class="line">        price: <span class="string">&quot;45&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a));</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;muyiy&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line">a.name = <span class="string">&quot;change&quot;</span>;</span><br><span class="line">a.book.price = <span class="string">&quot;55&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;change&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;55&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;muyiy&quot;,</span></span><br><span class="line"><span class="comment">// book: &#123;title: &quot;You Don&#x27;t Know JS&quot;, price: &quot;45&quot;&#125;</span></span><br><span class="line"><span class="comment">// &#125; </span></span><br></pre></td></tr></table></figure><p>对数组深拷贝效果如何：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">0</span>, <span class="string">&quot;1&quot;</span>, [<span class="number">2</span>, <span class="number">3</span>]];</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify( a.slice(<span class="number">1</span>) ));</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// [&quot;1&quot;, [2, 3]]</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">1</span>] = <span class="string">&quot;99&quot;</span>;</span><br><span class="line">a[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// [0, &quot;99&quot;, [4, 3]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">//  [&quot;1&quot;, [2, 3]]</span></span><br></pre></td></tr></table></figure><p>对数组深拷贝之后，改变原数组不会影响到拷贝之后的数组但是该方法有以下几个问题：<br>会忽略 undefined/symbol，不能处理正则/new Date<br>undefined、symbol 和函数这三种情况，会直接忽略</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;muyiy&#x27;</span>,</span><br><span class="line">    a: <span class="literal">undefined</span>,</span><br><span class="line">    b: <span class="built_in">Symbol</span>(<span class="string">&#x27;muyiy&#x27;</span>),</span><br><span class="line">    c: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// name: &quot;muyiy&quot;, </span></span><br><span class="line"><span class="comment">// a: undefined, </span></span><br><span class="line"><span class="comment">//  b: Symbol(muyiy), </span></span><br><span class="line"><span class="comment">//  c: ƒ ()</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// &#123;name: &quot;muyiy&quot;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="19-数组去重："><a href="#19-数组去重：" class="headerlink" title="19.数组去重："></a>19.数组去重：</h3><p>1.for循环嵌套for循环，使用splice去重更改原数组 正向遍历循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">distinct</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.length ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] === arr[j]) &#123;</span><br><span class="line">                    arr.splice(j, <span class="number">1</span>)</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    distinct(arr)</span><br><span class="line">    <span class="built_in">console</span>.log(arr) <span class="comment">// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：该方法可以顾虑到重复的 String、Boolean、 Number、undefined、null，返回的是去重后的原数组。<br>缺点：不能过滤掉 NaN、Object</p><p>2.for循环嵌套for循环，使用splice去重更改原数组 逆向遍历循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">distinct</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = arr.length; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j = i - <span class="number">1</span>; j &gt; -<span class="number">1</span> ; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] === arr[j]) &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(arr[j])</span><br><span class="line">                    arr.splice(j, <span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    distinct(arr)</span><br><span class="line">    <span class="built_in">console</span>.log(arr) <span class="comment">// [1, &quot;true&quot;, true, 15, false, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点同方法一</p><p>3.includes去重 返回新数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">distinct</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> newArr = []</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!newArr.includes(arr[i])) &#123;</span><br><span class="line">                newArr.push(arr[i])</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newArr</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(distinct(arr)) <span class="comment">// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点是可以过滤重复的NaN了，但是返回的是个新数组，对比方法一二，该方法多消耗了一些存储空间。</p><p>优点：该方法可以顾虑到重复的 String、Boolean、Number、undefined、null、NaN，返回的是去重后的新数组。<br>缺点：不能过滤掉 Object</p><p>4.indexOf去重 返回新数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">distinct</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> newArr = []</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(newArr.indexOf(arr[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                newArr.push(arr[i])</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newArr</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(distinct(arr)) <span class="comment">//  [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：该方法可以顾虑到重复的 String、Boolean、 Number、undefined、null，返回的是去重后的新数组。<br>缺点：不能过滤掉 NaN、Object</p><p>5.利用对象的属性key唯一的特性去重</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">distinct</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">        <span class="keyword">let</span> newArr = []</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!obj[arr[i]])&#123;</span><br><span class="line">                obj[arr[i]] = <span class="number">1</span></span><br><span class="line">                newArr.push(arr[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newArr</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(distinct(arr)) <span class="comment">// [1, &quot;true&quot;, 15, false, undefined, null, NaN, 0, &quot;a&quot;, &#123;…&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法不仅可以过滤掉重复的NaN,还是可以过滤掉Object。</p><p>优点：该方法可以顾虑到重复的 String、Boolean、 Number、undefined、null、NaN、Object，返回的是去重后的新数组。<br>缺点：针对 NaN和’NaN’, 对象的key会视为一个key，区分不了NaN和’NaN’</p><p>6.利用ES6的Set数据结构的特性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">distinct</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(distinct(arr)) <span class="comment">// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：该方法可以顾虑到重复的 String、Boolean、 Number、undefined、null、NaN，返回的是去重后的新数组。<br>缺点：不能过滤重复的Object</p><p>7.利用ES6的Map数据结构的特性去重</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;true&#x27;</span>,<span class="string">&#x27;true&#x27;</span>,<span class="literal">true</span>,<span class="literal">true</span>,<span class="number">15</span>,<span class="number">15</span>,<span class="literal">false</span>,<span class="literal">false</span>, <span class="literal">undefined</span>,<span class="literal">undefined</span>, <span class="literal">null</span>,<span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>,<span class="string">&#x27;NaN&#x27;</span>,<span class="string">&#x27;NaN&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,&#123;&#125;,&#123;&#125;];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">distinct</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">        <span class="keyword">let</span> newArr = []</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!map.has(arr[i])) &#123;</span><br><span class="line">                map.set(arr[i])</span><br><span class="line">                newArr.push(arr[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newArr</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(distinct(arr)) <span class="comment">// [1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, &#123;…&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：该方法可以顾虑到重复的 String、Boolean、 Number、undefined、null、NaN，返回的是去重后的新数组。<br>缺点：不能过滤重复的Object</p><p>总结：</p><ul><li>splice、indexof（不能过滤NaN、object）：<pre><code>  双重for循环，判断arr[i] 和 arr[j](j=i+1)是否相等利  用splice去重数组，正向遍历数组，不能过滤掉 NaN、Object  双重for循环，判断arr[i]和arr[j](j=i-1)是否相等利  用splice去重数组，逆向遍历数组，不能过滤掉 NaN、Object  定义新数组，for循环判断新数组是否包含indexOf当前循环值，  利用indexOf去重，不能过滤掉 NaN、Object</code></pre></li><li>includes、set、map（不能过滤object）：<pre><code>  定义新数组，for循环判断新数组是否includes当  前循环值，利用includes去重，不能过滤掉 Object  利用ES6的Set数据结构的特性：return Array.from  (new Set(arr))，不能过滤掉 Object  利用ES6的Map数据结构的特性去重：      let map = new Map()      for循环中判断：map.has(arr[i])  不能过滤掉 Object</code></pre></li><li>利用对象的属性key唯一的特性去重:<pre><code>  let obj = &#123;&#125;  for循环判断：obj[arr[i]]不存在将当前循环元素push新数组  可以过滤掉 NaN、Object，不可以区分&#39;NaN&#39;和NaN</code></pre></li></ul><h3 id="20-DOM-事件有哪些阶段？谈谈对事件代理的理解"><a href="#20-DOM-事件有哪些阶段？谈谈对事件代理的理解" class="headerlink" title="20.DOM 事件有哪些阶段？谈谈对事件代理的理解"></a>20.DOM 事件有哪些阶段？谈谈对事件代理的理解</h3><p>捕获阶段-目标阶段-冒泡阶段</p><p>事件代理简单说就是：事件不直接绑定到某元素上，而是绑定到该元素的父元素上，进行触发事件操作时(例如’click’)，再通过条件判断，执行事件触发后的语句(例如’alert(e.target.innerHTML)’)</p><p>好处：(1)使代码更简洁；(2)节省内存开销</p><h3 id="21-async-await"><a href="#21-async-await" class="headerlink" title="21.async/await"></a>21.async/await</h3><p>async用于声明一个函数是异步的，await用来等待一个异步<br>方法执行完成，await只能出现在async函数中</p><p>async函数会返回一个promise对象，如果async函数直接<br>return一个直接量，async函数会把这个直接量用promise.resolve()<br>封装成promise对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello async&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = testAsync();</span><br><span class="line"><span class="built_in">console</span>.log(result);<span class="comment">//Promise &#123;resolved： &#x27;hello async&#x27; &#125;</span></span><br></pre></td></tr></table></figure><p>所以如果不能用await取其返回值情况下可用：<br>then()链来处理这个promise对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">testAsync().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res); <span class="comment">//hello async</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果async没有返回值，它会返回Promise.resolve(undefined)</p><p>await等待的是一个表达式，这个表达式的结果是promise对<br>象或其他值（直接量或者普通函数）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;something&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">&quot;hello async&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> v1 = <span class="keyword">await</span> getSomething();</span><br><span class="line">    <span class="keyword">const</span> v2 = <span class="keyword">await</span> testAsync();</span><br><span class="line">    <span class="built_in">console</span>.log(v1, v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();<span class="comment">//something hello async</span></span><br></pre></td></tr></table></figure><p>如果await等待的不是promise对象，那await表达式的结果就是它等到的东西<br>如果await等待的是promise对象，那它就阻塞后面的代码，等着<br>promise对象resolve，resolve的值就是await表达式的运算结果</p><p>async会将其后的函数的返回值封装成一个promise对象，而await会等待这个promise完成，并将resolve结果返回</p><p>await函数结果可能是rejected，所以最好把await命令放<br>在try…catch块中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">await</span> getSomething();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">await</span> getSomething().catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err)</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="22-协程"><a href="#22-协程" class="headerlink" title="22.协程"></a>22.协程</h3><p>意思是多个线程互相协作，完成异步任务。<br>协程有点像函数，又有点像线程。它的运行流程大致如下：<br>第一步，协程A开始执行。</p><p>第二步，协程A执行到一半，进入暂停，执行权转移到协程B。</p><p>第三步，（一段时间后）协程B交还执行权。</p><p>第四步，协程A恢复执行。</p><h3 id="23-Generator"><a href="#23-Generator" class="headerlink" title="23.Generator"></a>23.Generator</h3><p>Generator函数就是协程再es6的实现，最大的特点就是可用交出函数的执行权（暂停执行）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码就是一个 Generator 函数。它不同于普通函数，是可以暂停执行的，所以函数名之前要加星号，以示区别。整个generator函数就是一个异步任务，需要操作暂停地方就用yeild语句注明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>generator函数返回一个内部指针g，执行generator函数不会返回结果，而是返回一个指针对象，调用g的next方法会移动内部指针移动到yeild语句</p><p>next 方法的作用是分阶段执行 Generator 函数，每次调用next方法会返回一个对象，表示当前阶段信息（value和done）value是yeild语句后表达式的值，done 属性是一个布尔值，表示Generator 函数是否执行完毕，即是否还有下一个阶段。</p><p>Generator函数可以暂停执行和恢复执行，这是可用异步任务的原因，除此外还有两个特效：函数体内数据交换和错误处理机制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">g.next(<span class="number">2</span>) <span class="comment">// &#123; value: 2, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>第二个 next 方法带有参数2，这个参数可以传入 Generator函数，作为上个阶段异步任务的返回结果，被函数体内的变量 y 接收。因此，这一步的 value 属性，返回的就是2</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js事件执行机制-事件循环</title>
      <link href="/ZJY.github.io/2021/01/20/js%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
      <url>/ZJY.github.io/2021/01/20/js%E4%BA%8B%E4%BB%B6%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="1-javascript是单线程语言"><a href="#1-javascript是单线程语言" class="headerlink" title="1.javascript是单线程语言"></a>1.javascript是单线程语言</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;定时器开始啦&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;马上开始执行for循环&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        i==<span class="number">99</span> &amp;&amp; resolve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;执行then函数&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;代码执行结束&#x27;</span>);</span><br></pre></td></tr></table></figure><p>结果：<br>马上开始执行for循环<br>代码执行结束<br>执行then函数<br>定时器开始啦</p><h3 id="2-Js事件循环"><a href="#2-Js事件循环" class="headerlink" title="2.Js事件循环"></a>2.Js事件循环</h3><ul><li>同步任务</li><li>异步任务</li></ul><p>同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。<br>当指定的事情完成时，Event Table会将这个函数移入Event Queue。<br>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。<br>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [];</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url:www.javascript.com,</span><br><span class="line">    data:data,</span><br><span class="line">    success:<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;发送成功!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;代码执行结束&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>ajax进入Event Table，注册回调函数success。</li><li>执行console.log(‘代码执行结束’)。</li><li>ajax事件完成，回调函数success进入Event Queue。</li><li>主线程从Event Queue读取回调函数success并执行</li></ul><p>除了广义的同步任务和异步任务，我们对异步任务有更精细的定义：</p><ul><li>macro-task(宏任务)：包括整体代码script，setTimeout，setInterval</li><li>micro-task(微任务)：Promise，process.nextTick</li></ul><p>事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;   <span class="comment">//宏任务timeout1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//微任务process2</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//微任务then2</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//微任务process1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;7&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//微任务then1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//宏任务timeout2</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; 微任务process3</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;10&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;11&#x27;</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//微任务then3</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;12&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>宏任务：timeout1—timeout2<br>微任务：process1—then1—process2—then2—process3—then3<br>输出顺序：1—7—整个script宏任务执行完毕，执行所有微任务process1，then1，—6—8—执行宏任务timeout1—2—4—执行所有微任务process2，then2—3—5—执行宏任务timout2—9—11—执行所有微任务process3，then3—10—12</p><p>1、7、6、8、2、4、3、5、9、11、10、12</p><p>事件循环Event loop是js实现异步的一种方法，也是js的执行机制</p><p>Javascript是一门单线程语言，事件循环是javascript的执行机制</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>js是单线程非阻塞的脚本语言，意味着代码在js执行的任何时候只有一个主线程来处理所有任务。而非阻塞是指当代码需要异步处理的时候，主线程会挂起这个任务，当异步任务处理完毕后，主线程再根据一定规则去执行相应的回调。</p><p>当任务处理完毕，js会将这个事件加入一个队列，这个队列叫做事件队列。被放入事件队列中的事件不会立刻执行其回调，而是等待执行栈中所有任务都执行完毕后，主线程会查询事件队列中是否有任务。</p><p>异步任务分为：宏任务和微任务，不同类型的任务会被分配到不同的任务队列中。</p><p>当执行栈中所有任务都执行完毕后，会去检查微任务队列是否有事件存在，如果存在，会依次执行任务队列对应的回调，直到为空。然后去宏任务队列中取出一个事件，把对应的回调加入到当前执行战，当执行栈中所有任务都执行完毕后，检查为任务队列是否有事件存在。无限重复此过程，就形成了循环，这个循环就叫做事件循环。</p><p>微任务包括但不限于以下几种：</p><ul><li>Promise.then</li><li>MutationObserver</li><li>Object.observe</li><li>process.nextTick</li></ul><p>宏任务包括但不限于以下几种：</p><ul><li>setTimeout</li><li>setInterval</li><li>setImmediate</li><li>MessageChannel</li><li>requestAnimationFrame</li><li>I/O</li><li>UI交互事件</li></ul><h3 id="什么是执行栈？"><a href="#什么是执行栈？" class="headerlink" title="什么是执行栈？"></a>什么是执行栈？</h3><p>当我们执行一个方法时，js会生成一个与该方法对于的执行环境（context）,又叫执行上下文。这个执行环境有这个方法的私有作用域，上层作用域的指向，方法的参数，私有作用域中定义的变量和this指向。这个执行环境会被添加到一个执行栈中，这个栈就是执行栈。</p><p>如果这个方法的代码又执行到了一行函数的调用语句，那么js会生成这个函数的执行环境并将其添加到执行栈中，然后进入这个执行环境继续执行其中代码，执行完毕并返回结果后，js会退出执行环境并把这个执行环境从栈中销毁，回到上一个方法的执行栈。</p><p>$nextTick，下次dom更新渲染后执行延迟回调，其实是下次微任务执行时更新dom，而$nextTick只是将回调添加到微任务中。</p><p>vue中更新dom的回调也是使用$nextTick注册的回调，都是向微任务队列中添加任务。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-面试点</title>
      <link href="/ZJY.github.io/2021/01/20/vue-%E9%9D%A2%E8%AF%95%E7%82%B9/"/>
      <url>/ZJY.github.io/2021/01/20/vue-%E9%9D%A2%E8%AF%95%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="1-mvvm"><a href="#1-mvvm" class="headerlink" title="1.mvvm"></a>1.mvvm</h3><p>m,指数据模型（data）,v,指视图，UI组件，vm视图模型，把传统的mvc中controller演变成viewModel.<br>viewModel是view和model的桥梁，数据会绑定到viewModel并自动将数据渲染到页面，视图变化时会<br>通知viewModel层更新数据。</p><h3 id="2-vue2中响应式原理"><a href="#2-vue2中响应式原理" class="headerlink" title="2.vue2中响应式原理"></a>2.vue2中响应式原理</h3><p>在初始化数据时，会使用Object.defineProperty()方法重新定义data中到所有属性，在使用对于属性时，<br>首先进行依赖收集（收集当前组件到watcher），如果属性发生变化时会通知相关依赖进行更新操作（订阅/发布）</p><h3 id="3-vue3响应式原理"><a href="#3-vue3响应式原理" class="headerlink" title="3.vue3响应式原理"></a>3.vue3响应式原理</h3><p>vue3使用proxy替代了object.defineproperty，proxy可直接检测到数组和对象到变化。并且有13种拦截方法。</p><h3 id="4-vue3只会监测数组到第一层，vue3怎么解决？"><a href="#4-vue3只会监测数组到第一层，vue3怎么解决？" class="headerlink" title="4.vue3只会监测数组到第一层，vue3怎么解决？"></a>4.vue3只会监测数组到第一层，vue3怎么解决？</h3><p>判断Reflect.get到返回值类型是否为object，如果是用Reactive方法继续进行代理，实现数组到深度监测</p><h3 id="5-监测数组可能多次触发get-set方法，如何防止？"><a href="#5-监测数组可能多次触发get-set方法，如何防止？" class="headerlink" title="5.监测数组可能多次触发get/set方法，如何防止？"></a>5.监测数组可能多次触发get/set方法，如何防止？</h3><p>判断key是否为当前被代理对象target自身属性，或者新值和旧值是否相等，两者满足其一可触发trigger</p><h3 id="6-vue2如何监测数组变化？"><a href="#6-vue2如何监测数组变化？" class="headerlink" title="6.vue2如何监测数组变化？"></a>6.vue2如何监测数组变化？</h3><p>使用了函数劫持，并重写了数组方法。vue对data中数组进行了原型链重写，并指向了自己定义的数组原型方法，<br>当调用数组api时，进行依赖更新，当数组中存在引用类型时，会对引用类型再次递归遍历进行监控属性监测数组。</p><h3 id="7-nextTick"><a href="#7-nextTick" class="headerlink" title="7.nextTick"></a>7.nextTick</h3><p>在下次Dom更新循环之后执行延迟回调。主要使用了宏任务和微任务，根据执行环境分别尝试采用：<br>promise/mutationobserve/setimmediate/settimeout定义了一个异步方法，多次调用nextTick会将方法存入队列中，<br>通过这个异步方法清空队列。</p><h3 id="8-vue生命周期"><a href="#8-vue生命周期" class="headerlink" title="8.vue生命周期"></a>8.vue生命周期</h3><ul><li>beforeCreate:new Vue()后第一个钩子函数，在此阶段data/methods/computed/watch中方法和数据都不能被访问；</li><li>created:实例被创建之后，此时已完成数据观测，可以访问，更改数据，此时更改数据不回触发update函数，此时<br>可初始化数据，不可访问Dom，或者vm.$nextTick中进行访问</li><li>beforeMount:实例被挂载之前，template模版已导入渲染函数编译，此时虚拟dom已创建完成，即将开始渲染，可更新数据</li><li>mounted:实例被挂载之后，dom已挂载，数据完成双向绑定，可更新数据，通过ref访问真是dom</li><li>beforeUpdate:数据更新之前，响应式数据更新之前，虚拟dom重新渲染之前触发，可更新数据不触发update</li><li>updated:完成更新之后，dom已完成更新，避免此阶段更新数据，造成重复渲染</li><li>beforeDestory：实例销毁之前，实例扔可用，可做收尾清除工作</li><li>destoryed:实例被销毁后，实例不可用</li></ul><h3 id="9-接口请求放在哪个生命周期？"><a href="#9-接口请求放在哪个生命周期？" class="headerlink" title="9.接口请求放在哪个生命周期？"></a>9.接口请求放在哪个生命周期？</h3><p>mounted和created中都可，根据是否需要访问dom决定，但是服务器渲染不支持mounted,需要放在created中</p><h3 id="10-computed和watch区别？"><a href="#10-computed和watch区别？" class="headerlink" title="10.computed和watch区别？"></a>10.computed和watch区别？</h3><p>computed本质上是一个具有缓存的watcher,依赖的属性发生变化就会更新视图，使用于消耗性能的场景<br>watch没有缓存，起到观察的作用，可以监听数据执行回调，深度监听，deep：true</p><h3 id="11-v-if和v-show的区别？"><a href="#11-v-if和v-show的区别？" class="headerlink" title="11.v-if和v-show的区别？"></a>11.v-if和v-show的区别？</h3><p>v-if条件不成立时，不会渲染dom，v-show是display属性样式切换当前dom的显示和隐藏，<br>v-if有更高的切换消耗；v-show有更高的初始渲染消耗</p><h3 id="12-组件中的data为什么是一个函数？"><a href="#12-组件中的data为什么是一个函数？" class="headerlink" title="12.组件中的data为什么是一个函数？"></a>12.组件中的data为什么是一个函数？</h3><p>组件可以被多次复用，创建多个实例，这些实例本质是同一个构造函数，如果data是对象，对象是引用类型，<br>修改对象会影响所有实例，因此data是一个函数</p><h3 id="13-v-model的原理"><a href="#13-v-model的原理" class="headerlink" title="13.v-model的原理"></a>13.v-model的原理</h3><p>v-model是一个语法糖，是value+input的语法糖，根据model属性的prop和event属性来进行定义。原生的v-model会根据<br>标签的不同生成不同的事件和属性</p><h3 id="14-vue事件绑定原理"><a href="#14-vue事件绑定原理" class="headerlink" title="14.vue事件绑定原理"></a>14.vue事件绑定原理</h3><p>原生绑定事件通过addEventlistener绑定给真实原素的，组件事件绑定通过vue自定义的$on实现的</p><h3 id="15-vue模版编译的原理？"><a href="#15-vue模版编译的原理？" class="headerlink" title="15.vue模版编译的原理？"></a>15.vue模版编译的原理？</h3><p>vue的编译过程就是将template转化为render函数的过程，经历以下阶段：</p><ul><li>将模版解析为AST（抽象语法树）</li><li>遍历AST标记静态节点</li><li>使用AST生成渲染函数</li></ul><p>这三部分内容分别抽象出三个模块来实现各自的功能，分别是：</p><ul><li>解析器</li><li>优化器</li><li>代码生成器</li></ul><p>首先解析模版，生成AST树，使用正则对模版进行解析，对不同标签文本用不同钩子进行处理<br>vue数据是响应式对，但不是所有数据都是响应式的，有一些数据渲染后就不会发生变化，其Dom也不会<br>发生变化，深度遍历AST树，标记这些静态节点就可以跳过比对<br>将优化过后的AST树转化为可执行的代码</p><p>解析器的作用是通过模版得到AST<br>生成AST需要借助html解析器，当html解析器触发不同的钩子函数时，我们可以构建出不同的节点。<br>html解析器的内部原理是一小段一小段的截取模版字符串，每截取一小段字符串就会根据截取处理的字符串类型触发不同的钩子函数，直到模版字符串截空停止运行。</p><p>优化器的作用是在AST找出静态子树并打上标记，这样作有2个好处：</p><ul><li>每次重新渲染时，不需要为静态子树创建新节点。</li><li>在虚拟dom打补丁的过程可以跳过。</li></ul><h3 id="16-keep-alive"><a href="#16-keep-alive" class="headerlink" title="16.keep-alive"></a>16.keep-alive</h3><p>keep-alive可以实现组件缓存，当组件切换时不会对当前组件进行卸载<br>通过include/exclued实现组件有条件对进行缓存<br>两个生命周期activated/deactivated，用来判断当前组件是否处于活跃状态</p><h3 id="17-vue组件生命周期调用顺序？"><a href="#17-vue组件生命周期调用顺序？" class="headerlink" title="17.vue组件生命周期调用顺序？"></a>17.vue组件生命周期调用顺序？</h3><ul><li>组件调用顺序是先父后子，渲染完成顺序是先子后父</li><li>组件销毁顺序是先父后子，销毁完成顺序是先子后父</li></ul><p>加载渲染过程：<br>父beforeCreate-&gt;父created-&gt;父beforeMount-子beforecreate-子created-》子beforeMounted-》子mounted-》父mounted</p><p>子组件更新过程：<br>父beforeUpdated-》子beforeUpdated-》子updated-》父updated</p><p>父组件更新过程：<br>父beforeUpdated-》父updated</p><p>销毁过程：<br>父beforeDestory-》子beforeDestory-》子destoryed-》父destoryed</p><h3 id="18-vue2组件通信"><a href="#18-vue2组件通信" class="headerlink" title="18.vue2组件通信"></a>18.vue2组件通信</h3><ul><li>父子间通信： 父-》子： props       子-》父：$on  $emit<br>获取父子组件实例 ：$parent  $children<br>ref获取实例的方式调用组件的属性或方法</li><li>兄弟组件通信： Event Bus/vuex</li><li>跨级组件通信：vuex  /Event Bus /$attrs  $listeners /Provide  inject</li></ul><h3 id="19-SSR"><a href="#19-SSR" class="headerlink" title="19.SSR"></a>19.SSR</h3><p>SSR服务端渲染，就是在客户端把标签渲染成html的工作放在服务端完成，然后将html返回给客户端<br>SSR有更好的SEO，首屏加载速度快，缺点是服务端渲染只支持beforeCreate和created两个钩子，需要nodejs环境，<br>对服务器有更大对负载需求</p><h3 id="20-vue性能优化"><a href="#20-vue性能优化" class="headerlink" title="20.vue性能优化"></a>20.vue性能优化</h3><ul><li><p>编码阶段：</p><ul><li>减少data中数据</li><li>v-if和v-show不能连用</li><li>SPA采用keep-alive缓存组件</li><li>使用路由懒加载，异步组件</li><li>第三模块按需引入</li><li>图片懒加载</li><li>防抖、节流</li></ul></li><li><p>SEO优化：</p><ul><li>预渲染</li><li>服务端渲染</li></ul></li><li><p>打包优化：</p><ul><li>压缩代码</li><li>tree shaking</li><li>cdn加载第三方模块</li><li>sourcemap优化</li></ul></li></ul><h3 id="21-hash路由和history路由的实现原理"><a href="#21-hash路由和history路由的实现原理" class="headerlink" title="21.hash路由和history路由的实现原理"></a>21.hash路由和history路由的实现原理</h3><p>location.hash的值实际上就是url中#后面的值<br>history采用懒H5中提供的API来实现，主要有history.pushState() history.replaceState()</p><h3 id="22-vuex"><a href="#22-vuex" class="headerlink" title="22.vuex"></a>22.vuex</h3><p>vuex和全局对象的区别：<br>vuex的状态存储是响应式的，组件从store中读取状态，当store中的状态变化时，会更新组件<br>不能直接改变store中状态，必须显式提交mutation</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        count:<span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutation:&#123;</span><br><span class="line">        <span class="function"><span class="title">increment</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">            state.count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">store.commit(<span class="string">&#x27;increment&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(store.state.count); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>由于 store 中的状态是响应式的，在组件中调用 store 中的状态简单到仅需要在计算属性中返回即可。触发变化也仅仅是在组件的 methods 中提交 mutation</p><h3 id="23-什么是vuex"><a href="#23-什么是vuex" class="headerlink" title="23.什么是vuex"></a>23.什么是vuex</h3><p>vuex是专门为vuejs应用程序开发的状态管理插件，集中存储管理组件状态，通过显式提交mutation改变组件状态</p><h3 id="24-vuex解决了什么？"><a href="#24-vuex解决了什么？" class="headerlink" title="24.vuex解决了什么？"></a>24.vuex解决了什么？</h3><p>多个组件依赖同一个状态，多层组件间传值<br>来自不同的组件的行为需要变更同一个状态</p><p>怎么引用vuex？<br>1.安装依赖 npm install vuex –save<br>2.在项目目录创建store文件夹<br>3.在store文件夹下新建index。js文件，创建vuex实例<br>4.在main文件中引入vuex和store</p><p>vuex的5个核心属性？<br>state    mutation        getter        actions        modules</p><p>vuex的状态管理存储在state中，通过提交mutation改变状态</p><p>vuex中状态是对象时，使用时，要深度克隆赋值对象再修改，防止影响原始数据</p><p>vuex中action和mutation有什么区别？<br>action提交的是mutation，而不是直接变更状态，mutation可以直接变更状态<br>action是this.$store.dispatch()来提交，而mutation是this.$store.commit来提交<br>接收参数不同，mutation第一个参数是state，action是context</p><h3 id="25-重定向页面："><a href="#25-重定向页面：" class="headerlink" title="25.重定向页面："></a>25.重定向页面：</h3><p>routes:[{path:’/a’, redirect: ‘/b’ }]<br>配置404页面：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    path: <span class="string">&quot;/404&quot;</span>,</span><br><span class="line">    name: <span class="string">&quot;notFound&quot;</span>,</span><br><span class="line">    component: notFound</span><br><span class="line">&#125;, </span><br><span class="line">&#123;</span><br><span class="line">    path: <span class="string">&quot;*&quot;</span>, <span class="comment">// 此处需特别注意置于最底部</span></span><br><span class="line">    redirect: <span class="string">&quot;/404&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="26-路由几种模式，区别是什么？"><a href="#26-路由几种模式，区别是什么？" class="headerlink" title="26.路由几种模式，区别是什么？"></a>26.路由几种模式，区别是什么？</h3><ul><li>hash：兼容所有浏览器，但不支持H5 history api hash值为#后面的内容，通过监听hashChange事件<br>来完成操作实现前端路由，hash值变化不会请求服务器</li><li>history：依赖H5 history API实现前端路由，和正常url一样，但是初次请求或刷新会请求服务器，没有<br>请求到对于资源会返回404</li><li>abstract：支持所有js运行环境，如果发现没有浏览器到api路由会强制进入此模式</li></ul><h3 id="27-发布-订阅者模式："><a href="#27-发布-订阅者模式：" class="headerlink" title="27.发布/订阅者模式："></a>27.发布/订阅者模式：</h3><p>vue内部实现了双向绑定机制，可以不再操作dom，此机制是通过数据劫持结合发布/订阅者模式实现的：通过object.defineProperty()来劫持各个属性的getter,setter属性，在数据变动时发布消息给订阅者，触发相应的监听回调。<br>订阅模式和观察者模式不一致，订阅模式有一个调度中心，对订阅事件统一进行管理。而观察者模式可以随意注册事件，调用事件。</p><h3 id="28-数据双向绑定基础：Object-defineProperty"><a href="#28-数据双向绑定基础：Object-defineProperty" class="headerlink" title="28.数据双向绑定基础：Object.defineProperty()"></a>28.数据双向绑定基础：Object.defineProperty()</h3><ul><li>数据属性：</li></ul><p>configurable—能否用delete删除属性从而重新定义属性<br>enumerable—能否通过for-in遍历，即是否可枚举<br>writable—能否修改属性的值，默认为true<br>value—属性的数据值，默认为undefined<br>若要修改上述4个数据属性，需要Object.defineProperty(属性所在对象，属性名，描述符对象)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name:’’</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person,”name”,&#123;</span><br><span class="line">    writable: <span class="literal">false</span>,</span><br><span class="line">    name:”test”</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>访问器属性：</li></ul><p>访问器属性不包含数据值value，包含一对getter,setter函数（非必须）。value和writable和get/set不能共存。<br>configurable—能否用delete删除属性从而重新定义属性<br>enumerable—能否通过for-in遍历，即是否可枚举<br>get—读取属性调用的函数，默认为undefined<br>value—读取属性调用的函数，默认为undefined</p><p>Object.create(null): this.set = Object.create(null)这样赋值，这样写不需要考虑原型链上的属性，可以真正创建一个纯净的对象。</p><h3 id="29-es6"><a href="#29-es6" class="headerlink" title="29.es6"></a>29.es6</h3><p>export default和export的区别：<br>1.在一个文件或模块中，可以有多个export，而export default只能有一个<br>2.通过export方式导出，在导入时要加{},而export default则不需要</p><p>箭头函数：<br>1.箭头函数中的this的指向是固定不变的，即是定义函数时的指向<br>2.普通函数中的this的指向是变化的，即是使用函数时的指向<br>class继承：<br>可通过extends关键字实现继承。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.company=‘A’;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">testA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.company;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.exployee=<span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>super关键字，表示父类的构造函数，用来新建父类的this对象。super虽然代表类父类A的构造函数，但是返回的是子类B的实例，即super内部的this指向的是B，因此 super()在这里相当于A.prototype.constructor.call(this)</p><ul><li>es5和es6实现继承的不同：</li></ul><p>es5的继承，实质上是先创建子类的实例对象this,然后将父类的方法添加到this上，Parent.apply(this)<br>es6的继承，实质上是先创建父类的实例对象this，然后再用子类的构造函数修改this。</p><ul><li>proxy:</li></ul><p>vue3将会用proxy代替object.defineProperty()完成数据劫持工作，会使初始化速度加倍，内存占用减半。<br>var proxy = new Proxy(target,handler);target表示要拦截的对象，handler用来定制拦截的行为。</p><h3 id="30-闭包"><a href="#30-闭包" class="headerlink" title="30.闭包"></a>30.闭包</h3><p>闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常用方式，就是一个函数中创建另一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一段：</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">con</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="built_in">this</span>.num )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> funOne = fun();</span><br><span class="line"></span><br><span class="line">funOne();  <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二段</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">con</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( num )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> funOne = fun();</span><br><span class="line"></span><br><span class="line">funOne(); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h3 id="31-函数柯里化"><a href="#31-函数柯里化" class="headerlink" title="31.函数柯里化"></a>31.函数柯里化</h3><p>就是把多个参数的函数，转化为单参数函数。<br>add(2)(3)(4)(5)输出14:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum=<span class="number">0</span>;</span><br><span class="line">    sum= sum+num;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">tempFun</span>(<span class="params">numB</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">arguments</span>.length===<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sum= sum+ numB;</span><br><span class="line">            <span class="keyword">return</span> tempFun;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-大文件上传</title>
      <link href="/ZJY.github.io/2021/01/19/javascript-%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/ZJY.github.io/2021/01/19/javascript-%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<p>整体思路：</p><ul><li>前端：<br>前端大文件上传网上的大部分文章已经给出了解决方案，核心是利用 Blob.prototype.slice 方法，和数组的 slice 方法相似，调用的 slice 方法可以返回原文件的某个切片<br>这样我们就可以根据预先设置好的切片最大数量将文件切分为一个个切片，然后借助 http 的可并发性，同时上传多个切片，这样从原本传一个大文件，变成了同时传多个小的文件切片，可以大大减少上传时间<br>另外由于是并发，传输到服务端的顺序可能会发生变化，所以我们还需要给每个切片记录顺序</li><li>服务端：<br>服务端需要负责接受这些切片，并在接收到所有切片后合并切片</li></ul><p>上传控件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> @<span class="attr">change</span>=<span class="string">&quot;handleFileChange&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">&quot;handleUpload&quot;</span>&gt;</span>上传<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    data: <span class="function">() =&gt;</span> (&#123;</span></span><br><span class="line">        container: &#123;</span><br><span class="line"><span class="javascript">        file: <span class="literal">null</span></span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;),</span><br><span class="line">methods: &#123;</span><br><span class="line"><span class="javascript">    <span class="keyword">async</span> <span class="function"><span class="title">handleFileChange</span>(<span class="params">e</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> [file] = e.target.files;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (!file) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">Object</span>.assign(<span class="built_in">this</span>.$data, <span class="built_in">this</span>.$options.data());</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.container.file = file;</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        <span class="keyword">async</span> <span class="function"><span class="title">handleUpload</span>(<span class="params"></span>)</span> &#123;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>请求逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">request(&#123;</span><br><span class="line">    url,</span><br><span class="line">    method = <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    data,</span><br><span class="line">    headers=&#123;&#125;,</span><br><span class="line">    requestList</span><br><span class="line">&#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        xhr.open(method,url);</span><br><span class="line">        <span class="built_in">Object</span>.keys(headers).forEach(<span class="function"><span class="params">key</span>=&gt;</span>&#123;</span><br><span class="line">            xhr.setRequestHeader(key, headers[key])</span><br><span class="line">        &#125;);</span><br><span class="line">        xhr.send(data),</span><br><span class="line">        xhr.onload = <span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">            resolve(&#123;</span><br><span class="line">                data: e.target.response</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上传切片：</p><p>上传需要做两件事：<br>1.对文件进行切片<br>2.将切片传给服务器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"> <span class="keyword">const</span> LENGTH = <span class="number">10</span>; <span class="comment">// 切片数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">data: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    container: &#123;</span><br><span class="line">        file: <span class="literal">null</span>,</span><br><span class="line">         data: []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;),</span><br><span class="line">methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">request</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">handleFileChange</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">    <span class="comment">// 生成文件切片</span></span><br><span class="line">    <span class="function"><span class="title">createFileChunk</span>(<span class="params">file, length= LENGTH</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> fileChunkList = [];</span><br><span class="line">        <span class="keyword">const</span> chunkSize = <span class="built_in">Math</span>.ceil(file.size / length);<span class="comment">//切片大小</span></span><br><span class="line">        <span class="keyword">let</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="title">whilte</span>(<span class="params">cur &lt; file.size</span>)</span> &#123;</span><br><span class="line">            fileChunkList.push(&#123;<span class="attr">file</span>:file.slice(cur,curchunkSize)&#125;);</span><br><span class="line">            cur=chunkSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fileChunkList;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 上传切片</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">uploadChunks</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> requestList = <span class="built_in">this</span>.data.map(<span class="function">(<span class="params">&#123;chunk&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> formData = <span class="keyword">new</span> formData();</span><br><span class="line">            formData.append(<span class="string">&quot;chunk&quot;</span>,chunk);</span><br><span class="line">            formData.append(<span class="string">&quot;hash&quot;</span>,hash);</span><br><span class="line">            formData.append(<span class="string">&quot;filename&quot;</span>,<span class="built_in">this</span>.container.file.name);</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                formData;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).map(<span class="keyword">async</span> (&#123;formData&#125;)=&gt;&#123;</span><br><span class="line">            <span class="built_in">this</span>.request(&#123;</span><br><span class="line">                url:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                data: formData</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">await</span> <span class="built_in">Promise</span>.all(requestList);<span class="comment">//并发切片</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">handleUpload</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(!<span class="built_in">this</span>.container.file) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">const</span> fileChunkList = <span class="built_in">this</span>.createFileChunk(<span class="built_in">this</span>.container.file);</span><br><span class="line">        <span class="built_in">this</span>.data = fileChunkList.map(<span class="function">(<span class="params">&#123;file&#125;,index</span>)=&gt;</span>&#123;</span><br><span class="line">            chunk: file,</span><br><span class="line">            hash: <span class="built_in">this</span>.container.file.name  <span class="string">&#x27;-&#x27;</span> index, <span class="comment">//文件名数组下标</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">await</span> <span class="built_in">this</span>.uploadChunks();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>当点击上传按钮时，调用 createFileChunk 将文件切片，切片数量通过一个常量 Length 控制，这里设置为 10，即将文件分成 10 个切片上传<br>createFileChunk 内使用 while 循环和 slice 方法将切片放入 fileChunkList 数组中返回<br>在生成文件切片时，需要给每个切片一个标识作为 hash，这里暂时使用文件名  下标，这样后端可以知道当前切片是第几个切片，用于之后的合并切片<br>随后调用 uploadChunks 上传所有的文件切片，将文件切片，切片 hash，以及文件名放入 FormData 中，再调用上一步的 request 函数返回一个 proimise，最后调用 Promise.all 并发上传所有的切片</p><p>发送合并请求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">await</span> <span class="built_in">Promise</span>.all(requestList);</span><br><span class="line"> <span class="comment">// 合并切片</span></span><br><span class="line"><span class="keyword">await</span> <span class="built_in">this</span>.mergeRequest();</span><br><span class="line"> <span class="keyword">async</span> <span class="function"><span class="title">mergeRequest</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="keyword">await</span> <span class="built_in">this</span>.request(&#123;</span><br><span class="line">         url: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">         headers: &#123;</span><br><span class="line">             <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">         &#125;,</span><br><span class="line">         data: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">             filename: <span class="built_in">this</span>.container.file.name</span><br><span class="line">         &#125;)</span><br><span class="line">     &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>服务端部分：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&quot;request&quot;</span>, <span class="keyword">async</span>(req, res)=&gt;&#123;</span><br><span class="line">    res.retHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>,<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    res.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>,<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(res.method == <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">        res.status = <span class="number">200</span>;</span><br><span class="line">        res.end();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function">()=&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;listening on port:3000&quot;</span>));</span><br></pre></td></tr></table></figure><p>接受切片：</p><p>使用multiparty包处理前端传来的formdata,在 multiparty.parse 的回调中，files 参数保存了 FormData 中文件，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">fields 参数保存了 FormData 中非文件的字段.</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fse = <span class="built_in">require</span>(<span class="string">&quot;fs-extra&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> multiparty = <span class="built_in">require</span>(<span class="string">&quot;multiparty&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"> <span class="keyword">const</span> UPLOAD_DIR = path.resolve(__dirname, <span class="string">&quot;..&quot;</span>, <span class="string">&quot;target&quot;</span>); <span class="comment">// 大文件存储目录</span></span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&quot;request&quot;</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">res.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">res.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (req.method === <span class="string">&quot;OPTIONS&quot;</span>) &#123;</span><br><span class="line">    res.status = <span class="number">200</span>;</span><br><span class="line">    res.end();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> multipart = <span class="keyword">new</span> multiparty.Form();</span><br><span class="line"></span><br><span class="line">  multipart.parse(req, <span class="keyword">async</span> (err, fields, files) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> [chunk] = files.chunk;</span><br><span class="line">    <span class="keyword">const</span> [hash] = fields.hash;</span><br><span class="line">    <span class="keyword">const</span> [filename] = fields.filename;</span><br><span class="line">    <span class="keyword">const</span> chunkDir = <span class="string">`<span class="subst">$&#123;UPLOAD_DIR&#125;</span>/<span class="subst">$&#123;filename&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 切片目录不存在，创建切片目录</span></span><br><span class="line">    <span class="keyword">if</span> (!fse.existsSync(chunkDir)) &#123;</span><br><span class="line">      <span class="keyword">await</span> fse.mkdirs(chunkDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重命名文件</span></span><br><span class="line">    <span class="keyword">await</span> fse.rename(chunk.path, <span class="string">`<span class="subst">$&#123;chunkDir&#125;</span>/<span class="subst">$&#123;hash&#125;</span>`</span>);</span><br><span class="line">    res.end(<span class="string">&quot;received file chunk&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;正在监听 3000 端口&quot;</span>));</span><br></pre></td></tr></table></figure><p>合并切片：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fse = <span class="built_in">require</span>(<span class="string">&quot;fs-extra&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer();</span><br><span class="line"><span class="keyword">const</span> UPLOAD_DIR = path.resolve(__dirname, <span class="string">&quot;..&quot;</span>, <span class="string">&quot;target&quot;</span>); <span class="comment">// 大文件存储目录</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">const</span> resolvePost = <span class="function"><span class="params">req</span> =&gt;</span></span><br><span class="line">   <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">let</span> chunk = <span class="string">&quot;&quot;</span>;</span><br><span class="line">     req.on(<span class="string">&quot;data&quot;</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">       chunk = data;</span><br><span class="line">     &#125;);</span><br><span class="line">     req.on(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">       resolve(<span class="built_in">JSON</span>.parse(chunk));</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 合并切片</span></span><br><span class="line"> <span class="keyword">const</span> mergeFileChunk = <span class="keyword">async</span> (filePath, filename) =&gt; &#123;</span><br><span class="line">   <span class="keyword">const</span> chunkDir = <span class="string">`<span class="subst">$&#123;UPLOAD_DIR&#125;</span>/<span class="subst">$&#123;filename&#125;</span>`</span>;</span><br><span class="line">   <span class="keyword">const</span> chunkPaths = <span class="keyword">await</span> fse.readdir(chunkDir);</span><br><span class="line">   <span class="keyword">await</span> fse.writeFile(filePath, <span class="string">&quot;&quot;</span>);</span><br><span class="line">   chunkPaths.forEach(<span class="function"><span class="params">chunkPath</span> =&gt;</span> &#123;</span><br><span class="line">     fse.appendFileSync(filePath, fse.readFileSync(<span class="string">`<span class="subst">$&#123;chunkDir&#125;</span>/<span class="subst">$&#123;chunkPath&#125;</span>`</span>));</span><br><span class="line">     fse.unlinkSync(<span class="string">`<span class="subst">$&#123;chunkDir&#125;</span>/<span class="subst">$&#123;chunkPath&#125;</span>`</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">   fse.rmdirSync(chunkDir); <span class="comment">// 合并后删除保存切片的目录</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&quot;request&quot;</span>, <span class="keyword">async</span> (req, res) =&gt; &#123;</span><br><span class="line">res.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">res.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (req.method === <span class="string">&quot;OPTIONS&quot;</span>) &#123;</span><br><span class="line">    res.status = <span class="number">200</span>;</span><br><span class="line">    res.end();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (req.url === <span class="string">&quot;/merge&quot;</span>) &#123;</span><br><span class="line">     <span class="keyword">const</span> data = <span class="keyword">await</span> resolvePost(req);</span><br><span class="line">     <span class="keyword">const</span> &#123; filename &#125; = data;</span><br><span class="line">     <span class="keyword">const</span> filePath = <span class="string">`<span class="subst">$&#123;UPLOAD_DIR&#125;</span>/<span class="subst">$&#123;filename&#125;</span>`</span>;</span><br><span class="line">     <span class="keyword">await</span> mergeFileChunk(filePath, filename);</span><br><span class="line">     res.end(</span><br><span class="line">       <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">         code: <span class="number">0</span>,</span><br><span class="line">         message: <span class="string">&quot;file merged success&quot;</span></span><br><span class="line">       &#125;)</span><br><span class="line">     );</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;正在监听 3000 端口&quot;</span>));</span><br></pre></td></tr></table></figure><p>总结：<br>前端上传大文件时使用blob.prototype.slice将文件切片，并发上传多个切片，最后发送一个合并的请求通知服务端合并切片。<br>服务端接收切片并存储，收到合并请求后使用fs.appendFileSync对多个切片进行合并<br>原生XMLHttpRequest的upload.onpropgress对切片上传进度的监听<br>使用vue计算属性根据每个切片的进度算出整个文件的上传进度</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-前端路由</title>
      <link href="/ZJY.github.io/2021/01/19/javascript-%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/"/>
      <url>/ZJY.github.io/2021/01/19/javascript-%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由?"></a>什么是路由?</h3><p>简单的说 路由就是根据不同的url地址来展示不同的内容或页面.</p><h3 id="前端路由的来源"><a href="#前端路由的来源" class="headerlink" title="前端路由的来源"></a>前端路由的来源</h3><p>在很久很久以前~ 用户的每次更新操作都需要重新刷新页面,非常的影响交互体验,后来,为了解决这个问题,便有了Ajax(异步加载方案),Ajax给体验带来了极大的提升。<br>虽然Ajax解决了用户交互时体验的痛点,但是多页面之间的跳转一样会有不好的体验,所以便有了spa(single-page application)使用的诞生。而spa应用便是基于前端路由实现的,所以便有了前端路由<br>如今比较火的vue-router/react-router 也是基于前端路由的原理实现的~</p><h3 id="前端路由的两种实现原理"><a href="#前端路由的两种实现原理" class="headerlink" title="前端路由的两种实现原理"></a>前端路由的两种实现原理</h3><p>1.Hash模式</p><pre><code>window对象提供了onhashchange事件来监听hash值的改变,一旦url中的hash值发生改变,便会触发该事件。window.onhashchange = function()&#123;&#125;</code></pre><p>2.history模式</p><pre><code>HTML5的History API 为浏览器的全局history对象增加的扩展方法。简单来说,history其实就是浏览器历史栈的一个接口window对象提供了onpopstate事件来监听历史栈的改变,一旦历史栈信息发生改变,便会触发该事件。需要特别注意的是,调用history.pushState()或history.replaceState()不会触发popstate事件。只有在做出浏览器动作时，才会触发该事件。window.onpopstate = function()&#123;// 历史栈 信息改变// do you want&#125;history提供了两个操作历史栈的API:history.pushState 和 history.replaceState：history.pushState(data[,title][,url]);//向历史记录中追加一条记录history.replaceState(data[,title][,url]);//替换当前页在历史记录中的信息。// data: 一个JavaScript对象，与用pushState()方法创建的新历史记录条目关联。无论何时用户导航到新创建的状态，popstate事件都会被触发，并且事件对象的state属性都包含历史记录条目的状态对象的拷贝。//title: FireFox浏览器目前会忽略该参数，虽然以后可能会用上。考虑到未来可能会对该方法进行修改，传一个空字符串会比较安全。或者，你也可以传入一个简短的标题，标明将要进入的状态。//url: 新的历史记录条目的地址。浏览器不会在调用pushState()方法后加载该地址，但之后，可能会试图加载，例如用户重启浏览器。新的URL不一定是绝对路径；如果是相对路径，它将以当前URL为基准；传入的URL与当前URL应该是同源的，否则，pushState()会抛出异常。该参数是可选的；不指定的话则为文档当前URL。pushState操作：    history.pushState(&#123;&quot;foo&quot;:bar&#125;,&quot;page 2&quot;,&quot;apply&quot;)    history.state;   //输出 &#123;foo:&quot;bar&quot;&#125;    window.onpopstate = function()&#123;        console.log(&#39;router&#39;);    &#125;    history.pushState(&#123;&quot;foo&quot;:&quot;bar1&quot;&#125;,&quot;page2&quot;,&quot;apply&quot;);// 此时执行不触发onpopstate方法    history.state； //输出 &#123;foo:&#39;bar1&#39;&#125;    history.back(); //做出后退操作，触发onpopstate事件，此时输出 &#39;router&#39;    history.state; //输出 &#123;foo:&quot;bar&quot;&#125;    history.forward(); //做前进操作，触发onpopstate事件，此时输出 &#39;router&#39;    history.state; //输出 &#123;foo:&quot;bar1&quot;&#125;replaceState操作：    history.back();    history.state; //输出 &#123;foo:bar&#125; 当前是bar    history.replaceState(&#123;&quot;foo&quot;:&quot;barreplace&quot;&#125;,&quot;page2&quot;,&quot;test&quot;);//不触发onpopstate事件， 此时浏览器地址改为test,并不重新加载    history.state; //输出：&#123;foo:&quot;barreplace&quot;&#125;    history.forward(); //触发onpopstate事件，输出&#39;router&#39;    history.state;  //输出： &#123;foo:&quot;bar1&quot;&#125;    history.back();//触发onpopstate事件，输出&#39;router&#39;,重新加载test    history.state; //输出：&#123;foo:&quot;barreplace&quot;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-小程序云开发</title>
      <link href="/ZJY.github.io/2021/01/19/javascript-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91/"/>
      <url>/ZJY.github.io/2021/01/19/javascript-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>1.云开发：</p><p>云开发是原生Serverless云服务。<br>云开发与传统模式相比少了后端开发这一块。</p><p>2.云开发能力：</p><p>存储<br>云函数<br>云数据库<br>音视频服务<br>智能图像服务<br>一天多交付，快速迭代产品</p><p>3.初始化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wx.cloud.init(&#123;</span><br><span class="line">    <span class="comment">// env 参数说明：</span></span><br><span class="line">    <span class="comment">//   env 参数决定接下来小程序发起的云开发调用（wx.cloud.xxx）会默认请求到哪个云环境的资源</span></span><br><span class="line">    <span class="comment">//   此处请填入环境 ID, 环境 ID 可打开云控制台查看</span></span><br><span class="line">    <span class="comment">//   如不填则使用默认环境（第一个创建的环境）</span></span><br><span class="line">    env: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    traceUser: <span class="literal">true</span>, <span class="comment">//是否在云开发控制台可见用户信息</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>4.数据库</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> db = wx.cloud.database();</span><br><span class="line"><span class="keyword">const</span> _ = db.command</span><br><span class="line">db.collection(<span class="string">&#x27;集合名&#x27;</span>).get().then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p>1.get()查询<br>2.where条件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">counter不等于<span class="number">1</span>  <span class="number">3</span>  <span class="number">4</span>的记录</span><br><span class="line">where(&#123;</span><br><span class="line">    counter: _.nin([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">&#125;)</span><br><span class="line">counter等于<span class="number">1</span>  <span class="number">3</span>  <span class="number">4</span>的记录</span><br><span class="line">where(&#123;</span><br><span class="line">    counter: _.in([<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3.字段类型查询</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.collection(<span class="string">&quot;data&quot;</span>)</span><br><span class="line">.field(&#123;</span><br><span class="line">    desc: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">.get().then(<span class="built_in">console</span>.log)</span><br><span class="line">查询所有数据但只显示有desc字段的内容，例如：</span><br><span class="line"><span class="number">0</span>: &#123;<span class="attr">_id</span>: <span class="string">&quot;dbbb40a0-a4e0-479d-8432-926d05b002a8&quot;</span>&#125;</span><br><span class="line"><span class="number">1</span>: &#123;<span class="attr">_id</span>: <span class="string">&quot;37aa3ea0-db49-4c12-849f-34e5342966da&quot;</span>, <span class="attr">desc</span>: <span class="string">&quot;name2&quot;</span>&#125;</span><br><span class="line"><span class="number">2</span>: &#123;<span class="attr">_id</span>: <span class="string">&quot;1d6ff516-5714-4970-9a28-a0f8b3f7a3e6&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>4.正则查询<br>可以使用原生的正则对象：<br>    /miniprogram/i<br>db.RegExp对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.RegExp(&#123;</span><br><span class="line">    regexp: <span class="string">&#x27;miniprogram&#x27;</span>,</span><br><span class="line">    options: <span class="string">&#x27;i&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>查询name值以name-0开头的数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    db.collection(<span class="string">&quot;data&quot;</span>)</span><br><span class="line">    .where(&#123;</span><br><span class="line">        name: <span class="keyword">new</span> db.RegExp(&#123;</span><br><span class="line">            regexp: <span class="string">&#x27;name-0[1-9]&#x27;</span>,</span><br><span class="line">            options: <span class="string">&#x27;i&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .get().then(<span class="built_in">console</span>.log)</span><br><span class="line"><span class="number">0</span>: &#123;<span class="attr">_id</span>: <span class="string">&quot;dbbb40a0-a4e0-479d-8432-926d05b002a8&quot;</span>, <span class="attr">counter</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;name-01&quot;</span>&#125;</span><br><span class="line"><span class="number">1</span>: &#123;<span class="attr">_id</span>: <span class="string">&quot;37aa3ea0-db49-4c12-849f-34e5342966da&quot;</span>, <span class="attr">counter</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&quot;name-02&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>5.地理位置查询</p><p>添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.collection(<span class="string">&#x27;location&#x27;</span>).add(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        location: db.Geo.Point(<span class="number">100.2333</span>,<span class="number">10.9978</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>查询：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.collection(<span class="string">&#x27;location&#x27;</span>).get().then( <span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res.data[<span class="number">0</span>].location)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>6.云开发数据库权限：</p><p>1.仅创建者可写，所有人可读<br>2.仅创建者可读写<br>3.仅管理端可写，所有人可读<br>4.仅管理端可读写</p><p>存储：</p><p>可使用fileid引用存储的资源</p><p>生成文件的临时链接：</p><p>为什么生成临时链接： fileid无法在小程序以外的平台使用<br>如何生成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wx.cloud.getTempFileURL(&#123;</span><br><span class="line">    fileList: [<span class="string">&#x27;cloud://zjy20200115-8v2oc.7a6a-zjy20200115-8v2oc-1258009129/oL40f5Rxp9wplmcEtUO3Av-4Yr9M/0.5019968125178349_1579073268192.jpg&#x27;</span>],<span class="comment">//fileid</span></span><br><span class="line">    success:<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res.fileList[<span class="number">0</span>].tempFileURL)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用云函数定时器：</p><p>1.在云函数目录下创建config.json文件，并设置触发器<br>2.上传触发器<br>步骤：<br>    1.创建云函数trigger<br>    2.上传云函数<br>    3.云函数目录下trigger创建config.json文件：添加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;triggers&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;trigger&quot;</span>, <span class="comment">//触发器名字</span></span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;timer&quot;</span>, <span class="comment">//类型：定时器</span></span><br><span class="line">            <span class="string">&quot;config&quot;</span>: <span class="string">&quot;* * * * * * *&quot;</span> <span class="comment">//触发事件配置，七位从右到左代表：年 星期 月 日 时 分 秒 ；七个*代表每秒钟执行一次</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.上传触发器<br>5.在云开发控制台-云函数-日志可查看</p><p>获取集合中指定记录的引用</p><p>db.collection(‘todos’).doc(‘my-todo-id’)<br>方法接受一个 id 参数，指定需引用的记录的 _id</p><p>limit(number):指定查询结果集数量上限:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.collection(<span class="string">&#x27;todos&#x27;</span>).limit(<span class="number">10</span>)</span><br><span class="line">.get()</span><br><span class="line">.then(<span class="built_in">console</span>.log)</span><br><span class="line">.catch(<span class="built_in">console</span>.error)</span><br></pre></td></tr></table></figure><p>skip(offset:number): 指定查询返回结果时从指定序列后的结果开始返回，常用于分页</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.collection(<span class="string">&#x27;todos&#x27;</span>).skip(<span class="number">10</span>)</span><br><span class="line">.get()</span><br><span class="line">.then(<span class="built_in">console</span>.log)</span><br><span class="line">.catch(<span class="built_in">console</span>.error)</span><br></pre></td></tr></table></figure><p>云上传：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wx.chooseImage(&#123;</span><br><span class="line">    success: <span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        wx.cloud.uploadFile(&#123;</span><br><span class="line">            cloudPath: <span class="string">&#x27;images/xx.png&#x27;</span>,</span><br><span class="line">            filePath: res.tempFilePaths[<span class="number">0</span>],</span><br><span class="line">        &#125;).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res.fileID)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>定位：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">wx.chooseLocation(&#123;</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res)</span><br><span class="line">        that.setData(&#123;</span><br><span class="line">            location:&#123;</span><br><span class="line">                name: res.name,</span><br><span class="line">                latitude: res.latitude,</span><br><span class="line">                longitude: res.longitude,</span><br><span class="line">                address: res.address</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>查看定位：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wx.openLocation(&#123;</span><br><span class="line">    latitude: <span class="built_in">this</span>.data.todoInfo.location.latitude,</span><br><span class="line">    longitude: <span class="built_in">this</span>.data.todoInfo.location.longitude,</span><br><span class="line">    name: <span class="built_in">this</span>.data.todoInfo.location.name,</span><br><span class="line">    address: <span class="built_in">this</span>.data.todoInfo.location.address   </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>report-submit： true,给表单此属性设置为true,会返回formId,用于发送模板消息</p><p>云函数查询数据：</p><p>新建云函数：query：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cloud = <span class="built_in">require</span>(<span class="string">&#x27;wx-server-sdk&#x27;</span>)</span><br><span class="line">cloud.init()</span><br><span class="line"><span class="keyword">const</span> db = cloud.database()</span><br><span class="line"><span class="comment">// 云函数入口函数</span></span><br><span class="line"><span class="built_in">exports</span>.main = <span class="keyword">async</span> (event, context) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> db.collection(<span class="string">&#x27;todos&#x27;</span>).get();</span><br><span class="line">&#125;</span><br><span class="line">页面查询触发：</span><br><span class="line">wx.cloud.callFunction(&#123;</span><br><span class="line">    name: <span class="string">&#x27;query&#x27;</span>,</span><br><span class="line">&#125;).then(<span class="built_in">console</span>.log)</span><br><span class="line"></span><br><span class="line">添加： add(&#123;<span class="attr">data</span>:&#123;&#125;&#125;)</span><br><span class="line">删除： remove()</span><br><span class="line">编辑： update(&#123;</span><br><span class="line">    data:&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在云函数中使用存储资源：</p><p>1.上传文件： uploadFile</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.main = <span class="keyword">async</span> (event, context) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> fileStream = fs.createReadStream(path.join(__dirname, <span class="string">&#x27;demo.jpg&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> cloud.uploadFile(&#123;</span><br><span class="line">        cloudPath: <span class="string">&#x27;demo.jpg&#x27;</span>,</span><br><span class="line">        fileContent: fileStream,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.下载文件： downloadFile<br>3.获取临时文件链接： getTempFileURL<br>4.删除文件： deleteFile</p><p>云函数访问第三方服务器:</p><p>1.安装got （版本9.6.0，10以上版本调用失败）<br>2.开启npm 模块<br>3.云函数修改后需重新上传</p><p>云函数访问数据库：</p><p>1.安装mysql2: npm i mysql2<br>2.引入： const mysql2 = require(‘mysql2’);<br>3.连接：<br>    const connection = await mysql.createConnection({<br>        host: ‘192.168.3.66’,<br>        port: ‘3306’,<br>        user: ‘root’,<br>        database: ‘sample’,<br>        password: ‘123456’<br>    })<br>    await connection.execute(“SELECT version();”)</p><p>云函数中生成小程序二维码：</p><p>1.引用安装wx-js-utils：npm install wx-js-utils<br>2.获取token和小程序id等信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">    WXMINIUser,</span><br><span class="line">    WXMINIQR</span><br><span class="line">&#125; = <span class="built_in">require</span>(<span class="string">&#x27;wx-js-utils&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> appId = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 小程序 appId</span></span><br><span class="line"><span class="keyword">const</span> secret = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 小程序 secret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取小程序码，A接口</span></span><br><span class="line"><span class="keyword">let</span> wXMINIUser = <span class="keyword">new</span> WXMINIUser(&#123;</span><br><span class="line">    appId,</span><br><span class="line">    secret</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般需要先获取 access_token</span></span><br><span class="line"><span class="keyword">let</span> access_token = <span class="keyword">await</span> wXMINIUser.getAccessToken();</span><br><span class="line"><span class="keyword">let</span> wXMINIQR = <span class="keyword">new</span> WXMINIQR();</span><br></pre></td></tr></table></figure><p>3.获取二维码api: getQR</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">options: &#123;</span><br><span class="line">    access_token,</span><br><span class="line">    path,<span class="comment">//</span></span><br><span class="line">    width</span><br><span class="line">&#125;</span><br><span class="line">示例：</span><br><span class="line"><span class="keyword">let</span> qrResult = <span class="keyword">await</span> wXMINIQR.getQR(&#123;</span><br><span class="line">    access_token,</span><br><span class="line">    path: <span class="string">&#x27;pages/index/index&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line">上传：</span><br><span class="line">wx.cloud.uploadFile(&#123;bn </span><br><span class="line">    cloudPath: <span class="string">&#x27;qr/qr.png&#x27;</span>,</span><br><span class="line">    fileConent: qrResult</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>腾讯云短信sdk: qcloudsms_js</p><p>npm i qcloudsms_js</p><p>微信支付： node tenpay</p><p>npm i tenpay</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack-webpack打包原理</title>
      <link href="/ZJY.github.io/2021/01/19/webpack-webpack%E6%89%93%E5%8C%85%E5%8E%9F%E7%90%86/"/>
      <url>/ZJY.github.io/2021/01/19/webpack-webpack%E6%89%93%E5%8C%85%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是webpack？"><a href="#什么是webpack？" class="headerlink" title="什么是webpack？"></a>什么是webpack？</h4><p>本质上，webpack是一个现代javascript应用程序的静态模块打包器（module bundler).当webpack处理应用程序时，它会递归地构建一个依赖关系图，<br>其中包含应用程序的需要的每个模块，然后将所有这些模块打包成一个或多个bundle.<br>webpack 就像一条生产线,要经过一系列处理流程后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的,多个流程之间有存在依赖关系,只有完成当前处理后才能交给下一个流程去处理。 插件就像是一个插入到生产线中的一个功能,在特定的时机对生产线上的资源做处理。webpack 通过 Tapable 来组织这条复杂的生产线。 webpack 在运行过程中会广播事件,插件只需要监听它所关心的事件,就能加入到这条生产线中,去改变生产线的运作。 webpack 的事件流机制保证了插件的有序性,使得整个系统扩展性很好</p><h4 id="webpack-核心概念"><a href="#webpack-核心概念" class="headerlink" title="webpack 核心概念"></a>webpack 核心概念</h4><p>1.entry<br>入口起点(entry point)指示 webpack 应该使用哪个模块,来作为构建其内部依赖图的开始.<br>进入入口起点后,webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。<br>每个依赖项随即被处理,最后输出到称之为 bundles 的文件中。</p><p>2.output<br>output 属性告诉 webpack 在哪里输出它所创建的 bundles,以及如何命名这些文件,默认值为 ./dist。<br>基本上,整个应用程序结构,都会被编译到你指定的输出路径的文件夹中。</p><p>3.Module<br>模块,在 Webpack 里一切皆模块,一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块</p><p>4.chunk<br>代码块,一个 Chunk 由多个模块组合而成,用于代码合并与分割。</p><p>5.loader<br>loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。<br>loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块,然后你就可以利用 webpack 的打包能力,对它们进行处理。<br>本质上,webpack loader 将所有类型的文件,转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。</p><p>6.Plugin<br>loader 被用于转换某些类型的模块,而插件则可以用于执行范围更广的任务。<br>插件的范围包括,从打包优化和压缩,一直到重新定义环境中的变量。插件接口功能极其强大,可以用来处理各种各样的任务。</p><h4 id="webpack-构建流程"><a href="#webpack-构建流程" class="headerlink" title="webpack 构建流程"></a>webpack 构建流程</h4><p>Webpack 的运行流程是一个串行的过程,从启动到结束会依次执行以下流程:<br>1.初始化参数：从配置文件和 Shell 语句中读取与合并参数,得出最终的参数<br>2.开始编译: 用上一步得到的参数初始化 Compiler 对象,加载所有配置的插件,执行对象的 run 方法开始执行编译。<br>3.确定入口：根据配置中的 entry 找出所有的入口文件<br>4.编译模块：从入口文件出发,调用所有配置的 Loader 对模块进行翻译,再找出该模块依赖的模块,再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理。<br>5.完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后,得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。<br>6.输出资源：根据入口和模块之间的依赖关系,组装成一个个包含多个模块的 Chunk,再把每个 Chunk 转换成一个单独的文件加入到输出列表,这步是可以修改输出内容的最后机会<br>7.输出完成：在确定好输出内容后,根据配置确定输出的路径和文件名,把文件内容写入到文件系统<br>在以上过程中,Webpack 会在特定的时间点广播出特定的事件,插件在监听到感兴趣的事件后会执行特定的逻辑,并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack-webpack基础使用</title>
      <link href="/ZJY.github.io/2021/01/19/webpack-webpack%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
      <url>/ZJY.github.io/2021/01/19/webpack-webpack%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h5 id="使用lodash-是一个一致性、模块化、高性能的-JavaScript-实用工具库"><a href="#使用lodash-是一个一致性、模块化、高性能的-JavaScript-实用工具库" class="headerlink" title="使用lodash:是一个一致性、模块化、高性能的 JavaScript 实用工具库"></a>使用lodash:是一个一致性、模块化、高性能的 JavaScript 实用工具库</h5><p>要使用lodash 需要本地安装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--npm install --save lodash</span><br></pre></td></tr></table></figure><h5 id="在安装一个要打包到生产环境的安装包时，你应该使用-npm-install-–save，如果你在安装一个用于开发环境的安装包（例如，linter-测试库等），你应该使用-npm-install-–save-dev。请在-npm-文档-中查找更多信息"><a href="#在安装一个要打包到生产环境的安装包时，你应该使用-npm-install-–save，如果你在安装一个用于开发环境的安装包（例如，linter-测试库等），你应该使用-npm-install-–save-dev。请在-npm-文档-中查找更多信息" class="headerlink" title="在安装一个要打包到生产环境的安装包时，你应该使用 npm install –save，如果你在安装一个用于开发环境的安装包（例如，linter, 测试库等），你应该使用 npm install –save-dev。请在 npm 文档 中查找更多信息"></a>在安装一个要打包到生产环境的安装包时，你应该使用 npm install –save，如果你在安装一个用于开发环境的安装包（例如，linter, 测试库等），你应该使用 npm install –save-dev。请在 npm 文档 中查找更多信息</h5><h5 id="加载css"><a href="#加载css" class="headerlink" title="加载css"></a>加载css</h5><p>为了从 JavaScript 模块中 import 一个 CSS 文件，你需要在 module 配置中 安装并添加 style-loader 和 css-loader：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--npm install --save-dev style-loader css-loader</span><br></pre></td></tr></table></figure><p>在webpack.config.js中配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">                use:[</span><br><span class="line">                    <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="加载图片：-在Css中有背景和图标等图片，需要安装file-loader来处理"><a href="#加载图片：-在Css中有背景和图标等图片，需要安装file-loader来处理" class="headerlink" title="加载图片：  在Css中有背景和图标等图片，需要安装file-loader来处理"></a>加载图片：  在Css中有背景和图标等图片，需要安装file-loader来处理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev file-loader</span><br></pre></td></tr></table></figure><p>在配置文件中配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test:<span class="regexp">/\.(png|svg|jpg|gif)&amp;/</span>,</span><br><span class="line">        use:[</span><br><span class="line">            <span class="string">&#x27;file-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="加载字体：-file-loader-和-url-loader-可以接收并加载任何文件，然后将其输出到构建目录"><a href="#加载字体：-file-loader-和-url-loader-可以接收并加载任何文件，然后将其输出到构建目录" class="headerlink" title="加载字体： file-loader 和 url-loader 可以接收并加载任何文件，然后将其输出到构建目录"></a>加载字体： file-loader 和 url-loader 可以接收并加载任何文件，然后将其输出到构建目录</h3><p>在配置文件中配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test:<span class="regexp">/\.(woff|woff2|eot|ttf|otf)$/</span>,</span><br><span class="line">        use:[</span><br><span class="line">            <span class="string">&#x27;file-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此外，可以加载的有用资源还有数据，如 JSON 文件，CSV、TSV 和 XML。类似于 NodeJS，JSON 支持实际上是内置的，也就是说 import Data from ‘./data.json’ 默认将正常运行。要导入 CSV、TSV 和 XML，你可以使用 csv-loader 和 xml-loader：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev csv-loader xml-loader</span><br></pre></td></tr></table></figure><p>在配置文件中配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        test:<span class="regexp">/\.(csv|tsv)$/</span>,</span><br><span class="line">        use:[</span><br><span class="line">            <span class="string">&#x27;csv-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        test:<span class="regexp">/\.xml$/</span>,</span><br><span class="line">        use:[</span><br><span class="line">            <span class="string">&#x27;xml-loader&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><p>如果我们更改了我们的一个入口起点的名称，甚至添加了一个新的名称，会发生什么？生成的包将被重命名在一个构建中，但是我们的index.html文件仍然会引用旧的名字。我们用 HtmlWebpackPlugin 来解决这个问题。首先安装插件，并且调整 webpack.config.js 文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev html-webpack-plugin</span><br><span class="line">webpack.config.js:</span><br><span class="line">    <span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line">    plugins: [</span><br><span class="line">       <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">       title: <span class="string">&#x27;Output Management&#x27;</span></span><br><span class="line">     &#125;)</span><br><span class="line">   ],</span><br></pre></td></tr></table></figure><h3 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h3><p>清理 /dist 文件夹:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install clean-webpack-plugin --save-dev</span><br><span class="line">webpack.config.js:</span><br><span class="line">    <span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line">    plugins: [</span><br><span class="line">      <span class="keyword">new</span> CleanWebpackPlugin(), /+</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><p>通过 manifest，webpack 能够对「你的模块映射到输出 bundle 的过程」保持追踪</p><h3 id="source-map"><a href="#source-map" class="headerlink" title="source map"></a>source map</h3><p>使用 source map: 为了更容易地追踪错误和警告，JavaScript 提供了 source map 功能，将编译后的代码映射回原始源代码。如果一个错误来自于 b.js，source map 就会明确的告诉你。ource map 有很多不同的选项可用,对于本指南，我们使用 inline-source-map 选项</p><p>devtool: ‘inline-source-map’</p><h3 id="webpack编译模式"><a href="#webpack编译模式" class="headerlink" title="webpack编译模式"></a>webpack编译模式</h3><p>每次要编译代码时，手动运行 npm run build 就会变得很麻烦,webpack 中有几个不同的选项，可以帮助你在代码发生变化后自动编译代码：</p><ul><li><p>1.webpack’s Watch Mode 使用观察模式 依赖图中的所有文件以进行更改。如果其中一个文件被更新，代码将被重新编译，所以你不必手动运行整个构建。<br>  scripts中添加”watch”: “webpack –watch”,唯一的缺点是，为了看到修改后的实际效果，你需要刷新浏览器。如果能够自动刷新浏览器就更好了，<br>  可以尝试使用 webpack-dev-server，恰好可以实现我们想要的功能</p></li><li><p>2.webpack-dev-server: 为你提供了一个简单的 web 服务器，并且能够实时重新加载(live reloading)让我们设置以下：npm install –save-dev webpack-dev-server<br>  修改配置文件，告诉开发服务器(dev server)，在哪里查找文件,webpack.config.js:<br>  devServer: {<br>   contentBase: ‘./dist’<br>  },<br>  以上配置告知 webpack-dev-server，在 localhost:8080 下建立服务，将 dist 目录   下的文件，作为可访问文件。在package.json中添加一个script脚本可直接运行开发服务器。</p></li><li><p>3.webpack-dev-middleware 是一个容器(wrapper)，它可以把 webpack 处理后的文件传递给一个服务器(server)。 webpack-dev-server 在内部使用了它，同时，它也可以作为一个单独的包来使用，以便进行更多自定义设置来实现更多的需求。接下来是一个 webpack-dev-middleware 配合 express server 的示例:<br>  首先，安装 express 和 webpack-dev-middleware:<br>  npm install –save-dev express webpack-dev-middleware<br>  webpack.config.js: output:{publicPath:’/‘}<br>  新建server.js,再添加一个npm script :”server”: “node server.js”,运行npm run server</p></li></ul><h3 id="tree-shaking是一个术语，通常用于描述移除-JavaScript-上下文中的未引用代码-dead-code"><a href="#tree-shaking是一个术语，通常用于描述移除-JavaScript-上下文中的未引用代码-dead-code" class="headerlink" title="tree shaking是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)"></a>tree shaking是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)</h3><h3 id="glifyJsPlugin-用来对js文件进行压缩，从而减小js文件的大小，加速load速度"><a href="#glifyJsPlugin-用来对js文件进行压缩，从而减小js文件的大小，加速load速度" class="headerlink" title="glifyJsPlugin 用来对js文件进行压缩，从而减小js文件的大小，加速load速度"></a>glifyJsPlugin 用来对js文件进行压缩，从而减小js文件的大小，加速load速度</h3><p>uglifyJsPlugin会拖慢webpack的编译速度，所有建议在开发简单将其关闭，部署的时候再将其打开。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--npm install uglifyjs-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure><p>通过webpack-merge配置不同环境的构建配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--npm install --save-dev webpack-merge</span><br></pre></td></tr></table></figure><p>多数情况下，你也可以进行 CSS 分离，以便在生产环境中节省加载时间:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--npm install --save-dev extract-text-webpack-plugin</span><br></pre></td></tr></table></figure><p>它会将所有的入口 chunk(entry chunks)中引用的 *.css，移动到独立分离的 CSS 文件。因此，你的样式将不再内嵌到 JS bundle 中，而是会放到一个单独的 CSS 文件（即 styles.css）当中。 如果你的样式文件大小较大，这会做更快提前加载，因为 CSS bundle 会跟 JS bundle 并行加载。</p><p>代码分离是 webpack 中最引人注目的特性之一。此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。有三种常用的代码分离方法：</p><ul><li><p>1.入口起点：使用 entry 配置手动地分离代码。</p></li><li><p>2.防止重复(prevent duplication): 通过使用 CommonsChunkPlugin 来移除重复的模块</p></li><li><p>3.动态导入(dynamic imports):</p><p>  涉及到动态代码拆分时，webpack 提供了两个类似的技术。对于动态导入，第一种，也是优先选择的方式是，使用符合 ECMAScript 提案 的 import() 语法。第二种，则是使用 webpack 特定的 require.ensure<br>  import() 调用会在内部用到 promises:使用： import().then(),由于import（）会返回一个promise函数，因此可以和async函数一起使用，但是需要使用像babel这样的预处理器和Syntax Dynamic Import Babel Plugin：</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--npm install --save-dev @babel/plugin-syntax-dynamic-<span class="keyword">import</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-vue基础知识点</title>
      <link href="/ZJY.github.io/2021/01/19/vue-vue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/ZJY.github.io/2021/01/19/vue-vue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="vue渐进式JavaScript框架"><a href="#vue渐进式JavaScript框架" class="headerlink" title="vue渐进式JavaScript框架"></a>vue渐进式JavaScript框架</h3><p>核心库和插件，核心库很小，需要其他插件时添加进来</p><p>核心库只关注视图层，动态构建用户界面</p><p>框架顺序：angluar(数据绑定和模板)、react（组件化和虚拟Dom技术）、vue</p><p>1、vue的特点<br>遵循MVVM模式<br>编码简洁、体积小、运行效率高<br>本身只关注UI，可以轻松引入插件（依赖vue)或第三方库(不依赖vue)开发项目</p><p>2、vue借鉴  </p><p>angluar(数据绑定和模板)<br>react（组件化和虚拟Dom技术）</p><p>3、vue扩展插件</p><p>vue-cli:vue脚手架<br>vue-resources(axios):ajax请求<br>vue-router:路由<br>vue-scroll:页面滑动<br>vue-lazyload：图片懒加载<br>vuex:状态管理模式<br>mint-ui：基于vue的UI组件库（移动端）<br>element-UI：基于vue的UI组件库（pc端）</p><p>4、vue的使用</p><p>1.引入vue.js<br>2.创建vue实例,el指定选择器范围，data初始化数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> vue(&#123;</span><br><span class="line">    el:<span class="string">&#x27;app&#x27;</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        message:<span class="string">&#x27;hello&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>5.MVVM<br>model:模型、数据对象（data）<br>view:视图、模板页面（指令、<code>&#123;&#123;&#125;&#125;`显示数据）viewmodel:视图模型（vue的实例）<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">                    viewmodel</span><br><span class="line">view-------------dom listener--------------&gt;model</span><br><span class="line">view&lt;------------data bindings--------------model</span><br><span class="line">(DOM)              (vue实例)              (js objects)</span><br></pre></td></tr></table></figure>6、数据绑定：Mustache语法（双大括号）`&#123;&#123;msg&#125;&#125;</code></p><p>7、v-once一次性的插值，当数据改变时，内容不会更新</p><p>8、v-html输入真正的HTML</p><p>9、v-bind：href将mustache语法作用于HTML特性上可简写：href</p><p>10、使用JavaScript表达式<code>&#123;&#123;msg.toUpperCase()&#125;&#125;</code></p><p>11、指令：带有v-前缀的特殊特性  v-if  v-for</p><p>12、v-on:click简写为：@click</p><p>13、计算属性computed和侦听属性watch<br>computed的set监听方法，值改变时调用set回调方法，需要显示值时，调用get回调方法<br>计算属性存在缓存，多次读取只执行一次getter计算</p><p>14、class和style绑定</p><ul><li>:class=”classA”(字符串）</li><li>:class=”{classA:isA,classB:isB}”(对象)</li><li>:class=”[‘classA;,’classB’]”(数组）</li><li>:style=”{color:activeColor,fontSize:fontSize+’px’}”(样式JS写法）</li></ul><p>15、条件渲染</p><p>v-if v-else-if v-else v-show<br>v-if是惰性的如果初始条件为假则什么都不做，直到条件第一次变为真时，v-show不管初始条件真假，元素总被渲染，并且知识简单地基于css切换<br>v-if有更高的切换开销，v-show有更高的初始渲染开销，因此，需频繁切换则使用v-show较好，如果运行时条件很少改变，则使用v-if</p><p>16、不建议v-if和v-show同时使用，v-for具有比v-if更高的优先级</p><p>17、列表渲染</p><p>v-for=”item in items”/v-for=”(item,index) in items”<br>可用of代替in<br>遍历对象按Object.keys()结果遍历</p><p>18、数组更新检测-变异方法</p><p>vue包含一组观察数组的变异方法，也会触发视图更新：<br>push()向数组末尾添加一个或多个元素，返回新的长度<br>pop()删除并返回数组的最后一个元素<br>shift()删除数组第一个元素并返回第一个元素的值<br>unshift()向数组开头添加一个或更多元素，并返回新的长度<br>splice()增、删、改数组项目，返回被删除的项目，改变原数组<br>sort()数组排序<br>reverse()颠倒数组的元素顺序，会改变原数组</p><p>19、filter数组过滤 sort排序</p><p>20、绑定事件@click=’test($event)’,$event代表当前绑定事件标签</p><p>test(event){ var text = event.target.innerHTML}</p><p>21、事件冒泡：从子到父依次执行，阻止事件冒泡，事件修饰符@click.stop=”test”原生写法:event.stopPropagation()</p><p>22、阻止事件的默认行为(比如跳转），@click.prevent=”test”原生写法：event.preventDefault</p><p>23、按键修饰符@click.enter .tab .deleter .esc .space .up .down .left .right</p><p>24、使用v-model对表单数据自动收集 双向绑定</p><p>26、vue实例的生命周期</p><p>new vue 创建vue实例<br>初始化显示（执行一次）：</p><pre><code>beforeCreate    初始化设置：observe data  init eventscreatedbeforeMountmounted</code></pre><p>更新状态（执行n次）：</p><pre><code>beforeUpdateupdated</code></pre><p>销毁vue实例（执行n次）：</p><pre><code>beforeDestorydestroyed</code></pre><p>常用生命周期：<br>mounted：请求ajax请求，设置定时器等<br>beforeDestroyed:销毁vue实例前，清除定时器等</p><p>27、transition过渡动画</p><p>在目标元素外包裹<code>&lt;transition name=&quot;xxx&quot;&gt;&lt;/transition&gt;</code><br>定义class样式：<br>    xxx-enter-active   xxx-leave-active<br>    xxx-enter          xxx-leave-to</p><p>28、自定义过滤器</p><p>1.在组件的选项中定义本地过滤器<br>2.在创建vue实例前定义全局过滤器<br>页面使用：<br><code>&#123;&#123;date | filterDate('YYYY-MM-DD')&#125;&#125;</code><br>js:<br>引入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> format <span class="keyword">from</span> <span class="string">&#x27;date-fns/format&#x27;</span></span><br><span class="line">filters:&#123;</span><br><span class="line">    filterDate:<span class="function"><span class="keyword">function</span>(<span class="params">value,fmt</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> format(value,fmt || <span class="string">&#x27;YYYY-MM-DD HH:mm:ss&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>29、指令</p><p>v-text:更新元素的textContext<br>v-html:更新元素的innerHTML<br>v-show:条件为true，切换元素的display属性<br>v-if<br>v-else-if<br>v-else<br>v-for:列表渲染<br>v-on/@:绑定事件监听器<br>v-bind:简写：，绑定Dom属性<br>v-model:在表单控件上双向绑定<br>v-pre:跳过这个元素和它的子元素的编译过程<br>v-cloak:<code>&lt;div v-cloak&gt;``&#123;&#123; message &#125;&#125;</code></div>这个指令保持在元素上直到关联实例结束编译 防止闪现, 与 css 配合:[v-cloak]{display:none}<br>v-once:只渲染元素和组件一次<br>$ref:指定唯一标识,vue 对象通过$refs 属性访问这个元素对象</p><p>30.自定义指令</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-upper-text</span>=<span class="string">&quot;msg&quot;</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-lower-text</span>=<span class="string">&quot;msg&quot;</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注册全局指令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">&#x27;upper-text&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">el,binding</span>)</span>&#123;</span><br><span class="line">    el.innerHTML= binding.value.toUpperCase()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册局部指令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">directives:&#123;</span><br><span class="line">    <span class="string">&#x27;lower-text&#x27;</span>:<span class="function"><span class="keyword">function</span>(<span class="params">el,binding</span>)</span>&#123;</span><br><span class="line">        el.innerHTML= binding.value.toLowerCase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>31.创建vue项目</p><p>npm install -g vue-cli<br>vue init webpack vueProjectname<br>cd vueProjectname<br>npm install<br>npm run dev<br>访问：<a href="http://localhost:8080/">http://localhost:8080/</a></p><p>32.模板项目结构</p><p>|–build:webpack 相关的配置文件夹(基本不需要修改)<br>|–dev-server.js: 通过 express 启动后台服务器<br>|–config:webpack 相关的配置文件夹(基本不需要修改)<br>|–index.js: 指定的后台服务的端口号和静态资源文件夹<br>|–node_modules<br>|–src: 源码文件夹<br>|–components:vue 组件及其相关资源文件夹<br>|–App.vue: 应用根主组件<br>|–main.js: 应用入口 js<br>|–static: 静态资源文件夹<br>|–.babelrc:babel 的配置文件<br>|–.eslintignore:eslint 检查忽略的配置 |–.eslintrc.js:eslint 检查的配置<br>|–.gitignore:git 版本管制忽略的配置<br>|–index.html: 主页面文件<br>|–package.json: 应用包配置文件<br>|–README.md: 应用描述说明的 readme 文件</p><p>33、项目打包和发布</p><p>1.打包：npm run build<br>2.发布：npm install -g serve<br>3.访问：<a href="http://localhost:5000/">http://localhost:5000</a></p><p>34.组件使用</p><p>1.引入组件  import List from ‘’<br>2.映射成标签：components:{}<br>3.使用<code>&lt;List&gt;&lt;/List&gt;</code></p><p>35、数据代理</p><p>数据代理是通过一个对象代理（A)对另一个对象（B,B在A中）中属性的操作</p><p>36、vue数据代理</p><p>通过MVVM对象代理data对象中所有属性的操作<br>基本流程：<br>    通过Object.defineProperty()给VM添加与data对象的属性相对应的属性描述符<br>    所有添加的属性都包含getter/setter<br>    getter/setter内部去操作data中对象属性数据</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>taro-taro的基本使用</title>
      <link href="/ZJY.github.io/2021/01/19/taro-taro%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/ZJY.github.io/2021/01/19/taro-taro%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行:"></a>项目运行:</h3><pre><code>微信小程序：npm run dev:weappH5:npm run dev:h5</code></pre><h3 id="项目打包"><a href="#项目打包" class="headerlink" title="项目打包"></a>项目打包</h3><pre><code>微信小程序：npm run build:weappH5:npm run build:h5</code></pre><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>在 Taro 中尺寸单位建议使用 px、 百分比 %，Taro 默认会对所有单位进行转换。在 Taro 中书写尺寸按照 1:1 的关系来进行书写</p><p>如果你希望部分 px 单位不被转换成 rpx 或者 rem ，最简单的做法就是在 px 单位中增加一个大写字母，例如 Px 或者 PX 这样，则会被转换插件忽略</p><p>Taro 默认以 750px 作为换算尺寸标准</p><p>Taro 提供了 API Taro.pxTransform 来做运行时的尺寸转换:Taro.pxTransform(10) // 小程序：rpx，H5：rem</p><p>对于头部包含注释 /<em>postcss-pxtransform disable</em>/ 的文件，插件不予处理。</p><p>externalClasses 需要使用 短横线命名法 (kebab-case)，而不是 React 惯用的 驼峰命名法 (camelCase)。否则无效。</p><p> Taro 中，所有组件都应当首字母大写并且使用大驼峰式命名法（Camel-Case）</p><p> Taro只能使用map,forEach,reduce等无效</p><p> setState() 函数是唯一能够更新 this.state 的地方。taro的状态更新一定是异步的，可以在回调中取得更新后的值，react的setState不总是异步的</p><p> 在 Taro 中不能使用 catchEvent 的方式阻止事件冒泡。你必须明确的使用 stopPropagation</p><p> 在 Taro 的页面和组件类中，this 指向的是 Taro 页面或组件的实例,要获取对应的小程序原生页面和组件的实例，通过this.$scope</p><h3 id="react组件的生命周期："><a href="#react组件的生命周期：" class="headerlink" title="react组件的生命周期："></a>react组件的生命周期：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// constructor，顾名思义，组件的构造函数。一般会在这里进行 state 的初始化，事件的绑定等等</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是当组件在进行挂载操作前，执行的函数，一般紧跟着 constructor 函数后执行</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentWillMount</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是当组件挂载在 dom 节点后执行。一般会在这里执行一些异步数据的拉取等动作</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当组件在进行更新之前，会执行的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentWillUpdate</span>(<span class="params">nextProps, nextState</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当组件收到新的 props 时会执行的函数，传入的参数就是 nextProps ，你可以在这里根据新的 props 来执行一些相关的操作，例如某些功能初始化等</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentWillReceiveProps</span>(<span class="params">nextProps</span>)</span> &#123;&#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当组件完成更新时，会执行的函数，传入两个参数是 prevProps 、prevState</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentDidUpdate</span>(<span class="params">prevProps, prevState</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 false 时，组件将不会进行更新，可用于渲染优化</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当组件准备销毁时执行。在这里一般可以执行一些回收的工作，例如 clearInterval(this.timer) 这种对定时器的回收操作</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line"></span><br><span class="line">        &lt;div&gt;</span><br><span class="line"></span><br><span class="line">            &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">            &lt;h2&gt;It is &#123;<span class="built_in">this</span>.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>props：父组件传给子组件的数据，会挂载在子组件的 this.props 上</p><p>state：与 props 不同，是属于组件自己内部的数据状态，一般在 constructor 构造函数里初始化定义 state</p><p>react组件的三个声明周期状态：</p><pre><code>*Mount: 插入真实Dom*Update: 被重新渲染*Unmount：被移除真实Dom</code></pre><h3 id="生命周期流程"><a href="#生命周期流程" class="headerlink" title="生命周期流程"></a>生命周期流程</h3><pre><code>第一次初始化渲染显示：ReactDom.render()    *constructor: 创建对象初始化state    *componentWillMount(): 将要插入回调    * render() : 用于插入虚拟 DOM 回调    * componentDidMount() : 已经插入回调每次更新 state: this.setSate()     * componentWillUpdate() : 将要更新回调    * render() : 更新(重新渲染    * componentDidUpdate() : 已经更新回调</code></pre><h3 id="taro-ui使用方式："><a href="#taro-ui使用方式：" class="headerlink" title="taro-ui使用方式："></a>taro-ui使用方式：</h3><pre><code>在页面test.tsx中：    import &#123; AtButton &#125; from &#39;taro-ui&#39;    按需引入：@import &quot;~taro-ui/dist/style/components/button.scss&quot;;全局引入使用：    在app.scss中：@import &quot;~taro-ui/dist/style/index.scss&quot;;    在页面：import &#123; AtButton &#125; from &#39;taro-ui&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> taro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css-scss的基本使用</title>
      <link href="/ZJY.github.io/2021/01/19/css-scss%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/ZJY.github.io/2021/01/19/css-scss%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="scss基础使用"><a href="#scss基础使用" class="headerlink" title="scss基础使用"></a>scss基础使用</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量:"></a>变量:</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$primary-color: #341234;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: $primary-color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">nav</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span> &#123;</span><br><span class="line">        left:<span class="number">0</span>;</span><br><span class="line">        <span class="attribute">right</span>:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="混合属性"><a href="#混合属性" class="headerlink" title="混合属性:"></a>混合属性:</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span>  alert &#123;</span><br><span class="line">    <span class="selector-tag">color</span>: <span class="selector-id">#723899</span>;</span><br><span class="line">    background-color: $primary-color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@mixin</span>  alert-a &#123;</span><br><span class="line">    <span class="selector-tag">color</span>: <span class="selector-id">#723899</span>;</span><br><span class="line">    background-color: $primary-color;</span><br><span class="line">    <span class="selector-tag">a</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>:$primary-color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@mixin</span> alert-b($text-color,$background) &#123;</span><br><span class="line">    color: $text-color;</span><br><span class="line">    background-color: $background;</span><br><span class="line">    <span class="selector-tag">span</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>: <span class="built_in">darken</span>($text-color,<span class="number">10%</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span>&#123;</span><br><span class="line">    @include alert</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span>&#123;</span><br><span class="line">    @include alert-a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line">    @include alert-b(#786789,#000 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承"><a href="#继承" class="headerlink" title="继承:"></a>继承:</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.alert</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.alert-info</span> &#123;</span><br><span class="line">    @extend .alert;</span><br><span class="line">    <span class="selector-tag">background</span>: <span class="selector-id">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色:"></a>颜色:</h4><p>rgb(255,255,255)<br>rgba(255,255,255,1)<br>红绿蓝透明度</p><p>hsl(50,100%,50%)<br>hsla(50,100%,50%,0.5)<br>色相 饱和度 明度 透明度</p><p>adjust-hue调整颜色 background: adjust-hue(#fff, 123deg)</p><p>lighten darken函数 $lighten-color: lighten(#fff,30%) $darken-color: darken(#fff,20%)</p><p>saturate增加颜色的纯度 desaturate减少颜色的纯度<br>$saturate-color: saturate(#000,40%)<br>$desaturate-color: desaturate(#000,40%)</p><p>opacify添加透明度(让颜色更不透明)  transparentize减少透明度(让颜色更透明)</p><h4 id="interpolation插入值"><a href="#interpolation插入值" class="headerlink" title="interpolation插入值 :"></a>interpolation插入值 :</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$text: &#x27;info&#x27;;</span><br><span class="line">.alert-#&#123;$text&#125; &#123;</span><br><span class="line">    background:$primary-color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">results</span>:</span><br><span class="line"><span class="selector-class">.alert-info</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="if条件判断"><a href="#if条件判断" class="headerlink" title="if条件判断:"></a>if条件判断:</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@if</span> condition&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$conditon: 2 &gt; 1;</span><br><span class="line"><span class="selector-class">.rounded</span> &#123;</span><br><span class="line">    @if $conditon &#123;</span><br><span class="line">        <span class="selector-tag">-webkit-animation-name</span>: <span class="selector-tag">taro</span>;</span><br><span class="line">        <span class="selector-tag">-moz-animation-name</span>: <span class="selector-tag">taro</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">border-radius</span>: 5<span class="selector-tag">px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$color : &quot;dark&quot;;</span><br><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    @if $color == dark &#123;</span><br><span class="line">        <span class="selector-tag">background-color</span>: <span class="selector-tag">darkblue</span>;</span><br><span class="line">    &#125; <span class="keyword">@else</span> if $color == lighten &#123;</span><br><span class="line">        <span class="selector-tag">background-color</span>: <span class="selector-tag">lightblue</span>;</span><br><span class="line">    &#125; <span class="keyword">@else</span> &#123;</span><br><span class="line">        <span class="selector-tag">background</span>: <span class="selector-tag">gray</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环:"></a>for循环:</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@for</span> $var from &lt;begain&gt; through &lt;end&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$columns: 4;</span><br><span class="line"><span class="keyword">@for</span> $i from <span class="number">1</span> through $columns &#123;</span><br><span class="line">    .col-#&#123;$i&#125; &#123;</span><br><span class="line">        width: 100% / $columns * $i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">results</span>:</span><br><span class="line"><span class="selector-class">.col-1</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">25%</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-2</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-3</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">75%</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-4</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@for</span> $i from <span class="number">1</span> to $columns &#123;</span><br><span class="line">    .col-#&#123;$i&#125; &#123;</span><br><span class="line">        width: 100% / $columns * $i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">results</span>:</span><br><span class="line"><span class="selector-class">.col-1</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">25%</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-2</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50%</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.col-3</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">75%</span>; &#125;</span><br></pre></td></tr></table></figure><h4 id="each语句"><a href="#each语句" class="headerlink" title="each语句"></a>each语句</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@each</span> $var in $lists &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$icons: success error warning;</span><br><span class="line"><span class="keyword">@each</span> $icon in $icons &#123;</span><br><span class="line">    .icon-#&#123;$icon&#125;&#123;</span><br><span class="line">        background-image: url(../image/icons/#&#123;$icon&#125;.png);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">results</span>:</span><br><span class="line"><span class="selector-class">.icon-success</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(../image/icons/success.png); &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.icon-error</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(../image/icons/error.png); &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.icon-warning</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(../image/icons/warning.png); &#125;</span><br></pre></td></tr></table></figure><h4 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@while</span> condition &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$i : 6;</span><br><span class="line"><span class="keyword">@while</span> $i &gt; <span class="number">0</span> &#123;</span><br><span class="line">    .item-#&#123;$i&#125; &#123;</span><br><span class="line">        width: 5px * $i;</span><br><span class="line">    &#125;</span><br><span class="line">    $i : $i - 2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">results</span>:</span><br><span class="line"><span class="selector-class">.item-6</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">30</span>rpx; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item-4</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20</span>rpx; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item-2</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">10</span>rpx; &#125;</span><br></pre></td></tr></table></figure><h4 id="用户自定义函数"><a href="#用户自定义函数" class="headerlink" title="用户自定义函数:"></a>用户自定义函数:</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$colors: (light: #fff, dark: #000);</span><br><span class="line"><span class="keyword">@function</span> color($key)&#123;</span><br><span class="line">    // <span class="keyword">@if</span> <span class="keyword">not</span> map-has-key($colors, $key)&#123;</span><br><span class="line">    //     <span class="keyword">@warn</span> <span class="string">&quot;在colors中没有这个属性&quot;</span></span><br><span class="line">    // &#125;</span><br><span class="line">    @return map-get($colors,$key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.test</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">color</span>(gray);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">results</span>:</span><br><span class="line">    <span class="selector-class">.test</span> &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="warn-警告信息-error错误信息"><a href="#warn-警告信息-error错误信息" class="headerlink" title="@warn 警告信息  @error错误信息"></a>@warn 警告信息  @error错误信息</h4><h4 id="sass编译输入四种格式"><a href="#sass编译输入四种格式" class="headerlink" title="sass编译输入四种格式:"></a>sass编译输入四种格式:</h4><p>1.nested,嵌套<br>2.compact,紧凑<br>3.expander,扩展<br>4.compressed,压缩</p><p>.sass缩进式写法  .scss嵌套写法</p><h4 id="partials与-import"><a href="#partials与-import" class="headerlink" title="partials与@import:"></a>partials与@import:</h4><p>文件名以_下划线开头的是partials,不会编译 _base.scss<br>可以通过@import “base”;将文件引入</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mongodb-MongoDB的安装使用</title>
      <link href="/ZJY.github.io/2021/01/19/mongodb-MongoDB%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
      <url>/ZJY.github.io/2021/01/19/mongodb-MongoDB%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>MongoDB非关系数据库、键值对数据、文档型数据库、快速开发<br>存储的是各种各样的json</p><p>1.安装MongoDB（官网下载，版本号偶数稳定版，奇数开发版）</p><p>2.配置环境变量</p><p>path中添加安装路径的bin文件夹 例E:\MongoDB\bin</p><p>3.在c盘根目录</p><p>存储数据的目录：创建data目录-》创建db目录</p><p>4.打开cmd命令窗口</p><ul><li>输入mongod 启动mongdb服务器 等待连接</li><li>32位电脑第一次启动时：mongod –storageEngine==mmapv1</li><li>可以通过mongod –dbpath url(启动指定数据库路径)</li><li>默认端口27017</li><li>指定端口号mongod –dbpath url(启动指定数据库路径c:\data\db) –port 1234</li></ul><p>5.再打开cmd窗口</p><p>输入mongo  连接</p><p>6.数据库</p><ul><li>数据库的服务器（保存数据） mongod 启动服务器</li><li>数据库的客户端（操作数据） mongo  启动客户端</li></ul><p>7.将MongoDB设置为系统服务，自动后台启动</p><p>c盘根目录data下创建log日志文件<br>在安装路径bin上一级目录创建配置文件mongod.cfg</p><pre><code>systemLog:    destination:file    path: c:\data\log\mongod.logstorage:    dbPath: c:\data\db</code></pre><p>以管理员身份打开命令窗口<br>执行如下命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc.exe create MongoDB binPath=<span class="string">&quot;\&quot;E:\MongoDB\bin\mongod.exe\&quot; --service --config=\&quot;E:\MongoDB\mongod.cfg\&quot;&quot;</span> DisplayName=<span class="string">&quot;MongoDB&quot;</span> start=<span class="string">&quot;auto&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>target和currentTarget区别</title>
      <link href="/ZJY.github.io/2021/01/19/javascript-target%E5%92%8CcurrentTarget%E5%8C%BA%E5%88%AB/"/>
      <url>/ZJY.github.io/2021/01/19/javascript-target%E5%92%8CcurrentTarget%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="target和currentTarget区别"><a href="#target和currentTarget区别" class="headerlink" title="target和currentTarget区别"></a>target和currentTarget区别</h2><p>target:触发事件的元素<br>currentTarget:事件绑定的元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;ulT&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item3&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item4&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item5&quot;</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时target和currentTarget是一样的 都是点击的li标签</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> lis = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>;i&lt;lis.length;i++)&#123;</span><br><span class="line">    lis[i].onclick= <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e.target);  <span class="comment">//&lt;li class=&quot;item1&quot;&gt;1&lt;/li&gt;</span></span><br><span class="line">        <span class="built_in">console</span>.log(e.currentTarget); <span class="comment">//&lt;li class=&quot;item1&quot;&gt;1&lt;/li&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时是不一样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line">ul.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.target);  <span class="comment">//当前的li</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.currentTarget); <span class="comment">//元素的ul</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECMAScript和JavaScript的区别以及小程序区别</title>
      <link href="/ZJY.github.io/2021/01/19/javascript-ECMAScript%E5%92%8CJavaScript%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8C%BA%E5%88%AB/"/>
      <url>/ZJY.github.io/2021/01/19/javascript-ECMAScript%E5%92%8CJavaScript%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h3><p>ECMAScript是一种由Ecma国际通过ECMA-262标准化的脚本程序设计语言， JavaScript 是 ECMAScript 的一种实现.</p><p>小程序中的 JavaScript同浏览器中的 JavaScript 以及 NodeJS 中的 JavaScript 是不相同的</p><h3 id="ECMA-262-规定了-ECMAScript-语言的几个重要组成部分："><a href="#ECMA-262-规定了-ECMAScript-语言的几个重要组成部分：" class="headerlink" title="ECMA-262 规定了 ECMAScript 语言的几个重要组成部分："></a>ECMA-262 规定了 ECMAScript 语言的几个重要组成部分：</h3><ul><li>语法</li><li>类型</li><li>语句</li><li>关键字</li><li>操作符</li><li>对象</li></ul><h3 id="浏览器中JavaScript-构成如下-ECMAScript-DOM（文档对象模型）-BOM（浏览器对象模型）"><a href="#浏览器中JavaScript-构成如下-ECMAScript-DOM（文档对象模型）-BOM（浏览器对象模型）" class="headerlink" title="浏览器中JavaScript 构成如下: ECMAScript + DOM（文档对象模型） + BOM（浏览器对象模型）"></a>浏览器中JavaScript 构成如下: ECMAScript + DOM（文档对象模型） + BOM（浏览器对象模型）</h3><h3 id="NodeJS中JavaScript-构成如下-ECMAScript-NPM-包管理系统-Native"><a href="#NodeJS中JavaScript-构成如下-ECMAScript-NPM-包管理系统-Native" class="headerlink" title="NodeJS中JavaScript 构成如下: ECMAScript + NPM (包管理系统) + Native"></a>NodeJS中JavaScript 构成如下: ECMAScript + NPM (包管理系统) + Native</h3><h3 id="小程序中-JavaScript-构成如下-ECMAScript-小程序框架-小程序-API"><a href="#小程序中-JavaScript-构成如下-ECMAScript-小程序框架-小程序-API" class="headerlink" title="小程序中 JavaScript 构成如下: ECMAScript + 小程序框架 + 小程序 API"></a>小程序中 JavaScript 构成如下: ECMAScript + 小程序框架 + 小程序 API</h3><p>同浏览器中的JavaScript 相比没有 BOM 以及 DOM 对象，所以类似 JQuery、Zepto这种浏览器类库是无法在小程序中运行起来的，同样的缺少 Native 模块和NPM包管理的机制，小程序中无法加载原生库，也无法直接使用大部分的 NPM 包。</p><h3 id="小程序的执行环境"><a href="#小程序的执行环境" class="headerlink" title="小程序的执行环境"></a>小程序的执行环境</h3><ul><li>小程序目前可以运行在三大平台：</li><li>iOS平台，包括iOS9、iOS10、iOS11</li><li>Android平台</li><li>小程序IDE</li></ul><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>浏览器中，所有 JavaScript 是在运行在同一个作用域下的，定义的参数或者方法可以被后续加载的脚本访问或者改写。同浏览器不同，小程序中可以将任何一个JavaScript 文件作为一个模块，通过module.exports 或者 exports 对外暴露接口。</p><h3 id="脚本的执行顺序"><a href="#脚本的执行顺序" class="headerlink" title="脚本的执行顺序"></a>脚本的执行顺序</h3><p>浏览器中，脚本严格按照加载的顺序执行;而在小程序中的脚本执行顺序有所不同。小程序的执行的入口文件是 app.js 。并且会根据其中 require 的模块顺序决定文件的运行顺序.当 app.js 执行结束后，小程序会按照开发者在 app.json 中定义的 pages 的顺序，逐一执行</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>同浏览器中运行的脚本文件有所不同，小程序的脚本的作用域同 NodeJS 更为相似。在文件中声明的变量和函数只在该文件中有效，不同的文件中可以声明相同名字的变量和函数，不会互相影响</p><h3 id="小程序通信模型"><a href="#小程序通信模型" class="headerlink" title="小程序通信模型"></a>小程序通信模型</h3><p>小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了WebView 进行渲染；逻辑层采用JsCore线程运行JS脚本。一个小程序存在多个界面，所以渲染层存在多个WebView线程，这两个线程的通信会经由微信客户端（下文中也会采用Native来代指微信客户端）做中转，逻辑层发送网络请求也经由Native转发</p><h3 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h3><p>WXML可以先转成JS对象，然后再渲染出真正的Dom树</p><h3 id="双线程下的界面渲染"><a href="#双线程下的界面渲染" class="headerlink" title="双线程下的界面渲染"></a>双线程下的界面渲染</h3><p>小程序的逻辑层和渲染层是分开的两个线程。在渲染层，宿主环境会把WXML转化成对应的JS对象，在逻辑层发生数据变更的时候，我们需要通过宿主环境提供的setData方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的Dom树上，渲染出正确的UI界面</p><h3 id="所有页面的脚本逻辑都跑在同一个JsCore线程，页面使用setTimeout或者setInterval的定时器，然后跳转到其他页面时，这些定时器并没有被清除，需要开发者自己在页面离开的时候进行清理"><a href="#所有页面的脚本逻辑都跑在同一个JsCore线程，页面使用setTimeout或者setInterval的定时器，然后跳转到其他页面时，这些定时器并没有被清除，需要开发者自己在页面离开的时候进行清理" class="headerlink" title="所有页面的脚本逻辑都跑在同一个JsCore线程，页面使用setTimeout或者setInterval的定时器，然后跳转到其他页面时，这些定时器并没有被清除，需要开发者自己在页面离开的时候进行清理"></a>所有页面的脚本逻辑都跑在同一个JsCore线程，页面使用setTimeout或者setInterval的定时器，然后跳转到其他页面时，这些定时器并没有被清除，需要开发者自己在页面离开的时候进行清理</h3><h3 id="Page构造器的参数"><a href="#Page构造器的参数" class="headerlink" title="Page构造器的参数"></a>Page构造器的参数</h3><ul><li>data:   Object   页面的初始数据</li><li>onLoad: Function 生命周期函数–监听页面加载，触发时机早于onShow和onReady 在页面没被销毁前只会触发1次</li><li>onShow: Function 生命周期函数–监听页面显示，触发事件早于onReady 一般从别的页面返回到当前页面时，当前页的+ onShow方法都会被调用</li><li>onReady:Function 生命周期函数–监听页面初次渲染完成  在页面没被销毁前只会触发1次</li><li>onHide: Function 生命周期函数–监听页面隐藏</li><li>onUnload:Function 生命周期函数–监听页面卸载</li><li>onPullDownRefresh:Function 页面相关事件处理函数–监听用户下拉动作</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gulp-gulp基础使用</title>
      <link href="/ZJY.github.io/2021/01/19/gulp-gulp%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
      <url>/ZJY.github.io/2021/01/19/gulp-gulp%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>1.前置条件：测试node /npm /npx是否安装<br>2.安装gulp命令行工具</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --<span class="built_in">global</span> gulp-cli</span><br></pre></td></tr></table></figure><p>3.创建项目目录</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npx mkdirp my-project</span><br><span class="line">cd my-project</span><br></pre></td></tr></table></figure><p>4.在项目目录下创建package.json文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><p>5.安装gulp,作为开发时依赖项</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev gulp</span><br></pre></td></tr></table></figure><p>6.检查gulp版本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp --version</span><br></pre></td></tr></table></figure><p>7.创建gulpfile文件</p><p>8.测试</p><p>在项目根目录下执行 gulp 命令：gulp</p><p>9.创建任务（task）:</p><p>每个 gulp 任务（task）都是一个异步的 JavaScript 函数，此函数是一个可以接收 callback 作为参数的函数，或者是一个返回 stream、promise、event emitter、child process 或 observable (后面会详细讲解) 类型值的函数</p><p>10.导出任务：</p><p>任务可以是公开或私有的：<br>公开任务： 从gulpfile中被导出，可以通过gulp命令直接调用<br>私有任务：被设计在内部使用，通常作为series（）或parallel()组合的组成部分。<br>一个私有（private）类型的任务（task）在外观和行为上和其他任务（task）是一样的，但是不能够被用户直接调用。如需将一个任务（task）注册为公开（public）类型的，只需从 gulpfile 中导出（export）即可</p><p>11.组合任务</p><p>两个组合方法： series()和parallel(),允许多个独立的任务组合为一个更大的操作。这两个方法都可以接受任意数目的任务函数和已组合的操作。<br>series()和parallel()可以互相嵌套至任意深度。<br>如果需要让任务按顺序执行，请使用series()方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; series &#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transpile</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bundle</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exports</span>.build = series(transpile, bundle);</span><br></pre></td></tr></table></figure><p>对于希望以最大并发来允许的任务，可以使用parallel()方法将他们组合：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cosnt &#123; parallel &#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">javascript</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line">functin <span class="function"><span class="title">css</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exports</span>.build = parallel(javascript, css);</span><br></pre></td></tr></table></figure><p>当series()和parallel()被调用时，任务会被立即组合在一起，这就允许在组合中进行改变，而不需要在单个任务中进行条件判断：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; series &#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minify</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">overload</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">transpile</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(process.env.NODE_ENV == <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">exports</span>.build = series(minify, overload);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">exports</span>.build = series(transpile,overload);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>series()和parallel()可以被嵌套任意深度：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; series, parallel &#125; = requier(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exports</span>.build = series(</span><br><span class="line">    a,</span><br><span class="line">    parallel(b</span><br><span class="line">    ,</span><br><span class="line">    series(c,d)</span><br><span class="line">    ),</span><br><span class="line">    e</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果在两个不同任务间调用同一个任务将被执行两次，并产生不可预期结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; series, parallel&#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> clean = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> javascript = series(clean,<span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> css = series(clean, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">exports</span>.build = parallel(javascript,css)</span><br></pre></td></tr></table></figure><p>重构为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; series, parallel &#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clean</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">css</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">javascript</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exports</span>.build = series(clean, parallel(css, javascript));</span><br></pre></td></tr></table></figure><p>12.异步执行：</p><p>异步执行方式：<br>1.返回stream</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; src, dest&#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">streanTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> src(<span class="string">&quot;*.js&quot;</span>)</span><br><span class="line">    .pipe(dest(<span class="string">&#x27;output&#x27;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.返回promise:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promiseTask</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.返回event emitter</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; EventEmitter &#125; = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eventEmitterTask</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> emitter = <span class="keyword">new</span> EventEmitter();</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123; emitter.emit(<span class="string">&#x27;finish&#x27;</span>)&#125;,<span class="number">250</span>);</span><br><span class="line">    <span class="keyword">return</span> emitter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.返回 child process</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; exec &#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">childProcessTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exec(<span class="string">&#x27;date&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.返回observable</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Observale&#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observaleTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.使用callback<br>如果任务不返回任何内容，则必须用callback来指示任务已完成</p><p>7.使用async/await</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncAwaitTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; version &#125; = fs.readFileSync(<span class="string">&#x27;package.json&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(version);</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;some result&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>13.处理文件</p><p>gulp暴露了src()和dest()方法用于处理计算机上存放的文件<br>src()接受glob参数，并从文件系统中读取文件然后生成一个node流<br>dest()接收一个输入目录作为参数，并且会产生一个node流作为终止流，当他接受到管道pipe传输的文件时，他会将文件内容及属性写到目录中</p><p>14.glob</p><p> glob 是由普通字符和/或通配字符组成的字符串，用于匹配文件路径。可以利用一个或多个 glob 在文件系统中定位文件</p><p> src() 方法接受一个 glob 字符串或由多个 glob 字符串组成的数组作为参数，用于确定哪些文件需要被操作。glob 或 glob 数组必须至少匹配到一个匹配项，否则 src() 将报错</p><ul><li>分隔符： /</li><li>特殊符号： *<br>在一个字符串片段中匹配任意数量的字符，包括零个匹配。对于匹配单级目录下的文件很有用： ‘*.js’</li><li>特殊字符： ** (两个星号)<br>在多个字符串片段中匹配任意数量的字符，包括零个匹配。 对于匹配嵌套目录下的文件很有用 ‘scripts/*<em>/</em>.js’</li><li>特殊字符： ! (取反)<br>由于 glob 匹配时是按照每个 glob 在数组中的位置依次进行匹配操作的，所以 glob 数组中的取反（negative）glob 必须跟在一个非取反（non-negative）的 glob 后面<pre><code>  [&#39;script/**/*.js&#39;, &#39;!scripts/vendor/&#39;]</code></pre></li><li>匹配重叠：<br>两个或多个 glob 故意或无意匹配了相同的文件就被认为是匹配重叠（overlapping）了。如果在同一个 src() 中使用了会产生匹配重叠的 glob，gulp 将尽力去除重叠部分，但是在多个 src() 调用时产生的匹配重叠是不会被去重的</li></ul><p>15.使用插件</p><p>Gulp 插件实质上是 Node 转换流（Transform Streams），它封装了通过管道（pipeline）转换文件的常见功能，通常是使用 .pipe() 方法并放在 src() 和 dest() 之间。他们可以更改经过流（stream）的每个文件的文件名、元数据或文件内容</p><p>16.文件监控</p><p>ulp api 中的 watch() 方法利用文件系统的监控程序（file system watcher）将 globs 与 任务（task） 进行关联。它对匹配 glob 的文件进行监控，如果有文件被修改了就执行关联的任务（task）。如果被执行的任务（task）没有触发 异步完成 信号，它将永远不会再次运行了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">css</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;</span><br><span class="line">watch(<span class="string">&#x27;src/*.css&#x27;</span>,css);</span><br></pre></td></tr></table></figure><p>与文件监控程序关联的任务不能时同步任务<br>默认情况下，只要创建、更改或删除文件，文件监控程序就会执行关联的任务（task）。 如果你需要使用不同的事件，你可以在调用 watch() 方法时通过 events 参数进行指定。可用的事件有 ‘add’、’addDir’、’change’、’unlink’、’unlinkDir’、’ready’、’error’。此外，还有一个 ‘all’ 事件，它表示除 ‘ready’ 和 ‘error’ 之外的所有事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; watch &#125; = <span class="built_in">require</span>(<span class="string">&#x27;gulp&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有事件都将被监控</span></span><br><span class="line">watch(<span class="string">&#x27;src/*.js&#x27;</span>, &#123; <span class="attr">events</span>: <span class="string">&#x27;all&#x27;</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>初次执行：<br>调用watch之后，关联的任务是不会被立即执行，要等到第一次文件修改之后才执行<br>如果需要在第一次文件修改之前执行，也就是调用watch之后立即执行，设置参数： ignoreInitial: false</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">watch(<span class="string">&#x27;src/*.js&#x27;</span>, &#123; <span class="attr">ignoreInitial</span>: <span class="literal">false</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    cb();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>队列： queue: false//禁止队列<br>延迟： delay: Nubmer //文件更改之后延迟多久被执行</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> gulp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6-模块化</title>
      <link href="/ZJY.github.io/2021/01/19/es6-%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>/ZJY.github.io/2021/01/19/es6-%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="es5中，用module-exports-和-exports导出模块，用require引入模块"><a href="#es5中，用module-exports-和-exports导出模块，用require引入模块" class="headerlink" title="es5中，用module.exports 和 exports导出模块，用require引入模块"></a>es5中，用module.exports 和 exports导出模块，用require引入模块</h3><h3 id="es6中，新增export-和-export-default-导出模块，import引入模块"><a href="#es6中，新增export-和-export-default-导出模块，import引入模块" class="headerlink" title="es6中，新增export 和 export default 导出模块，import引入模块"></a>es6中，新增export 和 export default 导出模块，import引入模块</h3><ol><li>module.exports 和 exports 的区别：</li></ol><p>module.exports 和 exports 导出的对象，可以在另一个文件中通过require引用</p><p>module 和 exports 是node.js给每个js文件内置的两个对象，初始值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">exports</span>):  &#123;&#125;  空对象</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>): &#123;..., <span class="attr">exports</span>: &#123;&#125; &#125;  ...代表其他属性如：id,filename...</span><br></pre></td></tr></table></figure><p>一开始这两个对象都是空对象{}，实际上这两个对象指向同一块内存<br>exports.age = 18 和 module.exports.age = 18 两者是等价的</p><p>但是require引入的本质是module.exports，所有当module.exports 和exports<br>指向的不是同一块内存时，exports的内容就会失效：例如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a.js:</span><br><span class="line"><span class="built_in">exports</span> = &#123;<span class="attr">name</span>:<span class="string">&#x27;lily&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;<span class="attr">name</span>:<span class="string">&#x27;lucy&#x27;</span> &#125;</span><br><span class="line">b.js:</span><br><span class="line"><span class="keyword">let</span> test = <span class="built_in">require</span>(<span class="string">&#x27;./a&#x27;</span>)</span><br><span class="line">consle.log(test)  <span class="comment">// &#123;name:&#x27;lucy&#x27;&#125;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>export default 和 export 的区别：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> People = &#123; <span class="attr">name</span>: <span class="string">&#x27;lucy&#x27;</span> ,<span class="attr">age</span>: <span class="number">18</span> &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> = People</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>):</span><br><span class="line">&#123;<span class="attr">exports</span>:&#123;<span class="attr">default</span>:&#123;<span class="attr">name</span>:<span class="string">&#x27;lucy&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;&#125;&#125;</span><br><span class="line"><span class="keyword">import</span> Peole <span class="keyword">from</span> <span class="string">&#x27;.a&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">name</span>:<span class="string">&#x27;aaa&#x27;</span>,age,<span class="number">12</span>&#125;</span><br><span class="line"><span class="keyword">const</span> b = &#123; <span class="attr">name</span>:<span class="string">&#x27;bbb&#x27;</span>, <span class="attr">age</span>:<span class="number">23</span>&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; a, b&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>):</span><br><span class="line">&#123;<span class="attr">exports</span>: &#123;<span class="attr">a</span>:&#123;<span class="attr">name</span>:<span class="string">&#x27;aaa&#x27;</span>,<span class="attr">age</span>:<span class="number">12</span>&#125;,<span class="attr">b</span>:&#123;<span class="attr">name</span>:<span class="string">&#x27;bbb&#x27;</span>,<span class="attr">age</span>:<span class="number">23</span>&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>导入： import {a,b} from ‘./a’</p><p>导出时， export 相当于将对象添加到module 的 exports中，<br>export default 相当于将对象添加到module 的 exports ，对象key 为default</p><p>导入时：<br>不带{}的导入，本质上就是导入exports的default属性，若default属性不存在，<br>则导入exports对象<br>带{}的导入，按key值导入exports中对应的属性值</p><p>一般来说，module.exports和exports与require对应。也就是用module.exports和exports<br>导出的模块，则用require导入。（不是绝对，如果代码支持es6，也可以用import引入）。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> es6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dart-dart基础</title>
      <link href="/ZJY.github.io/2021/01/19/dart-dart%E5%9F%BA%E7%A1%80/"/>
      <url>/ZJY.github.io/2021/01/19/dart-dart%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="1-安装dart-sdk"><a href="#1-安装dart-sdk" class="headerlink" title="1.安装dart sdk"></a>1.安装dart sdk</h3><p><a href="https://dart.dev/get-dart">https://dart.dev/get-dart</a><br>终端输入dart –version 测试是否安装成功</p><h3 id="2-配置vscode支持dart语法提示："><a href="#2-配置vscode支持dart语法提示：" class="headerlink" title="2.配置vscode支持dart语法提示："></a>2.配置vscode支持dart语法提示：</h3><p>1.安装插件dart<br>2.安装插件code runner  可以运行文件</p><h3 id="3-vscode运行dart文件中文乱码："><a href="#3-vscode运行dart文件中文乱码：" class="headerlink" title="3.vscode运行dart文件中文乱码："></a>3.vscode运行dart文件中文乱码：</h3><p>1.在settings.json添加：”code-runner.runInTerminal”: true,<br>2.重启vscode</p><h3 id="4-入口方法"><a href="#4-入口方法" class="headerlink" title="4.入口方法"></a>4.入口方法</h3><p>main(){};<br>void main(){};//没有返回值</p><h3 id="5-注释"><a href="#5-注释" class="headerlink" title="5.注释"></a>5.注释</h3><p>//注释<br>///注释<br>/<em>注释</em>/</p><h3 id="6-声明变量："><a href="#6-声明变量：" class="headerlink" title="6.声明变量："></a>6.声明变量：</h3><p>1.通过var声明： var str = “aaa”; //dart强类型校验，可以不预先声明变量类型，自行判断类型<br>2.通过类型声明  String str = “aaa”</p><p>变量命名规则：<br>        1.必须由数字/字母/下划线和$组成<br>        2.不能以数字开头<br>        3.不能是保留字和关键字<br>        4.区分大小写</p><h3 id="7-常量：-const-和-final"><a href="#7-常量：-const-和-final" class="headerlink" title="7.常量： const 和 final"></a>7.常量： const 和 final</h3><p>1.const 和finnal 赋值都不可以修改<br>2.区别： final可以开始不赋值，只能赋值一次，final不仅有const的编译时常量的特性，最重要的是它是编译时赋值<br>        例如：<br>        final date = new DateTime.now(); //正常 编译时赋值，只能赋值一次<br>        const date = new DateTime.now(); //报错 定义时赋值</p><h3 id="8-dart-数据类型："><a href="#8-dart-数据类型：" class="headerlink" title="8.dart 数据类型："></a>8.dart 数据类型：</h3><p>常用数据类型：</p><pre><code>    Numbers(数值)：int double    Strings(字符串)： String    Booleans(布尔值): bool    List(数组): 列表对象    Maps(字典)： Map是一个键值对相关的对象</code></pre><p>1.字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> str = <span class="string">&quot;falds&quot;</span></span><br><span class="line"><span class="built_in">String</span> str = <span class="string">&quot;&quot;</span><span class="string">&quot;flasjd</span></span><br><span class="line"><span class="string">flad</span></span><br><span class="line"><span class="string">d;fja&quot;</span><span class="string">&quot;&quot;</span> <span class="comment">//三个单引号或者三个双引号字符串可换行</span></span><br><span class="line"><span class="comment">// &lt;!-- 字符串拼接： --&gt;</span></span><br><span class="line">    print(<span class="string">&quot;$str $str&quot;</span>);</span><br><span class="line">    print(str +<span class="string">&quot; &quot;</span>+ str);</span><br></pre></td></tr></table></figure><p>2.数值类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = <span class="number">12</span>; <span class="comment">//只可以是整型</span></span><br><span class="line">double = <span class="number">12.23</span>  <span class="comment">//既可以是整型也可以是浮点型</span></span><br></pre></td></tr></table></figure><p>3.布尔类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool flag = <span class="literal">true</span>/<span class="literal">false</span> ; <span class="comment">//布尔类型的值只能是true/false</span></span><br><span class="line">条件判断不会对变量进行类型转换： <span class="number">123</span> != <span class="string">&#x27;123&#x27;</span></span><br></pre></td></tr></table></figure><p>4.数组类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> List();</span><br><span class="line">arr2.add(<span class="string">&quot;a&quot;</span>)</span><br></pre></td></tr></table></figure><p>3.指定数组元素类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr3 = <span class="keyword">new</span> List&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">arr3.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">arr3.add(<span class="number">1</span>); <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><p>5.Maps</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:<span class="string">&quot;test&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问： person[“name”]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">p[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;test&quot;</span></span><br></pre></td></tr></table></figure><p>6.is关键词判断数据类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;ad&#x27;</span>;</span><br><span class="line">print(str is <span class="built_in">String</span>)</span><br></pre></td></tr></table></figure><h3 id="9-运算符"><a href="#9-运算符" class="headerlink" title="9.运算符"></a>9.运算符</h3><ul><li><p>算术运算符</p><ol><li>+</li><li>-</li><li>*</li><li>/</li><li>% 取余</li><li>~/ 取整</li></ol></li><li><p>关系运算符：</p><ol><li>==</li><li>!=</li><li>&lt;</li><li><code>&gt;</code></li><li>&lt;=</li><li><code> &gt;=</code></li></ol></li><li><p>逻辑运算符：<br>  !<br>  &amp;&amp;<br>  ||</p></li><li><p>赋值运算符：<br>  <code>=</code><br>  <code>??=</code>  // int b; b??=23 如果b等于空的话，把23赋值给b</p></li><li><p>复合赋值运算符：<br>  +=<br>  -=<br>  *-<br>  /=<br>  ~/=</p></li><li><p>条件表达式：<br>  if… else<br>  if… else if<br>  swtich… case</p><p>  三目运算符 ? :<br>  ??运算符 b= a ?? 10 //a不为空时b等于a，a为空时b等于10</p><p>  b=a++ 赋值运算中： ++写在后面 先赋值后运算 ++a 写在前面先运算后赋值</p></li></ul><h3 id="10-类型转换："><a href="#10-类型转换：" class="headerlink" title="10.类型转换："></a>10.类型转换：</h3><ul><li>int.parse</li><li>double.parge</li><li>toString</li><li>str.isEmpty</li><li>num.isNaN</li></ul><h3 id="11-List属性："><a href="#11-List属性：" class="headerlink" title="11.List属性："></a>11.List属性：</h3><ul><li>length</li><li>isEmpty</li><li>isNotEmpty</li><li>reversed 翻转列表 [1,2,3].reversed //(3,2,1) [1,2,3].reversed.toList() //[3,2,1]</li></ul><h3 id="12-List方法："><a href="#12-List方法：" class="headerlink" title="12.List方法："></a>12.List方法：</h3><ul><li>add 数组添加 add(1)</li><li>addAll([1,2]) //拼接数组</li><li>indexOf 返回索引值</li><li>remove 移除值，参数为值</li><li>removeAt 参数为索引值</li><li>fillRange int start,int end,修改后的值</li><li>insert(int index,value)指定位置插入值</li><li>insertAll(index,interable)  insertAll(1,[1,2]) </li><li>join(分割符) 以分隔符拼接转换成字符串</li><li>split(分隔符) 将string以分隔符切割成数组</li><li>toList() 将其他类型对象转换为数组</li></ul><h3 id="13-Set主要功能是数组去重"><a href="#13-Set主要功能是数组去重" class="headerlink" title="13.Set主要功能是数组去重"></a>13.Set主要功能是数组去重</h3><p>set是不能重复且没有顺序的对象</p><h3 id="14-Maps-映射"><a href="#14-Maps-映射" class="headerlink" title="14.Maps 映射"></a>14.Maps 映射</h3><ul><li>key   var person={“a”:1,”b”:2} person.keys.toList()</li><li>value</li><li>isEmpty</li><li>isNotEmpty</li><li>addAll() 添加多个</li><li>remove(key)</li><li>containsValue(value) 是否存在某个值</li></ul><h3 id="15-循环："><a href="#15-循环：" class="headerlink" title="15.循环："></a>15.循环：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">forEach</span><br><span class="line">map  用于修改数据 <span class="keyword">var</span> newList = list.map((value)&#123; <span class="keyword">return</span> value*<span class="number">2</span>&#125;)</span><br><span class="line">where  <span class="keyword">var</span> newList = list.where((value)&#123; <span class="keyword">return</span> value &gt; <span class="number">5</span>&#125;) 返回符合条件的数组</span><br><span class="line">any  <span class="keyword">var</span> newList = list.any((value)&#123; <span class="keyword">return</span> value &gt; <span class="number">5</span>&#125;) 有一个满足条件返回<span class="literal">true</span></span><br><span class="line">some ar newList = list.some((value)&#123; <span class="keyword">return</span> value &gt; <span class="number">5</span>&#125;) 满足所有条件返回<span class="literal">true</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> dart </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css-grid布局</title>
      <link href="/ZJY.github.io/2021/01/19/css-grid%E5%B8%83%E5%B1%80/"/>
      <url>/ZJY.github.io/2021/01/19/css-grid%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<p>Flex是轴线布局，只能指定“项目” 针对轴线的位置，可以看作是一维布局。</p><p>Grid布局则是将容器分成行和列，产生单元格，然后指定项目所在单元格，可以看作是二维布局</p><h3 id="1-容器和项目："><a href="#1-容器和项目：" class="headerlink" title="1.容器和项目："></a>1.容器和项目：</h3><p>采用网格布局的区域，称为“容器” container， 容器内采用网格定位的子元素，称为“项目” item</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最外层的div元素就是容器， 内层的三个div 是项目<br>注意： 项目只能是容器的顶层子元素，不包含项目的子元素，grid布局只对项目生效</p><h3 id="2-行和列"><a href="#2-行和列" class="headerlink" title="2.行和列"></a>2.行和列</h3><p>容器里水平区域称为”行”row,垂直区域称为“列”column</p><h3 id="3-单元格"><a href="#3-单元格" class="headerlink" title="3.单元格"></a>3.单元格</h3><p>行和列的交叉区域，称为“单元格”cell<br>正常情况下，N行M列，会产生N*M个单元格</p><h3 id="4-网格线"><a href="#4-网格线" class="headerlink" title="4.网格线"></a>4.网格线</h3><p>划分网格的线，称为”网格线”（grid line）。水平网格线划分出行，垂直网格线划分出列<br>正常情况下，n行有n + 1根水平网格线，m列有m + 1根垂直网格线</p><p>Grid 布局的属性分成两类。一类定义在容器上面，称为容器属性；另一类定义在项目上面，称为项目属性。这部分先介绍容器属性</p><h3 id="5-容器属性"><a href="#5-容器属性" class="headerlink" title="5.容器属性"></a>5.容器属性</h3><h4 id="5-1-display属性"><a href="#5-1-display属性" class="headerlink" title="5.1 display属性"></a>5.1 display属性</h4><p>display: grid指定一个容器采用网格布局</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，容器元素都是块级元素，但也可以设成行内元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。</p><h4 id="5-2-grid-template-rows属性和grid-template-columns属性"><a href="#5-2-grid-template-rows属性和grid-template-columns属性" class="headerlink" title="5.2 grid-template-rows属性和grid-template-columns属性"></a>5.2 grid-template-rows属性和grid-template-columns属性</h4><p>容器指定了网格布局以后，接着就要划分行和列。grid-template-columns属性定义每一列的列宽，grid-template-rows属性定义每一行的行高。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了使用绝对单位,还可使用百分比：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: 33.33% 33.33% 33.33%;</span><br><span class="line"><span class="selector-tag">grid-template-rows</span>: 33.33% 33.33% 33.33%;</span><br></pre></td></tr></table></figure><p>1.repeat() 接受两个参数，第一个参数是重复的次数,第二个参数是所要重复的值:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: <span class="selector-tag">repeat</span>(3, 33.33%)</span><br></pre></td></tr></table></figure><p>重复某种模式：定义了6列，第一列和第四列的宽度为100px，第二列和第五列为20px，第三列和第六列为80px</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: <span class="selector-tag">repeat</span>(2, 100<span class="selector-tag">px</span> 20<span class="selector-tag">px</span> 80<span class="selector-tag">px</span>)</span><br></pre></td></tr></table></figure><p>2.auto-fill关键字<br>    有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用auto-fill关键字表示自动填充</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: <span class="selector-tag">repeat</span>(<span class="selector-tag">auto-fill</span>, 100<span class="selector-tag">px</span>)</span><br></pre></td></tr></table></figure><p>表示每列宽度100px，然后自动填充，直到容器不能放置更多的列</p><p>3.fr关键字</p><p>为了方便表示比例关系，网格布局提供了fr关键字（fraction 的缩写，意为”片段”）。如果两列的宽度分别为1fr和2fr，就表示后者是前者的两倍</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: 1<span class="selector-tag">fr</span> 1<span class="selector-tag">fr</span></span><br></pre></td></tr></table></figure><p>表示两个相同宽度的列。<br>fr可以与绝对长度的单位结合使用，这时会非常方便</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: 150<span class="selector-tag">px</span> 1<span class="selector-tag">fr</span> 2<span class="selector-tag">fr</span></span><br></pre></td></tr></table></figure><p>表示第一列宽度未150像素，第二列宽度是第三列的一半</p><p>4.minmax()函数产生一个长度范围，表示长度就在这个范围内，接收两个参数，分别为最小值和最大值</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: 1<span class="selector-tag">fr</span> 1<span class="selector-tag">fr</span> <span class="selector-tag">minmax</span>(100<span class="selector-tag">px</span>, 1<span class="selector-tag">fr</span>);</span><br></pre></td></tr></table></figure><p>5.auto关键字表示由浏览器自己决定长度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: 100<span class="selector-tag">px</span> <span class="selector-tag">auto</span> 100<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure><p>第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了min-width，且这个值大于最大宽度</p><p>6.网格线的名称</p><p>grid-template-columns属性和grid-template-rows属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: <span class="selector-attr">[c1]</span> 100<span class="selector-tag">px</span> <span class="selector-attr">[c2]</span> 100<span class="selector-tag">px</span> <span class="selector-attr">[c3]</span> <span class="selector-tag">auto</span> <span class="selector-attr">[c4]</span>;</span><br><span class="line"><span class="selector-tag">grid-template-rows</span>: <span class="selector-attr">[r1]</span> 100<span class="selector-tag">px</span> <span class="selector-attr">[r2]</span> 100<span class="selector-tag">px</span> <span class="selector-attr">[r3]</span> <span class="selector-tag">auto</span> <span class="selector-attr">[r4]</span></span><br></pre></td></tr></table></figure><p>7.布局实例</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: 70% 30%;</span><br></pre></td></tr></table></figure><p>上面代码将左边栏设为70%，右边栏设为30%。<br>传统的十二网格布局，写起来也很容易。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: <span class="selector-tag">repeat</span>(12, 1<span class="selector-tag">fr</span>);</span><br></pre></td></tr></table></figure><h4 id="5-3-grid-row-gap属性-grid-column-gap属性-grid-gap属性"><a href="#5-3-grid-row-gap属性-grid-column-gap属性-grid-gap属性" class="headerlink" title="5.3 grid-row-gap属性 grid-column-gap属性 grid-gap属性"></a>5.3 grid-row-gap属性 grid-column-gap属性 grid-gap属性</h4><p>grid-row-gap属性设置行与行的间隔（行间距），grid-column-gap属性设置列与列的间隔（列间距）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-row-gap</span>: 20<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">grid-column-gap</span>: 20<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">grid-gap</span>: &lt;<span class="selector-tag">grid-row-gap</span>&gt; &lt;<span class="selector-tag">grid-column-gap</span>&gt;</span><br><span class="line"><span class="selector-tag">grid-gap</span><span class="selector-pseudo">:20px</span>; <span class="comment">/* 如果省略了第二个值，则默认第二个值等于第一个值 */</span></span><br></pre></td></tr></table></figure><p>注： 根据最新标准，上面三个属性名的grid-前缀已经删除，grid-column-gap和grid-row-gap写成column-gap和row-gap，grid-gap写成gap。</p><h3 id="5-4-grid-template-areas属性"><a href="#5-4-grid-template-areas属性" class="headerlink" title="5.4 grid-template-areas属性"></a>5.4 grid-template-areas属性</h3><p>网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。grid-template-areas属性用于定义区域。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grid-template-areas: &#x27;a b c&#x27;</span><br><span class="line">                   &#x27;d e f&#x27;</span><br><span class="line">                   &#x27;g h i&#x27;;</span><br></pre></td></tr></table></figure><p>上面代码先划分出9个单元格，然后将其定名为a到i的九个区域，分别对应这九个单元格。<br>多个单元格合并成一个区域的写法如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grid-template-areas: &#x27;a a a&#x27;</span><br><span class="line">                 &#x27;b b b&#x27;</span><br><span class="line">                 &#x27;c c c&#x27;;</span><br></pre></td></tr></table></figure><p>上面代码将9个单元格分成a、b、c三个区域。<br>如果某些区域不需要利用，则使用”点”（.）表示</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grid-template-areas: &#x27;a . c&#x27;</span><br><span class="line">                 &#x27;d . f&#x27;</span><br><span class="line">                 &#x27;g . i&#x27;;</span><br></pre></td></tr></table></figure><p>注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end。</p><h3 id="5-5-grid-auto-flow属性"><a href="#5-5-grid-auto-flow属性" class="headerlink" title="5.5 grid-auto-flow属性"></a>5.5 grid-auto-flow属性</h3><p>划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行，即下图数字的顺序。<br>这个顺序由grid-auto-flow属性决定，默认值是row，即”先行后列”。也可以将它设成column，变成”先列后行”。<br>grid-auto-flow: row/row dense/column/column dense</p><h3 id="5-6-justify-items属性-align-items属性-place-items属性"><a href="#5-6-justify-items属性-align-items属性-place-items属性" class="headerlink" title="5.6 justify-items属性 align-items属性 place-items属性"></a>5.6 justify-items属性 align-items属性 place-items属性</h3><p>justify-items属性设置单元格内容的水平位置（左中右），align-items属性设置单元格内容的垂直位置（上中下）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">justify-items: start | end | center | stretch;</span><br><span class="line">align-items: start | end | center | stretch;</span><br><span class="line">    <span class="selector-tag">start</span>：对齐单元格的起始边缘。</span><br><span class="line">    <span class="selector-tag">end</span>：对齐单元格的结束边缘。</span><br><span class="line">    <span class="selector-tag">center</span>：单元格内部居中。</span><br><span class="line">    <span class="selector-tag">stretch</span>：拉伸，占满单元格的整个宽度（默认值）。</span><br><span class="line"><span class="selector-tag">place-items</span>属性是<span class="selector-tag">align-items</span>属性和<span class="selector-tag">justify-items</span>属性的合并简写形式。</span><br></pre></td></tr></table></figure><h4 id="5-7-justify-content属性-align-content-属性-place-content-属性"><a href="#5-7-justify-content属性-align-content-属性-place-content-属性" class="headerlink" title="5.7 justify-content属性 align-content 属性 place-content 属性"></a>5.7 justify-content属性 align-content 属性 place-content 属性</h4><p>justify-content属性是整个内容区域在容器里面的水平位置（左中右），align-content属性是整个内容区域的垂直位置（上中下）。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">justify-content: start | end | center | stretch | space-around | space-between | space-evenly;</span><br><span class="line">align-content: start | end | center | stretch | space-around | space-between | space-evenly; </span><br></pre></td></tr></table></figure><h3 id="5-8-grid-auto-rows-属性和-grid-auto-columns属性"><a href="#5-8-grid-auto-rows-属性和-grid-auto-columns属性" class="headerlink" title="5.8 grid-auto-rows 属性和 grid-auto-columns属性"></a>5.8 grid-auto-rows 属性和 grid-auto-columns属性</h3><p>有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目<br>grid-auto-columns属性和grid-auto-rows属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与grid-template-columns和grid-template-rows<br>完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-auto-rows</span>: 50<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-class">.item8</span>&#123;</span><br><span class="line">    <span class="attribute">grid-row-start</span>: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定第8个项目位于第四行行高50像素</p><h3 id="6-项目属性"><a href="#6-项目属性" class="headerlink" title="6.项目属性"></a>6.项目属性</h3><h4 id="6-1-grid-column-start-grid-column-end-grid-row-start-grid-row-end"><a href="#6-1-grid-column-start-grid-column-end-grid-row-start-grid-row-end" class="headerlink" title="6.1 grid-column-start grid-column-end grid-row-start grid-row-end"></a>6.1 grid-column-start grid-column-end grid-row-start grid-row-end</h4><p>项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。</p><pre><code>grid-column-start属性：左边框所在的垂直网格线grid-column-end属性：右边框所在的垂直网格线grid-row-start属性：上边框所在的水平网格线grid-row-end属性：下边框所在的水平网格线</code></pre><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">    <span class="attribute">grid-column-start</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">grid-column-end</span>: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线。<br>这四个属性的值，除了指定为第几个网格线，还可以指定为网格线的名字。<br>这四个属性的值还可以使用span关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-column-start</span>: <span class="selector-tag">span</span> 2;</span><br></pre></td></tr></table></figure><h4 id="6-2-grid-column-属性-grid-row-属性"><a href="#6-2-grid-column-属性-grid-row-属性" class="headerlink" title="6.2 grid-column 属性 grid-row 属性"></a>6.2 grid-column 属性 grid-row 属性</h4><p>grid-column属性是grid-column-start和grid-column-end的合并简写形式，grid-row属性是grid-row-start属性和grid-row-end的合并简写形式。</p><pre><code>grid-column: 1/3grid-column 1/span 2占据两列</code></pre><h4 id="6-3-grid-area"><a href="#6-3-grid-area" class="headerlink" title="6.3 grid-area"></a>6.3 grid-area</h4><p>grid-area属性指定项目放在哪一个区域</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">    <span class="attribute">grid-template-areas</span>: <span class="string">&#x27;a b c&#x27;</span></span><br><span class="line">                            <span class="string">&#x27;d e f&#x27;</span></span><br><span class="line">                            <span class="string">&#x27;g h i&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item1</span>&#123;</span><br><span class="line">    <span class="attribute">grid-area </span>:e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-4-justify-self-属性，align-self-属性，place-self-属性"><a href="#6-4-justify-self-属性，align-self-属性，place-self-属性" class="headerlink" title="6.4 justify-self 属性，align-self 属性，place-self 属性"></a>6.4 justify-self 属性，align-self 属性，place-self 属性</h4><p>justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。<br>align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css-flex布局</title>
      <link href="/ZJY.github.io/2021/01/19/css-flex%E5%B8%83%E5%B1%80/"/>
      <url>/ZJY.github.io/2021/01/19/css-flex%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="flexbox-布局"><a href="#flexbox-布局" class="headerlink" title="flexbox 布局"></a>flexbox 布局</h3><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p><p>任何一个容器都可以指定为 Flex 布局</p><p>flex:包含两部分：flex-container容器 和 flex-item</p><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。</p><p>主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p><h3 id="container属性"><a href="#container属性" class="headerlink" title="container属性:"></a>container属性:</h3><pre><code>flex-directionflex-wrapflex-flowjustify-contentalign-itemsalign-content</code></pre><p>1.display属性：</p><pre><code>flexinline-flex 行内容器-webkit-flex Webkit 内核的浏览器，必须加上-webkit前缀。</code></pre><p>注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效</p><p>2.flex-direction:</p><pre><code>row 水平方向从左向右column 垂直方向 从上往下row-reverse 水平方向从右向左column-reverse 垂直方向 从下向上</code></pre><p>3.flex-wrap: 默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行</p><pre><code>nowrap 不换行 默认值wrap 换行,第一行在上方。wrap-reverse 换行，第一行在下方。</code></pre><p>4.flex-flow: flex-direction 和 flex-wrap 结合</p><pre><code>row nowrap 两个参数对应</code></pre><p>5.justify-content： 定义了项目在主轴上的对齐方式</p><pre><code>centerspace-betweenspace-aroundspace-evenlyflex-startflex-end</code></pre><!-- ![avatar](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png) --><p>6.align-item：属性定义项目在交叉轴上如何对齐</p><pre><code>stretch 拉伸 如果项目未设置高度或设为auto，将占满整个容器的高度。flex-start 交叉轴的起点对齐。flex-end 交叉轴的终点对齐。center 交叉轴的中点对齐baseline 项目的第一行文字的基线对齐</code></pre><p>7.align-content: 多行显示设置垂直对齐方式 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用</p><pre><code>stretchflex-startflex-endcenterspace-between 行与行之间添加间隔space-around 行周围间隔</code></pre><h3 id="item属性："><a href="#item属性：" class="headerlink" title="item属性："></a>item属性：</h3><p>1.order: 控制item在容器里的位置 给item设置</p><pre><code>默认为0值越大排越后</code></pre><p>2.flex-grow： 控制item的宽度 值越大，宽度越宽,定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p><pre><code>flex-grow: 1; </code></pre><p>3.flex-basies: 设置item的宽度,定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p><pre><code>flex-basies: 100pxauto 默认值</code></pre><p>4.flex-shrink: 设置item缩小的比例,默认为1，即如果空间不足，该项目将缩小</p><pre><code>flex-shrink: 0; 设置不缩小设置比1大的数可设置缩小比例更大些如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小</code></pre><p>5.flex: 0 1 auto;分别对应 flex-grow flex-shrink flex-basies</p><p>6.align-self: 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p><pre><code>align-self: auto/flex-start/flex-end/center/stretch/baseline </code></pre>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css-css3选择器</title>
      <link href="/ZJY.github.io/2021/01/19/css-css3%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>/ZJY.github.io/2021/01/19/css-css3%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="类型选择器：-标签名进行选择"><a href="#类型选择器：-标签名进行选择" class="headerlink" title="类型选择器： 标签名进行选择"></a>类型选择器： 标签名进行选择</h3><ul><li>h1{}</li><li>h1,h2{} 选择器群组</li></ul><h3 id="通用选择器："><a href="#通用选择器：" class="headerlink" title="通用选择器： *"></a>通用选择器： *</h3><h3 id="类选择器："><a href="#类选择器：" class="headerlink" title="类选择器："></a>类选择器：</h3><ul><li>.content{}</li></ul><h3 id="ID选择器"><a href="#ID选择器" class="headerlink" title="ID选择器"></a>ID选择器</h3><ul><li>#title{}</li></ul><h3 id="属性选择器："><a href="#属性选择器：" class="headerlink" title="属性选择器："></a>属性选择器：</h3><ul><li>[attribute]</li><li>[attribute1][attribute2]</li><li>[attribute = value]</li><li>[attribute ~= value] 选择器用于选取属性值中包含指定词汇的元素 [title ~= ‘flower’]</li><li>[attribute |= value] 选择器用于选取带有以指定值开头的属性值的元素 [leng | en]</li><li>[attribute ^= value] 以value开头的值 [class ^=”test”]</li><li>[attribute $= value] 以value结尾的值</li><li>[attribute *= value] 选择器匹配属性值包含指定值的每个元素</li></ul><h3 id="伪类："><a href="#伪类：" class="headerlink" title="伪类："></a>伪类：</h3><ul><li><p>a:link a:visited a:hover a:active :focus </p></li><li><p>:target 选择器可用于选取当前活动的目标元素</p></li><li><p>:disabled 用于添加禁用样式</p></li><li><p>:nth-child(n) 选择器匹配属于其父元素的第 N 个子元素，不论元素的类</p></li><li><p>:nth-last-child() 同上，从最后一个子元素开始计数</p></li><li><p>:first-child  p:first-child 选择属于父元素的第一个子元素的每个<code>&lt;p&gt;</code>元素</p></li><li><p>:last-child  p:last-child    选择属于其父元素最后一个子元素每个<code>&lt;p&gt;</code>元素。</p></li><li><p>:nth-of-type() p:nth-of-type(2) 选择属于其父元素第二个<code>&lt;p&gt;</code>元素的每个<code>&lt;p&gt;</code>元素</p></li><li><p>:nth-last-of-type() 同上，但是从最后一个子元素开始计数</p></li><li><p>:first-of-type  p:first-of-type    选择属于其父元素的首个<code>&lt;p&gt;</code>元素的每个<code>&lt;p&gt;</code>元素</p></li><li><p>:last-of-type  p:last-of-type    选择属于其父元素的最后<code>&lt;p&gt;</code>元素的每个<code>&lt;p&gt;</code>元素</p></li><li></li><li><p>:only-child  p:only-child    选择属于其父元素的唯一子元素的每个<code>&lt;p&gt;</code>元素。</p></li><li><p>:only-of-type  p:only-of-type    选择属于其父元素唯一的<code>&lt;p&gt;</code>元素的每个<code>&lt;p&gt;</code>元素</p></li><li><p>:empty p:empty    选择没有子元素的每个<code>&lt;p&gt;</code>元素（包括文本节点）</p></li><li><p>:not :not(p)    选择非<code>&lt;p&gt;</code>元素的每个元素。</p></li></ul><h3 id="伪元素选择器："><a href="#伪元素选择器：" class="headerlink" title="伪元素选择器："></a>伪元素选择器：</h3><ul><li><p>::first-line p::first-line    选择每个<code>&lt;p&gt;</code>元素的首行。</p></li><li><p>::first-letter    p::first-letter    选择每个<code>&lt;p&gt;</code>元素的首字母。</p></li><li><p>::before    p::before    在每个<code>&lt;p&gt;</code>元素的内容之前插入内容。</p></li><li><p>::after    p::after    在每个<code>&lt;p&gt;</code>元素的内容之后插入内容。</p></li></ul><h3 id="组合选择器："><a href="#组合选择器：" class="headerlink" title="组合选择器："></a>组合选择器：</h3><ul><li>div img  以空格隔开 后裔选择器</li></ul><h3 id="儿子选择器："><a href="#儿子选择器：" class="headerlink" title="儿子选择器："></a>儿子选择器：</h3><ul><li>div &gt; img</li></ul><h3 id="兄弟选择器："><a href="#兄弟选择器：" class="headerlink" title="兄弟选择器："></a>兄弟选择器：</h3><ul><li>div + img</li><li>h2 ~ h3 h2 后面的h3 元素</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css-BFC块级格式化上下文</title>
      <link href="/ZJY.github.io/2021/01/14/css-BFC/"/>
      <url>/ZJY.github.io/2021/01/14/css-BFC/</url>
      
        <content type="html"><![CDATA[<h3 id="BOX：-css布局的基本单位-amp-盒模型"><a href="#BOX：-css布局的基本单位-amp-盒模型" class="headerlink" title="BOX： css布局的基本单位&amp;盒模型"></a>BOX： css布局的基本单位&amp;盒模型</h3><ul><li><p>盒模型–块级盒/行内盒<br>一个盒包含：内容（content）/边（border）/内边距（padding）/外边距（margin）<br>盒的尺寸（width和height–计算得到offsetWidth和offsetHeight）定义受到box-sizing属性的影响<br>IE怪异盒模型-块级盒-border-box：width = content + padding + margin<br>w3c标准盒模型-块级盒-content-box：width = content</p></li><li><p>行内盒：</p><ul><li>width/height 不起作用，盒子高度由内容决定（font-size/line-height）</li><li>margin-top/margin-bottom不起作用</li></ul></li></ul><p>tips：</p><ul><li>两类块级盒子可用过设置box-sizing转换</li><li>行内盒与块级盒转换可通过设置display属性来修改</li><li>行内盒参与IFC布局，块级盒参与BFC布局，如果块级盒包含行内盒，但是由于BFC内只有块级盒参与，因此行内盒会被匿名块级盒包含</li></ul><h3 id="BOX"><a href="#BOX" class="headerlink" title="BOX"></a>BOX</h3><p>Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。<br>不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染</p><ul><li>block-level：box的display 属性为block, list-item, table 的元素，会生成 block-level box。并且参与（BFC）block fomatting context；</li><li>inline-level：box的display 属性为inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context；</li></ul><h3 id="格式化上下文"><a href="#格式化上下文" class="headerlink" title="格式化上下文"></a>格式化上下文</h3><ul><li>块级格式化上下文( Block formatting contexts )( BFC )</li><li>行内格式化上下文( Inline formatting contexts ) ( IFC )</li><li>自适应格式化上下文( Flex Formatting Contexts )( FFC )</li><li>网格布局格式化上下文( GridLayout Formatting Contexts )( GFC )</li></ul><p>有一类盒被称为块容器，它们能够包含块级盒。块容器要么创建BFC，这样它内部仅仅包含块级盒，要么创建一个IFC，这样它内部仅仅包含行内级元素。</p><p>（也就是说，块容器中不可能既包含块级盒，又包含行内级盒，一旦他的子盒中有块级盒，所有行内级盒都会被自动创建匿名盒包裹）。</p><p>在非块级格式化上下文中的块容器总是会创建新的BFC：如display为inline-blocks, table-cells, 和table-captions所生成的盒。</p><p>而自身也在块级格式化上下文中的块容器，则只有overflow不为visible的情形下才会创建新的BFC</p><ul><li>绝对定位和浮动的块容器则总是会创建新的块级格式化上下文。</li><li>display值为table或者inline-table的元素将会生成表格（table），表格内部会使用特殊的格式化方式来排布其内部元素。</li><li>display值为grid或者inline-grid的元素将会生成网格元素（grid element），与table情形类似，它内部也是使用特殊的格式化方式来排布其内部元素，</li><li>display值为flex或者inline-flex的元素将会生成自适应容器（flex container），自适应容器在其内部产生自适应格式化上下文（flex formatting context）</li></ul><p>FC的全称是：Formatting Contexts，是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p><p>BFC:BFC(Block Formatting Contexts)直译为”块级格式化上下文”。<br>Block Formatting Contexts就是页面上的一个隔离的渲染区域，容器里面的子元素不会在布局上影响到外面的元素，反之也是如此。<br>浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。</p><p>BFC布局规则：</p><ul><li>内部的Box会在垂直方向，一个接一个地放置。</li><li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li><li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li><li>BFC的区域不会与float box重叠。</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li><li>计算BFC的高度时，浮动元素也参与计算</li></ul><p>那些元素生成BFC</p><ul><li>根元素</li><li>float属性不为none</li><li>position为absolute或fixed</li><li>display为inline-block, table-cell, table-caption, flex, inline-flex</li><li>overflow不为visible</li></ul><p>元素与盒</p><ul><li>在HTML中常常使用的概念是元素，而在CSS中，布局的基本单位是盒，盒总是矩形的。</li><li>元素与盒并非一一对应的关系，一个元素可能生成多个盒，CSS规则中的伪元素也可能生成盒，display属性为none的元素则不生成盒。</li><li>除了元素之外，HTML中的文本节点也可能会生成盒。</li></ul><p>正常流</p><ul><li>正常流是页面，大部分盒排布于正常流中。正常流中的盒必定位于某一格式化上下文中，正常流中有两种格式化上下文：块级格式化上下文（block formatting context，简称BFC）和行内格式化上下文（inline formatting context,IFC）。</li><li>在块级格式化上下文中，盒呈纵向排布，在行内格式化上下文中，盒则呈横向排布。</li><li>正常流根容器中是块级格式化上下文，不同的盒可能会在内部产生行内格式化上下文或者块级格式化上下文。</li></ul><p>块级与行内级</p><ul><li><p>正常流中的盒分为块级与行内级两种，任何一个行内级盒都不能够直接被放入块级格式化上下文中。如果有一个HTML元素生成了一个行内盒，而其所在的上下文是块级的话，那么应当为它生成一个匿名块级盒，匿名块级盒会在内部生成行内格式化上下文。</p></li><li><p>元素的display属性会决定盒是行内级还是块级：<br>block, table, flex, grid, list-item 为块级<br>inline, inline-block, inline-table, inline-flex, inline-grid 为行内级</p></li></ul><p>产生垂直外边距合并的必备条件,两个margin是邻接的必须满足以下条件:</p><ul><li>必须是处于常规文档流（非float和绝对定位）的块级盒子,并且处于同一个BFC当中<br>没有线盒，没有空隙（clearance，下面会讲到），没有padding和border将他们分隔开,都属于垂直方向上相邻的外边距，可以是下面任意一种情况:<ul><li>元素的margin-top与其第一个常规文档流的子元素的margin-top</li><li>元素的margin-bottom与其下一个常规文档流的兄弟元素的margin-top</li><li>height为auto的元素的margin-bottom与其最后一个常规文档流的子元素的margin-bottom</li><li>高度为0并且最小高度也为0，不包含常规文档流的子元素，并且自身没有建立新的BFC的元素的margin-top和margin-bottom</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css-BEM块元素修饰符</title>
      <link href="/ZJY.github.io/2021/01/14/css-BEM/"/>
      <url>/ZJY.github.io/2021/01/14/css-BEM/</url>
      
        <content type="html"><![CDATA[<h2 id="BlockElementModifier其实是块（block）、元素（element）、修饰符（modifier）。"><a href="#BlockElementModifier其实是块（block）、元素（element）、修饰符（modifier）。" class="headerlink" title="BlockElementModifier其实是块（block）、元素（element）、修饰符（modifier）。"></a>BlockElementModifier其实是块（block）、元素（element）、修饰符（modifier）。</h2><p>这三个部分使用__ 与<code>--</code>连接:<br>.块__元素–修饰符{}</p><p>block 代表了更高级别的抽象或组件<br>block__element 代表 block 的后代，用于形成一个完整的 block 的整体<br>block<code>--</code>modifier代表 block 的不同状态或不同版本</p><p>css引擎查找样式表，对每条规则都按从右到做的顺序去匹配<br>在scss中使用：使用@at-root内联选择器模式，编译出来的CSS无任何嵌套（这是关键）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.person</span> &#123;</span><br><span class="line">  @at-root #&#123;&amp;&#125;__hand &#123;</span><br><span class="line">    <span class="selector-tag">color</span>: <span class="selector-tag">red</span>;</span><br><span class="line">    <span class="keyword">@at-root</span> #&#123;&amp;&#125;<span class="selector-tag">--left</span> &#123;</span><br><span class="line">     <span class="attribute">color</span>: yellow;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">@at-root</span> #&#123;&amp;&#125;<span class="selector-tag">--female</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">    @at-root #&#123;&amp;&#125;__hand &#123;</span><br><span class="line">      <span class="selector-tag">color</span>: <span class="selector-tag">green</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*生成的css*/</span></span><br><span class="line"><span class="selector-class">.person__hand</span> &#123;</span><br><span class="line">   <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.person__hand--left</span> &#123;</span><br><span class="line">   <span class="attribute">color</span>: yellow; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.person--female</span>&#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.person--female__hand</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css-background属性使用</title>
      <link href="/ZJY.github.io/2021/01/14/css-background/"/>
      <url>/ZJY.github.io/2021/01/14/css-background/</url>
      
        <content type="html"><![CDATA[<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>Background 是一种 CSS 简写属性，一次性定义了所有的背景属性，包括 color, image, origin 还有 size, repeat 方式等等。</p><p>语法：</p><ul><li><p>background: background-color，background-image，background-repeat，background-attachment，background-position;(不强制要求书写顺序)</p><ul><li><p>background-color 指定要使用的背景颜色 transparent </p></li><li><p>background-position 指定背景图像的位置 0%, 0% </p></li><li><p>background-image 指定要使用的一个或多个背景图像 none </p></li><li><p>background-repeat 指定如何重复背景图像 repeat</p></li><li><p>background-attachment 设置背景图像是否固定或者随着页面的其余部分滚动。 croll</p></li><li><p>background-size 指定背景图片的大小 auto CSS3</p></li><li><p>background-origin 指定背景图像的定位区域 padding-box CSS3</p></li><li><p>background-clip 指定背景图像的绘画区域 border-box CSS3</p></li></ul></li></ul><p>多背景图片 background-image：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">background-image: url(<span class="string">&#x27;img1&#x27;</span>), url(<span class="string">&#x27;img2&#x27;</span>);</span><br><span class="line">background-size: <span class="number">50</span>%, <span class="number">100</span>%;</span><br><span class="line">background-repeat: repeat-x, no-repeat;</span><br></pre></td></tr></table></figure><p>多背景图片总结：</p><ul><li>背景图片所生效的样式，是属性值中与图片位置对应的值；</li><li>如果属性值比背景图片的个数要少，那么没有对应的值的图片样式以第一个值为准；</li><li>背景图片的层级按着从左往右，依次减小。当然，层级最低的还是 background-color；</li></ul><p>背景渐变 background-image: linear-gradient：路径渐变（可手动设置方向，默认自下向上）</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">background: linear-gradient(to left, #333, #333 50%, #eee 75%, #333 75%);</span><br><span class="line">background-image: linear-gradient(#71c9ce, #e3fdfd);</span><br></pre></td></tr></table></figure><p>background-image: radial-gradient 径向渐变：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-image: radial-gradient( #71c9ce, #e3fdfd);</span><br></pre></td></tr></table></figure><p>background-image: repeating-linear-gradient 重复路径渐变：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-image: repeating-linear-gradient(45deg, #71c9ce 20px, #a6e3e9 30px, #e3fdfd 40px);</span><br></pre></td></tr></table></figure><p>background-image: repeating-radial-gradient 重复径向渐变：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">background-image: repeating-radial-gradient(circle, #90ade4 ,#3350ba 20%);</span><br></pre></td></tr></table></figure><p>背景定位 background-position：</p><p>三个盒子：</p><ul><li>border-box  即所设置元素的 border 所占的区域，位于 padding 和 content 的外层</li><li>padding-box  即所设置元素的 padding 所占的区域，位于 border的内层、content 的外层</li><li>content-box 元素的 padding 所占区域包围着的即为 content</li></ul><p>background-position 默认的定位为 padding-box 盒子的左上角。其属性值可设置为：百分比 / 像素 /位置</p><p>背景重复 background-repeat：</p><p>除了常见的几个 repeat、repeat-x，repeat-y 以及 no-repeat 以外，还在CSS3 中新加了两个值： space 和 round：</p><ul><li>1.背景图片小于容器时<ul><li>background-repeat:space 在保证不缩放的前提下尽可能多的重复图片，并等分图片中间的空隙</li><li>background-repeat:round 在尽可能多的重复图片的前提下，拉伸图片以铺满容器</li></ul></li><li>2.背景图片大于容器时<ul><li>background-repeat:space 在不缩放的前提下裁剪图片，只保留在容器内的部分</li><li>background-repeat:round 缩小图片以铺满容器，长宽与容器尺寸一致（未按比例缩放，图片极有可能变形）</li></ul></li></ul><p>背景相对位置 background-origin：</p><ul><li>background-origin 属性规定 background-position 属性相对于什么位置来定位。属性值有 content-box 、padding-box 、border-box 三个，默认为 padding-box</li></ul><p>背景绘制区域 background-clip：</p><ul><li>background-clip 属性规定背景的绘制区域。默认值为 border-box，其属性值同 background-origin 一样，不过表现大不相同</li></ul><p>背景大小 background-size：</p><ul><li>background-size 除了常见的设置大小和百分比之外，还有两个特殊的属性：contain 和 cover</li><li>background-size: contain 图片长宽不相同时，把图片按比例缩小至较长的一方完全适应内容区域为止，多用于背景图片比元素大的情况</li><li>background-size: cover 图片长宽不相同时，把图片按比例放大至较短的一方完全适应内容区域为止，以使背景图像完全覆盖背景区域，多用于背景图片比元素小的情况。</li></ul><p>背景固定 background-attachment：fixed 背景固定/scroll 背景随页面滚动而滚动（默认）</p><p>扩展属性 background: element</p><ul><li>一个特殊的扩展属性，可以将某个元素设置为另一元素的背景。惊不惊喜，意不意外！不过这个属性只有 FireFox 4+ 的浏览器可以使用，并且需要加上浏览器前缀。<br>  background: element(#id)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-第十一章-javascript更多主题</title>
      <link href="/ZJY.github.io/2021/01/14/javascript-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-javascript%E6%9B%B4%E5%A4%9A%E4%B8%BB%E9%A2%98/"/>
      <url>/ZJY.github.io/2021/01/14/javascript-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-javascript%E6%9B%B4%E5%A4%9A%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript的更多主题"><a href="#JavaScript的更多主题" class="headerlink" title="JavaScript的更多主题"></a>JavaScript的更多主题</h2><h3 id="1-数据类型转换"><a href="#1-数据类型转换" class="headerlink" title="1. 数据类型转换"></a>1. 数据类型转换</h3><p>JavaScript是一种无类型语言，如果某个类型的值需要用于其他类型的值的环境中，JavaScript就会自动将    这个值转换成所需要的类型。例如，如果一个数字用于布尔值环境中，它就会被转换成布尔值。如果一个对象用于字符串类型中，那么它就会被转换为字符串。<br>自动数据类型转换：</p><table style="text-align:center">   <tr >      <td rowspan="2">值</td>      <td colspan="4">使用值的环境</td>   </tr>   <tr>      <td>字符串</td>      <td>数字</td>      <td>布尔值</td>      <td>对象</td>   </tr>   <tr>      <td>未定义的值</td>      <td>“undefined”</td>      <td>NaN</td>      <td>false</td>      <td>Error</td>   </tr>   <tr>      <td>null</td>      <td>“null”</td>      <td>0</td>      <td>false</td>      <td>Error</td>   </tr>   <tr>      <td>非空字符串</td>      <td>原内容</td>      <td>非空字符串对应数字或ASCLL码</td>      <td>true</td>      <td>String对象</td>   </tr>   <tr>      <td>空字符串</td>      <td>原内容</td>      <td>0</td>      <td>false</td>      <td>String对象</td>   </tr>   <tr>      <td>0</td>      <td>“0”</td>      <td>原值</td>      <td>false</td>      <td>Number对象</td>   </tr>   <tr>      <td>NaN</td>      <td>“NaN”</td>      <td>NaN</td>      <td>false</td>      <td>Number对象</td>   </tr>   <tr>      <td>无穷大</td>      <td>“Infinity”</td>      <td>原值</td>      <td>true</td>      <td>Number对象</td>   </tr>   <tr>      <td>负无穷大</td>      <td>“-Infinity”</td>      <td>原值</td>      <td>true</td>      <td>Number对象</td>   </tr>   <tr>      <td>其他所有数字</td>      <td>数字对应字符串</td>      <td>原值</td>      <td>true</td>      <td>Number对象</td>   </tr>   <tr>      <td>true</td>      <td>“true”</td>      <td>1</td>      <td>true</td>      <td>Boolean对象</td>   </tr>   <tr>      <td>false</td>      <td>“false”</td>      <td>0</td>      <td>false</td>      <td>Boolean对象</td>   </tr>   <tr>      <td>对象</td>      <td>toString()</td>      <td>valueOf()或toString()或NaN</td>      <td>true</td>      <td>原值</td>   </tr></table><h4 id="1-1-对象到基本数据类型的转换"><a href="#1-1-对象到基本数据类型的转换" class="headerlink" title="1.1 对象到基本数据类型的转换"></a>1.1 对象到基本数据类型的转换</h4><p>只要把非空对象用在布尔值环境中，它就会被转换为true。这适用于所有对象，即使是被转换成false的表示原始值的包装对象也不例外。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>))</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">0</span>))</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="keyword">new</span> <span class="built_in">Array</span>())</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>把对象转为数字是通过首先调用该对象的valueOf()方法来完成的。大多数对象继承了Object对象的默认valueOf()方法。它只是返回对象本身。由于默认的valueOf()方法不返回原始值，所有接下来javascript会通过调用对象的toString()方法，再将字符串转为数字来把对象转为数字。</p><p>对于数组，数组的toString()方法把数组元素逐一的转换成字符串，用逗号分隔符分隔连接起来，返回连接后的字符串。因此，没有元素的空数组，被转换为空字符串，空字符串被转换为数字0。如果数组只有一个为n的数字元素，则被转换为n本身，如果数组含有多个元素，则被转换为NaN。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>([])</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="literal">NaN</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"><span class="literal">NaN</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="number">1</span>])</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="built_in">Number</span>([<span class="string">&#x27;1&#x27;</span>])</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>运算符“+”和比较运算符(&lt;、&lt;=、&gt;和&gt;=)既能作用于数字，又能作用于字符串。所以当这两个运算符作用于对象时，就不太清楚应将该对象转换为数字还是字符串。在大多数情况下，JavaScript会先尝试调用对象的valueOf ()方法对它进行转换。如果该方法返回了原始值(通常是一个数字)，就使用那个值。但是valueOf ()方法通常返回的都是未被转换的对象，在这种情况下，JavaScript 将调用对象的tostring()方法对它进行转换。<br>对于这种转换规则，只有“+”运算符是例外的当“+”作用于Date对象时，首先调用toString()方法进行转换。存在这一例外的原因是Date对象既有toString又有valueOf方法。当“+”作用于一个Date对象时，你想执行的几乎都是连接操作，但是当用于比较运算符时想执行的几乎都是数字比较，以判断时间大小。</p><p>大多数对象没有valueOf()方法，或者没有能够返回有用的结果的valueOf()方法。当将“+”运算符作用于一个对象时，通常进行的是字符串的连接而不是加法运算。当将比较运算符作用于一个对象时，通常进行的则是字符串的比较，而不是数字比较。</p><h4 id="1-2-显示类型转换"><a href="#1-2-显示类型转换" class="headerlink" title="1.2 显示类型转换"></a>1.2 显示类型转换</h4><p>Number(),String(),Boolean(),Object()可以把它们参数转换为合适的类型。<br>还有别的技巧可以显式类型转换。<br>要把一个值转换为字符串，可以把它连接到一个空串上：<br>var str = x + “”;<br>要把一个值强制转换为数字，就用它减去0:<br>var number = x - 0;<br>要把一个值转换为布尔值，需要连用两次”!”：<br>var bool = !!x;</p><h4 id="1-3-从数字到字符串的转换"><a href="#1-3-从数字到字符串的转换" class="headerlink" title="1.3 从数字到字符串的转换"></a>1.3 从数字到字符串的转换</h4><p>将数字转换为字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="built_in">String</span>(number);</span><br><span class="line"><span class="keyword">var</span> str = number + ‘’;</span><br></pre></td></tr></table></figure><p>另一种方法是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = number.toString();</span><br><span class="line"><span class="comment">// Number的toString()方法又一个可选的参数，说明了转换的基数，如果省略默认是10，也可以是2-36之间的整数</span></span><br></pre></td></tr></table></figure><h4 id="1-4-从字符串到数字的转换"><a href="#1-4-从字符串到数字的转换" class="headerlink" title="1.4 从字符串到数字的转换"></a>1.4 从字符串到数字的转换</h4><p>从字符串到数字的转换，可以显式的使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="built_in">Number</span>(str);</span><br><span class="line"><span class="keyword">var</span> num = str - <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这种转换只适用于基数10，且允许字符串数字前面有空格，不允许字符串数字后面出现任何非空字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">‘ <span class="number">123</span>’ - <span class="number">0</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line">‘<span class="number">123</span> ’ - <span class="number">0</span></span><br><span class="line">‘a123’ - <span class="number">0</span></span><br><span class="line"><span class="literal">NaN</span></span><br><span class="line">‘<span class="number">123</span> a’ - <span class="number">0</span></span><br><span class="line"><span class="literal">NaN</span></span><br></pre></td></tr></table></figure><p>可以适用parseInt()/parseFloat()函数，这两个函数转换并返回字符串开头的所有数字，并忽略其后的所有非数字后缀。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;aq123&#x27;</span>)</span><br><span class="line"><span class="literal">NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;123a&#x27;</span>)</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="comment">// parseInt()只能解析整数，parseFloat()既能解析整数又能解析浮点数，如果一个字符串以’ox’或’0X’开头，那么parseInt()就将它解释为16进制。</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;3.14 meters&#x27;</span>)</span><br><span class="line"><span class="number">3.14</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;3.14 meters&#x27;</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;0xff&#x27;</span>)</span><br><span class="line"><span class="number">255</span></span><br></pre></td></tr></table></figure><p>parseInt()第二个参数指定要被解析的基数，是2-36之间的整数。<br>如果不能将字符串转换为数字，就返回NaN。</p><h3 id="2-使用值和使用引用"><a href="#2-使用值和使用引用" class="headerlink" title="2. 使用值和使用引用"></a>2. 使用值和使用引用</h3><p>在JavaScript中可以使用三种方式来操作数值：<br>1.可以复制它，把它赋值个一个新的变量<br>2.把它作为参数传递给一个函数或方法<br>3.可以把它和其他值比较来看是否相等<br>操作数值时，有2种根本不同的方式，一种“使用值”一种是“使用引用”。<br>当使用值来操作数据时，重要的是那个值。在一个赋值语句中，会生成一个实际值的副本，这个副本存储在变量中，对象的属性或数组元素中。副本和原始数据是两个分别存放的，独立的值。当使用值将一个数据传递给函数时，传递的是这个数据的副本。如果函数修改了这个值，改变的只是这个数据的副本，并不会修改原始的数据。</p><p>另一种操作数值的方式是使用引用。采用这个方式时，数据的实际副本只有一份，操作的是那个数值的引用。如果操作数据时使用的是引用，那么变量保存的并不是那个值，而是数值的引用，复制的，传递的以及比较的都是值的引用。因此在使用引用的赋值语句中，赋予的是数值的引用而不是值的副本更不是值本身。进行了赋值后，新的变量保存的也是对值的引用，这两个引用具有同等效力，如果其中一个修改了数值，那么原始引用也会改变。当使用引用将值传递给函数时，传递的也是值的引用。使用引用将一个数值和另一个数值比较时，比较的是两个引用，看它们是否引用的是同一个数值的唯一副本。<br>使用值和使用引用</p><table style="text-align:center">   <tr>      <td>操作</td>      <td>使用值</td>      <td>使用引用</td>   </tr>   <tr>      <td>复制</td>      <td>实际复制的是值，是2个不同的独立的副本</td>      <td>复制的只是对数值的引用，如果通过新的引用修改了值，也会改变原始引用</td>   </tr>   <tr>      <td>传递</td>      <td>传递的是一个独立的副本，对他的改变在函数外部没有影响</td>      <td>传递的是值的引用，如果通过函数传递的引用修改了值，这个改变在函数外部可见</td>   </tr>   <tr>      <td>比较</td>      <td>比较的两个独立的值，以判断是否相等</td>      <td>比较的是2个引用，以判断它们引用的是否是同一个数值，对两个不同的数值的引用不相等，即使这两个数值的是由相同的字节构成的。</td>   </tr></table><h4 id="2-1-基本类型和引用类型"><a href="#2-1-基本类型和引用类型" class="headerlink" title="2.1 基本类型和引用类型"></a>2.1 基本类型和引用类型</h4><p>基本类型使用值操作，引用类型使用引用来操作。<br>在JavaScript中，数字和布尔值是基本类型，说它们基本，是因为它们只是由小的、固定数量的字节构成的，这些字节是在JavaScript解释器的低层(基本层)进行操作的。另一方面，对象就是引用类型。作为特殊对象类型的数组和函数因此也是引用类型。由于这些数据类型可以包含任意多个属性或元素，所以它们不像固定大小的基本数值那样易于操作。因为对象和数组的值可能变得非常大，所以使用值来操作这些数据很不合理，这样做可能会产生大量低效率的内存复制和比较。<br>那么字符串又是什么类型的呢?由于字符串的长度是任意的，所以看起来它好像应该属于引用类型。但事实上在JavaScrip中它们通常被当作基本类型，因为它们并不是对象。<br>例：使用值进行复制，传递，比较</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> m = n;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add_to_total</span>(<span class="params">total, x</span>)</span>&#123;</span><br><span class="line">    total = total + x;</span><br><span class="line">&#125;</span><br><span class="line">add_to_total(n,m);</span><br><span class="line"><span class="built_in">console</span>.log(n,m); <span class="comment">//1 1</span></span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>) m = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(n,m);<span class="comment">//1  2</span></span><br></pre></td></tr></table></figure><p>例：使用引用进行复制，传递，比较</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmas = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2001</span>,<span class="number">11</span>,<span class="number">25</span>);</span><br><span class="line"><span class="keyword">var</span> solstice = xmas; <span class="comment">//赋值的是值的引用</span></span><br><span class="line">solstice.setDate(<span class="number">21</span>);</span><br><span class="line">xmas.getDate(); <span class="comment">//返回21，而不是原始值25</span></span><br><span class="line">(xmas == solstice) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xmas1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2001</span>,<span class="number">11</span>,<span class="number">25</span>);</span><br><span class="line"><span class="keyword">var</span> solstice1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2001</span>,<span class="number">11</span>,<span class="number">25</span>); </span><br><span class="line">(xmas1 == solstice1) <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h4 id="2-2-使用值和使用引用：总结"><a href="#2-2-使用值和使用引用：总结" class="headerlink" title="2.2 使用值和使用引用：总结"></a>2.2 使用值和使用引用：总结</h4><p>操作不同类型时所采取的方式。</p><table style="text-align:center">   <tr>      <td>类型</td>      <td>复制所使用的</td>      <td>传递所引用的</td>      <td>比较所引用的</td>   </tr>   <tr>      <td>数字</td>      <td>值</td>      <td>值</td>      <td>值</td>   </tr>   <tr>      <td>布尔值</td>      <td>值</td>      <td>值</td>      <td>值</td>   </tr>   <tr>      <td>字符串</td>      <td>不可变的值</td>      <td>不可变的</td>      <td>值</td>   </tr>   <tr>      <td>对象</td>      <td>引用</td>      <td>引用</td>      <td>引用</td>   </tr></table><h3 id="3-无用存储单元收集"><a href="#3-无用存储单元收集" class="headerlink" title="3. 无用存储单元收集"></a>3. 无用存储单元收集</h3><p>JavaScript·使用无用存储单元来回收那些由字符串、对象、数组和函数占用的而且不再使用的内存。</p><h4 id="3-1-标记和清除的无用存储单元"><a href="#3-1-标记和清除的无用存储单元" class="headerlink" title="3.1 标记和清除的无用存储单元"></a>3.1 标记和清除的无用存储单元</h4><p>一个标记 和清除的无用存储单元回收器会周期性地遍历javascript环境中的所有变量的列表，并且给这些变量所引用的值做标记。如果被引用的值是对象或数组，那么对象的属性或者数组的元素就会被递归地做上标记。通过递归地遍历所有值的树或者图，无用存储单元收集器就能够找到(并标记)仍旧使用的每个值。那些没有标记的值就是无用的存储单元。当采用标记和清除算法的无用单元收集器给所有正在使用的变量做完了标记之后，它就会开始进行清除。在这个阶段中，它将遍历环境中所有值的列表，同时释放那些没有标记的值。经典的标记和清除无用存储单元收集器每次都进行一次完整的标记和一次完整的清除工作，这在使用无用存储单元收集过程的系统中会大大降低系统的速度。该算法较为复杂的变形使效率相对提高，它们在后台执行收集，并不影响系统的性能。</p><h4 id="3-2-采用引用计数的无用存储单元收集"><a href="#3-2-采用引用计数的无用存储单元收集" class="headerlink" title="3.2 采用引用计数的无用存储单元收集"></a>3.2 采用引用计数的无用存储单元收集</h4><p>当一个对象被创建，而且它的一个引用被存储在变量中，引用计数就为1。当这个对象的引用被复制，并且存储在另一个变量中时，引用计数就增加到2。当保存这些引用的其中一个变量被某个新值覆盖了时，该象的引用计数就减为1。如果引用计数达到了0，那么就没有对这个对象的引用了。由于没有了对副本的引用，所以在程序中也就不会再有对这个对象的引用。因此， Javascript知道此时销毀对象并且收集与之关联的内存是安全的。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-第十章-正则表达式</title>
      <link href="/ZJY.github.io/2021/01/13/javascript-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/ZJY.github.io/2021/01/13/javascript-%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="第十章-正则表达式"><a href="#第十章-正则表达式" class="headerlink" title="第十章-正则表达式"></a>第十章-正则表达式</h2><p>正则表达式（regular expression）是一个描述字符模式的对象。javascript的RegExp类表示正则表达式。而String和RegExp都定义了使用正则表达式进行强大的模式匹配和文本检索与替换的函数。</p><h3 id="1-正则表达式的定义"><a href="#1-正则表达式的定义" class="headerlink" title="1. 正则表达式的定义"></a>1. 正则表达式的定义</h3><p>在javascript中，正则表达式由RegExp对象表示，当然可以使用RegExp()构造函数创建RegExp对象，不过通常用直接量语法来创建RegExp对象。被定义在一堆斜杠之间的字符，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = <span class="regexp">/s$/</span>; <span class="comment">//匹配所有以字母‘s’结尾的字符串</span></span><br></pre></td></tr></table></figure><p>也可用构造函数表示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(‘s$’);</span><br></pre></td></tr></table></figure><h4 id="1-1-直接量字符"><a href="#1-1-直接量字符" class="headerlink" title="1.1 直接量字符"></a>1.1 直接量字符</h4><p>正则表达式的直接量字符</p><table><thead><tr><th align="center">字符</th><th align="center">匹配</th></tr></thead><tbody><tr><td align="center">字母数字字符</td><td align="center">匹配自己本身</td></tr><tr><td align="center">\o</td><td align="center">NUL字符(\u0000)</td></tr><tr><td align="center">\t</td><td align="center">制表符</td></tr><tr><td align="center">\n</td><td align="center">换行符</td></tr><tr><td align="center">\v</td><td align="center">垂直制表符</td></tr><tr><td align="center">\v</td><td align="center">换页符</td></tr><tr><td align="center">\r</td><td align="center">回车</td></tr><tr><td align="center">\xnn</td><td align="center">由十六进制数nn指定的拉丁字符</td></tr><tr><td align="center">\uxxxx</td><td align="center">由十六进制xxxx指定的unicode字符</td></tr><tr><td align="center">\cX</td><td align="center">控制字符^X</td></tr></tbody></table><p>在正则中，许多标点符号具有特殊的含义：<br> ^ $ . * + ? = ! : | \ / () [] {}</p><h4 id="1-2-字符类"><a href="#1-2-字符类" class="headerlink" title="1.2 字符类"></a>1.2 字符类</h4><p>正则表达式的字符类</p><table><thead><tr><th align="center">字符</th><th align="center">匹配</th></tr></thead><tbody><tr><td align="center">[…]</td><td align="center">位于括号之内的任意字符</td></tr><tr><td align="center">[^…]</td><td align="center">不在括号之中的任意字符</td></tr><tr><td align="center">.</td><td align="center">除换行符和其他unicode行终止符之外的任意字符</td></tr><tr><td align="center">\w</td><td align="center">任何ASCLL单字字符，等价于[a-zA-Z0-9]</td></tr><tr><td align="center">\W</td><td align="center">任何ASCLL非单字字符，等价于[^a-zA-Z0-9]</td></tr><tr><td align="center">\s</td><td align="center">任何unicode空白符</td></tr><tr><td align="center">\S</td><td align="center">任何非unicode空白符</td></tr><tr><td align="center">\d</td><td align="center">任何ASCLL数字，等价于[0-9]</td></tr><tr><td align="center">\D</td><td align="center">任何ASCLL数字之外的任何字符，等价于[^0-9]</td></tr><tr><td align="center">[\b]</td><td align="center">退格直接量</td></tr></tbody></table><h4 id="1-3-重复"><a href="#1-3-重复" class="headerlink" title="1.3 重复"></a>1.3 重复</h4><p>正则表达式的重复字符</p><table><thead><tr><th align="center">字符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">{n,m}</td><td align="center">匹配前一项至少n次，但是不能超过m次</td></tr><tr><td align="center">{n,}</td><td align="center">匹配前一项n次或更多次</td></tr><tr><td align="center">{n}</td><td align="center">匹配前一项正好n次</td></tr><tr><td align="center">?</td><td align="center">匹配前一项0次或1次，等价于{0,1}</td></tr><tr><td align="center">+</td><td align="center">匹配前一项一次或多次，等价于{1,}</td></tr><tr><td align="center">*</td><td align="center">匹配前一项0次或多次，等价于{0,}</td></tr></tbody></table><h4 id="1-4-选择-分组和引用"><a href="#1-4-选择-分组和引用" class="headerlink" title="1.4 选择/分组和引用"></a>1.4 选择/分组和引用</h4><p>字符“｜”用于分隔供选择的字符，例如，/ab|cd|ef/既匹配字符串”ab”,又匹配”cd”,又或者是”ef”. 选择项从左到右考虑，直到发现了匹配项，如果左边选项匹配，就忽略右边的匹配项。</p><h4 id="1-5指定匹配的位置"><a href="#1-5指定匹配的位置" class="headerlink" title="1.5指定匹配的位置"></a>1.5指定匹配的位置</h4><table><thead><tr><th align="center">字符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">^</td><td align="center">匹配字符串的开头</td></tr><tr><td align="center">$</td><td align="center">匹配字符串的结尾</td></tr><tr><td align="center">\b</td><td align="center">匹配一个词语的边界</td></tr><tr><td align="center">\B</td><td align="center">匹配非词语边界的字符</td></tr></tbody></table><h4 id="1-6标志"><a href="#1-6标志" class="headerlink" title="1.6标志"></a>1.6标志</h4><table><thead><tr><th align="center">字符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">i</td><td align="center">执行大小写不敏感的匹配</td></tr><tr><td align="center">g</td><td align="center">执行全局匹配</td></tr><tr><td align="center">m</td><td align="center">多行模式</td></tr></tbody></table><h3 id="2-用于匹配模式的String方法"><a href="#2-用于匹配模式的String方法" class="headerlink" title="2. 用于匹配模式的String方法"></a>2. 用于匹配模式的String方法</h3><p>类String支持四种利用正则表达式的方法</p><ul><li>search(),该方法以正则表达式为参数，返回第一个与之匹配的子串的开始字符的位置，没有没有匹配子串，返回-1，例如：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“JavaScript”.search(<span class="regexp">/script/i</span>); <span class="comment">//4</span></span><br></pre></td></tr></table></figure><p>如果参数不是正则表达式，会传递给RegExp构造函数转换成正则表达式。search不支持全局检索。</p><ul><li><p>方法replace()执行检索和替换操作，第一个参数是正则表达式，第二个参数是要进行替换的字符串。如果正则表达式中设置类标记g，将用替换字符串替换被检索的字符串中所有与模式匹配的子串，否则只替换第一个与模式匹配的子串。如果第一个参数是字符串，则直接检索该字符串。例如：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">text.replace(<span class="regexp">/javascript/gi</span>,”JavaScript”);</span><br></pre></td></tr></table></figure><p>  第二个参数可以是函数，能够动态地计算替换字符串。</p></li><li><p>方法match()，唯一的参数就是正则表达式（或者参数传递给构造函数RegExp以转换成正则表达式），返回包含匹配结果的数组，例如：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“<span class="number">1</span> plus <span class="number">2</span> equals <span class="number">3</span>”.match(<span class="regexp">/\d+/g</span>); <span class="comment">//[“1”,”2”,”3”]</span></span><br></pre></td></tr></table></figure><p>  如果不设置标志g，只检索第一个匹配，返回的也是数组</p></li><li><p>split()方法可以把调用它的字符串分解为一个子串数组，使用分隔符作为参数，例如：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“<span class="number">123</span>,<span class="number">456</span>,<span class="number">789</span>”.split(‘,’); <span class="comment">//[“123”,”456”,”789”]</span></span><br></pre></td></tr></table></figure><p>  也可以用正则表达式为参数，指定分隔符，允许两个有任意多个空白符：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“<span class="number">1</span>,<span class="number">2</span>, <span class="number">3</span> , <span class="number">4</span> ,<span class="number">5</span>”.split(<span class="regexp">/\s*,\s*/</span>); <span class="comment">//[“1”,”2”,”3”,”4”,”5”]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-RegExp对象"><a href="#3-RegExp对象" class="headerlink" title="3. RegExp对象"></a>3. RegExp对象</h3><p>构造函数RegExp()有一个或2个字符串参数，第一个是包含正则表达式主体的字符串，即正则表达式斜杠之间的文本，用<code>\\</code>代表转义的\字符，第二个参数可选，是表达式的标志，“g”,”i”,”m”或它们的组合，例如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> zipcode = <span class="keyword">new</span> <span class="built_in">RegExp</span>(“\\d&#123;<span class="number">5</span>&#125;”,”g”);<span class="comment">//找到字符串中5个数字</span></span><br></pre></td></tr></table></figure><h4 id="3-1-用于模式匹配的RegExp方法"><a href="#3-1-用于模式匹配的RegExp方法" class="headerlink" title="3.1 用于模式匹配的RegExp方法"></a>3.1 用于模式匹配的RegExp方法</h4><p>RegExp对象定义类2个用于执行模式匹配操作的方法。</p><ul><li><p>exec()对一个指定的字符串执行正则表达式，就是在一个字符串中检索匹配，如果没有找到就返回null，如果找到一个匹配就返回一个数组。这个数组的元素0包含的是正则表达式相匹配的字符串，余下的所有元素包含的是与括号扩起来的子表达式相匹配的子串。而且，属性index包含类匹配发生的字符的位置，属性input引用的是被检索的字符串。</p></li><li><p>test()参数是一个字符串，如果这个字符串包含正则表达式的一个匹配就返回true</p></li></ul><h4 id="3-2-RegExp的实例属性"><a href="#3-2-RegExp的实例属性" class="headerlink" title="3.2 RegExp的实例属性"></a>3.2 RegExp的实例属性</h4><p>每个RegExp对象都有5个属性.</p><ul><li>属性source是一个只读字符串，存放的是正则表达式的文本。</li><li>属性global是一个只读的布尔值，说明该表达式是否有标志g。</li><li>属性ignoreCase是一个只读的布尔值，说明该表达式是否有标志i。</li><li>属性multiline是一个只读的布尔值，说明该表达式是否有标志m。</li><li>最后一个属性是lastIndex，可读写的整数。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-第九章-数组</title>
      <link href="/ZJY.github.io/2021/01/13/javascript-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%95%B0%E7%BB%84/"/>
      <url>/ZJY.github.io/2021/01/13/javascript-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="第九章-数组"><a href="#第九章-数组" class="headerlink" title="第九章-数组"></a>第九章-数组</h2><p>对象类型是一种包含已命名的的值的复合数据类型，数组即一种包含已编码的值的复合数据类型</p><h3 id="1-数组和数组元素"><a href="#1-数组和数组元素" class="headerlink" title="1. 数组和数组元素"></a>1. 数组和数组元素</h3><p>数组（array）是一种数据类型，它包含或者存储了编码的值。每个编码的值称作该数组的一个元素（element），每个元素的编码成为数组的下标（index）。</p><h4 id="1-1-数组的创建"><a href="#1-1-数组的创建" class="headerlink" title="1.1 数组的创建"></a>1.1 数组的创建</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">a</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line">a.length; <span class="comment">//3, 每个元素都是undefined</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>();<span class="comment">//[] 创建了一个空数组</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><h4 id="1-2-数组元素的读和写"><a href="#1-2-数组元素的读和写" class="headerlink" title="1.2 数组元素的读和写"></a>1.2 数组元素的读和写</h4><p>可以用[]来存取数组元素。方括号左边是对数组的引用，方括号中是具有非负整数的任意表达式。数组的下标必须是大于等于0并小于2<sup>23-1</sup>的整数，如果你使用的数字过大或者使用了小数负数，浮点数，会转化为字符串作为对象属性的名字，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">a[-<span class="number">12</span>] = <span class="number">12</span></span><br><span class="line">a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, &#123;-<span class="number">12</span>:<span class="number">12</span>&#125;]</span><br></pre></td></tr></table></figure><h4 id="1-3-数组的长度"><a href="#1-3-数组的长度" class="headerlink" title="1.3 数组的长度"></a>1.3 数组的长度</h4><p>所有的数组都有length属性，用来说明这个数组包含的元素个数。数组的length是自动更新的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">a.length</span><br><span class="line"><span class="number">0</span></span><br><span class="line">a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>);</span><br><span class="line">a.length</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><p>数组的length属性既可以读又可以写，当length设置了一个比他小的值，之后的值会被截断，值就会丢失。如果length设置的值比当前值大，那么未定义的元素就会被添加到数组末尾以使数组增加到指定长度。<br>通过设置数组length是唯一缩短数组长度的方法。如果使用delete来删除元素，虽然元素变成未定义的，但是数组的length属性不会变。</p><h3 id="2-数组的方法"><a href="#2-数组的方法" class="headerlink" title="2. 数组的方法"></a>2. 数组的方法</h3><h4 id="2-1-join方法"><a href="#2-1-join方法" class="headerlink" title="2.1 join方法"></a>2.1 join方法</h4><p>方法Array.join()方法可以将一个数组元素都转换成字符串，然后拼接起来。你可以指定一个可选的字符串来隔离结果字符串中的元素，如果没有指定，用逗号分割。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">a.join(<span class="string">&quot;*&quot;</span>)</span><br><span class="line"><span class="string">&quot;1*2&quot;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-reverse方法"><a href="#2-2-reverse方法" class="headerlink" title="2.2.reverse方法"></a>2.2.reverse方法</h4><p>方法Array.reverse()方法将颠倒数组顺序并返回颠倒后的结果。他在原数组上操作，并不是新建一个数组进行操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a.reverse();</span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">a</span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h4 id="2-3-sort方法"><a href="#2-3-sort方法" class="headerlink" title="2.3 sort方法"></a>2.3 sort方法</h4><p>Array.sort()方法是在原数组上对数组元素进行排序，返回排序后的结果，如果调用时不传参数，将按照字母顺序进行排序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">&#x27;banan&#x27;</span>,<span class="string">&#x27;apple&#x27;</span>,<span class="string">&#x27;orange&#x27;</span>];</span><br><span class="line">a.sort();</span><br><span class="line">a.join();</span><br><span class="line"><span class="string">&quot;apple,banan,orange&quot;</span></span><br><span class="line">a</span><br><span class="line">[<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banan&quot;</span>, <span class="string">&quot;orange&quot;</span>]</span><br></pre></td></tr></table></figure><p>如果含有未定义的元素，这些元素将被放在数组的末尾<br>如果要按照别的顺序排序，需要传递给sort方法一个比较函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>];</span><br><span class="line">a.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;)</span><br><span class="line"> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>];</span><br><span class="line">a.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b-a;</span><br><span class="line">&#125;)</span><br><span class="line"> [<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h4 id="2-4-concat"><a href="#2-4-concat" class="headerlink" title="2.4 concat"></a>2.4 concat</h4><p>方法Array.concat()能创建并返回一个数组,这个数组包含了调用concat()的原始数组的元素，其后跟随的是concat()的参数。如果其中有些参数是数组,那么它将被展开,其元素将被添加到返回的数组中。但是要注意concat()并不能递归地展开一个元素为数组的数组。下面是一些例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.concat(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment">//[1,2,3.4,5]</span></span><br><span class="line">a.concat([<span class="number">4</span>,<span class="number">5</span>]);</span><br><span class="line"><span class="comment">//返回[1,2,3,4,5]</span></span><br><span class="line">a.concat([<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>])</span><br><span class="line"><span class="comment">//[1,2,3,4,5,6,7]</span></span><br><span class="line">a.concat(<span class="number">4</span>,[<span class="number">5</span>,[<span class="number">6</span>,<span class="number">7</span>]])<span class="comment">//返回[1,2,3,4,5,[6,7]]</span></span><br></pre></td></tr></table></figure><h4 id="2-5-slice-方法"><a href="#2-5-slice-方法" class="headerlink" title="2.5 slice()方法"></a>2.5 slice()方法</h4><p>方法Array.slice()方法返回的是指定的一个数组片段，它的两个参数指定要返回数组的起止点，返回的值是包含第一个参数指定的元素和第二个参数指定元素的上一个元素为止的元素，但是并不包含第二个参数包含的元素。如果只传递一个参数，那么返回从第一个元素到末尾之间的元素，如果参数含有负数，那么从数组末尾开始算，例如，-1指的是数组最后一个元素。例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">a.slice(<span class="number">0</span>,<span class="number">3</span>)</span><br><span class="line"> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">a.slice(<span class="number">1</span>,-<span class="number">1</span>)</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">a.slice(-<span class="number">3</span>,-<span class="number">2</span>)</span><br><span class="line">[<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h4 id="2-6-splice方法"><a href="#2-6-splice方法" class="headerlink" title="2.6 splice方法"></a>2.6 splice方法</h4><p>方法Array.splice()在原数组上插入或删除数组元素，修改原数组。<br>第一个参数指定了要插入或删除的的元素在数组中的位置。第二个参数指定了要删除的元素个数。如果第二个参数省略，将删除从开始元素到末尾之间的元素，splice返回的是删除了的数组元素数组，如果没有删除，返回空数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">a.splice(<span class="number">4</span>)</span><br><span class="line">[<span class="number">5</span>]</span><br><span class="line">a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">a.splice(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">a</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">a.splice(<span class="number">1</span>,<span class="number">0</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">[]</span><br><span class="line">a</span><br><span class="line">[<span class="number">1</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">a.splice(<span class="number">1</span>,<span class="number">0</span>,[<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">[]</span><br><span class="line">a</span><br><span class="line">[<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>],<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>]</span><br><span class="line"><span class="comment">// splice并不将插入的元素展开</span></span><br></pre></td></tr></table></figure><h4 id="2-7-push方法和pop方法"><a href="#2-7-push方法和pop方法" class="headerlink" title="2.7 push方法和pop方法"></a>2.7 push方法和pop方法</h4><p>push和pop可以像栈那样使用数组，push可以向数组末尾添加一个或多个数组元素，并返回数组的新长度，pop可以删除数组最后一个元素，返回删除的值，这两个方法都修改原数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stack = [];</span><br><span class="line">stack.push(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line">stack.pop()</span><br><span class="line"><span class="number">2</span></span><br><span class="line">stack.push(<span class="number">3</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line">stack.pop()</span><br><span class="line"><span class="number">3</span></span><br><span class="line">stack.push([<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="number">2</span></span><br><span class="line">stack.pop()</span><br><span class="line"> [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">stack.pop()</span><br><span class="line"><span class="number">1</span></span><br><span class="line">stack</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><h4 id="2-8-unshift和shift方法"><a href="#2-8-unshift和shift方法" class="headerlink" title="2.8 unshift和shift方法"></a>2.8 unshift和shift方法</h4><p>和push和pop类似，只不过是在数组头部插入和删除元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = []</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line">a.unshift(<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">a.unshift(<span class="number">22</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line">a.shift()</span><br><span class="line"><span class="number">22</span></span><br><span class="line">a</span><br><span class="line">[<span class="number">1</span>]<span class="number">0</span>: 1length: 1__proto__: <span class="built_in">Array</span>(<span class="number">0</span>)</span><br><span class="line">a.unshift([<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="number">2</span></span><br><span class="line">a</span><br><span class="line"> [[<span class="number">4</span>, <span class="number">5</span>], <span class="number">1</span>]</span><br><span class="line">a.shift()</span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">a.shift()</span><br><span class="line"><span class="number">1</span></span><br><span class="line">a</span><br><span class="line">[]</span><br></pre></td></tr></table></figure><h4 id="2-9-toString方法"><a href="#2-9-toString方法" class="headerlink" title="2.9 toString方法"></a>2.9 toString方法</h4><p>数组的toString将数组每个元素转换为字符串，用逗号拼接，并且没有其他的界定符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].toString()</span><br><span class="line"><span class="string">&quot;1,2,3&quot;</span></span><br><span class="line">[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>].toString()</span><br><span class="line"><span class="string">&quot;a,b,c&quot;</span></span><br><span class="line">[<span class="number">1</span>,[<span class="number">2</span>,<span class="string">&quot;c&quot;</span>]].toString()</span><br><span class="line"><span class="string">&quot;1,2,c&quot;</span></span><br></pre></td></tr></table></figure><p>注意toString的返回值和无参数的join方法返回值相等：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,[<span class="number">2</span>,<span class="string">&quot;c&quot;</span>]].join()</span><br><span class="line"><span class="string">&quot;1,2,c&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-第八章-对象</title>
      <link href="/ZJY.github.io/2021/01/13/javascript-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1/"/>
      <url>/ZJY.github.io/2021/01/13/javascript-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="第八章-对象"><a href="#第八章-对象" class="headerlink" title="第八章-对象"></a>第八章-对象</h2><h3 id="1-对象和属性"><a href="#1-对象和属性" class="headerlink" title="1. 对象和属性"></a>1. 对象和属性</h3><p>对象是一种复合数据类型，将多个数据值存储在一个单元中，并使用名字来存取这些值。<br>解释对象的另一种方式就是，对象是一个无序的属性集合，每个属性都有自己的名字和值，存储在对象中已命名的值既可以是数字字符串也可以是对象。</p><h4 id="1-1-对象的创建"><a href="#1-1-对象的创建" class="headerlink" title="1.1 对象的创建"></a>1.1 对象的创建</h4><p>对象是由运算符new创建的，在这个运算符之后必须有用于初始化对象的构造函数名，可以用如下代码创建空对象（没有属性的对象）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure><p>javascript还支持内部构造函数，例如： var now  = new Date();<br>对象直接量定义了另一种初始化对象的方式。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    x:<span class="number">0</span>,</span><br><span class="line">    y:<span class="number">0</span>,</span><br><span class="line">    radius:<span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-属性的设置和查询"><a href="#1-2-属性的设置和查询" class="headerlink" title="1.2 属性的设置和查询"></a>1.2 属性的设置和查询</h4><p>通常使用“.”运算符来存取对象的属性。位于“.”运算符左边的是对象的引用，右边的是对象的属性，是一个标识符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">book.title = <span class="string">&#x27;javascript高级程序设计&#x27;</span>;<span class="comment">//设置属性</span></span><br><span class="line">book.title ; <span class="comment">//属性查询</span></span><br></pre></td></tr></table></figure><h4 id="1-3-属性的枚举"><a href="#1-3-属性的枚举" class="headerlink" title="1.3 属性的枚举"></a>1.3 属性的枚举</h4><p>可以通过for/in来遍历对象的属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getObjNames</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> names = “”;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> name <span class="keyword">in</span> obj) names+= name ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for/in循环属性并没有特定的顺序，虽然能枚举出用户定义的属性，但不能枚举出某些预定义的属性和方法</p><h4 id="1-4-未定义的属性"><a href="#1-4-未定义的属性" class="headerlink" title="1.4 未定义的属性"></a>1.4 未定义的属性</h4><p>如果要读取一个未定义的属性，那么读取的值是undefined.<br>可以用运算符delete来删除对象的属性：<br>delete book.title;<br>删除一个属性不仅仅是将属性值设置为undefined,而是真正从该对象中移除该属性。用for/in循环可以证明两者区别，它只能枚举出来被设定为undefined的属性，不能枚举已删除的属性。</p><h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2. 构造函数"></a>2. 构造函数</h3><p>在javascript中，使用new运算符和预定义的构造函数（Date(),Object(),Function()等）可以创建并初始化一个对象。</p><p>要创建已经定义了属性的对象，需要编写一个构造函数在新的对象中创建并初始化这些属性。构造函数是具有2个特性的javascript函数：</p><ul><li>由new运算符调用</li><li>传递给它的是对一个新创建的空对象的引用，将该引用作为关键字this的值，而且还要对新创建的对象进行初始化</li></ul><p>如下例子说明如何定义并调用Rectangle对象的构造函数<br>Rectangle对象的构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/定义构造函数</span><br><span class="line"><span class="comment">//注意如何初始化this引用的对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">w,h</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.width = w;</span><br><span class="line">    <span class="built_in">this</span>.height = h;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用构造函数创建2个Rectangle对象</span></span><br><span class="line"><span class="comment">//注意把宽和高传递给构造函数，这样就能初始化对象</span></span><br><span class="line"><span class="keyword">var</span> rect1 = <span class="keyword">new</span> Rectangle(<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">var</span> rect2 = <span class="keyword">new</span> Rectangle(<span class="number">8</span>,<span class="number">9</span>);</span><br></pre></td></tr></table></figure><p>构造函数只是初始化了对象，并不返回这个对象。构造函数通常没有返回值，只是初始化由this值传递进来的对象。<br>但是，构造函数可以返回一个对象值，如果这样做，被返回的对象就成了new表达式的值，this所引用的对象就被丢弃了。</p><h3 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h3><p>所谓方法（method）就是通过对象调用的javascript函数。函数就是数值，可以将函数赋值给任何变量，设置对象的属性。如果一个函数f和一个对象o，可以定义一个名为m的方法：o.m = f;<br>定义m方法之后可以通过o.m()调用它。</p><p>方法有一个重要的属性，即函数主体内部，关键字this变成了调用该方法的对象。例如，在o.m()中，主体可以使用关键字this来引用对象o.</p><p>任何一个用作方法的函数都会得到一个额外的实际参数，即调用该方法的对象。</p><p>由于方法通常是对对象执行某种操作，要表达函数作用于对象，最好采用方法的调用的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rect.setSize(width,height);</span><br><span class="line">setRectSize(rect, width, height);</span><br></pre></td></tr></table></figure><p>虽然这两行代码都是对对象做同样的操作，但第一行采用方法的调用语法。表达rect是操作的焦点。</p><p>虽然有区别地对特函数和方法比较有用，但实际上它们之间的差别井没有最初时那么大了。<br>回忆一下，函数是储存在变量中的值，而那个变量也不过是全局对象的一个属性。因此，当你调用一个函数时，实际上调用的是全局对象的一个方法。<br>在这样的函数中，关键字this引用的是全局对象。所以在函数和方法之间井设有件么技术上的差别。<br>真正的差别存在于设计和目的上，方法是用来对上this对象进行操作的，而函数通常是独立的，并不需要使用this对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例8-2方法的定义和调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compute_area</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.width * <span class="built_in">this</span>.height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> page = <span class="keyword">new</span> Rectangle(<span class="number">9</span>,<span class="number">88</span>);</span><br><span class="line">page.area = compute_area; <span class="comment">//通过把函数赋予对象的属性，来定义一个方法。</span></span><br><span class="line"><span class="keyword">var</span> a = page.area();</span><br></pre></td></tr></table></figure><p>在例8-2中有一个明显的缺点，那就是在调用rect对象的方法area()之前，必须先将该方法赋给rect对象的一个属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">例<span class="number">8</span>-<span class="number">3</span> 用构造函数定义方法</span><br><span class="line"><span class="comment">//首页定义一些函数，它们将被用作方法。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle_area</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>.width * <span class="built_in">this</span>.height; &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle_perimeter</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">2</span>*<span class="built_in">this</span>.width + <span class="number">2</span>*<span class="built_in">this</span>.height; &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle_set_size</span>(<span class="params">w,h</span>) </span>&#123; <span class="built_in">this</span>.width = w; <span class="built_in">this</span>.height = h; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为Rectangle对象定义一个构造函数，不仅要初始化属性还要给方法赋值。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">w,h</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//初始化对象的属性</span></span><br><span class="line">    <span class="built_in">this</span>.width = w;</span><br><span class="line">    <span class="built_in">this</span>.height = h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义对象的方法</span></span><br><span class="line">    <span class="built_in">this</span>.area = Rectangle;</span><br><span class="line">    <span class="built_in">this</span>.perimeter = Rectangle_perimeter;</span><br><span class="line">    <span class="built_in">this</span>.set_size = Rectangle_set_size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一旦创建Rectangle对象，就可以直接调用它的方法</span></span><br><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> Rectangle(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> a = r.area();</span><br><span class="line"><span class="keyword">var</span> p = r.perimeter();</span><br></pre></td></tr></table></figure><p>例8-3说明的方法还是有缺点，构造函数Rectangle()要对它所有属性都进行设置。由于每个属性都占用一定内存空间，所以给每个Rectangle类添加方法，内存占用就会增加。</p><h3 id="4-原型对象和继承"><a href="#4-原型对象和继承" class="headerlink" title="4.原型对象和继承"></a>4.原型对象和继承</h3><p>我们已经知道，用构造函数把方法赋予它要初始化的对象效率低下。<br>javascript对象都继承原型对象的属性。每个对象都有原型对象，原型对象的所有属性都是以它为原型的对象的属性。也就是说，每个对象都继承原型对象的所有属性。</p><p>一个对象的原型是由创建并初始化该对象的构造函数定义的。<br>javascript中所有函数都有prototype属性，它引用了一个对象。虽然原型对象初始化是空的，但你在其中定义的任何属性都会被该构造函数创建的所有对象继承。<br>因为原型对象的属性被一个类的所有对象共享，所有通常只用它们来定义类中所有相同的属性。这使得原型对象适用于方法定义，另外原型属性还适合于那些具有常量值的属性定义。</p><h4 id="4-1-原型和内部类"><a href="#4-1-原型和内部类" class="headerlink" title="4.1 原型和内部类"></a>4.1 原型和内部类</h4><p>不只是用户定义的类具有原型对象，像String和Date这样的内部类同样具有原型对象，也可以给它们赋值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.endsWith = <span class="function"><span class="keyword">function</span>(<span class="params">c</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (c == <span class="built_in">this</span>.charAt(<span class="built_in">this</span>.length - <span class="number">1</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> message = “hello world”;</span><br><span class="line">message.endsWith(‘h’); <span class="comment">//false</span></span><br><span class="line">message.endsWith(‘d’); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="5-面向对象的javascript"><a href="#5-面向对象的javascript" class="headerlink" title="5. 面向对象的javascript"></a>5. 面向对象的javascript</h3><p>javascript采取以原型对象为基础的继承机制，而不是采取类为基础的继承机制。</p><h4 id="5-1-实例的属性"><a href="#5-1-实例的属性" class="headerlink" title="5.1 实例的属性"></a>5.1 实例的属性</h4><p>每个对象都有它自己单独的属性副本。如果有10个给定的类的对象，那么每个实例属性就有10个副本。<br>在默认情况下，javascript对象的属性都是实例属性，但是为了更真实的模拟面向对象的设计语言，我们说javascript的实例属性都是在对象中用构造函数创建的或初始化的属性。</p><h4 id="5-2-实例方法"><a href="#5-2-实例方法" class="headerlink" title="5.2 实例方法"></a>5.2 实例方法</h4><p>实例方法和实例属性十分相似，只不过是方法而不是数值。实例方法由特定方法和实例对象调用的。<br>实例方法使用了this来引用它们要操作的对象或实例。虽然类的任何实例都可以调用实例方法，但是并不意味着每个对象都像实例属性那样含有自己专有的方法副本。相反，每个实例方法都是由类的所有实例所共享的。<br>在javascript中，给类定义一个实例方法，是通过把构造函数的原型对象的一个属性设置为函数值来实现的。</p><h4 id="5-3-类属性"><a href="#5-3-类属性" class="headerlink" title="5.3 类属性"></a>5.3 类属性</h4><p>在Java中，类属性是和类相关联的的变量。而不是和类的每个实例相关联的变量。无论类创建多少个实例，每个类属性就只有一个副本。就像实例属性是通过实例存取一样，类属性是通过类存取的。在javascript中，Number.MAX_VALUE就是类属性的一个例子，因为MAX_VALUE就是通过类Number存取的.</p><h4 id="5-4-类方法"><a href="#5-4-类方法" class="headerlink" title="5.4 类方法"></a>5.4 类方法</h4><p>类方法是一个与类关联的一起的方法，而不是和类的实例关联在一起的方法。要调用类方法就必须使用类本身，而不能使用类的实例。方法Date.parse()就是一个类方法。和类属性一样，类方法是全局性的。<br>因为类方法不是对特定对象进行操作的所以类方法更容易被认为是由类调用的函数。在javascript中，要定义一个类方法，只需要用合适的函数作为构造函数的属性即可。</p><h4 id="5-5-例子，类Circle"><a href="#5-5-例子，类Circle" class="headerlink" title="5.5 例子，类Circle()"></a>5.5 例子，类Circle()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义构造函数本身</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.r = radius;</span><br><span class="line">    <span class="comment">//r是构造函数定义并初始化的一个实例属性</span></span><br><span class="line">&#125;</span><br><span class="line">Circle.PI = <span class="number">3.14159</span>;<span class="comment">//定义类属性，是构造函数的一个属性</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cricle_area</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Circle.PI * <span class="built_in">this</span>.r * <span class="built_in">this</span>.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Circle.prototype.area = Cricle_area();<span class="comment">//通过把函数赋给构造函数的原型对象来定义一个实例方法。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle_max</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.r &gt; b.r) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line">Circle.max = Circle_max;<span class="comment">//将函数赋给构造函数的属性，使之成为类方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Circle(<span class="number">1.0</span>);<span class="comment">//创建Circle类的一个实例</span></span><br><span class="line">c.r = <span class="number">2.2</span>; <span class="comment">//修改类实例属性值</span></span><br><span class="line"><span class="keyword">var</span> a = c.crea(); <span class="comment">//调用实例方法</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> Circle(<span class="number">1.2</span>);</span><br><span class="line"><span class="keyword">var</span> bigger = Circle.max(c,d); <span class="comment">//调用类方法</span></span><br></pre></td></tr></table></figure><h4 id="5-6-例子，类Complex复数"><a href="#5-6-例子，类Complex复数" class="headerlink" title="5.6 例子，类Complex复数"></a>5.6 例子，类Complex复数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">复数就是一个实数和一个虚数的和</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 定义类的第一步就是定义该类的构造函数</span></span><br><span class="line"><span class="comment">* 这个构造函数要初始化对象的所有实例属性</span></span><br><span class="line"><span class="comment">* 这些属性是核心的状态变量，是它们使每个类实例不同</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Complex</span>(<span class="params">real, imaginary</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.x = real;<span class="comment">//复数的实数部分</span></span><br><span class="line">    <span class="built_in">this</span>.y = imaginary; <span class="comment">//复数的虚数部分</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 定义类的第二部是在构造函数的原型对象定义他的实例方法（或属性）</span></span><br><span class="line"><span class="comment">* 该对象定义的任何属性都被类的实例所继承</span></span><br><span class="line"><span class="comment">* 返回复数的大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Complex.prototype.maginary = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(<span class="built_in">this</span>.x * <span class="built_in">this</span>.x,<span class="built_in">this</span>.y * <span class="built_in">this</span>.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回复数的相反数</span></span><br><span class="line">Complex.prototype.negative = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Complex(-<span class="built_in">this</span>.x, -<span class="built_in">this</span>.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将Complex对象转化成一个字符串</span></span><br><span class="line">Complex.prototyoe.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&quot;</span>+ <span class="built_in">this</span>.x+<span class="string">&#x27;,&#x27;</span>+<span class="built_in">this</span>.y+<span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个复数的实数部分</span></span><br><span class="line">Complex.prototyoe.valueOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 定义类的第二部是定义类方法</span></span><br><span class="line"><span class="comment">* 常量和其他必要属性作为构造函数的属性而不是构造函数原型对象的属性</span></span><br><span class="line"><span class="comment">* 注意，类方法没有使用this关键字，因为它们只对实际参数进行操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Complex.add = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Complex(a.x+b.x,a.y+b.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex.subtract = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Complex(a.x-b.x,a.y-b.y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 下面是预定义复数</span></span><br><span class="line"><span class="comment">* 被定义为类属性，可以被用作常量，实际上并不是只读的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Complex.zero = <span class="keyword">new</span> Complex(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">Complex.one = <span class="keyword">new</span> Complex(<span class="number">1</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="5-7-超类和子类"><a href="#5-7-超类和子类" class="headerlink" title="5.7 超类和子类"></a>5.7 超类和子类</h4><p>在javascript中，类Object是最通用的类，其他所有类都是专用化了的类，或者说是Object的子类。<br>另一种解释就是Object是所有内部类的超类。所有类都继承类Object的基本方法。<br>对象从他的构造函数的原型对象中继承属性，原型对象本身就是一个对象，由构造函数Object()创建。这就意味着原型对象继承了Object.prototype属性，因此类Complex就继承了Complex.prototype的属性，而后者又继承了Object.prototype属性。因此，Complex继承了两个对象的属性，在Complex中查询某个属性时，首先查询这个对象本身，如果没有查询到，就查询Complex.prototype的对象，如果还未查询到，就查询Object.prototype对象。</p><h3 id="6-对象的属性和方法"><a href="#6-对象的属性和方法" class="headerlink" title="6. 对象的属性和方法"></a>6. 对象的属性和方法</h3><p>在javascript中，所有对象都是Object类创建而来，虽然一些专用的类比如String和用户自定义的类Complex都定义了自己的属性和方法，但是都支持Object类定义的属性和方法。</p><h4 id="6-1-constructor属性"><a href="#6-1-constructor属性" class="headerlink" title="6.1 constructor属性"></a>6.1 constructor属性</h4><p>每个对象都有constructor属性，它引用的是初始化该对象的构造函数，例如用构造函数Complex创建类一个对象o，那么o.constructor引用的就是Complex，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> Complex(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">o.constructor == Complex;</span><br></pre></td></tr></table></figure><h4 id="6-2-toString方法"><a href="#6-2-toString方法" class="headerlink" title="6.2 toString方法"></a>6.2 toString方法</h4><p>方法toString没有任何实际参数，它返回的是一个字符串，该方法返回的是调用它的对象的类型或值。当使用“+”运算符把一个字符串和一个对象连接一起或把一个对象传递给alert()或document.write()时，会调用toString方法。</p><p>由类Object定义的默认的toString方法揭示了有关内置对象的内部类型信息。<br>默认的toString方法返回的字符串形式总是[object class]，class是对象的内部类型，通常对应于该对象的构造函数名。例如，Array对像的class值是Array，Function对象的class值是“Function”，Date对象的class值是“Date”，内部Math对象的class值是“Math”，所有Error对象的的class值是“Error”，用户定义的对象（例如Complex）的class值是“Object”。</p><h4 id="6-3-toLocaelString方法"><a href="#6-3-toLocaelString方法" class="headerlink" title="6.3 toLocaelString方法"></a>6.3 toLocaelString方法</h4><p>除了toString外，Object类还定义了toLocaleString方法，该方法返回该对象局部化的字符串表示。Object类默认定义的toLocaelString方法，本身并不做任何局部化，返回值和toString一样。但是Object的子类可以定义自己的toLocaleString方法，Array，Number,Date都定义了自己的toLocaelString方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let now &#x3D; new Date();</span><br><span class="line">now.toString()</span><br><span class="line">&quot;Fri Jan 08 2021 14:05:09 GMT+0800 (中国标准时间)&quot;</span><br><span class="line">now.toLocaleString()</span><br><span class="line">&quot;2021&#x2F;1&#x2F;8 下午2:05:09&quot;</span><br><span class="line"></span><br><span class="line">let num &#x3D; new Number(1);</span><br><span class="line">num.toString()</span><br><span class="line">&quot;1&quot;</span><br><span class="line">num.toLocaleString()</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure><h4 id="6-4-valueOf方法"><a href="#6-4-valueOf方法" class="headerlink" title="6.4 valueOf方法"></a>6.4 valueOf方法</h4><p>valueOf方法和toString方法非常相似，当需要把对象转化为非字符串之外的原始类型（通常是数字）时，就需要调用它。这个函数返回的是能代表this关键字所引用的对象的值的类型。</p><p>由于对象没有定义为原始类型的值，所以大多数对象都没有等价的原始值，因此由Object定义的valueOf方法不执行任何转换，只是返回调用它的对象。像Number和Boolean这样的类具有明显的原始等价值。</p><p>有时你可以定义一个合理的原始等价类型的类，需要为类定义一个valueOf方法，例如Complex，就定义了一个valueOf方法，返回实数部分。定义valueOf方法时，当某些环境中，当执行对象转字符串时，方法valueOf的优先级比toString高，这样当你定义了一个valueOf方法时，如果想转为字符串需要明确的调用toString方法，以Complex为例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Complex(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">alert(“c”+c);<span class="comment">//调用valueOf方法显示“c=3”</span></span><br><span class="line">alert(“c”+c.toString);<span class="comment">//显示“c=&#123;3,3&#125;”</span></span><br></pre></td></tr></table></figure><h4 id="6-5-hasOwnProperty"><a href="#6-5-hasOwnProperty" class="headerlink" title="6.5 hasOwnProperty"></a>6.5 hasOwnProperty</h4><p>如果对象局部定义了一个非继承的属性，属性名是由字符串实际参数指定的，那么该值返回true，否则返回false，例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.hasOwnProperty(“unde”);<span class="comment">//false</span></span><br><span class="line">o.hasOwnProperty(“toString”);<span class="comment">//false,toString 是一个继承属性</span></span><br><span class="line"><span class="built_in">Math</span>.hasOwnProperty(“cos”);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="6-6-propertyIsEnumerable-方法"><a href="#6-6-propertyIsEnumerable-方法" class="headerlink" title="6.6 propertyIsEnumerable()方法"></a>6.6 propertyIsEnumerable()方法</h4><p>如果对象定义了一个属性，由字符串实际参数指定的，而且该属性可以用for/in遍历出来，那么该方法返回true，否则返回false，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">x</span>:<span class="number">1</span>&#125;;</span><br><span class="line">o.propertyIsEnumerable(“x”); <span class="comment">//true</span></span><br><span class="line">o.propertyIsEnumerable(“y”); <span class="comment">//false</span></span><br><span class="line">o.propertyIsEnumerable(“valueOf”); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>ECMAScript标准规定该方法只考虑对象直接定义的属性，不考虑对象的继承属性。</p><h4 id="6-7-isPrototypeOf方法"><a href="#6-7-isPrototypeOf方法" class="headerlink" title="6.7 isPrototypeOf方法"></a>6.7 isPrototypeOf方法</h4><p>如果调用对象是实际参数指定对象的原型对象，那么返回true，否则返回false，该方法用途和constructor属性相似：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(o);<span class="comment">//true  o.constructor == Object</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.isPrototypeOf(<span class="built_in">Object</span>); <span class="comment">//true  Object.constructor == Function</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-第七章-函数</title>
      <link href="/ZJY.github.io/2021/01/13/javascript-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%87%BD%E6%95%B0/"/>
      <url>/ZJY.github.io/2021/01/13/javascript-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="第七章-函数"><a href="#第七章-函数" class="headerlink" title="第七章-函数"></a>第七章-函数</h2><h3 id="1-函数定义和调用"><a href="#1-函数定义和调用" class="headerlink" title="1. 函数定义和调用"></a>1. 函数定义和调用</h3><p>定义函数最常用方法是function语句，该语句由function关键字构成，后面跟：</p><ul><li>函数名</li><li>一个括号括起来的参数列表，参数可选，多个参数用逗号分隔</li><li>构成函数主体的javascript语句，大括号括起来</li></ul><p>定义函数时可以使用个数可变的参数，而且函数既可以有return语句，也可以没有return语句，return语句使函数停止运行，并把结果返回给函数调用者。如果没有return语句，返回给调用者undefined.</p><h3 id="1-1-嵌套的函数"><a href="#1-1-嵌套的函数" class="headerlink" title="1.1 嵌套的函数"></a>1.1 嵌套的函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    funtion <span class="function"><span class="title">add</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> add(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-Function构造函数"><a href="#1-2-Function构造函数" class="headerlink" title="1.2 Function构造函数"></a>1.2 Function构造函数</h3><p>function语句并不是创建函数的唯一方式，在ECMAScript v1和javascript 1.1中还可以使用Function()构造函数和new运算符。<br>var f = new Function(“x”,”y”,”return x*y;”)<br>Function构造函数可以接收任意数量参数，最后一个参数是函数主体，没有参数可只传函数主体字符串参数。</p><h3 id="1-3-函数直接量"><a href="#1-3-函数直接量" class="headerlink" title="1.3 函数直接量"></a>1.3 函数直接量</h3><p>函数直接量是一个表达式，可以定义一个匿名函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">funtion <span class="function"><span class="title">f</span>(<span class="params">x,y</span>)</span>&#123;<span class="keyword">return</span> x*y；&#125; <span class="comment">//function语句</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Function</span>(“x”,”y”,”<span class="keyword">return</span> x*y;”)   <span class="comment">//Function构造函数</span></span><br><span class="line"><span class="keyword">var</span>  f = <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>) </span>&#123; <span class="keyword">return</span> x*y; &#125; <span class="comment">//函数直接量</span></span><br></pre></td></tr></table></figure><p>虽然函数直接量定义的是未命名函数，但也可以指定名称，在递归函数非常有用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = funtion <span class="function"><span class="title">fact</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x*fact(x-<span class="number">1</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码虽然定义了一个未命名函数，并把对他引用存储在变量f中，但并没有真正创建一个fact函数，只允许用这个名称引用自身</p><p>和Function构造函数一样，函数直接量创建的是匿名函数，而且不会自动地将这个函数存储在属性中。但是比起构造函数来，函数直接量又一个明显的优点。由Function构造函数创建的函数的主体，必须用一个字符串说明，用这种方式表达一个长而复杂的函数是非常笨拙的。<br>但是函数直接量的主体确是使用了javascript的语法。而且函数直接量只被解析和编译一次，而作为字符串传递给Function()函数的javascript代码则在每次调用该构造函数时只需被解析和编译一次。</p><h3 id="2-作为数据的函数"><a href="#2-作为数据的函数" class="headerlink" title="2. 作为数据的函数"></a>2. 作为数据的函数</h3><p>除了作为变量的值，还可以作为对象的属性，称为方法</p><h3 id="3-函数的作用域：调用对象"><a href="#3-函数的作用域：调用对象" class="headerlink" title="3. 函数的作用域：调用对象"></a>3. 函数的作用域：调用对象</h3><p>javascript函数的主体是在局部作用域中执行的，这个作用域通过把调用对象添加到作用域的头部创建的。<br>因为调用对象是作用域链的一部分，所以在函数体内可以把这个对象属性作为变量来访问。<br>var语句声明的变量作为调用对象的属性，函数形参也可用于对象的属性。</p><p>除了局部变量和形式参数外，调用对象还定义了一个属性：arguments，这个属性引用了另外一个Arguments对象。arguments应作为保留字。</p><h3 id="4-函数的实际参数：Arguments对象"><a href="#4-函数的实际参数：Arguments对象" class="headerlink" title="4. 函数的实际参数：Arguments对象"></a>4. 函数的实际参数：Arguments对象</h3><p>在一个函数体内，标识符arguments具有特殊含义。他是调用对象的一个属性，用来引用Arguments对象。Arguments对象就像一个数组，可以通过数字获取传递给函数的参数值。<br>但它并非真正但Array对象。用参数名改变参数值也会改变通过arguments[]取的值。</p><h4 id="4-1-属性callee"><a href="#4-1-属性callee" class="headerlink" title="4.1 属性callee"></a>4.1 属性callee</h4><p>除了数组元素，arguments对象还定义了callee属性。用来引用当前正在执行的函数。对未命名的函数非常有用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="built_in">arguments</span>.callee(x-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-函数的属性和方法"><a href="#5-函数的属性和方法" class="headerlink" title="5. 函数的属性和方法"></a>5. 函数的属性和方法</h3><p>在javascript程序中，函数可以用作数值，也可以通过Function()构造函数创建函数，所以函数是对象，Function对象，拥有属性和方法。</p><h4 id="5-1-属性length"><a href="#5-1-属性length" class="headerlink" title="5.1 属性length"></a>5.1 属性length</h4><p>在函数主体中，arguments数组的length属性指定了函数实际参数数目。<br>但是函数自身的length属性并非如此，它是只读特性，返回的是函数形式参数列表中声明的形式参数的数目。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = args.length; <span class="comment">//实际的参数个数</span></span><br><span class="line">    <span class="keyword">var</span> actualLen = args.callee.length <span class="comment">//声明的参数个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-属性prototype"><a href="#5-2-属性prototype" class="headerlink" title="5.2 属性prototype"></a>5.2 属性prototype</h4><p>每个函数都有一个prototype属性，引用的是预定义的原型对象。原型对象在使用new运算符把函数作为构造函数时起作用。它在定义新的对象类型时起着非常重要的作用。</p><h4 id="5-3-定义你自己的函数属性"><a href="#5-3-定义你自己的函数属性" class="headerlink" title="5.3 定义你自己的函数属性"></a>5.3 定义你自己的函数属性</h4><p>当函数需要在调用过程中始终不变的一个值时，使用Function对象的属性比定义一个全局变量更加方便。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test.counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> test.counter++;</span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">//0</span></span><br><span class="line">test(); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><h4 id="5-4-方法apply-和call"><a href="#5-4-方法apply-和call" class="headerlink" title="5.4 方法apply()和call()"></a>5.4 方法apply()和call()</h4><p>所有函数都定义了apply()和call()方法。<br>第一个参数都是要调用的函数对象，在函数体内这个关键词是this的值。<br>call()的剩余参数是传递给调用函数的值，例如要把两个数字传递给函数f，并把它作为对象o的方法调用，可以使用如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.call(o, <span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>apply()要传递的参数是一个数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.apply(o, [<span class="number">1</span>, <span class="number">2</span>]);</span><br></pre></td></tr></table></figure><p>比如要找到数字数组中最大值，可以用apply方法把数组传递给Math.max:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> biggest = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, array_number);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-第六章-语句</title>
      <link href="/ZJY.github.io/2021/01/13/javascript-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%AF%AD%E5%8F%A5/"/>
      <url>/ZJY.github.io/2021/01/13/javascript-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="第六章-语句"><a href="#第六章-语句" class="headerlink" title="第六章-语句"></a>第六章-语句</h2><h3 id="1-表达式语句"><a href="#1-表达式语句" class="headerlink" title="1. 表达式语句"></a>1. 表达式语句</h3><p>递增（++）和递减（–）运算符，delete运算符，函数调用，被作为语句使用，因为都改变了值，而不仅仅是表达式的一部分。</p><h3 id="2-复合语句"><a href="#2-复合语句" class="headerlink" title="2. 复合语句"></a>2. 复合语句</h3><p>复合语句就是用花括号括起来，将几个语句联合起来形成语句块。js语句可以包含别的语句，这样的语句叫复合语句。<br>正式的javascript语法规定每个复合语句可以包含一个子语块。那么使用语句块可以将任意数量语句放在子语块中。<br>javascript解释器执行复合语句时，按照编写顺序执行语句。通常javascript语句会执行完所有语句，但复合语句中若含有break语句、continue语句、return或throw语句，或它引发了错误等会被终止。</p><h3 id="3-if语句"><a href="#3-if语句" class="headerlink" title="3. if语句"></a>3. if语句</h3><p>条件控制语句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(express) <span class="comment">//null、undefined、0、“”、NaN值为false</span></span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><h3 id="4-else-if语句"><a href="#4-else-if语句" class="headerlink" title="4. else if语句"></a>4. else if语句</h3><p>用来执行多个条件语句，实际上是if/else嵌套</p><h3 id="5-switch语句"><a href="#5-switch语句" class="headerlink" title="5. switch语句"></a>5. switch语句</h3><p>用于重复检测同一个变量的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(express)&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span>(n)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        statement</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        statement</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数调用中可以用return替换break语句.<br>case使用===等同运算符匹配的，如果没有匹配值就执行default:，如果没有default：就跳过主体，default:语句可以放置任何位置。</p><h3 id="6-while语句"><a href="#6-while语句" class="headerlink" title="6. while语句"></a>6. while语句</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(express)</span><br><span class="line">    statement</span><br><span class="line">    <span class="comment">//express表达式值为true，执行statement循环体</span></span><br></pre></td></tr></table></figure><h3 id="7-do-while语句"><a href="#7-do-while语句" class="headerlink" title="7. do/while语句"></a>7. do/while语句</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">while</span>(express);</span><br></pre></td></tr></table></figure><p>循环体至少会被执行一次。用分号结尾.</p><h3 id="8-for语句"><a href="#8-for语句" class="headerlink" title="8. for语句"></a>8. for语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(initalize; test ; increment) &#x2F;&#x2F;初始化、检测、更新</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><h3 id="9-for-in语句"><a href="#9-for-in语句" class="headerlink" title="9. for/in语句"></a>9. for/in语句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(variable in object)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><p>variable是一个变量名，声明一个变量的var语句或者对象的一个属性或者数组的一个元素。</p><p>object是一个对象名或者计算结果为对象的表达式。for/in循环主体对object对象对每个属性执行一次，循环体执行之前，对象的属性名会被作为字符串赋值给variable.在循环体内部可以通过object[varible]访问属性的值    。variable可以是任意表达式。</p><p>for/in循环体并没有指定将对象属性赋给循环变量的顺序。for/in会遍历对象所有可能属性。对象属性被标记不可枚举的不可被遍历出来。</p><h3 id="10-标签语句"><a href="#10-标签语句" class="headerlink" title="10. 标签语句"></a>10. 标签语句</h3><p>identifier：statement，标签语句：标识符加冒号<br>标识符identifier可以是合法的js标识符，不能是保留字，标识符不同于变量名和函数名，所以不用担心重名。给语句添加标识符，起一个名字可以在任意地方引用。</p><h3 id="11-break语句"><a href="#11-break语句" class="headerlink" title="11. break语句"></a>11. break语句</h3><p>break语句会使包含在最内层的循环体立即结束或退出switch语句。语句很简单：<br>    break;<br>当break后面跟标签时，它会跳到标签语句结尾或者终止这个语句。break labelname；</p><h3 id="12-continue语句"><a href="#12-continue语句" class="headerlink" title="12. continue语句"></a>12. continue语句</h3><ul><li><p>continue语句退出当前循环，执行下一次循环，continue;</p></li><li><p>continue语句可以和标签一起使用在ecmascript v3和js1.2中，continue labelname;</p></li><li><p>continue语句只可以出现在while、for、do/while、for/in循环语句体中。<br>执行continue语句时，当前迭代就会终止，开始下一次迭代，这对不同循环是不同的：</p><ul><li>while循环中，会再次检测循环条件，如果是true，继续下一次迭代</li><li>do/while循环中，会跳到循环的底部，开始下一次迭代前首先判断循环条件</li><li>for循环中，会先更新循环变量值，再判断循环条件是否继续下一次迭代</li><li>for/in循环中，以下一个循环属性赋值给变量开始新的迭代</li></ul></li></ul><h3 id="13-var语句"><a href="#13-var语句" class="headerlink" title="13. var语句"></a>13. var语句</h3><p>var语句允许你明确的声明一个或多个变量。如果声明多个变量，用逗号隔开，并可选的初始化声明的变量值。</p><p>var语句通过在封闭函数的调用对象中创建同名的属性来定义变量，如果不在函数内，就在全局对象中创建同名属性来定义变量。</p><p>由var语句创建的特性不能被delete运算符删除。</p><h3 id="14-function语句"><a href="#14-function语句" class="headerlink" title="14. function语句"></a>14. function语句</h3><p>function语句定义了js函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcname</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数体内语句定义时不会被执行，在使用函数调用（）运算符调用时才执行编译。<br>函数定义在解析时发生而不是在运行时发生。<br>函数定义通常出现在代码顶层，它们也可以嵌套在其他函数定义中，但是只能嵌套在函数顶层定义中，也就是说函数定义不能出现在if语句，while循环或其他语句中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(f(<span class="number">4</span>)); <span class="comment">//16，可以在定义f()前调用它</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="number">0</span>; <span class="comment">//该语句重写属性f</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;<span class="keyword">return</span> x*x&#125;</span><br><span class="line">alert(f); <span class="comment">//0，函数f已经被变量f覆盖</span></span><br></pre></td></tr></table></figure><h3 id="15-return语句"><a href="#15-return语句" class="headerlink" title="15. return语句"></a>15. return语句</h3><p>运算符()调用函数是一个表达式，表达式的值通过return语句返回。return只能出现在函数体内，出现在其他地方会造成语法错误。return expression;<br>在执行return语句时，会先计算表达式的值，然后返回它的值作为函数的值</p><h3 id="16-throw语句"><a href="#16-throw语句" class="headerlink" title="16. throw语句"></a>16. throw语句</h3><p>所谓异常（exception）就是一个信号，说明发生了某种异常状况或错误。<br>抛出（throw）一个异常，就是用信号通知发生了错误或异常状况。<br>捕获（catch）一个异常就是处理它，即采取必要或适当的行为从异常恢复。在js中，当发生了运行时错误或用throw语句就会抛出异常。<br>throw expression;expression可以是任意类型，通常是Error类或子类的实例。<br>在抛出异常时，javascript解释器会立即停止正常的程序执行，跳到距离最近的异常处理器，即catch语句中。<br>如果抛出的异常中没有catch语句，即会检测次高级封闭代码块，查看是否有异常处理器，直到没有找到为止。</p><h3 id="17-try-catch-finally语句"><a href="#17-try-catch-finally语句" class="headerlink" title="17. try/catch/finally语句"></a>17. try/catch/finally语句</h3><p>try/catch/finally是javascript的异常处理机制。<br>try语句定义异常需要被处理的代码块。<br>catch发生异常时调用的语句块。<br>finally存放清除代码，无论try发生什么，都会被执行。<br>catch和finally都是可选的。但是try块至少跟一个catch或finally块。</p><p>通常情况下,控制流到达try块的尾部,然后开始执行 finally块,以便进行清除操作。如果由于 return语句、 continue句或 break语句使控制流离开了try块,那么在控制流转移到新目的地前, finally块就会被执行。</p><p>如果异常发生在try块中,而且存在一个相关的 catch块处理异常,控制流首先将转移到 catch块,然后再转移到fina1l块。如果没有处理异常的局部 catch块,控制流首先将转移到 finally块,然后向上传播到最近的能够处理异常的 catch从句。</p><p>如果 finally块自身用 return语句、 continue语句、 break语句或 throw语句转移了控制流,或者调用了抛出异常的方法改变了控制流,那么等待的控制流转移将被舍弃,并进行新的转移。例如,如果 finally从句抛出了一个异常,那么该异常将代替处于抛出过程中的异常。如果 finally从句运行到了 return语句,那么即使已经抛出了一个异常,而且该异常还没有被处理,该方法也会正常返回。</p><h3 id="18-with语句"><a href="#18-with语句" class="headerlink" title="18. with语句"></a>18. with语句</h3><p>with语句用于暂时修改作用域链。with (object) statement<br>这一语句能够有效的将object添加到作用域链的顶部，然后执行statement语句，再把作用域链恢复到初始状态。<br>在实际应用中,使用with语句可以减少大量的输入。例如,在客户端的 JavaScript中,深度嵌套的对象层次很常用。例如,可以输入如下的表达式来访问一个HTML表单的元素:</p><p> frames[1].document.forms[0].address.value</p><p>如果需要多次访问这个表单,可以使用with语句将这个表单添加到作用域链中:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">with</span>(<span class="params">frames [<span class="number">1</span>].<span class="built_in">document</span>.forms[<span class="number">0</span>]</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//此处直接访问表单元素</span></span><br><span class="line">    name.value = ‘’;</span><br><span class="line">    address.value = ‘’;</span><br><span class="line">    email.value = ‘’;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然有时使用with语句比较方便,但是人们反对使用它。使用了with语句的javaScript代码很难优化,因为它的运行速度比不使用with语句的等价代码要慢得多。而且,在with语句中的函数定义和变量初始化可能会产生令人惊讶的、相抵触的行为。因此,我们建议避免使用with语句。</p><p>注意,还有其他的、极为合理的方法可以用来节省输入。例如,上面使用with语句可重写为:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> form= frames[<span class="number">1</span>]. <span class="built_in">document</span>. forms[<span class="number">0</span>]</span><br><span class="line">form.name. value=<span class="string">&quot;</span></span><br><span class="line"><span class="string">form. address. value =&quot;</span><span class="string">&quot; form. email. value =&quot;</span><span class="string">&quot;</span></span><br></pre></td></tr></table></figure><h3 id="19-空语句"><a href="#19-空语句" class="headerlink" title="19. 空语句"></a>19. 空语句</h3><p>javascript中最后一个合法语句是空语句: ;</p><p>执行空语句显然不会产生任何作用,也不会执行任何动作。你可能认为使用这样一个语句是毫无意义的,但实践证明,当你想创建一个具有空主体的循环时,空语句是有用的。例如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化数组a</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt; a. length; a[i++] =<span class="number">0</span>) ;</span><br></pre></td></tr></table></figure><p>注意,在for循环、 while循环或者if语句的右括号后加分号会产生bug,这些bug很难被检测出来。例如,下面的代码产生的结果并不是作者想要的:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((a==<span class="number">0</span>) || (b==<span class="number">0</span>));/这行什么都不做</span><br><span class="line">o =<span class="literal">null</span>; <span class="comment">//这行总会被执行</span></span><br></pre></td></tr></table></figure><p>当你打算使用空语句时,最好在代码中使用注释,以清楚地说明是有目的地这样做。例如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;a. length;a[i++]=<span class="number">0</span>)<span class="comment">/*空函数体*/</span> ;</span><br></pre></td></tr></table></figure><h3 id="20-javascript语句小结"><a href="#20-javascript语句小结" class="headerlink" title="20.javascript语句小结"></a>20.javascript语句小结</h3><table><thead><tr><th align="center">语句</th><th align="center">语法</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">break</td><td align="center">break; <br> break labelname;</td><td align="center">退出最内层循环或者退出switch语句，又或者退出label指定的语句</td></tr><tr><td align="center">case</td><td align="center">case expression</td><td align="center">在switch语句中标记一个语句</td></tr><tr><td align="center">continue</td><td align="center">continue;<br>  continue labelname;</td><td align="center">重新开始新的循环或开始指定的label循环</td></tr><tr><td align="center">default</td><td align="center">default:</td><td align="center">在switch语句中指定默认语句</td></tr><tr><td align="center">do/while</td><td align="center">do statement <br> while(expression)</td><td align="center">while循环另一种形式</td></tr><tr><td align="center">空语句</td><td align="center">;</td><td align="center">什么都不做</td></tr><tr><td align="center">for</td><td align="center">for(init;test;increment) statement</td><td align="center">循环</td></tr><tr><td align="center">for/in</td><td align="center">for(variable in object) statement</td><td align="center">遍历一个对象的属性</td></tr><tr><td align="center">function</td><td align="center">function funname(expression){statement}</td><td align="center">函数声明</td></tr><tr><td align="center">if/else</td><td align="center">if(expression){statement} <br> else{}</td><td align="center">条件控制</td></tr><tr><td align="center">label</td><td align="center">identifier: statement</td><td align="center">给语句块指定一个标识符</td></tr><tr><td align="center">return</td><td align="center">return expression</td><td align="center">返回函数值</td></tr><tr><td align="center">switch</td><td align="center">switch(expression){statement}</td><td align="center">由case或default语句标记的多分支语句</td></tr><tr><td align="center">throw</td><td align="center">throw exception</td><td align="center">抛出一个异常</td></tr><tr><td align="center">try</td><td align="center">try{statement} <br> catch(e){statement}<br>  finally{statement}</td><td align="center">捕捉一个异常</td></tr><tr><td align="center">var</td><td align="center">var name1 = value</td><td align="center">声明或初始化变量</td></tr><tr><td align="center">while</td><td align="center">while(expression){statement}</td><td align="center">循环</td></tr><tr><td align="center">with</td><td align="center">with(object) statement</td><td align="center">扩展当前作用域链（不支持使用）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-第五章-表达式和运算符</title>
      <link href="/ZJY.github.io/2021/01/10/javascript-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/ZJY.github.io/2021/01/10/javascript-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="第五章-表达式和运算符"><a href="#第五章-表达式和运算符" class="headerlink" title="第五章-表达式和运算符"></a>第五章-表达式和运算符</h2><h3 id="1-表达式"><a href="#1-表达式" class="headerlink" title="1. 表达式"></a>1. 表达式</h3><p>最简单的表达式可以是直接量或者变量名。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">‘javascript’</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line">num</span><br></pre></td></tr></table></figure><p>直接量表达式的值是直接量本身，变量表达式的值是变量存放的值或引用的值。</p><h3 id="2-运算符概述"><a href="#2-运算符概述" class="headerlink" title="2. 运算符概述"></a>2. 运算符概述</h3><p>有些运算符由标点符号表示+ -，有些是由关键字表示，delete /instanceof</p><table><thead><tr><th align="center">P（运算符优先级）</th><th align="center">A（结合性：L/R）</th><th align="center">运算符</th><th align="center">运算数类型</th><th align="center">所执行的操作</th></tr></thead><tbody><tr><td align="center">15</td><td align="center">L</td><td align="center">.</td><td align="center">对象，标识符</td><td align="center">属性存取</td></tr><tr><td align="center"></td><td align="center">L</td><td align="center">[]</td><td align="center">数组，整数</td><td align="center">数组下标</td></tr><tr><td align="center"></td><td align="center">L</td><td align="center">()</td><td align="center">函数，参数</td><td align="center">函数调用</td></tr><tr><td align="center"></td><td align="center">R</td><td align="center">new</td><td align="center">构造函数调用</td><td align="center">创建新对象</td></tr><tr><td align="center">14</td><td align="center">R</td><td align="center">++</td><td align="center">lvalue</td><td align="center">先递增或后递增的运算（一元的）</td></tr><tr><td align="center"></td><td align="center">R</td><td align="center">–</td><td align="center">lvalue</td><td align="center">先递减或后递减的运算（一元的）</td></tr><tr><td align="center"></td><td align="center">R</td><td align="center">-</td><td align="center">数字</td><td align="center">一元减法（负）</td></tr><tr><td align="center"></td><td align="center">R</td><td align="center">+</td><td align="center">数字</td><td align="center">一元加法）</td></tr><tr><td align="center"></td><td align="center">R</td><td align="center">~</td><td align="center">数字</td><td align="center">按位取补码的操作（一元的）</td></tr><tr><td align="center"></td><td align="center">R</td><td align="center">!</td><td align="center">布尔值</td><td align="center">取逻辑补码的操作（一元的）</td></tr><tr><td align="center"></td><td align="center">R</td><td align="center">delete</td><td align="center">lvalue</td><td align="center">删除一个属性（一元的）</td></tr><tr><td align="center"></td><td align="center">R</td><td align="center">typeof</td><td align="center">任意</td><td align="center">返回数据类型（一元的）</td></tr><tr><td align="center"></td><td align="center">R</td><td align="center">void</td><td align="center">任意</td><td align="center">返回未定义的值（一元的）</td></tr><tr><td align="center">13</td><td align="center">L</td><td align="center">*,/,%</td><td align="center">数字</td><td align="center">乘法，除法， 取余运算</td></tr><tr><td align="center">12</td><td align="center">L</td><td align="center">+,-</td><td align="center">数字</td><td align="center">加法，减法运算</td></tr><tr><td align="center"></td><td align="center">L</td><td align="center">+</td><td align="center">字符串</td><td align="center">连接字符串</td></tr><tr><td align="center">11</td><td align="center">L</td><td align="center">&lt;&lt;</td><td align="center">整数</td><td align="center">左移</td></tr><tr><td align="center"></td><td align="center">L</td><td align="center">&gt;&gt;</td><td align="center">整数</td><td align="center">带符号扩展的右移</td></tr><tr><td align="center"></td><td align="center">L</td><td align="center">&gt;&gt;&gt;</td><td align="center">整数</td><td align="center">带零扩展的右移</td></tr><tr><td align="center">10</td><td align="center">L</td><td align="center">&lt;, &lt;=</td><td align="center">数字或字符串</td><td align="center">小于或小于等于</td></tr><tr><td align="center"></td><td align="center">L</td><td align="center">&gt;, &gt;=</td><td align="center">数字或字符串</td><td align="center">大于或大于等于</td></tr><tr><td align="center"></td><td align="center">L</td><td align="center">instanceof</td><td align="center">对象，构造函数</td><td align="center">检测对象类型</td></tr><tr><td align="center"></td><td align="center">L</td><td align="center">in</td><td align="center">字符串，对象</td><td align="center">检查一个属性是否存在</td></tr><tr><td align="center">9</td><td align="center">L</td><td align="center">==</td><td align="center">任意</td><td align="center">测试相等性</td></tr><tr><td align="center"></td><td align="center">L</td><td align="center">!=</td><td align="center">任意</td><td align="center">测试非相等性</td></tr><tr><td align="center"></td><td align="center">L</td><td align="center">===</td><td align="center">任意</td><td align="center">测试等同性</td></tr><tr><td align="center"></td><td align="center">L</td><td align="center">!==</td><td align="center">任意</td><td align="center">测试非等同性</td></tr><tr><td align="center">8</td><td align="center">L</td><td align="center">&amp;</td><td align="center">整数</td><td align="center">按位与操作</td></tr><tr><td align="center">7</td><td align="center">L</td><td align="center">^</td><td align="center">整数</td><td align="center">按位异或操作</td></tr><tr><td align="center">6</td><td align="center">L</td><td align="center">`</td><td align="center">`</td><td align="center">整数</td></tr><tr><td align="center">5</td><td align="center">L</td><td align="center">&amp;&amp;</td><td align="center">布尔值</td><td align="center">逻辑与操作</td></tr><tr><td align="center">4</td><td align="center">L</td><td align="center">`</td><td align="center"></td><td align="center">`</td></tr><tr><td align="center">3</td><td align="center">R</td><td align="center">？：</td><td align="center">布尔值、任意、任意</td><td align="center">条件运算符</td></tr><tr><td align="center">2</td><td align="center">R</td><td align="center">=</td><td align="center">任意</td><td align="center">赋值运算</td></tr><tr><td align="center"></td><td align="center">R</td><td align="center">*=，/=，%=，+=，-=，&lt;&lt;=,&gt;&gt;=,&gt;&gt;&gt;=,&amp;=,</td><td align="center">=</td><td align="center">任意</td></tr><tr><td align="center">1</td><td align="center">L</td><td align="center"></td><td align="center">任意</td><td align="center">多重计算的操作</td></tr></tbody></table><h4 id="2-1-运算数的个数"><a href="#2-1-运算数的个数" class="headerlink" title="2.1 运算数的个数"></a>2.1 运算数的个数</h4><p>一元运算符: -3 //取反<br>二元运算符： +<br>三元运算符： ?:</p><h4 id="2-2-运算数的优先级"><a href="#2-2-运算数的优先级" class="headerlink" title="2.2 运算数的优先级"></a>2.2 运算数的优先级</h4><p>乘法和除法是优先与加法和减法执行的，赋值的操作优先级很低，几乎最后执行。用括号可以提高优先级。</p><h4 id="2-3-运算数的结合性"><a href="#2-3-运算数的结合性" class="headerlink" title="2.3 运算数的结合性"></a>2.3 运算数的结合性</h4><p>L表示结合性从左到右，R表示结合性从右到左，一个运算符的结合性说明了优先级相等时执行操作的顺序。</p><h3 id="3-算术运算符"><a href="#3-算术运算符" class="headerlink" title="3. 算术运算符"></a>3. 算术运算符</h3><p><b>加法运算符（+）：</b><br>    运算符“+”可以对数字进行加法运算，也可以对字符串进行连接操作。如果一个运算数是字符串，那么另一个运算数会被转换成字符串，进行连接操作。如果“+”运    算符对一个运算数是对象，那么它会把对象转换成可以进行加法运算或者连接操作对数字或字符串，这一转换通过调用对象的valueOf()/toString()来执行的。</p><p><b>减法运算符（-）：</b><br>    把运算符“-”用于二元操作时，它将从第一个运算数减取第二个运算数。如果运算数是非数字的，会将它们转换成数字。</p><p><b>乘法运算符（<em>）：</b><br>    运算符“</em>”会把两个运算数相乘，如果运算数是非数字的，运算符“*”会将它们转换成数字。</p><p><b>除法运算符（/）：</b><br>    运算符“/”将用第一个运算数除以第二个运算数。如果运算数为非数字，则运算符“/”会将它们转为数字。除数为0的结果为正无穷或负无穷。0/0结果为NaN。<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>/<span class="number">0</span> <span class="comment">// Infinity</span></span><br><span class="line">-<span class="number">4</span>/<span class="number">0</span> <span class="comment">//-Infinity</span></span><br><span class="line"><span class="number">0</span>/<span class="number">0</span> <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure><br><b>模运算符（%）：</b><br>    模运算符计算的是第一个运算数对第二个运算数对模，即余数。如果运算数是非数字的，运算符“%”会将它们转换为数字。结果和第一个运算数符号相同。<br>    5%2 // 1<br>    -5%2 //-1<br>    取模运算符也适用于浮点型数字。</p><p><b>一元减法运算符（-）：</b><br>    当“-”被用于一元操作前（一个运算数前），它将执行一元取反操作。如果运算数是非数字的，运算符“-”会将它们转换为数字</p><p><b>一元加法运算符（+）：</b><br>    var a = +10000;”+”什么都没做，只计算参数的值。对于非数字型的运算符，会将运算数转为数字，如果不能被转换，将返回NaN.<br>    +’123’ //123<br>    +’1we’ //NaN</p><p><b>递增运算符（++）：</b><br>    运算符“++”对唯一运算数进行递增操作，如果运算数为非数字，会转为数字。<br>    i = 1; j = ++i;  // i:2,j:2<br>    i = 1; k = i++; //i:2, k:1<br>    如果运算符位于运算数前，即先递增，然后用运算数增长后值计算。<br>    如果运算符位于运算数后，即先运算，后递增，运算的是递增前的值。</p><p><b>递减运算符（–）：</b><br>    运算符“–”是对它惟一的数字运算数进行逆减操作的(如每次减1)，这个运算数必须是一个变量、数组的一个元素或者对象的一个属性。如果该变量元素或属性的值不是数字，运算符“-”首先会将它转换成一个数字。和运算符“++”一样，运算符“-”的实际行为是由它相对于运算数的位置决定的。<br>    如果它位于运算数之前，它就先减少运算数的值，并且返回减少后的运算数的直。如果它位于运算数之后，它将减少运算数的值，但是返回的却是没有减少的值。</p><h3 id="4-相等运算符"><a href="#4-相等运算符" class="headerlink" title="4. 相等运算符"></a>4. 相等运算符</h3><p>相等运算符“==”和等同运算符“===”用于计算两个值是否相等，根据结果返回布尔值。</p><h4 id="4-1-相等运算符（-）和等同运算符（-）"><a href="#4-1-相等运算符（-）和等同运算符（-）" class="headerlink" title="4.1 相等运算符（==）和等同运算符（===）"></a>4.1 相等运算符（==）和等同运算符（===）</h4><p>“==”和“===”都用于检测两个值是否相等。这两个运算符都接受任意类型都运算数。“===”是等同运算符，它采用严格都同一性定义检测两个运算数是否相同。“==”是相等运算符，它采用比较宽松的同一性（允许类型转换）定义检测两个数是否相等。</p><p><b>判断===运算符比较的两个值是否完全相等：</b></p><ul><li><p>如果两个值的类型不同，它们就不相等.</p></li><li><p>如果两个值是数字，而且值相同，那么除非其中一个或两个值都为NaN，否则它们是等同的。值NaN永远不会与其他任何值等同，包括它自身。可用全局函数isNaN（）检测值是否是NaN。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span>==<span class="literal">NaN</span> <span class="comment">//false   NaN===NaN //false</span></span><br></pre></td></tr></table></figure></li><li><p>如果两个值是字符串，而且串中同一位置上字符完全相同，那么它们就是完全等同。如果字符串内容或长度不同，它们就不是等同的。</p></li><li><p>如果两个值都是布尔值true或false，那么它们等同。</p></li><li><p>如果两个值引用的是同一个对象，数组或函数，那么它们完全等同。如果它们引用是不同的对象，即使这两个对象具有完全相同的属性或具有完全相同的元素，它们也不等同。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;;<span class="keyword">var</span> b = a; <span class="keyword">var</span> c = &#123;&#125;; <span class="keyword">var</span> d = c; b == d; <span class="comment">//false</span></span><br></pre></td></tr></table></figure></li><li><p>如果两个值都是null或undefined，那么它们完全相同。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true null === undefined //false </span></span><br></pre></td></tr></table></figure></li></ul><p><b>判断==运算符比较的两个值是否相等：</b></p><ul><li>如果两个值具有相同的类型，判断两个值是否相同，如果相同就相等</li><li>如果两个值类型不同，仍然有可能相等。<ul><li>如果一个值是null，另一个值是undefined，它们相等</li><li>如果一个值是数字，另一个值是字符串，把字符串转为数字，再用转换后值比较。</li><li>如果一个值是true,将它转换为1，再进行比较，如果是false，转换为0再比较</li><li>如果一个值是对象，另一个值是数字或字符串，将对象转换为原始类型的值再进行比较。可以使用对象的toString()方法或valueOf()方法将对象转换为原始类型的值。javascript核心语言的内部类通常先尝试valueOf()转换，再尝试toString()转换，但对于Date类，则先执行toString()转换。不属于javascript核心语言的对象可以采用js实现定义的方式把自身转换为原始数值。</li><li>其他的数值组合是不相等的。</li></ul></li></ul><p>如下代码是一个测试相等性的例子，带有类型转换： “1” == true ,true会先转换为1，字符串“1”会转为数字1，结果为true</p><h4 id="4-2-不等运算符（-）和不等同运算符（-）"><a href="#4-2-不等运算符（-）和不等同运算符（-）" class="headerlink" title="4.2 不等运算符（!=）和不等同运算符（!==）"></a>4.2 不等运算符（!=）和不等同运算符（!==）</h4><p>运算符（!=）和（！==）检测情况和（==）和（===）结果相反</p><h3 id="5-关系运算符"><a href="#5-关系运算符" class="headerlink" title="5. 关系运算符"></a>5. 关系运算符</h3><h4 id="5-1-比较运算符"><a href="#5-1-比较运算符" class="headerlink" title="5.1 比较运算符"></a>5.1 比较运算符</h4><p>比较运算符用来确定两个值的相对顺序。包括：</p><ul><li>小于运算符(＜）<ul><li>如果运算符＜的第一个运算数小于它的第二个运算数，它计算的值就为true否则它计算的值为fa1se</li></ul></li><li>大于运算符(＞)<ul><li>如果运算符＞的第一个运算数大于它的第二个运算数，它计算的值就为true，否则计算的值为 false</li></ul></li><li>小于等于运算符(＜=）<ul><li>如果运算符≤=的第一个运算数小于或等于第二个运算数，那么它计算的值就为true，否则计算的值为 false。</li></ul></li><li>大于等于运算符(&gt;=）<ul><li>如果运算符&gt;=的第一个运算数大于或等于第二个运算数，那么它计算的值就为true，否则计算的值为 false。</li></ul></li></ul><p>这些比较运算符的运算数可以是任意类型的，但是只能在数字和字符串上执行比较操作，所有不是数字或字符串的类型将会被转换为数字或字符串。比较和转换规则如下：</p><ul><li>如果两个运算数是数字或者都被转换成了数字，那么将采取数字比较。</li><li>如果两个运算数是字符串或都被转换成了字符串，那么将作为字符串进行比较。</li><li>如果一个运算数是字符串，或者被转换成了字符串，另一个运算数是数字，或者被转换成了数字，那么运算符将会把字符串转换为数字，执行数字比较。如果字符串不代表数字，它将会转换为NaN，比较结果是false。</li><li>如果对象可以被转换为数字或字符串，那么将执行数字转换。例如，比较date对象，可以从数字角度比较。</li><li>如果运算数都不能被转换为数字或字符串，那么结果返回false。</li><li>如果某个运算数是NaN，或者被转换成了NaN，那么结果返回false。</li></ul><h4 id="5-2-in运算符"><a href="#5-2-in运算符" class="headerlink" title="5.2 in运算符"></a>5.2 in运算符</h4><p>in运算符要求做不运算数是一个字符串，或可以被转为字符串，右边的运算数是一个对象或数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> point = &#123; <span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">1</span>&#125;</span><br><span class="line">“x” <span class="keyword">in</span> point;<span class="comment">//true</span></span><br><span class="line">“y” <span class="keyword">in</span> point;<span class="comment">//true</span></span><br><span class="line">“z” <span class="keyword">in</span> point; <span class="comment">//false</span></span><br><span class="line">“toString” <span class="keyword">in</span> point; <span class="comment">//继承属性，true</span></span><br></pre></td></tr></table></figure><h4 id="5-3-instanceof运算符"><a href="#5-3-instanceof运算符" class="headerlink" title="5.3 instanceof运算符"></a>5.3 instanceof运算符</h4><p>instanceof要求左边运算数是一个对象，右边运算数是对象类的名字。所有对象都是Object类的实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">d <span class="keyword">instanceof</span> <span class="built_in">Date</span>; <span class="comment">//true</span></span><br><span class="line">d <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">//true</span></span><br><span class="line">d <span class="keyword">instanceof</span> <span class="built_in">Number</span>; <span class="comment">//false</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">//true</span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">//true</span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>; <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>如果instanceof运算符的左边不是对象，或者右边运算数是一个对象，而不是构造函数，他将返回false. 另外，如果它右边运算数不是一个对象，他将返回运行时错误。</p><h3 id="6-字符串运算符"><a href="#6-字符串运算符" class="headerlink" title="6. 字符串运算符"></a>6. 字符串运算符</h3><p>有几个运算符在运算数是字符串时具有特殊的作用。<br>运算符“+”将连接两个字符串运算数：</p><pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“hello”+“ ”+“there”； <span class="comment">//hello there</span></span><br></pre></td></tr></table></figure></code></pre><p>运算符&lt;,&lt;=,&gt;,&gt;=将通过比较两个字符串来确定它们顺序。比较采用字母顺序，基于unicode编码标准。所有Latin字母表的大写字母都位于小写字母之前（即小于）。<br>运算符+比较特殊，它给予字符串运算数的优先级比数字运算数高。如果该运算符的一个运算数是字符串，那么另一个将被转换为字符串。进行连接操作。另一方面，如果比较运算符的两个运算数都是字符串，将进行字符串比较;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span> ； <span class="comment">//加法：3</span></span><br><span class="line">“<span class="number">1</span>”+ <span class="number">2</span>;  <span class="comment">//连接运算：“12”</span></span><br><span class="line">“<span class="number">1</span>”+ <span class="number">2</span>； <span class="comment">//连接运算： “12”</span></span><br><span class="line"><span class="number">11</span> &lt; <span class="number">3</span>；<span class="comment">//数字比较运算： false</span></span><br><span class="line">“<span class="number">11</span>” &lt; “<span class="number">3</span>”; <span class="comment">//字符串比较运算； true</span></span><br><span class="line">“<span class="number">11</span>” &lt; <span class="number">3</span>； <span class="comment">//数字比较运算：“11”被转换为11，false，如果只有一个是字符串，那么js会把它转换为数字。</span></span><br><span class="line">“one” &lt; <span class="number">3</span> <span class="comment">//数字比较运算：“one”转换为NaN,false</span></span><br></pre></td></tr></table></figure><h3 id="7-逻辑运算符"><a href="#7-逻辑运算符" class="headerlink" title="7. 逻辑运算符"></a>7. 逻辑运算符</h3><h4 id="7-1-逻辑与运算符（-amp-amp-）"><a href="#7-1-逻辑与运算符（-amp-amp-）" class="headerlink" title="7.1 逻辑与运算符（&amp;&amp;）"></a>7.1 逻辑与运算符（&amp;&amp;）</h4><p>当运算符&amp;&amp;的两个运算数都是布尔值时,它对这两个运算数执行布尔AND操作,即当且仅当它的两个运算数都是true时,它才返回true如果其中一个或两个运算数值为 false,它就返回 false。</p><p>这个运算符的实际行为比较复杂。首先,它将计算第一个运算数,也就是位于它左边的表达式。如果这个表达式的值可以被转换成 false(例如,左边运算数的值为null、0或 undefined),那么运算符将返回左边表达式的值。否则,它将计算第二个运算数,也就是位于它右边的表达式,并且返回这个表达式的值。</p><p>if( a == b) stop(); 等价于(a==b) &amp;&amp; stop();</p><h4 id="7-2-逻辑或运算符（-）"><a href="#7-2-逻辑或运算符（-）" class="headerlink" title="7.2 逻辑或运算符（||）"></a>7.2 逻辑或运算符（||）</h4><p>当运算符Ⅱ的两个运算数都是布尔值时，它对这两个运算数执行布尔或操作，即如果它的两个运算数中有一个值为为true(或者两个都为为true)，那么它就返回为true。如果它的两个运算数值都为false、它就返回false.</p><p>虽然 || 运算符常用为布尔或运算符，但是它和&amp;&amp;运算符一样，行为是比较复杂的.首先，它要计算第一个运算数，即它左边的表达式的值.如果这个表达式的值可以被转换成是真的，那么它就返回左边这个表达式的值。否则，它将计算第二个运算数，即位于它右边的表达式，并且返回该表达式的值.</p><h4 id="7-3-逻辑非运算符"><a href="#7-3-逻辑非运算符" class="headerlink" title="7.3 逻辑非运算符(!)"></a>7.3 逻辑非运算符(!)</h4><p>逻辑非运算符是一个一元运算符，它放在一个运算数之前。它用来对运算数对布尔值取反。对任意值x应用两次该运算符（即!!x）都可以将它转换为一个布尔值。</p><h3 id="8-逐位运算符"><a href="#8-逐位运算符" class="headerlink" title="8. 逐位运算符"></a>8. 逐位运算符</h3><ul><li>按位与运算符(&amp;)<br>运算符&amp;对它的整型参数逐位执行布尔AND操作只有两个运算数中相应的位都为1、那么结果中的这一位才为1。例如，0x1234 &amp; 0x00FF=0×0034</li><li>按位或运算符(｜)<br>运算符｜对它的整型参数逐位执行布尔或操作。如果其中一个运算数中的相应位为%1或者两个运算数中的相应位都为1，那么结果中的这一位就为1。例如，9｜10=11</li><li>按位异或运算符(^)<br>运算符^对它的整型参数逐位执行布尔异或操作.异或是指第一个运算数是true，或者第二个运算数是true，但是两者不能同时为true如果两个运算数中只有一个数的相应位为1(但不能同时为1)，那么结果中的这一位就为1例如，9^10=3。</li><li>按位非运算符(<code>~</code>)<br>运算符<code>~</code>是个一元运算符，它位于一个整型参数之前，它将运算数的所有位取反.根据javascript中带符号的整数的表示方法，对一个值使用<code>~</code>运算符相当于改变它的符号并且减1例如，<code>~</code>0x0f = Oxfffff00或-16</li><li>左移运算符(&lt;&lt;)<br>运算符&lt;&lt;左移第一个运算数中的所有位移动的位数由第二个运算数指定,移动的位数应该是一个0到31的整数。例如,在表达式a&lt;&lt;1中,a的第一位变成了它的第二位,a的第二位变成了它的第三位,以此类推新的第一位用0来补充,舍弃第32位的值。将一个值左移1位相当于对它乘2,左移2位相当于对它乘4,以此类推。例如,7&lt;&lt;1=14</li><li>带符号的右移运算符(&gt;&gt;)<br>运算符&gt;&gt;右移第一个运算数中的所有位,移动的位数由第二个运算数指定,移动的位数应该是一个0到31的整数。舍弃右边移出的位,填补在左边的位由原运算数的符号位决定,以便保持结果的符号与原操作数一致。如果第一个运算数是正的,就用O填补结果的高位;如果第一个运算数是负的,就用1填补结果的高位。将一个值右移1位,相当于用2除它(丢弃余数)右移2位,相当于用4除它,以此类推。例如,7&gt;1=3,-7&gt;&gt;1=-4</li><li>用0补足的右移运算符(&gt;&gt;&gt;)<br>运算符&gt;&gt;&gt;和运算符&gt;一样,只是从左边移入总是0,与原运算数的符号无关。例如,-1&gt;&gt;4=-1,但是-1&gt;&gt;4=268435455(0x0fffffff0)</li></ul><h3 id="9-赋值运算符"><a href="#9-赋值运算符" class="headerlink" title="9. 赋值运算符"></a>9. 赋值运算符</h3><p>运算符=要求它左边对运算数是一个变量，数组的一个元素，或是对象的一个属性，右边的运算数是一个任意的值，任意类型。</p><h4 id="9-1-带操作的运算符"><a href="#9-1-带操作的运算符" class="headerlink" title="9.1 带操作的运算符"></a>9.1 带操作的运算符</h4><p>运算符+=可以作用于数字和字符串，如果它的运算数是数字，执行加法运算和赋值操作，如果是字符串，将执行连接操作和赋值操作。还有-=,*=,&amp;=等。</p><h3 id="10-其他运算符"><a href="#10-其他运算符" class="headerlink" title="10. 其他运算符"></a>10. 其他运算符</h3><h4 id="10-1-条件运算符"><a href="#10-1-条件运算符" class="headerlink" title="10.1 条件运算符(?)"></a>10.1 条件运算符(?)</h4><p>条件运算符是 JavaScript中惟一的三元运算符(带有三个运算数)有时就称它为三元运算符。这个运算符常被写为?:,但是在代码中它却不是这样的,因为这个运算符具有三个运算数,第一个位于?之前,第二个位于?和:之间,第三个位于:之后。可以用如下方式来使用它:</p><p> x&gt;0 ? x<em>y : -x</em>y</p><p>条件运算符的第一个运算数必须是一个布尔值(或能够被转换为布尔值),通常它是一个比较表达式的结果。第二个和第三个运算数可以是任何类型的值。条件运算符的返回值是由第一个运算数的布尔值决定的。如果这个运算数的值为true,那么条件表达式的值就是第二个运算数的值。如果第一个运算数的值为 false,那么条件表达式的值就是第三个运算数的值。</p><h4 id="10-2-typeof运算符"><a href="#10-2-typeof运算符" class="headerlink" title="10.2 typeof运算符"></a>10.2 typeof运算符</h4><p>typeof是个一元运算符,放在一个运算数之前,这个运算数可以是任意类型的。它的返回值是一个字符串,该字符串说明了运算数的类型。</p><p>如果 typeof的运算数是数字、字符串或者布尔值,它返回的结果就是“number”、“string”或“boolean。对对象、数组和null,它返回的是“object。对函数运算数它返回的是“function”。如果运算数是未定义的,它将返回“undefined”</p><p>当 typeof的运算数是 Number、 String或 Boolean这样的包装对象时,它返回的是“object。此外,对Date和 RegExp对象,它也返回“object。对于那些不属于JavaScript核心语言,而是由 JavaScript嵌入的环境提供的对象, typeof的返回值是由实现决定的。但是,在客户端 JavaScript中, typeof对所有的客户端对象返回的都是“object”,这与它对所有核心对象的处理是一样的。</p><p>由于 typeof对所有的对象和数组类型返回的都是“object”,所以它只在区别对象和原始类型时才有用。要区别一种对象类型和另一种对象类型,必须使用其他的方法。例如instanceof运算符和 constructor属性.</p><h4 id="10-3-对象创建运算符-new"><a href="#10-3-对象创建运算符-new" class="headerlink" title="10.3 对象创建运算符(new)"></a>10.3 对象创建运算符(new)</h4><p>new运算符用来创建一个新对象,并调用构造函数初始化它。new是一个一元运算符,出现在构造函数的调用之前。它的语法如下:</p><p>new constructor(arguments)</p><p>constructor必须是一个构造函数表达式其后应该有一个用括号括起来的参数列表,列表中有零或多个参数,参数之间用逗号分隔。 JavaScript简化了该语法,即如果函数调用时没有参数,就可以省去括号这种简化了的语法只适用于运算符new.下面是一些使用new运算符的例子:</p><p> o=new Object; //此处省略了可选的括号</p><p> d=new Date();//返回一个表示当前时间的Date对象</p><p>c= new Rectangle(3.0.4.0,1.52.75);//创建 Rectangle类的对象<br>obj[i]=new constructors[i] ();</p><p>运算符new首先创建一个新对象,该对象的属性都未被定义接下来,它将调用特定的构造函数,传递指定的参数,此外还要把新创建的对象传递给关键字this这样构造函数就可以使用关键字this来初始化新对象.</p><h4 id="10-4-delete运算符"><a href="#10-4-delete运算符" class="headerlink" title="10.4 delete运算符"></a>10.4 delete运算符</h4><p>delete运算符是个一元运算符,它将删除运算数所指定的对象的属性、数组元素或变量(注3)。如果删除操作成功,它将返回true,如果运算数不能被删除,它将返回 false。并非所有的属性和变量都是可以删除的,某些内部的核心属性和客户端属性不能删除,用var语句声明的变量也不能被删除。如果 delete使用的运算数是一个不存在的属性,它将返回true(令人吃惊的是, ECMAScript标准规定,当 delete运算的运算数不是属性、数组元素或变量时,它返回true.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"><span class="keyword">delete</span> o.x</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="keyword">typeof</span> o.x</span><br><span class="line"><span class="string">&quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">delete</span> o.x</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="keyword">delete</span> o</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="keyword">delete</span> <span class="number">1</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">y = <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">delete</span> y</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>delete所能影响的只是属性值，并不能影响这些属性引用的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> my = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">my.a = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">my.b = my.a;</span><br><span class="line"><span class="keyword">delete</span> my.a;</span><br><span class="line"><span class="built_in">console</span>.log(my.b);<span class="comment">//时间值 Mon Jan 11 2021 17:54:58 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure><h4 id="10-5-void运算符"><a href="#10-5-void运算符" class="headerlink" title="10.5 void运算符"></a>10.5 void运算符</h4><p>void是一个一元运算符,它可以出现在任何类型操作数之前。这个运算符的用途比较特殊,它总是舍弃运算数的值,然后返回undefined这种运算符常用在客户端的 javascript:URL中。在这里可以计算表达式的值,而浏览器不会显示出这个值</p><p>例如,可以在HTML的标记中以如下方式使用void运算符:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;javascript: void window.open () &quot;</span>&gt;Open New Window&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>void另一个用途是专门生成undefined值</p><h4 id="10-6-逗号运算符"><a href="#10-6-逗号运算符" class="headerlink" title="10.6 逗号运算符(,)"></a>10.6 逗号运算符(,)</h4><p>逗号运算符非常简单。它先计算其左边的参数,再计算其右边的参数,然后返回右边参数的值。因此,如下的代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">0</span>,j=<span class="number">1</span>,k=<span class="number">2</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">i=<span class="number">0</span>;</span><br><span class="line">j=<span class="number">1</span>;</span><br><span class="line">k=<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>这个奇怪的运算符只在个别环境中使用,一般是在只允许出现一个表达式的地方计算几个不同的表达式时才使用的。在实际应用中,逗号运算符只和for循环语句联合使用。</p><h4 id="10-7-数组和对象存取运算符"><a href="#10-7-数组和对象存取运算符" class="headerlink" title="10.7 数组和对象存取运算符"></a>10.7 数组和对象存取运算符</h4><p>运算符“.”左边是一个对象，右边是一个标识符<br>运算符“[]”用于存取数组元素，还可以存取对象的属性。</p><h4 id="10-8-函数调用运算符（）"><a href="#10-8-函数调用运算符（）" class="headerlink" title="10.8 函数调用运算符（）"></a>10.8 函数调用运算符（）</h4><!-- * @Description: javascript-第五章-表达式和运算符 * @version::  * @Author: zhao * @Date: 2021-01-10 22:43:09 * @LastEditors: zhao * @LastEditTime: 2021-01-11 11:37:15-->]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-第四章-变量</title>
      <link href="/ZJY.github.io/2021/01/10/javascript-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%8F%98%E9%87%8F/"/>
      <url>/ZJY.github.io/2021/01/10/javascript-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="第四章-变量"><a href="#第四章-变量" class="headerlink" title="第四章 变量"></a>第四章 变量</h2><h3 id="1-变量的类型"><a href="#1-变量的类型" class="headerlink" title="1.变量的类型"></a>1.变量的类型</h3><p>js是无类型的，变量可以存放任意类型的值</p><h3 id="2-变量的声明"><a href="#2-变量的声明" class="headerlink" title="2.变量的声明"></a>2.变量的声明</h3><p>要使用一个变量，要使用var关键字声明。<br>    var i;<br>    var num;<br>    也可以一次声明多个变量：var i,num;<br>    也可以将变量声明和初始化绑到一块：var message = ‘hello’;<br>    var i=0,k=1;</p><p>var 声明的变量是永久性的，用delete运算符删除变量会引发错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">delete</span> i; <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 10</span></span><br><span class="line">a=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">delete</span> a; <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// a is not defined </span></span><br></pre></td></tr></table></figure><p>重复声明同一个变量是合法的，且不会报错。<br>如果尝试读取一个未声明的变量的值，会引发错误。<br>如果给未用var声明的变量赋值，js会隐式的声明该变量，隐式声明变量会使该变量为全局变量。</p><h3 id="3-变量的作用域"><a href="#3-变量的作用域" class="headerlink" title="3.变量的作用域"></a>3.变量的作用域</h3><p>变量的作用域就是程序中定义变量的区域。全局变量的作用域全局性的，在js中处处有定义。而在函数内部定义的变量只能在函数内部使用，是局部性的。函数的参数也是局部作用域，只在函数内部有定义。<br>在函数内部，局部变量的优先级比同名的全局变量高.</p><h4 id="3-1-没有块级作用域"><a href="#3-1-没有块级作用域" class="headerlink" title="3.1 没有块级作用域"></a>3.1 没有块级作用域</h4><p>即函数中声明的所用变量在整个函数中有定义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> o==<span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> k=<span class="number">0</span>; k&lt;<span class="number">10</span>;k++)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">document</span>.write(k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(i,j,k);</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="literal">null</span>); <span class="comment">// 0 0  10  i,j,k在整个函数中有定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> scope=<span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(scope);</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">&#x27;local&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(scope);</span><br><span class="line">&#125;</span><br><span class="line">f(); <span class="comment">// undefined  local</span></span><br></pre></td></tr></table></figure><h4 id="3-2-未定义的变量和未赋值的变量"><a href="#3-2-未定义的变量和未赋值的变量" class="headerlink" title="3.2 未定义的变量和未赋值的变量"></a>3.2 未定义的变量和未赋值的变量</h4><p>var x;  //声明一个未赋值的变量<br>alert(u); //使用未声明的变量将引发错误<br>u=3; //给未声明的变量赋值，将创建该变量</p><h3 id="4-基本类型"><a href="#4-基本类型" class="headerlink" title="4.基本类型"></a>4.基本类型</h3><p>变量具有或存放了值，存放的具体内容就是js所支持的数据类型。<br>基本数据类型：null,number,string,bool,undefined<br>引用数据类型：对象，数组和函数。</p><p>基本类型在内存中具有固定的大小。引用类型没有固定的大小。<br>引用类型，变量存储的是对这个值的引用，通常是指针或内存地址。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//3.14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">A[<span class="number">0</span>]=<span class="number">99</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//[99,2,3]</span></span><br></pre></td></tr></table></figure><p>变量保存了基本数据类型的值，而只保存了对引用类型的引用。</p><h3 id="5-无用存储单元的收集"><a href="#5-无用存储单元的收集" class="headerlink" title="5.无用存储单元的收集"></a>5.无用存储单元的收集</h3><p>由于引用类型没有固定的大小，所以引用类型可能非常的大。由于字符串、数组、对象没有固定大小，所以当知道他们的大小时，才能为他们进行动态的内存分配。</p><p>js程序每次创建字符串、对象和数组时，解释器都要分配内存来储存实体，只要像这样动态的分配了内存，最终都要释放内存以便它们能够被再用。否则，js解释器会消耗所有系统内存，造成系统崩溃。</p><p>js不要求手动释放内存，它使用一种无用存储单元收集方法。当js检测到一个对象不再使用时，就会把它所占用内存释放掉。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = ‘hello’;</span><br><span class="line"><span class="keyword">var</span> u = s.toUppercase();</span><br><span class="line">s = u;</span><br></pre></td></tr></table></figure><p>程序检测到’hello’字符串不再使用，就会释放掉这块内存.</p><h3 id="6-作为属性的变量"><a href="#6-作为属性的变量" class="headerlink" title="6.作为属性的变量"></a>6.作为属性的变量</h3><p>变量和对象的属性基本是一样的，赋值和用法都相同。</p><h4 id="6-1-全局对象"><a href="#6-1-全局对象" class="headerlink" title="6.1 全局对象"></a>6.1 全局对象</h4><p>在js解释器执行前，首先要做的事情之一在任何代码执行之前，创建一个全局对象（global object）。这个对象的属性就是全局变量。</p><p>当js声明一个全局变量时，实际上就是定义了那个全局对象的一个属性。</p><p>在程序的顶层代码中，可以用this代替那个全局对象。<br>在客户端js中，window对象代表浏览器窗口，是包含在窗口中所有js代码的全局对象。这个全局Window对象具有自我引用的window属性，它代替了this属性。可以用来引用全局对象。Window对象定义了全局的核心属性，例如Infinity,parseInt,Math,除此之外还定义了全局的客户端属性，navigator和 screen.</p><h4 id="6-2-局部变量：调用对象"><a href="#6-2-局部变量：调用对象" class="headerlink" title="6.2 局部变量：调用对象"></a>6.2 局部变量：调用对象</h4><p>全局变量是特殊的全局对象的属性，局部变量是调用对象（call object）的属性。</p><p>在执行一个函数时，局部变量和参数是作为调用对象的属性存储的。用一个完全独立的对象存储局部变量可以使js防止同名变量覆盖全局变量的值。</p><h4 id="6-3-javascript的执行环境"><a href="#6-3-javascript的执行环境" class="headerlink" title="6.3 javascript的执行环境"></a>6.3 javascript的执行环境</h4><p>javascript的解释器每次开始执行一个函数时，就会为那个函数创建一个执行环境（execution context）。显然，这个执行环境就是js代码段执行时所在环境。</p><p>所用js函数都有自己的执行环境，有自己的调用对象，调用对象定义了局部变量。运行不属于任何js代码的环境使用的就是全局对象。</p><p>js允许有多个全局执行环境，每个全局执行环境有不同的全局对象（但在在这种情况下，全局对象就不完全是全局的了）。</p><p>一个显而易见的例子就是，每个独立的浏览器窗口或同一窗口不同框架中都定义了独立的全局执行环境。每个框架或窗口中的客户端js代码都运行在自己的执行环境中，具有自己的全局对象。但是这些独立的客户端全局对象，具有将其他对象连接起来的属性。因此，一个框架可以通过parent.frames[1]来引用另一个框架的代码，在第二个框架中可以用表达式parent.frames[0].x来引用第一个框架的全局变量x。</p><h3 id="7-变量的作用域"><a href="#7-变量的作用域" class="headerlink" title="7.变量的作用域"></a>7.变量的作用域</h3><p><img src="/ZJY.github.io/images/scope.png" alt="变量的作用域"></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-第三章-数据类型和值</title>
      <link href="/ZJY.github.io/2021/01/10/javascript-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%80%BC/"/>
      <url>/ZJY.github.io/2021/01/10/javascript-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="第三章-数据类型和值"><a href="#第三章-数据类型和值" class="headerlink" title="第三章 数据类型和值"></a>第三章 数据类型和值</h2><p>计算机程序是通过操作值来运行的。能够表示并操作的值的类型称为数据类型。</p><p>javascript允许使用3种基本数据类型：数字、字符串、布尔。此外还支持另外2种小数据类型：null（空）和undefined（未定义），只定义了一个值。</p><p>除了基本数据类型外，javascript还支持复合数据类型-对象，是值的集合。对象有两种，一种是已命名的值的无序集合，另一种是有编号的值的有序集合。后者称为数组。</p><p>javascript还定义了另一种特殊的类型-函数，是具有可执行代码的对象。js为函数定义了专用的语法。</p><p>除了数组和函数还定义了其他专用的对象，这些对象不是新的数据类型而是新的对象类。Date类定义的表示日期的对象。</p><p>RegExp类定义的表示正则表达式的对象。Error类定义的是js程序中发生的语法和运行时错误的对象。</p><h3 id="1-数字"><a href="#1-数字" class="headerlink" title="1.数字"></a>1.数字</h3><p>在js中，不区分整点型和浮点型数字，所有数字都是浮点型的，采用ieee 754标准的64位浮点格式表示</p><h4 id="1-1-整型直接量-十进制"><a href="#1-1-整型直接量-十进制" class="headerlink" title="1.1 整型直接量(十进制)"></a>1.1 整型直接量(十进制)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>   <span class="number">3</span>   <span class="number">1000</span></span><br></pre></td></tr></table></figure><p>整数表示从2<sup>-53</sup> 到2 <sup>53</sup>,使用超过尾数范围的数字，就会失去精确性，<br>有些整数的运算，是对32位进行的，（2<sup>-31</sup> 到 2<sup>31-1</sup>)</p><h4 id="1-2八进制和十六进制直接量"><a href="#1-2八进制和十六进制直接量" class="headerlink" title="1.2八进制和十六进制直接量"></a>1.2八进制和十六进制直接量</h4><p>除了10进制的整型直接量，js还支持8进制和16进制直接量。</p><p>16进制中数字可以用0-9表示，字母可以用a(A)-f(F)表示，代表0-15之间数字。16进制直接量由’0x’ 或‘0X’开头，后面跟16进制数字串。</p><p>0x123 基数是16 //1<em>16</em>16+2*16+3</p><p>尽管ECMAScript标准不支持8进制的直接量，但是javascript的某些实现却允许你使用8进制的直接量。8进制是以0开头，后面跟随0-7直接的数字，</p><p>0377 基数是8 // 3<em>8</em>8+7*8+7</p><p>由于某些js实现支持8进制有些不支持，所以尽量不要使用0开头的整型直接量。</p><h4 id="1-3浮点型直接量"><a href="#1-3浮点型直接量" class="headerlink" title="1.3浮点型直接量"></a>1.3浮点型直接量</h4><p>由整数部分，小数点，小数部分组成，此外还可以用指数计数法表示浮点型直接量，即实数后面跟字母e或者E，后面跟正号和负号，再加一个整型指数。表示前面的实数乘以10的指数次幂。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.14</span></span><br><span class="line"><span class="number">344.89</span></span><br><span class="line"><span class="number">6.34e12</span> <span class="comment">//6.34*1012</span></span><br></pre></td></tr></table></figure><h4 id="1-4特殊数值"><a href="#1-4特殊数值" class="headerlink" title="1.4特殊数值"></a>1.4特殊数值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">Infinity</span>  无穷大</span><br><span class="line">-<span class="literal">Infinity</span>  负无穷大</span><br><span class="line"><span class="literal">NaN</span>    非数字的特殊值，和任何值都不相等，包括自己，用专门的<span class="built_in">isNaN</span>()函数来检测这个值。</span><br><span class="line"><span class="built_in">isFinite</span>()函数来测试一个值是否是<span class="literal">NaN</span>，正无穷大或负无穷大。</span><br><span class="line"><span class="built_in">Number</span>.MAX_VALUE  可表示的最大数字</span><br><span class="line"><span class="built_in">Number</span>.MIN_VALUE   可表示的最小数字（接近于<span class="number">0</span>）</span><br><span class="line"><span class="built_in">Number</span>.NaN  非数字的特殊值</span><br><span class="line"><span class="built_in">Number</span>.POSITION_INFINITY 表示正无穷大的特殊值</span><br><span class="line"><span class="built_in">Number</span>.NEGATIVE_INFINITY 表示负无穷大的特殊值</span><br></pre></td></tr></table></figure><h3 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2.字符串"></a>2.字符串</h3><p>由unicode字符、数字和标点符号组成的序列，表示文本的数据类型。</p><h4 id="2-1-字符串直接量"><a href="#2-1-字符串直接量" class="headerlink" title="2.1 字符串直接量"></a>2.1 字符串直接量</h4><p>由单引号或者双引号扩起来的unicdoe字符序列。可以包含0个或多个字符序列</p><h4 id="2-2-字符串直接量中的转义字符"><a href="#2-2-字符串直接量中的转义字符" class="headerlink" title="2.2 字符串直接量中的转义字符"></a>2.2 字符串直接量中的转义字符</h4><p>反斜杠\后加一个字母就可以表示特殊的用法。\n表示换行符<br>‘you&#39;re right’, \’表示单引号或者撇号</p><h3 id="3-布尔值"><a href="#3-布尔值" class="headerlink" title="3.布尔值"></a>3.布尔值</h3><p>true和false两个值，通常用于控制结果</p><h3 id="4-函数"><a href="#4-函数" class="headerlink" title="4.函数"></a>4.函数</h3><p>一段可执行的代码段，由js定义或由js预定义，可多次执行和调用。js函数是一个真正的数据类型，可以对函数进行操作。</p><p>Math.sin()预定义函数</p><h4 id="4-1-函数直接量"><a href="#4-1-函数直接量" class="headerlink" title="4.1 函数直接量"></a>4.1 函数直接量</h4><p>有关键字function和可选对参数名、用括号括起来对参数列表和花括号括起来定义的。</p><p>除了用函数定义来定义函数：</p><p>function square(x){ return x*x }</p><p>还可以用函数直接量类定义：</p><p>var square = funtion(x) { return x*x }</p><p>如果一个函数值存储在某个对象的属性中，那个这个函数通常被称为方法，属性名称被称为方法名。</p><h3 id="5-对象"><a href="#5-对象" class="headerlink" title="5.对象"></a>5.对象</h3><p>已命名的数据的集合，每个数值都有一个名字,称为对象的属性，通过”.”操作符和属性名访问。</p><h4 id="5-1-创建对象"><a href="#5-1-创建对象" class="headerlink" title="5.1 创建对象"></a>5.1 创建对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/javascript/gi</span>);</span><br></pre></td></tr></table></figure><h4 id="5-2-对象直接量"><a href="#5-2-对象直接量" class="headerlink" title="5.2 对象直接量"></a>5.2 对象直接量</h4><p>var point = {x: 1,y:3}，<br>对象直接量可以嵌套，属性值可以不是常量。</p><h3 id="6-数组"><a href="#6-数组" class="headerlink" title="6.数组"></a>6.数组</h3><p>数值的集合，数组的每个数值都有一个下标，js不支持多维数组，但数组元素可以是数组。数组下标是非负整数</p><h4 id="6-1-数组的创建"><a href="#6-1-数组的创建" class="headerlink" title="6.1 数组的创建"></a>6.1 数组的创建</h4><p>可以通过构造函数Array()创建:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1.2</span>;</span><br><span class="line">arr[<span class="number">1</span>] = ‘javascript’;</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1.2</span>,’javascript’);</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>); 创建的是表示<span class="number">10</span>个未定义的数组</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-2-数组直接量"><a href="#6-2-数组直接量" class="headerlink" title="6.2 数组直接量"></a>6.2 数组直接量</h4><p>var arr = [1,2,3,4];<br>数组可以嵌套，var arr = [[1,2,3],2];<br>数组元素不局限于常量：var arr = [1024,1024+1]<br>数组可以存放未定义的元素：var arr = [1,,,,5]</p><h3 id="7-null"><a href="#7-null" class="headerlink" title="7.null"></a>7.null</h3><p>表示“无”值，尝被看作对象类型的特殊值，表示“无对象”的值。js保留字</p><h3 id="8-undefined"><a href="#8-undefined" class="headerlink" title="8.undefined"></a>8.undefined</h3><p>当你使用一个未定义的值，或已定义未赋值的值，或不存在的对象属性时，返回这个值。</p><p>null == undefined  //true</p><p>如果要区分null和undefined可用 === 或者typeof区分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// “object”  </span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// undefined</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> 不是js保留字</span><br><span class="line">ECMAScript v3 定义了名为<span class="literal">undefined</span>的全局变量，值为<span class="literal">undefined</span></span><br></pre></td></tr></table></figure><h3 id="9-Date对象"><a href="#9-Date对象" class="headerlink" title="9.Date对象"></a>9.Date对象</h3><p>表示日期和时间的对象类。可以用运算符new和构造函数Date()创建Date对象</p><h3 id="10-正则表达式"><a href="#10-正则表达式" class="headerlink" title="10.正则表达式"></a>10.正则表达式</h3><p>用于模式匹配和查找替换操作，正则表达式直接量：/^html/</p><h3 id="11-Error"><a href="#11-Error" class="headerlink" title="11.Error"></a>11.Error</h3><p>表示错误的类,每个Error对象都有一个message属性，存放js特定错误消息。预定义的错误对象的类型有Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError和URIError.</p><h3 id="12-基本数据类型的包装对象"><a href="#12-基本数据类型的包装对象" class="headerlink" title="12.基本数据类型的包装对象"></a>12.基本数据类型的包装对象</h3><p>var str =”lfjlajdfasd”;<br>var result = str.substring(1,4);<br>三个基本的数据类型都有一个相应的对象类，js不仅有数字、字符串、布尔类型，还有Number、String、Bool类，这些类是基本数据类型的包装，这些类不仅有基本数据类型的值，还定义了用来运算的属性和方法</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript-第二章-词法结构</title>
      <link href="/ZJY.github.io/2021/01/10/javascript-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%AF%8D%E6%B3%95%E7%BB%93%E6%9E%84/"/>
      <url>/ZJY.github.io/2021/01/10/javascript-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%AF%8D%E6%B3%95%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="第二章-词法结构"><a href="#第二章-词法结构" class="headerlink" title="第二章 词法结构"></a>第二章 词法结构</h2><h3 id="1-字符集"><a href="#1-字符集" class="headerlink" title="1.字符集"></a>1.字符集</h3><p>采用16位的unicode编码可以表示任意一种书面语言，javascript是采用unicode字符集编写的。js中任意字符都是用2个字节表示。</p><h3 id="2-区分大小写"><a href="#2-区分大小写" class="headerlink" title="2.区分大小写"></a>2.区分大小写</h3><p>在html中标记和性质名可以任意大小写方式输入，但是在js中通常是小写的。例如，在html中事件处理性质名是onClick，但是在js中只能用onclick。</p><h3 id="3-空白符和换行符"><a href="#3-空白符和换行符" class="headerlink" title="3.空白符和换行符"></a>3.空白符和换行符</h3><p>js会忽略空白符号、制表符、换行符，除非是字符串或正则表达式中。</p><h3 id="4-分号可选"><a href="#4-分号可选" class="headerlink" title="4.分号可选"></a>4.分号可选</h3><p>但是省略分号并不是一个良好的编程习惯，应习惯于使用分号。</p><h3 id="5-注释"><a href="#5-注释" class="headerlink" title="5.注释"></a>5.注释</h3><p>单行： //  多行： /****/</p><h3 id="6-直接量"><a href="#6-直接量" class="headerlink" title="6.直接量"></a>6.直接量</h3><p>就是程序中直接显示的数据值，以下都是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1.2</span></span><br><span class="line">“hello,world”</span><br><span class="line"><span class="literal">null</span>,</span><br><span class="line">True,</span><br><span class="line">False,</span><br><span class="line">/javascript/gi,</span><br><span class="line">&#123;<span class="attr">x</span>:<span class="number">1</span>,<span class="attr">y</span>:<span class="number">1</span>&#125;, <span class="comment">//对象直接量</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] <span class="comment">//数组直接量</span></span><br></pre></td></tr></table></figure><h3 id="7-标识符"><a href="#7-标识符" class="headerlink" title="7.标识符"></a>7.标识符</h3><p>一个名字，用来命名变量和函数，或者代码中某些循环的标签。<br>命名规则：首字符以字母、下划线和美元符号开头，后面可以是数字、字母、下划线、美元符号</p><h3 id="8-保留字"><a href="#8-保留字" class="headerlink" title="8.保留字"></a>8.保留字</h3><p>不能用作标识符，有特殊意义</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript-第一章-Javascript的概述</title>
      <link href="/ZJY.github.io/2021/01/10/javascript-%E7%AC%AC%E4%B8%80%E7%AB%A0-Javascript%E7%9A%84%E6%A6%82%E8%BF%B0/"/>
      <url>/ZJY.github.io/2021/01/10/javascript-%E7%AC%AC%E4%B8%80%E7%AB%A0-Javascript%E7%9A%84%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Javascript的概述"><a href="#Javascript的概述" class="headerlink" title="Javascript的概述"></a>Javascript的概述</h3><p>JavaScript是一种轻型的，解释型的程序设计语言。具有面向对象的能力。是一种无类型的语言，也就是说变量不必具有明确的类型。<br>除了能够动态的生成浏览器要显示的html文档，js不具备任何图形处理能力。<br>处于安全考虑，客户端javascript不允许对文件进行读写操作。<br>除了能够引发浏览器下载任意url所指对文档以及把html表单内容发送给服务器脚本、电子邮件外，javascript不支持任意形式的联网技术。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
