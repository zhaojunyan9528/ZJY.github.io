<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="一.HTML1.html语义化 使页面内容结构化，即使丢失样式也能使页面呈现清晰的结构  有利于SEO，搜索引擎根据标签确定上下文和关键字的权重有利于开发和维护  语义化更具有可读性，代码更好维护  方便其他设备解析，如配合盲人阅读器渲染页面易于用户阅读，如：   header  定义头部内容  nav 定义导航区域  main 定义主要文档内 容  article 表示文章、博客等内容  asi">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试基础">
<meta property="og:url" content="https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="ZJY">
<meta property="og:description" content="一.HTML1.html语义化 使页面内容结构化，即使丢失样式也能使页面呈现清晰的结构  有利于SEO，搜索引擎根据标签确定上下文和关键字的权重有利于开发和维护  语义化更具有可读性，代码更好维护  方便其他设备解析，如配合盲人阅读器渲染页面易于用户阅读，如：   header  定义头部内容  nav 定义导航区域  main 定义主要文档内 容  article 表示文章、博客等内容  asi">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhaojunyan9528.github.io/ZJY.github.io/timages/weappPay.png">
<meta property="article:published_time" content="2021-01-20T17:24:08.000Z">
<meta property="article:modified_time" content="2023-12-12T11:55:45.900Z">
<meta property="article:author" content="ZJY">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhaojunyan9528.github.io/ZJY.github.io/timages/weappPay.png">
    
    
      
        
          <link rel="shortcut icon" href="/ZJY.github.io/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/ZJY.github.io/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/ZJY.github.io/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>前端面试基础</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/ZJY.github.io/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/ZJY.github.io/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/ZJY.github.io/">首页</a></li>
         
          <li><a href="/ZJY.github.io/archives/">归档</a></li>
         
          <li><a href="/ZJY.github.io/tags">标签</a></li>
         
          <li><a href="/ZJY.github.io/categories">分类</a></li>
         
          <li><a href="/ZJY.github.io/search/">搜索</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/ZJY.github.io/2021/01/26/%E4%BA%92%E8%81%94%E7%BD%91%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/ZJY.github.io/2021/01/20/%E9%9D%A2%E8%AF%95/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/&text=前端面试基础"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/&title=前端面试基础"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/&is_video=false&description=前端面试基础"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=前端面试基础&body=Check out this article: https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/&title=前端面试基础"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/&title=前端面试基础"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/&title=前端面试基础"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/&title=前端面试基础"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/&name=前端面试基础&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/&t=前端面试基础"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-HTML"><span class="toc-number">1.</span> <span class="toc-text">一.HTML</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-html%E8%AF%AD%E4%B9%89%E5%8C%96"><span class="toc-number">1.1.</span> <span class="toc-text">1.html语义化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-HTML5%E6%96%B0%E6%A0%87%E7%AD%BE"><span class="toc-number">1.2.</span> <span class="toc-text">2.HTML5新标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-html5%E8%AF%AD%E4%B9%89%E5%8C%96"><span class="toc-number">1.3.</span> <span class="toc-text">3.html5语义化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-html5%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">1.4.</span> <span class="toc-text">4.html5新特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AF%B9WEB%E6%A0%87%E5%87%86%E5%92%8CW3C%E7%9A%84%E7%90%86%E8%A7%A3%E8%AE%A4%E8%AF%86"><span class="toc-number">1.5.</span> <span class="toc-text">5.对WEB标准和W3C的理解认识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BB%80%E4%B9%88%E6%98%AFDOCTYPE%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="toc-number">1.6.</span> <span class="toc-text">6.什么是DOCTYPE及作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-CSS"><span class="toc-number">2.</span> <span class="toc-text">二.CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">1.盒模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-rem%E5%92%8Cem%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.</span> <span class="toc-text">2.rem和em的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B8%B8%E8%A7%81%E5%8D%95%E4%BD%8D"><span class="toc-number">2.3.</span> <span class="toc-text">3.常见单位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%A7%86%E5%8F%A3%E9%85%8D%E7%BD%AE"><span class="toc-number">2.4.</span> <span class="toc-text">4.移动端视口配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA%E4%B8%8E%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.</span> <span class="toc-text">5.渐进增强与优雅降级的理解及区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-cookie%E3%80%81sessionStorage%E3%80%81localStorage%E5%8C%BA%E5%88%AB"><span class="toc-number">2.6.</span> <span class="toc-text">6.cookie、sessionStorage、localStorage区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-css%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">2.7.</span> <span class="toc-text">7.css选择器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-css3%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">2.8.</span> <span class="toc-text">8.css3新特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0"><span class="toc-number">2.9.</span> <span class="toc-text">9.行内元素和块级元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-css%E7%9A%84position%E7%9A%84%E5%AE%9A%E4%BD%8D"><span class="toc-number">2.10.</span> <span class="toc-text">10.css的position的定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-Flex%E5%B8%83%E5%B1%80"><span class="toc-number">2.11.</span> <span class="toc-text">11.Flex布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-display%E6%9C%89%E5%93%AA%E4%BA%9B%E5%80%BC%EF%BC%9F%E8%AF%B4%E6%98%8E%E4%BB%96%E4%BB%AC%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.12.</span> <span class="toc-text">12.display有哪些值？说明他们的作用?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-BFC"><span class="toc-number">2.13.</span> <span class="toc-text">13.BFC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-number">2.14.</span> <span class="toc-text">14.水平垂直居中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-Sass%E3%80%81Less%E3%80%81Stylus%E5%8C%BA%E5%88%AB"><span class="toc-number">2.15.</span> <span class="toc-text">15.Sass、Less、Stylus区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-display-none%E4%B8%8Evisibility-hidden%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.16.</span> <span class="toc-text">16.display: none与visibility: hidden的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E9%87%8D%E7%BB%98-amp-%E5%9B%9E%E6%B5%81"><span class="toc-number">2.17.</span> <span class="toc-text">17.重绘 &amp; 回流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E9%98%B2%E6%8A%96%EF%BC%88debounce%EF%BC%89"><span class="toc-number">2.18.</span> <span class="toc-text">18.防抖（debounce）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E8%8A%82%E6%B5%81%EF%BC%88throttle%EF%BC%89"><span class="toc-number">2.19.</span> <span class="toc-text">19.节流（throttle）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E8%8E%B7%E5%8F%96%E7%9B%92%E5%AD%90%E5%AE%BD%E9%AB%98%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8C%BA%E5%88%AB"><span class="toc-number">2.20.</span> <span class="toc-text">20.获取盒子宽高的几种方式及区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-link%E5%92%8Cimport%E5%8C%BA%E5%88%AB"><span class="toc-number">2.21.</span> <span class="toc-text">21.link和import区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E5%A4%9A%E8%A1%8C%E5%85%83%E7%B4%A0%E7%9C%81%E7%95%A5%E5%8F%B7"><span class="toc-number">2.22.</span> <span class="toc-text">22.多行元素省略号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-JS"><span class="toc-number">3.</span> <span class="toc-text">三.JS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JS%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">1.JS的基本数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%87%A0%E7%A7%8D%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.2.</span> <span class="toc-text">2.几种判断数据类型的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-null%E5%92%8Cundefined%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.3.</span> <span class="toc-text">3.null和undefined的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AF%B9%E8%B1%A1%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.4.</span> <span class="toc-text">4.对象深浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%95%B0%E7%BB%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.</span> <span class="toc-text">5.数组基本方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-js%E6%9C%89%E9%82%A3%E4%BA%9B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.6.</span> <span class="toc-text">6.js有那些内置对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-get%E8%AF%B7%E6%B1%82%E4%BC%A0%E5%8F%82%E9%95%BF%E5%BA%A6%E7%9A%84%E8%AF%AF%E5%8C%BA"><span class="toc-number">3.7.</span> <span class="toc-text">7.get请求传参长度的误区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="toc-number">3.8.</span> <span class="toc-text">8.同步任务和异步任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">3.9.</span> <span class="toc-text">9.事件和回调函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">3.10.</span> <span class="toc-text">10.定时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.11.</span> <span class="toc-text">11.进程和线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-axios%E5%9C%A8vue-js%E4%B8%AD%E5%BA%94%E7%94%A8%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">3.12.</span> <span class="toc-text">12.axios在vue.js中应用和特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-HTTP%E4%B8%AD%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F"><span class="toc-number">3.13.</span> <span class="toc-text">13.HTTP中定义请求方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-get%E5%92%8Cpost%E5%8C%BA%E5%88%AB"><span class="toc-number">3.14.</span> <span class="toc-text">14.get和post区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-http%E4%B8%ADcontent-type"><span class="toc-number">3.15.</span> <span class="toc-text">15.http中content-type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-import%E5%92%8Crequire%E5%8C%BA%E5%88%AB"><span class="toc-number">3.16.</span> <span class="toc-text">16.import和require区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-ajax"><span class="toc-number">3.17.</span> <span class="toc-text">17.ajax</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E9%97%AD%E5%8C%85"><span class="toc-number">3.18.</span> <span class="toc-text">18.闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-js%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-number">3.19.</span> <span class="toc-text">19.js作用域和作用域链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">3.20.</span> <span class="toc-text">20.组件化和模块化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E5%9B%BE%E7%89%87%E7%9A%84%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">3.21.</span> <span class="toc-text">21.图片的预加载和懒加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-mouseover%E5%92%8Cmouseenter%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.22.</span> <span class="toc-text">22.mouseover和mouseenter的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E5%AF%B9This%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.23.</span> <span class="toc-text">23.对This对象的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-ES6%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD"><span class="toc-number">3.24.</span> <span class="toc-text">24.ES6其他常用功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-bind%E3%80%81call%E3%80%81apply%E7%94%A8%E6%B3%95%E5%8F%8A%E5%8C%BA%E5%88%AB"><span class="toc-number">3.25.</span> <span class="toc-text">25.bind、call、apply用法及区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E7%9B%AE%E5%89%8DJS%E8%A7%A3%E5%86%B3%E5%BC%82%E6%AD%A5%E7%9A%84%E6%96%B9%E6%A1%88%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">3.26.</span> <span class="toc-text">26.目前JS解决异步的方案有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">3.27.</span> <span class="toc-text">27.创建对象有几种方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-Vue"><span class="toc-number">4.</span> <span class="toc-text">四.Vue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">1.Vue生命周期的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%80%BB%E5%85%B1%E6%9C%89%E5%87%A0%E4%B8%AA%E9%98%B6%E6%AE%B5%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">2.Vue生命周期总共有几个阶段？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-DOM%E6%B8%B2%E6%9F%93%E5%9C%A8%E5%93%AA%E4%B8%AA%E5%91%A8%E6%9C%9F%E4%B8%AD%E5%B0%B1%E5%B7%B2%E7%BB%8F%E5%AE%8C%E6%88%90%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">3.DOM渲染在哪个周期中就已经完成？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%AF%8F%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%80%82%E5%90%88%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">4.每个生命周期适合哪些场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%85%B3%E4%BA%8Evue%E7%9A%84keep-alive%E9%9C%80%E8%A6%81%E6%9D%A1%E4%BB%B6%E6%80%A7%E7%BC%93%E5%AD%98%E7%9A%84%E8%A7%A3%E5%86%B3"><span class="toc-number">4.5.</span> <span class="toc-text">5.关于vue的keep-alive需要条件性缓存的解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Vue-%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">4.6.</span> <span class="toc-text">6.Vue 路由懒加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Proxy%E4%B8%8EObject-defineProperty-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">4.7.</span> <span class="toc-text">7.Proxy与Object.defineProperty()的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-v-show%E4%B8%8Ev-if%E5%8C%BA%E5%88%AB"><span class="toc-number">4.8.</span> <span class="toc-text">8.v-show与v-if区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-vue%E6%9C%89%E5%93%AA%E4%BA%9B%E6%8C%87%E4%BB%A4"><span class="toc-number">4.9.</span> <span class="toc-text">9.vue有哪些指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E5%80%BC%E9%80%9A%E4%BF%A1"><span class="toc-number">4.10.</span> <span class="toc-text">10.组件之间的传值通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%AD%90%E7%BB%84%E4%BB%B6%E8%B0%83%E7%94%A8%E7%88%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95%E5%87%BD%E6%95%B0"><span class="toc-number">4.11.</span> <span class="toc-text">11.子组件调用父组件的方法函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E6%96%B9%E5%BC%8F"><span class="toc-number">4.12.</span> <span class="toc-text">12.路由跳转方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-mvvm"><span class="toc-number">4.13.</span> <span class="toc-text">13.mvvm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-computed%E5%92%8Cwatch%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">4.14.</span> <span class="toc-text">14.computed和watch有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-key"><span class="toc-number">4.15.</span> <span class="toc-text">15.key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84data%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">4.16.</span> <span class="toc-text">16.组件中的data为什么是函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-Class-%E4%B8%8E-Style-%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%EF%BC%9F"><span class="toc-number">4.17.</span> <span class="toc-text">17.Class 与 Style 如何动态绑定？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-vue%E7%9A%84%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">4.18.</span> <span class="toc-text">18.vue的单向数据流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-keep-alive"><span class="toc-number">4.19.</span> <span class="toc-text">19.keep-alive</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-v-model-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">4.20.</span> <span class="toc-text">20.v-model 的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-nextTick"><span class="toc-number">4.21.</span> <span class="toc-text">21.nextTick()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-vue%E6%8F%92%E6%A7%BD"><span class="toc-number">4.22.</span> <span class="toc-text">22.vue插槽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB"><span class="toc-number">4.23.</span> <span class="toc-text">23.导航守卫</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-vuex%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.24.</span> <span class="toc-text">24.vuex是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E4%BC%98%E5%8C%96SPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6"><span class="toc-number">4.25.</span> <span class="toc-text">25.优化SPA首屏加载速度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E4%BD%A0%E6%9C%89%E5%AF%B9-Vue-%E9%A1%B9%E7%9B%AE%E8%BF%9B%E8%A1%8C%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">4.26.</span> <span class="toc-text">26.你有对 Vue 项目进行哪些优化？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-ES6"><span class="toc-number">5.</span> <span class="toc-text">五.ES6</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-var-let-const%E5%8C%BA%E5%88%AB"><span class="toc-number">5.1.</span> <span class="toc-text">1.var let const区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">5.2.</span> <span class="toc-text">2.解构赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-forEach%E3%80%81for-in%E3%80%81for-of%E4%B8%89%E8%80%85%E5%8C%BA%E5%88%AB"><span class="toc-number">5.3.</span> <span class="toc-text">3.forEach、for in、for of三者区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%BA%94%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.4.</span> <span class="toc-text">4.使用箭头函数应注意什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Set%E3%80%81Map%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.5.</span> <span class="toc-text">5.Set、Map的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Ajax"><span class="toc-number">5.6.</span> <span class="toc-text">6.Ajax</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.7.</span> <span class="toc-text">7.同步和异步的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-ajax%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-number">5.8.</span> <span class="toc-text">8.ajax的优点和缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-get%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.9.</span> <span class="toc-text">9.get和post的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8post%EF%BC%9F"><span class="toc-number">5.10.</span> <span class="toc-text">10.什么时候使用post？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="toc-number">5.11.</span> <span class="toc-text">11.同源策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="toc-number">5.12.</span> <span class="toc-text">12.如何解决跨域问题?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-number">6.</span> <span class="toc-text">六.浏览器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BB%E6%B5%81%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-number">6.1.</span> <span class="toc-text">1.主流浏览器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8"><span class="toc-number">6.2.</span> <span class="toc-text">2.浏览器内核</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9"><span class="toc-number">6.3.</span> <span class="toc-text">3.浏览器兼容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-%E5%85%B6%E4%BB%96"><span class="toc-number">7.</span> <span class="toc-text">七.其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%89%8D%E7%AB%AF%E7%BB%84%E4%BB%B6%E5%8C%96%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">7.1.</span> <span class="toc-text">1.前端组件化和模块化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AFAjax%E5%92%8CJSON%EF%BC%8C%E5%AE%83%E4%BB%AC%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-number">7.2.</span> <span class="toc-text">2.什么是Ajax和JSON，它们的优点和缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Github"><span class="toc-number">7.3.</span> <span class="toc-text">3.Github</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-webpack"><span class="toc-number">7.4.</span> <span class="toc-text">4.webpack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F"><span class="toc-number">7.5.</span> <span class="toc-text">5.微信小程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B"><span class="toc-number">7.6.</span> <span class="toc-text">6.微信小程序支付流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%BE%AE%E4%BF%A1%E7%BD%91%E9%A1%B5%E6%8E%88%E6%9D%83%E6%B5%81%E7%A8%8B"><span class="toc-number">7.7.</span> <span class="toc-text">7.微信网页授权流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B"><span class="toc-number">7.8.</span> <span class="toc-text">8.小程序登录流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%88%E6%9D%83"><span class="toc-number">7.9.</span> <span class="toc-text">9.小程序授权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE"><span class="toc-number">7.10.</span> <span class="toc-text">10.网络协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-HTTP-HTTPS"><span class="toc-number">7.11.</span> <span class="toc-text">11.HTTP&#x2F;HTTPS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%88%B0%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">7.12.</span> <span class="toc-text">12.从输入URL到页面加载到过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">7.13.</span> <span class="toc-text">13.HTTP状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">7.14.</span> <span class="toc-text">14.性能优化</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        前端面试基础
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">ZJY</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2021-01-20T17:24:08.000Z" itemprop="datePublished">2021-01-20</time>
        
        (Updated: <time datetime="2023-12-12T11:55:45.900Z" itemprop="dateModified">2023-12-12</time>)
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/ZJY.github.io/categories/%E9%9D%A2%E8%AF%95/">面试</a> › <a class="category-link" href="/ZJY.github.io/categories/%E9%9D%A2%E8%AF%95/Javascript/">Javascript</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/ZJY.github.io/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="一-HTML"><a href="#一-HTML" class="headerlink" title="一.HTML"></a>一.HTML</h2><h3 id="1-html语义化"><a href="#1-html语义化" class="headerlink" title="1.html语义化"></a>1.html语义化</h3><ul>
<li><p>使页面内容结构化，即使丢失样式也能使页面呈现清晰的结构</p>
</li>
<li><p>有利于SEO，搜索引擎根据标签确定上下文和关键字的权重有利于开发和维护</p>
</li>
<li><p>语义化更具有可读性，代码更好维护</p>
</li>
<li><p>方便其他设备解析，如配合盲人阅读器渲染页面易于用户阅读，<br>如：</p>
<p>  header  定义头部内容<br>  nav 定义导航区域<br>  main 定义主要文档内 容<br>  article 表示文章、博客等内容<br>  aside   侧边内容<br>  footer  尾部</p>
</li>
</ul>
<p>div、article、section</p>
<p>div、article、section是语义从无到有，逐渐增强的。<br>div无任何语义，仅仅用作样式化或脚本的标签。<br>对于一段主题性的内容，则适用于section元素。<br>对于可脱离上下文，作为一段完整独立内容的，适用于article。</p>
<ul>
<li><p>article元素代表文档、页面或应用程序中独立的、完整的、可以独自被外部引用的内容。它可以是一篇博客或报刊中的文章、一篇论坛帖子、一段用户评论或独立的插件，或其他任何独立的内容。除了内容部分，一个article元素通常有它自己的标题（一般放在一个header元素里面），有时还有自己的脚注</p>
</li>
<li><p>section元素的作用是对页面上的内容进行分块，或者说对文章进行分段；一个section元素通常由内容及其标题组成，通常不推荐为那些没有标题的内容使用section元素</p>
</li>
</ul>
<h3 id="2-HTML5新标签"><a href="#2-HTML5新标签" class="headerlink" title="2.HTML5新标签"></a>2.HTML5新标签</h3><pre><code>&lt;header&gt; &lt;footer&gt; &lt;nav&gt; &lt;aside&gt; &lt;aduio&gt; &lt;video&gt; &lt;canvas&gt;</code></pre>
<h3 id="3-html5语义化"><a href="#3-html5语义化" class="headerlink" title="3.html5语义化"></a>3.html5语义化</h3><p>表示选择合适的标签（语义化标签）便于开发者阅读和写出更优雅的代码</p>
<h3 id="4-html5新特性"><a href="#4-html5新特性" class="headerlink" title="4.html5新特性"></a>4.html5新特性</h3><p>HTML5新特性有哪些？</p>
<pre><code>语义化标签
音视频处理
canvas / webGL
history API
requestAnimationFrame
地理位置
webSocket</code></pre>
<h3 id="5-对WEB标准和W3C的理解认识"><a href="#5-对WEB标准和W3C的理解认识" class="headerlink" title="5.对WEB标准和W3C的理解认识"></a>5.对WEB标准和W3C的理解认识</h3><p>个人理解：</p>
<pre><code>html - 表示人的光身体 ---结构
css - 表示给人穿的衣服 ---表现
js - 表示人的行为，走路等 ---行为</code></pre>
<p>web简单来说可以分为结构、表现和行为。</p>
<ul>
<li>其中结构主要是由HTML标签组成。</li>
<li>表现是指css样式表，可用通过css使页面标签更具美感。</li>
<li>行为是指用户和页面有一定的交互，同时结构和表现也会发生变化，主要由js组成</li>
</ul>
<p>web标准一般是将该三部分独立分开，使其更具有模块化。但一般产生行为时，就会有结构或者表现的变化，也使这三者的界限并不那么清晰。</p>
<p>W3C对web标准提出了规范化的要求，也就是在实际编程中的<br>一些代码规范：</p>
<pre><code>1.对于结构要求（标签规范可以提高搜索引擎对页面的抓取率，对seo很有帮助）：
    标签要小写
    标签要闭合
    标签不能随意嵌套

2.对于css和js来说：
    使用外链css和js，使结构、表现、行为三者分离。
    提高页面渲染速度，提高用户体验

    尽量少使用行内样式，使结构和表现分离，标签的id和class要见文知意，标签越少，加载越快，用户体验越高

    不需要变动页面内容，便可提供打印版本而不需要复制内容，提高网站易用性。</code></pre>
<h3 id="6-什么是DOCTYPE及作用"><a href="#6-什么是DOCTYPE及作用" class="headerlink" title="6.什么是DOCTYPE及作用"></a>6.什么是DOCTYPE及作用</h3><p>DTD（document type definition，文档类型定义）是一系列的语法规则，用来定义XML或（X）HTML的文件类型。浏览器会使用它来判断文档类型，决定使用何种协议来解析以及切换浏览器模式。（DTD告诉浏览器我是什么文档类型，浏览器会根据这个来判断用什么引擎来解析和渲染他们）</p>
<p>DOCTYPE是用来声明文档类型和DTD规范的，一个主要的用途便是文件的合法性验证。如果文件代码不合法，那么浏览器解析时会出一些错误。（DOCTYPE告诉浏览器当前是哪个文档类型）</p>
<!DOCTYPE html><p>作用：<br>告诉浏览器用哪种HTML版本的规范来解析HTML文档</p>
<h2 id="二-CSS"><a href="#二-CSS" class="headerlink" title="二.CSS"></a>二.CSS</h2><h3 id="1-盒模型"><a href="#1-盒模型" class="headerlink" title="1.盒模型"></a>1.盒模型</h3><ul>
<li>组成：border+padding+content+margin</li>
<li>标准盒模型：width: content  box-sizing: content-box</li>
<li>怪异盒模型/IE：width: content+padding+border  box-sizing:border-box</li>
</ul>
<h3 id="2-rem和em的区别"><a href="#2-rem和em的区别" class="headerlink" title="2.rem和em的区别"></a>2.rem和em的区别</h3><p>rem是根据根元素的font-size变化，em是根据父元素的font-size变化</p>
<ul>
<li>rem：相对于根元素html的font-size，假如html为font-size：12px，那么，在其当中的div设置为font-size：2rem,就是当中的div为24px</li>
<li>em：相对于当前对象内文本的字体大小计算，假如某个p元素为font-size:12px,在它内部有个span标签继承p元素字体大小，设置font-size：2em,那么，这时候的span字体大小为：12*2=24px</li>
</ul>
<h3 id="3-常见单位"><a href="#3-常见单位" class="headerlink" title="3.常见单位"></a>3.常见单位</h3><ol>
<li>px：绝对单位，页面按精确像素展示</li>
<li>em：相对单位，基准点为当前对象内文本的字体大小，整个页面内1em不是一个固定的值</li>
<li>rem：相对单位，可理解为”root em”, 相对根节点html的字体大小来计算，CSS3新加属性，chrome/firefox/IE9+支持</li>
<li>vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%</li>
<li>vh：viewpoint height，视窗高度，1vh等于视窗高度的1%</li>
<li>vmin：vw和vh中较小的那个</li>
<li>vmax：vw和vh中较大的那个</li>
<li>%:百分比</li>
</ol>
<h3 id="4-移动端视口配置"><a href="#4-移动端视口配置" class="headerlink" title="4.移动端视口配置"></a>4.移动端视口配置</h3><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,
initial-scale=1.0,minimum-scale=1.0,
maximum-scale=1.0,user-scalable=no&quot;&gt;
initial-scale：初始的缩放比例
minimum-scale：允许用户缩放到的最小比例
maximum-scale：允许用户缩放到的最大比例
user-scalable：用户是否可以手动缩放</code></pre>
<h3 id="5-渐进增强与优雅降级的理解及区别"><a href="#5-渐进增强与优雅降级的理解及区别" class="headerlink" title="5.渐进增强与优雅降级的理解及区别"></a>5.渐进增强与优雅降级的理解及区别</h3><ul>
<li><p>渐进增强（Progressive Enhancement）：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。</p>
</li>
<li><p>优雅降级（Graceful Degradation）：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行hack 使其可以在低版本浏览器上正常浏览。</p>
</li>
</ul>
<p>两者区别？</p>
<p>1、广义：<br>其实要定义一个基准线，在此之上的增强叫做渐进增强，在此之下的兼容叫优雅降级<br>2、狭义：<br>渐进增强一般说的是使用CSS3技术，在不影响老浏览器的正常显示与使用情形下来增强体验，而优雅降级则是体现html标签的语义，以便在js/css的加载失败/被禁用时，也不影响用户的相应功能</p>
<h3 id="6-cookie、sessionStorage、localStorage区别"><a href="#6-cookie、sessionStorage、localStorage区别" class="headerlink" title="6.cookie、sessionStorage、localStorage区别"></a>6.cookie、sessionStorage、localStorage区别</h3><p>相同点：</p>
<ul>
<li>都是保存在浏览器端、且同源的</li>
</ul>
<p>不同点：</p>
<ul>
<li><p>cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下</p>
</li>
<li><p>存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M+</p>
</li>
<li><p>cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除</p>
</li>
<li><p>cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地</p>
</li>
<li><p>作用域不同，sessionStorage在不同的浏览器窗口中不共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的</p>
</li>
</ul>
<h3 id="7-css选择器"><a href="#7-css选择器" class="headerlink" title="7.css选择器"></a>7.css选择器</h3><ul>
<li><p>常用css选择器</p>
<p>  id选择器   #header<br>  类选择器   .header<br>  元素选择器  div<br>  通配符     *<br>  后代选择器  div p, p a<br>  儿子选择器  div &gt; span<br>  兄弟选择器  div + p, h2 ~ h3<br>  伪类选择器  a:hover<br>  属性选择器  input[type=”text”]<br>  伪元素选择器  p::before  p::first-line</p>
</li>
<li><p>css选择器权重</p>
<p>  !important &gt; id &gt; class &gt; 元素和伪元素 &gt; * &gt; 继承 &gt;默认</p>
</li>
</ul>
<h3 id="8-css3新特性"><a href="#8-css3新特性" class="headerlink" title="8.css3新特性"></a>8.css3新特性</h3><ul>
<li>transition 过渡</li>
<li>transform   旋转 倾斜 移动 缩放</li>
<li>animation   动画</li>
<li>shadow  阴影</li>
<li>grdient 渐变</li>
<li>border-radius   圆角</li>
</ul>
<h3 id="9-行内元素和块级元素"><a href="#9-行内元素和块级元素" class="headerlink" title="9.行内元素和块级元素"></a>9.行内元素和块级元素</h3><ul>
<li><p>行内元素（display: inline）:</p>
<ul>
<li>设置宽高无效，宽度和高度由内容决定</li>
<li>设置margin左右有效，上下无效，padding都有效</li>
<li>不会自动换行</li>
<li>有span,img,input,a,b,sub,sup,i</li>
</ul>
</li>
<li><p>块级元素(display:block):</p>
<ul>
<li>可以设置宽高</li>
<li>margin和padding都有效</li>
<li>自动换行</li>
<li>多个块元素写一起，排列从上到下</li>
<li>由div,p,nav,h,footer,main,header等</li>
</ul>
</li>
<li><p>行内块元素（display:inline-block）</p>
<ul>
<li>能够设置宽高</li>
<li>margin/padding都有效</li>
<li>不会自动换行</li>
<li>默认排列方式从左到右</li>
</ul>
</li>
</ul>
<h3 id="10-css的position的定位"><a href="#10-css的position的定位" class="headerlink" title="10.css的position的定位"></a>10.css的position的定位</h3><p>relative  absolute  fixed  static</p>
<ul>
<li>绝对定位： absolute和fiexed统称为绝对定位</li>
<li>相对定位： relative</li>
<li>默认值：static<br>相对定位和绝对定位的区别：</li>
<li>relative：<br>相对于自身位置定位，仍处于文档流中，元素的宽高不变，设置偏移量也不会影响其他元素的位置，如果最外层设置relative，在没有设置宽度情况，元素宽度是整个浏览器的宽度</li>
<li>absolute：<br>相对于离自己最近的设置了相对或绝对定位的父元素定位，如果没有父元素设置相对和绝对定位，则相对于跟元素html定位，设置了绝对定位的元素脱离了文档流，如果没有设置宽高由元素内容决定，脱离后元素位置是空的下面的元素会占据</li>
<li>fixed：<br>相对于浏览器窗口定位,如果没有设置宽高由元素内容决定。</li>
</ul>
<h3 id="11-Flex布局"><a href="#11-Flex布局" class="headerlink" title="11.Flex布局"></a>11.Flex布局</h3><p>Flexbox为Flexible box缩写，“弹性布局”，任何一个元素都能设置弹性布局包含两部分，一个为容器，一个为项目<br>水平的主轴（main axis）和垂直的交叉轴（cross axis）<br>主轴的排列方式：从左到右；交叉轴的排列方式：从上到下;</p>
<p>容器的属性：</p>
<ul>
<li>flex-direction:主轴的方向-row/row-reverse/column/column-reverse</li>
<li>flex-wrap:项目排列方式是否换行–nowrap/wrap/wrap-reverse</li>
<li>flex-flow:direction和wrap的缩写</li>
<li>justify-content:项目在主轴排列方式–flex-start/flex-end/center/space-between/space-around</li>
<li>align-items:项目在交叉轴的如何对齐-flex-start/flex-end/center/baseline/stretch</li>
</ul>
<p>项目属性：</p>
<ul>
<li>order：number （数值越小越靠前，默认为0）项目排列顺序</li>
<li>flex-grow ：number（默认0，如果有剩余空间也不放大，值为1放大，2是1的双倍大小，此类推）定义项目放大比例</li>
<li>flex-shrink ：number （默认为1，如果空间不足则会缩小，值为0不能缩小）项目缩小比例</li>
<li>flex-basis ：number/auto （默认auto，可设置固定的值50px/50%）定义项目自身的大小</li>
<li>flex：属性是flex-grow，flex-shrink ,flex-basis的简写，默认值为0、1、auto</li>
<li>align-self ：auto | flex-start | flex-end | center | baseline | stretch项目自身对齐</li>
</ul>
<h3 id="12-display有哪些值？说明他们的作用"><a href="#12-display有哪些值？说明他们的作用" class="headerlink" title="12.display有哪些值？说明他们的作用?"></a>12.display有哪些值？说明他们的作用?</h3><ul>
<li>inline（默认）–内联</li>
<li>none–隐藏</li>
<li>block–块显示</li>
<li>table–表格显示</li>
<li>list-item–项目列表</li>
<li>inline-block-内联块</li>
</ul>
<h3 id="13-BFC"><a href="#13-BFC" class="headerlink" title="13.BFC"></a>13.BFC</h3><p>BFC块格式化上下文，是Web页面的可视CSS渲染的一部分.是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p>
<p>下列方式会创建块格式化上下文</p>
<pre><code>    根元素html
    浮动元素（元素的float不是none）
    绝对定位元素（元素的display为absolute或fixed）
    行内块元素（display：inline-block）
    表格单元格（display：table-cell）
    表格标题（display：table-caption）
    匿名表格单元格元素（display：table/table-row/table-row-group/table-header-group/table-footer-group或inline-table）
    overflow计算值不为visible的块元素
    display值为flow-root的元素
    contain值为layout/content/paint的元素
    弹性元素（display为flex或inline-flex 元素的直接子元素）
    网格元素（display为grid或inline-grid 元素的直接子元素）
    多列容器（元素的column-count或column-width部位auto）
    column-span为all的元素始终会创建一个新的BFC，即使该元素没有包裹一个多列容器中。</code></pre>
<p>BFC布局规则：</p>
<pre><code>    内部的box会在垂直方向，一个一个排列
    Box垂直方向的距离由margin决定，同一个BFC内相邻的两个box的margin值会重叠
    每个元素的margin box的左边与border box的左边相接触，即使浮动也如此
    BFC区域不和float box区域重叠
    BFC是页面上一个独立的容器，内部子元素不回对外部元素产生影响
    计算BFC高度时，浮动元素也参与计算</code></pre>
<p>BFC的使用场景？</p>
<pre><code>去除边距重叠现象
清除浮动（让父元素的高度包含子浮动元素）
避免某元素被浮动元素覆盖
避免多列布局由于宽度计算四舍五入而自动换行</code></pre>
<h3 id="14-水平垂直居中"><a href="#14-水平垂直居中" class="headerlink" title="14.水平垂直居中"></a>14.水平垂直居中</h3><pre><code>水平居中： margin:0 auto;text-align:center;flex:justify-content
垂直居中：line-height;flex:align-items
水平垂直居中：flex;absolute+margin负；absolute+translate负</code></pre>
<h3 id="15-Sass、Less、Stylus区别"><a href="#15-Sass、Less、Stylus区别" class="headerlink" title="15.Sass、Less、Stylus区别"></a>15.Sass、Less、Stylus区别</h3><p>什么是CSS预处理器?<br>CSS预处理器是一种语言用来为CSS增加一些编程的特性，无需考虑浏览器兼容问题，例如你可以在CSS中使用变量，简单的程序逻辑、函数等在编程语言中的一些基本技巧，可以让CSS更加简洁，适应性更强，代码更直观等诸多好处</p>
<ul>
<li><p>基本语法区别<br>  Sass是以.sass为扩展名，Less是以.less为扩展名，Stylus是以.styl为扩展名</p>
</li>
<li><p>变量的区别<br>  Sass 变量必须是以$开头的，然后变量和值之间使用冒号（：）隔开，和css属性是一样的。<br>  Less 变量是以@开头的，其余sass都是一样的。<br>  Stylus 对变量是没有任何设定的，可以是以$开头或者任意字符，而且变量之间可以冒号，空格隔开，但是在stylus中不能用@开头</p>
</li>
</ul>
<p>三种预处理器都有：嵌套、运算符、颜色函数、导入、继承、混入。Stylus还有一些高级特性。例如循环、判断等</p>
<h3 id="16-display-none与visibility-hidden的区别"><a href="#16-display-none与visibility-hidden的区别" class="headerlink" title="16.display: none与visibility: hidden的区别"></a>16.display: none与visibility: hidden的区别</h3><pre><code>display：none 不显示对应的元素，在文档布局中不再分配空间（回流+重绘）

visibility：hidden 隐藏对应元素，在文档布局中仍保留原来的空间（重绘）</code></pre>
<h3 id="17-重绘-amp-回流"><a href="#17-重绘-amp-回流" class="headerlink" title="17.重绘 &amp; 回流"></a>17.重绘 &amp; 回流</h3><p>浏览器渲染过程如下：</p>
<ul>
<li>解析HTML，生成DOM树，解析CSS，生成CSSOM树</li>
<li>将DOM树和CSSOM树结合，生成渲染树(Render Tree)</li>
<li>Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）</li>
<li>Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</li>
<li>Display:将像素发送给GPU，展示在页面上</li>
</ul>
<p>通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流</p>
<p>我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。</p>
<p>何时发生回流重绘</p>
<ul>
<li>添加或删除可见的DOM元素</li>
<li>元素的位置发生变化</li>
<li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li>
<li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。</li>
<li>页面一开始渲染的时候（这肯定避免不了）</li>
<li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）</li>
</ul>
<p>注意：回流一定会触发重绘，而重绘不一定会回流根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。</p>
<p>当你获取布局信息的操作的时候，会强制队列刷新</p>
<p>最小化重绘和重排：</p>
<p>  批量修改DOM：<br>  使元素脱离文档流<br>  对其进行多次修改<br>  将元素带回到文档中。</p>
<p>有三种方式可以让DOM脱离文档流：</p>
<p>  隐藏元素，应用修改，重新显示<br>  使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。<br>  将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。</p>
<h3 id="18-防抖（debounce）"><a href="#18-防抖（debounce）" class="headerlink" title="18.防抖（debounce）"></a>18.防抖（debounce）</h3><p>防抖就是在触发事件n秒内函数只执行一次，如果在n秒内又触发了事件，就重新计时<br>如下，鼠标移动时，计数：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height:150px;line-height:150px;text-align:center; color: #fff;background-color:#ccc;font-size:80px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> num = <span class="number">1</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> content = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;content&#x27;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">  content.innerHTML = num++;</span><br><span class="line">&#125;;</span><br><span class="line">content.onmousemove = count;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>防抖函数分为非立即执行版和立即执行版</p>
<p>非立即执行版：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func,wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(timeout)&#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        &#125;</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            func.apply(context,args)</span><br><span class="line">        &#125;,wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在触发事件后函数 1 秒后才执行，而如果我在触发事件后的 1秒内又触发了事件，则会重新计算函数执行时间<br>content.onmousemove = debounce(count,1000);</p>
<p>let context = this;<br>let args = arguments;<br>防抖函数的代码使用这两行代码来获取 this 和参数，是为了让 debounce 函数最终返回的函数 this指向不变以及依旧能接受到 e 参数</p>
<p>立即执行版：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func,wait</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(timeout)&#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> callNow = !timeout;</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      timeout = <span class="literal">null</span></span><br><span class="line">    &#125;,wait)</span><br><span class="line">    <span class="keyword">if</span> (callNow) func.apply(context, args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。</p>
<h3 id="19-节流（throttle）"><a href="#19-节流（throttle）" class="headerlink" title="19.节流（throttle）"></a>19.节流（throttle）</h3><p>连续触发函数在n秒内只执行一次，稀释了函数的执行频率<br>时间戳版：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func,wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span>(now-previous &gt; wait)&#123;</span><br><span class="line">            func.apply(context,args);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">content.onmousemove = throttle(count,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>在持续触发事件的过程中，函数会立即执行，并且每 1s 执行一次</p>
<p>定时器版：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func,wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = argments;</span><br><span class="line">        <span class="keyword">if</span>(!timeout)&#123;</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            timeout = <span class="literal">null</span>;</span><br><span class="line">            func.apply(context, args)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在持续触发事件的过程中，函数不会立即执行，并且每1s 执行一次，在停止触发事件后，函数还会再执行一次。</p>
<p>时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候。</p>
<h3 id="20-获取盒子宽高的几种方式及区别"><a href="#20-获取盒子宽高的几种方式及区别" class="headerlink" title="20.获取盒子宽高的几种方式及区别"></a>20.获取盒子宽高的几种方式及区别</h3><ul>
<li><p>dom.style.width/height<br>这种方式只能取到dom元素内联样式所设置的宽高，也就是说如果该节点的样式是在style标签中或外联的CSS文件中设置的话，通过这种方法是获取不到dom的宽高的</p>
</li>
<li><p>dom.currentStyle.width/height<br>获取渲染后的宽高。但是仅IE支持</p>
</li>
<li><p>window.getComputedStyle(dom).width/height<br>与2原理相似，但是兼容性，通用性更好一些</p>
</li>
<li><p>dom.getBoundingClientRect().width/height<br>计算元素绝对位置，获取到四个元素left,top,width,height</p>
</li>
</ul>
<p>扩展：获取浏览器高度和宽度的兼容性写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  w = <span class="built_in">window</span>.innerWidth || <span class="built_in">document</span>.documentElement.clientWidth || <span class="built_in">document</span>.body.clientWidth</span><br><span class="line"><span class="keyword">var</span>  h = <span class="built_in">window</span>.innerHeight || <span class="built_in">document</span>.documentElement.clientHeight || <span class="built_in">document</span>.body.clientHeight</span><br></pre></td></tr></table></figure>
<h3 id="21-link和import区别"><a href="#21-link和import区别" class="headerlink" title="21.link和import区别"></a>21.link和import区别</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line"><span class="keyword">@import</span> url(CSS文件路径地址);</span><br><span class="line">&lt;/<span class="selector-tag">style</span>&gt;</span><br><span class="line">&lt;link href=&quot;CSSurl路径&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>import是css提供的语法规则，只有导入样式表的作用，link是html的标签，不仅可以加载样式还可以设置rel type等属性</li>
<li>import是css2才引入等，只支持ie5+，而link没有兼容问题</li>
<li>import在页面加载完毕才引入，link在加载页面时引入</li>
<li>link可用dom操作引入link加载样式</li>
</ul>
<h3 id="22-多行元素省略号"><a href="#22-多行元素省略号" class="headerlink" title="22.多行元素省略号"></a>22.多行元素省略号</h3><pre><code>overflow : hidden;
text-overflow: ellipsis;
display: -webkit-box;
-webkit-line-clamp: 3;
-webkit-box-orient: vertical</code></pre>
<h2 id="三-JS"><a href="#三-JS" class="headerlink" title="三.JS"></a>三.JS</h2><h3 id="1-JS的基本数据类型"><a href="#1-JS的基本数据类型" class="headerlink" title="1.JS的基本数据类型"></a>1.JS的基本数据类型</h3><p><code>Number</code>  <code>String</code>  <code>Boolean</code>  <code>Null</code>  <code>undefined</code> 新增<code>Symbol</code></p>
<h3 id="2-几种判断数据类型的优缺点"><a href="#2-几种判断数据类型的优缺点" class="headerlink" title="2.几种判断数据类型的优缺点"></a>2.几种判断数据类型的优缺点</h3><p>一、typeof</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">1</span>);               <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>);            <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">&#x27;mc&#x27;</span>);           <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);    <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> []);              <span class="comment">// object </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;);              <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>);            <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>);       <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>优点：能够快速区分基本数据类型 缺点：不能将Object、Array和Null区分，都返回object</p>
<p>二、instanceof</p>
<p>instanceof用来检测构造函数的prototype属性是否存在某实例对象的原型链上</p>
<p>语法：object instanceof constructor<br>参数：<br>object:某个实例对象<br>constructor:某个构造函数<br>描述：二、instanceof用来检测constructor.prototype属性是否存在在object的原型链上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>);                    <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);                <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>);                <span class="comment">// false  </span></span><br><span class="line"><span class="built_in">console</span>.log([] <span class="keyword">instanceof</span> <span class="built_in">Array</span>);                    <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Function</span>);       <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>);                   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>优点：能够区分Array、Object和Function，适合用于判断自定义的类实例对象 缺点：Number，Boolean，String基本数据类型不能判断</p>
<p>三、Object.prototype.toString.call()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="number">1</span>));                      <span class="comment">//[object Number]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="literal">true</span>));                   <span class="comment">//[object Boolean]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="string">&#x27;mc&#x27;</span>));                  <span class="comment">//[object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call([]));                     <span class="comment">//[object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(&#123;&#125;));                     <span class="comment">//[object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;));           <span class="comment">//[object Function]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="literal">undefined</span>));              <span class="comment">//[object Undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(toString.call(<span class="literal">null</span>));                   <span class="comment">//[object Null]</span></span><br></pre></td></tr></table></figure>
<p>优点：精准判断数据类型 缺点：写法繁琐不容易记，推荐进行封装后使用</p>
<h3 id="3-null和undefined的区别"><a href="#3-null和undefined的区别" class="headerlink" title="3.null和undefined的区别"></a>3.null和undefined的区别</h3><pre><code>undefined是访问一个未初始化的变量时返回的值，而null是访问一个尚未存在的对象时所返回的值。

undefined看作是空的变量，而null看作是空的对象</code></pre>
<h3 id="4-对象深浅拷贝"><a href="#4-对象深浅拷贝" class="headerlink" title="4.对象深浅拷贝"></a>4.对象深浅拷贝</h3><p>一、深拷贝</p>
<ul>
<li>1.1 最简单的方法就是JSON.parse(JSON.stringify())<br>但是这种拷贝方法不可以拷贝一些特殊的属性（例如正则表达式，undefine，function）</li>
<li>1.2 用递归去复制所有层级属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopyTwo</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> objClone = <span class="built_in">Array</span>.isArray(obj) ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (obj &amp;&amp; <span class="keyword">typeof</span> obj == <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">          <span class="comment">//判断obj子元素是否为对象，如果是，递归复制</span></span><br><span class="line">          <span class="keyword">if</span> (obj[key] &amp;&amp; <span class="keyword">typeof</span> obj[key] === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">              objClone[key] = deepCopyTwo(obj[key]);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//如果不是，简单复制</span></span><br><span class="line">              objClone[key] = obj[key];</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> objClone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二、浅拷贝</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(target, ...sources)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        result[i] = obj[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-数组基本方法"><a href="#5-数组基本方法" class="headerlink" title="5.数组基本方法"></a>5.数组基本方法</h3><ul>
<li><p>push()：将参数逐个添加到数组尾部，返回修改后的数组长度</p>
</li>
<li><p>unshift()：将参数逐个添加到数组前端，返回修改后的数组长度</p>
</li>
<li><p>pop()：移除数组中的最后一项，返回移除的项</p>
</li>
<li><p>shift()：移除数组中的第一项，返回移除的项</p>
</li>
</ul>
<p>push pop shift unshift 都会直接改变原数组</p>
<ul>
<li><p>map: 遍历数组，返回回调返回值组成的新数组</p>
</li>
<li><p>forEach: 无法break，可以用try/catch中throw new Error来停止</p>
</li>
<li><p>filter: 过滤</p>
</li>
<li><p>some: 有一项返回true，则整体为true</p>
</li>
<li><p>every: 有一项返回false，则整体为false</p>
</li>
<li><p>join: 通过指定连接符生成字符串</p>
</li>
<li><p>concat: 连接数组，不影响原数组， 浅拷贝</p>
</li>
<li><p>slice(start, end): 返回截断后的新数组，不改变原数组</p>
</li>
<li><p>splice(start, number, value…):返回删除元素组成的数组，value 为插入项，改变原数组</p>
</li>
<li><p>indexOf / lastIndexOf(value, fromIndex): 查找数组项，返回对应的下标</p>
</li>
<li><p>reduce / reduceRight(fn(prev, cur)， defaultPrev): 两两执行，prev 为上次化简函数的return值,cur 为当前值(从第二项开始)</p>
</li>
</ul>
<p>map和forEach的区别：</p>
<p>1.都用来遍历数组，map速度比forEach快<br>2.map返回回调返回值组成的新数组，不会对原数组产生影响，forEach没有返回值，不能return或者break<br>3.map返回数组，所以可以链式调用</p>
<h3 id="6-js有那些内置对象"><a href="#6-js有那些内置对象" class="headerlink" title="6.js有那些内置对象"></a>6.js有那些内置对象</h3><p>Object是JavaScript中所有对象的父对象</p>
<p>数据封装对象：Object、Array、Boolean、Number和String<br>其他对象：Function、Arguments、Math、Date、RegExp、Error</p>
<h3 id="7-get请求传参长度的误区"><a href="#7-get请求传参长度的误区" class="headerlink" title="7.get请求传参长度的误区"></a>7.get请求传参长度的误区</h3><ul>
<li>HTTP 协议 未规定 GET 和POST的长度限制</li>
<li>GET的最大长度显示是因为 浏览器和 web服务器限制了 URI的长度</li>
<li>不同的浏览器和WEB服务器，限制的最大长度不一样</li>
<li>要支持IE，则最大长度为2083byte，若只支持Chrome，则最大长度 8182byte</li>
</ul>
<p>补充get和post请求在缓存方面的区别</p>
<ul>
<li>get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存</li>
<li>post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。</li>
</ul>
<h3 id="8-同步任务和异步任务"><a href="#8-同步任务和异步任务" class="headerlink" title="8.同步任务和异步任务"></a>8.同步任务和异步任务</h3><ul>
<li><p>同步任务：在主线程上执行的任务，只有前一个任务执行完，才能执行下一个任务</p>
</li>
<li><p>异步任务：不进入主线程而进入“任务队列”的任务，只有任务队列通知主线程，某个任务可以执行了，该任务才会进入主线程执行。</p>
<p>  异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）：<br>  1）所以同步任务都在主线程执行，形成一个执行栈<br>  2）主线程之外，还有一个任务队列，只要异步任务有了执行结果，就在任务队列放置一个事件<br>  3）一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列，看看有哪些事件，对应的事件就结束等待状态，进入执行栈进行执行<br>  4）主线程不断重复第三步</p>
<p>  主线程从“任务队列”中读取事件，这个事件是循环不断的，又称为事件循环（Event loop）</p>
</li>
</ul>
<h3 id="9-事件和回调函数"><a href="#9-事件和回调函数" class="headerlink" title="9.事件和回调函数"></a>9.事件和回调函数</h3><p>“任务队列”就是一个事件的队列，当IO设备完成一项任务，就在“任务队列”中添加一个事件，表示相关的异步任务可以进入执行栈了，主线程读取“任务队列”，就是读取有哪些事件</p>
<p>“回调函数”（callback）就是被主线程挂起来的代码。异步任务必须指定回调函数，主线程执行异步任务就是执行对应的回调函数。</p>
<h3 id="10-定时器"><a href="#10-定时器" class="headerlink" title="10.定时器"></a>10.定时器</h3><p>定时器功能主要由setTimeout()和setInterval()这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者则为反复执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">2</span>);&#125;,<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码的执行结果是1，3，2，因为setTimeout()将第二行推迟到1000毫秒之后执行。</p>
<p>如果将setTimeout()的第二个参数设为0，就表示当前代码执行完（执行栈清空）以后，立即执行（0毫秒间隔）指定的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>);&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码的执行结果总是2，1，因为只有在执行完第二行以后，系统才会去执行”任务队列”中的回调函数。</p>
<p>setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行</p>
<p>HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加.需要注意的是，setTimeout()只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行</p>
<p>除了setTimeout和setInterval这两个方法，Node.js还提供了另外两个与”任务队列”有关的方法：process.nextTick和setImmediate。</p>
<ul>
<li><p>process.nextTick方法可以在当前”执行栈”的尾部—-下一次Event Loop（主线程读取”任务队列”）之前—-触发回调函数。也就是说，它指定的任务总是发生在所有异步任务之前。setImmediate方法则是在当前”任务队列”的尾部添加事件，也就是说，它指定的任务总是在下一次EventLoop时执行，这与setTimeout(fn, 0)很像</p>
</li>
<li><p>process.nextTick和setImmediate的一个重要区别：多个process.nextTick语句总是在当前”执行栈”一次执行完，多个setImmediate可能则需要多次loop才能执行完</p>
</li>
</ul>
<p>另外，由于process.nextTick指定的回调函数是在本次”事件循环”触发，而setImmediate指定的是在下次”事件循环”触发，所以很显然，前者总是比后者发生得早，而且执行效率也高（因为不用检查”任务队列”）。</p>
<h3 id="11-进程和线程"><a href="#11-进程和线程" class="headerlink" title="11.进程和线程"></a>11.进程和线程</h3><p>进程和线程是操作系统的基本概念</p>
<p>单个cpu一次只能运行一个任务，任一时刻，CPU总是运行一个进程，其他进程处于非运行状态</p>
<ul>
<li>一个进程可用包含多个线程</li>
<li>一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。</li>
<li>一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。”互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。</li>
</ul>
<p>某些内存区域，只能供给固定数目的线程使用。”信号量”（Semaphore），用来保证多个线程不会互相冲突</p>
<p>操作系统的设计，因此可以归结为三点：</p>
<pre><code>（1）以多进程形式，允许多个任务同时运行；

（2）以多线程形式，允许单个任务分成不同的部分运行；

（3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源</code></pre>
<h3 id="12-axios在vue-js中应用和特点"><a href="#12-axios在vue-js中应用和特点" class="headerlink" title="12.axios在vue.js中应用和特点"></a>12.axios在vue.js中应用和特点</h3><p>axios是基于promise的http请求客户端，可用在浏览器和node。js中使用</p>
<p>使用场景：结合vue.js发送请求，拦截请求</p>
<p>特点：<br>    1.基于promise<br>    2.拦截请求和响应<br>    3.转换请求和响应的数据<br>    4.可在node.js中使用</p>
<p>安装：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save axios</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> ‘axios’</span><br></pre></td></tr></table></figure>
<p>结合Vue.js的请求响应拦截器：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求拦截</span></span><br><span class="line">axios.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (config.url.indexOf(<span class="string">&#x27;/oauth/token?grant_type=password&#x27;</span>) != -<span class="number">1</span>) &#123;</span><br><span class="line">    config.headers[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="string">&#x27;Basic Y2xpOnNlYw==&#x27;</span></span><br><span class="line">    <span class="comment">// config.headers[&#x27;Content-Type&#x27;] = &#x27;application/json;charset-UTF-8&#x27;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getToken()) &#123;</span><br><span class="line">    config.headers[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="string">&#x27;Bearer &#x27;</span> + getToken() + <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Do something with request error</span></span><br><span class="line">  <span class="built_in">console</span>.log(error) <span class="comment">// for debug</span></span><br><span class="line">  <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截</span></span><br><span class="line">axios.interceptors.response.use(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.data.code !== <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (res.data.code) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;401&#x27;</span>:</span><br><span class="line">        <span class="built_in">window</span>.location.href = <span class="string">&#x27;/login&#x27;</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;403&#x27;</span>:</span><br><span class="line">        Notification.error(&#123;</span><br><span class="line">          title: <span class="string">&#x27;错误：403&#x27;</span>,</span><br><span class="line">          message: <span class="string">&#x27;访问拒绝&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;404&#x27;</span>:</span><br><span class="line">        Notification.error(&#123;</span><br><span class="line">          title: <span class="string">&#x27;错误：404&#x27;</span>,</span><br><span class="line">          message: <span class="string">&#x27;找不到网络资源&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;500&#x27;</span>:</span><br><span class="line">        Notification.error(&#123;</span><br><span class="line">          title: <span class="string">&#x27;错误：500&#x27;</span>,</span><br><span class="line">          message: res.data.error.errorMsg</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.data</span><br><span class="line">&#125;, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err.response) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (err.response.status) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;401&#x27;</span>:</span><br><span class="line">        <span class="built_in">window</span>.location.href = <span class="string">&#x27;/login&#x27;</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;403&#x27;</span>:</span><br><span class="line">        Notification.error(&#123;</span><br><span class="line">          title: <span class="string">&#x27;错误：403&#x27;</span>,</span><br><span class="line">          message: <span class="string">&#x27;访问拒绝&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;404&#x27;</span>:</span><br><span class="line">        Notification.error(&#123;</span><br><span class="line">          title: <span class="string">&#x27;错误：404&#x27;</span>,</span><br><span class="line">          message: <span class="string">&#x27;找不到网络资源&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;500&#x27;</span>:</span><br><span class="line">        Notification.error(&#123;</span><br><span class="line">          title: <span class="string">&#x27;错误：500&#x27;</span>,</span><br><span class="line">          message: <span class="string">&#x27;服务器出错&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求封装</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">_axios</span> (<span class="params">method, url, params</span>) </span>&#123;</span><br><span class="line">  method = method.toUpperCase()</span><br><span class="line">  <span class="keyword">var</span> options = &#123;</span><br><span class="line">    method: method,</span><br><span class="line">    url: url,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json;charset=UTF-8&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (method === <span class="string">&#x27;POST&#x27;</span> || method === <span class="string">&#x27;PATCH&#x27;</span> || method === <span class="string">&#x27;PUT&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (params) &#123;</span><br><span class="line">      options.data = params</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> axios(options)</span><br><span class="line">      .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">      &#125;, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> error</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (method === <span class="string">&#x27;GET&#x27;</span> || method === <span class="string">&#x27;DELETE&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (params) &#123;</span><br><span class="line">      options.params = params</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> axios(options)</span><br><span class="line">      .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">      &#125;, <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> error</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-HTTP中定义请求方式"><a href="#13-HTTP中定义请求方式" class="headerlink" title="13.HTTP中定义请求方式"></a>13.HTTP中定义请求方式</h3><ul>
<li><p>get</p>
</li>
<li><p>post</p>
</li>
<li><p>put</p>
</li>
<li><p>delete</p>
</li>
<li><p>trace</p>
</li>
<li><p>options</p>
</li>
<li><p>head</p>
</li>
</ul>
<p>1.get</p>
<p>get请求只是查询数据，不对数据库进行删改操作；请求会把参数放在url后面；http协议对url长度没有限制，有限制的是浏览器和服务器</p>
<p>2.post</p>
<p>post请求一般是对服务器的数据做改变，比如数据的提交，新增操作，请求参数放在请求体中</p>
<p>3.put</p>
<p>put和post一样都是对服务器数据对修改，但是put侧重于对数据的修改，而post是对数据的新增</p>
<p>4.delete</p>
<p>用来请求删除服务器的资源，但有可能删除不成功（取消delete请求）</p>
<p>5.options</p>
<p>options请求属于浏览器的预检请求，查看服务器是否接受请求，预检通过后，浏览器才会去发get，post，put，delete等，响应报文包含一个 Allow 首部字段，该字段的值表明了服务器支持的所有 HTTP 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Allow: OPTIONS, GET, HEAD, POST</span><br><span class="line">Cache-Control: max-age=<span class="number">604800</span></span><br><span class="line"><span class="built_in">Date</span>: Thu, <span class="number">13</span> Oct <span class="number">2016</span> <span class="number">11</span>:<span class="number">45</span>:<span class="number">00</span> GMT</span><br><span class="line">Expires: Thu, <span class="number">20</span> Oct <span class="number">2016</span> <span class="number">11</span>:<span class="number">45</span>:<span class="number">00</span> GMT</span><br><span class="line">Server: EOS (lax004/<span class="number">2813</span>)</span><br><span class="line">x-ec-custom-error: <span class="number">1</span></span><br><span class="line">Content-Length: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>在 CORS 中，可以使用 OPTIONS 方法发起一个预检请求，以检测实际请求是否可以被服务器所接受。预检请求报文中的 Access-Control-Request-Method首部字段告知服务器实际请求所使用的 HTTP方法；Access-Control-Request-Headers首部字段告知服务器实际请求所携带的自定义首部字段。服务器基于从预检请求获得的信息来判断，是否接受接下来的实际请求</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS /resources/post-here/ HTTP/<span class="number">1.1</span> </span><br><span class="line">Host: bar.other </span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;</span><br><span class="line">Accept-Language: en-us,en;q=<span class="number">0.5</span> </span><br><span class="line">Accept-Encoding: gzip,deflate </span><br><span class="line">Accept-Charset: ISO-<span class="number">8859</span>-<span class="number">1</span>,utf-<span class="number">8</span>;</span><br><span class="line">Connection: keep-alive </span><br><span class="line">Origin: http:<span class="comment">//foo.example </span></span><br><span class="line">Access-Control-Request-Method: POST </span><br><span class="line">Access-Control-Request-Headers: X-PINGOTHER, Content-Type</span><br></pre></td></tr></table></figure>
<p>服务器所返回的 Access-Control-Allow-Methods 首部字段将所有允许的请求方法告知客户端。该首部字段与 Allow 类似，但只能用于涉及到 CORS 的场景中。</p>
<pre><code>    Access-Control-Allow-Methods: POST, GET, OPTIONS 
    Access-Control-Allow-Headers: X-PINGOTHER, Content-Type </code></pre>
<p>6.head</p>
<p>与GET方法的行为很类似，但服务器在响应中只返回实体的主体部分</p>
<p>7.trace</p>
<p>会在目的服务器端发起一个“回环”诊断。这样客户端就可以查看HTTP请求报文在发送的途中，是否被修改过了</p>
<h3 id="14-get和post区别"><a href="#14-get和post区别" class="headerlink" title="14.get和post区别"></a>14.get和post区别</h3><ul>
<li><p>GET参数通过URL传递，POST放在Request body中。</p>
</li>
<li><p>GET请求会被浏览器主动cache，而POST不会，除非手动设置</p>
</li>
<li><p>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留</p>
</li>
<li><p>Get 请求中有非 ASCII 字符，会在请求之前进行转码，POST不用，因为POST在Request body中，通过 MIME，也就可以传输非 ASCII 字符</p>
</li>
<li><p>一般我们在浏览器输入一个网址访问网站都是GET请求,HTTP的底层是TCP/IP。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。但是请求的数据量太大对浏览器和服务器都是很大负担。所以业界有了不成文规定，（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。</p>
</li>
<li><p>GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）</p>
</li>
<li><p>在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。但并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次</p>
</li>
</ul>
<h3 id="15-http中content-type"><a href="#15-http中content-type" class="headerlink" title="15.http中content-type"></a>15.http中content-type</h3><p>MediaType，即是Internet Media Type，互联网媒体类型；也叫做MIME类型，在Http协议消息头中，使用Content-Type来表示具体请求中的媒体类型信息</p>
<p>常见的媒体格式类型如下：</p>
<ul>
<li>text/html ： HTML格式</li>
<li>text/plain ：纯文本格式</li>
<li>text/xml ：  XML格式</li>
<li>image/gif ：gif图片格式</li>
<li>image/jpeg ：jpg图片格式</li>
<li>image/png：png图片格式</li>
</ul>
<p>以application开头的媒体格式类型：</p>
<ul>
<li>application/xhtml+xml ：XHTML格式</li>
<li>application/xml     ： XML数据格式</li>
<li>application/atom+xml  ：Atom XML聚合格式</li>
<li>application/json    ： JSON数据格式</li>
<li>application/pdf       ：pdf格式  </li>
<li>application/msword  ： Word文档格式</li>
<li>application/octet-stream ： 二进制流数据（如常见的文件下载）</li>
<li>application/x-www-form-urlencoded ： <form encType=””>中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）</li>
</ul>
<p>另外一种常见的媒体格式是上传文件之时使用的：</p>
<ul>
<li>multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式</li>
</ul>
<h3 id="16-import和require区别"><a href="#16-import和require区别" class="headerlink" title="16.import和require区别"></a>16.import和require区别</h3><ul>
<li><p>加载方式<br>require：运行时加载，所以require理论上可以运用在代码的任何地方<br>import：编译时加载，import是编译时调用，所以必须放在文件开头</p>
</li>
<li><p>遵循规范<br>require 是 AMD规范引入方式<br>import是es6的一个语法标准，如果要兼容浏览器的话必须转化成es5的语法</p>
</li>
<li><p>本质<br>require是赋值过程，其实require的结果就是对象、数字、字符串、函数等，再把require的结果赋值给某个变量import是解构过程，但是目前所有的引擎都还没有实现import，我们在node中使用babel支持ES6，也仅仅是将ES6转码为ES5再执行，import语法会被转码为require</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="built_in">exports</span>.fs = fs</span><br><span class="line"><span class="built_in">module</span>.exports = fs</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> fs&#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;readFile&#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;readFile <span class="keyword">as</span> read&#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> fs, &#123;readFile&#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> fs</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fs</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">readFile</span></span></span><br><span class="line"><span class="function"><span class="title">export</span> </span>&#123;readFile, read&#125;</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="17-ajax"><a href="#17-ajax" class="headerlink" title="17.ajax"></a>17.ajax</h3><p>ajax是异步javascript和xml；<br>Ajax是一种用于创建快速动态网页的技术。</p>
<p>ajax的使用及实现步骤：<br>1.创建XMLHttpRequest对象,也就是创建一个异步调用对象.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlHttp;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;  <span class="comment">//针对除IE6以外的浏览器</span></span><br><span class="line">    xmlHttp=<span class="keyword">new</span> XMLHttpRequest(); <span class="comment">//实例化一个XMLHttpRequest</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   xmlHttp=<span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);   <span class="comment">//针对IE5,IE6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xmlhttp.open(method,url,<span class="keyword">async</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure>
<p>3.设置响应HTTP请求状态变化的函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xmlHttp.onreadystatechange()=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(xmlHttp.readyState === <span class="number">4</span> &amp;&amp; xmlHttp.status === <span class="number">200</span>)&#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;myDiv&quot;</span>).innerHTML=xmlhttp.responseText;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>//服务器响应<br>responseText:获得字符串形式的响应数据。<br>responseXML:获得 XML 形式的响应数据。<br>readyState:存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。</p>
<pre><code>0: 请求未初始化
1: 服务器连接已建立
2: 请求已接收
3: 请求处理中
4: 请求已完成，且响应已就绪</code></pre>
<p>status:</p>
<pre><code>200: &quot;OK&quot;
404: 未找到页面</code></pre>
<p>当 readyState 等于 4 且状态为 200 时，表示响应已就绪：<br>ajax步骤：</p>
<pre><code>创建XMLHttpRequest对象。
设置请求方式。
调用回调函数。
发送请求。</code></pre>
<h3 id="18-闭包"><a href="#18-闭包" class="headerlink" title="18.闭包"></a>18.闭包</h3><p>函数A 里面包含了 函数B，而 函数B 里面使用了 函数A 的变量，那么 函数B 被称为闭包。</p>
<p>又或者：闭包就是能够读取其他函数内部变量的函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特征：</p>
<ul>
<li>函数内再嵌套函数</li>
<li>内部函数可以引用外层的参数和变量</li>
<li>参数和变量不会被垃圾回收制回收  </li>
</ul>
<p>闭包的理解：使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。</p>
<p>在js中，函数即闭包，只有函数才会产生作用域的概念</p>
<p>闭包 的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中</p>
<ul>
<li>好处：能够实现封装和缓存等</li>
<li>坏处：消耗内存，使用不当造成内存泄漏；在退出函数之前，将不使用的局部变量全部删除</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答案：3个3<br>解析：首先，for 循环是同步代码，先执行三遍 for，i变成了 3；然后，再执行异步代码 setTimeout，这时候输出的 i，只能是 3 个 3 了<br>解决方法：<br>1.使用let i=0;每个 let 和代码块结合起来形成块级作用域，当 setTimeout() 打印时，会寻找最近的块级作用域中的 i，所以依次打印出 0 1 2<br>2.立即执行函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="19-js作用域和作用域链"><a href="#19-js作用域和作用域链" class="headerlink" title="19.js作用域和作用域链"></a>19.js作用域和作用域链</h3><p>1.作用域</p>
<p>在JavaScript中，作用域分为 全局作用域 和 函数作用域</p>
<ul>
<li>全局作用域：<br>代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域</li>
<li>函数作用域：<br>在固定的代码片段才能被访问</li>
</ul>
<p>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</p>
<p>变量取值：到创建 这个变量 的函数的作用域中取值</p>
<p>2.作用域链</p>
<p>一般情况下，变量取值到 创建 这个变量 的函数的作用域中取值。</p>
<p>但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链</p>
<p>3.原型和原型链</p>
<p>概念：<br>每个对象在其内部都会初始化一个属性，这个属性就是prototype（原型），指向对象的原型对象，当访问一个对象的某个属性时，就会去对象中查找，如果对象中不存在这个属性就去prototype中查找，而prototype又有自己的prototype，</p>
<p>任何对象都有一个<code>__proto__</code>[[prototype]]）,它是一个指针，指向构造函数的原型对象。</p>
<p>原型和原型链的关系：</p>
<pre><code>instance.constructor.prototype =instance.__proto__
构造函数的原型===实例化对象的原型链</code></pre>
<p>原型和原型链的特点:</p>
<pre><code>JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。
当我们修改原型时，与之相关的对象也会继承这一改变</code></pre>
<p>当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性，如果没有的就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象</p>
<h3 id="20-组件化和模块化"><a href="#20-组件化和模块化" class="headerlink" title="20.组件化和模块化"></a>20.组件化和模块化</h3><p>1.组件化</p>
<ul>
<li>为什么要组件化?</li>
</ul>
<p>有时候页面代码量太大，逻辑太多或者同一个功能组件在许多页面均有使用，维护起来相当复杂，这个时候，就需要组件化开发来进行功能拆分、组件封装，已达到组件通用性，增强代码可读性，维护成本也能大大降低</p>
<ul>
<li>组件化开发的优点</li>
</ul>
<p>很大程度上降低系统各个功能的耦合性，并且提高了功能内部的聚合性，降低了开发成本</p>
<ul>
<li><p>组件化开发的准则：</p>
<p>  专一<br>  可配置性<br>  标准<br>  复用性<br>  可维护性</p>
</li>
</ul>
<p>2.模块化</p>
<ul>
<li>为什么要模块化?</li>
</ul>
<p>早期的javascript版本没有块级作用域、没有类、没有包、也没有模块，这样会带来一些问题，如复用、依赖、冲突、代码组织混乱等，随着前端的膨胀，模块化显得非常迫切</p>
<ul>
<li><p>模块化的好处</p>
<p>  提高代码可复用性<br>  避免变量污染，命名冲突<br>  提高可维护性<br>  方便依赖关系管理</p>
</li>
<li><p>模块化的几种方法：</p>
</li>
</ul>
<p>1)函数封装：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myModule = &#123;</span><br><span class="line">  var1: <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  var2: <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">  fn1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  fn2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：这样避免了变量污染，只要保证模块名唯一即可，同时同一模块内的成员也有了关系</p>
<p>缺陷：外部可以睡意修改内部成员，这样就会产生意外的安全问题</p>
<p>2)立即执行函数表达式(IIFE)：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myModule = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> var1 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> var2 = <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">      fn1: fn1,</span><br><span class="line">      fn2: fn2</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>总结：这样在模块外部无法修改我们没有暴露出来的变量、函数</p>
<p>缺点：功能相对较弱，封装过程增加了工作量，仍会导致命名空间污染可能、闭包是有成本的</p>
<h3 id="21-图片的预加载和懒加载"><a href="#21-图片的预加载和懒加载" class="headerlink" title="21.图片的预加载和懒加载"></a>21.图片的预加载和懒加载</h3><ul>
<li>预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染</li>
<li>懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数<br>两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。预加载则会增加服务器前端压力，懒加载对服务器有一定的缓解压力作用。</li>
</ul>
<h3 id="22-mouseover和mouseenter的区别"><a href="#22-mouseover和mouseenter的区别" class="headerlink" title="22.mouseover和mouseenter的区别"></a>22.mouseover和mouseenter的区别</h3><ul>
<li>mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是mouseout</li>
<li>mouseenter：当鼠标移入元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是mouseleave</li>
</ul>
<p>解决异步回调地狱：promise、generator、async/await</p>
<h3 id="23-对This对象的理解"><a href="#23-对This对象的理解" class="headerlink" title="23.对This对象的理解"></a>23.对This对象的理解</h3><p>this总是指向函数的直接调用者（而非间接调用者）</p>
<p>如果有new关键字，this指向new出来的那个对象</p>
<p>在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window</p>
<p>this表示当前对象，this的指向是根据调用的上下文来决定的，默认指向window对象，指向window对象时可以省略不写</p>
<p>全局环境： this始终指向的是window对象<br>局部环境： 在全局作用域下直接调用函数，this指向window 对象函数调用，哪个对象调用就指向哪个对象 使用new实例化对象，在构造函数中的this指向实例化对象 使用call或apply改变this的指向<br>总结：this始终指向最后一个调用它的函数的对象</p>
<h3 id="24-ES6其他常用功能"><a href="#24-ES6其他常用功能" class="headerlink" title="24.ES6其他常用功能"></a>24.ES6其他常用功能</h3><ol>
<li>let/const</li>
<li>多行字符串/模板变量</li>
<li>解构赋值</li>
<li>块级作用域</li>
<li>函数默认参数</li>
<li>箭头函数</li>
</ol>
<h3 id="25-bind、call、apply用法及区别"><a href="#25-bind、call、apply用法及区别" class="headerlink" title="25.bind、call、apply用法及区别"></a>25.bind、call、apply用法及区别</h3><p>相同点： 三个函数的作用就是改变this的指向，将函数绑定到上下文中； 不同点： 三个函数的语法不同</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun.call(thisArg[, arg1[, arg2[, ...]]])</span><br><span class="line">fun.apply(thisArg, [argsArray])</span><br><span class="line"><span class="keyword">var</span> bindFn = fun.bind(thisArg[, arg1[, arg2[, ...]]])</span><br><span class="line">bindFn()</span><br></pre></td></tr></table></figure>
<h3 id="26-目前JS解决异步的方案有哪些"><a href="#26-目前JS解决异步的方案有哪些" class="headerlink" title="26.目前JS解决异步的方案有哪些"></a>26.目前JS解决异步的方案有哪些</h3><p>回调函数<br>事件监听<br>发布-订阅<br>Promise<br>Generator<br>Async/Await</p>
<h3 id="27-创建对象有几种方法"><a href="#27-创建对象有几种方法" class="headerlink" title="27.创建对象有几种方法"></a>27.创建对象有几种方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种：字面量</span></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;<span class="attr">name</span>: <span class="string">&quot;o1&quot;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>(&#123;<span class="attr">name</span>: <span class="string">&quot;o2&quot;</span>&#125;)</span><br><span class="line"><span class="comment">// 第二种：通过构造函数</span></span><br><span class="line"><span class="keyword">var</span> M = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;<span class="built_in">this</span>.name = name&#125;</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="keyword">new</span> M(<span class="string">&quot;o3&quot;</span>)</span><br><span class="line"><span class="comment">// 第三种：Object.create()</span></span><br><span class="line"><span class="keyword">var</span> p = &#123;<span class="attr">name</span>: <span class="string">&quot;p&quot;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> o4 = <span class="built_in">Object</span>.create(p)</span><br></pre></td></tr></table></figure>
<h2 id="四-Vue"><a href="#四-Vue" class="headerlink" title="四.Vue"></a>四.Vue</h2><p>vue的生命周期：就是vue实例从创建到销毁的过程，也就是从开始创建，初始化数据，编译模版，挂载Dom，渲染更新，卸载等过程</p>
<h3 id="1-Vue生命周期的作用是什么？"><a href="#1-Vue生命周期的作用是什么？" class="headerlink" title="1.Vue生命周期的作用是什么？"></a>1.Vue生命周期的作用是什么？</h3><p>它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑</p>
<h3 id="2-Vue生命周期总共有几个阶段？"><a href="#2-Vue生命周期总共有几个阶段？" class="headerlink" title="2.Vue生命周期总共有几个阶段？"></a>2.Vue生命周期总共有几个阶段？</h3><p>它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后</p>
<h3 id="3-DOM渲染在哪个周期中就已经完成？"><a href="#3-DOM渲染在哪个周期中就已经完成？" class="headerlink" title="3.DOM渲染在哪个周期中就已经完成？"></a>3.DOM渲染在哪个周期中就已经完成？</h3><p>DOM 渲染在 mounted 中就已经完成了</p>
<h3 id="4-每个生命周期适合哪些场景？"><a href="#4-每个生命周期适合哪些场景？" class="headerlink" title="4.每个生命周期适合哪些场景？"></a>4.每个生命周期适合哪些场景？</h3><p>生命周期钩子的一些使用方法：<br>    beforecreate : 可以在这加个loading事件，在加载实例时触发<br>    created : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用<br>    mounted : 挂载元素，获取到DOM节点<br>    updated : 如果对数据统一处理，在这里写上相应函数<br>    beforeDestroy : 销毁实例前做收尾清除工作<br>    nextTick : 更新数据后立即操作dom</p>
<h3 id="5-关于vue的keep-alive需要条件性缓存的解决"><a href="#5-关于vue的keep-alive需要条件性缓存的解决" class="headerlink" title="5.关于vue的keep-alive需要条件性缓存的解决"></a>5.关于vue的keep-alive需要条件性缓存的解决</h3><p>A&gt;B不缓存，C&gt;B需要缓存<br>在路由里面加上了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: <span class="string">&#x27;/b&#x27;</span>,</span><br><span class="line">  name: <span class="string">&#x27;B&#x27;</span>,</span><br><span class="line">  component: B,</span><br><span class="line">  meta:&#123;</span><br><span class="line">    keepAlive:<span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在app.vue写了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">    &lt;router-view v-if&#x3D;&quot;$route.meta.keepAlive&quot;&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">&lt;&#x2F;keep-alive&gt;</span><br><span class="line">&lt;router-view v-if&#x3D;&quot;!$route.meta.keepAlive&quot;&gt;&lt;&#x2F;router-view&gt;</span><br></pre></td></tr></table></figure>
<p>A页面写了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">beforeRouteLeave</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span><br><span class="line">  to.meta.keepAlive = <span class="literal">false</span>;</span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C页面写了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">beforeRouteLeave</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span><br><span class="line">  to.meta.keepAlive = <span class="literal">true</span>;</span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>meta.keepAlive=true这种方法，解决不了条件缓存问题<br>原因：在keep-alive源码中，include和exclude是被watch的 ，当发生变化时，keep-alive会去校验cache里是否匹配，匹配不上的会被删除。也就是说，官方是为这种情况做了处理的。而meta这种方法，因为没有存在某种类似于watch的方法，导致这种方法天然是和实际cache里面的内容有出入的，所以可定会存在各种奇怪的bug</p>
<p>利用include,动态添加”B”<br>1、在app.vue下增加keep-alive</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">&quot;catchList&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>catchList，是vuex维护的需要缓存的组件名的一个数组</p>
<p>2、在路由中加入</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to,next,<span class="keyword">from</span></span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (to.name === <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">    store.commit(<span class="string">&#x27;keepAlive&#x27;</span>, <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>3、在b.vue中加入(A&gt;B不缓存，C&gt;B缓存)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteLeave(<span class="function">(<span class="params">to,next,<span class="keyword">from</span></span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (to.name !== <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line">    store.commit(<span class="string">&#x27;noKeepAlive&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在vuex中mutation是</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">keepAlive</span>(<span class="params">state, component</span>)</span> &#123;</span><br><span class="line">  !state.catchList.includes(component) &amp;&amp;</span><br><span class="line">  state.catchList.push(component)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">noKeepAlive</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">state.catchList = []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要是B的组件，都缓存。只有当从A&gt;B的时候，才让B不缓存。</p>
<h3 id="6-Vue-路由懒加载"><a href="#6-Vue-路由懒加载" class="headerlink" title="6.Vue 路由懒加载"></a>6.Vue 路由懒加载</h3><p>Vue项目中实现路由按需加载（路由懒加载）的3中方式：<br>一、Vue异步组件技术：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">  name: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">  component: <span class="function"><span class="params">resolve</span> =&gt;</span> reqire([<span class="string">&#x27;path路径&#x27;</span>], resolve)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二、es6提案的import()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Home = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;path路径&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>三、webpack提供的require.ensure()</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  path: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">  name: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">  component: <span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">require</span>.ensure([],<span class="function">() =&gt;</span>  r(<span class="built_in">require</span>(<span class="string">&#x27;path路径&#x27;</span>)), <span class="string">&#x27;demo&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-Proxy与Object-defineProperty-的对比"><a href="#7-Proxy与Object-defineProperty-的对比" class="headerlink" title="7.Proxy与Object.defineProperty()的对比"></a>7.Proxy与Object.defineProperty()的对比</h3><p>Proxy的优点：<br>      1. 可以直接监听对象而非属性,并返回一个新对象<br>        2. 可以直接监听数组的变化<br>        3. 可以劫持整个对象，并返回一个新对象</p>
<p>Proxy的缺点：<br>    Proxy是es6提供的新特性，兼容性不好，所以导致Vue3一致没有正式发布让让广大开发者使用，IE9以下不兼容</p>
<p>Object.defineProperty的优点：<br>    IE8以下的版本不兼容</p>
<p>Object.defineProperty的缺点：<br>    只能劫持对象的属性，我们需要对每个对象的每个属性进行遍历，无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应</p>
<p>Proxy代理整个对象，Object.defineProperty只代理对象上的某个属性。<br>如果对象内部要全部递归代理，则Proxy可以只在调用时递归，而Object.defineProperty需要在一开始就全部递归，Proxy性能优于Object.defineProperty。<br>对象上定义新属性时，Proxy可以监听到，Object.defineProperty监听不到。<br>数组新增删除修改时，Proxy可以监听到，Object.defineProperty监听不到。<br>Proxy不兼容IE9以下，Object.defineProperty不兼容IE8及以下。</p>
<h3 id="8-v-show与v-if区别"><a href="#8-v-show与v-if区别" class="headerlink" title="8.v-show与v-if区别"></a>8.v-show与v-if区别</h3><p>v-show是css切换，v-if是完整的销毁和重新创建</p>
<p>使用 频繁切换时用v-show，运行时较少改变时用v-if</p>
<p>v-if=’false’ v-if是条件渲染，当false的时候不会渲染</p>
<h3 id="9-vue有哪些指令"><a href="#9-vue有哪些指令" class="headerlink" title="9.vue有哪些指令"></a>9.vue有哪些指令</h3><ul>
<li><p>v-model //在表单控件或者组件上创建双向绑定</p>
</li>
<li><p>v-if  //根据表达式的值的 truthiness 来有条件地渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建</p>
</li>
<li><p>v-else-if</p>
</li>
<li><p>v-else</p>
</li>
<li><p>v-text //更新元素的 textContent</p>
</li>
<li><p>v-show //根据表达式之真假值，切换元素的 display CSS property。</p>
</li>
<li><p>v-html://更新元素的 innerHTML。注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译。如果试图使用 v-html 组合模板，可以重新考虑是否通过使用组件来替代。</p>
</li>
<li><p>v-on:绑定事件监听器</p>
</li>
<li><p>v-bind //动态地绑定一个或多个 attribute，或一个组件 prop 到表达式。</p>
</li>
<li><p>v-for //基于源数据多次渲染元素或模板块</p>
</li>
<li><p>v-cloak //这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕</p>
</li>
<li><p>v-once //只渲染元素和组件一次</p>
</li>
<li><p>v-pre //跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。</p>
</li>
<li><p>v-slot //提供具名插槽或需要接收 prop 的插槽</p>
</li>
</ul>
<p>绑定class的数组用法</p>
<pre><code>对象方法: v-bind:class=&quot;&#123;&#39;orange&#39;: isRipe, &#39;green&#39;: isNotRipe&#125;&quot;
数组方法:  v-bind:class=&quot;[class1, class2]&quot;
行内: v-bind:style=&quot;&#123;color: color, fontSize: fontSize+&#39;px&#39; &#125;&quot;</code></pre>
<h3 id="10-组件之间的传值通信"><a href="#10-组件之间的传值通信" class="headerlink" title="10.组件之间的传值通信"></a>10.组件之间的传值通信</h3><ul>
<li><p>父组件给子组件传值:props</p>
</li>
<li><p>子组件向父组件通信:父组件向子组件传递事件方法，子组件通过$emit触发事件，回调给父组件</p>
</li>
<li><p>非父子，兄弟组件之间通信:<br>可以通过实例一个vue实例Bus作为媒介，要相互通信的兄弟组件之中，都引入Bus，然后通过分别调用Bus事件触发和监听来实现通信和参数传递</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click&#x3D;&quot;toBus&quot;&gt;子组件传给兄弟组件&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Bus from &#39;..&#x2F;common&#x2F;js&#x2F;bus.js&#39;</span><br><span class="line">export default&#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    toBus () &#123;</span><br><span class="line">        Bus.$emit(&#39;on&#39;, &#39;来自兄弟组件&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>另一个组件也import Bus.js 在钩子函数中监听on事件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Bus <span class="keyword">from</span> <span class="string">&#x27;../common/js/bus.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    Bus.$on(<span class="string">&#x27;on&#x27;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.message = msg</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-子组件调用父组件的方法函数"><a href="#11-子组件调用父组件的方法函数" class="headerlink" title="11.子组件调用父组件的方法函数"></a>11.子组件调用父组件的方法函数</h3><ul>
<li>直接在子组件中通过this.$parent.event来调用父组件的方法</li>
<li>在子组件里用$emit向父组件触发一个事件，父组件监听这个事件就行了</li>
<li>父组件把方法传入子组件中，在子组件里直接调用这个方法</li>
</ul>
<h3 id="12-路由跳转方式"><a href="#12-路由跳转方式" class="headerlink" title="12.路由跳转方式"></a>12.路由跳转方式</h3><p><code>&lt;router-link to=&#39;home&#39;&gt;</code> router-link标签会渲染为<code>&lt;a&gt;</code>标签</p>
<p>另一种是编程是导航 也就是通过js跳转 比如 router.push(‘/home’)</p>
<h3 id="13-mvvm"><a href="#13-mvvm" class="headerlink" title="13.mvvm"></a>13.mvvm</h3><ul>
<li><p>M - Model，Model 代表数据模型，也可以在 Model 中定义数据修改和操作的业务逻辑</p>
</li>
<li><p>V - View，View 代表 UI 组件，它负责将数据模型转化为 UI 展现出来</p>
</li>
<li><p>VM - ViewModel，ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步 View 和 Model 的对象，连接 Model 和 View之间的桥梁，绑定数据到viewmodel层并自动更新渲染到页面上，视图变化通知到viewmodel层去更新数据</p>
</li>
</ul>
<h3 id="14-computed和watch有什么区别"><a href="#14-computed和watch有什么区别" class="headerlink" title="14.computed和watch有什么区别?"></a>14.computed和watch有什么区别?</h3><ul>
<li><p>computed:</p>
<ol>
<li>computed是计算属性,也就是计算值,它更多用于计算值的场景</li>
<li>computed具有缓存性,computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时才会重新调用对应的getter来计算</li>
<li>computed适用于计算比较消耗性能的计算场景</li>
</ol>
</li>
<li><p>watch：</p>
<ol>
<li>更多的是「观察」的作用,类似于某些数据的监听回调,用于观察props $emit或者本组件的值,当数据变化时来执行回调进行后续操作</li>
<li>无缓存性，页面重新渲染时值不变化也会执行</li>
</ol>
</li>
<li><p>小结：</p>
<ol>
<li>当我们要进行数值计算,而且依赖于其他数据，那么把这个数据设计为computed</li>
<li>如果你需要在某个数据变化时做一些事情，使用watch来观察这个数据变化</li>
</ol>
</li>
</ul>
<h3 id="15-key"><a href="#15-key" class="headerlink" title="15.key"></a>15.key</h3><p>key是为Vue中的vnode标记的唯一id，通过这个key，我们的diff操作可以 更准确、更快速</p>
<ul>
<li><p>准确:<br>  如果不加key,那么vue会选择复用节点(Vue的就地更新策略),<br>  导致之前节点的状态被保留下来，会产生一系列的bug</p>
</li>
<li><p>快速:<br>  key的唯一性可以被Map数据结构充分利用</p>
</li>
</ul>
<p>预期：number | string</p>
<p>key 的特殊属性主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key的变化重新排列元素顺序，并且会移除 key 不存在的元素。</p>
<p>有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误。</p>
<p>最常见的用例是结合 v-for：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-for&#x3D;&quot;item in items&quot; :key&#x3D;&quot;item.id&quot;&gt;...&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>
<p>它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用：</p>
<ul>
<li>完整地触发组件的生命周期钩子</li>
<li>触发过渡</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition&gt;</span><br><span class="line">  &lt;span :key&#x3D;&quot;text&quot;&gt;&#123;&#123; text &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;transition&gt;</span><br></pre></td></tr></table></figure>
<p>当 text 发生改变时，<code>&lt;span&gt;</code> 总是会被替换而不是被修改，因此会触发过渡</p>
<h3 id="16-组件中的data为什么是函数？"><a href="#16-组件中的data为什么是函数？" class="headerlink" title="16.组件中的data为什么是函数？"></a>16.组件中的data为什么是函数？</h3><p>组件可以被多次复用，创建多个实例，这些实例本质是同一个构造函数，如果data是对象，对象是引用类型，修改对象会影响所有实例，因此data是一个函数</p>
<h3 id="17-Class-与-Style-如何动态绑定？"><a href="#17-Class-与-Style-如何动态绑定？" class="headerlink" title="17.Class 与 Style 如何动态绑定？"></a>17.Class 与 Style 如何动态绑定？</h3><p>1)class<br>对象语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;&#123; &#x27;active&#x27;: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    isActive: <span class="literal">true</span>,</span><br><span class="line">    hasError: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>数组语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    activeClass: <span class="string">&#x27;active&#x27;</span>,</span><br><span class="line">    errorClass: <span class="string">&#x27;text-danger&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2)style：</p>
<p>对象语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=<span class="string">&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    activeColor: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">    fontSize: <span class="number">30</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:style=<span class="string">&quot;[styleColor, styleSize]&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"><span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    styleColor: &#123;</span><br><span class="line">       color: <span class="string">&#x27;red&#x27;</span></span><br><span class="line">     &#125;,</span><br><span class="line">    styleSize:&#123;</span><br><span class="line">       fontSize:<span class="string">&#x27;23px&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="18-vue的单向数据流"><a href="#18-vue的单向数据流" class="headerlink" title="18.vue的单向数据流"></a>18.vue的单向数据流</h3><p>所有的 prop都使得其父子prop之间形成了一个单向下行绑定：<br>父级 prop的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解</p>
<p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。<br>这意味着你不应该在一个子组件内部改变prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。<br>子组件想修改时，只能通过 $emit派发一个自定义事件，父组件接收到后，由父组件修改</p>
<p>有两种常见的试图改变一个 prop 的情形 :</p>
<p>1)这个 prop 用来传递一个初始值:<br>这个子组件接下来希望将其作为一个本地的 prop 数据来使用，在这种情况下，最好定义一个本地的 data属性并将这个 prop 用作其初始值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">&#x27;initialCounter&#x27;</span>],</span><br><span class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter: <span class="built_in">this</span>.initialCounter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2)prop 以一种原始的值传入且需要进行转换：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">&#x27;size&#x27;</span>],</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedSize: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="19-keep-alive"><a href="#19-keep-alive" class="headerlink" title="19.keep-alive"></a>19.keep-alive</h3><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p>
<ul>
<li><p>一般结合路由和动态组件一起使用，用于缓存组件；</p>
</li>
<li><p>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include表示只有名称匹配的组件会被缓存，exclude表示任何名称匹配的组件都不会被缓存 ，其中 exclude的优先级比 include 高；</p>
</li>
<li><p>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</p>
</li>
</ul>
<h3 id="20-v-model-的原理"><a href="#20-v-model-的原理" class="headerlink" title="20.v-model 的原理"></a>20.v-model 的原理</h3><p>vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p>
<ul>
<li>text 和 textarea 元素使用 value 属性和 input 事件；</li>
<li>checkbox 和 radio 使用 checked 属性和 change 事件；</li>
<li>select 字段将 value 作为 prop 并将 change 作为事件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model&#x3D;&#39;something&#39;&gt;</span><br><span class="line">&lt;!-- 相当于 --&gt;</span><br><span class="line">&lt;input v-bind:value&#x3D;&quot;something&quot; v-on:input&#x3D;&quot;something &#x3D; $event.target.value&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件</p>
<h3 id="21-nextTick"><a href="#21-nextTick" class="headerlink" title="21.nextTick()"></a>21.nextTick()</h3><p>在下次DOM更新循环结束之后执行延迟回调。在修改数据之后，立即使用的这个回调函数，获取更新后的DOM</p>
<h3 id="22-vue插槽"><a href="#22-vue插槽" class="headerlink" title="22.vue插槽"></a>22.vue插槽</h3><ul>
<li><p>单个插槽：<br>  当子组件模板只有一个没有属性的插槽时，<br>  父组件传入的整个内容片段将插入到插槽所在的 DOM 位置，<br>  并替换掉插槽标签本身</p>
</li>
<li><p>命名插槽：<br>  solt元素可以用一个特殊的特性name来进一步配置如何分发内容。<br>  多个插槽可以有不同的名字。 这样可以将父组件模板中 slot 位置，<br>  和子组件 slot 元素产生关联，便于插槽内容对应传递</p>
</li>
<li><p>作用域插槽：<br>  可以访问组件内部数据的可复用插槽(reusable slot)<br>  在父级中，具有特殊特性 slot-scope 的<code>&lt;template&gt;</code> 元素必须存在，<br>  表示它是作用域插槽的模板。slot-scope 的值将被用作一个临时变量名，<br>  此变量接收从子组件传递过来的 prop 对象</p>
</li>
</ul>
<h3 id="23-导航守卫"><a href="#23-导航守卫" class="headerlink" title="23.导航守卫"></a>23.导航守卫</h3><p>vue-router提供的导航守卫主要通过跳转或取消的方式守卫导航<br>参数或查询的改变不会触发进入/离开的导航守卫<br>你可以通过观察 $route 对象来应对这些变化，或使用beforeRouteUpdate 的组件内守卫</p>
<ul>
<li>全局前置守卫：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>守卫是异步解析执行，此时导航在所有守卫 resolve 完之前一直处于 等待中</p>
<p>to: Route: 即将要进入的目标 路由对象</p>
<p>from: Route: 当前导航正要离开的路由</p>
<p>next: Function: 一定要调用该方法来 resolve这个钩子。执行效果依赖 next 方法的调用参数。<br>确保要调用 next 方法，否则钩子就不会被 resolved</p>
<ul>
<li>路由独享的守卫</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">routes: [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/foo&#x27;</span>,</span><br><span class="line">    component: Foo,</span><br><span class="line">    beforeEnter: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>组件内的守卫</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  template: <span class="string">`...`</span>,</span><br><span class="line">  beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在渲染该组件的对应路由被 confirm 前调用</span></span><br><span class="line">    <span class="comment">// 不！能！获取组件实例 `this`</span></span><br><span class="line">    <span class="comment">// 因为当守卫执行前，组件实例还没被创建</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span><br><span class="line">    <span class="comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span><br><span class="line">    <span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 导航离开该组件的对应路由时调用</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>vue-router有哪几种导航钩子</p>
<pre><code>第一种：是全局导航钩子：router.beforeEach(to,from,
next)，作用：跳转前进行判断拦截

第二种：组件内的钩子：beforeRouteEnter/beforeRouteUpdate/beforeRouteLeave

第三种：单独路由独享组件：beforeEnter</code></pre>
<h3 id="24-vuex是什么？"><a href="#24-vuex是什么？" class="headerlink" title="24.vuex是什么？"></a>24.vuex是什么？</h3><p>vuex是专门为vuejs应用程序开发的状态管理插件，集中存储管理组件状态，通过显式提交mutation改变组件状态<br>vuex 就是一个仓库，仓库里放了很多对象。其中 state就是数据源存放地，对应于一般 vue 对象里面的 data</p>
<p>state 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新</p>
<p>它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性</p>
<p>Vuex有5种属性: 分别是 state、getter、mutation、action、module;</p>
<ul>
<li><p>state<br>  Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据</p>
</li>
<li><p>mutations<br>  mutations定义的方法动态修改Vuex 的 store 中的状态或数据</p>
</li>
<li><p>getters<br>  类似vue的计算属性，主要用来过滤一些数据</p>
</li>
<li><p>actions<br>  actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action</p>
</li>
<li><p>modules<br>  由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得复杂时，store对象就变得臃肿。为了解决以上问题，vuex允许将store分隔成模块。每个模块有自己的state/getter/mutation/action,甚至是嵌套子模块。<br>总结<br>vuex 一般用于中大型 web 单页应用中对应用的状态进行管理，对于一些组件间关系较为简单的小型应用，使用 vuex 的必要性不是很大，因为完全可以用组件 prop属性或者事件来完成父子组件之间的通信，vuex 更多地用于解决跨组件通信以及作为数据中心集中式存储数据</p>
</li>
</ul>
<p>vuex解决了什么？<br>    多个组件依赖同一个状态，多层组件间传值<br>    来自不同的组件的行为需要变更同一个状态</p>
<h3 id="25-优化SPA首屏加载速度"><a href="#25-优化SPA首屏加载速度" class="headerlink" title="25.优化SPA首屏加载速度"></a>25.优化SPA首屏加载速度</h3><ul>
<li><p>缩小webpack或者其他打包工具生成的包的大小</p>
<p>  用webpack-bundle-analyzer的分析工具哪个模块占空间大</p>
</li>
<li><p>第三方UI组件按需引入</p>
</li>
<li><p>使用服务端渲染方式（基于vue的nuxt.js开发）</p>
</li>
<li><p>使用预渲染的方式</p>
<p>  在打包时会预先运行一次js代码，将一部分静态页面直接渲染成html写在生成的index.html中，在加载完index.html后页面就能展示，无需等待加载js缺点是在需要预渲染的页面较多时，build打包的时间会十分漫长</p>
</li>
<li><p>使用gzip减小网络传输的流量大小</p>
<p>  HTTP协议上的gzip编码是一种用来改进web应用程序性能的技术，web服务器和客户端（浏览器）必须共同支持gzip，使用gzip可以将原静态文件压缩到30%，效果很明显，对于优化首屏加载时间非常适合在nginx中配置<br>  http{<br>  gzip on;<br>  }</p>
</li>
<li><p>组件懒加载</p>
</li>
</ul>
<h3 id="26-你有对-Vue-项目进行哪些优化？"><a href="#26-你有对-Vue-项目进行哪些优化？" class="headerlink" title="26.你有对 Vue 项目进行哪些优化？"></a>26.你有对 Vue 项目进行哪些优化？</h3><p>1)代码层面的优化</p>
<ul>
<li>v-if 和 v-show 区分使用场景</li>
<li>computed 和 watch  区分使用场景</li>
<li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li>
<li>长列表性能优化</li>
<li>事件的销毁</li>
<li>图片资源懒加载</li>
<li>路由懒加载</li>
<li>第三方插件的按需引入</li>
<li>优化无限列表性能</li>
<li>服务端渲染 SSR or 预渲染</li>
<li>减少data中数据</li>
<li>SPA采用keep-alive缓存组件</li>
</ul>
<p>2)Webpack 层面的优化</p>
<ul>
<li>Webpack 对图片进行压缩</li>
<li>减少 ES6 转为 ES5 的冗余代码</li>
<li>提取公共代码</li>
<li>模板预编译</li>
<li>提取组件的 CSS</li>
<li>优化 SourceMap</li>
<li>构建结果输出分析</li>
<li>Vue 项目的编译优化</li>
<li>压缩代码</li>
<li>tree shaking</li>
<li>cdn加载第三方模块</li>
<li>sourcemap优化</li>
</ul>
<p>3)基础的 Web 技术的优化</p>
<ul>
<li>开启 gzip 压缩</li>
<li>浏览器缓存</li>
<li>CDN 的使用</li>
<li>使用 Chrome Performance 查找性能瓶颈</li>
</ul>
<h2 id="五-ES6"><a href="#五-ES6" class="headerlink" title="五.ES6"></a>五.ES6</h2><h3 id="1-var-let-const区别"><a href="#1-var-let-const区别" class="headerlink" title="1.var let const区别"></a>1.var let const区别</h3><p>let、const声明的变量仅在块级作用域内有效，var声明变<br>量是全局的，没有块级作用域功能<br>let 、const 不存在变量提升 , var 存在变量提升<br>let 、const不能在同一块级作用域内重复申请</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">test();<span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">test();<span class="comment">//ReferenceError: Cannot access &#x27;name&#x27; before initialization</span></span><br></pre></td></tr></table></figure>
<p>通过 var 声明的变量有初始值 undefined，而通过 let声明的变量直到定义的代码被执行时才会初始化。在变量初始化前访问变量会导致 ReferenceError</p>
<h3 id="2-解构赋值"><a href="#2-解构赋值" class="headerlink" title="2.解构赋值"></a>2.解构赋值</h3><p>1)数组解构</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]   <span class="comment">//a=1, b=2, c=3</span></span><br><span class="line"><span class="keyword">let</span> [d, [e], f] = [<span class="number">1</span>, [<span class="number">2</span>], <span class="number">3</span>]    <span class="comment">//嵌套数组解构 d=1, e=2, f=3</span></span><br><span class="line"><span class="keyword">let</span> [g, ...h] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]   <span class="comment">//数组拆分 g=1, h=[2, 3]</span></span><br><span class="line"><span class="keyword">let</span> [i,,j] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]   <span class="comment">//不连续解构 i=1, j=3</span></span><br><span class="line"><span class="keyword">let</span> [k,l] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]   <span class="comment">//不完全解构 k=1, l=2</span></span><br></pre></td></tr></table></figure>
<p>2)对象解构：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a, b&#125; = &#123;<span class="attr">a</span>: <span class="string">&#x27;aaaa&#x27;</span>, <span class="attr">b</span>: <span class="string">&#x27;bbbb&#x27;</span>&#125;      <span class="comment">//a=&#x27;aaaa&#x27; b=&#x27;bbbb&#x27;</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">d</span>: <span class="string">&#x27;aaaa&#x27;</span>, <span class="attr">e</span>: &#123;<span class="attr">f</span>: <span class="string">&#x27;bbbb&#x27;</span>&#125;&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;d, <span class="attr">e</span>:&#123;f&#125;&#125; = obj    <span class="comment">//嵌套解构 d=&#x27;aaaa&#x27; f=&#x27;bbbb&#x27;</span></span><br><span class="line"><span class="keyword">let</span> g;</span><br><span class="line">(g = &#123;<span class="attr">g</span>: <span class="string">&#x27;aaaa&#x27;</span>&#125;)   <span class="comment">//以声明变量解构 g=&#x27;aaaa&#x27;</span></span><br><span class="line"><span class="keyword">let</span> [h, i, j, k] = <span class="string">&#x27;nice&#x27;</span>    <span class="comment">//字符串解构 h=&#x27;n&#x27; i=&#x27;i&#x27; j=&#x27;c&#x27; k=&#x27;e&#x27;</span></span><br></pre></td></tr></table></figure>
<p>函数参数的定义  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">personInfo</span>(<span class="params">name, age, address, gender</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name, age, address, gender)</span><br><span class="line">&#125;</span><br><span class="line">personInfo(<span class="string">&#x27;william&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;changsha&#x27;</span>, <span class="string">&#x27;man&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>上面这个例子在对用户信息的时候需要传递四个参数，且需要一一对应，这样就会极易出现参数顺序传错的情况，从而导致bug，接下来来看es6解构赋值是怎么解决这个问题的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">personInfo</span>(<span class="params">&#123;name, age, address, gender&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name, age, address, gender)</span><br><span class="line">&#125;</span><br><span class="line">    personInfo(&#123;<span class="attr">gender</span>: <span class="string">&#x27;man&#x27;</span>, <span class="attr">address</span>: <span class="string">&#x27;changsha&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;william&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>交换变量的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=<span class="number">1</span>, b=<span class="number">2</span>;</span><br><span class="line">[b, a] = [a, b]</span><br><span class="line"><span class="built_in">console</span>.log(a, b)</span><br></pre></td></tr></table></figure>
<p>函数默认参数</p>
<p>es5：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveInfo</span>(<span class="params">name, age, address, gender</span>) </span>&#123;</span><br><span class="line">  name = name || <span class="string">&#x27;william&#x27;</span></span><br><span class="line">  age = age || <span class="number">18</span></span><br><span class="line">  address = address || <span class="string">&#x27;changsha&#x27;</span></span><br><span class="line">  gender = gender || <span class="string">&#x27;man&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(name, age, address, gender)</span><br><span class="line">&#125;</span><br><span class="line">saveInfo()</span><br></pre></td></tr></table></figure>
<p>es6:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">saveInfo</span>(<span class="params">&#123;name= <span class="string">&#x27;william&#x27;</span>, age= <span class="number">18</span>, address= <span class="string">&#x27;changsha&#x27;</span>, gender= <span class="string">&#x27;man&#x27;</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name, age, address, gender)</span><br><span class="line">&#125;</span><br><span class="line">saveInfo()</span><br></pre></td></tr></table></figure>
<h3 id="3-forEach、for-in、for-of三者区别"><a href="#3-forEach、for-in、for-of三者区别" class="headerlink" title="3.forEach、for in、for of三者区别"></a>3.forEach、for in、for of三者区别</h3><ul>
<li><p>forEach更多的用来遍历数组，无法return或break</p>
</li>
<li><p>for in 一般常用来遍历对象或json，循环遍历的值都是数据结构的键值，也遍历数组</p>
</li>
<li><p>for of数组对象都可以遍历，遍历对象需要通过和Object.keys()一起使用<br>它是ES6中新增加的语法，用来循环获取一对键值对中的值<br>一个数据结构只有部署了 Symbol.iterator 属性, 才具有 iterator接口可以使用 for of循环<br>以下数据结构部署了 Symbol.iteratoer属性：</p>
<ul>
<li>数组</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>Nodelist</li>
<li>arguments对象<br>如果想让对象可以使用 for of循环怎么办?使用 Object.keys() 获取对象的 key值集合后,再使用 for of<br>或者使用内置的Object.values()方法获取对象的value值集合再使用for of</li>
</ul>
</li>
<li><p>for in循环出的是key，for of循环出的是value</p>
</li>
</ul>
<h3 id="4-使用箭头函数应注意什么？"><a href="#4-使用箭头函数应注意什么？" class="headerlink" title="4.使用箭头函数应注意什么？"></a>4.使用箭头函数应注意什么？</h3><ul>
<li>1、用了箭头函数，this就不是指向window，而是父级（指向是可变的）</li>
<li>2、不能够使用arguments对象</li>
<li>3、不能用作构造函数，这就是说不能够使用new命令，否则会抛出一个错误</li>
<li>4、不可以使用yield命令，因此箭头函数不能用作 Generator 函数</li>
</ul>
<h3 id="5-Set、Map的区别"><a href="#5-Set、Map的区别" class="headerlink" title="5.Set、Map的区别"></a>5.Set、Map的区别</h3><p>应用场景Set用于数据重组，Map用于数据储存</p>
<ul>
<li>Set：<br>  1，成员不能重复<br>  2，只有键值没有键名，类似数组<br>  3，可以遍历，方法有add, delete,has</li>
<li>Map:<br>  1，本质上是健值对的集合，类似集合<br>  2，可以遍历，可以跟各种数据格式转换</li>
</ul>
<h3 id="6-Ajax"><a href="#6-Ajax" class="headerlink" title="6.Ajax"></a>6.Ajax</h3><p>1.创建一个XmlHttpRequest对象，也就是创建一个异步调用对象<br>2.创建一个发送请求到方法，设置http请求方法，url和验证信息<br>3.设置请求状态变化到方法<br>4.发送请求<br>5.获取异步调用返回的数据<br>6.使用js和dom实现局部刷新</p>
<h3 id="7-同步和异步的区别"><a href="#7-同步和异步的区别" class="headerlink" title="7.同步和异步的区别"></a>7.同步和异步的区别</h3><ul>
<li>同步：<br>按照一定的顺序去执行，执行完一个才能执行下一个浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作</li>
<li>异步：<br>浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容执行顺序是不确定的，由触发条件决定，什么时间执行也是不确定的，即使是定时器（下面做解释），异步处理可以同时执行多个。</li>
</ul>
<h3 id="8-ajax的优点和缺点"><a href="#8-ajax的优点和缺点" class="headerlink" title="8.ajax的优点和缺点"></a>8.ajax的优点和缺点</h3><ul>
<li><p>ajax的优点<br>  1、无刷新更新数据（在不刷新整个页面的情况下维持与服务器通信）<br>  2、异步与服务器通信（使用异步的方式与服务器通信，不打断用户的操作）<br>  3、前端和后端负载均衡（将一些后端的工作交给前端，减少服务器与宽度的负担）<br>  4、界面和应用相分离（ajax将界面和应用分离也就是数据与呈现相分离）</p>
</li>
<li><p>ajax的缺点<br>  1、ajax不支持浏览器back按钮<br>  2、安全问题 Aajax暴露了与服务器交互的细节<br>  3、对搜索引擎的支持比较弱<br>  4、破坏了Back与History后退按钮的正常行为等浏览器机制</p>
</li>
</ul>
<h3 id="9-get和post的区别"><a href="#9-get和post的区别" class="headerlink" title="9.get和post的区别"></a>9.get和post的区别</h3><p>1、get和post在HTTP中都代表着请求数据，其中get请求相对来说更简单、快速，效率高些<br>2、get相对post安全性低<br>3、get有缓存，post没有<br>4、get体积小，post可以无限大<br>5、get的url参数可见，post不可见<br>6、get只接受ASCII字符的参数数据类型，post没有限制<br>7、get请求参数会保留历史记录，post中参数不会保留<br>8、get会被浏览器主动catch，post不会，需要手动设置<br>9、get在浏览器回退时无害，post会再次提交请求</p>
<h3 id="10-什么时候使用post？"><a href="#10-什么时候使用post？" class="headerlink" title="10.什么时候使用post？"></a>10.什么时候使用post？</h3><p>post一般用于修改服务器上的资源，对所发送的信息没有限制。比如<br>    1、无法使用缓存文件（更新服务器上的文件或数据库）<br>    2、向服务器发送大量数据（POST 没有数据量限制）<br>    3、发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</p>
<h3 id="11-同源策略"><a href="#11-同源策略" class="headerlink" title="11.同源策略"></a>11.同源策略</h3><p>同源策略是浏览器的一个安全功能，不同源的客户端脚本在没有明确授权的情况下，不能相互读取对方资源</p>
<p>同源策略限制了一个源的文档和脚本和另一个源的资源进行交互，是一个隔离潜在恶意文件攻击的安全机制</p>
<p>不受同源策略限制的：</p>
<p>1.页面中的连接，重定向和表单提交<br>2.第三方js的引入不受限制，但不能js读写加载的内容，script，link，img，iframe</p>
<h3 id="12-如何解决跨域问题"><a href="#12-如何解决跨域问题" class="headerlink" title="12.如何解决跨域问题?"></a>12.如何解决跨域问题?</h3><p>跨域的概念：协议、域名、端口都相同才同域，否则都是跨域</p>
<p>解决跨域问题：</p>
<p>1、 通过jsonp跨域<br>2、 document.domain + iframe跨域<br>3、 location.hash + iframe<br>4、 window.name + iframe跨域<br>5、 postMessage跨域<br>6、 跨域资源共享（CORS）<br>7、 nginx代理跨域<br>8、 nodejs中间件代理跨域<br>9、 WebSocket协议跨域</p>
<h2 id="六-浏览器"><a href="#六-浏览器" class="headerlink" title="六.浏览器"></a>六.浏览器</h2><h3 id="1-主流浏览器"><a href="#1-主流浏览器" class="headerlink" title="1.主流浏览器"></a>1.主流浏览器</h3><p>IE Google Chrome Firefox Opera Safari</p>
<h3 id="2-浏览器内核"><a href="#2-浏览器内核" class="headerlink" title="2.浏览器内核"></a>2.浏览器内核</h3><p>渲染引擎和js引擎<br>渲染引擎：用来解释网页语法并渲染到网页上</p>
<p>浏览器内核决定了如何显示网页内容和格式化的信息<br>Trident：IE、360<br>Gecko：火狐<br>Presto：Opera<br>Blink：Opera，Googlechrome<br>webkit：Safari</p>
<h3 id="3-浏览器兼容"><a href="#3-浏览器兼容" class="headerlink" title="3.浏览器兼容"></a>3.浏览器兼容</h3><p>1.不同浏览器默认内外边距不同：*{margin:0;padding:0}<br>2.图片默认有间距:img设置float<br>3. IE6双边距bug：块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大。hack：display:inline;将其转化为行内属性。<br>4. 设置较小高度标签（一般小于10px），在IE6，IE7中高度超出自己设置高度。hack：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。<br>5. Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。<br>6. 超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有hover和active了。解决方法是改变CSS属性的排列顺序:L-V-H-A ( love hate ): a:link {} a:visited {} a:hover {} a:active {}</p>
<h2 id="七-其他"><a href="#七-其他" class="headerlink" title="七.其他"></a>七.其他</h2><h3 id="1-前端组件化和模块化"><a href="#1-前端组件化和模块化" class="headerlink" title="1.前端组件化和模块化"></a>1.前端组件化和模块化</h3><p>组件化：组件化是具体的，按照一些功能的通用性和复用性来抽象组件侧重于UI部分，比如弹窗按钮</p>
<p>模块化：模块化是抽象的，按照项目业务划分的大块侧重于数据数据的封装</p>
<p>对于组件来说，其主要是提高代码的复用性，功能单一独立模块是将同一类型的代码整合在一起，例如用户信息，设置等，所以模块等功能相当复杂，但都同属于同一业务（提高内聚降低耦合）</p>
<h3 id="2-什么是Ajax和JSON，它们的优点和缺点"><a href="#2-什么是Ajax和JSON，它们的优点和缺点" class="headerlink" title="2.什么是Ajax和JSON，它们的优点和缺点"></a>2.什么是Ajax和JSON，它们的优点和缺点</h3><ul>
<li><p>Ajax：</p>
<p>  Ajax是异步JavaScript和XML，用于在Web页面中实现异步数据交互<br>  Ajax优点：<br>  异步请求响应快，用户体验好；页面无刷新、数据局部更新；按需取数据，减少了冗余请求和服务器的负担；<br>  Ajax缺点：<br>  异步回调问题、this指向问题、路由跳转back问题；对搜索引擎的支持比较弱，对于一些手机还不是很好的支持</p>
</li>
<li><p>JSON：</p>
<p>  是一种轻量级的数据交换格式，看着像对象，本质是字符串<br>  JSON优点：<br>  轻量级、易于人的阅读和编写，便于js解析，支持复合数据类型<br>  JSON缺点：<br>  没有XML格式这么推广的深入人心和使用广泛, 没有XML那么通用性。</p>
</li>
</ul>
<h3 id="3-Github"><a href="#3-Github" class="headerlink" title="3.Github"></a>3.Github</h3><p>git常用的命令<br>从远程库克隆到本地：git clone 网站上的仓库地址<br>新增文件的命令：git add .<br>提交文件的命令：git commit –m或者git commit –a<br>查看工作区状况：git status –s<br>拉取合并远程分支的操作：git fetch/git merge或者git pull<br>查看提交记录命令：git reflog</p>
<h3 id="4-webpack"><a href="#4-webpack" class="headerlink" title="4.webpack"></a>4.webpack</h3><p>webpack打包原理：<br>webpack只是一个打包模块的机制，只是把依赖的模块转化成可以代表这些包的静态文件。webpack就是识别你的入口文件。识别你的模块依赖，来打包你的代码。至于你的代码使用的是commonjs还是amd或者es6的import。webpack都会对其进行分析。来获取代码的依赖。webpack做的就是分析代码，转换代码，编译代码，输出代码。webpack本身是一个node的模块，所以webpack.config.js是以commonjs形式书写的(node中的模块化是commonjs规范的)</p>
<p>webpack 核心概念<br>1.entry<br>入口起点(entry point)指示 webpack 应该使用哪个模块,来作为构建其内部依赖图的开始. 进入入口起点后,webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。 每个依赖项随即被处理,最后输出到称之为 bundles 的文件中。</p>
<p>2.output<br>output 属性告诉 webpack 在哪里输出它所创建的bundles,以及如何命名这些文件,默认值为 ./dist。 基本上整个应用程序结构,都会被编译到你指定的输出路径的文件夹中。</p>
<p>3.Module 模块<br>在 Webpack 里一切皆模块,一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块</p>
<p>4.chunk 代码块<br>一个 Chunk 由多个模块组合而成,用于代码合并与分割。</p>
<p>5.loader<br>loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。 loader 可以将所有类型的文件转换为 webpack能够处理的有效模块,然后你就可以利用 webpack 的打包能力,对它们进行处理。 本质上,webpack loader将所有类型的文件,转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。</p>
<p>6.Plugin<br>loader 被用于转换某些类型的模块,而插件则可以用于执行范围更广的任务。 插件的范围包括,从打包优化和压缩,一直到重新定义环境中的变量。插件接口功能极其强大,可以用来处理各种各样的任务。</p>
<p>模块热更新<br>模块热更新是webpack的一个功能，他可以使代码修改过后不用刷新就可以更新，是高级版的自动刷新浏览器</p>
<p>devServer中通过hot属性可以控制模块的热替换</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> env = process.env.NODE_ENV == <span class="string">&quot;development&quot;</span> ? <span class="string">&quot;development&quot;</span> : <span class="string">&quot;production&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  mode: env,</span><br><span class="line"> devServer: &#123;</span><br><span class="line">     hot:<span class="literal">true</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">  plugins: [</span><br><span class="line">     <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(), <span class="comment">//热加载插件</span></span><br><span class="line">  ],</span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure>
<p>webpack的优点</p>
<pre><code>专注于处理模块化的项目，能做到开箱即用，一步到位
可通过plugin扩展，完整好用又不失灵活
使用场景不局限于web开发
社区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展
良好的开发体验</code></pre>
<p>webpack的缺点</p>
<pre><code>webpack的缺点是只能用于采用模块化开发的项目</code></pre>
<h3 id="5-微信小程序"><a href="#5-微信小程序" class="headerlink" title="5.微信小程序"></a>5.微信小程序</h3><ul>
<li>onLoad()：页面加载时触发。</li>
<li>onReady()：页面初次渲染完成时触发。</li>
<li>onShow()：页面显示/切入前台时触发。</li>
<li>onHide()：页面隐藏/切入后台时触发。</li>
<li>onUnload()：页面卸载时触发。</li>
</ul>
<p>小程序运行环境分为渲染层和逻辑层，其中wxml和wxss工作在渲染层，js工作在逻辑层</p>
<p>小程序的渲染层和逻辑层分别由两个线程来管理：渲染层的界面使用webview来管理，逻辑层使用jscore来运行js脚本，一个小程序存在多个界面，所以渲染层有多个webview，两个线程通过微信客户端做中转，逻辑层请求网络经由客户端转发</p>
<h3 id="6-微信小程序支付流程"><a href="#6-微信小程序支付流程" class="headerlink" title="6.微信小程序支付流程"></a>6.微信小程序支付流程</h3><ul>
<li>1.wx.login用code换取openid</li>
<li>2.生成商户订单</li>
<li>3.调用支付统一下单api，返回预付单信息prepay_id</li>
<li>4.将组合数据再次签名，返回5个参数和sign</li>
<li>5.小程序获取参数后，鉴权调起支付</li>
<li>6.返回支付结果给小程序，推送支付结果给商户，修改订单状态</li>
</ul>
<p><img src="/ZJY.github.io/timages/weappPay.png" alt="image"></p>
<h3 id="7-微信网页授权流程"><a href="#7-微信网页授权流程" class="headerlink" title="7.微信网页授权流程"></a>7.微信网页授权流程</h3><p>前置条件：<br>        公众平台设置授权回调域名，在域名内页面可进行OAuth2.0鉴权</p>
<p>关于网页授权的两种scope的区别说明<br>1.以snsapi_base为scope发起的网页授权，是用来获取进入页面的用户的openid的，并且是静默授权跳转到回调页面的<br>2.snsapi_userinfo为scope发起的网页授权，是用来获取用户基本信息的，但是需要用户手动同意，由于用户同意过所以无需关注就可获取用户基本信息<br>3、用户管理类接口中的“获取用户基本信息接口”，是在用户和公众号产生消息交互或关注后事件推送后，才能根据用户OpenID来获取用户基本信息。这个接口，包括其他微信接口，都是需要该用户（即openid）关注了公众号后，才能调用成功的。</p>
<p>网页授权流程分为四步：<br>        1.引导用户进入授权页面，同意授权，获取code<br>        2.通过code换取网页授权access_token<br>        3.如果需要，刷新access_token<br>        4.通过access_token和opened获取用户基本信息</p>
<h3 id="8-小程序登录流程"><a href="#8-小程序登录流程" class="headerlink" title="8.小程序登录流程"></a>8.小程序登录流程</h3><p>1.wx.login()获取code，传给开发者服务器<br>2.开发者服务器用appid,appsecret,code调用登录凭证校验<br>（ auth.code2Session ）向微信服务器获取openid和sessionkey<br>3.发者服务器可以根据用户标识来生成自定义登录态，用于后<br>续业务逻辑中前后端交互时识别用户身份。</p>
<h3 id="9-小程序授权"><a href="#9-小程序授权" class="headerlink" title="9.小程序授权"></a>9.小程序授权</h3><p>如果用户未接受或拒绝过此权限，会弹窗询问用户，用户点击同意后方可调用接口；</p>
<p>如果用户已授权，可以直接调用接口；</p>
<p>如果用户已拒绝授权，则不会出现弹窗，而是直接进入接口fail 回调。请开发者兼容用户拒绝授权的场景。（wx.openSetting引导用户进行授权）</p>
<p>开发者可以使用 wx.getSetting 获取用户当前的授权状态。</p>
<p>微信小程序分为两个部分：webview 和 appService。其中 webview 主要用来展示 UI，appService 用来处理业务逻辑、数据及接口调用。它们在两个进程中进行，通过系统层 JSBridge 实现通信，实现 UI 的渲染、事件的处理</p>
<h3 id="10-网络协议"><a href="#10-网络协议" class="headerlink" title="10.网络协议"></a>10.网络协议</h3><p>网络分层<br>目前网络分层可分为两种：OSI 模型和 TCP/IP 模型<br>OSI模型</p>
<pre><code>应用层（Application）
表示层（Presentation）
会话层（Session）
传输层（Transport）
网络层（Network）
数据链路层（Data Link）
物理层（Physical）</code></pre>
<p>TCP/IP模型</p>
<pre><code>应用层（Application）
传输层（Host-to-Host Transport）
互联网层（Internet）
网络接口层（Network Interface）</code></pre>
<h3 id="11-HTTP-HTTPS"><a href="#11-HTTP-HTTPS" class="headerlink" title="11.HTTP/HTTPS"></a>11.HTTP/HTTPS</h3><p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用<br>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议<br>3、http和https使用的是完全不同的连接方式，用的端口也不一样，默认前者是80，后者是443<br>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p>
<h3 id="12-从输入URL到页面加载到过程？"><a href="#12-从输入URL到页面加载到过程？" class="headerlink" title="12.从输入URL到页面加载到过程？"></a>12.从输入URL到页面加载到过程？</h3><p>1.浏览器地址栏输入URL并回车<br>2.通过DNS将域名解析成IP地址。在解析过程中，按照浏览器缓存、系统缓存、路由器缓存、ISP(运营商)DNS缓存、根域名服务器、顶级域名服务器、主域名服务器的顺序，逐步读取缓存，直到拿到IP地址。（应用层）<br>3.根据获取IP进行tcp连接（三次握手）（传输层）<br>4.发送http请求<br>5.服务器处理请求，浏览器接收http的响应<br>6.渲染页面，构造dom树<br>7.关闭tcp连接（四次挥手）</p>
<h3 id="13-HTTP状态码"><a href="#13-HTTP状态码" class="headerlink" title="13.HTTP状态码"></a>13.HTTP状态码</h3><p>区分状态码<br>    1××开头  - 临时响应<br>    2××开头  - 请求成功<br>    3××开头  - 请求被重定向<br>    4××开头  - 请求错误<br>    5××开头  - 服务器错误<br>常见状态码<br>    200 - 请求成功，Ajax 接受到信息了<br>    400 - 服务器不理解请求<br>    403 - 服务器拒绝请求<br>    404 - 请求页面错误<br>    500 - 服务器内部错误，无法完成请求</p>
<h3 id="14-性能优化"><a href="#14-性能优化" class="headerlink" title="14.性能优化"></a>14.性能优化</h3><ul>
<li><p>HTML优化<br>  1、避免 HTML 中书写 CSS 代码，因为这样难以维护。<br>  2、使用 Viewport 加速页面的渲染。<br>  3、使用语义化标签，减少 CSS 代码，增加可读性和 SEO。<br>  4、减少标签的使用，DOM 解析是一个大量遍历的过程，减少不必要的标签，能降低遍历的次数。<br>  5、避免 src、href 等的值为空，因为即时它们为空，浏览器也会发起 HTTP 请求。</p>
</li>
<li><p>CSS优化<br>  1、优化选择器路径：使用 .c {} 而不是 .a .b .c {}。<br>  2、选择器合并：共同的属性内容提起出来，压缩空间和资源开销。<br>  3、精准样式：使用 padding-left: 10px 而不是 padding: 0 0 0 10px。<br>  4、雪碧图：将小的图标合并到一张图中，这样所有的图片只需要请求一次。<br>  5、避免通配符：.a .b <em>{} 这样的选择器，根据从右到左的解析顺序在解析过程中遇到通配符</em> {} 会遍历整个 DOM，性能大大损耗。<br>  6、少用 float：float 在渲染时计算量比较大，可以使用 flex 布局。<br>  7、为 0 值去单位：增加兼容性。<br>  8、压缩文件大小，减少资源下载负担。</p>
</li>
<li><p>JavaScript优化<br>  1、尽可能把 <code>&lt;script&gt;</code> 标签放在 body 之后，避免 JS 的执行卡住 DOM 的渲染，最大程度保证页面尽快地展示出来<br>  2、尽可能合并 JS 代码：提取公共方法，进行面向对象设计等……<br>  3、CSS 能做的事情，尽量不用 JS 来做，毕竟 JS 的解析执行比较粗暴，而 CSS 效率更高。<br>  4、尽可能逐条操作 DOM，并预定好 CSs 样式，从而减少 reflow 或者 repaint 的次数。<br>  5、尽可能少地创建 DOM，而是在 HTML 和 CSS 中使用 display: none 来隐藏，按需显示。<br>  6、压缩文件大小，减少资源下载负担。</p>
</li>
</ul>

  </div>
  <div>
      <!-- <a href="https://github.com/zhaojunyan9528/ZJY.github.io/tree/myblog/source/_posts/前端面试基础.md" target="_blank">编辑</a> -->
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/ZJY.github.io/">首页</a></li>
         
          <li><a href="/ZJY.github.io/archives/">归档</a></li>
         
          <li><a href="/ZJY.github.io/tags">标签</a></li>
         
          <li><a href="/ZJY.github.io/categories">分类</a></li>
         
          <li><a href="/ZJY.github.io/search/">搜索</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-HTML"><span class="toc-number">1.</span> <span class="toc-text">一.HTML</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-html%E8%AF%AD%E4%B9%89%E5%8C%96"><span class="toc-number">1.1.</span> <span class="toc-text">1.html语义化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-HTML5%E6%96%B0%E6%A0%87%E7%AD%BE"><span class="toc-number">1.2.</span> <span class="toc-text">2.HTML5新标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-html5%E8%AF%AD%E4%B9%89%E5%8C%96"><span class="toc-number">1.3.</span> <span class="toc-text">3.html5语义化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-html5%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">1.4.</span> <span class="toc-text">4.html5新特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AF%B9WEB%E6%A0%87%E5%87%86%E5%92%8CW3C%E7%9A%84%E7%90%86%E8%A7%A3%E8%AE%A4%E8%AF%86"><span class="toc-number">1.5.</span> <span class="toc-text">5.对WEB标准和W3C的理解认识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BB%80%E4%B9%88%E6%98%AFDOCTYPE%E5%8F%8A%E4%BD%9C%E7%94%A8"><span class="toc-number">1.6.</span> <span class="toc-text">6.什么是DOCTYPE及作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-CSS"><span class="toc-number">2.</span> <span class="toc-text">二.CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">1.盒模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-rem%E5%92%8Cem%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.</span> <span class="toc-text">2.rem和em的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B8%B8%E8%A7%81%E5%8D%95%E4%BD%8D"><span class="toc-number">2.3.</span> <span class="toc-text">3.常见单位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%A7%86%E5%8F%A3%E9%85%8D%E7%BD%AE"><span class="toc-number">2.4.</span> <span class="toc-text">4.移动端视口配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%B8%90%E8%BF%9B%E5%A2%9E%E5%BC%BA%E4%B8%8E%E4%BC%98%E9%9B%85%E9%99%8D%E7%BA%A7%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.</span> <span class="toc-text">5.渐进增强与优雅降级的理解及区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-cookie%E3%80%81sessionStorage%E3%80%81localStorage%E5%8C%BA%E5%88%AB"><span class="toc-number">2.6.</span> <span class="toc-text">6.cookie、sessionStorage、localStorage区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-css%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">2.7.</span> <span class="toc-text">7.css选择器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-css3%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">2.8.</span> <span class="toc-text">8.css3新特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0"><span class="toc-number">2.9.</span> <span class="toc-text">9.行内元素和块级元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-css%E7%9A%84position%E7%9A%84%E5%AE%9A%E4%BD%8D"><span class="toc-number">2.10.</span> <span class="toc-text">10.css的position的定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-Flex%E5%B8%83%E5%B1%80"><span class="toc-number">2.11.</span> <span class="toc-text">11.Flex布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-display%E6%9C%89%E5%93%AA%E4%BA%9B%E5%80%BC%EF%BC%9F%E8%AF%B4%E6%98%8E%E4%BB%96%E4%BB%AC%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.12.</span> <span class="toc-text">12.display有哪些值？说明他们的作用?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-BFC"><span class="toc-number">2.13.</span> <span class="toc-text">13.BFC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-number">2.14.</span> <span class="toc-text">14.水平垂直居中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-Sass%E3%80%81Less%E3%80%81Stylus%E5%8C%BA%E5%88%AB"><span class="toc-number">2.15.</span> <span class="toc-text">15.Sass、Less、Stylus区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-display-none%E4%B8%8Evisibility-hidden%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.16.</span> <span class="toc-text">16.display: none与visibility: hidden的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E9%87%8D%E7%BB%98-amp-%E5%9B%9E%E6%B5%81"><span class="toc-number">2.17.</span> <span class="toc-text">17.重绘 &amp; 回流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E9%98%B2%E6%8A%96%EF%BC%88debounce%EF%BC%89"><span class="toc-number">2.18.</span> <span class="toc-text">18.防抖（debounce）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E8%8A%82%E6%B5%81%EF%BC%88throttle%EF%BC%89"><span class="toc-number">2.19.</span> <span class="toc-text">19.节流（throttle）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E8%8E%B7%E5%8F%96%E7%9B%92%E5%AD%90%E5%AE%BD%E9%AB%98%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8C%BA%E5%88%AB"><span class="toc-number">2.20.</span> <span class="toc-text">20.获取盒子宽高的几种方式及区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-link%E5%92%8Cimport%E5%8C%BA%E5%88%AB"><span class="toc-number">2.21.</span> <span class="toc-text">21.link和import区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E5%A4%9A%E8%A1%8C%E5%85%83%E7%B4%A0%E7%9C%81%E7%95%A5%E5%8F%B7"><span class="toc-number">2.22.</span> <span class="toc-text">22.多行元素省略号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-JS"><span class="toc-number">3.</span> <span class="toc-text">三.JS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JS%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">1.JS的基本数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%87%A0%E7%A7%8D%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.2.</span> <span class="toc-text">2.几种判断数据类型的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-null%E5%92%8Cundefined%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.3.</span> <span class="toc-text">3.null和undefined的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AF%B9%E8%B1%A1%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.4.</span> <span class="toc-text">4.对象深浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%95%B0%E7%BB%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.</span> <span class="toc-text">5.数组基本方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-js%E6%9C%89%E9%82%A3%E4%BA%9B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.6.</span> <span class="toc-text">6.js有那些内置对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-get%E8%AF%B7%E6%B1%82%E4%BC%A0%E5%8F%82%E9%95%BF%E5%BA%A6%E7%9A%84%E8%AF%AF%E5%8C%BA"><span class="toc-number">3.7.</span> <span class="toc-text">7.get请求传参长度的误区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="toc-number">3.8.</span> <span class="toc-text">8.同步任务和异步任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">3.9.</span> <span class="toc-text">9.事件和回调函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">3.10.</span> <span class="toc-text">10.定时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.11.</span> <span class="toc-text">11.进程和线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-axios%E5%9C%A8vue-js%E4%B8%AD%E5%BA%94%E7%94%A8%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">3.12.</span> <span class="toc-text">12.axios在vue.js中应用和特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-HTTP%E4%B8%AD%E5%AE%9A%E4%B9%89%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F"><span class="toc-number">3.13.</span> <span class="toc-text">13.HTTP中定义请求方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-get%E5%92%8Cpost%E5%8C%BA%E5%88%AB"><span class="toc-number">3.14.</span> <span class="toc-text">14.get和post区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-http%E4%B8%ADcontent-type"><span class="toc-number">3.15.</span> <span class="toc-text">15.http中content-type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-import%E5%92%8Crequire%E5%8C%BA%E5%88%AB"><span class="toc-number">3.16.</span> <span class="toc-text">16.import和require区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-ajax"><span class="toc-number">3.17.</span> <span class="toc-text">17.ajax</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E9%97%AD%E5%8C%85"><span class="toc-number">3.18.</span> <span class="toc-text">18.闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-js%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-number">3.19.</span> <span class="toc-text">19.js作用域和作用域链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E7%BB%84%E4%BB%B6%E5%8C%96%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">3.20.</span> <span class="toc-text">20.组件化和模块化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E5%9B%BE%E7%89%87%E7%9A%84%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">3.21.</span> <span class="toc-text">21.图片的预加载和懒加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-mouseover%E5%92%8Cmouseenter%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.22.</span> <span class="toc-text">22.mouseover和mouseenter的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E5%AF%B9This%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.23.</span> <span class="toc-text">23.对This对象的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-ES6%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD"><span class="toc-number">3.24.</span> <span class="toc-text">24.ES6其他常用功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-bind%E3%80%81call%E3%80%81apply%E7%94%A8%E6%B3%95%E5%8F%8A%E5%8C%BA%E5%88%AB"><span class="toc-number">3.25.</span> <span class="toc-text">25.bind、call、apply用法及区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E7%9B%AE%E5%89%8DJS%E8%A7%A3%E5%86%B3%E5%BC%82%E6%AD%A5%E7%9A%84%E6%96%B9%E6%A1%88%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">3.26.</span> <span class="toc-text">26.目前JS解决异步的方案有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">3.27.</span> <span class="toc-text">27.创建对象有几种方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-Vue"><span class="toc-number">4.</span> <span class="toc-text">四.Vue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">1.Vue生命周期的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%80%BB%E5%85%B1%E6%9C%89%E5%87%A0%E4%B8%AA%E9%98%B6%E6%AE%B5%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">2.Vue生命周期总共有几个阶段？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-DOM%E6%B8%B2%E6%9F%93%E5%9C%A8%E5%93%AA%E4%B8%AA%E5%91%A8%E6%9C%9F%E4%B8%AD%E5%B0%B1%E5%B7%B2%E7%BB%8F%E5%AE%8C%E6%88%90%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">3.DOM渲染在哪个周期中就已经完成？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%AF%8F%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%80%82%E5%90%88%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">4.每个生命周期适合哪些场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%85%B3%E4%BA%8Evue%E7%9A%84keep-alive%E9%9C%80%E8%A6%81%E6%9D%A1%E4%BB%B6%E6%80%A7%E7%BC%93%E5%AD%98%E7%9A%84%E8%A7%A3%E5%86%B3"><span class="toc-number">4.5.</span> <span class="toc-text">5.关于vue的keep-alive需要条件性缓存的解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Vue-%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">4.6.</span> <span class="toc-text">6.Vue 路由懒加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Proxy%E4%B8%8EObject-defineProperty-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">4.7.</span> <span class="toc-text">7.Proxy与Object.defineProperty()的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-v-show%E4%B8%8Ev-if%E5%8C%BA%E5%88%AB"><span class="toc-number">4.8.</span> <span class="toc-text">8.v-show与v-if区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-vue%E6%9C%89%E5%93%AA%E4%BA%9B%E6%8C%87%E4%BB%A4"><span class="toc-number">4.9.</span> <span class="toc-text">9.vue有哪些指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E5%80%BC%E9%80%9A%E4%BF%A1"><span class="toc-number">4.10.</span> <span class="toc-text">10.组件之间的传值通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%AD%90%E7%BB%84%E4%BB%B6%E8%B0%83%E7%94%A8%E7%88%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95%E5%87%BD%E6%95%B0"><span class="toc-number">4.11.</span> <span class="toc-text">11.子组件调用父组件的方法函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E6%96%B9%E5%BC%8F"><span class="toc-number">4.12.</span> <span class="toc-text">12.路由跳转方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-mvvm"><span class="toc-number">4.13.</span> <span class="toc-text">13.mvvm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-computed%E5%92%8Cwatch%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">4.14.</span> <span class="toc-text">14.computed和watch有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-key"><span class="toc-number">4.15.</span> <span class="toc-text">15.key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84data%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">4.16.</span> <span class="toc-text">16.组件中的data为什么是函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-Class-%E4%B8%8E-Style-%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%EF%BC%9F"><span class="toc-number">4.17.</span> <span class="toc-text">17.Class 与 Style 如何动态绑定？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-vue%E7%9A%84%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">4.18.</span> <span class="toc-text">18.vue的单向数据流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-keep-alive"><span class="toc-number">4.19.</span> <span class="toc-text">19.keep-alive</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-v-model-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">4.20.</span> <span class="toc-text">20.v-model 的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-nextTick"><span class="toc-number">4.21.</span> <span class="toc-text">21.nextTick()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-vue%E6%8F%92%E6%A7%BD"><span class="toc-number">4.22.</span> <span class="toc-text">22.vue插槽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB"><span class="toc-number">4.23.</span> <span class="toc-text">23.导航守卫</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-vuex%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.24.</span> <span class="toc-text">24.vuex是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E4%BC%98%E5%8C%96SPA%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6"><span class="toc-number">4.25.</span> <span class="toc-text">25.优化SPA首屏加载速度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E4%BD%A0%E6%9C%89%E5%AF%B9-Vue-%E9%A1%B9%E7%9B%AE%E8%BF%9B%E8%A1%8C%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">4.26.</span> <span class="toc-text">26.你有对 Vue 项目进行哪些优化？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-ES6"><span class="toc-number">5.</span> <span class="toc-text">五.ES6</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-var-let-const%E5%8C%BA%E5%88%AB"><span class="toc-number">5.1.</span> <span class="toc-text">1.var let const区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">5.2.</span> <span class="toc-text">2.解构赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-forEach%E3%80%81for-in%E3%80%81for-of%E4%B8%89%E8%80%85%E5%8C%BA%E5%88%AB"><span class="toc-number">5.3.</span> <span class="toc-text">3.forEach、for in、for of三者区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%BA%94%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.4.</span> <span class="toc-text">4.使用箭头函数应注意什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Set%E3%80%81Map%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.5.</span> <span class="toc-text">5.Set、Map的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Ajax"><span class="toc-number">5.6.</span> <span class="toc-text">6.Ajax</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.7.</span> <span class="toc-text">7.同步和异步的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-ajax%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-number">5.8.</span> <span class="toc-text">8.ajax的优点和缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-get%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.9.</span> <span class="toc-text">9.get和post的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8post%EF%BC%9F"><span class="toc-number">5.10.</span> <span class="toc-text">10.什么时候使用post？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="toc-number">5.11.</span> <span class="toc-text">11.同源策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="toc-number">5.12.</span> <span class="toc-text">12.如何解决跨域问题?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-number">6.</span> <span class="toc-text">六.浏览器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BB%E6%B5%81%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-number">6.1.</span> <span class="toc-text">1.主流浏览器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8"><span class="toc-number">6.2.</span> <span class="toc-text">2.浏览器内核</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9"><span class="toc-number">6.3.</span> <span class="toc-text">3.浏览器兼容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-%E5%85%B6%E4%BB%96"><span class="toc-number">7.</span> <span class="toc-text">七.其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%89%8D%E7%AB%AF%E7%BB%84%E4%BB%B6%E5%8C%96%E5%92%8C%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">7.1.</span> <span class="toc-text">1.前端组件化和模块化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AFAjax%E5%92%8CJSON%EF%BC%8C%E5%AE%83%E4%BB%AC%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-number">7.2.</span> <span class="toc-text">2.什么是Ajax和JSON，它们的优点和缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Github"><span class="toc-number">7.3.</span> <span class="toc-text">3.Github</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-webpack"><span class="toc-number">7.4.</span> <span class="toc-text">4.webpack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F"><span class="toc-number">7.5.</span> <span class="toc-text">5.微信小程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B"><span class="toc-number">7.6.</span> <span class="toc-text">6.微信小程序支付流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%BE%AE%E4%BF%A1%E7%BD%91%E9%A1%B5%E6%8E%88%E6%9D%83%E6%B5%81%E7%A8%8B"><span class="toc-number">7.7.</span> <span class="toc-text">7.微信网页授权流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B"><span class="toc-number">7.8.</span> <span class="toc-text">8.小程序登录流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8E%88%E6%9D%83"><span class="toc-number">7.9.</span> <span class="toc-text">9.小程序授权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE"><span class="toc-number">7.10.</span> <span class="toc-text">10.网络协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-HTTP-HTTPS"><span class="toc-number">7.11.</span> <span class="toc-text">11.HTTP&#x2F;HTTPS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%88%B0%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">7.12.</span> <span class="toc-text">12.从输入URL到页面加载到过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">7.13.</span> <span class="toc-text">13.HTTP状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">7.14.</span> <span class="toc-text">14.性能优化</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/&text=前端面试基础"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/&title=前端面试基础"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/&is_video=false&description=前端面试基础"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=前端面试基础&body=Check out this article: https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/&title=前端面试基础"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/&title=前端面试基础"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/&title=前端面试基础"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/&title=前端面试基础"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/&name=前端面试基础&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/&t=前端面试基础"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2020-2023
    ZJY
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/ZJY.github.io/">首页</a></li>
         
          <li><a href="/ZJY.github.io/archives/">归档</a></li>
         
          <li><a href="/ZJY.github.io/tags">标签</a></li>
         
          <li><a href="/ZJY.github.io/categories">分类</a></li>
         
          <li><a href="/ZJY.github.io/search/">搜索</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/ZJY.github.io/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/ZJY.github.io/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/ZJY.github.io/lib/jquery/jquery.min.js"></script>


<script src="/ZJY.github.io/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/ZJY.github.io/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>


<script src="/ZJY.github.io/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
