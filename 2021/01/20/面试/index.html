<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="1.webpack优化 优化开发体验（提升开发效率）  优化构建速度 （配置时相关路径尽量写绝对路径，以减少查找，代码中写导入语句时，确定文件时带上文件后缀，以避免查找） 使用DllPlugin (动态链接库,原因在于包含大量复用模块的动态链接库只需要编译一次，在之后的构建过程中被动态链接库包含的模块将不会在重新编译，而是直接使用动态链接库中的代码) 使用HappyPack （在整个 Webpac">
<meta property="og:type" content="article">
<meta property="og:title" content="面试">
<meta property="og:url" content="https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E9%9D%A2%E8%AF%95/index.html">
<meta property="og:site_name" content="ZJY">
<meta property="og:description" content="1.webpack优化 优化开发体验（提升开发效率）  优化构建速度 （配置时相关路径尽量写绝对路径，以减少查找，代码中写导入语句时，确定文件时带上文件后缀，以避免查找） 使用DllPlugin (动态链接库,原因在于包含大量复用模块的动态链接库只需要编译一次，在之后的构建过程中被动态链接库包含的模块将不会在重新编译，而是直接使用动态链接库中的代码) 使用HappyPack （在整个 Webpac">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zhaojunyan9528.github.io/ZJY.github.io/images/minxins1.png">
<meta property="og:image" content="https://zhaojunyan9528.github.io/ZJY.github.io/images/minxins2.png">
<meta property="og:image" content="https://zhaojunyan9528.github.io/ZJY.github.io/images/minxins3.png">
<meta property="article:published_time" content="2021-01-20T17:24:08.000Z">
<meta property="article:modified_time" content="2023-05-31T08:30:59.815Z">
<meta property="article:author" content="ZJY">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zhaojunyan9528.github.io/ZJY.github.io/images/minxins1.png">
    
    
      
        
          <link rel="shortcut icon" href="/ZJY.github.io/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/ZJY.github.io/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/ZJY.github.io/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>面试</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/ZJY.github.io/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/ZJY.github.io/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/ZJY.github.io/">首页</a></li>
         
          <li><a href="/ZJY.github.io/archives/">归档</a></li>
         
          <li><a href="/ZJY.github.io/tags">标签</a></li>
         
          <li><a href="/ZJY.github.io/categories">分类</a></li>
         
          <li><a href="/ZJY.github.io/search/">搜索</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/ZJY.github.io/2021/01/20/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/ZJY.github.io/2021/01/20/javascript-symbol%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E9%9D%A2%E8%AF%95/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E9%9D%A2%E8%AF%95/&text=面试"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E9%9D%A2%E8%AF%95/&title=面试"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E9%9D%A2%E8%AF%95/&is_video=false&description=面试"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=面试&body=Check out this article: https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E9%9D%A2%E8%AF%95/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E9%9D%A2%E8%AF%95/&title=面试"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E9%9D%A2%E8%AF%95/&title=面试"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E9%9D%A2%E8%AF%95/&title=面试"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E9%9D%A2%E8%AF%95/&title=面试"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E9%9D%A2%E8%AF%95/&name=面试&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E9%9D%A2%E8%AF%95/&t=面试"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-webpack%E4%BC%98%E5%8C%96"><span class="toc-number">1.</span> <span class="toc-text">1.webpack优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-webpack%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%E7%8E%AF%E5%A2%83%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">2.webpack如何区分环境？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E8%B7%AF%E7%94%B1%E4%BB%A5%E5%8F%8AsetData%E5%8E%9F%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">3.小程序的生命周期和路由以及setData原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%93%AA%E4%BA%9Bcss%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">4.哪些css属性可以继承？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-call-apply-bind%E9%83%BD%E6%98%AF%E7%94%A8%E6%9D%A5%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89this%E5%AF%B9%E8%B1%A1%E7%9A%84"><span class="toc-number">5.</span> <span class="toc-text">5.call&#x2F;apply&#x2F;bind都是用来重新定义this对象的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-z-index%E5%B1%9E%E6%80%A7"><span class="toc-number">6.</span> <span class="toc-text">6.z-index属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">7.</span> <span class="toc-text">7.vue生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-JavaScript%E7%9A%84let%E5%92%8Cconst"><span class="toc-number">8.</span> <span class="toc-text">8.JavaScript的let和const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">9.</span> <span class="toc-text">9.箭头函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-vuex%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8C%81%E4%B8%8D%E5%8F%98"><span class="toc-number">10.</span> <span class="toc-text">10.vuex页面刷新数据保持不变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%85%AC%E4%BC%97%E5%8F%B7openid%E5%92%8Cunionid%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">11.</span> <span class="toc-text">11.公众号openid和unionid的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-axios%E7%BB%9F%E4%B8%80%E5%B0%81%E8%A3%85"><span class="toc-number">12.</span> <span class="toc-text">12.axios统一封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E6%95%B0%E7%BB%84%E7%9A%84toString%E6%96%B9%E6%B3%95"><span class="toc-number">13.</span> <span class="toc-text">13.数组的toString方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E5%AF%B9%E8%B1%A1%E7%9A%84toString%E6%96%B9%E6%B3%95"><span class="toc-number">14.</span> <span class="toc-text">14.对象的toString方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E6%80%8E%E6%A0%B7%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%B8%8D%E6%98%AF%E6%95%B0%E7%BB%84%EF%BC%9F"><span class="toc-number">15.</span> <span class="toc-text">15.怎样判断一个对象是不是数组？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-js%E8%A7%A3%E5%86%B3%E8%8B%B9%E6%9E%9C%E7%A7%BB%E5%8A%A8%E7%AB%AF300ms%E5%BB%B6%E8%BF%9F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">16.</span> <span class="toc-text">16.js解决苹果移动端300ms延迟的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">17.</span> <span class="toc-text">17.tcp三次握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">18.</span> <span class="toc-text">18.四次挥手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-osi%E6%A8%A1%E5%9E%8B"><span class="toc-number">19.</span> <span class="toc-text">19.osi模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-vue-minxins"><span class="toc-number">20.</span> <span class="toc-text">20.vue minxins</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">21.</span> <span class="toc-text">21.git常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-vue%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9Fdom"><span class="toc-number">22.</span> <span class="toc-text">22.vue中的虚拟dom</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="toc-number">23.</span> <span class="toc-text">23.vue双向绑定原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-on-once-emit-off"><span class="toc-number">24.</span> <span class="toc-text">24.$on,$once,$emit,$off</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-vue%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%EF%BC%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8F%98%E5%BC%82%E6%A3%80%E6%B5%8B"><span class="toc-number">25.</span> <span class="toc-text">25.vue的响应式原理，数组的变异检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-vue-loader"><span class="toc-number">26.</span> <span class="toc-text">26.vue-loader</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        面试
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">ZJY</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2021-01-20T17:24:08.000Z" itemprop="datePublished">2021-01-20</time>
        
        (Updated: <time datetime="2023-05-31T08:30:59.815Z" itemprop="dateModified">2023-05-31</time>)
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/ZJY.github.io/categories/%E9%9D%A2%E8%AF%95/">面试</a> › <a class="category-link" href="/ZJY.github.io/categories/%E9%9D%A2%E8%AF%95/Javascript/">Javascript</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/ZJY.github.io/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h3 id="1-webpack优化"><a href="#1-webpack优化" class="headerlink" title="1.webpack优化"></a>1.webpack优化</h3><ul>
<li><p>优化开发体验（提升开发效率）</p>
<ul>
<li>优化构建速度 （配置时相关路径尽量写绝对路径，以减少查找，代码中写导入语句时，确定文件时带上文件后缀，以避免查找）</li>
<li>使用DllPlugin (动态链接库,原因在于包含大量复用模块的动态链接库只需要编译一次，在之后的构建过程中被动态链接库包含的模块将不会在重新编译，而是直接使用动态链接库中的代码)</li>
<li>使用HappyPack （在整个 Webpack 构建流程中，最耗时的流程可能就是 Loader 对文件的转换操作了，因为要转换的文件数据巨多，而且这些转换操作都只能一个个挨着处理。HappyPack的核心原理就是把这部分任务分解到多个进程去并行处理，从而减少了总的构建时间。）</li>
<li>使用ParallelUglifyPlugin (ParallelUglifyPlugin 会开启多个子进程，把对多个文件的压缩工作分配给多个子进程去完成，每个子进程其实还是通过 UglifyJS去压缩代码，但是变成了并行执行)</li>
</ul>
</li>
<li><p>优化使用体验</p>
<ul>
<li>使用自动刷新（使用 webpack 模块负责监听文件，webpack-dev-server 模块则负责刷新浏览器。）</li>
<li>使用模块热替换 （hot）</li>
</ul>
</li>
<li><p>优化输出质量</p>
<ul>
<li>减少用户能感知到的加载时间，也就是首屏加载<ul>
<li>区分环境 （开发和线上环境 代码压缩和提示日志）</li>
<li>压缩代码 （UglifyJsPlugin：通过封装 UglifyJS 实现压缩。ParallelUglifyPlugin：多进程并行处理压缩）</li>
<li>CDN加速 （CDN 又叫内容分发网络，通过把资源部署到世界各地，用户在访问时按照就近原则从离用户最近的服务器获取资源，从而加速资源的获取速度。要给网站接入 CDN，需要把网页的静态资源上传到 CDN 服务上去，在服务这些静态资源的时候需要通过 CDN 服务提供的 URL 地址去访问）</li>
<li>使用Tree Shaking (Tree Shaking 可以用来剔除 JavaScript 中用不上的死代码)</li>
<li>提取公共代码</li>
<li>按需加载</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-webpack如何区分环境？"><a href="#2-webpack如何区分环境？" class="headerlink" title="2.webpack如何区分环境？"></a>2.webpack如何区分环境？</h3><p>具体区分方法很简单，在源码中通过如下方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;你正在线上环境&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;你正在使用开发环境&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其大概原理是借助于环境变量的值去判断执行哪个分支</p>
<h3 id="3-小程序的生命周期和路由以及setData原理"><a href="#3-小程序的生命周期和路由以及setData原理" class="headerlink" title="3.小程序的生命周期和路由以及setData原理"></a>3.小程序的生命周期和路由以及setData原理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">onLaunch</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onLaunch监听小程序初始化&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">onShow</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onShow监听小程序显示&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">onHide</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onHide监听小程序隐藏&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小程序的生命周期函数的调用顺序为：onLaunch&gt;onShow&gt;onHide</p>
<p>页面生命周期：<br>页面生命周期函数就是当你每进入/切换到一个新的页面的时候，就会调用的生命周期函数。Page(Object) 函数用来注册一个页面。接受一个Object类型参数，其指定页面的初始数据、生命周期回调、事件处理函数等。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">onLoad</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onLoad监听页面加载:首次进入页面加载时触发，可以在 onLoad 的参数中获取打开当前页面路径中的参数。&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">onReady</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onReady监听页面初次渲染完成&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">onShow</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onShow监听页面显示:加载完成后、后台切到前台或重新进入页面时触发&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">onHide</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onHide监听页面隐藏&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">onUnload</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;onUnload监听页面卸载&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生命周期函数的调用顺序为：onLoad&gt;onShow&gt;onReady。</p>
<p>首次进入小程序会先触发应用生命周期中onLaunch方法和onShow方法，其次触发页面生命周期中onLoad、onShow和onReady方法。</p>
<p>前台切换到后台时，先触发页面生命周期中onHide方法，再触发应用生命周期的onHide方法。</p>
<p>后台切换到前台时，先触发应用生命周期中onShow方法，再触发页面生命周期的onShow方法。</p>
<p>setData:setData 函数用于将数据从逻辑层发送到视图层（异步），同时改变对应的 this.data 的值（同步）</p>
<p>setData工作原理<br>小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。当前，视图层和逻辑层的数据传输，实际上通过两边提供的 evaluateJavascript 所实现。即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。</p>
<p>而 evaluateJavascript 的执行会受很多方面的影响，数据到达视图层并不是实时的。</p>
<h3 id="4-哪些css属性可以继承？"><a href="#4-哪些css属性可以继承？" class="headerlink" title="4.哪些css属性可以继承？"></a>4.哪些css属性可以继承？</h3><p>可继承的有： font-size font-family color、<br>不可继承的有：border、padding、margin、width、height<br>与字体相关的样式通常可以继承，与尺寸相关的样式通常不能继承</p>
<h3 id="5-call-apply-bind都是用来重新定义this对象的"><a href="#5-call-apply-bind都是用来重新定义this对象的" class="headerlink" title="5.call/apply/bind都是用来重新定义this对象的"></a>5.call/apply/bind都是用来重新定义this对象的</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;wang&#x27;</span>,age = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;zhang&#x27;</span>,</span><br><span class="line">    objAag: <span class="built_in">this</span>.age,</span><br><span class="line">    myFun:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;年龄&#x27;</span> + <span class="built_in">this</span>.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.objAag; <span class="comment">//17</span></span><br><span class="line">obj.myFun(); <span class="comment">//zhang年龄undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用call/apply/bind</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db = &#123;</span><br><span class="line">    name:<span class="string">&#x27;dema&#x27;</span>,</span><br><span class="line">    age: <span class="number">99</span></span><br><span class="line">&#125;</span><br><span class="line">obj.myFun.call(db); <span class="comment">// dema年龄99</span></span><br><span class="line">obj.myFun.apply(db); <span class="comment">// dema年龄99</span></span><br><span class="line">obj.myFun.bind(db)(); <span class="comment">// dema年龄99</span></span><br></pre></td></tr></table></figure>
<p>以上除了bind多了个（）外，结果都一致，由此可知，bind返回的是一个新函数，必须调用它能执行</p>
<p>call/apply/bind 传参数区别</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;wang&#x27;</span>,age = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">&#x27;zhang&#x27;</span>,</span><br><span class="line">    objAag: <span class="built_in">this</span>.age,</span><br><span class="line">    myFun:<span class="function"><span class="keyword">function</span>(<span class="params">fm,t</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;年龄&#x27;</span> + <span class="built_in">this</span>.age,<span class="string">&#x27;来自 &#x27;</span>+ fm+<span class="string">&#x27; 去往&#x27;</span>+t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> db = &#123;</span><br><span class="line">    name:<span class="string">&#x27;dema&#x27;</span>,</span><br><span class="line">    age: <span class="number">99</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.myFun.call(db,<span class="string">&#x27;成都&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>); <span class="comment">//dema年龄99 来自 成都 去往上海</span></span><br><span class="line">obj.myFun.apply(db,[<span class="string">&#x27;成都&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>]); <span class="comment">//dema年龄99 来自 成都 去往上海</span></span><br><span class="line">obj.myFun.bind(db,[<span class="string">&#x27;成都&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>])(); <span class="comment">//dema年龄99 来自 成都,上海 去往undefined</span></span><br><span class="line">obj.myFun.bind(db,<span class="string">&#x27;成都&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>)(); <span class="comment">//dema年龄99 来自 成都 去往上海</span></span><br><span class="line">obj.myFun.bind(db)(<span class="string">&#x27;成都&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>); <span class="comment">// dema年龄99 来自 成都 去往上海</span></span><br></pre></td></tr></table></figure>
<p>call 、bind 、 apply 这三个函数的第一个参数都是 this 的指向对象,第二个参数：<br>call的参数直接放进去，多个参数用逗号分隔<br>apply的第二个参数是数组<br>bind 除了返回是函数以外，它 的参数和 call 一样</p>
<h3 id="6-z-index属性"><a href="#6-z-index属性" class="headerlink" title="6.z-index属性"></a>6.z-index属性</h3><p>z-index 属性指定一个元素的堆叠顺序。</p>
<p>拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。</p>
<p>注释：元素可拥有负的 z-index 属性值。</p>
<p>注释：Z-index 仅能在定位元素上奏效（例如 position:absolute, position:relative, or position:fixed)</p>
<p>可能的值：</p>
<ul>
<li>auto ：默认。堆叠顺序与父元素相等。</li>
<li>number ：设置元素的堆叠顺序。</li>
<li>inherit： 规定应该从父元素继承 z-index 属性的值。</li>
</ul>
<p>默认的 z-index 是 0</p>
<h3 id="7-vue生命周期"><a href="#7-vue生命周期" class="headerlink" title="7.vue生命周期"></a>7.vue生命周期</h3><ul>
<li>beforeCreate：在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用</li>
<li>created：在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，property 和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el property 目前尚不可用。一般creadted钩子函数主要是用来初始化数据。</li>
<li>beforeMount：在挂载开始之前被调用：相关的 render 函数首次被调用。</li>
<li>mounted： 实例被挂载后调用，这时 el 被新创建的 vm.$el 替换了。如果根实例挂载到了一个文档内的元素上，当 mounted 被调用时 vm.$el 也在文档内。注意 mounted 不会保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 mounted 内部使用 vm.$nextTick。该钩子函数是在挂在完成以后也就是模板渲染完成以后才会被调用</li>
<li>beforeUpdate： 数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</li>
<li>updated:由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。</li>
<li>activated：被 keep-alive 缓存的组件激活时调用。</li>
<li>deactivated：被 keep-alive 缓存的组件停用时调用</li>
<li>beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用</li>
<li>destroyed： 实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁</li>
<li>errorCaptured：当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。</li>
</ul>
<h3 id="8-JavaScript的let和const"><a href="#8-JavaScript的let和const" class="headerlink" title="8.JavaScript的let和const"></a>8.JavaScript的let和const</h3><p>ES2015(ES6) 新增加了两个重要的 JavaScript 关键字: let 和 const。</p>
<p>let 声明的变量只能let命令所在代码块内有效<br>const声明一个只读的常量，一旦声明了值，该值就不能改变。</p>
<p>在 ES6 之前，JavaScript 只有两种作用域： 全局变量 与 函数内的局部变量。</p>
<p>全局变量：</p>
<p>在函数外声明的变量是全局的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> carName = <span class="string">&quot;Volvo&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这里可以使用 carName 变量</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里也可以使用 carName 变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>全局变量在js程序的任何地方都可用</p>
<p>局部变量：<br>在函数内部声明的变量的作用域是局部的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里不能使用 carName 变量</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> carName = <span class="string">&quot;Volvo&quot;</span>;</span><br><span class="line">    <span class="comment">// 这里可以使用 carName 变量</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这里不能使用 carName 变量</span></span><br></pre></td></tr></table></figure>
<p>函数内使用var声明的变量只能在函数内部可用，没有用var声明的变量全局可用</p>
<p>javascript的块级作用域：<br>使用var声明的变量不具有块级作用域的特性，在{}外仍然能使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">2</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里可以使用 x 变量</span></span><br></pre></td></tr></table></figure>
<p>在es6之前没有块级作用域的概念<br>es6可以使用let关键字来实现块级作用域<br>let 声明的变量只在 let 命令所在的代码块 {} 内有效，在 {} 之外不能访问。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里不能使用 x 变量</span></span><br></pre></td></tr></table></figure>
<p>重新定义变量：</p>
<p>使用var关键字重新声明变量会带来问题<br>在块中重新声明变量也会重新声明块外的变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 这里输出 x 为 10</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 这里输出 x 为 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里输出 x 为 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>let 关键字就可以解决这个问题，因为它只在 let 命令所在的代码块 {} 内有效。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 这里输出 x 为 10</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 这里输出 x 为 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里输出 x 为 10</span></span><br></pre></td></tr></table></figure>
<p>循环作用域：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一些代码...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里输出 i 为 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 一些代码...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里输出 i 为 5</span></span><br></pre></td></tr></table></figure>
<p>在第一个实例中，使用了 var 关键字，它声明的变量是全局的，包括循环体内与循环体外。</p>
<p>在第二个实例中，使用 let 关键字， 它声明的变量作用域只在循环体内，循环体外的变量不受影响。</p>
<p>局部变量：</p>
<p>在函数体内使用 var 和 let 关键字声明的变量有点类似。</p>
<p>它们的作用域都是 局部的:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 var</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> carName = <span class="string">&quot;Volvo&quot;</span>;   <span class="comment">// 局部作用域</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 let</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> carName = <span class="string">&quot;Volvo&quot;</span>;   <span class="comment">//  局部作用域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>全局变量<br>在函数体外或代码块外使用 var 和 let 关键字声明的变量也有点类似。</p>
<p>它们的作用域都是 全局的:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 var</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;       <span class="comment">// 全局作用域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 let</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">2</span>;       <span class="comment">// 全局作用域</span></span><br></pre></td></tr></table></figure>
<p>HTML 代码中使用全局变量:<br>在JavaScript中，全局作用域是针对JavaScript环境<br>在html中，全局作用域是指window对象</p>
<p>使用var关键字声明的全局作用域变量是属于 window 对象:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> carName = <span class="string">&quot;Volvo&quot;</span>;</span><br><span class="line"><span class="comment">// 可以使用 window.carName 访问变量</span></span><br></pre></td></tr></table></figure>
<p>使用let声明的全局作用域变量不属于window对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> carName = <span class="string">&quot;Volvo&quot;</span>;</span><br><span class="line"><span class="comment">// 不能使用 window.carName 访问变量</span></span><br></pre></td></tr></table></figure>
<p>重置变量：</p>
<p>使用var关键字声明的变量任何地方都可以修改：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// x 为 2</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 现在 x 为 3</span></span><br></pre></td></tr></table></figure>
<p>在相同的作用域下，不能使用let来重置var声明的变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;       <span class="comment">// 合法</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">3</span>;       <span class="comment">// 不合法</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">4</span>;   <span class="comment">// 合法</span></span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>   <span class="comment">// 不合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在相同的作用域下，不能使用let重置let声明的变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">2</span>;       <span class="comment">// 合法</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">3</span>;       <span class="comment">// 不合法</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">4</span>;   <span class="comment">// 合法</span></span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;   <span class="comment">// 不合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在相同作用域下，不能使用var关键字来重置let声明的变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">2</span>;       <span class="comment">// 合法</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;       <span class="comment">// 不合法</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">4</span>;   <span class="comment">// 合法</span></span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">5</span>;   <span class="comment">// 不合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>let 关键字在不同作用域，或不同块级作用域中是可以重新声明赋值的:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">2</span>;       <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">3</span>;   <span class="comment">// 合法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">4</span>;   <span class="comment">// 合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变量提升：</p>
<p>js中，var声明的变量可以先使用后声明</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在这里可以使用 carName 变量</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> carName;</span><br></pre></td></tr></table></figure>
<p>let声明的变量不可以先使用再声明：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在这里不可以使用 carName 变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> carName;</span><br></pre></td></tr></table></figure>
<p>const关键字<br>const用来声明一个或多个常量值，声明时必须进行初始化，且初始化后不可以再修改：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.141592653589793</span>;</span><br><span class="line">PI = <span class="number">3.14</span>;      <span class="comment">// 报错</span></span><br><span class="line">PI = PI + <span class="number">10</span>;   <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>const和let定义变量的类似：</p>
<ul>
<li>二者都是块级作用域</li>
<li>都不能和所在作用域内其他变量或函数同名</li>
</ul>
<p>两者区别：</p>
<ul>
<li>const声明变量必须初始化，let可以不用初始化</li>
<li>const初始化后不可以修改，let初始化后可以修改</li>
</ul>
<p>const并非是一个真正的常量<br>const 的本质: const 定义的变量并非常量，并非不可变，它定义了一个常量引用一个值。使用 const 定义的对象或者数组，其实是可变的。下面的代码并不会报错：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建常量对象</span></span><br><span class="line"><span class="keyword">const</span> car = &#123;<span class="attr">type</span>:<span class="string">&quot;Fiat&quot;</span>, <span class="attr">model</span>:<span class="string">&quot;500&quot;</span>, <span class="attr">color</span>:<span class="string">&quot;white&quot;</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 修改属性:</span></span><br><span class="line">car.color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 添加属性</span></span><br><span class="line">car.owner = <span class="string">&quot;Johnson&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>但不能对常量对象重新赋值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> car = &#123;<span class="attr">type</span>:<span class="string">&quot;Fiat&quot;</span>, <span class="attr">model</span>:<span class="string">&quot;500&quot;</span>, <span class="attr">color</span>:<span class="string">&quot;white&quot;</span>&#125;;</span><br><span class="line">car = &#123;<span class="attr">type</span>:<span class="string">&quot;Volvo&quot;</span>, <span class="attr">model</span>:<span class="string">&quot;EX60&quot;</span>, <span class="attr">color</span>:<span class="string">&quot;red&quot;</span>&#125;;    <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<p>在相同的作用域或块级作用域中，不能使用 const 关键字来重置 var 和 let关键字声明的变量:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;         <span class="comment">// 合法</span></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">2</span>;       <span class="comment">// 不合法</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">2</span>;     <span class="comment">// 合法</span></span><br><span class="line">    <span class="keyword">const</span> x = <span class="number">2</span>;   <span class="comment">// 不合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在相同的作用域或块级作用域中，不能使用 const 关键字来重置 const 关键字声明的变量:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">2</span>;       <span class="comment">// 合法</span></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">3</span>;       <span class="comment">// 不合法</span></span><br><span class="line">x = <span class="number">3</span>;             <span class="comment">// 不合法</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">3</span>;         <span class="comment">// 不合法</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">3</span>;         <span class="comment">// 不合法</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> x = <span class="number">2</span>;   <span class="comment">// 合法</span></span><br><span class="line">    <span class="keyword">const</span> x = <span class="number">3</span>;   <span class="comment">// 不合法</span></span><br><span class="line">    x = <span class="number">3</span>;         <span class="comment">// 不合法</span></span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">3</span>;     <span class="comment">// 不合法</span></span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">3</span>;     <span class="comment">// 不合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>const 关键字在不同作用域，或不同块级作用域中是可以重新声明赋值的:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">2</span>;       <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> x = <span class="number">3</span>;   <span class="comment">// 合法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> x = <span class="number">4</span>;   <span class="comment">// 合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>const 关键字定义的变量则不可以在使用后声明，也就是变量需要先声明再使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">carName = <span class="string">&quot;Volvo&quot;</span>;    <span class="comment">// 在这里不可以使用 carName 变量</span></span><br><span class="line"><span class="keyword">const</span> carName = <span class="string">&quot;Volvo&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="9-箭头函数"><a href="#9-箭头函数" class="headerlink" title="9.箭头函数"></a>9.箭头函数</h3><p>ES6 之前，JavaScript 的 this 对象一直很令人头大，回调函数，经常看到 var self = this 这样的代码，为了将外部 this 传递到回调函数中，那么有了箭头函数，就不需要这样做了，直接使用 this 就行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">&#x27;sayHello&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line">Person.sayHello();  <span class="comment">// 20</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> Person1 = &#123;</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">&#x27;sayHello&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line">Person1.sayHello();  <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>
<p>当我们需要维护this上下文的时候，使用箭头函数</p>
<p>箭头函数：<br>箭头函数提供了一种更加简洁的函数书写方式。基本语法是：<br>参数 =&gt; 函数体</p>
<p>基本用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>);  <span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>当箭头函数没有参数或者有多个参数，要用 () 括起来:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">a,b</span>) =&gt;</span> a+b;</span><br><span class="line">f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">//8</span></span><br></pre></td></tr></table></figure>
<p>当箭头函数函数体有多行语句，用 {} 包裹起来，表示代码块，当只有一行语句，并且需要返回结果时，可以省略 {} , 结果会自动返回。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">a,b</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">let</span> result = a+b;</span><br><span class="line"> <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<p>当箭头函数要返回对象的时候，为了区分于代码块，要用 () 将对象包裹起来</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">id,name</span>) =&gt;</span> &#123;<span class="attr">id</span>: id, <span class="attr">name</span>: name&#125;;</span><br><span class="line">f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">// SyntaxError: Unexpected token :</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">id,name</span>) =&gt;</span> (&#123;<span class="attr">id</span>: id, <span class="attr">name</span>: name&#125;);</span><br><span class="line">f(<span class="number">6</span>,<span class="number">2</span>);  <span class="comment">// &#123;id: 6, name: 2&#125;</span></span><br></pre></td></tr></table></figure>
<p>注意点：没有 this、super、arguments 和 new.target 绑定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 箭头函数里面没有 this 对象，</span></span><br><span class="line">  <span class="comment">// 此时的 this 是外层的 this 对象，即 Window </span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">func(<span class="number">55</span>)  <span class="comment">// Window </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> func = <span class="function">() =&gt;</span> &#123;    </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">func(<span class="number">55</span>);  <span class="comment">// ReferenceError: arguments is not defined</span></span><br></pre></td></tr></table></figure>
<p>箭头函数体中的 this 对象，是定义函数时的对象，而不是使用函数时的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 定义时，this 绑定的是 fn 中的 this 对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// fn 的 this 对象为 &#123;a: 19&#125;</span></span><br><span class="line">fn.call(&#123;<span class="attr">a</span>: <span class="number">18</span>&#125;);  <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>
<p>不可以作为构造函数，也就是不能使用 new 命令，否则会报错</p>
<h3 id="10-vuex页面刷新数据保持不变"><a href="#10-vuex页面刷新数据保持不变" class="headerlink" title="10.vuex页面刷新数据保持不变"></a>10.vuex页面刷新数据保持不变</h3><p>用vuex做全局状态管理的时候，页面刷新，数据会丢失，是因为store中的数据是保存在运行内存中的，页面刷新时就会重新加载vue实例，store会被重新赋值。<br>解决方法：</p>
<p>方案一：<br>由于state中的数据是响应式的，而数据又是通过mutation来修改的，所以在mutation修改state数据时调用localStorage.setItem()方法来进行数据的存储：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state:&#123;</span><br><span class="line">        orderList:[],</span><br><span class="line">        menuList:[]</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        <span class="function"><span class="title">orderList</span>(<span class="params">state,data</span>)</span>&#123;</span><br><span class="line">            state.orderList = data;</span><br><span class="line">            <span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;orderList&#x27;</span>, <span class="built_in">JSON</span>.stringify(data))</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">menuList</span>(<span class="params">state,data</span>)</span>&#123;</span><br><span class="line">            state.menuList = data;</span><br><span class="line">            <span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;menuList&#x27;</span>, <span class="built_in">JSON</span>.stringify(data))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在页面加载的时候再通过localStorage.getItem()方法将值取出放回vuex，可在app.vue的created方法中写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.localStorage.getItem(<span class="string">&#x27;orderList&#x27;</span>))&#123;</span><br><span class="line">        <span class="built_in">this</span>.$store.replaceState(<span class="built_in">Object</span>.assign(&#123;&#125;, <span class="built_in">this</span>.$store.state, <span class="built_in">JSON</span>.parse(<span class="built_in">window</span>.localStorage.getItem(<span class="string">&#x27;orderList&#x27;</span>))))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方案二：<br>方案一能够顺利解决问题，但不断触发localStorage.setItem()方法对性能不是特别友好，而且一直将数据同步到localStorage中似乎就没必要再用vuex做状态管理，直接用localStorage即可，于是对以上解决方法进行了改进，通过监听beforeunload事件来进行数据的localStorage存储，beforeunload事件在页面刷新时进行触发，具体做法是在App.vue的created()周期函数中下如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.localStorage.getItem(<span class="string">&#x27;orderList&#x27;</span>))&#123;</span><br><span class="line">        <span class="built_in">this</span>.$store.replaceState(<span class="built_in">Object</span>.assign(&#123;&#125;, <span class="built_in">this</span>.$store.state, <span class="built_in">JSON</span>.parse(<span class="built_in">window</span>.localStorage.getItem(<span class="string">&#x27;orderList&#x27;</span>))))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;beforeunload&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.localStorage.setItem(<span class="string">&quot;orderList&quot;</span>,<span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>.$store.state.orderList))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-公众号openid和unionid的区别"><a href="#11-公众号openid和unionid的区别" class="headerlink" title="11.公众号openid和unionid的区别"></a>11.公众号openid和unionid的区别</h3><ul>
<li>微信openid和unionid长度是不一样的：openid=28，unionid=29</li>
<li>openid同一用户同一应用唯一，unionid同一用户不同应用唯一<ul>
<li>这里的不同应用是指在同一微信开发平台下的不同应用</li>
<li>为了识别用户，每个用户针对每个公众号会产生一个安全的openid</li>
<li>一个用户虽然对多个公众号和应用有多个不同的openid，但他对所有这些同一开放平台账号下的公众号和应用，只有一个unionid</li>
</ul>
</li>
</ul>
<h3 id="12-axios统一封装"><a href="#12-axios统一封装" class="headerlink" title="12.axios统一封装"></a>12.axios统一封装</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> _axios = axios.create();</span><br><span class="line"></span><br><span class="line">_axios.default.baseURL = <span class="string">&#x27;requesturl&#x27;</span>;</span><br><span class="line">_axios.interceptors.request.use(<span class="function"><span class="keyword">function</span>(<span class="params">config</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 在发送请求前做些什么</span></span><br><span class="line">    config =&gt; &#123;</span><br><span class="line">        config.withCredentials = <span class="literal">true</span>; <span class="comment">// 允许携带token ,这个是解决跨域产生的相关问题</span></span><br><span class="line">        config.timeout = <span class="number">12000</span>;</span><br><span class="line">        config.headers = &#123;</span><br><span class="line">            <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    config.headers[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="string">`<span class="subst">$&#123;<span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;token&#x27;</span>)&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加相应拦截器</span></span><br><span class="line">_axios.interceptors.response.use(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(response.data.code == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> response.data</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(response.data.message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 对相应错误做些什么</span></span><br><span class="line">    <span class="function"><span class="title">swtich</span>(<span class="params">error.response.status</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">401</span>:</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">403</span>:</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">500</span>:</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> _axios;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用axios</span></span><br><span class="line"><span class="keyword">import</span> _axios <span class="keyword">from</span> <span class="string">&#x27;./axios&#x27;</span>;</span><br><span class="line"><span class="comment">// 接口定义</span></span><br><span class="line"><span class="function"><span class="title">getList</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _axios(&#123;</span><br><span class="line">        method: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">        url:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        params:&#123;data&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">postList</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _axios(&#123;</span><br><span class="line">        method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">        url:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        data:&#123;data&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 页面接口调用</span></span><br><span class="line">getList(data).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>12.webpack</p>
<p>loader和plugin的使用</p>
<ul>
<li>loader：下载、使用</li>
<li>plugin: 下载、引入、使用</li>
</ul>
<p>配置文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;resolve&#125; = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">&#x27;./src/index.js&#x27;</span>, <span class="comment">//打包的入口文件</span></span><br><span class="line">    output:&#123;</span><br><span class="line">        <span class="comment">// 输出的文件名，以及文件路径</span></span><br><span class="line">        filename: <span class="string">&#x27;build.js&#x27;</span>, <span class="comment">//输出的文件名</span></span><br><span class="line">        path: resolve(__dirname,<span class="string">&#x27;build&#x27;</span>) <span class="comment">//// 当前路径(__dirname)的build文件夹</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        <span class="comment">// 在此配置loader</span></span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>, <span class="comment">//表示匹配以css结尾的文件</span></span><br><span class="line">                use:[</span><br><span class="line">                    <span class="comment">// 使用以下loader进行编译从下往上</span></span><br><span class="line">                    <span class="string">&#x27;style-loader&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;css-loader&#x27;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test:<span class="regexp">/\.(png|svg|jpg|gif)&amp;/</span>,</span><br><span class="line">                use:[</span><br><span class="line">                    <span class="string">&#x27;file-loader&#x27;</span> <span class="comment">//在Css中有背景和图标等图片，需要安装file-loader来处理</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="comment">// 在此配置插件，插件的作用比loader要强，如压缩编译转换等</span></span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin(), <span class="comment">//清理 /dist 文件夹</span></span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">           title: <span class="string">&#x27;Output Management&#x27;</span></span><br><span class="line">        &#125;), <span class="comment">//生成html文件</span></span><br><span class="line">    ],</span><br><span class="line">      mode: <span class="string">&quot;development&quot;</span>  <span class="comment">//配置当前打包环境 development-开发环境、production-生产环境 （生产环境会压缩代码）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常用loader(按顺序引入)</p>
<p>处理 css</p>
<ul>
<li>style-loader</li>
<li>css-loader</li>
</ul>
<p>处理 less</p>
<ul>
<li>style-loader</li>
<li>css-loader</li>
<li>less-loader(less-loader依赖less，要一起安装)</li>
</ul>
<p>处理css图片资源</p>
<ul>
<li>url-loader(依赖file-loader,可一并安装)</li>
</ul>
<p>处理html图片资源</p>
<ul>
<li>html-loader</li>
</ul>
<p>处理其他资源(如：字体文件等)</p>
<ul>
<li>file-loader</li>
</ul>
<p>常用plugins</p>
<ul>
<li>html-webpack-plugin</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hwp = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>)</span><br><span class="line"><span class="keyword">new</span> hwp(&#123;</span><br><span class="line">  template:<span class="string">&quot;./src/index.html&quot;</span>，  <span class="comment">//以该文件为模板进行复制打包</span></span><br><span class="line">  minify:&#123;</span><br><span class="line">    collapseWhitespace:<span class="literal">true</span>, <span class="comment">//压缩空格</span></span><br><span class="line">    removeComments:<span class="literal">true</span> <span class="comment">// 去除注释</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>clean-webpack-plugin</li>
</ul>
<h3 id="13-数组的toString方法"><a href="#13-数组的toString方法" class="headerlink" title="13.数组的toString方法"></a>13.数组的toString方法</h3><p>数组的toString方法会将数组的每个元素转换为字符串，有逗号拼接并且没有其他界定符</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].toString()</span><br><span class="line"><span class="string">&quot;1,2,3&quot;</span></span><br><span class="line">[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>].toString()</span><br><span class="line"><span class="string">&quot;a,b,c&quot;</span></span><br><span class="line">[<span class="number">1</span>,[<span class="number">2</span>,<span class="string">&quot;c&quot;</span>]].toString()</span><br><span class="line"><span class="string">&quot;1,2,c&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="14-对象的toString方法"><a href="#14-对象的toString方法" class="headerlink" title="14.对象的toString方法"></a>14.对象的toString方法</h3><p>对象的toString方法没有任何参数，返回一个字符串，该方法返回的是调用它的对象的类型或值。<br>当使用“+”运算符把一个字符串和一个对象连接一起或把一个对象传递给alert()或document.write()时，会调用toString方法。</p>
<p>默认的toString方法返回的字符串形式总是[object class],class是对象的内部类型，通常对应的是该对象的构造函数名。例如，Array对象的class值是Array，Function对象的class值是“Function”，Date对象的class值是“Date”，内部Math对象的class值是“Math”，所有Error对象的的class值是“Error”，用户定义的对象（例如Complex）的class值是“Object”。</p>
<h3 id="15-怎样判断一个对象是不是数组？"><a href="#15-怎样判断一个对象是不是数组？" class="headerlink" title="15.怎样判断一个对象是不是数组？"></a>15.怎样判断一个对象是不是数组？</h3><ul>
<li>从原型入手，Array.prototype.isPrototypeOf(obj);<br>利用isPrototypeOf()方法判断Array是否在obj的原型链上</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.isPrototypeOf([]); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.isPrototypeOf(&#123;&#125;); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用instanceof, obj instanceof Array<br>instanceof检测构造函数的prototype属性是否存在实例对象的原型链上</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Object.prototype.toString.call(obj)<br>根据对象的class属性，跨原型链调用toString方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]); <span class="comment">//&quot;[object Array]&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Array.isArray()</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray([]); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h3 id="16-js解决苹果移动端300ms延迟的问题"><a href="#16-js解决苹果移动端300ms延迟的问题" class="headerlink" title="16.js解决苹果移动端300ms延迟的问题"></a>16.js解决苹果移动端300ms延迟的问题</h3><p>做移动端页面开发的可能会了解到，ios系统click事件会有卡顿的现象，这个问题的根源是苹果本身自带的safari有双击放大页面的功能，再次双击会返回到原始尺寸，所以在第一次点击的系统会延迟300ms来判断是不是双击操作，为了解决这个问题，网上也给了解决的办法，把click事件绑定到ontouchstart事件上，这样就解决了300ms延迟的问题，这个文件是fastclick.js</p>
<h3 id="17-tcp三次握手"><a href="#17-tcp三次握手" class="headerlink" title="17.tcp三次握手"></a>17.tcp三次握手</h3><p>为了准确无误将数据送达目标处，TCP协议采取了三次握手协议。<br>用tcp协议将数据包送出去后，tcp不会对发送后的情况置之不理，它一定向对方确认是否收到。</p>
<ul>
<li>1.发送端首先发送带SYN标志的数据给对方。</li>
<li>2.接收方收到后回传一个SYN/ACK标志的数据包以示传达确认信息。</li>
<li>3.最后，发送端再回传一个带ACK标志的字段，代表握手结束</li>
</ul>
<p>若在握手过程中某个阶段被打断，TCP会再次以相同的顺序发送数据包。</p>
<h3 id="18-四次挥手"><a href="#18-四次挥手" class="headerlink" title="18.四次挥手"></a>18.四次挥手</h3><p>第一次：客户端请求断开FIN,seq=u<br>第二次：服务器确认客户端的断开请求ACK,ack=u+1,seq=v<br>第三次：服务器请求断开FIN,seq=w,ACK,ack=u+1<br>第四次：客户端确认服务器的断开ACK,ack=w+1,seq=u+1</p>
<h3 id="19-osi模型"><a href="#19-osi模型" class="headerlink" title="19.osi模型"></a>19.osi模型</h3><ul>
<li>应用层：提供应用程序间通道</li>
<li>表示层：处理数据格式、数据加密等</li>
<li>会话层：建立、维护和管理会话</li>
<li>传输层：建立主机端到端的连接</li>
<li>网络层：寻址和路由选择</li>
<li>数据链路层：提供介质访问，链路管理等</li>
<li>物理层：比特流传输</li>
</ul>
<h3 id="20-vue-minxins"><a href="#20-vue-minxins" class="headerlink" title="20.vue minxins"></a>20.vue minxins</h3><p>mixins定义：mixins选项接受一个混入对象的数组，类型：<code>Array&lt;Object&gt;</code></p>
<p>mixins原理：真正的实现是靠mergeOptions函数实现的。</p>
<p>这个函数传进去的两个参数分别是this.options 和 mixin，而mergeOptions函数则实现了递归遍历this.options，然后执行mergeField，返回最终合并的this.options<br>mergeField函数：一般我们执行mergeField 里的key基本上就是上面strats的属性了，用的最多的可能就是data、methods、props了，所以如果我们在mixins中用到了data，其本质上就是合并当前vue实例对象里的data和我们传进去的mixin里的data，其他属性也是一样的</p>
<p>合并策略：<br>1.data<br>mixins中的data会合并到实例中的data中，有冲突的话，实例中data的数据会覆盖mixins中的数据</p>
<p><img src="/ZJY.github.io/images/minxins1.png" alt="image"></p>
<p>2.钩子函数<br>mixins中和实例中的钩子函数，都会执行，先执行mixins中的钩子函数</p>
<p><img src="/ZJY.github.io/images/minxins2.png" alt="image"></p>
<p>3.methods、components、directives<br>methods、components、directives会执行，当有冲突的时候，实例中的会覆盖mixins中的</p>
<p><img src="/ZJY.github.io/images/minxins3.png" alt="image"></p>
<h3 id="21-git常用命令"><a href="#21-git常用命令" class="headerlink" title="21.git常用命令"></a>21.git常用命令</h3><p>创建仓库：<br>git init</p>
<p>提交代码相关：</p>
<ul>
<li>把当工作区文件加到暂存区<ul>
<li>单个文件加入：git add x.js</li>
<li>全部文件加入: git add .</li>
</ul>
</li>
<li>把暂存区的内容提交到本地仓库: git commit -m “xxx”</li>
<li>克隆一下远程仓库到本地:<br>git clone <a href="mailto:&#x67;&#x69;&#116;&#x40;&#103;&#105;&#x74;&#x68;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#109;">&#x67;&#x69;&#116;&#x40;&#103;&#105;&#x74;&#x68;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#109;</a>:michaelliao/gitskills.git<br>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。</li>
<li>添加一个远程仓库:git remote add origin <a href="mailto:&#x67;&#105;&#116;&#x40;&#x67;&#105;&#x74;&#104;&#x75;&#x62;&#x2e;&#99;&#x6f;&#x6d;">&#x67;&#105;&#116;&#x40;&#x67;&#105;&#x74;&#104;&#x75;&#x62;&#x2e;&#99;&#x6f;&#x6d;</a>:michaelliao/learngit.git</li>
<li>本地库的所有内容推送到远程库上:git push -u origin master</li>
<li>提交日志查看（详细）:git log</li>
<li>提交查看（简洁版）:git log –pretty=oneline</li>
<li>指定本地dev分支与远程origin/dev分支的链接:git branch –set-upstream-to=origin/dev dev</li>
</ul>
<p>版本回退:</p>
<ul>
<li>回到上一个版本:git reset –hard HEAD^</li>
<li>回到上倒数第3个版本:git reset –hard HEAD^^^</li>
<li>回到指定版本:git reset –hard 1094a</li>
</ul>
<p>撤销更改:<br>丢弃修改，这个文件回到最近一次git commit或git add时的状态。类似svn revert命令。<br>git checkout – readme.txt</p>
<p>删除本地分支 :git branch -d 本地分支名<br>删除远程分支:<br>git push origin –delete 分支名<br>git branch -r -d origin/branchName<br>git push origin :branchName</p>
<h3 id="22-vue中的虚拟dom"><a href="#22-vue中的虚拟dom" class="headerlink" title="22.vue中的虚拟dom"></a>22.vue中的虚拟dom</h3><p>1.什么是虚拟DOM<br>虚拟DOM 表现为一个 Object对象。并且最少包含标签名 (tag)、属性 (attrs) 和子元素对象 (children) 三个属性<br>创建虚拟DOM就是为了更好将虚拟的节点渲染到页面视图中，所以虚拟DOM对象的节点与真实DOM的属性一一照应</p>
<p>2.为什么需要虚拟DOM<br>DOM是很慢的，其元素非常庞大，页面的性能问题，大部分都是由DOM操作引起的</p>
<p>真实的DOM节点，哪怕一个最简单的div也包含着很多属性<br>操作DOM的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户的体验</p>
<p>3.Diff原理<br>diff算法就是进行虚拟节点对比，并返回一个patch对象，用来存储两个节点不同的地方，最后用patch记录的消息去局部更新Dom。通俗的讲就是：diff的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的DOM打补丁<br>通过diff算法比较 新 旧 两个VDOM，将不同的地方进行修改，相同的地方就地复用，最后再通过render函数渲染页面</p>
<h3 id="23-vue双向绑定原理"><a href="#23-vue双向绑定原理" class="headerlink" title="23.vue双向绑定原理"></a>23.vue双向绑定原理</h3><p>vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<h3 id="24-on-once-emit-off"><a href="#24-on-once-emit-off" class="headerlink" title="24.$on,$once,$emit,$off"></a>24.$on,$once,$emit,$off</h3><p>vm.$on( event, callback ):<br>监听当前实例上的自定义事件。事件可以由 vm.$emit 触发。回调函数会接收所有传入事件触发函数的额外参数</p>
<p>vm.$once( event, callback ):<br>监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除</p>
<p>vm.$off( [event, callback] ):<br>移除自定义事件监听器。</p>
<p>如果没有提供参数，则移除所有的事件监听器；</p>
<p>如果只提供了事件，则移除该事件所有的监听器；</p>
<p>如果同时提供了事件与回调，则只移除这个回调的监听器</p>
<p>vm.$emit( eventName, […args] ):<br>触发当前实例上的事件。附加参数都会传给监听器回调。</p>
<h3 id="25-vue的响应式原理，数组的变异检测"><a href="#25-vue的响应式原理，数组的变异检测" class="headerlink" title="25.vue的响应式原理，数组的变异检测"></a>25.vue的响应式原理，数组的变异检测</h3><p>当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。</p>
<p>这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更</p>
<p>每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。</p>
<p>检测变化的注意事项<br>由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。尽管如此我们还是有一些办法来回避这些限制并保证它们的响应性。</p>
<p>对于对象：<br>Vue 无法检测 property 的添加或移除。由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 data 对象上存在才能让 Vue 将它转换为响应式的</p>
<p>对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式 property</p>
<p>对于数组：<br>Vue 不能检测以下数组的变动：<br>当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue<br>当你修改数组的长度时，例如：vm.items.length = newLength</p>
<p>为了解决第一类问题，以下两种方式都可以实现和 vm.items[indexOfItem] = newValue 相同的效果，同时也将在响应式系统内触发状态更新：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line">Vue.set(vm.items, indexOfItem, newValue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.prototype.splice</span></span><br><span class="line">vm.items.splice(indexOfItem, <span class="number">1</span>, newValue)</span><br></pre></td></tr></table></figure>
<p>为了解决第二类问题，你可以使用 splice:vm.items.splice(indexOfItem, 1, newValue)</p>
<p>异步更新队列:</p>
<p>可能你还没有注意到，Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替</p>
<h3 id="26-vue-loader"><a href="#26-vue-loader" class="headerlink" title="26.vue-loader"></a>26.vue-loader</h3><p>vue-loader作用：<br>解析和转换.vue文件，提取出其中的逻辑代码script，样式代码style，以及html模版template，再分别把他们交给对应的loader去处理</p>
<p>用途：js可以写es6,style样式可以写scss或less</p>
<p>css-loader：加载由 vue-loader 提取出的 CSS 代码。<br>vue-template-compiler：把vue-loader提取出的HTML模板编译成可执行的jacascript代码</p>

  </div>
  <div>
      <!-- <a href="https://github.com/zhaojunyan9528/ZJY.github.io/tree/myblog/source/_posts/面试.md" target="_blank">编辑</a> -->
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/ZJY.github.io/">首页</a></li>
         
          <li><a href="/ZJY.github.io/archives/">归档</a></li>
         
          <li><a href="/ZJY.github.io/tags">标签</a></li>
         
          <li><a href="/ZJY.github.io/categories">分类</a></li>
         
          <li><a href="/ZJY.github.io/search/">搜索</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-webpack%E4%BC%98%E5%8C%96"><span class="toc-number">1.</span> <span class="toc-text">1.webpack优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-webpack%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%E7%8E%AF%E5%A2%83%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">2.webpack如何区分环境？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E8%B7%AF%E7%94%B1%E4%BB%A5%E5%8F%8AsetData%E5%8E%9F%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">3.小程序的生命周期和路由以及setData原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%93%AA%E4%BA%9Bcss%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">4.哪些css属性可以继承？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-call-apply-bind%E9%83%BD%E6%98%AF%E7%94%A8%E6%9D%A5%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89this%E5%AF%B9%E8%B1%A1%E7%9A%84"><span class="toc-number">5.</span> <span class="toc-text">5.call&#x2F;apply&#x2F;bind都是用来重新定义this对象的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-z-index%E5%B1%9E%E6%80%A7"><span class="toc-number">6.</span> <span class="toc-text">6.z-index属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">7.</span> <span class="toc-text">7.vue生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-JavaScript%E7%9A%84let%E5%92%8Cconst"><span class="toc-number">8.</span> <span class="toc-text">8.JavaScript的let和const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">9.</span> <span class="toc-text">9.箭头函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-vuex%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E6%95%B0%E6%8D%AE%E4%BF%9D%E6%8C%81%E4%B8%8D%E5%8F%98"><span class="toc-number">10.</span> <span class="toc-text">10.vuex页面刷新数据保持不变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%85%AC%E4%BC%97%E5%8F%B7openid%E5%92%8Cunionid%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">11.</span> <span class="toc-text">11.公众号openid和unionid的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-axios%E7%BB%9F%E4%B8%80%E5%B0%81%E8%A3%85"><span class="toc-number">12.</span> <span class="toc-text">12.axios统一封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E6%95%B0%E7%BB%84%E7%9A%84toString%E6%96%B9%E6%B3%95"><span class="toc-number">13.</span> <span class="toc-text">13.数组的toString方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E5%AF%B9%E8%B1%A1%E7%9A%84toString%E6%96%B9%E6%B3%95"><span class="toc-number">14.</span> <span class="toc-text">14.对象的toString方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E6%80%8E%E6%A0%B7%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%B8%8D%E6%98%AF%E6%95%B0%E7%BB%84%EF%BC%9F"><span class="toc-number">15.</span> <span class="toc-text">15.怎样判断一个对象是不是数组？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-js%E8%A7%A3%E5%86%B3%E8%8B%B9%E6%9E%9C%E7%A7%BB%E5%8A%A8%E7%AB%AF300ms%E5%BB%B6%E8%BF%9F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">16.</span> <span class="toc-text">16.js解决苹果移动端300ms延迟的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">17.</span> <span class="toc-text">17.tcp三次握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">18.</span> <span class="toc-text">18.四次挥手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-osi%E6%A8%A1%E5%9E%8B"><span class="toc-number">19.</span> <span class="toc-text">19.osi模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-vue-minxins"><span class="toc-number">20.</span> <span class="toc-text">20.vue minxins</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">21.</span> <span class="toc-text">21.git常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-vue%E4%B8%AD%E7%9A%84%E8%99%9A%E6%8B%9Fdom"><span class="toc-number">22.</span> <span class="toc-text">22.vue中的虚拟dom</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="toc-number">23.</span> <span class="toc-text">23.vue双向绑定原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-on-once-emit-off"><span class="toc-number">24.</span> <span class="toc-text">24.$on,$once,$emit,$off</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-vue%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%EF%BC%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%8F%98%E5%BC%82%E6%A3%80%E6%B5%8B"><span class="toc-number">25.</span> <span class="toc-text">25.vue的响应式原理，数组的变异检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-vue-loader"><span class="toc-number">26.</span> <span class="toc-text">26.vue-loader</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E9%9D%A2%E8%AF%95/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E9%9D%A2%E8%AF%95/&text=面试"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E9%9D%A2%E8%AF%95/&title=面试"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E9%9D%A2%E8%AF%95/&is_video=false&description=面试"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=面试&body=Check out this article: https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E9%9D%A2%E8%AF%95/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E9%9D%A2%E8%AF%95/&title=面试"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E9%9D%A2%E8%AF%95/&title=面试"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E9%9D%A2%E8%AF%95/&title=面试"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E9%9D%A2%E8%AF%95/&title=面试"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E9%9D%A2%E8%AF%95/&name=面试&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://zhaojunyan9528.github.io/ZJY.github.io/2021/01/20/%E9%9D%A2%E8%AF%95/&t=面试"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2020-2023
    ZJY
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/ZJY.github.io/">首页</a></li>
         
          <li><a href="/ZJY.github.io/archives/">归档</a></li>
         
          <li><a href="/ZJY.github.io/tags">标签</a></li>
         
          <li><a href="/ZJY.github.io/categories">分类</a></li>
         
          <li><a href="/ZJY.github.io/search/">搜索</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/ZJY.github.io/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/ZJY.github.io/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/ZJY.github.io/lib/jquery/jquery.min.js"></script>


<script src="/ZJY.github.io/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/ZJY.github.io/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>


<script src="/ZJY.github.io/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
