<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="TypeScript是一门专为开发大规模JavaScript应用程序而设计的编程语言，是JavaScript的超集，包含了JavaScript现有的全部功能，并且使用了与JavaScript相同的语法和语义。 TypeScript代码不能直接运行，它需要先被编译成JavaScript代码然后才能运行。Type-Script编译器（tsc）将负责把TypeScript代码编译为JavaScript代">
<meta property="og:type" content="article">
<meta property="og:title" content="TypeScript入门实战书籍笔记">
<meta property="og:url" content="https://zhaojunyan9528.github.io/ZJY.github.io/2022/09/15/typescript%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="ZJY">
<meta property="og:description" content="TypeScript是一门专为开发大规模JavaScript应用程序而设计的编程语言，是JavaScript的超集，包含了JavaScript现有的全部功能，并且使用了与JavaScript相同的语法和语义。 TypeScript代码不能直接运行，它需要先被编译成JavaScript代码然后才能运行。Type-Script编译器（tsc）将负责把TypeScript代码编译为JavaScript代">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-09-15T15:22:30.000Z">
<meta property="article:modified_time" content="2023-12-12T11:55:45.900Z">
<meta property="article:author" content="ZJY">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/ZJY.github.io/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/ZJY.github.io/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/ZJY.github.io/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>TypeScript入门实战书籍笔记</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/ZJY.github.io/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/ZJY.github.io/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/ZJY.github.io/">首页</a></li>
         
          <li><a href="/ZJY.github.io/archives/">归档</a></li>
         
          <li><a href="/ZJY.github.io/tags">标签</a></li>
         
          <li><a href="/ZJY.github.io/categories">分类</a></li>
         
          <li><a href="/ZJY.github.io/search/">搜索</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/ZJY.github.io/2022/09/29/%E5%85%B3%E4%BA%8Ehusky-lint-staged%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/ZJY.github.io/2022/07/14/css-%E7%AC%94%E8%AE%B0/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://zhaojunyan9528.github.io/ZJY.github.io/2022/09/15/typescript%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://zhaojunyan9528.github.io/ZJY.github.io/2022/09/15/typescript%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0/&text=TypeScript入门实战书籍笔记"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://zhaojunyan9528.github.io/ZJY.github.io/2022/09/15/typescript%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0/&title=TypeScript入门实战书籍笔记"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://zhaojunyan9528.github.io/ZJY.github.io/2022/09/15/typescript%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0/&is_video=false&description=TypeScript入门实战书籍笔记"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=TypeScript入门实战书籍笔记&body=Check out this article: https://zhaojunyan9528.github.io/ZJY.github.io/2022/09/15/typescript%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://zhaojunyan9528.github.io/ZJY.github.io/2022/09/15/typescript%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0/&title=TypeScript入门实战书籍笔记"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://zhaojunyan9528.github.io/ZJY.github.io/2022/09/15/typescript%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0/&title=TypeScript入门实战书籍笔记"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://zhaojunyan9528.github.io/ZJY.github.io/2022/09/15/typescript%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0/&title=TypeScript入门实战书籍笔记"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://zhaojunyan9528.github.io/ZJY.github.io/2022/09/15/typescript%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0/&title=TypeScript入门实战书籍笔记"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://zhaojunyan9528.github.io/ZJY.github.io/2022/09/15/typescript%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0/&name=TypeScript入门实战书籍笔记&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://zhaojunyan9528.github.io/ZJY.github.io/2022/09/15/typescript%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0/&t=TypeScript入门实战书籍笔记"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-TypeScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">第一章 TypeScript语言基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%B3%A8%E9%87%8A"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-Undefined"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.3.1 Undefined</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-Null"><span class="toc-number">1.3.2.</span> <span class="toc-text">1.3.2 Null</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3-Boolean"><span class="toc-number">1.3.3.</span> <span class="toc-text">1.3.3 Boolean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-4-String"><span class="toc-number">1.3.4.</span> <span class="toc-text">1.3.4 String</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-5-Number"><span class="toc-number">1.3.5.</span> <span class="toc-text">1.3.5 Number</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-6-Symbol"><span class="toc-number">1.3.6.</span> <span class="toc-text">1.3.6 Symbol</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-7-Object"><span class="toc-number">1.3.7.</span> <span class="toc-text">1.3.7 Object</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 字面量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-Null%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.4.1 Null字面量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2-Boolean%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">1.4.2.</span> <span class="toc-text">1.4.2 Boolean字面量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-3-Number%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">1.4.3.</span> <span class="toc-text">1.4.3 Number字面量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">1.4.4.</span> <span class="toc-text">1.4.4 字符串字面量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-5-%E6%A8%A1%E7%89%88%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">1.4.5.</span> <span class="toc-text">1.4.5 模版字面量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-1-%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.5.1 对象字面量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2-%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.5.2.</span> <span class="toc-text">1.5.2 原型对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E6%95%B0%E7%BB%84"><span class="toc-number">1.6.</span> <span class="toc-text">1.6 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-1-%E6%95%B0%E7%BB%84%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">1.6.1.</span> <span class="toc-text">1.6.1 数组字面量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-2-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0"><span class="toc-number">1.6.2.</span> <span class="toc-text">1.6.2 数组中元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.</span> <span class="toc-text">1.7 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-1-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">1.7.1.</span> <span class="toc-text">1.7.1 函数声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-2-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.7.2.</span> <span class="toc-text">1.7.2 函数表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-3-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.3.</span> <span class="toc-text">1.7.3 箭头函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-TypeScript%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6"><span class="toc-number">2.</span> <span class="toc-text">第二章 TypeScript语言进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-BigInt"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 BigInt</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E5%88%9B%E5%BB%BABigInt"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1 创建BigInt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-BigInt%E4%B8%8ENumber"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.2 BigInt与Number</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 展开运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E5%B1%95%E5%BC%80%E6%95%B0%E7%BB%84%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1 展开数组字面量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E5%B1%95%E5%BC%80%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2 展开对象字面量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E5%B1%95%E5%BC%80%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.2.3 展开函数参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E8%A7%A3%E6%9E%84"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 解构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1 数组解构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2 对象解构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%8F%AF%E9%80%89%E9%93%BE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 可选链运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-number">2.4.1.</span> <span class="toc-text">2.4.1 基础语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E7%9F%AD%E8%B7%AF%E6%B1%82%E5%80%BC"><span class="toc-number">2.4.2.</span> <span class="toc-text">2.4.2 短路求值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E7%A9%BA%E5%80%BC%E5%90%88%E5%B9%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 空值合并运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-TypeScript%E7%B1%BB%E5%9E%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">3.</span> <span class="toc-text">第三章 TypeScript类型基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 类型注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 类型检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 原始类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-boolean"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1 boolean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-string"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.3.2 string</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-number"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.3.3 number</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-4-bigint"><span class="toc-number">3.3.4.</span> <span class="toc-text">3.3.4 bigint</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-5-symbol%E4%B8%8Eunique-symbol"><span class="toc-number">3.3.5.</span> <span class="toc-text">3.3.5 symbol与unique symbol</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-6-Nullable"><span class="toc-number">3.3.6.</span> <span class="toc-text">3.3.6 Nullable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-7-void"><span class="toc-number">3.3.7.</span> <span class="toc-text">3.3.7 void</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 枚举类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-%E6%95%B0%E5%80%BC%E5%9E%8B%E6%9E%9A%E4%B8%BE"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.4.1 数值型枚举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9E%9A%E4%B8%BE"><span class="toc-number">3.4.2.</span> <span class="toc-text">3.4.2 字符串枚举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-3-%E5%BC%82%E6%9E%84%E5%9E%8B%E6%9E%9A%E4%B8%BE"><span class="toc-number">3.4.3.</span> <span class="toc-text">3.4.3 异构型枚举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-4-%E6%9E%9A%E4%B8%BE%E6%88%90%E5%91%98%E6%98%A0%E5%B0%84"><span class="toc-number">3.4.4.</span> <span class="toc-text">3.4.4 枚举成员映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-5-%E5%B8%B8%E9%87%8F%E6%9E%9A%E4%B8%BE%E6%88%90%E5%91%98%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9E%9A%E4%B8%BE%E6%88%90%E5%91%98"><span class="toc-number">3.4.5.</span> <span class="toc-text">3.4.5 常量枚举成员和计算枚举成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-6-%E8%81%94%E5%90%88%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.6.</span> <span class="toc-text">3.4.6 联合枚举类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-7-const%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.7.</span> <span class="toc-text">3.4.7 const枚举类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 字面量类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-1-boolean%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.1.</span> <span class="toc-text">3.5.1 boolean字面量类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-2-string%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.2.</span> <span class="toc-text">3.5.2 string字面量类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-3-%E6%95%B0%E5%AD%97%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.3.</span> <span class="toc-text">3.5.3 数字字面量类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-4-%E6%9E%9A%E4%B8%BE%E6%88%90%E5%91%98%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.4.</span> <span class="toc-text">3.5.4 枚举成员字面量类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E5%8D%95%E5%85%83%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.6.</span> <span class="toc-text">3.6 单元类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E9%A1%B6%E7%AB%AF%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.7.</span> <span class="toc-text">3.7 顶端类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-1-any"><span class="toc-number">3.7.1.</span> <span class="toc-text">3.7.1 any</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-2-unknown"><span class="toc-number">3.7.2.</span> <span class="toc-text">3.7.2 unknown</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-%E5%B0%BE%E7%AB%AF%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.8.</span> <span class="toc-text">3.8 尾端类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-1-never"><span class="toc-number">3.8.1.</span> <span class="toc-text">3.8.1 never</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.9.</span> <span class="toc-text">3.9 数组类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-1-%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-number">3.9.1.</span> <span class="toc-text">3.9.1 数组类型定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-2-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.9.2.</span> <span class="toc-text">3.9.2 数组元素类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-3-%E5%8F%AA%E8%AF%BB%E6%95%B0%E7%BB%84"><span class="toc-number">3.9.3.</span> <span class="toc-text">3.9.3 只读数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-10-%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.10.</span> <span class="toc-text">3.10 元组类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-10-1-%E5%85%83%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.10.1.</span> <span class="toc-text">3.10.1 元组的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-10-2-%E5%8F%AA%E8%AF%BB%E5%85%83%E7%BB%84"><span class="toc-number">3.10.2.</span> <span class="toc-text">3.10.2 只读元组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-10-3-%E8%AE%BF%E9%97%AE%E5%85%83%E7%BB%84%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">3.10.3.</span> <span class="toc-text">3.10.3　访问元组中的元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-10-4-%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%8F%AF%E9%80%89%E5%85%83%E7%B4%A0"><span class="toc-number">3.10.4.</span> <span class="toc-text">3.10.4 元组类型中的可选元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-10-5-%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%89%A9%E4%BD%99%E5%85%83%E7%B4%A0"><span class="toc-number">3.10.5.</span> <span class="toc-text">3.10.5　元组类型中的剩余元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-10-6-%E5%85%83%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-number">3.10.6.</span> <span class="toc-text">3.10.6　元组的长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-10-7-%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">3.10.7.</span> <span class="toc-text">3.10.7　元组类型与数组类型的兼容性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-11-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.11.</span> <span class="toc-text">3.11 对象类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-1-Object"><span class="toc-number">3.11.1.</span> <span class="toc-text">3.11.1 Object</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-2-object"><span class="toc-number">3.11.2.</span> <span class="toc-text">3.11.2 object</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-3-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">3.11.3.</span> <span class="toc-text">3.11.3 对象类型字面量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-4-%E5%BC%B1%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.11.4.</span> <span class="toc-text">3.11.4 弱类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-12-%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.12.</span> <span class="toc-text">3.12 函数类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-1-%E5%B8%B8%E8%A7%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.12.1.</span> <span class="toc-text">3.12.1 常规参数类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-2-%E5%8F%AF%E9%80%89%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.12.2.</span> <span class="toc-text">3.12.2 可选函数参数类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-3-%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.12.3.</span> <span class="toc-text">3.12.3 默认参数类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-4-%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.12.4.</span> <span class="toc-text">3.12.4 剩余参数类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-5-%E8%A7%A3%E6%9E%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.12.5.</span> <span class="toc-text">3.12.5 解构参数类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-6-%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.12.6.</span> <span class="toc-text">3.12.6　返回值类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-7-%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">3.12.7.</span> <span class="toc-text">3.12.7 函数类型字面量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-8-%E8%B0%83%E7%94%A8%E7%AD%BE%E5%90%8D"><span class="toc-number">3.12.8.</span> <span class="toc-text">3.12.8 调用签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-9-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">3.12.9.</span> <span class="toc-text">3.12.9 构造函数类型字面量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-10-%E6%9E%84%E9%80%A0%E7%AD%BE%E5%90%8D"><span class="toc-number">3.12.10.</span> <span class="toc-text">3.12.10 构造签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-11-%E8%B0%83%E7%94%A8%E7%AD%BE%E5%90%8D%E5%92%8C%E6%9E%84%E9%80%A0%E7%AD%BE%E5%90%8D"><span class="toc-number">3.12.11.</span> <span class="toc-text">3.12.11 调用签名和构造签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-12-%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0"><span class="toc-number">3.12.12.</span> <span class="toc-text">3.12.12 重载函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-13-%E5%87%BD%E6%95%B0%E4%B8%ADthis%E5%80%BC%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.12.13.</span> <span class="toc-text">3.12.13 函数中this值的类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-13-%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.13.</span> <span class="toc-text">3.13 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-13-1-%E6%8E%A5%E5%8F%A3%E5%A3%B0%E6%98%8E"><span class="toc-number">3.13.1.</span> <span class="toc-text">3.13.1 接口声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-13-2-%E5%B1%9E%E6%80%A7%E7%AD%BE%E5%90%8D"><span class="toc-number">3.13.2.</span> <span class="toc-text">3.13.2 属性签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-13-3-%E8%B0%83%E7%94%A8%E7%AD%BE%E5%90%8D"><span class="toc-number">3.13.3.</span> <span class="toc-text">3.13.3 调用签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-13-4-%E6%9E%84%E9%80%A0%E7%AD%BE%E5%90%8D"><span class="toc-number">3.13.4.</span> <span class="toc-text">3.13.4 构造签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-13-5-%E6%96%B9%E6%B3%95%E7%AD%BE%E5%90%8D"><span class="toc-number">3.13.5.</span> <span class="toc-text">3.13.5 方法签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-13-6-%E7%B4%A2%E5%BC%95%E7%AD%BE%E5%90%8D"><span class="toc-number">3.13.6.</span> <span class="toc-text">3.13.6 索引签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-13-7-%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">3.13.7.</span> <span class="toc-text">3.13.7 可选属性和方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-13-8-%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">3.13.8.</span> <span class="toc-text">3.13.8 只读属性和方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-13-9-%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">3.13.9.</span> <span class="toc-text">3.13.9 接口的继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-14-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">3.14.</span> <span class="toc-text">3.14 类型别名</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-14-1-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E5%A3%B0%E6%98%8E"><span class="toc-number">3.14.1.</span> <span class="toc-text">3.14.1 类型别名声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-14-2-%E9%80%92%E5%BD%92%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">3.14.2.</span> <span class="toc-text">3.14.2 递归的类型别名</span></a></li></ol></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        TypeScript入门实战书籍笔记
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">ZJY</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-09-15T15:22:30.000Z" itemprop="datePublished">2022-09-15</time>
        
        (Updated: <time datetime="2023-12-12T11:55:45.900Z" itemprop="dateModified">2023-12-12</time>)
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/ZJY.github.io/categories/%E7%AC%94%E8%AE%B0/">笔记</a> › <a class="category-link" href="/ZJY.github.io/categories/%E7%AC%94%E8%AE%B0/Javascript/">Javascript</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/ZJY.github.io/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>TypeScript是一门专为开发大规模JavaScript应用程序而设计的编程语言，是JavaScript的超集，包含了JavaScript现有的全部功能，并且使用了与JavaScript相同的语法和语义。</p>
<p>TypeScript代码不能直接运行，它需要先被编译成JavaScript代码然后才能运行。Type-Script编译器（tsc）将负责把TypeScript代码编译为JavaScript代码</p>
<h2 id="第一章-TypeScript语言基础"><a href="#第一章-TypeScript语言基础" class="headerlink" title="第一章 TypeScript语言基础"></a>第一章 TypeScript语言基础</h2><h3 id="1-1-变量"><a href="#1-1-变量" class="headerlink" title="1.1 变量"></a>1.1 变量</h3><p>可以用变量来存储和操作数据。当我们操作变量时，实际上操作的是变量对应的存储地址中的数据。</p>
<p>变量名也叫标识符，定义规则：</p>
<ol>
<li>允许包含字母、下划线、数字和美元符号”$”</li>
<li>允许包含unicode转义序列，如”\u0069\u{6F}”</li>
<li>仅允许使用字母、unicdoe转义序列，下划线，美元符号”$”作为第一个字符</li>
<li>标识符区分大小写</li>
<li>不允许使用保留字作为标识符</li>
</ol>
<p>变量声明：var, let, const   let和const声明变量具有块级作用域<br>块级作用域的概念包含了两部分，即块和作用域。变量的作用域指的是该变量的可访问区域，一个变量只能在其所处的作用域内被访问，在作用域外是不可见的。块级作用域中的块指的是“块语句”。块语句用于将零条或多条语句组织在一起。在语法上，块语句使用一对大括号“{}”来表示</p>
<h3 id="1-2-注释"><a href="#1-2-注释" class="headerlink" title="1.2 注释"></a>1.2 注释</h3><p>TypeScript支持三种类型的注释：</p>
<ol>
<li>单行注释</li>
<li>多行注释</li>
<li>区域注释</li>
</ol>
<p>单行注释：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// single line comment</span></span><br></pre></td></tr></table></figure>
<p>多行注释:</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * multi-line comment</span></span><br><span class="line"><span class="comment"> * multi-line comment</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>区域注释：区域注释不是一种新的注释语法，它借助单行注释的语法实现了定义代码折叠区域的功能</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span> <span class="comment">//#region 区域描述</span></span><br><span class="line"><span class="number">02</span> </span><br><span class="line"><span class="number">03</span> <span class="keyword">let</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="number">04</span> </span><br><span class="line"><span class="number">05</span> <span class="comment">//#endregion</span></span><br></pre></td></tr></table></figure>
<h3 id="1-3-数据类型"><a href="#1-3-数据类型" class="headerlink" title="1.3 数据类型"></a>1.3 数据类型</h3><p>在ECMAScript 2015规范中定义了如下七种数据类型：</p>
<ol>
<li>Undefined</li>
<li>Null</li>
<li>Boolean</li>
<li>Number</li>
<li>String</li>
<li>Symbol</li>
<li>Object</li>
</ol>
<p>其中，Undefined、Null、Boolean、String、Symbol和Number类型是原始数据类型，Object类型是非原始数据类型。原始数据类型是编程语言内置的基础数据类型，可用于构造复合类型。</p>
<h4 id="1-3-1-Undefined"><a href="#1-3-1-Undefined" class="headerlink" title="1.3.1 Undefined"></a>1.3.1 Undefined</h4><p>Undefined类型只包含一个值，即undefined。在变量未被初始化时，它的值为undefined。</p>
<h4 id="1-3-2-Null"><a href="#1-3-2-Null" class="headerlink" title="1.3.2 Null"></a>1.3.2 Null</h4><p>Null类型也只包含一个值，即null。我们通常使用null值来表示未初始化的对象。此外，null值也常被用在JSON文件中，表示一个值不存在。</p>
<h4 id="1-3-3-Boolean"><a href="#1-3-3-Boolean" class="headerlink" title="1.3.3 Boolean"></a>1.3.3 Boolean</h4><p>Boolean类型包含两个逻辑值，分别是true和false。</p>
<h4 id="1-3-4-String"><a href="#1-3-4-String" class="headerlink" title="1.3.4 String"></a>1.3.4 String</h4><p>String类型表示文本字符串，它由0个或多个字符构成.<br>Javascript使用utf-16编码来表示一个字符。utf-16编码以2个字节表示一个编码单元，每个字符使用一个编码单元或者两个编码单元来表示。在底层存储中，字符串是由零个或多个16位无符号整数构成的有序序列。<br>ECMAScript 2015规定了字符串允许的最大长度为2的53次方-1，该数值也是JavaScript所能安全表示的最大整数。</p>
<h4 id="1-3-5-Number"><a href="#1-3-5-Number" class="headerlink" title="1.3.5 Number"></a>1.3.5 Number</h4><p>Javascript不详细区分整数、浮点数以及带符号的数字类型。使用双精度的64位浮点数字格式（IEEE 754）来表示数字，因此数字本质上都是浮点数。在该格式中，符号占1位（bit），指数部分占11位，小数部分占52位，共64位。</p>
<h4 id="1-3-6-Symbol"><a href="#1-3-6-Symbol" class="headerlink" title="1.3.6 Symbol"></a>1.3.6 Symbol</h4><p>Symbol是ECMAScript 2015新引入的原始类型。<br>Symbol值有一个重要特征，每个Symbol值都是唯一且不可改变的。Symbol值的应用场景是作为对象的属性名。</p>
<p>JavaScript提供了一个全局的“Symbol()”函数来创建Symbol类型的值。我们可以将“Symbol()”函数想象成GUID（全局唯一标识符）的生成器，每次调用“Symbol()”函数都会生成一个完全不同的Symbol值。</p>
<h4 id="1-3-7-Object"><a href="#1-3-7-Object" class="headerlink" title="1.3.7 Object"></a>1.3.7 Object</h4><p>对象是属性的集合。对象属性使用键值来标识，键值只能为字符串或Symbol值，空字符串也是合法的键值。</p>
<h3 id="1-4-字面量"><a href="#1-4-字面量" class="headerlink" title="1.4 字面量"></a>1.4 字面量</h3><p>在计算机科学中，字面量用于在源代码中表示某个固定值。在JavaScript程序中，字面量不是变量，它是直接给出的固定值。</p>
<h4 id="1-4-1-Null字面量"><a href="#1-4-1-Null字面量" class="headerlink" title="1.4.1 Null字面量"></a>1.4.1 Null字面量</h4><p>Null字面量只有一个，记作null。</p>
<h4 id="1-4-2-Boolean字面量"><a href="#1-4-2-Boolean字面量" class="headerlink" title="1.4.2 Boolean字面量"></a>1.4.2 Boolean字面量</h4><p>Boolean字面量有两个，分别记作true和false。</p>
<h4 id="1-4-3-Number字面量"><a href="#1-4-3-Number字面量" class="headerlink" title="1.4.3 Number字面量"></a>1.4.3 Number字面量</h4><p>Number字面量包含4类：</p>
<ol>
<li>二进制整数字面量：以0b或者0B开头，只包含数字0或1</li>
<li>八进制整数字面量：以0o或者0O开头,只包含数字0到7</li>
<li>十进制数字字面量：一串数字组成，支持整数、小数、科学记数法</li>
<li>十六进制整数字面量：以0x或者0X开头,可以包含数字0至9、小写字母a至f以及大写字母A至F</li>
</ol>
<h4 id="1-4-4-字符串字面量"><a href="#1-4-4-字符串字面量" class="headerlink" title="1.4.4 字符串字面量"></a>1.4.4 字符串字面量</h4><p>字符串字面量是使用一对单引号或双引号包围起来的Unicode字符.<br>字符串字面量中可以包含Unicode转义序列和十六进制转义序列。</p>
<h4 id="1-4-5-模版字面量"><a href="#1-4-5-模版字面量" class="headerlink" title="1.4.5 模版字面量"></a>1.4.5 模版字面量</h4><p>模板字面量是ECMAScript 2015引入的新特性，它提供了一种语法糖来帮助构造字符串。<br>模板字符串的基本语法是使用反引号“`”替换了字符串字面量中的单、双引号</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> const template = `</span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>昵称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>多米<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>女<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">12 `;</span><br></pre></td></tr></table></figure>
<p>字符串占位符：“${}”</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const root = &#x27;https://www.bai.com&#x27;</span><br><span class="line">const url = `$&#123;root&#125;?a=1`</span><br></pre></td></tr></table></figure>
<h3 id="1-5-对象"><a href="#1-5-对象" class="headerlink" title="1.5 对象"></a>1.5 对象</h3><p>在JavaScript中，对象属于非原始类型。同时，对象也是一种复合数据类型，它由若干个对象属性构成。对象属性可以是任意数据类型，如数字、函数或者对象等。当对象属性为函数时，我们通常称之为方法。</p>
<h4 id="1-5-1-对象字面量"><a href="#1-5-1-对象字面量" class="headerlink" title="1.5.1 对象字面量"></a>1.5.1 对象字面量</h4><p>1.数据属性<br>数据属性由属性名和属性值组成：<br>{<br>  PropertyName: PropertyValue,<br>}</p>
<p>对象属性名可以为标识符、字符串字面量和数字字面量，对象属性值可以为任意值</p>
<p>2.存取器属性<br>一个存取器属性由一个或两个存取器方法组成，分别为get方法和set方法两种。<br>如果一个属性只定义了get方法而没有定义对应的set方法，那么该属性就成了只读属性。</p>
<h4 id="1-5-2-原型对象"><a href="#1-5-2-原型对象" class="headerlink" title="1.5.2 原型对象"></a>1.5.2 原型对象</h4><p>每个对象都有一个原型。对象的原型既可以是一个对象，即原型对象，也可以是null值。原型对象又有其自身的原型，对象的原型会形成一条原型链，原型链将终止于null值。<br>原型能够用来在不同对象之间共享属性和方法，JavaScript中的继承机制也是通过原型来实现的。<br>原型的作用主要体现在查询对象某个属性或方法时会沿着原型链依次向后搜索，如果直到原型链尽头null值也没有查询到对应属性，那么会返回undefined。</p>
<p>注：原型对象在属性查询和属性设置时起到的作用是不对等的。在查询对象属性时会考虑对象的原型，但是在设置对象属性时不会考虑对象的原型，而是直接修改对象本身的属性值。</p>
<h3 id="1-6-数组"><a href="#1-6-数组" class="headerlink" title="1.6 数组"></a>1.6 数组</h3><p>数组是一组有序元素的集合，它使用数字作为元素索引值。数组属于对象数据类型。</p>
<h4 id="1-6-1-数组字面量"><a href="#1-6-1-数组字面量" class="headerlink" title="1.6.1 数组字面量"></a>1.6.1 数组字面量</h4><p>数组字面量是常用的创建数组的方法。 const colors = [‘red’, ‘green’]</p>
<h4 id="1-6-2-数组中元素"><a href="#1-6-2-数组中元素" class="headerlink" title="1.6.2 数组中元素"></a>1.6.2 数组中元素</h4><p>数组中元素可以是数字，函数或对象，可以是任意类型的值。通过数字索引访问，从0开始，访问越界不会报错，返回undefined</p>
<h3 id="1-7-函数"><a href="#1-7-函数" class="headerlink" title="1.7 函数"></a>1.7 函数</h3><p>JavaScript中的函数是“头等函数”，它具有以下特性：</p>
<ol>
<li>函数可以赋值给变量或对象属性</li>
<li>函数可以作为函数的返回值</li>
<li>函数可以作为另一个函数的参数传递</li>
</ol>
<h4 id="1-7-1-函数声明"><a href="#1-7-1-函数声明" class="headerlink" title="1.7.1 函数声明"></a>1.7.1 函数声明</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">name</span>(<span class="params">param1,param2,...</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-7-2-函数表达式"><a href="#1-7-2-函数表达式" class="headerlink" title="1.7.2 函数表达式"></a>1.7.2 函数表达式</h4><p>函数表达式中的函数名是可选的。当没有指定函数名时，该函数也叫作匿名函数。</p>
<p>立即执行的函数表达式：在定义时就立即被调用的函数表达式</p>
<p>定义方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>
<p>包围函数表达式的()叫分组运算符，将函数置于分组运算符之内时，该函数即成了函数表达式。</p>
<p>立即执行的函数表达式两个特点：</p>
<ol>
<li>能够创建新的作用域，函数内部不会对外部产生影响，提供了一定数据封装性</li>
<li>立即执行的函数表达式自身不会对外部作用域产生任何影响，无法通过函数表达式来访问。</li>
</ol>
<h4 id="1-7-3-箭头函数"><a href="#1-7-3-箭头函数" class="headerlink" title="1.7.3 箭头函数"></a>1.7.3 箭头函数</h4><p>箭头函数是ECMAScript 2015中新增的特性，用来定义匿名的函数表达式。<br>箭头函数一定是匿名函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(params1, param2, ...) =&gt; &#123; <span class="comment">// body &#125;</span></span><br></pre></td></tr></table></figure>
<p>箭头函数没有this绑定，使用外层作用域的this绑定。</p>
<h2 id="第二章-TypeScript语言进阶"><a href="#第二章-TypeScript语言进阶" class="headerlink" title="第二章 TypeScript语言进阶"></a>第二章 TypeScript语言进阶</h2><h3 id="2-1-BigInt"><a href="#2-1-BigInt" class="headerlink" title="2.1 BigInt"></a>2.1 BigInt</h3><p>一个新的原始数据类型，属性数值类型的一种。<br>目前，JavaScript语言中共有以下七种原始数据类型：</p>
<ol>
<li>Undefined</li>
<li>Null</li>
<li>Boolean</li>
<li>String</li>
<li>Number</li>
<li>BigInt</li>
<li>Symbol</li>
</ol>
<p>BigInt能表示任意精度的整数，尤其是大于2的53次方-1的整数。</p>
<h4 id="2-1-1-创建BigInt"><a href="#2-1-1-创建BigInt" class="headerlink" title="2.1.1 创建BigInt"></a>2.1.1 创建BigInt</h4><ol>
<li>使用BigInt字面量</li>
<li>使用BigInt()函数</li>
</ol>
<p>BigInt字面量的语法是在一个整数后面添加一个小写字母“n”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unit = <span class="number">1n</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> unit1 = BigInt(<span class="number">1</span>) <span class="comment">// 1n</span></span><br></pre></td></tr></table></figure>
<h4 id="2-1-2-BigInt与Number"><a href="#2-1-2-BigInt与Number" class="headerlink" title="2.1.2 BigInt与Number"></a>2.1.2 BigInt与Number</h4><p>BigInt类型的值与Number类型的值可以进行相等关系比较，在进行严格相等比较时，两者用不相等。BigInt类型的值与Number类型的值不允许进行混合数学运算。<br>可以通过Number()函数将BigInt类型的值转换为Number类型的值，但是会损失精度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="number">1n</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-展开运算符"><a href="#2-2-展开运算符" class="headerlink" title="2.2 展开运算符"></a>2.2 展开运算符</h3><p>…expression</p>
<h4 id="2-2-1-展开数组字面量"><a href="#2-2-1-展开数组字面量" class="headerlink" title="2.2.1 展开数组字面量"></a>2.2.1 展开数组字面量</h4><p>数组字面量中的展开运算符可以应用在任何可迭代对象上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstHalfYearSeasons = [<span class="string">&#x27;Spring&#x27;</span>, <span class="string">&#x27;Summer&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> seasons = [...firstHalfYearSeasons, <span class="string">&#x27;Fall&#x27;</span>, <span class="string">&#x27;Winter&#x27;</span>];</span><br><span class="line">seasons; <span class="comment">// [&quot;Spring&quot;, &quot;Summer&quot;, &quot;Fall&quot;, &quot;Winter&quot;]</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-2-展开对象字面量"><a href="#2-2-2-展开对象字面量" class="headerlink" title="2.2.2 展开对象字面量"></a>2.2.2 展开对象字面量</h4><p>对象字面量的展开运算符会将操作数自身可枚举属性复制到当前对象字面量中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> point2d = &#123;</span><br><span class="line">  x: <span class="number">0</span>,</span><br><span class="line">  y: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> point3d = &#123;</span><br><span class="line">  ...point2d,</span><br><span class="line">  z: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">point3d <span class="comment">// &#123; x: 0, y: 0, z: 0 &#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-3-展开函数参数"><a href="#2-2-3-展开函数参数" class="headerlink" title="2.2.3 展开函数参数"></a>2.2.3 展开函数参数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> max = <span class="built_in">Math</span>.max(...nums);</span><br><span class="line">max;  <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-解构"><a href="#2-3-解构" class="headerlink" title="2.3 解构"></a>2.3 解构</h3><h4 id="2-3-1-数组解构"><a href="#2-3-1-数组解构" class="headerlink" title="2.3.1 数组解构"></a>2.3.1 数组解构</h4><p>赋值运算符右侧为需要解构的数组，赋值运算符左侧是解构赋值的目标，在解构赋值的同时也支持声明新的变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> point = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line"><span class="keyword">const</span> [x, y] = point</span><br><span class="line">x <span class="comment">// 0</span></span><br><span class="line">y <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h4 id="2-3-2-对象解构"><a href="#2-3-2-对象解构" class="headerlink" title="2.3.2 对象解构"></a>2.3.2 对象解构</h4><p>赋值运算符右侧为需要解构的对象，赋值运算符左侧是解构赋值的目标，在解构赋值的同时也支持声明新的变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> point = &#123;<span class="attr">x</span>:<span class="number">0</span>, <span class="attr">y</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;x, y&#125; = point</span><br><span class="line">x <span class="comment">// 0</span></span><br><span class="line">y <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="2-4-可选链运算符"><a href="#2-4-可选链运算符" class="headerlink" title="2.4 可选链运算符"></a>2.4 可选链运算符</h3><p>当尝试访问对象属性时，如果对象的值为undefined或null，那么属性访问将产生错误。为了提高程序的健壮性，在访问对象属性时通常需要检查对象是否已经初始化，只有当对象不为undefined和null时才去访问对象的属性。</p>
<h4 id="2-4-1-基础语法"><a href="#2-4-1-基础语法" class="headerlink" title="2.4.1 基础语法"></a>2.4.1 基础语法</h4><p>由”?.”组成，有以下三种语法：</p>
<ol>
<li>可选静态属性访问</li>
<li>可选计算属性访问</li>
<li>可选的函数调用或方法调用</li>
</ol>
<p>可选的静态属性访问：obj?.prop<br>如果obj的值为null或者undefined，那么表达式的求值结果为undefined，否则为obj.prop</p>
<p>可选计算属性访问: obj?.[expression]<br>如果obj的值为null或者undefined，那么表达式的求值结果为undefined，否则为obj.[expression]</p>
<p>可选的函数调用或方法调用: fn?.()<br>如果fn的值为null或者undefined，那么表达式的求值结果为undefined，否则为fn()</p>
<h4 id="2-4-2-短路求值"><a href="#2-4-2-短路求值" class="headerlink" title="2.4.2 短路求值"></a>2.4.2 短路求值</h4><p>如果可选链运算符左侧操作数的求值结果为undefined或null，那么右侧的操作数不会再被求值，我们将这种行为称作短路求值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a1 = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b1 = <span class="literal">undefined</span></span><br><span class="line">b1?.[++a1]</span><br><span class="line">a1 <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>二元逻辑运算符“&amp;&amp;”和“||”也具有短路求值的特性。</p>
<h3 id="2-5-空值合并运算符"><a href="#2-5-空值合并运算符" class="headerlink" title="2.5 空值合并运算符"></a>2.5 空值合并运算符</h3><p>语法：a ?? b</p>
<p>当且仅当”??”运算符左侧操作数a的值为undefined或null时，返回右侧操作数b；否则返回左侧操作数a</p>
<h2 id="第三章-TypeScript类型基础"><a href="#第三章-TypeScript类型基础" class="headerlink" title="第三章 TypeScript类型基础"></a>第三章 TypeScript类型基础</h2><h3 id="3-1-类型注解"><a href="#3-1-类型注解" class="headerlink" title="3.1 类型注解"></a>3.1 类型注解</h3><p>:Type</p>
<p>const greeting:string = ‘Hello’</p>
<p>TypeScript中的类型注解是可选的，编译器在大部分情况下都能够自动推断出表达式的类型</p>
<h3 id="3-2-类型检查"><a href="#3-2-类型检查" class="headerlink" title="3.2 类型检查"></a>3.2 类型检查</h3><p>类型检查是验证程序中类型约束是否正确的过程。<br>类型检查既可以在程序编译时进行，即静态类型检查；也可以在程序运行时进行，即动态类型检查。TypeScript支持静态类型检查，JavaScript支持动态类型检查。</p>
<p>TypeScript提供了两种静态类型检查模式：</p>
<ol>
<li><p>非严格类型检查（默认方式）。</p>
<p>非严格类型检查是TypeScript默认的类型检查模式。在该模式下，类型检查的规则相对宽松。例如，在非严格类型检查模式下不会对undefined值和null值做过多限制，允许将undefined值和null值赋值给string类型的变量。</p>
</li>
<li><p>严格类型检查</p>
</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;strict&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会尽可能地发现代码中的错误，例如，在严格类型检查模式下不允许将undefined值和null值赋值给string类型的变量。</p>
<h3 id="3-3-原始类型"><a href="#3-3-原始类型" class="headerlink" title="3.3 原始类型"></a>3.3 原始类型</h3><p>TypeScript中的原始类型包含以下几种：</p>
<ol>
<li>boolean</li>
<li>string</li>
<li>number</li>
<li>bigint</li>
<li>symbol</li>
<li>undefined</li>
<li>null</li>
<li>void</li>
<li>枚举类型</li>
<li>字面量类型</li>
</ol>
<h4 id="3-3-1-boolean"><a href="#3-3-1-boolean" class="headerlink" title="3.3.1 boolean"></a>3.3.1 boolean</h4><p>TypeScript中的boolean类型对应于JavaScript中的Boolean原始类型。该类型能够表示两个逻辑值：true和false。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> yes:<span class="built_in">boolean</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">const</span> no:<span class="built_in">boolean</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h4 id="3-3-2-string"><a href="#3-3-2-string" class="headerlink" title="3.3.2 string"></a>3.3.2 string</h4><p>TypeScript中的string类型对应于JavaScript中的String原始类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo:<span class="built_in">string</span> = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"><span class="keyword">const</span> bar:<span class="built_in">string</span> = <span class="string">`bar,<span class="subst">$&#123;foo&#125;</span>`</span></span><br></pre></td></tr></table></figure>
<h4 id="3-3-3-number"><a href="#3-3-3-number" class="headerlink" title="3.3.3 number"></a>3.3.3 number</h4><p>TypeScript中的number类型对应于JavaScript中的Number原始类型。该类型能够表示采用双精度64位二进制浮点数格式存储的数字。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二进制数</span></span><br><span class="line"><span class="keyword">const</span> bin:<span class="built_in">number</span> = <span class="number">0b1010</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 八进制数</span></span><br><span class="line"><span class="keyword">const</span> oct:<span class="built_in">number</span> = <span class="number">0o744</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 十进制数</span></span><br><span class="line"><span class="keyword">const</span> integer:<span class="built_in">number</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> float:<span class="built_in">number</span> = <span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 十六进制数</span></span><br><span class="line"><span class="keyword">const</span> hex:<span class="built_in">number</span> = <span class="number">0xffffff</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3-3-4-bigint"><a href="#3-3-4-bigint" class="headerlink" title="3.3.4 bigint"></a>3.3.4 bigint</h4><p>TypeScript中的bigint类型对应于JavaScript中的BigInt原始类型。该类型能够表示任意精度的整数，但也仅能表示整数</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二进制数</span></span><br><span class="line"><span class="keyword">const</span> bin:<span class="built_in">number</span> = <span class="number">0b1010n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 八进制数</span></span><br><span class="line"><span class="keyword">const</span> oct:<span class="built_in">number</span> = <span class="number">0o744n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 十进制数</span></span><br><span class="line"><span class="keyword">const</span> integer:<span class="built_in">number</span> = <span class="number">10n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 十六进制数</span></span><br><span class="line"><span class="keyword">const</span> hex:<span class="built_in">number</span> = <span class="number">0xffffffn</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3-3-5-symbol与unique-symbol"><a href="#3-3-5-symbol与unique-symbol" class="headerlink" title="3.3.5 symbol与unique symbol"></a>3.3.5 symbol与unique symbol</h4><p>TypeScript中的symbol类型对应于JavaScript中的Symbol原始类型。该类型能够表示任意的Symbol值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义Symbol</span></span><br><span class="line"><span class="keyword">const</span> key: symbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="comment">// Well-Known Symbol</span></span><br><span class="line"><span class="keyword">const</span> symbolHasInstance: symbol = <span class="built_in">Symbol</span>.hasInstance;</span><br></pre></td></tr></table></figure>
<p>字面量能够表示一个固定值。例如，数字字面量“3”表示固定数值“3”.<br>symbol类型不同于其他原始类型，它不存在字面量形式<br>symbol类型的值只能通过”Symbol()”和”Symbol.for()”来创建或者直接饮用某个well-known Symbol值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s0: symbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> s1: symbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> s2: symbol = <span class="built_in">Symbol</span>.hasInstance;</span><br><span class="line"><span class="keyword">const</span> s3: symbol = s0;</span><br><span class="line">s0 <span class="comment">// Symbol()</span></span><br><span class="line">s1 <span class="comment">// Symbol(foo)</span></span><br><span class="line">s2 <span class="comment">// Symbol(Symbol.hasInstance)</span></span><br><span class="line">s3 <span class="comment">// Symbol()</span></span><br></pre></td></tr></table></figure>
<p>为了能够将一个Symbol值视作表示固定值的字面量，TypeScript引入了“unique symbol”类型.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s0: unique symbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> s1: unique symbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;s1&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>“unique symbol”类型的主要用途是用作接口、类等类型中的可计算属性名.<br>因为如果使用可计算属性名在接口中添加了一个类型成员，那么必须保证该类型成员的名字是固定的，否则接口定义将失去意义。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s0: unique symbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> s1: symbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;s1&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s0,s1)</span><br><span class="line"><span class="keyword">interface</span> foo &#123;</span><br><span class="line">    [s0]: <span class="built_in">String</span>,</span><br><span class="line">    [s1]: <span class="built_in">String</span> <span class="comment">// A computed property name in an interface must refer to an expression whose type is a literal type or a &#x27;unique symbol&#x27; type. 计算属性名称必须引用类型为字面量类型或者&#x27;unique symbol&#x27;类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TypeScript中只允许使用const声明或readonly属性声明来定义“unique symbol”类型的值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须使用const声明</span></span><br><span class="line"><span class="keyword">const</span> a: unique symbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> WithUniqueSymbol &#123;</span><br><span class="line">    <span class="comment">// 必须使用readonly修饰符</span></span><br><span class="line">    <span class="keyword">readonly</span> b: unique symbol;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 必须使用static和readonly修饰符</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">readonly</span> c: unique symbol = <span class="built_in">Symbol</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用let或var声明定义“unique symbol”类型的变量，那么将产生错误，因为标识符与Symbol值之间的绑定是可变的</p>
<p>“unique symbol”类型的值只允许使用“Symbol()”函数或“Symbol.for()”方法的返回值进行初始化，因为只有这样才能够“确保”引用了唯一的Symbol值.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a: unique symbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> b: unique symbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;desc&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c: unique symbol = a;</span><br><span class="line"><span class="comment">// 错误：a的类型与c的类型不兼容</span></span><br></pre></td></tr></table></figure>
<p>使用相同的参数调用“Symbol.for()”方法实际上返回的是相同的Symbol值<br>因此，可能出现多个“unique symbol”类型的值实际上是同一个Symbol值的情况。由于设计上的局限性，TypeScript目前无法识别出这种情况.<br>在设计上，每一个“unique symbol”类型都是一种独立的类型。在不同的“unique symbol”类型之间不允许相互赋值；在比较两个“unique symbol”类型的值时，也将永远返回false.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> e: unique symbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;same&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> f: unique symbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;same&#x27;</span>); </span><br><span class="line"><span class="keyword">if</span>(e === f) &#123; </span><br><span class="line">  <span class="comment">// false</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;equal&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注：</span></span><br><span class="line"><span class="keyword">const</span> e: unique symbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;same&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> f: unique symbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line"><span class="comment">// 此时e和f相等，打印equal,但Symbol(&#x27;same&#x27;)和Symbol(&#x27;same&#x27;)；</span></span><br><span class="line"><span class="comment">// Symbol(&#x27;same&#x27;)和Symbol.for(&#x27;same&#x27;)不相等，不知道为啥，应该是都不相等的，但运行代码能打印equal</span></span><br></pre></td></tr></table></figure>
<p>“unique symbol”类型是symbol类型的子类型，可以将“unique symbol”类型赋值给symbol类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f: unique symbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> g:symbol = f</span><br></pre></td></tr></table></figure>
<h4 id="3-3-6-Nullable"><a href="#3-3-6-Nullable" class="headerlink" title="3.3.6 Nullable"></a>3.3.6 Nullable</h4><p>TypeScript中的Nullable类型指的是值可以为undefined或null的类型。</p>
<ol>
<li>undefined类型：只包含一个值，即undefined</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo:<span class="literal">undefined</span> = <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>null类型：只包含一个值，即null</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo:<span class="literal">null</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>strictNullChecks,即严格的null检查模式，同时作用于undefined类型和null类型检查<br>默认不启用该选项，在不启用时允许将undefined和null值赋值给string类型等其他类型，如下：</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * strictNullChecks:false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> m1:<span class="built_in">boolean</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> m2:<span class="built_in">string</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> m3:<span class="built_in">number</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> m4:bigint = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> m5:symbol = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> m6:<span class="literal">null</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> m7:<span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n1:<span class="built_in">boolean</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> n2:<span class="built_in">string</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> n3:<span class="built_in">number</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> n4:bigint = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> n5:symbol = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> n6:<span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> n7:<span class="literal">undefined</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure>
<p>当启用strictNullChecks编译选项时，undefined和null值不能再赋值给不相关的类型，undefined只能赋值给undefined，null值也只能赋值给null。<br>但是undefined值和null值允许赋值给顶端类型，同时undefined值也允许赋值给void类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> m1:<span class="built_in">void</span> = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> m2:<span class="built_in">any</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> m3:unknown = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n2:<span class="built_in">any</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> n3:unknown = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null和undefined是两个不同的类型</span></span><br><span class="line"><span class="keyword">let</span> foo:<span class="literal">undefined</span> = <span class="literal">null</span> <span class="comment">// 编译错误 null不能赋值给undefined</span></span><br><span class="line"><span class="keyword">let</span> bar:<span class="literal">null</span> = <span class="literal">undefined</span> <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure>
<h4 id="3-3-7-void"><a href="#3-3-7-void" class="headerlink" title="3.3.7 void"></a>3.3.7 void</h4><p>void类型表示某个值不存在，该类型用作函数的返回值类型。</p>
<p>除了将void类型作为函数返回值类型外，在其他地方使用void类型是无意义的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">message:<span class="built_in">string</span></span>):<span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启用strictNullChecks时只允许将undefined赋值给void</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * strictNullChecks:true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foos</span>(<span class="params"></span>):<span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params"></span>):<span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">//wrong: Type &#x27;null&#x27; is not assignable to type &#x27;void&#x27;.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * strictNullChecks:false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foos</span>(<span class="params"></span>):<span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params"></span>):<span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-枚举类型"><a href="#3-4-枚举类型" class="headerlink" title="3.4 枚举类型"></a>3.4 枚举类型</h3><p>枚举类型由0个或多个枚举成员构成，每个枚举成员都是命名的常量。<br>枚举类型是ts中的原始类型，由enum关键字定义。枚举类型分为：</p>
<ol>
<li>数值型枚举</li>
<li>字符串枚举</li>
<li>异构型枚举</li>
</ol>
<h4 id="3-4-1-数值型枚举"><a href="#3-4-1-数值型枚举" class="headerlink" title="3.4.1 数值型枚举"></a>3.4.1 数值型枚举</h4><p>由一组命名的数值常量构成,是nunber类型的子类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Direction &#123;</span><br><span class="line">  Up, <span class="comment">// 0</span></span><br><span class="line">  Right, <span class="comment">// 1</span></span><br><span class="line">  Down, <span class="comment">// 2</span></span><br><span class="line">  Left <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> direction: Direction = Direction.Up</span><br></pre></td></tr></table></figure>
<p>如果在定义枚举时没有设置枚举成员的值，那么TypeScript将自动计算枚举成员的值。根据TypeScript语言的规则，第一个枚举成员的值为0，其后每个枚举成员的值等于前一个枚举成员的值加1.</p>
<p>在定义数值型枚举时，可以为一个或多个枚举成员设置初始值。对于未指定初始值的枚举成员，其值为前一个枚举成员的值加1.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Direction &#123;</span><br><span class="line">  Up = <span class="number">1</span>, <span class="comment">// 1</span></span><br><span class="line">  Right, <span class="comment">// 2</span></span><br><span class="line">  Down = <span class="number">10</span>, <span class="comment">// 10</span></span><br><span class="line">  Left <span class="comment">// 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>枚举类型时number类型的子类型，所以可以将数值型枚举类型赋值给number类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num: <span class="built_in">number</span> = Direction.Up</span><br></pre></td></tr></table></figure>
<p>number类型的值也可以赋值给枚举类型，即使不在枚举类型枚举成员列表中也不会出错。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> d1: Direction = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> d2: Direction = <span class="number">100</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-2-字符串枚举"><a href="#3-4-2-字符串枚举" class="headerlink" title="3.4.2 字符串枚举"></a>3.4.2 字符串枚举</h4><p>字符串枚举类型成员必须由字符串字面量或另一个字符串枚举成员来初始化，不存在自增行为。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Direction &#123;</span><br><span class="line">  Up = <span class="string">&#x27;up&#x27;</span>,</span><br><span class="line">  Right = <span class="string">&#x27;right&#x27;</span>,</span><br><span class="line">  Down = <span class="string">&#x27;down&#x27;</span>,</span><br><span class="line">  Left = <span class="string">&#x27;left&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  U = Up,</span><br><span class="line">  R = Right,</span><br><span class="line">  D = Down,</span><br><span class="line">  L = Left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符串枚举类型是字符串的子类型，因此允许将字符串枚举类型赋值给string类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str: <span class="built_in">string</span> = Direction.Up</span><br></pre></td></tr></table></figure>
<p>但是反过来将string类型赋值给字符串枚举类型，将产生编译错误。</p>
<h4 id="3-4-3-异构型枚举"><a href="#3-4-3-异构型枚举" class="headerlink" title="3.4.3 异构型枚举"></a>3.4.3 异构型枚举</h4><p>TypeScript允许在一个枚举中同时定义数值型枚举成员和字符串枚举成员，我们将这种类型的枚举称作异构型枚举。不推荐使用</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Color &#123;</span><br><span class="line">  Black = <span class="number">0</span>,</span><br><span class="line">  White = <span class="string">&#x27;white&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在定义异构型枚举时，不允许使用计算的值作为枚举成员的初始值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Color &#123;</span><br><span class="line">  Black = <span class="number">0</span> + <span class="number">0</span>, <span class="comment">// 在具有字符串值成员的枚举中不允许计算值。</span></span><br><span class="line">  White = <span class="string">&#x27;white&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在异构型枚举中，必须为字符串枚举成员之后的数值型枚举成员定义初始值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> ColorA &#123;</span><br><span class="line">  Black,</span><br><span class="line">  White = <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">enum</span> ColorB &#123;</span><br><span class="line">  White = <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">  Black <span class="comment">// wrong: Enum member must have initializer.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-4-4-枚举成员映射"><a href="#3-4-4-枚举成员映射" class="headerlink" title="3.4.4 枚举成员映射"></a>3.4.4 枚举成员映射</h4><p>不论哪种类型枚举，都可以通过枚举成员名去访问枚举成员值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> ColorA &#123;</span><br><span class="line">    Black,</span><br><span class="line">    White = <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(ColorA.Black) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(ColorA.White) <span class="comment">// &#x27;1&#x27;</span></span><br></pre></td></tr></table></figure>
<p>对于数值型枚举，不仅可以通过枚举成员名访问枚举成员值，还可以通过枚举成员值去获取枚举成员名。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Bool &#123;</span><br><span class="line">    True = <span class="number">0</span>,</span><br><span class="line">    False = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Bool.True) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(Bool.False) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(Bool[Bool.True]) <span class="comment">// &#x27;True&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(Bool[Bool.False]) <span class="comment">// &#x27;False&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(Bool[<span class="number">0</span>]) <span class="comment">// &#x27;True&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(Bool[<span class="number">1</span>]) <span class="comment">// &#x27;False&#x27;</span></span><br></pre></td></tr></table></figure>
<p>对于字符串枚举和异构型枚举，则不能够通过枚举成员值去获取枚举成员名.</p>
<h4 id="3-4-5-常量枚举成员和计算枚举成员"><a href="#3-4-5-常量枚举成员和计算枚举成员" class="headerlink" title="3.4.5 常量枚举成员和计算枚举成员"></a>3.4.5 常量枚举成员和计算枚举成员</h4><p>每个枚举成员都有一个值，根据枚举成员值的定义可以将枚举成员划分为以下两类：</p>
<ol>
<li>常量枚举成员</li>
<li>计算枚举成员</li>
</ol>
<p>常量枚举表达式的具体规则如下：</p>
<p>  常量枚举表达式可以是数字字面量、字符串字面量和不包含替换值的模板字面量。<br>  常量枚举表达式可以是对前面定义的常量枚举成员的引用<br>  常量枚举表达式可以是用分组运算符包围起来的常量枚举表达式。<br>  常量枚举表达式中可以使用一元运算符“+”“-”“~”，操作数必须为常量枚举表达式<br>  常量枚举表达式中可以使用二元运算符“+”“-”“*”“**”“/”“%”“&lt;&lt;”“&gt;&gt;”“&gt;&gt;&gt;”“&amp;”“|”“^”，两个操作数必须为常量枚举表达式。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Foo &#123;</span><br><span class="line">  A = <span class="number">0</span>,</span><br><span class="line">  B = <span class="string">&#x27;B&#x27;</span>,</span><br><span class="line">  C = <span class="string">`C`</span>,</span><br><span class="line">  D = A,</span><br><span class="line"></span><br><span class="line">  E = -<span class="number">1</span>, <span class="comment">// 一元运算符</span></span><br><span class="line">  F = <span class="number">12</span> + <span class="number">3</span>, <span class="comment">// 二元运算符</span></span><br><span class="line">  G = (<span class="number">1</span>/<span class="number">1</span>) * <span class="number">3</span> <span class="comment">// 分组运算符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字面量枚举成员是常量枚举成员的子集，字面量枚举成员是指满足下列条件之一的枚举成员，具体条件如下：</p>
<p>  枚举成员没有定义初始值<br>  枚举成员的初始值为数字字面量、字符串字面量和不包含替换值的模板字面量。<br>  枚举成员的初始值为对其他字面量枚举成员的引用</p>
<p>除常量枚举成员之外的其他枚举成员都属于计算枚举成员。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Foo &#123;</span><br><span class="line">  A = <span class="string">&#x27;A&#x27;</span>.length,</span><br><span class="line">  B = <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-4-6-联合枚举类型"><a href="#3-4-6-联合枚举类型" class="headerlink" title="3.4.6 联合枚举类型"></a>3.4.6 联合枚举类型</h4><p>当枚举类型中的成员全是常量枚举成员时，该枚举类型成了联合枚举类型。</p>
<p>联合枚举类型中的枚举成员除了能表示一个常量外，还能够表示一种类型，即联合枚举成员类型。<br>联合枚举成员类型是联合枚举类型的子类型，因此可以将联合枚举成员类型赋值给联合枚举类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Direction &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Right,</span><br><span class="line">    Down,</span><br><span class="line">    Left</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> up: Direction.Up = Direction.Up</span><br><span class="line"><span class="built_in">console</span>.log(up) <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">const</span> dir: Direction = up</span><br><span class="line"><span class="built_in">console</span>.log(dir) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-7-const枚举类型"><a href="#3-4-7-const枚举类型" class="headerlink" title="3.4.7 const枚举类型"></a>3.4.7 const枚举类型</h4><p>枚举类型是ts对js的扩展，js本身并不支持枚举类型。在编译时，ts会将枚举类型编译为js对象。</p>
<p>const枚举类型将在编译阶段被完全删除，并且在使用了const枚举类型的地方将const枚举成员的值内联到代码中。</p>
<p>const枚举类型使用“const enum”关键字定义，示例如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">enum</span> Direction &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Right,</span><br><span class="line">    Down,</span><br><span class="line">    Left</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> directions = [</span><br><span class="line">    Direction.Up,</span><br><span class="line">    Direction.Right,</span><br><span class="line">    Direction.Down,</span><br><span class="line">    Direction.Left</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>编译后:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> directions = [</span><br><span class="line">  <span class="number">0</span> <span class="comment">/* Up */</span>,</span><br><span class="line">  <span class="number">1</span> <span class="comment">/* Right */</span>,</span><br><span class="line">  <span class="number">2</span> <span class="comment">/* Down */</span>,</span><br><span class="line">  <span class="number">3</span> <span class="comment">/* Left */</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h3 id="3-5-字面量类型"><a href="#3-5-字面量类型" class="headerlink" title="3.5 字面量类型"></a>3.5 字面量类型</h3><p>每一个字面量类型都只有一个可能的值，即字面量本身。</p>
<h4 id="3-5-1-boolean字面量类型"><a href="#3-5-1-boolean字面量类型" class="headerlink" title="3.5.1 boolean字面量类型"></a>3.5.1 boolean字面量类型</h4><ol>
<li>true字面量类型</li>
<li>false字面量类型</li>
</ol>
<p>原始类型boolean等同于由true字面量类型和false字面量类型构成的组合类型。<br>true字面量类型只能接受true值；同理，false字面量类型只能接受false值，示例如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a: <span class="literal">true</span> = <span class="literal">true</span></span><br><span class="line">cosnt b: <span class="literal">false</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>boolean字面量类型是boolean类型的子集，因此可以将boolean字面量类型赋值给boolean类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a: <span class="literal">true</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> b: <span class="literal">false</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> c: <span class="built_in">boolean</span>;</span><br><span class="line">c = a;</span><br><span class="line">c = b;</span><br></pre></td></tr></table></figure>
<h4 id="3-5-2-string字面量类型"><a href="#3-5-2-string字面量类型" class="headerlink" title="3.5.2 string字面量类型"></a>3.5.2 string字面量类型</h4><p>字符串字母量和模版字面量都可以创建字符串。字符串字面量和不带参数的模版字面量可以作为string字面量。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a: <span class="string">&#x27;hello&#x27;</span> = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">const</span> b: <span class="string">`world`</span> = <span class="string">`world`</span></span><br><span class="line"><span class="keyword">let</span> c: <span class="built_in">string</span></span><br><span class="line">c = a</span><br><span class="line">c = b</span><br></pre></td></tr></table></figure>
<p>string字面量类型是string类型的子类型，因此可以将string字面量类型赋值给string类型.</p>
<h4 id="3-5-3-数字字面量类型"><a href="#3-5-3-数字字面量类型" class="headerlink" title="3.5.3 数字字面量类型"></a>3.5.3 数字字面量类型</h4><p>number字面量<br>bigint字面量</p>
<p>所有的二进制、八进制、十进制、十六进制都可以作为数字字面量类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a0: <span class="number">0b1</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> b0: <span class="number">0o1</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> c0: <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> d0: <span class="number">0x1</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a1: <span class="number">0b1n</span> = <span class="number">1n</span></span><br><span class="line"><span class="keyword">const</span> b1: <span class="number">0o1n</span> = <span class="number">1n</span></span><br><span class="line"><span class="keyword">const</span> c1: <span class="number">1n</span> = <span class="number">1n</span></span><br><span class="line"><span class="keyword">const</span> d1: <span class="number">0x1n</span> = <span class="number">1n</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> e: -<span class="number">10</span> = -<span class="number">10</span> <span class="comment">// 正负数都可以当数字字面量</span></span><br><span class="line"><span class="keyword">const</span> f: -<span class="number">10n</span> = -<span class="number">10n</span></span><br></pre></td></tr></table></figure>
<p>number字面量类型和biginit字面量类型是number类型和bigint的子类型，所以可以进行赋值</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num: <span class="built_in">number</span> = a0</span><br><span class="line"><span class="keyword">const</span> num1: bigint = a1</span><br></pre></td></tr></table></figure>
<h4 id="3-5-4-枚举成员字面量类型"><a href="#3-5-4-枚举成员字面量类型" class="headerlink" title="3.5.4 枚举成员字面量类型"></a>3.5.4 枚举成员字面量类型</h4><p>联合枚举成员类型也可以将其称作枚举成员字面量类型，因为联合枚举成员类型使用枚举成员字面量形式表示。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">enum</span> Direction &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Right,</span><br><span class="line">    Down,</span><br><span class="line">    Left</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> up: Direction.Up = Direction.Up</span><br><span class="line"><span class="keyword">const</span> right: Direction.Right = Direction.Right</span><br></pre></td></tr></table></figure>
<h3 id="3-6-单元类型"><a href="#3-6-单元类型" class="headerlink" title="3.6 单元类型"></a>3.6 单元类型</h3><p>单元类型也叫单例类型，是指仅包含一个可能值的类型。<br>ts的单元类型有以下：</p>
<ol>
<li>undefined</li>
<li>null</li>
<li>unique symbol</li>
<li>void</li>
<li>联合枚举成员类型</li>
<li>字面量类型</li>
</ol>
<h3 id="3-7-顶端类型"><a href="#3-7-顶端类型" class="headerlink" title="3.7 顶端类型"></a>3.7 顶端类型</h3><p>顶端类型涵盖了类型系统中所有可能的值。<br>ts中有以下2种顶端类型：</p>
<ol>
<li>any</li>
<li>unknown</li>
</ol>
<h4 id="3-7-1-any"><a href="#3-7-1-any" class="headerlink" title="3.7.1 any"></a>3.7.1 any</h4><p>any类型使用any关键字作为标识。在ts中，所有类型都是any的子类型，所以可以将任何类型的值赋值给any，也可以将any类型的值赋值给任意类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">x = <span class="literal">true</span>; <span class="comment">// boolean</span></span><br><span class="line">x = <span class="string">&#x27;hi&#x27;</span>; <span class="comment">// string</span></span><br><span class="line">x = <span class="number">3.14</span>; <span class="comment">// number</span></span><br><span class="line">x = <span class="number">99999n</span>; <span class="comment">// bigint</span></span><br><span class="line">x = <span class="built_in">Symbol</span>(); <span class="comment">// Symbol</span></span><br><span class="line">x = <span class="literal">undefined</span>; <span class="comment">// undefined</span></span><br><span class="line">x = <span class="literal">null</span>; <span class="comment">// null</span></span><br><span class="line">x = &#123;&#125;;</span><br><span class="line">x = [];</span><br><span class="line">x = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: <span class="built_in">boolean</span>   = x;</span><br><span class="line"><span class="keyword">let</span> b: <span class="built_in">string</span>    = x;</span><br><span class="line"><span class="keyword">let</span> c: <span class="built_in">number</span>    = x;</span><br><span class="line"><span class="keyword">let</span> d: bigint    = x;</span><br><span class="line"><span class="keyword">let</span> e: symbol    = x;</span><br><span class="line"><span class="keyword">let</span> f: <span class="built_in">void</span>      = x;</span><br><span class="line"><span class="keyword">let</span> g: <span class="literal">undefined</span> = x;</span><br><span class="line"><span class="keyword">let</span> h: <span class="literal">null</span>      = x;</span><br></pre></td></tr></table></figure>
<p>使用any类型来跳过编译器的类型检查</p>
<p>ts中类型注解是可选的，若没有声明类型注解编译器又无法自动推断，那么这个值的默认类型为any类型<br>如果想避免这种情况，可以启用–noImplicitAny编译选项，当启用时，发生隐式的any类型转换,那么会产生编译错误.</p>
<h4 id="3-7-2-unknown"><a href="#3-7-2-unknown" class="headerlink" title="3.7.2 unknown"></a>3.7.2 unknown</h4><p>unknown类型使用unknown关键字作为标识.根据顶端类型的性质，任何其他类型都能够赋值给unknown类型，该行为与any类型是一致的.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: unknown;</span><br><span class="line"></span><br><span class="line">x = <span class="literal">true</span>; <span class="comment">// boolean</span></span><br><span class="line">x = <span class="string">&#x27;hi&#x27;</span>; <span class="comment">// string</span></span><br><span class="line">x = <span class="number">3.14</span>; <span class="comment">// number</span></span><br><span class="line">x = <span class="number">99999n</span>; <span class="comment">// bigint</span></span><br><span class="line">x = <span class="built_in">Symbol</span>(); <span class="comment">// Symbol</span></span><br><span class="line">x = <span class="literal">undefined</span>; <span class="comment">// undefined</span></span><br><span class="line">x = <span class="literal">null</span>; <span class="comment">// null</span></span><br><span class="line">x = &#123;&#125;;</span><br><span class="line">x = [];</span><br><span class="line">x = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>unknown类型比any类型安全，unknown类型只可以赋值给any类型和unknown类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: unknown</span><br><span class="line"></span><br><span class="line"><span class="comment">// right</span></span><br><span class="line"><span class="keyword">let</span> a1: unknown = x</span><br><span class="line"><span class="keyword">let</span> b1: <span class="built_in">any</span> = x</span><br><span class="line"><span class="comment">// wrong</span></span><br><span class="line"><span class="keyword">let</span> a: <span class="built_in">boolean</span>   = x;</span><br><span class="line"><span class="keyword">let</span> b: <span class="built_in">string</span>    = x;</span><br><span class="line"><span class="keyword">let</span> c: <span class="built_in">number</span>    = x;</span><br><span class="line"><span class="keyword">let</span> d: bigint    = x;</span><br><span class="line"><span class="keyword">let</span> e: symbol    = x;</span><br><span class="line"><span class="keyword">let</span> f: <span class="built_in">void</span>      = x;</span><br><span class="line"><span class="keyword">let</span> g: <span class="literal">undefined</span> = x;</span><br><span class="line"><span class="keyword">let</span> h: <span class="literal">null</span>      = x;</span><br></pre></td></tr></table></figure>
<p>在程序中使用unknown类型时，我们必须将其细化为某种具体类型，否则将产生编译错误.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">message: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> message.length; <span class="comment">// 无编译错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1(<span class="literal">undefined</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params">message: unknown</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> message.length; <span class="comment">// wrong : Cannot read properties of undefined (reading &#x27;length&#x27;) </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> message === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> message.length </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f2(<span class="literal">undefined</span>);</span><br></pre></td></tr></table></figure>
<p>  TypeScript中仅有any和unknown两种顶端类型。<br>  TypeScript中的所有类型都能够赋值给any类型和unknown类型，相当于两者都没有写入的限制。<br>  any类型能够赋值给任何其他类型，唯独不包括马上要介绍的never类型。<br>  unknown类型仅能够赋值给any类型和unknown类型。<br>  在使用unknown类型之前，必须将其细化为某种具体类型，而使用any类型时则没有任何限制。<br>  unknown类型相当于类型安全的any类型。这也是在有了any类型之后，TypeScript又引入unknown类型的根本原因。</p>
<h3 id="3-8-尾端类型"><a href="#3-8-尾端类型" class="headerlink" title="3.8 尾端类型"></a>3.8 尾端类型</h3><p>尾端类型是所有类型的子类型，也称作0类型或空类型。<br>ts中只存在一种尾端类型。即never</p>
<h4 id="3-8-1-never"><a href="#3-8-1-never" class="headerlink" title="3.8.1 never"></a>3.8.1 never</h4><p>never类型： </p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="built_in">never</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>never类型是其他类型的子类型，所以允许赋值给任何类型<br>never类型不是任何类型的子类型，除never类型自身外，其他类型的值都不能赋值给never类型。any类型也不可以赋值给never类型。</p>
<p>使用场景：</p>
<ol>
<li><p>never类型可以作为函数的返回值，表示该函数无法返回一个值。没有return语句的函数返回值类型是void，只有函数无法返回一个值的情况函数返回值才是never类型。比如函数抛出异常或者返回体内无限循环永不结束</p>
</li>
<li><p>在“条件类型”中常使用never类型来帮助完成一些类型运算</p>
</li>
<li><p>类型推断，在ts编译器执行类型推断操作时，如果发现无可用的类型那么推断结果为never类型</p>
</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">message: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> message === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    message <span class="comment">// string</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    message <span class="comment">// never</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-9-数组类型"><a href="#3-9-数组类型" class="headerlink" title="3.9 数组类型"></a>3.9 数组类型</h3><h4 id="3-9-1-数组类型定义"><a href="#3-9-1-数组类型定义" class="headerlink" title="3.9.1 数组类型定义"></a>3.9.1 数组类型定义</h4><ol>
<li>简便数组类型表示法</li>
<li>泛型数组类型表示法</li>
</ol>
<p>简便数组类型表示法：<br>TElement[]<br>TElement代表数组元素的类型，[]代表数组类型。例：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> digits: <span class="built_in">number</span>[] = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<p>如果数组中元素为复合类型，例既有number又有string，TElement需要用分组运算符()包裹</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> red: (<span class="built_in">number</span> | <span class="built_in">string</span>)[] = [<span class="string">&#x27;red&#x27;</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>泛型数组类型表示法:泛型数组类型表示法就是使用泛型来表示数组类型,语法：<br>Array<TElement> Array代表数组类型；“<TElement>”是类型参数的语法</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> digits1: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> red1: <span class="built_in">Array</span>&lt;<span class="built_in">number</span> | <span class="built_in">string</span>&gt; = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>, <span class="string">&#x27;red&#x27;</span>] <span class="comment">// 数组元素复合类型</span></span><br></pre></td></tr></table></figure>
<h4 id="3-9-2-数组元素类型"><a href="#3-9-2-数组元素类型" class="headerlink" title="3.9.2 数组元素类型"></a>3.9.2 数组元素类型</h4><p>在定义了数组类型之后，当访问数组元素时能够获得正确的元素类型信息。示例如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> digits1: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> zero: <span class="built_in">number</span> = digits1[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">const</span> zero1 = digits1[<span class="number">0</span>] <span class="comment">// zero1 为number</span></span><br><span class="line"><span class="keyword">const</span> out: <span class="built_in">number</span> = digits1[<span class="number">100</span>] <span class="comment">// 及时越界还是会得到声明的数组元素类型</span></span><br></pre></td></tr></table></figure>
<h4 id="3-9-3-只读数组"><a href="#3-9-3-只读数组" class="headerlink" title="3.9.3 只读数组"></a>3.9.3 只读数组</h4><p>只读数组与常规数组的区别在于，只读数组仅允许程序读取数组元素而不允许修改数组元素。</p>
<p>ts提供以下3种方式定义只读数组：</p>
<ol>
<li>使用ReadonlyArray<T>内置类型</li>
<li>使用readonly修饰符</li>
<li>使用Readonly<T>工具类型</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> red: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = [<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="keyword">const</span> green: <span class="keyword">readonly</span> <span class="built_in">number</span>[] = [<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>] <span class="comment">// readonly不允许和泛型数组表示法一起使用</span></span><br><span class="line"><span class="keyword">const</span> green1: <span class="keyword">readonly</span> <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>] <span class="comment">// wrong</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> blue: Readonly&lt;<span class="built_in">number</span>[]&gt; = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>] <span class="comment">// 类型参数T的值为数组类型“number[]”，而不是数组元素类型number</span></span><br></pre></td></tr></table></figure>
<p>注：在进行赋值操作时，允许将常规数组类型赋值给只读数组类型，但是不允许将只读数组类型赋值给常规数组类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> digits: <span class="built_in">number</span>[] = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">const</span> ra: <span class="keyword">readonly</span> <span class="built_in">number</span>[] = digits</span><br><span class="line"><span class="keyword">const</span> a: <span class="built_in">number</span>[] = arr <span class="comment">// wrong</span></span><br></pre></td></tr></table></figure>
<h3 id="3-10-元组类型"><a href="#3-10-元组类型" class="headerlink" title="3.10 元组类型"></a>3.10 元组类型</h3><p>元组表示有限元素构成的有序列表，js没有元组定义，ts中使用数组表示元组。<br>在ts中元组是数组的子类型，元组是长度固定的数组，并且数组中每个元素类型都是确定的。</p>
<h4 id="3-10-1-元组的定义"><a href="#3-10-1-元组的定义" class="headerlink" title="3.10.1 元组的定义"></a>3.10.1 元组的定义</h4><p>语法如下：<br>[T0, T1, …Tn]<br>该语法中的T0、T1和Tn表示元组中元素的类型，针对元组中每一个位置上的元素都需要定义其数据类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> point: [<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="keyword">const</span> score: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">&#x27;math&#x27;</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure>
<p>赋值时必须保持类型兼容和数量一致</p>
<h4 id="3-10-2-只读元组"><a href="#3-10-2-只读元组" class="headerlink" title="3.10.2 只读元组"></a>3.10.2 只读元组</h4><p>只读元组类型是只读数组类型的子类型。定义只读元组有以下两种方式：</p>
<ol>
<li>使用readonly修饰符</li>
<li>使用Readonly<T>工具类型</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> point: <span class="keyword">readonly</span> [<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="keyword">const</span> score: Readonly&lt;[<span class="built_in">string</span>, <span class="built_in">number</span>]&gt; = [<span class="string">&#x27;math&#x27;</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure>
<p>注：在给只读元组类型赋值时，允许将常规元组赋值给只读元组类型，不允许将只读元组赋值给常规元组类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> point: [<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> point1: <span class="keyword">readonly</span> [<span class="built_in">number</span>, <span class="built_in">number</span>] = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x: <span class="keyword">readonly</span> [<span class="built_in">number</span>, <span class="built_in">number</span>] = point</span><br><span class="line"><span class="keyword">const</span> y: [<span class="built_in">number</span>, <span class="built_in">number</span>] = point1 <span class="comment">// wrong</span></span><br></pre></td></tr></table></figure>
<h4 id="3-10-3-访问元组中的元素"><a href="#3-10-3-访问元组中的元素" class="headerlink" title="3.10.3　访问元组中的元素"></a>3.10.3　访问元组中的元素</h4><p>在访问元组中指定位置上的元素时，编译器能够推断出相应的元素类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> score: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">&#x27;math&#x27;</span>, <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = score[<span class="number">0</span>] <span class="comment">// string</span></span><br><span class="line"><span class="keyword">const</span> b = score[<span class="number">1</span>] <span class="comment">// number</span></span><br><span class="line"><span class="keyword">const</span> c: <span class="built_in">number</span> = score[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">const</span> d = score[<span class="number">2</span>] <span class="comment">// wrong 访问元组中不存在元素编译错误</span></span><br></pre></td></tr></table></figure>
<h4 id="3-10-4-元组类型中的可选元素"><a href="#3-10-4-元组类型中的可选元素" class="headerlink" title="3.10.4 元组类型中的可选元素"></a>3.10.4 元组类型中的可选元素</h4><p>定义元组可选元素的语法是在元素类型之后添加一个问号“?”，具体语法如下所示：<br>[T0?, T1?, …Tn?]<br>如果元组中同时存在可选元素和必选元素，那么可选元素必须位于必选元素之后，具体语法如下所示：<br>[T0, T1?, …, Tn?]</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tuple: [<span class="built_in">boolean</span>, <span class="built_in">string</span>?, <span class="built_in">number</span>?] = [<span class="literal">true</span>, <span class="string">&#x27;yes&#x27;</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">tuple = [<span class="literal">true</span>];</span><br><span class="line">tuple = [<span class="literal">true</span>, <span class="string">&#x27;yes&#x27;</span>];</span><br><span class="line">tuple = [<span class="literal">true</span>, <span class="string">&#x27;yes&#x27;</span>, <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<h4 id="3-10-5-元组类型中的剩余元素"><a href="#3-10-5-元组类型中的剩余元素" class="headerlink" title="3.10.5　元组类型中的剩余元素"></a>3.10.5　元组类型中的剩余元素</h4><p>语法：[…T[]]<br>T表示剩余元素的类型。</p>
<p>如果元组类型的定义中含有剩余元素，那么该元组的元素数量是开放的，它可以包含零个或多个指定类型的剩余元素。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tuple: [<span class="built_in">number</span>, ...string[]];</span><br><span class="line"></span><br><span class="line">tuple = [<span class="number">0</span>];</span><br><span class="line">tuple = [<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">tuple = [<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">tuple = [<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br></pre></td></tr></table></figure>
<h4 id="3-10-6-元组的长度"><a href="#3-10-6-元组的长度" class="headerlink" title="3.10.6　元组的长度"></a>3.10.6　元组的长度</h4><p>对于不包含可选元素和剩余元素的元组而言，元组中元素的数量是固定的。<br>TypeScript编译器能够识别出元组的长度并充分利用该信息来进行类型检查</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">point: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 编译器推断出length的类型为数字字面量类型2</span></span><br><span class="line">    <span class="keyword">const</span> length = point.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (length === <span class="number">3</span>) &#123;       <span class="comment">// 编译错误！条件表达式永远为 false</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于包含可选元素的元组，元组长度不固定，编译器能够根据元组可选元素识别出元组所有可能的长度，构造出一个联合类型来表示元组的长度</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tuple: [<span class="built_in">boolean</span>, <span class="built_in">string</span>?, <span class="built_in">number</span>?] = [<span class="literal">true</span>, <span class="string">&#x27;yes&#x27;</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> len = tuple.length <span class="comment">// 1|2|3</span></span><br><span class="line">len = <span class="number">1</span></span><br><span class="line">len = <span class="number">2</span></span><br><span class="line">len = <span class="number">3</span></span><br><span class="line">len = <span class="number">4</span> <span class="comment">//wrong: Type &#x27;4&#x27; is not assignable to type &#x27;1 | 2 | 3&#x27;.</span></span><br></pre></td></tr></table></figure>
<p>如果元组类型中定义了剩余元素，该元组length属性的类型将放宽为number类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tuple: [<span class="built_in">number</span>, ...string[]] = [<span class="number">0</span>, <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> len = tuple.length <span class="comment">// number</span></span><br></pre></td></tr></table></figure>
<h4 id="3-10-7-元组类型与数组类型的兼容性"><a href="#3-10-7-元组类型与数组类型的兼容性" class="headerlink" title="3.10.7　元组类型与数组类型的兼容性"></a>3.10.7　元组类型与数组类型的兼容性</h4><p>元组类型是数组类型的子类型，只读元组类型是只读数组类型的子类型,允许将元组类型赋值给类型兼容的元组类型和数组类型<br>元组类型允许赋值给常规数组类型和只读数组类型，但只读元组类型只允许赋值给只读数组类型<br>由于数组类型是元组类型的父类型，因此不允许将数组类型赋值给元组类型</p>
<h3 id="3-11-对象类型"><a href="#3-11-对象类型" class="headerlink" title="3.11 对象类型"></a>3.11 对象类型</h3><p>三种基本的对象类型：</p>
<p>  Object类型（首字母为大写字母O）<br>  object类型（首字母为小写字母o）<br>  对象类型字面量</p>
<h4 id="3-11-1-Object"><a href="#3-11-1-Object" class="headerlink" title="3.11.1 Object"></a>3.11.1 Object</h4><p>这里的Object是指Object类型而不是Object()构造函数。<br>Object.prototype是一个特殊的对象，是js中的公共原型对象。<br>Object类型是Object.prototype对象的类型。主要作用是描述js中几乎所有共享（通过原型继承）的属性和方法。</p>
<p>类型兼容性：除了undefined和null外其他类型都可以赋值给Object类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="built_in">Object</span></span><br><span class="line">x = <span class="literal">true</span></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">x = <span class="string">&#x27;str&#x27;</span></span><br><span class="line">x = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">x = <span class="literal">undefined</span> <span class="comment">// 编译错误：Type &#x27;undefined&#x27; is not assignable to type &#x27;Object&#x27;.</span></span><br><span class="line">x = <span class="literal">null</span> <span class="comment">// 编译错误： Type &#x27;null&#x27; is not assignable to type &#x27;Object&#x27;.</span></span><br></pre></td></tr></table></figure>
<p>Object类型描述了所有对象共享的属性和方法，而JavaScript允许在原始值上直接访问这些方法，因此TypeScript允许将原始值赋值给Object类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str: <span class="built_in">Object</span> = <span class="string">&#x27;str&#x27;</span></span><br><span class="line">str.valueOf()</span><br></pre></td></tr></table></figure>
<p>js存在自动封箱操作，当在原始值上调用某个方法时，js会对原始值进行封箱操作，并将其转化为对象类型，然后再调用相应的方法。</p>
<p>封箱（boxing）指将原始值包装成一个对象的过程，执行封箱操作后，就能像使用对象一样使用原始数据类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自动封箱，将&#x27;hi&#x27;转换为String对象类型</span></span><br><span class="line"><span class="string">&#x27;hi&#x27;</span>.toUpperCase();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动封箱，将3转换为Number对象类型</span></span><br><span class="line"><span class="comment">// 注意：这里使用了两个点符号</span></span><br><span class="line"><span class="number">3.</span>.toString()</span><br></pre></td></tr></table></figure>
<p>注：不要将Object类型应用于自定义变量，参数或属性等类型，因为Object类型是Object.prototype对象的类型，是所有对象共享的属性和方法。</p>
<h4 id="3-11-2-object"><a href="#3-11-2-object" class="headerlink" title="3.11.2 object"></a>3.11.2 object</h4><p>非原始类型。<br>在object类型中不允许读取和访问自定义属性，只允许访问对象的共享属性和方法，也就是Object类型中定义的属性和方法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj: <span class="built_in">object</span> = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;</span><br><span class="line">obj.x <span class="comment">// 编译错误 Property &#x27;x&#x27; does not exist on type &#x27;object&#x27;.</span></span><br><span class="line"></span><br><span class="line">obj.toString() <span class="comment">// right</span></span><br></pre></td></tr></table></figure>
<p>不允许将原始类型赋值给object类型，这和Object类型不一样，Object类型允许将原始类型赋值给它。<br>只要非原始类型也就是对象类型才能赋值给object类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nonPrimitive: <span class="built_in">object</span>;</span><br><span class="line"><span class="comment">// wrong</span></span><br><span class="line">nonPrimitive = <span class="number">1</span></span><br><span class="line">nonPrimitive = <span class="literal">true</span></span><br><span class="line">nonPrimitive = <span class="string">&#x27;str&#x27;</span></span><br><span class="line">nonPrimitive = <span class="literal">undefined</span></span><br><span class="line">nonPrimitive = <span class="literal">null</span></span><br><span class="line">nonPrimitive = <span class="built_in">Symbol</span>()</span><br><span class="line">nonPrimitive = <span class="number">1n</span></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">nonPrimitive = &#123;&#125;;</span><br><span class="line">nonPrimitive = &#123; <span class="attr">x</span>: <span class="number">0</span> &#125;;</span><br><span class="line">nonPrimitive = [<span class="number">0</span>];</span><br><span class="line">nonPrimitive = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">nonPrimitive = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>object类型仅能够赋值给3种类型：</p>
<ol>
<li>顶端类型any和unknown: 因为任何类型都是顶端类型的子类型</li>
<li>Object类型</li>
<li>空对象类型字面量{}</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nonPrimitive: <span class="built_in">object</span> = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a: <span class="built_in">any</span> = nonPrimitive;</span><br><span class="line"><span class="keyword">const</span> b: unknown = nonPrimitive;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj: <span class="built_in">Object</span> = nonPrimitive</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1: &#123;&#125; = nonPrimitive</span><br></pre></td></tr></table></figure>
<h4 id="3-11-3-对象类型字面量"><a href="#3-11-3-对象类型字面量" class="headerlink" title="3.11.3 对象类型字面量"></a>3.11.3 对象类型字面量</h4><p>对象类型字面量是定义对象类型的方法之一。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> point: &#123; <span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>&#125; = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>
<p>对象类型字面量的类型成员可分为以下五类：</p>
<ol>
<li>属性签名</li>
<li>调用签名</li>
<li>构造签名</li>
<li>方法签名</li>
<li>索引签名</li>
</ol>
<p>属性签名：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> point: &#123;<span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span> &#125; = &#123; <span class="attr">x</span>:<span class="number">0</span>, <span class="attr">y</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可计算属性签名</span></span><br><span class="line"><span class="keyword">const</span> a: <span class="string">&#x27;a&#x27;</span> = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">let</span> obj: &#123;</span><br><span class="line">  [a]: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可计算属性名的类型为“unique symbol”类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1: &#123; x; y&#125; <span class="comment">// 允许省略签名类型，该属性类型默认为any</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">&#123;</span><br><span class="line">  x: <span class="built_in">any</span>; <span class="comment">// noImplicitAny启用时，编译错误</span></span><br><span class="line">  y: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选属性</span></span><br><span class="line"><span class="keyword">let</span> point1: &#123; <span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>, z?: <span class="built_in">number</span>&#125;</span><br><span class="line">point = &#123;<span class="attr">x</span>:<span class="number">0</span>,<span class="attr">y</span>:<span class="number">1</span>&#125;</span><br><span class="line">point = &#123;<span class="attr">x</span>:<span class="number">0</span>,<span class="attr">y</span>:<span class="number">1</span>, z=<span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只允许访问已经定义的必选属性和可选属性</span></span><br><span class="line">point.x;</span><br><span class="line">point.y;</span><br><span class="line">point.z;</span><br><span class="line"></span><br><span class="line">point.t; <span class="comment">// wrong</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只读属性</span></span><br><span class="line"><span class="keyword">let</span> point2 : &#123;</span><br><span class="line">  <span class="keyword">readonly</span> x: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">readonly</span> y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line">point2 = &#123; <span class="attr">x</span>:<span class="number">0</span>, <span class="attr">y</span>:<span class="number">0</span>&#125;</span><br><span class="line"><span class="comment">// 只读属性的值在初始化后不允许再被修改</span></span><br><span class="line">point2.x = <span class="number">1</span> <span class="comment">// wrong</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不允许在空对象类型访问任何自定义属性</span></span><br><span class="line"><span class="keyword">const</span> point3: &#123;&#125; = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;;</span><br><span class="line"> </span><br><span class="line">point3.x;</span><br><span class="line"><span class="comment">//    ~</span></span><br><span class="line"><span class="comment">//    编译错误！属性 &#x27;x&#x27; 不存在于类型 &#x27;&#123;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">point3.y;</span><br><span class="line"><span class="comment">//    ~</span></span><br><span class="line"><span class="comment">//    编译错误！属性 &#x27;y&#x27; 不存在于类型 &#x27;&#123;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在空对象类型字面量&#123;&#125;上，允许访问对象公共的属性和方法，也就是Object类型上定义的方法和属性。</span></span><br><span class="line">point3.valueOf()</span><br></pre></td></tr></table></figure>
<h4 id="3-11-4-弱类型"><a href="#3-11-4-弱类型" class="headerlink" title="3.11.4 弱类型"></a>3.11.4 弱类型</h4><p>弱类型同时满足以下条件的对象类型：</p>
<ol>
<li>对象类型中至少包含一个属性。</li>
<li>对象类型中所有属性都是可选属性。</li>
<li>对象类型中不包含字符串索引签名、数值索引签名、调用签名和构造签名</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> config: &#123;</span><br><span class="line">  url?: <span class="built_in">string</span>,</span><br><span class="line">  <span class="keyword">async</span>?: <span class="built_in">boolean</span>,</span><br><span class="line">  timeout?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-12-函数类型"><a href="#3-12-函数类型" class="headerlink" title="3.12 函数类型"></a>3.12 函数类型</h3><h4 id="3-12-1-常规参数类型"><a href="#3-12-1-常规参数类型" class="headerlink" title="3.12.1 常规参数类型"></a>3.12.1 常规参数类型</h4><p>函数形参类型定义：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数表达式和匿名函数</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y <span class="comment">// 参数x 和 y没有定义类型，也无法推断类型，那么x和y隐式获得any类型，如果启用了noImplicitAny,那么会产生编译错误，可以指明为any类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-12-2-可选函数参数类型"><a href="#3-12-2-可选函数参数类型" class="headerlink" title="3.12.2 可选函数参数类型"></a>3.12.2 可选函数参数类型</h4><p>在调用函数时，编译器会检查传入实际参数的个数与函数定义中形式参数的个数是否相等。如果两者不相等，则会产生编译错误。如果一个参数是可选参数，那么就需要在函数类型定义中明确指定。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可选参数位于必选参数后面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y?: <span class="built_in">number</span>, z?: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + (y ?? <span class="number">0</span>) + (z ?? <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-12-3-默认参数类型"><a href="#3-12-3-默认参数类型" class="headerlink" title="3.12.3 默认参数类型"></a>3.12.3 默认参数类型</h4><p>如果定义了默认参数，并且默认参数在参数列表的末尾，那么该参数将被视为可选参数。例：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y <span class="comment">// y为可选参数，其类型被推断为number</span></span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>) <span class="comment">// 1</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">3</span>) <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span> = <span class="number">0</span>, y: <span class="built_in">number</span></span>) </span>&#123;&#125; <span class="comment">// 此时x不是可选参数，为必选参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x?: <span class="built_in">number</span> = <span class="number">0</span></span>) </span>&#123;&#125; <span class="comment">// 编译错误，同一个参数不能同时出现默认参数和可选参数</span></span><br></pre></td></tr></table></figure>
<h4 id="3-12-4-剩余参数类型"><a href="#3-12-4-剩余参数类型" class="headerlink" title="3.12.4 剩余参数类型"></a>3.12.4 剩余参数类型</h4><p>剩余参数类型处理的是多个参数，剩余参数类型应该为数组类型或者元组类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">...args: <span class="built_in">number</span>[]</span>) </span>&#123;&#125;</span><br><span class="line">f()</span><br><span class="line">f(<span class="number">1</span>)</span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元组类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">...args: [<span class="built_in">boolean</span>, <span class="built_in">number</span>]</span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">args_0: <span class="built_in">boolean</span>, args_1: <span class="built_in">number</span></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选元素的元组类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f0</span>(<span class="params">...args: [<span class="built_in">boolean</span>, <span class="built_in">string</span>?]</span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">args_0: <span class="built_in">boolean</span>, args_1?: <span class="built_in">string</span></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带有剩余元素的元组类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f0</span>(<span class="params">...args: [<span class="built_in">boolean</span>, ...<span class="built_in">string</span>[]]</span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">args_0: <span class="built_in">boolean</span>, ...args_1: <span class="built_in">string</span>[]</span>)</span></span><br></pre></td></tr></table></figure>
<h4 id="3-12-5-解构参数类型"><a href="#3-12-5-解构参数类型" class="headerlink" title="3.12.5 解构参数类型"></a>3.12.5 解构参数类型</h4><p>解构可以用在函数参数列表中。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f0</span>(<span class="params">[x,y]</span>) </span>&#123;&#125;</span><br><span class="line">f0([<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">&#123;x,y&#125;</span>) </span>&#123;&#125;</span><br><span class="line">f1(&#123;<span class="attr">x</span>:<span class="number">0</span>,<span class="attr">y</span>:<span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类型注解为解构参数添加类型信息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f0</span>(<span class="params">[x,y]: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) </span>&#123;&#125;</span><br><span class="line">f0([<span class="number">0</span>,<span class="number">0</span>])</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">&#123;x,y&#125;: &#123;x: <span class="built_in">number</span>, y: <span class="built_in">number</span>&#125;</span>) </span>&#123;&#125;</span><br><span class="line">f1(&#123;<span class="attr">x</span>:<span class="number">0</span>,<span class="attr">y</span>:<span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="3-12-6-返回值类型"><a href="#3-12-6-返回值类型" class="headerlink" title="3.12.6　返回值类型"></a>3.12.6　返回值类型</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f0</span>(<span class="params"></span>):<span class="title">void</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>):<span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span> <span class="comment">// right</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// wrong</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span> <span class="comment">// wrong</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span> <span class="comment">// wrong</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span> <span class="comment">// strictNullChecks= false void类型返回值可以返回null值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-12-7-函数类型字面量"><a href="#3-12-7-函数类型字面量" class="headerlink" title="3.12.7 函数类型字面量"></a>3.12.7 函数类型字面量</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> add: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f: <span class="function">(<span class="params"><span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"><span class="comment">//      ~~~~~~</span></span><br><span class="line"><span class="comment">//      编译错误 形参必须命名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 形参和实际参数名不必相同</span></span><br><span class="line"><span class="keyword">let</span> f: <span class="function">(<span class="params">x: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">f = <span class="function"><span class="keyword">function</span> (<span class="params">y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar: <span class="function">() =&gt;</span> ; <span class="comment">// 编译错误，必须指定函数返回值类型</span></span><br></pre></td></tr></table></figure>
<h4 id="3-12-8-调用签名"><a href="#3-12-8-调用签名" class="headerlink" title="3.12.8 调用签名"></a>3.12.8 调用签名</h4><p>函数是一个可调用的对象，可以用对象类型来表示函数类型。<br>若在对象类型中定义了调用签名类型成员，那么我们称该对象类型为调用签名类型。语法：<br>{<br>  (parameterList): Type<br>}<br>parameterList表示函数参数形式参数列表类型，Type表示返回值类型，两者都是可选的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add: &#123; <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> &#125;</span><br><span class="line">add = <span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数类型字母量完全等同于仅包含一个类型成员且是调用签名类型的对象类型字面量</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  (parameterList) : Type</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简写为：</span></span><br><span class="line">(parameterList) =&gt; Type</span><br><span class="line"><span class="comment">// 函数类型字面量</span></span><br><span class="line"><span class="keyword">const</span> abs0: <span class="function">(<span class="params">x: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="built_in">Math</span>.abs</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用签名</span></span><br><span class="line"><span class="keyword">const</span> abs1: &#123; (x: <span class="built_in">number</span>): <span class="built_in">number</span> &#125; = <span class="built_in">Math</span>.abs</span><br><span class="line"></span><br><span class="line">abs0(-<span class="number">1</span>) === abs1(-<span class="number">1</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="3-12-9-构造函数类型字面量"><a href="#3-12-9-构造函数类型字面量" class="headerlink" title="3.12.9 构造函数类型字面量"></a>3.12.9 构造函数类型字面量</h4><p>构造函数用来创建和初始化对象，比如js内置构造函数Date，const date = new Date()</p>
<p>构造函数类型字面量定义构造函数类型方法之一，语法如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> (parameterList) =&gt; Type</span><br></pre></td></tr></table></figure>
<p>new关键字，parameterList构造函数形式参数列表类型，Type是返回值类型<br>JavaScript提供了一个内置的Error构造函数，它接受一个可选的message作为参数并返回新创建的Error对象，示例如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="built_in">Error</span>()</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;error message&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用构造函数字面量来表示Error构造函数类型</span></span><br><span class="line"><span class="keyword">let</span> ErrorConsturctior: <span class="keyword">new</span> (message?: <span class="built_in">string</span>) =&gt; <span class="built_in">Error</span></span><br></pre></td></tr></table></figure>
<h4 id="3-12-10-构造签名"><a href="#3-12-10-构造签名" class="headerlink" title="3.12.10 构造签名"></a>3.12.10 构造签名</h4><p>构造签名与调用签名类似，若在对象类型中定义了构造签名类型成员，那么称该对象为构造签名类型，语法如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">new</span> (parameterList): Type </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>new是运算符关键字，ParameterList表示构造函数形式参数列表类型，Type表示构造函数返回值类型，两者都是可选的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Dog: &#123; <span class="keyword">new</span> (name: <span class="built_in">string</span>): <span class="built_in">Object</span> &#125;</span><br><span class="line">Dog = <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dog = <span class="keyword">new</span> Dog(<span class="string">&#x27;huahua&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>构造函数字面量完全等同于一个仅包含一个构造函数签名类型的成员的对象类型字面量。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">new</span> (parameterList): Type</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简写为：</span></span><br><span class="line"><span class="keyword">new</span> (parameterList) =&gt; Type</span><br></pre></td></tr></table></figure>
<h4 id="3-12-11-调用签名和构造签名"><a href="#3-12-11-调用签名和构造签名" class="headerlink" title="3.12.11 调用签名和构造签名"></a>3.12.11 调用签名和构造签名</h4><p>有一些函数被设计为既可以作为普通函数使用，同时又可以作为构造函数来使用</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a: <span class="built_in">number</span> = <span class="built_in">Number</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> b: <span class="built_in">Number</span> = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>在对象类型中同时定义调用签名和构造签名，既可以被调用，又可以作为构造函数：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">new</span> (x: <span class="built_in">number</span>): <span class="built_in">Number</span>; <span class="comment">// 构造签名</span></span><br><span class="line">  (x: <span class="built_in">number</span>): <span class="built_in">number</span> <span class="comment">// 调用签名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> F: &#123;</span><br><span class="line">  <span class="keyword">new</span> (x: <span class="built_in">number</span>): <span class="built_in">Number</span>; <span class="comment">// 构造签名</span></span><br><span class="line">  (x: <span class="built_in">number</span>): <span class="built_in">number</span> <span class="comment">// 调用签名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a: <span class="built_in">number</span> = F(<span class="number">1</span>) <span class="comment">// 普通函数调用</span></span><br><span class="line"><span class="keyword">const</span> b: <span class="built_in">Number</span> = <span class="keyword">new</span> F(<span class="number">1</span>) <span class="comment">// 构造函数调用</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3-12-12-重载函数"><a href="#3-12-12-重载函数" class="headerlink" title="3.12.12 重载函数"></a>3.12.12 重载函数</h4><p>重载函数是指一个函数同时拥有多个同类的函数签名，比如一个函数拥有2个及以上调用签名，一个构造函数同时拥有2个及以上构造签名。<br>函数重载定义组成：</p>
<ol>
<li>一条或多条函数重载语句</li>
<li>一条函数实现语句</li>
</ol>
<p>函数重载：不带有函数体的函数声明语句。只存在于代码编译阶段，生成js代码后会被删除</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span></span>; <span class="comment">// 函数重载</span></span><br></pre></td></tr></table></figure>
<p>函数重载允许存在一个或多个，只有多于1个的才有意义。函数重载不允许使用默认参数，函数重载位于函数体实现之前，必须和函数实现中的函数名一致。例如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">any</span>[], y: <span class="built_in">any</span>[]</span>): <span class="title">any</span>[]</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">any</span>[], y: <span class="built_in">number</span> | <span class="built_in">any</span>[]</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 实现代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数重载和函数重载，函数重载和函数体实现语句中间不允许出现别的语句，否则编译错误。</p>
<p>函数实现：包含了函数体代码，存在编译前和编译后，只允许有一个函数实现且位于所有函数重载之后。</p>
<p>函数实现必须兼容每个函数重载中的函数签名。函数实现的函数签名类型必须能够赋值给函数重载的函数签名类型。</p>
<h4 id="3-12-13-函数中this值的类型"><a href="#3-12-13-函数中this值的类型" class="headerlink" title="3.12.13 函数中this值的类型"></a>3.12.13 函数中this值的类型</h4><p>this是js中关键字，表示调用函数的对象或实例对象。<br>默认情况，编译器会将函数中的this值设为any类型，允许程序在this上执行任意的操作。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 以下语句均没有错误</span></span><br><span class="line">  <span class="built_in">this</span>.a = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">this</span>.b++;</span><br><span class="line">  <span class="built_in">this</span>.c = <span class="function">() =&gt;</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当启用了–noImplicitThis编译选项时，如果this值默认获得了any类型，那么将产生编译错误；如果函数体中没有引用this值，则没有任何影响.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 以下语句均没有错误</span></span><br><span class="line">  <span class="built_in">this</span>.a = <span class="literal">true</span>; <span class="comment">// &#x27;this&#x27; implicitly has type &#x27;any&#x27; because it does not have a type annotation.</span></span><br><span class="line">  <span class="built_in">this</span>.b++; <span class="comment">// wrong  this隐式地any类型，因为没有给this添加类型注解</span></span><br><span class="line">  <span class="built_in">this</span>.c = <span class="function">() =&gt;</span> &#123;&#125;; <span class="comment">// wrong</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ts支持在函数形式参数列表中定义this参数来描述this值的类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"><span class="built_in">this</span>: &#123;name: <span class="built_in">string</span>&#125;</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;str&#x27;</span></span><br><span class="line">    <span class="built_in">this</span>.name = <span class="number">0</span> <span class="comment">// wrong: Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>this参数固定使用this作为参数名，是可选参数，若存在必须在形式参数列表的第一位。this参数的类型即为函数体中this值的类型。<br>this参数不同于常规的函数形式参数，它只存在于编译阶段，在编译生成的JavaScript代码中会被完全删除，在运行时的代码中不存在这个this参数。</p>
<p>如果我们想要定义一个纯函数或者是不想让函数代码依赖于this的值，那么在这种情况下可以明确地将this参数定义为void类型。这样做之后，在函数体中就不允许读写this的属性和方法</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"><span class="built_in">this</span>: <span class="built_in">void</span></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;str&#x27;</span> <span class="comment">// wrong: Property &#x27;name&#x27; does not exist on type &#x27;void&#x27;.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当调用定义了this参数的函数时，若this值的实际类型与函数定义中的期望类型不匹配，则会产生编译错误</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"><span class="built_in">this</span>: &#123; baz: <span class="built_in">string</span>&#125;, bar: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">0</span>) <span class="comment">// wrong: The &#x27;this&#x27; context of type &#x27;void&#x27; is not assignable to method&#x27;s &#x27;this&#x27; of type &#x27;&#123; baz: string; &#125;&#x27;.</span></span><br><span class="line">foo(&#123;<span class="attr">baz</span>: <span class="string">&#x27;str&#x27;</span>&#125;, <span class="string">&#x27;str&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="3-13-接口"><a href="#3-13-接口" class="headerlink" title="3.13 接口"></a>3.13 接口</h3><p>接口也能表示对象类型，只在编译阶段存在，无法表示原始类型</p>
<h4 id="3-13-1-接口声明"><a href="#3-13-1-接口声明" class="headerlink" title="3.13.1 接口声明"></a>3.13.1 接口声明</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> InterfaceName &#123;</span><br><span class="line">  TypeMember,</span><br><span class="line">  TypeMember,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>interface关键字，InterfaceName接口名，它必须是合法的标识符通常首字母大写；TypeMember表示接口的类型成员。<br>接口类型的类型成员分为：</p>
<ol>
<li>属性签名</li>
<li>调用签名</li>
<li>构造签名</li>
<li>方法签名</li>
<li>索引签名</li>
</ol>
<h4 id="3-13-2-属性签名"><a href="#3-13-2-属性签名" class="headerlink" title="3.13.2 属性签名"></a>3.13.2 属性签名</h4><p>PropertyName: Type; PropertyName表示对象名称，可以为标识符、字符串、数字和可计算属性名；Type表示属性类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span>,</span><br><span class="line">  y: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-13-3-调用签名"><a href="#3-13-3-调用签名" class="headerlink" title="3.13.3 调用签名"></a>3.13.3 调用签名</h4><p>调用签名定义了该对象类型表示的函数在调用时的类型参数、参数列表和返回值类型。<br>(parameterList): Type<br>ParameterList表示函数形式参数列表类型；Type表示函数返回值类型，两者都是可选的</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ErrorConsturctior &#123;</span><br><span class="line">  (message?: <span class="built_in">string</span>): <span class="built_in">Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-13-4-构造签名"><a href="#3-13-4-构造签名" class="headerlink" title="3.13.4 构造签名"></a>3.13.4 构造签名</h4><p>构造签名定义了该对象类型表示的构造函数在使用new运算符调用时的参数列表和返回类型。</p>
<p>new (parameterList): Type</p>
<p>new是运算符关键字；ParameterList表示构造函数形式参数列表类型；Type表示构造函数返回值类型，两者都是可选的.</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ErrorConsturctior &#123;</span><br><span class="line">  <span class="keyword">new</span> (message?: <span class="built_in">string</span>): <span class="built_in">Error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-13-5-方法签名"><a href="#3-13-5-方法签名" class="headerlink" title="3.13.5 方法签名"></a>3.13.5 方法签名</h4><p>方法签名是声明函数类型的属性成员的简写。<br>PropertyName(parameterList): Type</p>
<p>PropertyName表示对象属性名，可以是标识符，数字，字符串，可计算的属性名；<br>parameterList为可选的方法形式参数列表类型；<br>Type为可选的方法返回值类型。<br>方法签名是在调用签名之前加属性名作为方法名。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Document &#123;</span><br><span class="line">  getElementById(elementId: <span class="built_in">string</span>): HTMLElement | <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-13-6-索引签名"><a href="#3-13-6-索引签名" class="headerlink" title="3.13.6 索引签名"></a>3.13.6 索引签名</h4><p>js支持使用索引去访问对象的属性，即通过方括号”[]”语法去访问对象属性。<br>索引签名有2种：</p>
<ol>
<li>字符串索引签名</li>
<li>数值索引签名</li>
</ol>
<p>字符串索引签名：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[indexName: <span class="built_in">string</span>]: Type</span><br></pre></td></tr></table></figure>
<p>indexName表示索引名，任意合法的标识符必须为string类型.索引名只起占位作用，不代表真实的对象属性名；<br>Type表示索引值的类型，可以为任意类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  [prop: <span class="built_in">number</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj: A = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line">obj[<span class="number">0</span>] <span class="comment">// string</span></span><br></pre></td></tr></table></figure>
<p>若接口中同时存在字符串索引和数字索引，那么数值索引的类型必须能够赋值给字符串索引的签名的类型，因为在js中属性名只能为字符串或Symbol。js也允许使用数字等其他值作为索引，但最终会被转换为字符串类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  [prop: <span class="built_in">string</span>]: <span class="built_in">number</span>,</span><br><span class="line">  [prop: <span class="built_in">number</span>]: <span class="number">0</span> | <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">  [prop: <span class="built_in">string</span>]: <span class="number">0</span> | <span class="number">1</span>,</span><br><span class="line">  [prop: <span class="built_in">number</span>]: <span class="built_in">number</span> <span class="comment">// 编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-13-7-可选属性和方法"><a href="#3-13-7-可选属性和方法" class="headerlink" title="3.13.7 可选属性和方法"></a>3.13.7 可选属性和方法</h4><p>默认情况下，接口中属性签名和方法签名定义的对象属性都是必选的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Foo &#123;</span><br><span class="line">    x: <span class="built_in">string</span>,</span><br><span class="line">    y(): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a: Foo = &#123; <span class="attr">x</span>: <span class="string">&#x27;hi&#x27;</span>&#125; <span class="comment">// wrong 缺少属性y</span></span><br><span class="line"><span class="keyword">const</span> b: Foo = &#123; <span class="function"><span class="title">y</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;&#125; <span class="comment">// wrong 缺少属性x</span></span><br><span class="line"><span class="keyword">const</span> c: Foo = &#123; <span class="comment">// right</span></span><br><span class="line">    x: <span class="string">&#x27;hi&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">y</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以在属性名或者方法名后面添加?表示可选</p>
<p>propertyName?: Type<br>propertyName?(parameterList): Type</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Foo &#123;</span><br><span class="line">    x?: <span class="built_in">string</span>,</span><br><span class="line">    y?(): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a: Foo = &#123; <span class="attr">x</span>: <span class="string">&#x27;hi&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> b: Foo = &#123; <span class="function"><span class="title">y</span>(<span class="params"></span>)</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;&#125;</span><br><span class="line"><span class="keyword">const</span> c: Foo = &#123;</span><br><span class="line">    x: <span class="string">&#x27;hi&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">y</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> d: Foo = &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如果接口中定义了重载方法，那么所有重载方法签名必须同时为必须或可选的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Foo &#123;</span><br><span class="line">    a(): <span class="built_in">void</span>,</span><br><span class="line">    a(x: <span class="built_in">string</span>): <span class="built_in">void</span>,</span><br><span class="line"></span><br><span class="line">    b?(): <span class="built_in">void</span>,</span><br><span class="line">    b?(x: <span class="built_in">string</span>): <span class="built_in">void</span></span><br><span class="line"></span><br><span class="line">    c(): <span class="built_in">void</span>,</span><br><span class="line">    c?(x: <span class="built_in">string</span>): <span class="built_in">void</span> <span class="comment">// wrong 重载方法签名必须同时为可选的或必选的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-13-8-只读属性和方法"><a href="#3-13-8-只读属性和方法" class="headerlink" title="3.13.8 只读属性和方法"></a>3.13.8 只读属性和方法</h4><p>在接口声明中，readonly修复符能够定义只读属性，readonly修饰符只允许在属性签名和索引签名中使用。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    <span class="keyword">readonly</span> a: <span class="built_in">string</span>,</span><br><span class="line">    <span class="keyword">readonly</span> [prop: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若接口中只定义了只读的索引签名，那么接口中所有属性都是只读的</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    <span class="keyword">readonly</span> [prop: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj: A = &#123; <span class="attr">x</span>: <span class="string">&#x27;a&#x27;</span> &#125;</span><br><span class="line">obj[x] = <span class="string">&#x27;b&#x27;</span> <span class="comment">// wrong 只读</span></span><br></pre></td></tr></table></figure>
<p>如果接口中既定义了只读索引签名，又定义了非只读的属性签名，那么非只读的属性签名定义的属性依旧是非只读的，除此之外的所有属性都是只读的</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    <span class="keyword">readonly</span> [prop: <span class="built_in">string</span>]: <span class="built_in">number</span>,</span><br><span class="line">    x: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj: A = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span>&#125;</span><br><span class="line">obj[<span class="string">&#x27;x&#x27;</span>] = <span class="number">2</span></span><br><span class="line">obj[<span class="string">&#x27;y&#x27;</span>] = <span class="number">2</span> <span class="comment">// wrong 只读</span></span><br></pre></td></tr></table></figure>
<h4 id="3-13-9-接口的继承"><a href="#3-13-9-接口的继承" class="headerlink" title="3.13.9 接口的继承"></a>3.13.9 接口的继承</h4><p>接口可以继承其他的对象类型，这相当于将对象类型中成员复制到当前接口中，可以继承的对象类型如下：</p>
<ol>
<li>接口</li>
<li>对象类型的类型别名</li>
<li>类</li>
<li>对象类型的交叉类型</li>
</ol>
<p>接口继承需要使用extends关键字。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Style &#123;</span><br><span class="line">    color: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Cricle <span class="keyword">extends</span> Shape, Style &#123;</span><br><span class="line">    radius: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c: Cricle = &#123;</span><br><span class="line">    name: <span class="string">&#x27;circle&#x27;</span>,</span><br><span class="line">    color: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">    radius: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果子接口与父接口之间存在同名的类型成员，那么子接口中的类型成员具有更高的优先级。同时，子接口与父接口中的同名类型成员必须是类型兼容的。也就是说，子接口中同名类型成员的类型需要能够赋值给父接口中同名类型成员的类型，否则将产生编译错误</p>
<p>如果仅是多个父接口之间存在同名的类型成员，而子接口本身没有该同名类型成员，那么父接口中同名类型成员的类型必须是完全相同的，否则将产生编译错误。解决方法是子接口中定义一个同名的类型成员，拥有更高的优先级，同时应兼容父接口的同名类型成员。</p>
<h3 id="3-14-类型别名"><a href="#3-14-类型别名" class="headerlink" title="3.14 类型别名"></a>3.14 类型别名</h3><h4 id="3-14-1-类型别名声明"><a href="#3-14-1-类型别名声明" class="headerlink" title="3.14.1 类型别名声明"></a>3.14.1 类型别名声明</h4><p>type AliasName = Type<br>在该语法中，type是声明类型别名的关键字；AliasName表示类型别名的名称；Type表示类型别名关联的具体类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point = &#123; <span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span> &#125;</span><br></pre></td></tr></table></figure>
<p>类型别名引用的类型可以为任意类型，例如原始类型、对象类型、联合类型和交叉类型等</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringType = <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> BooleanType = <span class="literal">true</span> | <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point = &#123; <span class="attr">x</span>: <span class="built_in">number</span>; y: <span class="built_in">number</span>; z?: <span class="built_in">number</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>在类型别名中，也可以引用其他类型别名</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Numeric = <span class="built_in">number</span> | bigint;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string | number | bigint</span></span><br><span class="line"><span class="keyword">type</span> StringOrNumber = <span class="built_in">string</span> | Numeric;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DecimalDigit = <span class="number">0</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span> | <span class="number">6</span> | <span class="number">7</span> | <span class="number">8</span> | <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> digit: DecimalDigit = <span class="number">6</span>; </span><br></pre></td></tr></table></figure>
<h4 id="3-14-2-递归的类型别名"><a href="#3-14-2-递归的类型别名" class="headerlink" title="3.14.2 递归的类型别名"></a>3.14.2 递归的类型别名</h4><p>一般情况下，在类型别名声明中赋值运算符的右侧不允许引用当前定义的类型别名。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T = T <span class="comment">// wrong</span></span><br></pre></td></tr></table></figure>
  </div>
  <div>
      <!-- <a href="https://github.com/zhaojunyan9528/ZJY.github.io/tree/myblog/source/_posts/typescript入门实战书籍笔记.md" target="_blank">编辑</a> -->
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/ZJY.github.io/">首页</a></li>
         
          <li><a href="/ZJY.github.io/archives/">归档</a></li>
         
          <li><a href="/ZJY.github.io/tags">标签</a></li>
         
          <li><a href="/ZJY.github.io/categories">分类</a></li>
         
          <li><a href="/ZJY.github.io/search/">搜索</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-TypeScript%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">第一章 TypeScript语言基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%B3%A8%E9%87%8A"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-Undefined"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.3.1 Undefined</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-Null"><span class="toc-number">1.3.2.</span> <span class="toc-text">1.3.2 Null</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3-Boolean"><span class="toc-number">1.3.3.</span> <span class="toc-text">1.3.3 Boolean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-4-String"><span class="toc-number">1.3.4.</span> <span class="toc-text">1.3.4 String</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-5-Number"><span class="toc-number">1.3.5.</span> <span class="toc-text">1.3.5 Number</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-6-Symbol"><span class="toc-number">1.3.6.</span> <span class="toc-text">1.3.6 Symbol</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-7-Object"><span class="toc-number">1.3.7.</span> <span class="toc-text">1.3.7 Object</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 字面量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-Null%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.4.1 Null字面量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2-Boolean%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">1.4.2.</span> <span class="toc-text">1.4.2 Boolean字面量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-3-Number%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">1.4.3.</span> <span class="toc-text">1.4.3 Number字面量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">1.4.4.</span> <span class="toc-text">1.4.4 字符串字面量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-5-%E6%A8%A1%E7%89%88%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">1.4.5.</span> <span class="toc-text">1.4.5 模版字面量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-1-%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.5.1 对象字面量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2-%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.5.2.</span> <span class="toc-text">1.5.2 原型对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E6%95%B0%E7%BB%84"><span class="toc-number">1.6.</span> <span class="toc-text">1.6 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-1-%E6%95%B0%E7%BB%84%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">1.6.1.</span> <span class="toc-text">1.6.1 数组字面量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-2-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0"><span class="toc-number">1.6.2.</span> <span class="toc-text">1.6.2 数组中元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.</span> <span class="toc-text">1.7 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-1-%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-number">1.7.1.</span> <span class="toc-text">1.7.1 函数声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-2-%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.7.2.</span> <span class="toc-text">1.7.2 函数表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-3-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.3.</span> <span class="toc-text">1.7.3 箭头函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-TypeScript%E8%AF%AD%E8%A8%80%E8%BF%9B%E9%98%B6"><span class="toc-number">2.</span> <span class="toc-text">第二章 TypeScript语言进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-BigInt"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 BigInt</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E5%88%9B%E5%BB%BABigInt"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1 创建BigInt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-BigInt%E4%B8%8ENumber"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.2 BigInt与Number</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 展开运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E5%B1%95%E5%BC%80%E6%95%B0%E7%BB%84%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1 展开数组字面量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E5%B1%95%E5%BC%80%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2 展开对象字面量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E5%B1%95%E5%BC%80%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.2.3 展开函数参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E8%A7%A3%E6%9E%84"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 解构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1 数组解构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2 对象解构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%8F%AF%E9%80%89%E9%93%BE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 可选链运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-number">2.4.1.</span> <span class="toc-text">2.4.1 基础语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E7%9F%AD%E8%B7%AF%E6%B1%82%E5%80%BC"><span class="toc-number">2.4.2.</span> <span class="toc-text">2.4.2 短路求值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E7%A9%BA%E5%80%BC%E5%90%88%E5%B9%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 空值合并运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-TypeScript%E7%B1%BB%E5%9E%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">3.</span> <span class="toc-text">第三章 TypeScript类型基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 类型注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 类型检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 原始类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-boolean"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1 boolean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-string"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.3.2 string</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-number"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.3.3 number</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-4-bigint"><span class="toc-number">3.3.4.</span> <span class="toc-text">3.3.4 bigint</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-5-symbol%E4%B8%8Eunique-symbol"><span class="toc-number">3.3.5.</span> <span class="toc-text">3.3.5 symbol与unique symbol</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-6-Nullable"><span class="toc-number">3.3.6.</span> <span class="toc-text">3.3.6 Nullable</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-7-void"><span class="toc-number">3.3.7.</span> <span class="toc-text">3.3.7 void</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 枚举类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-1-%E6%95%B0%E5%80%BC%E5%9E%8B%E6%9E%9A%E4%B8%BE"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.4.1 数值型枚举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9E%9A%E4%B8%BE"><span class="toc-number">3.4.2.</span> <span class="toc-text">3.4.2 字符串枚举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-3-%E5%BC%82%E6%9E%84%E5%9E%8B%E6%9E%9A%E4%B8%BE"><span class="toc-number">3.4.3.</span> <span class="toc-text">3.4.3 异构型枚举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-4-%E6%9E%9A%E4%B8%BE%E6%88%90%E5%91%98%E6%98%A0%E5%B0%84"><span class="toc-number">3.4.4.</span> <span class="toc-text">3.4.4 枚举成员映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-5-%E5%B8%B8%E9%87%8F%E6%9E%9A%E4%B8%BE%E6%88%90%E5%91%98%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9E%9A%E4%B8%BE%E6%88%90%E5%91%98"><span class="toc-number">3.4.5.</span> <span class="toc-text">3.4.5 常量枚举成员和计算枚举成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-6-%E8%81%94%E5%90%88%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.6.</span> <span class="toc-text">3.4.6 联合枚举类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-7-const%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.7.</span> <span class="toc-text">3.4.7 const枚举类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 字面量类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-1-boolean%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.1.</span> <span class="toc-text">3.5.1 boolean字面量类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-2-string%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.2.</span> <span class="toc-text">3.5.2 string字面量类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-3-%E6%95%B0%E5%AD%97%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.3.</span> <span class="toc-text">3.5.3 数字字面量类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-4-%E6%9E%9A%E4%B8%BE%E6%88%90%E5%91%98%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.4.</span> <span class="toc-text">3.5.4 枚举成员字面量类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E5%8D%95%E5%85%83%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.6.</span> <span class="toc-text">3.6 单元类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E9%A1%B6%E7%AB%AF%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.7.</span> <span class="toc-text">3.7 顶端类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-1-any"><span class="toc-number">3.7.1.</span> <span class="toc-text">3.7.1 any</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-2-unknown"><span class="toc-number">3.7.2.</span> <span class="toc-text">3.7.2 unknown</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-%E5%B0%BE%E7%AB%AF%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.8.</span> <span class="toc-text">3.8 尾端类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-1-never"><span class="toc-number">3.8.1.</span> <span class="toc-text">3.8.1 never</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.9.</span> <span class="toc-text">3.9 数组类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-1-%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-number">3.9.1.</span> <span class="toc-text">3.9.1 数组类型定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-2-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.9.2.</span> <span class="toc-text">3.9.2 数组元素类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-3-%E5%8F%AA%E8%AF%BB%E6%95%B0%E7%BB%84"><span class="toc-number">3.9.3.</span> <span class="toc-text">3.9.3 只读数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-10-%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.10.</span> <span class="toc-text">3.10 元组类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-10-1-%E5%85%83%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.10.1.</span> <span class="toc-text">3.10.1 元组的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-10-2-%E5%8F%AA%E8%AF%BB%E5%85%83%E7%BB%84"><span class="toc-number">3.10.2.</span> <span class="toc-text">3.10.2 只读元组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-10-3-%E8%AE%BF%E9%97%AE%E5%85%83%E7%BB%84%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">3.10.3.</span> <span class="toc-text">3.10.3　访问元组中的元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-10-4-%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%8F%AF%E9%80%89%E5%85%83%E7%B4%A0"><span class="toc-number">3.10.4.</span> <span class="toc-text">3.10.4 元组类型中的可选元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-10-5-%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%89%A9%E4%BD%99%E5%85%83%E7%B4%A0"><span class="toc-number">3.10.5.</span> <span class="toc-text">3.10.5　元组类型中的剩余元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-10-6-%E5%85%83%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-number">3.10.6.</span> <span class="toc-text">3.10.6　元组的长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-10-7-%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">3.10.7.</span> <span class="toc-text">3.10.7　元组类型与数组类型的兼容性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-11-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.11.</span> <span class="toc-text">3.11 对象类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-1-Object"><span class="toc-number">3.11.1.</span> <span class="toc-text">3.11.1 Object</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-2-object"><span class="toc-number">3.11.2.</span> <span class="toc-text">3.11.2 object</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-3-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">3.11.3.</span> <span class="toc-text">3.11.3 对象类型字面量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-4-%E5%BC%B1%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.11.4.</span> <span class="toc-text">3.11.4 弱类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-12-%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.12.</span> <span class="toc-text">3.12 函数类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-1-%E5%B8%B8%E8%A7%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.12.1.</span> <span class="toc-text">3.12.1 常规参数类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-2-%E5%8F%AF%E9%80%89%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.12.2.</span> <span class="toc-text">3.12.2 可选函数参数类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-3-%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.12.3.</span> <span class="toc-text">3.12.3 默认参数类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-4-%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.12.4.</span> <span class="toc-text">3.12.4 剩余参数类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-5-%E8%A7%A3%E6%9E%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.12.5.</span> <span class="toc-text">3.12.5 解构参数类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-6-%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.12.6.</span> <span class="toc-text">3.12.6　返回值类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-7-%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">3.12.7.</span> <span class="toc-text">3.12.7 函数类型字面量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-8-%E8%B0%83%E7%94%A8%E7%AD%BE%E5%90%8D"><span class="toc-number">3.12.8.</span> <span class="toc-text">3.12.8 调用签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-9-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">3.12.9.</span> <span class="toc-text">3.12.9 构造函数类型字面量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-10-%E6%9E%84%E9%80%A0%E7%AD%BE%E5%90%8D"><span class="toc-number">3.12.10.</span> <span class="toc-text">3.12.10 构造签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-11-%E8%B0%83%E7%94%A8%E7%AD%BE%E5%90%8D%E5%92%8C%E6%9E%84%E9%80%A0%E7%AD%BE%E5%90%8D"><span class="toc-number">3.12.11.</span> <span class="toc-text">3.12.11 调用签名和构造签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-12-%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0"><span class="toc-number">3.12.12.</span> <span class="toc-text">3.12.12 重载函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-12-13-%E5%87%BD%E6%95%B0%E4%B8%ADthis%E5%80%BC%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.12.13.</span> <span class="toc-text">3.12.13 函数中this值的类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-13-%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.13.</span> <span class="toc-text">3.13 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-13-1-%E6%8E%A5%E5%8F%A3%E5%A3%B0%E6%98%8E"><span class="toc-number">3.13.1.</span> <span class="toc-text">3.13.1 接口声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-13-2-%E5%B1%9E%E6%80%A7%E7%AD%BE%E5%90%8D"><span class="toc-number">3.13.2.</span> <span class="toc-text">3.13.2 属性签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-13-3-%E8%B0%83%E7%94%A8%E7%AD%BE%E5%90%8D"><span class="toc-number">3.13.3.</span> <span class="toc-text">3.13.3 调用签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-13-4-%E6%9E%84%E9%80%A0%E7%AD%BE%E5%90%8D"><span class="toc-number">3.13.4.</span> <span class="toc-text">3.13.4 构造签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-13-5-%E6%96%B9%E6%B3%95%E7%AD%BE%E5%90%8D"><span class="toc-number">3.13.5.</span> <span class="toc-text">3.13.5 方法签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-13-6-%E7%B4%A2%E5%BC%95%E7%AD%BE%E5%90%8D"><span class="toc-number">3.13.6.</span> <span class="toc-text">3.13.6 索引签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-13-7-%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">3.13.7.</span> <span class="toc-text">3.13.7 可选属性和方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-13-8-%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">3.13.8.</span> <span class="toc-text">3.13.8 只读属性和方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-13-9-%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">3.13.9.</span> <span class="toc-text">3.13.9 接口的继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-14-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">3.14.</span> <span class="toc-text">3.14 类型别名</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-14-1-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%E5%A3%B0%E6%98%8E"><span class="toc-number">3.14.1.</span> <span class="toc-text">3.14.1 类型别名声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-14-2-%E9%80%92%E5%BD%92%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">3.14.2.</span> <span class="toc-text">3.14.2 递归的类型别名</span></a></li></ol></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://zhaojunyan9528.github.io/ZJY.github.io/2022/09/15/typescript%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://zhaojunyan9528.github.io/ZJY.github.io/2022/09/15/typescript%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0/&text=TypeScript入门实战书籍笔记"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://zhaojunyan9528.github.io/ZJY.github.io/2022/09/15/typescript%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0/&title=TypeScript入门实战书籍笔记"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://zhaojunyan9528.github.io/ZJY.github.io/2022/09/15/typescript%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0/&is_video=false&description=TypeScript入门实战书籍笔记"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=TypeScript入门实战书籍笔记&body=Check out this article: https://zhaojunyan9528.github.io/ZJY.github.io/2022/09/15/typescript%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://zhaojunyan9528.github.io/ZJY.github.io/2022/09/15/typescript%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0/&title=TypeScript入门实战书籍笔记"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://zhaojunyan9528.github.io/ZJY.github.io/2022/09/15/typescript%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0/&title=TypeScript入门实战书籍笔记"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://zhaojunyan9528.github.io/ZJY.github.io/2022/09/15/typescript%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0/&title=TypeScript入门实战书籍笔记"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://zhaojunyan9528.github.io/ZJY.github.io/2022/09/15/typescript%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0/&title=TypeScript入门实战书籍笔记"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://zhaojunyan9528.github.io/ZJY.github.io/2022/09/15/typescript%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0/&name=TypeScript入门实战书籍笔记&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://zhaojunyan9528.github.io/ZJY.github.io/2022/09/15/typescript%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0/&t=TypeScript入门实战书籍笔记"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2020-2023
    ZJY
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/ZJY.github.io/">首页</a></li>
         
          <li><a href="/ZJY.github.io/archives/">归档</a></li>
         
          <li><a href="/ZJY.github.io/tags">标签</a></li>
         
          <li><a href="/ZJY.github.io/categories">分类</a></li>
         
          <li><a href="/ZJY.github.io/search/">搜索</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/ZJY.github.io/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/ZJY.github.io/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/ZJY.github.io/lib/jquery/jquery.min.js"></script>


<script src="/ZJY.github.io/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/ZJY.github.io/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>


<script src="/ZJY.github.io/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
